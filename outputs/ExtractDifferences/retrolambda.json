[
    {
        "commit_hash": "2c047b2d3e7cc2c9b76210011597e015dc24d9e7",
        "previous_commit_hash": null,
        "diff_stats": {
            "additions": 8,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,8 @@\n+*.txt           eol=lf\n+*.md            eol=lf\n+*.java          eol=lf\n+*.properties    eol=lf\n+*.rb            eol=lf\n+*.xml           eol=lf\n+*.html          eol=lf\n+*.iml           eol=lf\n"
    },
    {
        "commit_hash": "2c047b2d3e7cc2c9b76210011597e015dc24d9e7",
        "previous_commit_hash": null,
        "diff_stats": {
            "additions": 2,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,2 @@\n+/target/\n+/*/target/\n"
    },
    {
        "commit_hash": "11d160645e57ae70148f6e21b063aff6ea2447aa",
        "previous_commit_hash": "2c047b2d3e7cc2c9b76210011597e015dc24d9e7",
        "diff_stats": {
            "additions": 14,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,14 @@\n+\n+Retrolambda: Use Lambdas on Java 7\n+==================================\n+\n+Just as there was [Retroweaver](http://retroweaver.sourceforge.net/) et al.\n+for running Java 5 code with generics on Java 1.4, *Retrolambda* lets you\n+run Java 8 code with lambda expressions on Java 7. It does this by\n+transforming your Java 8 compiled bytecode so that it can be run on Java 7\n+runtime.\n+\n+This tool backports only lambda expressions - it doesn't let you use the\n+Java APIs that are new in Java 8.\n+\n+**WORK IN PROGRESS**\n"
    },
    {
        "commit_hash": "5f7dcdb4b023ac657eaf3e5d60c038057c4e9400",
        "previous_commit_hash": "11d160645e57ae70148f6e21b063aff6ea2447aa",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1 @@\n+/workspace.xml\n"
    },
    {
        "commit_hash": "5f7dcdb4b023ac657eaf3e5d60c038057c4e9400",
        "previous_commit_hash": "11d160645e57ae70148f6e21b063aff6ea2447aa",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1 @@\n+Retrolambda\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "5f7dcdb4b023ac657eaf3e5d60c038057c4e9400",
        "previous_commit_hash": "11d160645e57ae70148f6e21b063aff6ea2447aa",
        "diff_stats": {
            "additions": 18,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,18 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project version=\"4\">\n+  <component name=\"ProjectCodeStyleSettingsManager\">\n+    <option name=\"PER_PROJECT_SETTINGS\">\n+      <value>\n+        <XML>\n+          <option name=\"XML_LEGACY_SETTINGS_IMPORTED\" value=\"true\" />\n+        </XML>\n+        <codeStyleSettings language=\"JAVA\">\n+          <indentOptions>\n+            <option name=\"TAB_SIZE\" value=\"8\" />\n+          </indentOptions>\n+        </codeStyleSettings>\n+      </value>\n+    </option>\n+  </component>\n+</project>\n+\n"
    },
    {
        "commit_hash": "5f7dcdb4b023ac657eaf3e5d60c038057c4e9400",
        "previous_commit_hash": "11d160645e57ae70148f6e21b063aff6ea2447aa",
        "diff_stats": {
            "additions": 31,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,31 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project version=\"4\">\n+  <component name=\"CompilerConfiguration\">\n+    <option name=\"DEFAULT_COMPILER\" value=\"Javac\" />\n+    <resourceExtensions />\n+    <wildcardResourcePatterns>\n+      <entry name=\"!?*.class\" />\n+    </wildcardResourcePatterns>\n+    <annotationProcessing>\n+      <profile default=\"true\" name=\"Default\" enabled=\"false\">\n+        <processorPath useClasspath=\"true\" />\n+      </profile>\n+      <profile default=\"false\" name=\"Maven default annotation processors profile\" enabled=\"true\">\n+        <sourceOutputDir name=\"target/generated-sources/annotations\" />\n+        <sourceTestOutputDir name=\"target/generated-test-sources/test-annotations\" />\n+        <outputRelativeToContentRoot value=\"true\" />\n+        <processorPath useClasspath=\"true\" />\n+        <module name=\"end-to-end-tests\" />\n+        <module name=\"retrolambda\" />\n+        <module name=\"retrolambda-runtime (1)\" />\n+      </profile>\n+    </annotationProcessing>\n+    <bytecodeTargetLevel>\n+      <module name=\"end-to-end-tests\" target=\"1.8\" />\n+      <module name=\"parent\" target=\"1.8\" />\n+      <module name=\"project\" target=\"1.8\" />\n+      <module name=\"retrolambda\" target=\"1.8\" />\n+    </bytecodeTargetLevel>\n+  </component>\n+</project>\n+\n"
    },
    {
        "commit_hash": "5f7dcdb4b023ac657eaf3e5d60c038057c4e9400",
        "previous_commit_hash": "11d160645e57ae70148f6e21b063aff6ea2447aa",
        "diff_stats": {
            "additions": 9,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,9 @@\n+<component name=\"CopyrightManager\">\n+  <copyright>\n+    <option name=\"notice\" value=\"Copyright \u00a9 &amp;#36;today.year Esko Luontola &lt;www.orfjackal.net&gt;&#10;This software is released under the Apache License 2.0.&#10;The license text is at http://www.apache.org/licenses/LICENSE-2.0\" />\n+    <option name=\"keyword\" value=\"Copyright\" />\n+    <option name=\"allowReplaceKeyword\" value=\"\" />\n+    <option name=\"myName\" value=\"Apache 2.0\" />\n+    <option name=\"myLocal\" value=\"true\" />\n+  </copyright>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "5f7dcdb4b023ac657eaf3e5d60c038057c4e9400",
        "previous_commit_hash": "11d160645e57ae70148f6e21b063aff6ea2447aa",
        "diff_stats": {
            "additions": 30,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,30 @@\n+<component name=\"CopyrightManager\">\n+  <settings default=\"Apache 2.0\">\n+    <module2copyright />\n+    <LanguageOptions name=\"CSS\">\n+      <option name=\"fileTypeOverride\" value=\"1\" />\n+    </LanguageOptions>\n+    <LanguageOptions name=\"HTML\">\n+      <option name=\"fileTypeOverride\" value=\"1\" />\n+      <option name=\"prefixLines\" value=\"false\" />\n+    </LanguageOptions>\n+    <LanguageOptions name=\"JSP\">\n+      <option name=\"fileTypeOverride\" value=\"1\" />\n+      <option name=\"prefixLines\" value=\"false\" />\n+    </LanguageOptions>\n+    <LanguageOptions name=\"JSPX\">\n+      <option name=\"fileTypeOverride\" value=\"1\" />\n+      <option name=\"prefixLines\" value=\"false\" />\n+    </LanguageOptions>\n+    <LanguageOptions name=\"Properties\">\n+      <option name=\"fileTypeOverride\" value=\"1\" />\n+    </LanguageOptions>\n+    <LanguageOptions name=\"XML\">\n+      <option name=\"fileTypeOverride\" value=\"1\" />\n+      <option name=\"prefixLines\" value=\"false\" />\n+    </LanguageOptions>\n+    <LanguageOptions name=\"__TEMPLATE__\">\n+      <option name=\"block\" value=\"false\" />\n+    </LanguageOptions>\n+  </settings>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "5f7dcdb4b023ac657eaf3e5d60c038057c4e9400",
        "previous_commit_hash": "11d160645e57ae70148f6e21b063aff6ea2447aa",
        "diff_stats": {
            "additions": 3,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,3 @@\n+<component name=\"ProjectDictionaryState\">\n+  <dictionary name=\"ORFJackal\" />\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "5f7dcdb4b023ac657eaf3e5d60c038057c4e9400",
        "previous_commit_hash": "11d160645e57ae70148f6e21b063aff6ea2447aa",
        "diff_stats": {
            "additions": 12,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,12 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project version=\"4\">\n+  <component name=\"Encoding\" useUTFGuessing=\"true\" native2AsciiForPropertiesFiles=\"true\" defaultCharsetForPropertiesFiles=\"UTF-8\">\n+    <file url=\"file://$PROJECT_DIR$\" charset=\"UTF-8\" />\n+    <file url=\"file://$PROJECT_DIR$/end-to-end-tests\" charset=\"UTF-8\" />\n+    <file url=\"file://$PROJECT_DIR$/parent\" charset=\"UTF-8\" />\n+    <file url=\"file://$PROJECT_DIR$/retrolambda\" charset=\"UTF-8\" />\n+    <file url=\"file://$PROJECT_DIR$/retrolambda-runtime\" charset=\"UTF-8\" />\n+    <file url=\"PROJECT\" charset=\"UTF-8\" />\n+  </component>\n+</project>\n+\n"
    },
    {
        "commit_hash": "5f7dcdb4b023ac657eaf3e5d60c038057c4e9400",
        "previous_commit_hash": "11d160645e57ae70148f6e21b063aff6ea2447aa",
        "diff_stats": {
            "additions": 7,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,7 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project version=\"4\">\n+  <component name=\"GradleSettings\">\n+    <option name=\"gradleHome\" value=\"C:/Program Files/gradle\" />\n+  </component>\n+</project>\n+\n"
    },
    {
        "commit_hash": "5f7dcdb4b023ac657eaf3e5d60c038057c4e9400",
        "previous_commit_hash": "11d160645e57ae70148f6e21b063aff6ea2447aa",
        "diff_stats": {
            "additions": 66,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,66 @@\n+<component name=\"InspectionProjectProfileManager\">\n+  <profile version=\"1.0\" is_locked=\"false\">\n+    <option name=\"myName\" value=\"Project Default\" />\n+    <option name=\"myLocal\" value=\"false\" />\n+    <inspection_tool class=\"CollectionContainsUrl\" enabled=\"true\" level=\"WARNING\" enabled_by_default=\"true\" />\n+    <inspection_tool class=\"CollectionsFieldAccessReplaceableByMethodCall\" enabled=\"true\" level=\"WARNING\" enabled_by_default=\"true\" />\n+    <inspection_tool class=\"EnumerationCanBeIteration\" enabled=\"true\" level=\"WARNING\" enabled_by_default=\"true\" />\n+    <inspection_tool class=\"EqualsHashCodeCalledOnUrl\" enabled=\"true\" level=\"WARNING\" enabled_by_default=\"true\" />\n+    <inspection_tool class=\"Fix shebang\" enabled=\"true\" level=\"WARNING\" enabled_by_default=\"true\">/bin/sh#/bin/bash</inspection_tool>\n+    <inspection_tool class=\"JavaDoc\" enabled=\"true\" level=\"WARNING\" enabled_by_default=\"true\">\n+      <option name=\"TOP_LEVEL_CLASS_OPTIONS\">\n+        <value>\n+          <option name=\"ACCESS_JAVADOC_REQUIRED_FOR\" value=\"none\" />\n+          <option name=\"REQUIRED_TAGS\" value=\"\" />\n+        </value>\n+      </option>\n+      <option name=\"INNER_CLASS_OPTIONS\">\n+        <value>\n+          <option name=\"ACCESS_JAVADOC_REQUIRED_FOR\" value=\"none\" />\n+          <option name=\"REQUIRED_TAGS\" value=\"\" />\n+        </value>\n+      </option>\n+      <option name=\"METHOD_OPTIONS\">\n+        <value>\n+          <option name=\"ACCESS_JAVADOC_REQUIRED_FOR\" value=\"none\" />\n+          <option name=\"REQUIRED_TAGS\" value=\"\" />\n+        </value>\n+      </option>\n+      <option name=\"FIELD_OPTIONS\">\n+        <value>\n+          <option name=\"ACCESS_JAVADOC_REQUIRED_FOR\" value=\"none\" />\n+          <option name=\"REQUIRED_TAGS\" value=\"\" />\n+        </value>\n+      </option>\n+      <option name=\"IGNORE_DEPRECATED\" value=\"false\" />\n+      <option name=\"IGNORE_JAVADOC_PERIOD\" value=\"true\" />\n+      <option name=\"IGNORE_DUPLICATED_THROWS\" value=\"false\" />\n+      <option name=\"IGNORE_POINT_TO_ITSELF\" value=\"false\" />\n+      <option name=\"myAdditionalJavadocTags\" value=\"\" />\n+    </inspection_tool>\n+    <inspection_tool class=\"ListIndexOfReplaceableByContains\" enabled=\"true\" level=\"WARNING\" enabled_by_default=\"true\" />\n+    <inspection_tool class=\"LongLiteralsEndingWithLowercaseL\" enabled=\"true\" level=\"WARNING\" enabled_by_default=\"true\" />\n+    <inspection_tool class=\"MethodMayBeSynchronized\" enabled=\"true\" level=\"WARNING\" enabled_by_default=\"true\" />\n+    <inspection_tool class=\"NonSerializableWithSerialVersionUIDField\" enabled=\"true\" level=\"WARNING\" enabled_by_default=\"true\" />\n+    <inspection_tool class=\"PointlessArithmeticExpression\" enabled=\"true\" level=\"WARNING\" enabled_by_default=\"true\">\n+      <option name=\"m_ignoreExpressionsContainingConstants\" value=\"true\" />\n+    </inspection_tool>\n+    <inspection_tool class=\"RawUseOfParameterizedType\" enabled=\"true\" level=\"WARNING\" enabled_by_default=\"true\" />\n+    <inspection_tool class=\"RedundantSuppression\" enabled=\"true\" level=\"WARNING\" enabled_by_default=\"true\" />\n+    <inspection_tool class=\"RedundantThrowsDeclaration\" enabled=\"true\" level=\"WARNING\" enabled_by_default=\"true\" />\n+    <inspection_tool class=\"SerialPersistentFieldsWithWrongSignature\" enabled=\"true\" level=\"WARNING\" enabled_by_default=\"true\" />\n+    <inspection_tool class=\"SerialVersionUIDNotStaticFinal\" enabled=\"true\" level=\"WARNING\" enabled_by_default=\"true\" />\n+    <inspection_tool class=\"SerializableWithUnconstructableAncestor\" enabled=\"true\" level=\"WARNING\" enabled_by_default=\"true\" />\n+    <inspection_tool class=\"SuspiciousIndentAfterControlStatement\" enabled=\"true\" level=\"WARNING\" enabled_by_default=\"true\" />\n+    <inspection_tool class=\"SynchronizedOnLiteralObject\" enabled=\"true\" level=\"WARNING\" enabled_by_default=\"true\" />\n+    <inspection_tool class=\"TestOnlyProblems\" enabled=\"true\" level=\"WARNING\" enabled_by_default=\"true\" />\n+    <inspection_tool class=\"TransientFieldInNonSerializableClass\" enabled=\"true\" level=\"WARNING\" enabled_by_default=\"true\" />\n+    <inspection_tool class=\"TransientFieldNotInitialized\" enabled=\"true\" level=\"WARNING\" enabled_by_default=\"true\" />\n+    <inspection_tool class=\"UnnecessaryBoxing\" enabled=\"true\" level=\"INFO\" enabled_by_default=\"true\" />\n+    <inspection_tool class=\"UnnecessaryUnboxing\" enabled=\"true\" level=\"INFO\" enabled_by_default=\"true\" />\n+    <inspection_tool class=\"UnpredictableBigDecimalConstructorCall\" enabled=\"true\" level=\"WARNING\" enabled_by_default=\"true\">\n+      <option name=\"ignoreReferences\" value=\"true\" />\n+      <option name=\"ignoreComplexLiterals\" value=\"false\" />\n+    </inspection_tool>\n+  </profile>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "5f7dcdb4b023ac657eaf3e5d60c038057c4e9400",
        "previous_commit_hash": "11d160645e57ae70148f6e21b063aff6ea2447aa",
        "diff_stats": {
            "additions": 7,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,7 @@\n+<component name=\"InspectionProjectProfileManager\">\n+  <settings>\n+    <option name=\"PROJECT_PROFILE\" value=\"Project Default\" />\n+    <option name=\"USE_PROJECT_PROFILE\" value=\"true\" />\n+    <version value=\"1.0\" />\n+  </settings>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "5f7dcdb4b023ac657eaf3e5d60c038057c4e9400",
        "previous_commit_hash": "11d160645e57ae70148f6e21b063aff6ea2447aa",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,13 @@\n+<component name=\"libraryTable\">\n+  <library name=\"Maven: junit:junit:4.11\">\n+    <CLASSES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/junit/junit/4.11/junit-4.11.jar!/\" />\n+    </CLASSES>\n+    <JAVADOC>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/junit/junit/4.11/junit-4.11-javadoc.jar!/\" />\n+    </JAVADOC>\n+    <SOURCES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/junit/junit/4.11/junit-4.11-sources.jar!/\" />\n+    </SOURCES>\n+  </library>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "5f7dcdb4b023ac657eaf3e5d60c038057c4e9400",
        "previous_commit_hash": "11d160645e57ae70148f6e21b063aff6ea2447aa",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,13 @@\n+<component name=\"libraryTable\">\n+  <library name=\"Maven: org.hamcrest:hamcrest-core:1.3\">\n+    <CLASSES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3.jar!/\" />\n+    </CLASSES>\n+    <JAVADOC>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3-javadoc.jar!/\" />\n+    </JAVADOC>\n+    <SOURCES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3-sources.jar!/\" />\n+    </SOURCES>\n+  </library>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "5f7dcdb4b023ac657eaf3e5d60c038057c4e9400",
        "previous_commit_hash": "11d160645e57ae70148f6e21b063aff6ea2447aa",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,13 @@\n+<component name=\"libraryTable\">\n+  <library name=\"Maven: org.hamcrest:hamcrest-library:1.3\">\n+    <CLASSES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/hamcrest/hamcrest-library/1.3/hamcrest-library-1.3.jar!/\" />\n+    </CLASSES>\n+    <JAVADOC>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/hamcrest/hamcrest-library/1.3/hamcrest-library-1.3-javadoc.jar!/\" />\n+    </JAVADOC>\n+    <SOURCES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/hamcrest/hamcrest-library/1.3/hamcrest-library-1.3-sources.jar!/\" />\n+    </SOURCES>\n+  </library>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "5f7dcdb4b023ac657eaf3e5d60c038057c4e9400",
        "previous_commit_hash": "11d160645e57ae70148f6e21b063aff6ea2447aa",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,13 @@\n+<component name=\"libraryTable\">\n+  <library name=\"Maven: org.mockito:mockito-core:1.9.5-rc1\">\n+    <CLASSES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/mockito/mockito-core/1.9.5-rc1/mockito-core-1.9.5-rc1.jar!/\" />\n+    </CLASSES>\n+    <JAVADOC>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/mockito/mockito-core/1.9.5-rc1/mockito-core-1.9.5-rc1-javadoc.jar!/\" />\n+    </JAVADOC>\n+    <SOURCES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/mockito/mockito-core/1.9.5-rc1/mockito-core-1.9.5-rc1-sources.jar!/\" />\n+    </SOURCES>\n+  </library>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "5f7dcdb4b023ac657eaf3e5d60c038057c4e9400",
        "previous_commit_hash": "11d160645e57ae70148f6e21b063aff6ea2447aa",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,13 @@\n+<component name=\"libraryTable\">\n+  <library name=\"Maven: org.objenesis:objenesis:1.0\">\n+    <CLASSES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/objenesis/objenesis/1.0/objenesis-1.0.jar!/\" />\n+    </CLASSES>\n+    <JAVADOC>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/objenesis/objenesis/1.0/objenesis-1.0-javadoc.jar!/\" />\n+    </JAVADOC>\n+    <SOURCES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/objenesis/objenesis/1.0/objenesis-1.0-sources.jar!/\" />\n+    </SOURCES>\n+  </library>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "5f7dcdb4b023ac657eaf3e5d60c038057c4e9400",
        "previous_commit_hash": "11d160645e57ae70148f6e21b063aff6ea2447aa",
        "diff_stats": {
            "additions": 150,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,150 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project version=\"4\">\n+  <component name=\"CoverageOptionsProvider\">\n+    <option name=\"myAddOrReplace\" value=\"0\" />\n+    <option name=\"myActivateViewOnRun\" value=\"false\" />\n+  </component>\n+  <component name=\"EntryPointsManager\">\n+    <entry_points version=\"2.0\" />\n+  </component>\n+  <component name=\"JavadocGenerationManager\">\n+    <option name=\"OUTPUT_DIRECTORY\" />\n+    <option name=\"OPTION_SCOPE\" value=\"protected\" />\n+    <option name=\"OPTION_HIERARCHY\" value=\"true\" />\n+    <option name=\"OPTION_NAVIGATOR\" value=\"true\" />\n+    <option name=\"OPTION_INDEX\" value=\"true\" />\n+    <option name=\"OPTION_SEPARATE_INDEX\" value=\"true\" />\n+    <option name=\"OPTION_DOCUMENT_TAG_USE\" value=\"false\" />\n+    <option name=\"OPTION_DOCUMENT_TAG_AUTHOR\" value=\"false\" />\n+    <option name=\"OPTION_DOCUMENT_TAG_VERSION\" value=\"false\" />\n+    <option name=\"OPTION_DOCUMENT_TAG_DEPRECATED\" value=\"true\" />\n+    <option name=\"OPTION_DEPRECATED_LIST\" value=\"true\" />\n+    <option name=\"OTHER_OPTIONS\" value=\"\" />\n+    <option name=\"HEAP_SIZE\" />\n+    <option name=\"LOCALE\" />\n+    <option name=\"OPEN_IN_BROWSER\" value=\"true\" />\n+  </component>\n+  <component name=\"MavenProjectsManager\">\n+    <option name=\"originalFiles\">\n+      <list>\n+        <option value=\"$PROJECT_DIR$/pom.xml\" />\n+      </list>\n+    </option>\n+  </component>\n+  <component name=\"ModuleEditorState\">\n+    <option name=\"LAST_EDITED_MODULE_NAME\" />\n+    <option name=\"LAST_EDITED_TAB_NAME\" />\n+  </component>\n+  <component name=\"ProjectInspectionProfilesVisibleTreeState\">\n+    <entry key=\"Project Default\">\n+      <profile-state>\n+        <expanded-state>\n+          <State>\n+            <id />\n+          </State>\n+          <State>\n+            <id>Code style issuesJavaScript</id>\n+          </State>\n+          <State>\n+            <id>Data flow issues</id>\n+          </State>\n+          <State>\n+            <id>J2ME issues</id>\n+          </State>\n+          <State>\n+            <id>JBoss Seam issues</id>\n+          </State>\n+          <State>\n+            <id>JRuby</id>\n+          </State>\n+          <State>\n+            <id>JUnit issues</id>\n+          </State>\n+          <State>\n+            <id>Java EE issues</id>\n+          </State>\n+          <State>\n+            <id>JavaScript</id>\n+          </State>\n+          <State>\n+            <id>Naming conventions</id>\n+          </State>\n+          <State>\n+            <id>Probable bugs</id>\n+          </State>\n+          <State>\n+            <id>Scala: General</id>\n+          </State>\n+          <State>\n+            <id>Threading issues</id>\n+          </State>\n+          <State>\n+            <id>XPath</id>\n+          </State>\n+        </expanded-state>\n+        <selected-state>\n+          <State>\n+            <id>Abstraction issues</id>\n+          </State>\n+        </selected-state>\n+      </profile-state>\n+    </entry>\n+  </component>\n+  <component name=\"ProjectRootManager\" version=\"2\" languageLevel=\"JDK_1_8\" assert-keyword=\"true\" jdk-15=\"true\" project-jdk-name=\"1.8\" project-jdk-type=\"JavaSDK\">\n+    <output url=\"file://$PROJECT_DIR$/classes\" />\n+  </component>\n+  <component name=\"SvnConfiguration\" maxAnnotateRevisions=\"500\" myUseAcceleration=\"nothing\" myAutoUpdateAfterCommit=\"false\" cleanupOnStartRun=\"false\">\n+    <option name=\"USER\" value=\"\" />\n+    <option name=\"PASSWORD\" value=\"\" />\n+    <option name=\"mySSHConnectionTimeout\" value=\"30000\" />\n+    <option name=\"mySSHReadTimeout\" value=\"30000\" />\n+    <option name=\"LAST_MERGED_REVISION\" />\n+    <option name=\"MERGE_DRY_RUN\" value=\"false\" />\n+    <option name=\"MERGE_DIFF_USE_ANCESTRY\" value=\"true\" />\n+    <option name=\"UPDATE_LOCK_ON_DEMAND\" value=\"false\" />\n+    <option name=\"IGNORE_SPACES_IN_MERGE\" value=\"false\" />\n+    <option name=\"DETECT_NESTED_COPIES\" value=\"true\" />\n+    <option name=\"CHECK_NESTED_FOR_QUICK_MERGE\" value=\"false\" />\n+    <option name=\"IGNORE_SPACES_IN_ANNOTATE\" value=\"true\" />\n+    <option name=\"SHOW_MERGE_SOURCES_IN_ANNOTATE\" value=\"true\" />\n+    <option name=\"FORCE_UPDATE\" value=\"false\" />\n+    <option name=\"IGNORE_EXTERNALS\" value=\"false\" />\n+    <configuration useDefault=\"true\">C:\\Users\\ORFJackal\\AppData\\Roaming\\Subversion</configuration>\n+    <myIsUseDefaultProxy>false</myIsUseDefaultProxy>\n+  </component>\n+  <component name=\"VssConfiguration\">\n+    <option name=\"CLIENT_PATH\" value=\"\" />\n+    <option name=\"SRCSAFEINI_PATH\" value=\"\" />\n+    <option name=\"USER_NAME\" value=\"\" />\n+    <option name=\"PWD\" value=\"\" />\n+    <CheckoutOptions>\n+      <option name=\"COMMENT\" value=\"\" />\n+      <option name=\"DO_NOT_GET_LATEST_VERSION\" value=\"false\" />\n+      <option name=\"REPLACE_WRITABLE\" value=\"false\" />\n+      <option name=\"RECURSIVE\" value=\"false\" />\n+    </CheckoutOptions>\n+    <CheckinOptions>\n+      <option name=\"COMMENT\" value=\"\" />\n+      <option name=\"KEEP_CHECKED_OUT\" value=\"false\" />\n+      <option name=\"RECURSIVE\" value=\"false\" />\n+    </CheckinOptions>\n+    <AddOptions>\n+      <option name=\"STORE_ONLY_LATEST_VERSION\" value=\"false\" />\n+      <option name=\"CHECK_OUT_IMMEDIATELY\" value=\"false\" />\n+    </AddOptions>\n+    <UndocheckoutOptions>\n+      <option name=\"MAKE_WRITABLE\" value=\"false\" />\n+      <option name=\"REPLACE_LOCAL_COPY\" value=\"2\" />\n+      <option name=\"RECURSIVE\" value=\"false\" />\n+    </UndocheckoutOptions>\n+    <GetOptions>\n+      <option name=\"REPLACE_WRITABLE\" value=\"0\" />\n+      <option name=\"MAKE_WRITABLE\" value=\"false\" />\n+      <option name=\"ANSWER_NEGATIVELY\" value=\"false\" />\n+      <option name=\"ANSWER_POSITIVELY\" value=\"false\" />\n+      <option name=\"RECURSIVE\" value=\"false\" />\n+      <option name=\"VERSION\" />\n+    </GetOptions>\n+  </component>\n+</project>\n+\n"
    },
    {
        "commit_hash": "5f7dcdb4b023ac657eaf3e5d60c038057c4e9400",
        "previous_commit_hash": "11d160645e57ae70148f6e21b063aff6ea2447aa",
        "diff_stats": {
            "additions": 12,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,12 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project version=\"4\">\n+  <component name=\"ProjectModuleManager\">\n+    <modules>\n+      <module fileurl=\"file://$PROJECT_DIR$/end-to-end-tests/end-to-end-tests.iml\" filepath=\"$PROJECT_DIR$/end-to-end-tests/end-to-end-tests.iml\" />\n+      <module fileurl=\"file://$PROJECT_DIR$/parent/parent.iml\" filepath=\"$PROJECT_DIR$/parent/parent.iml\" />\n+      <module fileurl=\"file://$PROJECT_DIR$/project.iml\" filepath=\"$PROJECT_DIR$/project.iml\" />\n+      <module fileurl=\"file://$PROJECT_DIR$/retrolambda/retrolambda.iml\" filepath=\"$PROJECT_DIR$/retrolambda/retrolambda.iml\" />\n+    </modules>\n+  </component>\n+</project>\n+\n"
    },
    {
        "commit_hash": "5f7dcdb4b023ac657eaf3e5d60c038057c4e9400",
        "previous_commit_hash": "11d160645e57ae70148f6e21b063aff6ea2447aa",
        "diff_stats": {
            "additions": 5,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,5 @@\n+<component name=\"DependencyValidationManager\">\n+  <state>\n+    <option name=\"SKIP_IMPORT_STATEMENTS\" value=\"false\" />\n+  </state>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "5f7dcdb4b023ac657eaf3e5d60c038057c4e9400",
        "previous_commit_hash": "11d160645e57ae70148f6e21b063aff6ea2447aa",
        "diff_stats": {
            "additions": 125,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,125 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project version=\"4\">\n+  <component name=\"Palette2\">\n+    <group name=\"Swing\">\n+      <item class=\"com.intellij.uiDesigner.HSpacer\" tooltip-text=\"Horizontal Spacer\" icon=\"/com/intellij/uiDesigner/icons/hspacer.png\" removable=\"false\" auto-create-binding=\"false\" can-attach-label=\"false\">\n+        <default-constraints vsize-policy=\"1\" hsize-policy=\"6\" anchor=\"0\" fill=\"1\" />\n+      </item>\n+      <item class=\"com.intellij.uiDesigner.VSpacer\" tooltip-text=\"Vertical Spacer\" icon=\"/com/intellij/uiDesigner/icons/vspacer.png\" removable=\"false\" auto-create-binding=\"false\" can-attach-label=\"false\">\n+        <default-constraints vsize-policy=\"6\" hsize-policy=\"1\" anchor=\"0\" fill=\"2\" />\n+      </item>\n+      <item class=\"javax.swing.JPanel\" icon=\"/com/intellij/uiDesigner/icons/panel.png\" removable=\"false\" auto-create-binding=\"false\" can-attach-label=\"false\">\n+        <default-constraints vsize-policy=\"3\" hsize-policy=\"3\" anchor=\"0\" fill=\"3\" />\n+      </item>\n+      <item class=\"javax.swing.JScrollPane\" icon=\"/com/intellij/uiDesigner/icons/scrollPane.png\" removable=\"false\" auto-create-binding=\"false\" can-attach-label=\"true\">\n+        <default-constraints vsize-policy=\"7\" hsize-policy=\"7\" anchor=\"0\" fill=\"3\" />\n+      </item>\n+      <item class=\"javax.swing.JButton\" icon=\"/com/intellij/uiDesigner/icons/button.png\" removable=\"false\" auto-create-binding=\"true\" can-attach-label=\"false\">\n+        <default-constraints vsize-policy=\"0\" hsize-policy=\"3\" anchor=\"0\" fill=\"1\" />\n+        <initial-values>\n+          <property name=\"text\" value=\"Button\" />\n+        </initial-values>\n+      </item>\n+      <item class=\"javax.swing.JRadioButton\" icon=\"/com/intellij/uiDesigner/icons/radioButton.png\" removable=\"false\" auto-create-binding=\"true\" can-attach-label=\"false\">\n+        <default-constraints vsize-policy=\"0\" hsize-policy=\"3\" anchor=\"8\" fill=\"0\" />\n+        <initial-values>\n+          <property name=\"text\" value=\"RadioButton\" />\n+        </initial-values>\n+      </item>\n+      <item class=\"javax.swing.JCheckBox\" icon=\"/com/intellij/uiDesigner/icons/checkBox.png\" removable=\"false\" auto-create-binding=\"true\" can-attach-label=\"false\">\n+        <default-constraints vsize-policy=\"0\" hsize-policy=\"3\" anchor=\"8\" fill=\"0\" />\n+        <initial-values>\n+          <property name=\"text\" value=\"CheckBox\" />\n+        </initial-values>\n+      </item>\n+      <item class=\"javax.swing.JLabel\" icon=\"/com/intellij/uiDesigner/icons/label.png\" removable=\"false\" auto-create-binding=\"false\" can-attach-label=\"false\">\n+        <default-constraints vsize-policy=\"0\" hsize-policy=\"0\" anchor=\"8\" fill=\"0\" />\n+        <initial-values>\n+          <property name=\"text\" value=\"Label\" />\n+        </initial-values>\n+      </item>\n+      <item class=\"javax.swing.JTextField\" icon=\"/com/intellij/uiDesigner/icons/textField.png\" removable=\"false\" auto-create-binding=\"true\" can-attach-label=\"true\">\n+        <default-constraints vsize-policy=\"0\" hsize-policy=\"6\" anchor=\"8\" fill=\"1\">\n+          <preferred-size width=\"150\" height=\"-1\" />\n+        </default-constraints>\n+      </item>\n+      <item class=\"javax.swing.JPasswordField\" icon=\"/com/intellij/uiDesigner/icons/passwordField.png\" removable=\"false\" auto-create-binding=\"true\" can-attach-label=\"true\">\n+        <default-constraints vsize-policy=\"0\" hsize-policy=\"6\" anchor=\"8\" fill=\"1\">\n+          <preferred-size width=\"150\" height=\"-1\" />\n+        </default-constraints>\n+      </item>\n+      <item class=\"javax.swing.JFormattedTextField\" icon=\"/com/intellij/uiDesigner/icons/formattedTextField.png\" removable=\"false\" auto-create-binding=\"true\" can-attach-label=\"true\">\n+        <default-constraints vsize-policy=\"0\" hsize-policy=\"6\" anchor=\"8\" fill=\"1\">\n+          <preferred-size width=\"150\" height=\"-1\" />\n+        </default-constraints>\n+      </item>\n+      <item class=\"javax.swing.JTextArea\" icon=\"/com/intellij/uiDesigner/icons/textArea.png\" removable=\"false\" auto-create-binding=\"true\" can-attach-label=\"true\">\n+        <default-constraints vsize-policy=\"6\" hsize-policy=\"6\" anchor=\"0\" fill=\"3\">\n+          <preferred-size width=\"150\" height=\"50\" />\n+        </default-constraints>\n+      </item>\n+      <item class=\"javax.swing.JTextPane\" icon=\"/com/intellij/uiDesigner/icons/textPane.png\" removable=\"false\" auto-create-binding=\"true\" can-attach-label=\"true\">\n+        <default-constraints vsize-policy=\"6\" hsize-policy=\"6\" anchor=\"0\" fill=\"3\">\n+          <preferred-size width=\"150\" height=\"50\" />\n+        </default-constraints>\n+      </item>\n+      <item class=\"javax.swing.JEditorPane\" icon=\"/com/intellij/uiDesigner/icons/editorPane.png\" removable=\"false\" auto-create-binding=\"true\" can-attach-label=\"true\">\n+        <default-constraints vsize-policy=\"6\" hsize-policy=\"6\" anchor=\"0\" fill=\"3\">\n+          <preferred-size width=\"150\" height=\"50\" />\n+        </default-constraints>\n+      </item>\n+      <item class=\"javax.swing.JComboBox\" icon=\"/com/intellij/uiDesigner/icons/comboBox.png\" removable=\"false\" auto-create-binding=\"true\" can-attach-label=\"true\">\n+        <default-constraints vsize-policy=\"0\" hsize-policy=\"2\" anchor=\"8\" fill=\"1\" />\n+      </item>\n+      <item class=\"javax.swing.JTable\" icon=\"/com/intellij/uiDesigner/icons/table.png\" removable=\"false\" auto-create-binding=\"true\" can-attach-label=\"false\">\n+        <default-constraints vsize-policy=\"6\" hsize-policy=\"6\" anchor=\"0\" fill=\"3\">\n+          <preferred-size width=\"150\" height=\"50\" />\n+        </default-constraints>\n+      </item>\n+      <item class=\"javax.swing.JList\" icon=\"/com/intellij/uiDesigner/icons/list.png\" removable=\"false\" auto-create-binding=\"true\" can-attach-label=\"false\">\n+        <default-constraints vsize-policy=\"6\" hsize-policy=\"2\" anchor=\"0\" fill=\"3\">\n+          <preferred-size width=\"150\" height=\"50\" />\n+        </default-constraints>\n+      </item>\n+      <item class=\"javax.swing.JTree\" icon=\"/com/intellij/uiDesigner/icons/tree.png\" removable=\"false\" auto-create-binding=\"true\" can-attach-label=\"false\">\n+        <default-constraints vsize-policy=\"6\" hsize-policy=\"6\" anchor=\"0\" fill=\"3\">\n+          <preferred-size width=\"150\" height=\"50\" />\n+        </default-constraints>\n+      </item>\n+      <item class=\"javax.swing.JTabbedPane\" icon=\"/com/intellij/uiDesigner/icons/tabbedPane.png\" removable=\"false\" auto-create-binding=\"true\" can-attach-label=\"false\">\n+        <default-constraints vsize-policy=\"3\" hsize-policy=\"3\" anchor=\"0\" fill=\"3\">\n+          <preferred-size width=\"200\" height=\"200\" />\n+        </default-constraints>\n+      </item>\n+      <item class=\"javax.swing.JSplitPane\" icon=\"/com/intellij/uiDesigner/icons/splitPane.png\" removable=\"false\" auto-create-binding=\"false\" can-attach-label=\"false\">\n+        <default-constraints vsize-policy=\"3\" hsize-policy=\"3\" anchor=\"0\" fill=\"3\">\n+          <preferred-size width=\"200\" height=\"200\" />\n+        </default-constraints>\n+      </item>\n+      <item class=\"javax.swing.JSpinner\" icon=\"/com/intellij/uiDesigner/icons/spinner.png\" removable=\"false\" auto-create-binding=\"true\" can-attach-label=\"true\">\n+        <default-constraints vsize-policy=\"0\" hsize-policy=\"6\" anchor=\"8\" fill=\"1\" />\n+      </item>\n+      <item class=\"javax.swing.JSlider\" icon=\"/com/intellij/uiDesigner/icons/slider.png\" removable=\"false\" auto-create-binding=\"true\" can-attach-label=\"false\">\n+        <default-constraints vsize-policy=\"0\" hsize-policy=\"6\" anchor=\"8\" fill=\"1\" />\n+      </item>\n+      <item class=\"javax.swing.JSeparator\" icon=\"/com/intellij/uiDesigner/icons/separator.png\" removable=\"false\" auto-create-binding=\"false\" can-attach-label=\"false\">\n+        <default-constraints vsize-policy=\"6\" hsize-policy=\"6\" anchor=\"0\" fill=\"3\" />\n+      </item>\n+      <item class=\"javax.swing.JProgressBar\" icon=\"/com/intellij/uiDesigner/icons/progressbar.png\" removable=\"false\" auto-create-binding=\"true\" can-attach-label=\"false\">\n+        <default-constraints vsize-policy=\"0\" hsize-policy=\"6\" anchor=\"0\" fill=\"1\" />\n+      </item>\n+      <item class=\"javax.swing.JToolBar\" icon=\"/com/intellij/uiDesigner/icons/toolbar.png\" removable=\"false\" auto-create-binding=\"false\" can-attach-label=\"false\">\n+        <default-constraints vsize-policy=\"0\" hsize-policy=\"6\" anchor=\"0\" fill=\"1\">\n+          <preferred-size width=\"-1\" height=\"20\" />\n+        </default-constraints>\n+      </item>\n+      <item class=\"javax.swing.JToolBar$Separator\" icon=\"/com/intellij/uiDesigner/icons/toolbarSeparator.png\" removable=\"false\" auto-create-binding=\"false\" can-attach-label=\"false\">\n+        <default-constraints vsize-policy=\"0\" hsize-policy=\"0\" anchor=\"0\" fill=\"1\" />\n+      </item>\n+      <item class=\"javax.swing.JScrollBar\" icon=\"/com/intellij/uiDesigner/icons/scrollbar.png\" removable=\"false\" auto-create-binding=\"true\" can-attach-label=\"false\">\n+        <default-constraints vsize-policy=\"6\" hsize-policy=\"0\" anchor=\"0\" fill=\"2\" />\n+      </item>\n+    </group>\n+  </component>\n+</project>\n+\n"
    },
    {
        "commit_hash": "5f7dcdb4b023ac657eaf3e5d60c038057c4e9400",
        "previous_commit_hash": "11d160645e57ae70148f6e21b063aff6ea2447aa",
        "diff_stats": {
            "additions": 7,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,7 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project version=\"4\">\n+  <component name=\"VcsDirectoryMappings\">\n+    <mapping directory=\"$PROJECT_DIR$\" vcs=\"Git\" />\n+  </component>\n+</project>\n+\n"
    },
    {
        "commit_hash": "5f7dcdb4b023ac657eaf3e5d60c038057c4e9400",
        "previous_commit_hash": "11d160645e57ae70148f6e21b063aff6ea2447aa",
        "diff_stats": {
            "additions": 19,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,19 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<module org.jetbrains.idea.maven.project.MavenProjectsManager.isMavenModule=\"true\" type=\"JAVA_MODULE\" version=\"4\">\n+  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"false\">\n+    <output url=\"file://$MODULE_DIR$/target/classes\" />\n+    <output-test url=\"file://$MODULE_DIR$/target/test-classes\" />\n+    <exclude-output />\n+    <content url=\"file://$MODULE_DIR$\">\n+      <excludeFolder url=\"file://$MODULE_DIR$/target\" />\n+    </content>\n+    <orderEntry type=\"inheritedJdk\" />\n+    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.11\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-library:1.3\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-core:1.3\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.mockito:mockito-core:1.9.5-rc1\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.objenesis:objenesis:1.0\" level=\"project\" />\n+  </component>\n+</module>\n+\n"
    },
    {
        "commit_hash": "5f7dcdb4b023ac657eaf3e5d60c038057c4e9400",
        "previous_commit_hash": "11d160645e57ae70148f6e21b063aff6ea2447aa",
        "diff_stats": {
            "additions": 31,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,31 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <parent>\n+        <groupId>net.orfjackal.retrolambda</groupId>\n+        <artifactId>parent</artifactId>\n+        <version>0.1-SNAPSHOT</version>\n+        <relativePath>../parent/pom.xml</relativePath>\n+    </parent>\n+\n+    <artifactId>end-to-end-tests</artifactId>\n+    <packaging>jar</packaging>\n+\n+    <build>\n+        <plugins>\n+\n+            <!-- Don't deploy the tests to Maven Central -->\n+\n+            <plugin>\n+                <artifactId>maven-deploy-plugin</artifactId>\n+                <configuration>\n+                    <skip>true</skip>\n+                </configuration>\n+            </plugin>\n+\n+        </plugins>\n+    </build>\n+\n+</project>\n"
    },
    {
        "commit_hash": "5f7dcdb4b023ac657eaf3e5d60c038057c4e9400",
        "previous_commit_hash": "11d160645e57ae70148f6e21b063aff6ea2447aa",
        "diff_stats": {
            "additions": 19,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,19 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<module org.jetbrains.idea.maven.project.MavenProjectsManager.isMavenModule=\"true\" type=\"JAVA_MODULE\" version=\"4\">\n+  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"false\">\n+    <output url=\"file://$MODULE_DIR$/target/classes\" />\n+    <output-test url=\"file://$MODULE_DIR$/target/test-classes\" />\n+    <exclude-output />\n+    <content url=\"file://$MODULE_DIR$\">\n+      <excludeFolder url=\"file://$MODULE_DIR$/target\" />\n+    </content>\n+    <orderEntry type=\"inheritedJdk\" />\n+    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.11\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-library:1.3\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-core:1.3\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.mockito:mockito-core:1.9.5-rc1\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.objenesis:objenesis:1.0\" level=\"project\" />\n+  </component>\n+</module>\n+\n"
    },
    {
        "commit_hash": "5f7dcdb4b023ac657eaf3e5d60c038057c4e9400",
        "previous_commit_hash": "11d160645e57ae70148f6e21b063aff6ea2447aa",
        "diff_stats": {
            "additions": 342,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,342 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <parent>\n+        <groupId>org.sonatype.oss</groupId>\n+        <artifactId>oss-parent</artifactId>\n+        <version>7</version>\n+    </parent>\n+\n+    <groupId>net.orfjackal.retrolambda</groupId>\n+    <artifactId>parent</artifactId>\n+    <version>0.1-SNAPSHOT</version>\n+    <packaging>pom</packaging>\n+\n+    <description>Backport of Java 8 lambda expressions to Java 7</description>\n+    <url>https://github.com/orfjackal/retrolambda</url>\n+    <inceptionYear>2013</inceptionYear>\n+\n+    <licenses>\n+        <license>\n+            <name>Apache License 2.0</name>\n+            <url>http://www.apache.org/licenses/LICENSE-2.0</url>\n+        </license>\n+    </licenses>\n+\n+    <developers>\n+        <developer>\n+            <id>orfjackal</id>\n+            <name>Esko Luontola</name>\n+            <url>http://www.orfjackal.net/</url>\n+        </developer>\n+    </developers>\n+\n+    <scm>\n+        <connection>scm:git:git://github.com/orfjackal/retrolambda.git</connection>\n+        <url>https://github.com/orfjackal/retrolambda</url>\n+    </scm>\n+\n+    <properties>\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+        <minimumMavenVersion>3.0.3</minimumMavenVersion>\n+    </properties>\n+\n+    <prerequisites>\n+        <maven>${minimumMavenVersion}</maven>\n+    </prerequisites>\n+\n+    <dependencies>\n+\n+        <!-- Testing -->\n+\n+        <dependency>\n+            <groupId>junit</groupId>\n+            <artifactId>junit</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>org.hamcrest</groupId>\n+            <artifactId>hamcrest-library</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>org.mockito</groupId>\n+            <artifactId>mockito-core</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+\n+    </dependencies>\n+\n+    <dependencyManagement>\n+        <dependencies>\n+\n+            <!-- Bytecode Manipulation -->\n+\n+            <dependency>\n+                <groupId>org.ow2.asm</groupId>\n+                <artifactId>asm-debug-all</artifactId>\n+                <version>4.0</version>\n+            </dependency>\n+\n+            <!-- Testing -->\n+\n+            <dependency>\n+                <groupId>junit</groupId>\n+                <artifactId>junit</artifactId>\n+                <version>4.11</version>\n+                <exclusions>\n+                    <!-- Avoid diverging hamcrest-library and hamcrest-core versions -->\n+                    <exclusion>\n+                        <groupId>org.hamcrest</groupId>\n+                        <artifactId>hamcrest-core</artifactId>\n+                    </exclusion>\n+                </exclusions>\n+            </dependency>\n+\n+            <dependency>\n+                <groupId>org.hamcrest</groupId>\n+                <artifactId>hamcrest-library</artifactId>\n+                <version>1.3</version>\n+            </dependency>\n+\n+            <dependency>\n+                <groupId>org.mockito</groupId>\n+                <artifactId>mockito-core</artifactId>\n+                <version>1.9.5-rc1</version>\n+            </dependency>\n+\n+        </dependencies>\n+    </dependencyManagement>\n+\n+    <build>\n+        <plugins>\n+\n+            <plugin>\n+                <artifactId>maven-compiler-plugin</artifactId>\n+                <configuration>\n+                    <source>1.8</source>\n+                    <target>1.8</target>\n+                </configuration>\n+            </plugin>\n+\n+            <plugin>\n+                <artifactId>maven-surefire-plugin</artifactId>\n+                <configuration>\n+                    <includes>\n+                        <include>**/*Test.class</include>\n+                    </includes>\n+                    <redirectTestOutputToFile>true</redirectTestOutputToFile>\n+                </configuration>\n+            </plugin>\n+\n+            <plugin>\n+                <artifactId>maven-source-plugin</artifactId>\n+                <executions>\n+                    <execution>\n+                        <id>attach-sources</id>\n+                        <goals>\n+                            <goal>jar-no-fork</goal>\n+                        </goals>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+\n+            <plugin>\n+                <artifactId>maven-enforcer-plugin</artifactId>\n+                <executions>\n+                    <execution>\n+                        <!-- XXX: Using a different ID than in oss-parent to avoid overriding its checks by accident. See https://issues.sonatype.org/browse/OSSRH-2004 -->\n+                        <id>enforce-maven-3</id>\n+                        <goals>\n+                            <goal>enforce</goal>\n+                        </goals>\n+                        <configuration>\n+                            <rules>\n+                                <requireMavenVersion>\n+                                    <version>[${minimumMavenVersion},)</version>\n+                                </requireMavenVersion>\n+                            </rules>\n+                        </configuration>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+\n+            <plugin>\n+                <artifactId>maven-antrun-plugin</artifactId>\n+                <executions>\n+                    <execution>\n+                        <!-- XXX: workaround for an issue with maven-shade-plugin\n+                             There appears to be some stale state from previous executions of the Shade plugin,\n+                             which manifest themselves as \"We have a duplicate\" warnings on build and also as\n+                             some classes not being updated on build. -->\n+                        <id>delete-old-artifact</id>\n+                        <phase>prepare-package</phase>\n+                        <goals>\n+                            <goal>run</goal>\n+                        </goals>\n+                        <configuration>\n+                            <target>\n+                                <delete file=\"${project.build.directory}/${project.build.finalName}.${project.packaging}\"/>\n+                            </target>\n+                        </configuration>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+\n+        </plugins>\n+        <pluginManagement>\n+            <plugins>\n+\n+                <plugin>\n+                    <artifactId>maven-clean-plugin</artifactId>\n+                    <version>2.5</version>\n+                </plugin>\n+\n+                <plugin>\n+                    <artifactId>maven-compiler-plugin</artifactId>\n+                    <version>2.5</version>\n+                </plugin>\n+\n+                <plugin>\n+                    <artifactId>maven-resources-plugin</artifactId>\n+                    <version>2.6</version>\n+                </plugin>\n+\n+                <plugin>\n+                    <artifactId>maven-jar-plugin</artifactId>\n+                    <version>2.4</version>\n+                </plugin>\n+\n+                <plugin>\n+                    <artifactId>maven-source-plugin</artifactId>\n+                    <version>2.1.2</version>\n+                </plugin>\n+\n+                <plugin>\n+                    <artifactId>maven-javadoc-plugin</artifactId>\n+                    <version>2.9.1</version>\n+                </plugin>\n+\n+                <plugin>\n+                    <artifactId>maven-install-plugin</artifactId>\n+                    <version>2.4</version>\n+                </plugin>\n+\n+                <plugin>\n+                    <artifactId>maven-deploy-plugin</artifactId>\n+                    <version>2.7</version>\n+                </plugin>\n+\n+                <plugin>\n+                    <artifactId>maven-plugin-plugin</artifactId>\n+                    <version>3.1</version>\n+                </plugin>\n+\n+                <plugin>\n+                    <artifactId>maven-site-plugin</artifactId>\n+                    <version>3.1</version>\n+                </plugin>\n+\n+                <plugin>\n+                    <artifactId>maven-shade-plugin</artifactId>\n+                    <version>2.0</version>\n+                    <configuration>\n+                        <minimizeJar>true</minimizeJar>\n+                        <!-- Keep the generated POM file out of the base directory -->\n+                        <dependencyReducedPomLocation>\n+                            ${project.build.directory}/dependency-reduced-pom.xml\n+                        </dependencyReducedPomLocation>\n+                    </configuration>\n+                </plugin>\n+\n+                <plugin>\n+                    <artifactId>maven-enforcer-plugin</artifactId>\n+                    <version>1.1</version>\n+                </plugin>\n+\n+                <plugin>\n+                    <artifactId>maven-surefire-plugin</artifactId>\n+                    <version>2.12.3</version>\n+                </plugin>\n+\n+                <plugin>\n+                    <artifactId>maven-failsafe-plugin</artifactId>\n+                    <version>2.12.3</version>\n+                </plugin>\n+\n+                <plugin>\n+                    <artifactId>maven-invoker-plugin</artifactId>\n+                    <version>1.7</version>\n+                </plugin>\n+\n+                <plugin>\n+                    <artifactId>maven-dependency-plugin</artifactId>\n+                    <version>2.5.1</version>\n+                </plugin>\n+\n+                <plugin>\n+                    <artifactId>maven-antrun-plugin</artifactId>\n+                    <version>1.7</version>\n+                </plugin>\n+\n+                <plugin>\n+                    <groupId>org.codehaus.mojo</groupId>\n+                    <artifactId>versions-maven-plugin</artifactId>\n+                    <version>1.3.1</version>\n+                </plugin>\n+\n+                <plugin>\n+                    <groupId>org.pitest</groupId>\n+                    <artifactId>pitest-maven</artifactId>\n+                    <version>0.29</version>\n+                </plugin>\n+\n+            </plugins>\n+        </pluginManagement>\n+    </build>\n+\n+    <profiles>\n+        <profile>\n+            <id>coverage-report</id>\n+            <build>\n+                <plugins>\n+                    <plugin>\n+                        <groupId>org.pitest</groupId>\n+                        <artifactId>pitest-maven</artifactId>\n+                        <executions>\n+                            <execution>\n+                                <goals>\n+                                    <goal>mutationCoverage</goal>\n+                                </goals>\n+                            </execution>\n+                        </executions>\n+                        <configuration>\n+                            <threads>4</threads>\n+                            <jvmArgs>\n+                                <arg>-ea</arg>\n+                            </jvmArgs>\n+                            <targetClasses>\n+                                <pattern>net.orfjackal.retrolambda.*</pattern>\n+                            </targetClasses>\n+                            <targetTests>\n+                                <pattern>net.orfjackal.retrolambda.*Test</pattern>\n+                            </targetTests>\n+                            <failWhenNoMutations>false</failWhenNoMutations>\n+                            <timestampedReports>false</timestampedReports>\n+                            <mutators>\n+                                <mutator>ALL</mutator>\n+                            </mutators>\n+                            <mutateStaticInitializers>true</mutateStaticInitializers>\n+                        </configuration>\n+                    </plugin>\n+                </plugins>\n+            </build>\n+        </profile>\n+    </profiles>\n+\n+</project>\n"
    },
    {
        "commit_hash": "5f7dcdb4b023ac657eaf3e5d60c038057c4e9400",
        "previous_commit_hash": "11d160645e57ae70148f6e21b063aff6ea2447aa",
        "diff_stats": {
            "additions": 39,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,39 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <parent>\n+        <groupId>net.orfjackal.retrolambda</groupId>\n+        <artifactId>parent</artifactId>\n+        <version>0.1-SNAPSHOT</version>\n+        <relativePath>parent/pom.xml</relativePath>\n+    </parent>\n+\n+    <artifactId>project</artifactId>\n+    <packaging>pom</packaging>\n+\n+    <name>Retrolambda</name>\n+\n+    <modules>\n+        <module>parent</module>\n+        <module>retrolambda</module>\n+        <module>end-to-end-tests</module>\n+    </modules>\n+\n+    <build>\n+        <plugins>\n+\n+            <!-- Don't deploy the project's aggregate module to Maven Central -->\n+\n+            <plugin>\n+                <artifactId>maven-deploy-plugin</artifactId>\n+                <configuration>\n+                    <skip>true</skip>\n+                </configuration>\n+            </plugin>\n+\n+        </plugins>\n+    </build>\n+\n+</project>\n"
    },
    {
        "commit_hash": "5f7dcdb4b023ac657eaf3e5d60c038057c4e9400",
        "previous_commit_hash": "11d160645e57ae70148f6e21b063aff6ea2447aa",
        "diff_stats": {
            "additions": 19,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,19 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<module org.jetbrains.idea.maven.project.MavenProjectsManager.isMavenModule=\"true\" type=\"JAVA_MODULE\" version=\"4\">\n+  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"false\">\n+    <output url=\"file://$MODULE_DIR$/target/classes\" />\n+    <output-test url=\"file://$MODULE_DIR$/target/test-classes\" />\n+    <exclude-output />\n+    <content url=\"file://$MODULE_DIR$\">\n+      <excludeFolder url=\"file://$MODULE_DIR$/target\" />\n+    </content>\n+    <orderEntry type=\"inheritedJdk\" />\n+    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.11\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-library:1.3\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-core:1.3\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.mockito:mockito-core:1.9.5-rc1\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.objenesis:objenesis:1.0\" level=\"project\" />\n+  </component>\n+</module>\n+\n"
    },
    {
        "commit_hash": "5f7dcdb4b023ac657eaf3e5d60c038057c4e9400",
        "previous_commit_hash": "11d160645e57ae70148f6e21b063aff6ea2447aa",
        "diff_stats": {
            "additions": 34,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,34 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <parent>\n+        <groupId>net.orfjackal.retrolambda</groupId>\n+        <artifactId>parent</artifactId>\n+        <version>0.1-SNAPSHOT</version>\n+        <relativePath>../parent/pom.xml</relativePath>\n+    </parent>\n+\n+    <artifactId>retrolambda</artifactId>\n+    <packaging>jar</packaging>\n+\n+    <build>\n+        <plugins>\n+\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-jar-plugin</artifactId>\n+                <configuration>\n+                    <archive>\n+                        <manifestEntries>\n+                            <Premain-Class>net.orfjackal.retrolambda.SpikeAgent</Premain-Class>\n+                        </manifestEntries>\n+                    </archive>\n+                </configuration>\n+            </plugin>\n+\n+        </plugins>\n+    </build>\n+\n+</project>\n"
    },
    {
        "commit_hash": "5f7dcdb4b023ac657eaf3e5d60c038057c4e9400",
        "previous_commit_hash": "11d160645e57ae70148f6e21b063aff6ea2447aa",
        "diff_stats": {
            "additions": 19,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,19 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<module org.jetbrains.idea.maven.project.MavenProjectsManager.isMavenModule=\"true\" type=\"JAVA_MODULE\" version=\"4\">\n+  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"false\">\n+    <output url=\"file://$MODULE_DIR$/target/classes\" />\n+    <output-test url=\"file://$MODULE_DIR$/target/test-classes\" />\n+    <content url=\"file://$MODULE_DIR$\">\n+      <sourceFolder url=\"file://$MODULE_DIR$/src/main/java\" isTestSource=\"false\" />\n+      <excludeFolder url=\"file://$MODULE_DIR$/target\" />\n+    </content>\n+    <orderEntry type=\"jdk\" jdkName=\"1.8\" jdkType=\"JavaSDK\" />\n+    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.11\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-library:1.3\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-core:1.3\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.mockito:mockito-core:1.9.5-rc1\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.objenesis:objenesis:1.0\" level=\"project\" />\n+  </component>\n+</module>\n+\n"
    },
    {
        "commit_hash": "b9b17b4c333f6a2da89eeabb48d1bdcecaabb82a",
        "previous_commit_hash": "5f7dcdb4b023ac657eaf3e5d60c038057c4e9400",
        "diff_stats": {
            "additions": 43,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,43 @@\n+// Copyright \u00a9 2013 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda;\n+\n+import java.lang.invoke.*;\n+import java.lang.reflect.*;\n+\n+public class Spike {\n+\n+    public static void main(String[] args) throws Exception {\n+        Class<?> targetClass = Dummy.class;\n+        ClassLoader targetClassClassLoader = targetClass.getClassLoader();\n+\n+        Constructor<MethodHandles.Lookup> ctor = MethodHandles.Lookup.class.getDeclaredConstructor(Class.class);\n+        ctor.setAccessible(true);\n+        MethodHandles.Lookup caller = ctor.newInstance(targetClass);\n+\n+        LambdaMetafactory.metafactory(\n+                caller,\n+                \"run\",\n+                MethodType.fromMethodDescriptorString(\"()Ljava/lang/Runnable;\", targetClassClassLoader),\n+                MethodType.fromMethodDescriptorString(\"()V\", targetClassClassLoader),\n+                caller.findStatic(targetClass, \"lambda$0\", MethodType.fromMethodDescriptorString(\"()V\", targetClassClassLoader)),\n+                MethodType.fromMethodDescriptorString(\"()V\", targetClassClassLoader));\n+    }\n+\n+    private static MethodHandles.Lookup getTrustedLookup() throws Exception {\n+        Field f = MethodHandles.Lookup.class.getDeclaredField(\"IMPL_LOOKUP\");\n+        f.setAccessible(true);\n+        return (MethodHandles.Lookup) f.get(null);\n+    }\n+}\n+\n+class Dummy {\n+\n+    public void foo() {\n+        Runnable r = () -> {\n+            System.out.println(\"foo\");\n+        };\n+    }\n+}\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "b9b17b4c333f6a2da89eeabb48d1bdcecaabb82a",
        "previous_commit_hash": "5f7dcdb4b023ac657eaf3e5d60c038057c4e9400",
        "diff_stats": {
            "additions": 35,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,35 @@\n+// Copyright \u00a9 2013 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda;\n+\n+import java.io.IOException;\n+import java.lang.instrument.*;\n+import java.nio.file.*;\n+import java.security.ProtectionDomain;\n+\n+public class SpikeAgent {\n+    public static void premain(String agentArgs, Instrumentation inst) {\n+        inst.addTransformer(new MyClassFileTransformer());\n+    }\n+}\n+\n+class MyClassFileTransformer implements ClassFileTransformer {\n+    @Override\n+    public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {\n+        if (!className.contains(\"$$Lambda$\")) {\n+            return null;\n+        }\n+        try {\n+            System.out.println(className);\n+            Path savePath = Paths.get(\"generated\", className + \".class\");\n+            Files.createDirectories(savePath.getParent());\n+            Files.write(savePath, classfileBuffer);\n+\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        return null;\n+    }\n+}\n"
    },
    {
        "commit_hash": "2bcea70f2f0d56902549e9b168c73625a3113bb0",
        "previous_commit_hash": "b9b17b4c333f6a2da89eeabb48d1bdcecaabb82a",
        "diff_stats": {
            "additions": 202,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,202 @@\n+\n+                                 Apache License\n+                           Version 2.0, January 2004\n+                        http://www.apache.org/licenses/\n+\n+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n+\n+   1. Definitions.\n+\n+      \"License\" shall mean the terms and conditions for use, reproduction,\n+      and distribution as defined by Sections 1 through 9 of this document.\n+\n+      \"Licensor\" shall mean the copyright owner or entity authorized by\n+      the copyright owner that is granting the License.\n+\n+      \"Legal Entity\" shall mean the union of the acting entity and all\n+      other entities that control, are controlled by, or are under common\n+      control with that entity. For the purposes of this definition,\n+      \"control\" means (i) the power, direct or indirect, to cause the\n+      direction or management of such entity, whether by contract or\n+      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n+      outstanding shares, or (iii) beneficial ownership of such entity.\n+\n+      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n+      exercising permissions granted by this License.\n+\n+      \"Source\" form shall mean the preferred form for making modifications,\n+      including but not limited to software source code, documentation\n+      source, and configuration files.\n+\n+      \"Object\" form shall mean any form resulting from mechanical\n+      transformation or translation of a Source form, including but\n+      not limited to compiled object code, generated documentation,\n+      and conversions to other media types.\n+\n+      \"Work\" shall mean the work of authorship, whether in Source or\n+      Object form, made available under the License, as indicated by a\n+      copyright notice that is included in or attached to the work\n+      (an example is provided in the Appendix below).\n+\n+      \"Derivative Works\" shall mean any work, whether in Source or Object\n+      form, that is based on (or derived from) the Work and for which the\n+      editorial revisions, annotations, elaborations, or other modifications\n+      represent, as a whole, an original work of authorship. For the purposes\n+      of this License, Derivative Works shall not include works that remain\n+      separable from, or merely link (or bind by name) to the interfaces of,\n+      the Work and Derivative Works thereof.\n+\n+      \"Contribution\" shall mean any work of authorship, including\n+      the original version of the Work and any modifications or additions\n+      to that Work or Derivative Works thereof, that is intentionally\n+      submitted to Licensor for inclusion in the Work by the copyright owner\n+      or by an individual or Legal Entity authorized to submit on behalf of\n+      the copyright owner. For the purposes of this definition, \"submitted\"\n+      means any form of electronic, verbal, or written communication sent\n+      to the Licensor or its representatives, including but not limited to\n+      communication on electronic mailing lists, source code control systems,\n+      and issue tracking systems that are managed by, or on behalf of, the\n+      Licensor for the purpose of discussing and improving the Work, but\n+      excluding communication that is conspicuously marked or otherwise\n+      designated in writing by the copyright owner as \"Not a Contribution.\"\n+\n+      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n+      on behalf of whom a Contribution has been received by Licensor and\n+      subsequently incorporated within the Work.\n+\n+   2. Grant of Copyright License. Subject to the terms and conditions of\n+      this License, each Contributor hereby grants to You a perpetual,\n+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n+      copyright license to reproduce, prepare Derivative Works of,\n+      publicly display, publicly perform, sublicense, and distribute the\n+      Work and such Derivative Works in Source or Object form.\n+\n+   3. Grant of Patent License. Subject to the terms and conditions of\n+      this License, each Contributor hereby grants to You a perpetual,\n+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n+      (except as stated in this section) patent license to make, have made,\n+      use, offer to sell, sell, import, and otherwise transfer the Work,\n+      where such license applies only to those patent claims licensable\n+      by such Contributor that are necessarily infringed by their\n+      Contribution(s) alone or by combination of their Contribution(s)\n+      with the Work to which such Contribution(s) was submitted. If You\n+      institute patent litigation against any entity (including a\n+      cross-claim or counterclaim in a lawsuit) alleging that the Work\n+      or a Contribution incorporated within the Work constitutes direct\n+      or contributory patent infringement, then any patent licenses\n+      granted to You under this License for that Work shall terminate\n+      as of the date such litigation is filed.\n+\n+   4. Redistribution. You may reproduce and distribute copies of the\n+      Work or Derivative Works thereof in any medium, with or without\n+      modifications, and in Source or Object form, provided that You\n+      meet the following conditions:\n+\n+      (a) You must give any other recipients of the Work or\n+          Derivative Works a copy of this License; and\n+\n+      (b) You must cause any modified files to carry prominent notices\n+          stating that You changed the files; and\n+\n+      (c) You must retain, in the Source form of any Derivative Works\n+          that You distribute, all copyright, patent, trademark, and\n+          attribution notices from the Source form of the Work,\n+          excluding those notices that do not pertain to any part of\n+          the Derivative Works; and\n+\n+      (d) If the Work includes a \"NOTICE\" text file as part of its\n+          distribution, then any Derivative Works that You distribute must\n+          include a readable copy of the attribution notices contained\n+          within such NOTICE file, excluding those notices that do not\n+          pertain to any part of the Derivative Works, in at least one\n+          of the following places: within a NOTICE text file distributed\n+          as part of the Derivative Works; within the Source form or\n+          documentation, if provided along with the Derivative Works; or,\n+          within a display generated by the Derivative Works, if and\n+          wherever such third-party notices normally appear. The contents\n+          of the NOTICE file are for informational purposes only and\n+          do not modify the License. You may add Your own attribution\n+          notices within Derivative Works that You distribute, alongside\n+          or as an addendum to the NOTICE text from the Work, provided\n+          that such additional attribution notices cannot be construed\n+          as modifying the License.\n+\n+      You may add Your own copyright statement to Your modifications and\n+      may provide additional or different license terms and conditions\n+      for use, reproduction, or distribution of Your modifications, or\n+      for any such Derivative Works as a whole, provided Your use,\n+      reproduction, and distribution of the Work otherwise complies with\n+      the conditions stated in this License.\n+\n+   5. Submission of Contributions. Unless You explicitly state otherwise,\n+      any Contribution intentionally submitted for inclusion in the Work\n+      by You to the Licensor shall be under the terms and conditions of\n+      this License, without any additional terms or conditions.\n+      Notwithstanding the above, nothing herein shall supersede or modify\n+      the terms of any separate license agreement you may have executed\n+      with Licensor regarding such Contributions.\n+\n+   6. Trademarks. This License does not grant permission to use the trade\n+      names, trademarks, service marks, or product names of the Licensor,\n+      except as required for reasonable and customary use in describing the\n+      origin of the Work and reproducing the content of the NOTICE file.\n+\n+   7. Disclaimer of Warranty. Unless required by applicable law or\n+      agreed to in writing, Licensor provides the Work (and each\n+      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+      implied, including, without limitation, any warranties or conditions\n+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n+      PARTICULAR PURPOSE. You are solely responsible for determining the\n+      appropriateness of using or redistributing the Work and assume any\n+      risks associated with Your exercise of permissions under this License.\n+\n+   8. Limitation of Liability. In no event and under no legal theory,\n+      whether in tort (including negligence), contract, or otherwise,\n+      unless required by applicable law (such as deliberate and grossly\n+      negligent acts) or agreed to in writing, shall any Contributor be\n+      liable to You for damages, including any direct, indirect, special,\n+      incidental, or consequential damages of any character arising as a\n+      result of this License or out of the use or inability to use the\n+      Work (including but not limited to damages for loss of goodwill,\n+      work stoppage, computer failure or malfunction, or any and all\n+      other commercial damages or losses), even if such Contributor\n+      has been advised of the possibility of such damages.\n+\n+   9. Accepting Warranty or Additional Liability. While redistributing\n+      the Work or Derivative Works thereof, You may choose to offer,\n+      and charge a fee for, acceptance of support, warranty, indemnity,\n+      or other liability obligations and/or rights consistent with this\n+      License. However, in accepting such obligations, You may act only\n+      on Your own behalf and on Your sole responsibility, not on behalf\n+      of any other Contributor, and only if You agree to indemnify,\n+      defend, and hold each Contributor harmless for any liability\n+      incurred by, or claims asserted against, such Contributor by reason\n+      of your accepting any such warranty or additional liability.\n+\n+   END OF TERMS AND CONDITIONS\n+\n+   APPENDIX: How to apply the Apache License to your work.\n+\n+      To apply the Apache License to your work, attach the following\n+      boilerplate notice, with the fields enclosed by brackets \"[]\"\n+      replaced with your own identifying information. (Don't include\n+      the brackets!)  The text should be enclosed in the appropriate\n+      comment syntax for the file format. We also recommend that a\n+      file or class name and description of purpose be included on the\n+      same \"printed page\" as the copyright notice for easier\n+      identification within third-party archives.\n+\n+   Copyright [yyyy] [name of copyright owner]\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n"
    },
    {
        "commit_hash": "f97cd5919715a07f29d0ce21932af571361fd7a2",
        "previous_commit_hash": "2bcea70f2f0d56902549e9b168c73625a3113bb0",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -3,8 +3,8 @@\n   <component name=\"NewModuleRootManager\" inherit-compiler-output=\"false\">\n     <output url=\"file://$MODULE_DIR$/target/classes\" />\n     <output-test url=\"file://$MODULE_DIR$/target/test-classes\" />\n-    <exclude-output />\n     <content url=\"file://$MODULE_DIR$\">\n+      <sourceFolder url=\"file://$MODULE_DIR$/src/test/java\" isTestSource=\"true\" />\n       <excludeFolder url=\"file://$MODULE_DIR$/target\" />\n     </content>\n     <orderEntry type=\"inheritedJdk\" />\n"
    },
    {
        "commit_hash": "f97cd5919715a07f29d0ce21932af571361fd7a2",
        "previous_commit_hash": "2bcea70f2f0d56902549e9b168c73625a3113bb0",
        "diff_stats": {
            "additions": 21,
            "deletions": 0
        },
        "diff_content": "@@ -25,6 +25,27 @@\n                 </configuration>\n             </plugin>\n \n+            <!-- Run tests using Java 7 (but compile with Java 8) -->\n+\n+            <plugin>\n+                <artifactId>maven-surefire-plugin</artifactId>\n+                <configuration>\n+                    <skipTests>true</skipTests>\n+                </configuration>\n+            </plugin>\n+\n+            <plugin>\n+                <artifactId>maven-failsafe-plugin</artifactId>\n+                <executions>\n+                    <execution>\n+                        <goals>\n+                            <goal>integration-test</goal>\n+                            <goal>verify</goal>\n+                        </goals>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+\n         </plugins>\n     </build>\n \n"
    },
    {
        "commit_hash": "f97cd5919715a07f29d0ce21932af571361fd7a2",
        "previous_commit_hash": "2bcea70f2f0d56902549e9b168c73625a3113bb0",
        "diff_stats": {
            "additions": 22,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,22 @@\n+// Copyright \u00a9 2013 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.test;\n+\n+import org.junit.Test;\n+\n+import java.util.concurrent.Callable;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+\n+public class LambdaTest {\n+\n+    @Test\n+    public void lambda_returning_value() throws Exception {\n+        Callable<String> lambda = () -> \"some value\";\n+\n+        assertThat(lambda.call(), is(\"some value\"));\n+    }\n+}\n"
    },
    {
        "commit_hash": "f97cd5919715a07f29d0ce21932af571361fd7a2",
        "previous_commit_hash": "2bcea70f2f0d56902549e9b168c73625a3113bb0",
        "diff_stats": {
            "additions": 33,
            "deletions": 6
        },
        "diff_content": "@@ -7,6 +7,7 @@\n         <groupId>org.sonatype.oss</groupId>\n         <artifactId>oss-parent</artifactId>\n         <version>7</version>\n+        <relativePath/>\n     </parent>\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n@@ -121,6 +122,8 @@\n                 <configuration>\n                     <source>1.8</source>\n                     <target>1.8</target>\n+                    <fork>true</fork>\n+                    <executable>${env.JAVA8_HOME}/bin/javac</executable>\n                 </configuration>\n             </plugin>\n \n@@ -131,6 +134,18 @@\n                         <include>**/*Test.class</include>\n                     </includes>\n                     <redirectTestOutputToFile>true</redirectTestOutputToFile>\n+                    <jvm>${env.JAVA8_HOME}/bin/java</jvm>\n+                </configuration>\n+            </plugin>\n+\n+            <plugin>\n+                <artifactId>maven-failsafe-plugin</artifactId>\n+                <configuration>\n+                    <includes>\n+                        <include>**/*Test.class</include>\n+                    </includes>\n+                    <redirectTestOutputToFile>true</redirectTestOutputToFile>\n+                    <jvm>${env.JAVA7_HOME}/bin/java</jvm>\n                 </configuration>\n             </plugin>\n \n@@ -148,6 +163,7 @@\n \n             <plugin>\n                 <artifactId>maven-enforcer-plugin</artifactId>\n+                <version>1.3.1</version>\n                 <executions>\n                     <execution>\n                         <!-- XXX: Using a different ID than in oss-parent to avoid overriding its checks by accident. See https://issues.sonatype.org/browse/OSSRH-2004 -->\n@@ -163,6 +179,22 @@\n                             </rules>\n                         </configuration>\n                     </execution>\n+                    <execution>\n+                        <id>enforce-multiple-java-versions</id>\n+                        <goals>\n+                            <goal>enforce</goal>\n+                        </goals>\n+                        <configuration>\n+                            <rules>\n+                                <requireEnvironmentVariable>\n+                                    <variableName>JAVA7_HOME</variableName>\n+                                </requireEnvironmentVariable>\n+                                <requireEnvironmentVariable>\n+                                    <variableName>JAVA8_HOME</variableName>\n+                                </requireEnvironmentVariable>\n+                            </rules>\n+                        </configuration>\n+                    </execution>\n                 </executions>\n             </plugin>\n \n@@ -199,7 +231,7 @@\n \n                 <plugin>\n                     <artifactId>maven-compiler-plugin</artifactId>\n-                    <version>2.5</version>\n+                    <version>3.1</version>\n                 </plugin>\n \n                 <plugin>\n@@ -254,11 +286,6 @@\n                     </configuration>\n                 </plugin>\n \n-                <plugin>\n-                    <artifactId>maven-enforcer-plugin</artifactId>\n-                    <version>1.1</version>\n-                </plugin>\n-\n                 <plugin>\n                     <artifactId>maven-surefire-plugin</artifactId>\n                     <version>2.12.3</version>\n"
    },
    {
        "commit_hash": "54de14326fb2c3ac94742bd632bdb4cb38c7ee2f",
        "previous_commit_hash": "f97cd5919715a07f29d0ce21932af571361fd7a2",
        "diff_stats": {
            "additions": 8,
            "deletions": 1
        },
        "diff_content": "@@ -1,3 +1,10 @@\n <component name=\"ProjectDictionaryState\">\n-  <dictionary name=\"ORFJackal\" />\n+  <dictionary name=\"ORFJackal\">\n+    <words>\n+      <w>backport</w>\n+      <w>backporter</w>\n+      <w>bytecode</w>\n+      <w>retrolambda</w>\n+    </words>\n+  </dictionary>\n </component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "54de14326fb2c3ac94742bd632bdb4cb38c7ee2f",
        "previous_commit_hash": "f97cd5919715a07f29d0ce21932af571361fd7a2",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,13 @@\n+<component name=\"libraryTable\">\n+  <library name=\"Maven: org.ow2.asm:asm-debug-all:4.1\">\n+    <CLASSES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm-debug-all/4.1/asm-debug-all-4.1.jar!/\" />\n+    </CLASSES>\n+    <JAVADOC>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm-debug-all/4.1/asm-debug-all-4.1-javadoc.jar!/\" />\n+    </JAVADOC>\n+    <SOURCES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm-debug-all/4.1/asm-debug-all-4.1-sources.jar!/\" />\n+    </SOURCES>\n+  </library>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "54de14326fb2c3ac94742bd632bdb4cb38c7ee2f",
        "previous_commit_hash": "f97cd5919715a07f29d0ce21932af571361fd7a2",
        "diff_stats": {
            "additions": 24,
            "deletions": 0
        },
        "diff_content": "@@ -46,6 +46,30 @@\n                 </executions>\n             </plugin>\n \n+            <!-- Process our byte codes to make them run on Java 7 -->\n+\n+            <plugin>\n+                <artifactId>maven-antrun-plugin</artifactId>\n+                <executions>\n+                    <execution>\n+                        <id>process-test-classes</id>\n+                        <phase>process-test-classes</phase>\n+                        <goals>\n+                            <goal>run</goal>\n+                        </goals>\n+                        <configuration>\n+                            <target>\n+                                <exec executable=\"${env.JAVA8_HOME}/bin/java\" failonerror=\"true\">\n+                                    <arg value=\"-jar\"/>\n+                                    <arg value=\"../retrolambda/target/retrolambda-${project.version}.jar\"/>\n+                                    <arg value=\"${project.build.testOutputDirectory}\"/>\n+                                </exec>\n+                            </target>\n+                        </configuration>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+\n         </plugins>\n     </build>\n \n"
    },
    {
        "commit_hash": "54de14326fb2c3ac94742bd632bdb4cb38c7ee2f",
        "previous_commit_hash": "f97cd5919715a07f29d0ce21932af571361fd7a2",
        "diff_stats": {
            "additions": 4,
            "deletions": 3
        },
        "diff_content": "@@ -81,7 +81,7 @@\n             <dependency>\n                 <groupId>org.ow2.asm</groupId>\n                 <artifactId>asm-debug-all</artifactId>\n-                <version>4.0</version>\n+                <version>4.1</version>\n             </dependency>\n \n             <!-- Testing -->\n@@ -276,9 +276,10 @@\n \n                 <plugin>\n                     <artifactId>maven-shade-plugin</artifactId>\n-                    <version>2.0</version>\n+                    <version>2.1</version>\n                     <configuration>\n-                        <minimizeJar>true</minimizeJar>\n+                        <!-- XXX: we cannot relocate the classes or minimize the JAR, because the shade plugin doesn't yet support Java 8 -->\n+                        <!--<minimizeJar>true</minimizeJar>-->\n                         <!-- Keep the generated POM file out of the base directory -->\n                         <dependencyReducedPomLocation>\n                             ${project.build.directory}/dependency-reduced-pom.xml\n"
    },
    {
        "commit_hash": "54de14326fb2c3ac94742bd632bdb4cb38c7ee2f",
        "previous_commit_hash": "f97cd5919715a07f29d0ce21932af571361fd7a2",
        "diff_stats": {
            "additions": 26,
            "deletions": 0
        },
        "diff_content": "@@ -13,6 +13,15 @@\n     <artifactId>retrolambda</artifactId>\n     <packaging>jar</packaging>\n \n+    <dependencies>\n+\n+        <dependency>\n+            <groupId>org.ow2.asm</groupId>\n+            <artifactId>asm-debug-all</artifactId>\n+        </dependency>\n+\n+    </dependencies>\n+\n     <build>\n         <plugins>\n \n@@ -21,6 +30,9 @@\n                 <artifactId>maven-jar-plugin</artifactId>\n                 <configuration>\n                     <archive>\n+                        <manifest>\n+                            <mainClass>net.orfjackal.retrolambda.Main</mainClass>\n+                        </manifest>\n                         <manifestEntries>\n                             <Premain-Class>net.orfjackal.retrolambda.SpikeAgent</Premain-Class>\n                         </manifestEntries>\n@@ -28,6 +40,20 @@\n                 </configuration>\n             </plugin>\n \n+            <!-- Create an uber jar containing all dependencies -->\n+            <!-- XXX: we cannot relocate the classes or minimize the JAR, because the shade plugin doesn't yet support Java 8 -->\n+\n+            <plugin>\n+                <artifactId>maven-shade-plugin</artifactId>\n+                <executions>\n+                    <execution>\n+                        <goals>\n+                            <goal>shade</goal>\n+                        </goals>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+\n         </plugins>\n     </build>\n \n"
    },
    {
        "commit_hash": "54de14326fb2c3ac94742bd632bdb4cb38c7ee2f",
        "previous_commit_hash": "f97cd5919715a07f29d0ce21932af571361fd7a2",
        "diff_stats": {
            "additions": 2,
            "deletions": 1
        },
        "diff_content": "@@ -7,8 +7,9 @@\n       <sourceFolder url=\"file://$MODULE_DIR$/src/main/java\" isTestSource=\"false\" />\n       <excludeFolder url=\"file://$MODULE_DIR$/target\" />\n     </content>\n-    <orderEntry type=\"jdk\" jdkName=\"1.8\" jdkType=\"JavaSDK\" />\n+    <orderEntry type=\"inheritedJdk\" />\n     <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.ow2.asm:asm-debug-all:4.1\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.11\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-library:1.3\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-core:1.3\" level=\"project\" />\n"
    },
    {
        "commit_hash": "54de14326fb2c3ac94742bd632bdb4cb38c7ee2f",
        "previous_commit_hash": "f97cd5919715a07f29d0ce21932af571361fd7a2",
        "diff_stats": {
            "additions": 29,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,29 @@\n+// Copyright \u00a9 2013 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda;\n+\n+import java.io.IOException;\n+import java.nio.file.*;\n+import java.nio.file.attribute.BasicFileAttributes;\n+\n+public abstract class BytecodeTransformingFileVisitor extends SimpleFileVisitor<Path> {\n+\n+    @Override\n+    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n+        if (isJavaClass(file)) {\n+            System.out.println(file);\n+            byte[] originalBytes = Files.readAllBytes(file);\n+            byte[] transformedBytes = transform(originalBytes);\n+            Files.write(file, transformedBytes);\n+        }\n+        return FileVisitResult.CONTINUE;\n+    }\n+\n+    protected abstract byte[] transform(byte[] bytecode);\n+\n+    private static boolean isJavaClass(Path file) {\n+        return file.getFileName().toString().endsWith(\".class\");\n+    }\n+}\n"
    },
    {
        "commit_hash": "54de14326fb2c3ac94742bd632bdb4cb38c7ee2f",
        "previous_commit_hash": "f97cd5919715a07f29d0ce21932af571361fd7a2",
        "diff_stats": {
            "additions": 43,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,43 @@\n+// Copyright \u00a9 2013 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda;\n+\n+import org.objectweb.asm.*;\n+\n+import java.nio.ByteBuffer;\n+\n+public class LambdaBackporter {\n+\n+    private static final int JAVA_8_BYTECODE_VERSION = 52;\n+    private static final int MAJOR_VERSION_OFFSET = 6;\n+\n+    public static byte[] transform(byte[] bytecode) {\n+        asmJava8SupportWorkaround(bytecode);\n+        ClassWriter writer = new ClassWriter(0);\n+        new ClassReader(bytecode).accept(new MyClassVisitor(writer), 0);\n+        return writer.toByteArray();\n+    }\n+\n+    private static void asmJava8SupportWorkaround(byte[] bytecode) {\n+        ByteBuffer buffer = ByteBuffer.wrap(bytecode);\n+        short majorVersion = buffer.getShort(MAJOR_VERSION_OFFSET);\n+\n+        if (majorVersion == JAVA_8_BYTECODE_VERSION) {\n+            // XXX: ASM doesn't yet support Java 8, so we must fake the data to be from Java 7\n+            buffer.putShort(MAJOR_VERSION_OFFSET, (short) (majorVersion - 1));\n+            // TODO: once we can remove this workaround, make our ClassVisitor responsible for setting the bytecode version\n+\n+        } else if (majorVersion > JAVA_8_BYTECODE_VERSION) {\n+            throw new IllegalArgumentException(\"Only Java 8 and lower is supported, but bytecode version was \" + majorVersion);\n+        }\n+    }\n+\n+    private static class MyClassVisitor extends ClassVisitor {\n+\n+        public MyClassVisitor(ClassWriter cw) {\n+            super(Opcodes.ASM4, cw);\n+        }\n+    }\n+}\n"
    },
    {
        "commit_hash": "54de14326fb2c3ac94742bd632bdb4cb38c7ee2f",
        "previous_commit_hash": "f97cd5919715a07f29d0ce21932af571361fd7a2",
        "diff_stats": {
            "additions": 38,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,38 @@\n+// Copyright \u00a9 2013 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda;\n+\n+import java.io.*;\n+import java.nio.file.*;\n+import java.util.Properties;\n+\n+public class Main {\n+\n+    public static void main(String[] args) throws IOException {\n+        System.out.println(\"Retrolambda \" + getVersion());\n+\n+        Path classesDir = Paths.get(args[0]);\n+        if (!Files.isDirectory(classesDir)) {\n+            System.out.println(\"Nothing to do; not a directory: \" + classesDir);\n+            return;\n+        }\n+\n+        Files.walkFileTree(classesDir, new BytecodeTransformingFileVisitor() {\n+            protected byte[] transform(byte[] bytecode) {\n+                return LambdaBackporter.transform(bytecode);\n+            }\n+        });\n+    }\n+\n+    private static String getVersion() throws IOException {\n+        Properties p = new Properties();\n+        try (InputStream in = ClassLoader.getSystemResourceAsStream(\"META-INF/maven/net.orfjackal.retrolambda/retrolambda/pom.properties\")) {\n+            if (in != null) {\n+                p.load(in);\n+            }\n+        }\n+        return p.getProperty(\"version\", \"DEVELOPMENT-VERSION\");\n+    }\n+}\n"
    },
    {
        "commit_hash": "cae2be8c38994e7678845cb7aaa2d0dc18284743",
        "previous_commit_hash": "54de14326fb2c3ac94742bd632bdb4cb38c7ee2f",
        "diff_stats": {
            "additions": 1,
            "deletions": 6
        },
        "diff_content": "@@ -20,12 +20,7 @@\n         <module name=\"retrolambda-runtime (1)\" />\n       </profile>\n     </annotationProcessing>\n-    <bytecodeTargetLevel>\n-      <module name=\"end-to-end-tests\" target=\"1.8\" />\n-      <module name=\"parent\" target=\"1.8\" />\n-      <module name=\"project\" target=\"1.8\" />\n-      <module name=\"retrolambda\" target=\"1.8\" />\n-    </bytecodeTargetLevel>\n+    <bytecodeTargetLevel target=\"1.8\" />\n   </component>\n </project>\n \n"
    },
    {
        "commit_hash": "cae2be8c38994e7678845cb7aaa2d0dc18284743",
        "previous_commit_hash": "54de14326fb2c3ac94742bd632bdb4cb38c7ee2f",
        "diff_stats": {
            "additions": 29,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,29 @@\n+<component name=\"ProjectRunConfigurationManager\">\n+  <configuration default=\"false\" name=\"End-to-end tests\" type=\"MavenRunConfiguration\" factoryName=\"Maven\">\n+    <MavenSettings>\n+      <option name=\"myGeneralSettings\" />\n+      <option name=\"myRunnerSettings\" />\n+      <option name=\"myRunnerParameters\">\n+        <MavenRunnerParameters>\n+          <option name=\"profiles\">\n+            <set />\n+          </option>\n+          <option name=\"goals\">\n+            <list>\n+              <option value=\"clean\" />\n+              <option value=\"verify\" />\n+            </list>\n+          </option>\n+          <option name=\"profilesMap\">\n+            <map />\n+          </option>\n+          <option name=\"resolveToWorkspace\" value=\"false\" />\n+          <option name=\"workingDirPath\" value=\"$PROJECT_DIR$\" />\n+        </MavenRunnerParameters>\n+      </option>\n+    </MavenSettings>\n+    <RunnerSettings RunnerId=\"Run\" />\n+    <ConfigurationWrapper RunnerId=\"Run\" />\n+    <method />\n+  </configuration>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "cae2be8c38994e7678845cb7aaa2d0dc18284743",
        "previous_commit_hash": "54de14326fb2c3ac94742bd632bdb4cb38c7ee2f",
        "diff_stats": {
            "additions": 7,
            "deletions": 2
        },
        "diff_content": "@@ -59,9 +59,14 @@\n                         </goals>\n                         <configuration>\n                             <target>\n+                                <property name=\"test_classpath\" refid=\"maven.test.classpath\"/>\n                                 <exec executable=\"${env.JAVA8_HOME}/bin/java\" failonerror=\"true\">\n-                                    <arg value=\"-jar\"/>\n-                                    <arg value=\"../retrolambda/target/retrolambda-${project.version}.jar\"/>\n+                                    <arg value=\"-cp\"/>\n+                                    <arg value=\"../retrolambda/target/retrolambda-${project.version}.jar${path.separator}${test_classpath}\"/>\n+                                    <!-- XXX: using -jar overrides any -cp or CLASSPATH env var; try adding a custom property? -->\n+                                    <!--<arg value=\"-jar\"/>-->\n+                                    <!--<arg value=\"../retrolambda/target/retrolambda-${project.version}.jar\"/>-->\n+                                    <arg value=\"net.orfjackal.retrolambda.Main\"/>\n                                     <arg value=\"${project.build.testOutputDirectory}\"/>\n                                 </exec>\n                             </target>\n"
    },
    {
        "commit_hash": "cae2be8c38994e7678845cb7aaa2d0dc18284743",
        "previous_commit_hash": "54de14326fb2c3ac94742bd632bdb4cb38c7ee2f",
        "diff_stats": {
            "additions": 113,
            "deletions": 0
        },
        "diff_content": "@@ -6,7 +6,10 @@ package net.orfjackal.retrolambda;\n \n import org.objectweb.asm.*;\n \n+import java.lang.invoke.*;\n+import java.lang.reflect.Constructor;\n import java.nio.ByteBuffer;\n+import java.util.*;\n \n public class LambdaBackporter {\n \n@@ -35,9 +38,119 @@ public class LambdaBackporter {\n     }\n \n     private static class MyClassVisitor extends ClassVisitor {\n+        private String myClassName;\n \n         public MyClassVisitor(ClassWriter cw) {\n             super(Opcodes.ASM4, cw);\n         }\n+\n+        @Override\n+        public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n+            super.visit(version, access, name, signature, superName, interfaces);\n+            this.myClassName = name;\n+        }\n+\n+        @Override\n+        public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+            MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n+            return new InvokeDynamicInsnConvertingMethodVisitor(api, mv, myClassName);\n+        }\n+    }\n+\n+    private static class InvokeDynamicInsnConvertingMethodVisitor extends MethodVisitor {\n+        private final String myClassName;\n+\n+        public InvokeDynamicInsnConvertingMethodVisitor(int api, MethodVisitor mv, String myClassName) {\n+            super(api, mv);\n+            this.myClassName = myClassName;\n+        }\n+\n+        @Override\n+        public void visitInvokeDynamicInsn(String name, String desc, Handle bsm, Object... bsmArgs) {\n+            // TODO: remove debug code\n+            System.out.println(\"visitInvokeDynamicInsn\\n\" +\n+                    \"\\t\" + name + \"\\n\" +\n+                    \"\\t\" + desc + \"\\n\" +\n+                    \"\\t\" + bsm + \"\\n\" +\n+                    \"\\t\" + Arrays.toString(bsmArgs));\n+            System.out.println(\"bsm.getDesc() = \" + bsm.getDesc());\n+            System.out.println(\"bsm.getName() = \" + bsm.getName());\n+            System.out.println(\"bsm.getOwner() = \" + bsm.getOwner());\n+            System.out.println(\"bsm.getTag() = \" + bsm.getTag());\n+\n+            if (bsm.getOwner().equals(\"java/lang/invoke/LambdaMetafactory\")) {\n+                backportLambda(name, Type.getType(desc), bsm, bsmArgs);\n+            } else {\n+                super.visitInvokeDynamicInsn(name, desc, bsm, bsmArgs);\n+            }\n+        }\n+\n+        private void backportLambda(String invokedName, Type invokedType, Handle bsm, Object[] bsmArgs) {\n+            try {\n+                Class<?> invoker = Class.forName(myClassName.replace('/', '.'));\n+                callBootstrapMethod(invoker, invokedName, invokedType, bsm, bsmArgs);\n+\n+                // TODO: find out the name of the generated class and call it here\n+                super.visitMethodInsn(Opcodes.INVOKESPECIAL, \"com/example/Placeholder\", \"<init>\", \"()V\");\n+\n+            } catch (Throwable t) {\n+                throw new RuntimeException(t);\n+            }\n+        }\n+\n+        private CallSite callBootstrapMethod(Class<?> invoker, String invokedName, Type invokedType, Handle bsm, Object[] bsmArgs) throws Throwable {\n+            ClassLoader cl = invoker.getClassLoader();\n+            MethodHandles.Lookup caller = getLookup(invoker);\n+\n+            List<Object> args = new ArrayList<>();\n+            args.add(caller);\n+            args.add(invokedName);\n+            args.add(toMethodType(invokedType, cl));\n+            for (Object arg : bsmArgs) {\n+                args.add(asmToInvokerType(arg, cl, caller));\n+            }\n+\n+            MethodHandle bootstrapMethod = toMethodHandle(bsm, cl, caller);\n+            return (CallSite) bootstrapMethod.invokeWithArguments(args);\n+        }\n+    }\n+\n+    private static MethodHandles.Lookup getLookup(Class<?> targetClass) {\n+        try {\n+            Constructor<MethodHandles.Lookup> ctor = MethodHandles.Lookup.class.getDeclaredConstructor(Class.class);\n+            ctor.setAccessible(true);\n+            return ctor.newInstance(targetClass);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static Object asmToInvokerType(Object arg, ClassLoader classLoader, MethodHandles.Lookup caller) {\n+        if (arg instanceof Type) {\n+            return toMethodType((Type) arg, classLoader);\n+        } else if (arg instanceof Handle) {\n+            return toMethodHandle((Handle) arg, classLoader, caller);\n+        } else {\n+            return arg;\n+        }\n+    }\n+\n+    private static MethodType toMethodType(Type type, ClassLoader classLoader) {\n+        return MethodType.fromMethodDescriptorString(type.getInternalName(), classLoader);\n+    }\n+\n+    private static MethodHandle toMethodHandle(Handle handle, ClassLoader classLoader, MethodHandles.Lookup lookup) {\n+        try {\n+            MethodType type = MethodType.fromMethodDescriptorString(handle.getDesc(), classLoader);\n+            Class<?> owner = classLoader.loadClass(handle.getOwner().replace('/', '.'));\n+            if (handle.getTag() == Opcodes.H_INVOKESTATIC) {\n+                return lookup.findStatic(owner, handle.getName(), type);\n+            } else {\n+                throw new AssertionError(\"unexpected tag: \" + handle.getTag());\n+            }\n+\n+        } catch (ClassNotFoundException | NoSuchMethodException | IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n     }\n }\n"
    },
    {
        "commit_hash": "cae2be8c38994e7678845cb7aaa2d0dc18284743",
        "previous_commit_hash": "54de14326fb2c3ac94742bd632bdb4cb38c7ee2f",
        "diff_stats": {
            "additions": 16,
            "deletions": 7
        },
        "diff_content": "@@ -10,7 +10,7 @@ import java.util.Properties;\n \n public class Main {\n \n-    public static void main(String[] args) throws IOException {\n+    public static void main(String[] args) {\n         System.out.println(\"Retrolambda \" + getVersion());\n \n         Path classesDir = Paths.get(args[0]);\n@@ -19,19 +19,28 @@ public class Main {\n             return;\n         }\n \n-        Files.walkFileTree(classesDir, new BytecodeTransformingFileVisitor() {\n-            protected byte[] transform(byte[] bytecode) {\n-                return LambdaBackporter.transform(bytecode);\n-            }\n-        });\n+        try {\n+            Files.walkFileTree(classesDir, new BytecodeTransformingFileVisitor() {\n+                protected byte[] transform(byte[] bytecode) {\n+                    return LambdaBackporter.transform(bytecode);\n+                }\n+            });\n+\n+        } catch (Throwable t) {\n+            System.out.println(\"Error! Failed to transform some classes\");\n+            t.printStackTrace(System.out);\n+            System.exit(1);\n+        }\n     }\n \n-    private static String getVersion() throws IOException {\n+    private static String getVersion() {\n         Properties p = new Properties();\n         try (InputStream in = ClassLoader.getSystemResourceAsStream(\"META-INF/maven/net.orfjackal.retrolambda/retrolambda/pom.properties\")) {\n             if (in != null) {\n                 p.load(in);\n             }\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n         }\n         return p.getProperty(\"version\", \"DEVELOPMENT-VERSION\");\n     }\n"
    },
    {
        "commit_hash": "ecaedc28c9f80664385754174120f81f1ae96634",
        "previous_commit_hash": "cae2be8c38994e7678845cb7aaa2d0dc18284743",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -4,6 +4,7 @@\n       <w>backport</w>\n       <w>backporter</w>\n       <w>bytecode</w>\n+      <w>premain</w>\n       <w>retrolambda</w>\n     </words>\n   </dictionary>\n"
    },
    {
        "commit_hash": "ecaedc28c9f80664385754174120f81f1ae96634",
        "previous_commit_hash": "cae2be8c38994e7678845cb7aaa2d0dc18284743",
        "diff_stats": {
            "additions": 2,
            "deletions": 0
        },
        "diff_content": "@@ -61,6 +61,8 @@\n                             <target>\n                                 <property name=\"test_classpath\" refid=\"maven.test.classpath\"/>\n                                 <exec executable=\"${env.JAVA8_HOME}/bin/java\" failonerror=\"true\">\n+                                    <arg value=\"-Dretrolambda.inputDir=${project.build.testOutputDirectory}\"/>\n+                                    <arg value=\"-javaagent:../retrolambda/target/retrolambda-${project.version}.jar\"/>\n                                     <arg value=\"-cp\"/>\n                                     <arg value=\"../retrolambda/target/retrolambda-${project.version}.jar${path.separator}${test_classpath}\"/>\n                                     <!-- XXX: using -jar overrides any -cp or CLASSPATH env var; try adding a custom property? -->\n"
    },
    {
        "commit_hash": "ecaedc28c9f80664385754174120f81f1ae96634",
        "previous_commit_hash": "cae2be8c38994e7678845cb7aaa2d0dc18284743",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -34,7 +34,7 @@\n                             <mainClass>net.orfjackal.retrolambda.Main</mainClass>\n                         </manifest>\n                         <manifestEntries>\n-                            <Premain-Class>net.orfjackal.retrolambda.SpikeAgent</Premain-Class>\n+                            <Premain-Class>net.orfjackal.retrolambda.PreMain</Premain-Class>\n                         </manifestEntries>\n                     </archive>\n                 </configuration>\n"
    },
    {
        "commit_hash": "ecaedc28c9f80664385754174120f81f1ae96634",
        "previous_commit_hash": "cae2be8c38994e7678845cb7aaa2d0dc18284743",
        "diff_stats": {
            "additions": 16,
            "deletions": 5
        },
        "diff_content": "@@ -10,13 +10,24 @@ import java.nio.file.attribute.BasicFileAttributes;\n \n public abstract class BytecodeTransformingFileVisitor extends SimpleFileVisitor<Path> {\n \n+    private final Path inputDir;\n+    private final Path outputDir;\n+\n+    public BytecodeTransformingFileVisitor(Path inputDir, Path outputDir) {\n+        this.inputDir = inputDir;\n+        this.outputDir = outputDir;\n+    }\n+\n     @Override\n-    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n-        if (isJavaClass(file)) {\n-            System.out.println(file);\n-            byte[] originalBytes = Files.readAllBytes(file);\n+    public FileVisitResult visitFile(Path inputFile, BasicFileAttributes attrs) throws IOException {\n+        if (isJavaClass(inputFile)) {\n+            System.out.println(inputFile); // TODO: remove debug printing\n+            byte[] originalBytes = Files.readAllBytes(inputFile);\n             byte[] transformedBytes = transform(originalBytes);\n-            Files.write(file, transformedBytes);\n+\n+            Path outputFile = outputDir.resolve(inputDir.relativize(inputFile));\n+            Files.createDirectories(outputFile.getParent());\n+            Files.write(outputFile, transformedBytes);\n         }\n         return FileVisitResult.CONTINUE;\n     }\n"
    },
    {
        "commit_hash": "ecaedc28c9f80664385754174120f81f1ae96634",
        "previous_commit_hash": "cae2be8c38994e7678845cb7aaa2d0dc18284743",
        "diff_stats": {
            "additions": 36,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,36 @@\n+// Copyright \u00a9 2013 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda;\n+\n+import java.nio.file.*;\n+import java.util.Properties;\n+\n+public class Config {\n+\n+    private static final String INPUT_DIR = \"retrolambda.inputDir\";\n+    private static final String OUTPUT_DIR = \"retrolambda.outputDir\";\n+\n+    private final Properties p;\n+\n+    public Config(Properties p) {\n+        this.p = p;\n+    }\n+\n+    public Path getInputDir() {\n+        String inputDir = p.getProperty(INPUT_DIR);\n+        if (inputDir == null) {\n+            throw new IllegalArgumentException(\"Missing required property: \" + INPUT_DIR);\n+        }\n+        return Paths.get(inputDir);\n+    }\n+\n+    public Path getOutputDir() {\n+        String outputDir = p.getProperty(OUTPUT_DIR);\n+        if (outputDir == null) {\n+            return getInputDir();\n+        }\n+        return Paths.get(outputDir);\n+    }\n+}\n"
    },
    {
        "commit_hash": "ecaedc28c9f80664385754174120f81f1ae96634",
        "previous_commit_hash": "cae2be8c38994e7678845cb7aaa2d0dc18284743",
        "diff_stats": {
            "additions": 12,
            "deletions": 8
        },
        "diff_content": "@@ -8,22 +8,26 @@ import java.io.IOException;\n import java.lang.instrument.*;\n import java.nio.file.*;\n import java.security.ProtectionDomain;\n+import java.util.regex.Pattern;\n \n-public class SpikeAgent {\n-    public static void premain(String agentArgs, Instrumentation inst) {\n-        inst.addTransformer(new MyClassFileTransformer());\n+public class LambdaSavingClassFileTransformer implements ClassFileTransformer {\n+\n+    private static final Pattern LAMBDA_CLASS = Pattern.compile(\".+\\\\$\\\\$Lambda\\\\$\\\\d+$\");\n+\n+    private final Path outputDir;\n+\n+    public LambdaSavingClassFileTransformer(Path outputDir) {\n+        this.outputDir = outputDir;\n     }\n-}\n \n-class MyClassFileTransformer implements ClassFileTransformer {\n     @Override\n     public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {\n-        if (!className.contains(\"$$Lambda$\")) {\n+        if (!LAMBDA_CLASS.matcher(className).matches()) {\n             return null;\n         }\n         try {\n-            System.out.println(className);\n-            Path savePath = Paths.get(\"generated\", className + \".class\");\n+            System.out.println(\"Saving lambda class: \" + className);\n+            Path savePath = outputDir.resolve(className + \".class\");\n             Files.createDirectories(savePath.getParent());\n             Files.write(savePath, classfileBuffer);\n \n"
    },
    {
        "commit_hash": "ecaedc28c9f80664385754174120f81f1ae96634",
        "previous_commit_hash": "cae2be8c38994e7678845cb7aaa2d0dc18284743",
        "diff_stats": {
            "additions": 7,
            "deletions": 4
        },
        "diff_content": "@@ -13,14 +13,17 @@ public class Main {\n     public static void main(String[] args) {\n         System.out.println(\"Retrolambda \" + getVersion());\n \n-        Path classesDir = Paths.get(args[0]);\n-        if (!Files.isDirectory(classesDir)) {\n-            System.out.println(\"Nothing to do; not a directory: \" + classesDir);\n+        Config config = new Config(System.getProperties());\n+        Path inputDir = config.getInputDir();\n+        Path outputDir = config.getOutputDir();\n+\n+        if (!Files.isDirectory(inputDir)) {\n+            System.out.println(\"Nothing to do; not a directory: \" + inputDir);\n             return;\n         }\n \n         try {\n-            Files.walkFileTree(classesDir, new BytecodeTransformingFileVisitor() {\n+            Files.walkFileTree(inputDir, new BytecodeTransformingFileVisitor(inputDir, outputDir) {\n                 protected byte[] transform(byte[] bytecode) {\n                     return LambdaBackporter.transform(bytecode);\n                 }\n"
    },
    {
        "commit_hash": "ecaedc28c9f80664385754174120f81f1ae96634",
        "previous_commit_hash": "cae2be8c38994e7678845cb7aaa2d0dc18284743",
        "diff_stats": {
            "additions": 17,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,17 @@\n+// Copyright \u00a9 2013 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda;\n+\n+import java.lang.instrument.Instrumentation;\n+import java.nio.file.Path;\n+\n+public class PreMain {\n+\n+    public static void premain(String agentArgs, Instrumentation inst) {\n+        Config config = new Config(System.getProperties());\n+        Path outputDir = config.getOutputDir();\n+        inst.addTransformer(new LambdaSavingClassFileTransformer(outputDir));\n+    }\n+}\n"
    },
    {
        "commit_hash": "b9209f18e7c599537f0067e1cf123760137912c3",
        "previous_commit_hash": "ecaedc28c9f80664385754174120f81f1ae96634",
        "diff_stats": {
            "additions": 5,
            "deletions": 2
        },
        "diff_content": "@@ -89,9 +89,12 @@ public class LambdaBackporter {\n             try {\n                 Class<?> invoker = Class.forName(myClassName.replace('/', '.'));\n                 callBootstrapMethod(invoker, invokedName, invokedType, bsm, bsmArgs);\n+                String lambdaClass = LambdaSavingClassFileTransformer.getLastFoundLambdaClass();\n \n-                // TODO: find out the name of the generated class and call it here\n-                super.visitMethodInsn(Opcodes.INVOKESPECIAL, \"com/example/Placeholder\", \"<init>\", \"()V\");\n+                // TODO: constructor parameters for lambda\n+                super.visitTypeInsn(Opcodes.NEW, lambdaClass);\n+                super.visitInsn(Opcodes.DUP);\n+                super.visitMethodInsn(Opcodes.INVOKESPECIAL, lambdaClass, \"<init>\", \"()V\");\n \n             } catch (Throwable t) {\n                 throw new RuntimeException(t);\n"
    },
    {
        "commit_hash": "b9209f18e7c599537f0067e1cf123760137912c3",
        "previous_commit_hash": "ecaedc28c9f80664385754174120f81f1ae96634",
        "diff_stats": {
            "additions": 7,
            "deletions": 0
        },
        "diff_content": "@@ -8,18 +8,24 @@ import java.io.IOException;\n import java.lang.instrument.*;\n import java.nio.file.*;\n import java.security.ProtectionDomain;\n+import java.util.concurrent.*;\n import java.util.regex.Pattern;\n \n public class LambdaSavingClassFileTransformer implements ClassFileTransformer {\n \n     private static final Pattern LAMBDA_CLASS = Pattern.compile(\".+\\\\$\\\\$Lambda\\\\$\\\\d+$\");\n \n+    private static final BlockingDeque<String> foundLambdaClasses = new LinkedBlockingDeque<>(1); // we expect only one at a time\n     private final Path outputDir;\n \n     public LambdaSavingClassFileTransformer(Path outputDir) {\n         this.outputDir = outputDir;\n     }\n \n+    public static String getLastFoundLambdaClass() {\n+        return foundLambdaClasses.pop();\n+    }\n+\n     @Override\n     public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {\n         if (!LAMBDA_CLASS.matcher(className).matches()) {\n@@ -27,6 +33,7 @@ public class LambdaSavingClassFileTransformer implements ClassFileTransformer {\n         }\n         try {\n             System.out.println(\"Saving lambda class: \" + className);\n+            foundLambdaClasses.push(className);\n             Path savePath = outputDir.resolve(className + \".class\");\n             Files.createDirectories(savePath.getParent());\n             Files.write(savePath, classfileBuffer);\n"
    },
    {
        "commit_hash": "0f53af7fbc56cd8dce4fa36c1f4006fecc6980e2",
        "previous_commit_hash": "b9209f18e7c599537f0067e1cf123760137912c3",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@ import java.lang.reflect.Constructor;\n import java.nio.ByteBuffer;\n import java.util.*;\n \n-public class LambdaBackporter {\n+public class LambdaUsageBackporter {\n \n     private static final int JAVA_8_BYTECODE_VERSION = 52;\n     private static final int MAJOR_VERSION_OFFSET = 6;\n"
    },
    {
        "commit_hash": "0f53af7fbc56cd8dce4fa36c1f4006fecc6980e2",
        "previous_commit_hash": "b9209f18e7c599537f0067e1cf123760137912c3",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -25,7 +25,7 @@ public class Main {\n         try {\n             Files.walkFileTree(inputDir, new BytecodeTransformingFileVisitor(inputDir, outputDir) {\n                 protected byte[] transform(byte[] bytecode) {\n-                    return LambdaBackporter.transform(bytecode);\n+                    return LambdaUsageBackporter.transform(bytecode);\n                 }\n             });\n \n"
    },
    {
        "commit_hash": "8c28c871d8d58cfc26422dedc89c1053adf2992c",
        "previous_commit_hash": "0f53af7fbc56cd8dce4fa36c1f4006fecc6980e2",
        "diff_stats": {
            "additions": 69,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,69 @@\n+// Copyright \u00a9 2013 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda;\n+\n+import org.objectweb.asm.*;\n+\n+public class LambdaClassBackporter {\n+\n+    private static final String MAGIC_LAMBDA_IMPL = \"java/lang/invoke/MagicLambdaImpl\";\n+    private static final String JAVA_LANG_OBJECT = \"java/lang/Object\";\n+\n+    public static byte[] transform(byte[] bytecode) {\n+        ClassWriter writer = new ClassWriter(0);\n+        new ClassReader(bytecode).accept(new MyClassVisitor(writer), 0);\n+        return writer.toByteArray();\n+    }\n+\n+    private static class MyClassVisitor extends ClassVisitor {\n+\n+        public MyClassVisitor(ClassWriter cw) {\n+            super(Opcodes.ASM4, cw);\n+        }\n+\n+        @Override\n+        public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n+            if (superName.equals(MAGIC_LAMBDA_IMPL)) {\n+                superName = JAVA_LANG_OBJECT;\n+            }\n+            super.visit(version, access, name, signature, superName, interfaces);\n+        }\n+\n+        @Override\n+        public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+            if (name.equals(\"<init>\") && hasFlag(access, Opcodes.ACC_PRIVATE)) {\n+                access = clearFlag(access, Opcodes.ACC_PRIVATE); // make package-private (i.e. no flag)\n+            }\n+            MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n+            return new MagicLambdaRemovingMethodVisitor(mv);\n+        }\n+    }\n+\n+    private static class MagicLambdaRemovingMethodVisitor extends MethodVisitor {\n+\n+        public MagicLambdaRemovingMethodVisitor(MethodVisitor mv) {\n+            super(Opcodes.ASM4, mv);\n+        }\n+\n+        @Override\n+        public void visitMethodInsn(int opcode, String owner, String name, String desc) {\n+            if (opcode == Opcodes.INVOKESPECIAL\n+                    && owner.equals(MAGIC_LAMBDA_IMPL)\n+                    && name.equals(\"<init>\")\n+                    && desc.equals(\"()V\")) {\n+                owner = JAVA_LANG_OBJECT;\n+            }\n+            super.visitMethodInsn(opcode, owner, name, desc);\n+        }\n+    }\n+\n+    private static boolean hasFlag(int subject, int flag) {\n+        return (subject & flag) == flag;\n+    }\n+\n+    private static int clearFlag(int subject, int flag) {\n+        return subject & ~flag;\n+    }\n+}\n"
    },
    {
        "commit_hash": "8c28c871d8d58cfc26422dedc89c1053adf2992c",
        "previous_commit_hash": "0f53af7fbc56cd8dce4fa36c1f4006fecc6980e2",
        "diff_stats": {
            "additions": 2,
            "deletions": 1
        },
        "diff_content": "@@ -34,9 +34,10 @@ public class LambdaSavingClassFileTransformer implements ClassFileTransformer {\n         try {\n             System.out.println(\"Saving lambda class: \" + className);\n             foundLambdaClasses.push(className);\n+            byte[] transformedBytes = LambdaClassBackporter.transform(classfileBuffer);\n             Path savePath = outputDir.resolve(className + \".class\");\n             Files.createDirectories(savePath.getParent());\n-            Files.write(savePath, classfileBuffer);\n+            Files.write(savePath, transformedBytes);\n \n         } catch (IOException e) {\n             e.printStackTrace();\n"
    },
    {
        "commit_hash": "22624e4e92159ad288edd3b6fdc729e8e8d50fb7",
        "previous_commit_hash": "8c28c871d8d58cfc26422dedc89c1053adf2992c",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -4,6 +4,7 @@\n       <w>backport</w>\n       <w>backporter</w>\n       <w>bytecode</w>\n+      <w>metafactory</w>\n       <w>premain</w>\n       <w>retrolambda</w>\n     </words>\n"
    },
    {
        "commit_hash": "22624e4e92159ad288edd3b6fdc729e8e8d50fb7",
        "previous_commit_hash": "8c28c871d8d58cfc26422dedc89c1053adf2992c",
        "diff_stats": {
            "additions": 25,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,25 @@\n+// Copyright \u00a9 2013 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda;\n+\n+import org.objectweb.asm.Opcodes;\n+\n+public class Flags {\n+\n+    public static int makeNonPrivate(int access) {\n+        if (hasFlag(access, Opcodes.ACC_PRIVATE)) {\n+            return clearFlag(access, Opcodes.ACC_PRIVATE); // make package-private (i.e. no flag)\n+        }\n+        return access;\n+    }\n+\n+    public static boolean hasFlag(int subject, int flag) {\n+        return (subject & flag) == flag;\n+    }\n+\n+    public static int clearFlag(int subject, int flag) {\n+        return subject & ~flag;\n+    }\n+}\n"
    },
    {
        "commit_hash": "22624e4e92159ad288edd3b6fdc729e8e8d50fb7",
        "previous_commit_hash": "8c28c871d8d58cfc26422dedc89c1053adf2992c",
        "diff_stats": {
            "additions": 2,
            "deletions": 10
        },
        "diff_content": "@@ -33,8 +33,8 @@ public class LambdaClassBackporter {\n \n         @Override\n         public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n-            if (name.equals(\"<init>\") && hasFlag(access, Opcodes.ACC_PRIVATE)) {\n-                access = clearFlag(access, Opcodes.ACC_PRIVATE); // make package-private (i.e. no flag)\n+            if (name.equals(\"<init>\")) {\n+                access = Flags.makeNonPrivate(access);\n             }\n             MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n             return new MagicLambdaRemovingMethodVisitor(mv);\n@@ -58,12 +58,4 @@ public class LambdaClassBackporter {\n             super.visitMethodInsn(opcode, owner, name, desc);\n         }\n     }\n-\n-    private static boolean hasFlag(int subject, int flag) {\n-        return (subject & flag) == flag;\n-    }\n-\n-    private static int clearFlag(int subject, int flag) {\n-        return subject & ~flag;\n-    }\n }\n"
    },
    {
        "commit_hash": "22624e4e92159ad288edd3b6fdc729e8e8d50fb7",
        "previous_commit_hash": "8c28c871d8d58cfc26422dedc89c1053adf2992c",
        "diff_stats": {
            "additions": 8,
            "deletions": 1
        },
        "diff_content": "@@ -10,12 +10,16 @@ import java.lang.invoke.*;\n import java.lang.reflect.Constructor;\n import java.nio.ByteBuffer;\n import java.util.*;\n+import java.util.regex.Pattern;\n \n public class LambdaUsageBackporter {\n \n     private static final int JAVA_8_BYTECODE_VERSION = 52;\n     private static final int MAJOR_VERSION_OFFSET = 6;\n \n+    private static final String LAMBDA_METAFACTORY = \"java/lang/invoke/LambdaMetafactory\";\n+    private static final Pattern LAMBDA_IMPL_METHOD = Pattern.compile(\"^lambda\\\\$\\\\d+$\");\n+\n     public static byte[] transform(byte[] bytecode) {\n         asmJava8SupportWorkaround(bytecode);\n         ClassWriter writer = new ClassWriter(0);\n@@ -52,6 +56,9 @@ public class LambdaUsageBackporter {\n \n         @Override\n         public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+            if (LAMBDA_IMPL_METHOD.matcher(name).matches()) {\n+                access = Flags.makeNonPrivate(access);\n+            }\n             MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n             return new InvokeDynamicInsnConvertingMethodVisitor(api, mv, myClassName);\n         }\n@@ -78,7 +85,7 @@ public class LambdaUsageBackporter {\n             System.out.println(\"bsm.getOwner() = \" + bsm.getOwner());\n             System.out.println(\"bsm.getTag() = \" + bsm.getTag());\n \n-            if (bsm.getOwner().equals(\"java/lang/invoke/LambdaMetafactory\")) {\n+            if (bsm.getOwner().equals(LAMBDA_METAFACTORY)) {\n                 backportLambda(name, Type.getType(desc), bsm, bsmArgs);\n             } else {\n                 super.visitInvokeDynamicInsn(name, desc, bsm, bsmArgs);\n"
    },
    {
        "commit_hash": "1b5c4cdeb6f9424f2666efeb98a9faddf394fb39",
        "previous_commit_hash": "22624e4e92159ad288edd3b6fdc729e8e8d50fb7",
        "diff_stats": {
            "additions": 8,
            "deletions": 0
        },
        "diff_content": "@@ -19,4 +19,12 @@ public class LambdaTest {\n \n         assertThat(lambda.call(), is(\"some value\"));\n     }\n+\n+    @Test\n+    public void lambda_returning_nothing() {\n+        Runnable lambda = () -> {\n+        };\n+\n+        lambda.run();\n+    }\n }\n"
    },
    {
        "commit_hash": "1b5c4cdeb6f9424f2666efeb98a9faddf394fb39",
        "previous_commit_hash": "22624e4e92159ad288edd3b6fdc729e8e8d50fb7",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -22,7 +22,7 @@ public class LambdaUsageBackporter {\n \n     public static byte[] transform(byte[] bytecode) {\n         asmJava8SupportWorkaround(bytecode);\n-        ClassWriter writer = new ClassWriter(0);\n+        ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n         new ClassReader(bytecode).accept(new MyClassVisitor(writer), 0);\n         return writer.toByteArray();\n     }\n"
    },
    {
        "commit_hash": "b013872190cfcdeb747d0106e54a89efd694e49e",
        "previous_commit_hash": "1b5c4cdeb6f9424f2666efeb98a9faddf394fb39",
        "diff_stats": {
            "additions": 12,
            "deletions": 0
        },
        "diff_content": "@@ -27,4 +27,16 @@ public class LambdaTest {\n \n         lambda.run();\n     }\n+\n+    private int instanceVar = 0;\n+\n+    @Test\n+    public void lambda_using_instance_variables() {\n+        Runnable lambda = () -> {\n+            instanceVar = 42;\n+        };\n+        lambda.run();\n+\n+        assertThat(instanceVar, is(42));\n+    }\n }\n"
    },
    {
        "commit_hash": "b013872190cfcdeb747d0106e54a89efd694e49e",
        "previous_commit_hash": "1b5c4cdeb6f9424f2666efeb98a9faddf394fb39",
        "diff_stats": {
            "additions": 5,
            "deletions": 0
        },
        "diff_content": "@@ -153,8 +153,13 @@ public class LambdaUsageBackporter {\n         try {\n             MethodType type = MethodType.fromMethodDescriptorString(handle.getDesc(), classLoader);\n             Class<?> owner = classLoader.loadClass(handle.getOwner().replace('/', '.'));\n+\n             if (handle.getTag() == Opcodes.H_INVOKESTATIC) {\n                 return lookup.findStatic(owner, handle.getName(), type);\n+\n+            } else if (handle.getTag() == Opcodes.H_INVOKESPECIAL) {\n+                return lookup.findSpecial(owner, handle.getName(), type, owner);\n+\n             } else {\n                 throw new AssertionError(\"unexpected tag: \" + handle.getTag());\n             }\n"
    },
    {
        "commit_hash": "f51ef25843a23d8f708ced4fc34c05f65aa5bcf6",
        "previous_commit_hash": "b013872190cfcdeb747d0106e54a89efd694e49e",
        "diff_stats": {
            "additions": 50,
            "deletions": 6
        },
        "diff_content": "@@ -43,6 +43,7 @@ public class LambdaUsageBackporter {\n \n     private static class MyClassVisitor extends ClassVisitor {\n         private String myClassName;\n+        private final List<LambdaFactoryMethod> lambdaFactoryMethods = new ArrayList<>();\n \n         public MyClassVisitor(ClassWriter cw) {\n             super(Opcodes.ASM4, cw);\n@@ -60,16 +61,26 @@ public class LambdaUsageBackporter {\n                 access = Flags.makeNonPrivate(access);\n             }\n             MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n-            return new InvokeDynamicInsnConvertingMethodVisitor(api, mv, myClassName);\n+            return new InvokeDynamicInsnConvertingMethodVisitor(api, mv, myClassName, lambdaFactoryMethods);\n+        }\n+\n+        @Override\n+        public void visitEnd() {\n+            for (LambdaFactoryMethod factoryMethod : lambdaFactoryMethods) {\n+                factoryMethod.generateMethod(cv);\n+            }\n+            super.visitEnd();\n         }\n     }\n \n     private static class InvokeDynamicInsnConvertingMethodVisitor extends MethodVisitor {\n         private final String myClassName;\n+        private final List<LambdaFactoryMethod> lambdaFactoryMethods;\n \n-        public InvokeDynamicInsnConvertingMethodVisitor(int api, MethodVisitor mv, String myClassName) {\n+        public InvokeDynamicInsnConvertingMethodVisitor(int api, MethodVisitor mv, String myClassName, List<LambdaFactoryMethod> lambdaFactoryMethods) {\n             super(api, mv);\n             this.myClassName = myClassName;\n+            this.lambdaFactoryMethods = lambdaFactoryMethods;\n         }\n \n         @Override\n@@ -98,10 +109,9 @@ public class LambdaUsageBackporter {\n                 callBootstrapMethod(invoker, invokedName, invokedType, bsm, bsmArgs);\n                 String lambdaClass = LambdaSavingClassFileTransformer.getLastFoundLambdaClass();\n \n-                // TODO: constructor parameters for lambda\n-                super.visitTypeInsn(Opcodes.NEW, lambdaClass);\n-                super.visitInsn(Opcodes.DUP);\n-                super.visitMethodInsn(Opcodes.INVOKESPECIAL, lambdaClass, \"<init>\", \"()V\");\n+                LambdaFactoryMethod factoryMethod = new LambdaFactoryMethod(invokedType, lambdaClass);\n+                lambdaFactoryMethods.add(factoryMethod);\n+                super.visitMethodInsn(Opcodes.INVOKESTATIC, myClassName, factoryMethod.getName(), invokedType.getDescriptor());\n \n             } catch (Throwable t) {\n                 throw new RuntimeException(t);\n@@ -168,4 +178,38 @@ public class LambdaUsageBackporter {\n             throw new RuntimeException(e);\n         }\n     }\n+\n+    private static class LambdaFactoryMethod {\n+        private final Type invokedType;\n+        private final String lambdaClass;\n+\n+        public LambdaFactoryMethod(Type invokedType, String lambdaClass) {\n+            this.invokedType = invokedType;\n+            this.lambdaClass = lambdaClass;\n+        }\n+\n+        public void generateMethod(ClassVisitor cv) {\n+            MethodVisitor mv = cv.visitMethod(Opcodes.ACC_PRIVATE | Opcodes.ACC_STATIC | Opcodes.ACC_SYNTHETIC,\n+                    getName(), invokedType.getDescriptor(), null, null);\n+            mv.visitCode();\n+            mv.visitTypeInsn(Opcodes.NEW, lambdaClass);\n+            mv.visitInsn(Opcodes.DUP);\n+            Type[] argumentTypes = invokedType.getArgumentTypes();\n+            for (int i = 0; i < argumentTypes.length; i++) {\n+                mv.visitVarInsn(Opcodes.ALOAD, i);\n+            }\n+            mv.visitMethodInsn(Opcodes.INVOKESPECIAL, lambdaClass, \"<init>\", withVoidReturnType(invokedType));\n+            mv.visitInsn(Opcodes.ARETURN);\n+            mv.visitMaxs(0, 0); // rely on COMPUTE_MAXS\n+            mv.visitEnd();\n+        }\n+\n+        public String getName() {\n+            return \"lambdaFactory$\" + lambdaClass.replaceFirst(\".+\\\\$\\\\$Lambda\\\\$\", \"\");\n+        }\n+\n+        private static String withVoidReturnType(Type type) {\n+            return Type.getMethodType(Type.VOID_TYPE, type.getArgumentTypes()).getDescriptor();\n+        }\n+    }\n }\n"
    },
    {
        "commit_hash": "e4a5d62d7379d9e8556bf161e4d3ea5aa73a150f",
        "previous_commit_hash": "f51ef25843a23d8f708ced4fc34c05f65aa5bcf6",
        "diff_stats": {
            "additions": 11,
            "deletions": 0
        },
        "diff_content": "@@ -39,4 +39,15 @@ public class LambdaTest {\n \n         assertThat(instanceVar, is(42));\n     }\n+\n+    @Test\n+    public void lambda_using_local_variables() {\n+        int[] localVar = new int[1];\n+        Runnable lambda = () -> {\n+            localVar[0] = 42;\n+        };\n+        lambda.run();\n+\n+        assertThat(localVar[0], is(42));\n+    }\n }\n"
    },
    {
        "commit_hash": "735beca189ef147e7e6cd9d0e8315ccdc83b032e",
        "previous_commit_hash": "e4a5d62d7379d9e8556bf161e4d3ea5aa73a150f",
        "diff_stats": {
            "additions": 15,
            "deletions": 0
        },
        "diff_content": "@@ -50,4 +50,19 @@ public class LambdaTest {\n \n         assertThat(localVar[0], is(42));\n     }\n+\n+    @Test\n+    public void lambda_using_local_variables_of_primitive_types() throws Exception {\n+        boolean bool = true;\n+        byte b = 2;\n+        short s = 3;\n+        int i = 4;\n+        long l = 5;\n+        float f = 6;\n+        double d = 7;\n+        char c = 8;\n+        Callable<Integer> lambda = () -> (int) ((bool ? 1 : 0) + b + s + i + l + f + d + c);\n+\n+        assertThat(lambda.call(), is(36));\n+    }\n }\n"
    },
    {
        "commit_hash": "735beca189ef147e7e6cd9d0e8315ccdc83b032e",
        "previous_commit_hash": "e4a5d62d7379d9e8556bf161e4d3ea5aa73a150f",
        "diff_stats": {
            "additions": 23,
            "deletions": 3
        },
        "diff_content": "@@ -194,9 +194,10 @@ public class LambdaUsageBackporter {\n             mv.visitCode();\n             mv.visitTypeInsn(Opcodes.NEW, lambdaClass);\n             mv.visitInsn(Opcodes.DUP);\n-            Type[] argumentTypes = invokedType.getArgumentTypes();\n-            for (int i = 0; i < argumentTypes.length; i++) {\n-                mv.visitVarInsn(Opcodes.ALOAD, i);\n+            int varIndex = 0;\n+            for (Type type : invokedType.getArgumentTypes()) {\n+                mv.visitVarInsn(getLoadInsn(type), varIndex);\n+                varIndex += type.getSize();\n             }\n             mv.visitMethodInsn(Opcodes.INVOKESPECIAL, lambdaClass, \"<init>\", withVoidReturnType(invokedType));\n             mv.visitInsn(Opcodes.ARETURN);\n@@ -208,6 +209,25 @@ public class LambdaUsageBackporter {\n             return \"lambdaFactory$\" + lambdaClass.replaceFirst(\".+\\\\$\\\\$Lambda\\\\$\", \"\");\n         }\n \n+        private static int getLoadInsn(Type type) {\n+            switch (type.getSort()) {\n+                case Type.BOOLEAN:\n+                case Type.CHAR:\n+                case Type.BYTE:\n+                case Type.SHORT:\n+                case Type.INT:\n+                    return Opcodes.ILOAD;\n+                case Type.LONG:\n+                    return Opcodes.LLOAD;\n+                case Type.FLOAT:\n+                    return Opcodes.FLOAD;\n+                case Type.DOUBLE:\n+                    return Opcodes.DLOAD;\n+                default:\n+                    return Opcodes.ALOAD;\n+            }\n+        }\n+\n         private static String withVoidReturnType(Type type) {\n             return Type.getMethodType(Type.VOID_TYPE, type.getArgumentTypes()).getDescriptor();\n         }\n"
    },
    {
        "commit_hash": "189870c485657533801d7a20f538bf8657457be4",
        "previous_commit_hash": "735beca189ef147e7e6cd9d0e8315ccdc83b032e",
        "diff_stats": {
            "additions": 0,
            "deletions": 43
        },
        "diff_content": "@@ -1,43 +0,0 @@\n-// Copyright \u00a9 2013 Esko Luontola <www.orfjackal.net>\n-// This software is released under the Apache License 2.0.\n-// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n-\n-package net.orfjackal.retrolambda;\n-\n-import java.lang.invoke.*;\n-import java.lang.reflect.*;\n-\n-public class Spike {\n-\n-    public static void main(String[] args) throws Exception {\n-        Class<?> targetClass = Dummy.class;\n-        ClassLoader targetClassClassLoader = targetClass.getClassLoader();\n-\n-        Constructor<MethodHandles.Lookup> ctor = MethodHandles.Lookup.class.getDeclaredConstructor(Class.class);\n-        ctor.setAccessible(true);\n-        MethodHandles.Lookup caller = ctor.newInstance(targetClass);\n-\n-        LambdaMetafactory.metafactory(\n-                caller,\n-                \"run\",\n-                MethodType.fromMethodDescriptorString(\"()Ljava/lang/Runnable;\", targetClassClassLoader),\n-                MethodType.fromMethodDescriptorString(\"()V\", targetClassClassLoader),\n-                caller.findStatic(targetClass, \"lambda$0\", MethodType.fromMethodDescriptorString(\"()V\", targetClassClassLoader)),\n-                MethodType.fromMethodDescriptorString(\"()V\", targetClassClassLoader));\n-    }\n-\n-    private static MethodHandles.Lookup getTrustedLookup() throws Exception {\n-        Field f = MethodHandles.Lookup.class.getDeclaredField(\"IMPL_LOOKUP\");\n-        f.setAccessible(true);\n-        return (MethodHandles.Lookup) f.get(null);\n-    }\n-}\n-\n-class Dummy {\n-\n-    public void foo() {\n-        Runnable r = () -> {\n-            System.out.println(\"foo\");\n-        };\n-    }\n-}\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "b66676fd80aaa9d450ad6351a73ad70c2a4f588a",
        "previous_commit_hash": "189870c485657533801d7a20f538bf8657457be4",
        "diff_stats": {
            "additions": 0,
            "deletions": 1
        },
        "diff_content": "@@ -21,7 +21,6 @@ public abstract class BytecodeTransformingFileVisitor extends SimpleFileVisitor<\n     @Override\n     public FileVisitResult visitFile(Path inputFile, BasicFileAttributes attrs) throws IOException {\n         if (isJavaClass(inputFile)) {\n-            System.out.println(inputFile); // TODO: remove debug printing\n             byte[] originalBytes = Files.readAllBytes(inputFile);\n             byte[] transformedBytes = transform(originalBytes);\n \n"
    },
    {
        "commit_hash": "b66676fd80aaa9d450ad6351a73ad70c2a4f588a",
        "previous_commit_hash": "189870c485657533801d7a20f538bf8657457be4",
        "diff_stats": {
            "additions": 0,
            "deletions": 11
        },
        "diff_content": "@@ -85,17 +85,6 @@ public class LambdaUsageBackporter {\n \n         @Override\n         public void visitInvokeDynamicInsn(String name, String desc, Handle bsm, Object... bsmArgs) {\n-            // TODO: remove debug code\n-            System.out.println(\"visitInvokeDynamicInsn\\n\" +\n-                    \"\\t\" + name + \"\\n\" +\n-                    \"\\t\" + desc + \"\\n\" +\n-                    \"\\t\" + bsm + \"\\n\" +\n-                    \"\\t\" + Arrays.toString(bsmArgs));\n-            System.out.println(\"bsm.getDesc() = \" + bsm.getDesc());\n-            System.out.println(\"bsm.getName() = \" + bsm.getName());\n-            System.out.println(\"bsm.getOwner() = \" + bsm.getOwner());\n-            System.out.println(\"bsm.getTag() = \" + bsm.getTag());\n-\n             if (bsm.getOwner().equals(LAMBDA_METAFACTORY)) {\n                 backportLambda(name, Type.getType(desc), bsm, bsmArgs);\n             } else {\n"
    },
    {
        "commit_hash": "45597cac8315e310a2e097d922e436231c287031",
        "previous_commit_hash": "b66676fd80aaa9d450ad6351a73ad70c2a4f588a",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -4,6 +4,7 @@\n       <w>backport</w>\n       <w>backporter</w>\n       <w>bytecode</w>\n+      <w>insn</w>\n       <w>metafactory</w>\n       <w>premain</w>\n       <w>retrolambda</w>\n"
    },
    {
        "commit_hash": "45597cac8315e310a2e097d922e436231c287031",
        "previous_commit_hash": "b66676fd80aaa9d450ad6351a73ad70c2a4f588a",
        "diff_stats": {
            "additions": 26,
            "deletions": 36
        },
        "diff_content": "@@ -86,28 +86,27 @@ public class LambdaUsageBackporter {\n         @Override\n         public void visitInvokeDynamicInsn(String name, String desc, Handle bsm, Object... bsmArgs) {\n             if (bsm.getOwner().equals(LAMBDA_METAFACTORY)) {\n-                backportLambda(name, Type.getType(desc), bsm, bsmArgs);\n+                try {\n+                    backportLambda(name, Type.getType(desc), bsm, bsmArgs);\n+                } catch (Throwable t) {\n+                    throw new RuntimeException(t);\n+                }\n             } else {\n                 super.visitInvokeDynamicInsn(name, desc, bsm, bsmArgs);\n             }\n         }\n \n-        private void backportLambda(String invokedName, Type invokedType, Handle bsm, Object[] bsmArgs) {\n-            try {\n-                Class<?> invoker = Class.forName(myClassName.replace('/', '.'));\n-                callBootstrapMethod(invoker, invokedName, invokedType, bsm, bsmArgs);\n-                String lambdaClass = LambdaSavingClassFileTransformer.getLastFoundLambdaClass();\n+        private void backportLambda(String invokedName, Type invokedType, Handle bsm, Object[] bsmArgs) throws Throwable {\n+            Class<?> invoker = Class.forName(myClassName.replace('/', '.'));\n+            callBootstrapMethod(invoker, invokedName, invokedType, bsm, bsmArgs);\n+            String lambdaClass = LambdaSavingClassFileTransformer.getLastFoundLambdaClass();\n \n-                LambdaFactoryMethod factoryMethod = new LambdaFactoryMethod(invokedType, lambdaClass);\n-                lambdaFactoryMethods.add(factoryMethod);\n-                super.visitMethodInsn(Opcodes.INVOKESTATIC, myClassName, factoryMethod.getName(), invokedType.getDescriptor());\n-\n-            } catch (Throwable t) {\n-                throw new RuntimeException(t);\n-            }\n+            LambdaFactoryMethod factoryMethod = new LambdaFactoryMethod(invokedType, lambdaClass);\n+            lambdaFactoryMethods.add(factoryMethod);\n+            super.visitMethodInsn(Opcodes.INVOKESTATIC, myClassName, factoryMethod.getName(), invokedType.getDescriptor());\n         }\n \n-        private CallSite callBootstrapMethod(Class<?> invoker, String invokedName, Type invokedType, Handle bsm, Object[] bsmArgs) throws Throwable {\n+        private static CallSite callBootstrapMethod(Class<?> invoker, String invokedName, Type invokedType, Handle bsm, Object[] bsmArgs) throws Throwable {\n             ClassLoader cl = invoker.getClassLoader();\n             MethodHandles.Lookup caller = getLookup(invoker);\n \n@@ -122,34 +121,28 @@ public class LambdaUsageBackporter {\n             MethodHandle bootstrapMethod = toMethodHandle(bsm, cl, caller);\n             return (CallSite) bootstrapMethod.invokeWithArguments(args);\n         }\n-    }\n \n-    private static MethodHandles.Lookup getLookup(Class<?> targetClass) {\n-        try {\n+        private static MethodHandles.Lookup getLookup(Class<?> targetClass) throws Exception {\n             Constructor<MethodHandles.Lookup> ctor = MethodHandles.Lookup.class.getDeclaredConstructor(Class.class);\n             ctor.setAccessible(true);\n             return ctor.newInstance(targetClass);\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n         }\n-    }\n \n-    private static Object asmToInvokerType(Object arg, ClassLoader classLoader, MethodHandles.Lookup caller) {\n-        if (arg instanceof Type) {\n-            return toMethodType((Type) arg, classLoader);\n-        } else if (arg instanceof Handle) {\n-            return toMethodHandle((Handle) arg, classLoader, caller);\n-        } else {\n-            return arg;\n+        private static Object asmToInvokerType(Object arg, ClassLoader classLoader, MethodHandles.Lookup caller) throws Exception {\n+            if (arg instanceof Type) {\n+                return toMethodType((Type) arg, classLoader);\n+            } else if (arg instanceof Handle) {\n+                return toMethodHandle((Handle) arg, classLoader, caller);\n+            } else {\n+                return arg;\n+            }\n         }\n-    }\n \n-    private static MethodType toMethodType(Type type, ClassLoader classLoader) {\n-        return MethodType.fromMethodDescriptorString(type.getInternalName(), classLoader);\n-    }\n+        private static MethodType toMethodType(Type type, ClassLoader classLoader) {\n+            return MethodType.fromMethodDescriptorString(type.getInternalName(), classLoader);\n+        }\n \n-    private static MethodHandle toMethodHandle(Handle handle, ClassLoader classLoader, MethodHandles.Lookup lookup) {\n-        try {\n+        private static MethodHandle toMethodHandle(Handle handle, ClassLoader classLoader, MethodHandles.Lookup lookup) throws Exception {\n             MethodType type = MethodType.fromMethodDescriptorString(handle.getDesc(), classLoader);\n             Class<?> owner = classLoader.loadClass(handle.getOwner().replace('/', '.'));\n \n@@ -162,9 +155,6 @@ public class LambdaUsageBackporter {\n             } else {\n                 throw new AssertionError(\"unexpected tag: \" + handle.getTag());\n             }\n-\n-        } catch (ClassNotFoundException | NoSuchMethodException | IllegalAccessException e) {\n-            throw new RuntimeException(e);\n         }\n     }\n \n"
    },
    {
        "commit_hash": "07880bc57252bd99faefe02df2e2ecedca7b7af2",
        "previous_commit_hash": "45597cac8315e310a2e097d922e436231c287031",
        "diff_stats": {
            "additions": 2,
            "deletions": 0
        },
        "diff_content": "@@ -16,6 +16,8 @@ public class Main {\n         Config config = new Config(System.getProperties());\n         Path inputDir = config.getInputDir();\n         Path outputDir = config.getOutputDir();\n+        System.out.println(\"Input directory:  \" + inputDir);\n+        System.out.println(\"Output directory: \" + outputDir);\n \n         if (!Files.isDirectory(inputDir)) {\n             System.out.println(\"Nothing to do; not a directory: \" + inputDir);\n"
    },
    {
        "commit_hash": "cec381fb4838c6bf280ec7de6051c8a416f3a5f6",
        "previous_commit_hash": "07880bc57252bd99faefe02df2e2ecedca7b7af2",
        "diff_stats": {
            "additions": 0,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,6 @@\n     <file url=\"file://$PROJECT_DIR$/end-to-end-tests\" charset=\"UTF-8\" />\n     <file url=\"file://$PROJECT_DIR$/parent\" charset=\"UTF-8\" />\n     <file url=\"file://$PROJECT_DIR$/retrolambda\" charset=\"UTF-8\" />\n-    <file url=\"file://$PROJECT_DIR$/retrolambda-runtime\" charset=\"UTF-8\" />\n     <file url=\"PROJECT\" charset=\"UTF-8\" />\n   </component>\n </project>\n"
    },
    {
        "commit_hash": "cec381fb4838c6bf280ec7de6051c8a416f3a5f6",
        "previous_commit_hash": "07880bc57252bd99faefe02df2e2ecedca7b7af2",
        "diff_stats": {
            "additions": 8,
            "deletions": 0
        },
        "diff_content": "@@ -65,4 +65,12 @@ public class LambdaTest {\n \n         assertThat(lambda.call(), is(36));\n     }\n+\n+    @Test\n+    public void method_references_to_virtual_methods() throws Exception {\n+        String foo = \"foo\";\n+        Callable<String> ref = foo::toUpperCase;\n+\n+        assertThat(ref.call(), is(\"FOO\"));\n+    }\n }\n"
    },
    {
        "commit_hash": "cec381fb4838c6bf280ec7de6051c8a416f3a5f6",
        "previous_commit_hash": "07880bc57252bd99faefe02df2e2ecedca7b7af2",
        "diff_stats": {
            "additions": 3,
            "deletions": 0
        },
        "diff_content": "@@ -152,6 +152,9 @@ public class LambdaUsageBackporter {\n             } else if (handle.getTag() == Opcodes.H_INVOKESPECIAL) {\n                 return lookup.findSpecial(owner, handle.getName(), type, owner);\n \n+            } else if (handle.getTag() == Opcodes.H_INVOKEVIRTUAL) {\n+                return lookup.findVirtual(owner, handle.getName(), type);\n+\n             } else {\n                 throw new AssertionError(\"unexpected tag: \" + handle.getTag());\n             }\n"
    },
    {
        "commit_hash": "3d365710bd80f737732cc17fbb604c6cc84d881c",
        "previous_commit_hash": "cec381fb4838c6bf280ec7de6051c8a416f3a5f6",
        "diff_stats": {
            "additions": 9,
            "deletions": 0
        },
        "diff_content": "@@ -6,6 +6,7 @@ package net.orfjackal.retrolambda.test;\n \n import org.junit.Test;\n \n+import java.util.*;\n import java.util.concurrent.Callable;\n \n import static org.hamcrest.MatcherAssert.assertThat;\n@@ -73,4 +74,12 @@ public class LambdaTest {\n \n         assertThat(ref.call(), is(\"FOO\"));\n     }\n+\n+    @Test\n+    public void method_references_to_interface_methods() throws Exception {\n+        List<String> foos = Arrays.asList(\"foo\");\n+        Callable<Integer> ref = foos::size;\n+\n+        assertThat(ref.call(), is(1));\n+    }\n }\n"
    },
    {
        "commit_hash": "3d365710bd80f737732cc17fbb604c6cc84d881c",
        "previous_commit_hash": "cec381fb4838c6bf280ec7de6051c8a416f3a5f6",
        "diff_stats": {
            "additions": 2,
            "deletions": 1
        },
        "diff_content": "@@ -152,7 +152,8 @@ public class LambdaUsageBackporter {\n             } else if (handle.getTag() == Opcodes.H_INVOKESPECIAL) {\n                 return lookup.findSpecial(owner, handle.getName(), type, owner);\n \n-            } else if (handle.getTag() == Opcodes.H_INVOKEVIRTUAL) {\n+            } else if (handle.getTag() == Opcodes.H_INVOKEVIRTUAL\n+                    || handle.getTag() == Opcodes.H_INVOKEINTERFACE) {\n                 return lookup.findVirtual(owner, handle.getName(), type);\n \n             } else {\n"
    },
    {
        "commit_hash": "55d5e3efc871ef7c7a3b1a5ae5dfa08399c1aca0",
        "previous_commit_hash": "3d365710bd80f737732cc17fbb604c6cc84d881c",
        "diff_stats": {
            "additions": 16,
            "deletions": 1
        },
        "diff_content": "@@ -10,7 +10,7 @@ import java.util.*;\n import java.util.concurrent.Callable;\n \n import static org.hamcrest.MatcherAssert.assertThat;\n-import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.*;\n \n public class LambdaTest {\n \n@@ -82,4 +82,19 @@ public class LambdaTest {\n \n         assertThat(ref.call(), is(1));\n     }\n+\n+    @Test\n+    public void method_references_to_static_methods() throws Exception {\n+        long expected = System.currentTimeMillis();\n+        Callable<Long> ref = System::currentTimeMillis;\n+\n+        assertThat(ref.call(), is(greaterThanOrEqualTo(expected)));\n+    }\n+\n+    @Test\n+    public void method_references_to_constructors() throws Exception {\n+        Callable<ArrayList<?>> ref = ArrayList::new;\n+\n+        assertThat(ref.call(), is(instanceOf(ArrayList.class)));\n+    }\n }\n"
    },
    {
        "commit_hash": "55d5e3efc871ef7c7a3b1a5ae5dfa08399c1aca0",
        "previous_commit_hash": "3d365710bd80f737732cc17fbb604c6cc84d881c",
        "diff_stats": {
            "additions": 3,
            "deletions": 0
        },
        "diff_content": "@@ -152,6 +152,9 @@ public class LambdaUsageBackporter {\n             } else if (handle.getTag() == Opcodes.H_INVOKESPECIAL) {\n                 return lookup.findSpecial(owner, handle.getName(), type, owner);\n \n+            } else if (handle.getTag() == Opcodes.H_NEWINVOKESPECIAL) {\n+                return lookup.findConstructor(owner, type);\n+\n             } else if (handle.getTag() == Opcodes.H_INVOKEVIRTUAL\n                     || handle.getTag() == Opcodes.H_INVOKEINTERFACE) {\n                 return lookup.findVirtual(owner, handle.getName(), type);\n"
    },
    {
        "commit_hash": "f0f07ad64128e7d424aa144e73edc4d07115f08a",
        "previous_commit_hash": "55d5e3efc871ef7c7a3b1a5ae5dfa08399c1aca0",
        "diff_stats": {
            "additions": 12,
            "deletions": 11
        },
        "diff_content": "@@ -146,21 +146,22 @@ public class LambdaUsageBackporter {\n             MethodType type = MethodType.fromMethodDescriptorString(handle.getDesc(), classLoader);\n             Class<?> owner = classLoader.loadClass(handle.getOwner().replace('/', '.'));\n \n-            if (handle.getTag() == Opcodes.H_INVOKESTATIC) {\n-                return lookup.findStatic(owner, handle.getName(), type);\n+            switch (handle.getTag()) {\n+                case Opcodes.H_INVOKESTATIC:\n+                    return lookup.findStatic(owner, handle.getName(), type);\n \n-            } else if (handle.getTag() == Opcodes.H_INVOKESPECIAL) {\n-                return lookup.findSpecial(owner, handle.getName(), type, owner);\n+                case Opcodes.H_INVOKEVIRTUAL:\n+                case Opcodes.H_INVOKEINTERFACE:\n+                    return lookup.findVirtual(owner, handle.getName(), type);\n \n-            } else if (handle.getTag() == Opcodes.H_NEWINVOKESPECIAL) {\n-                return lookup.findConstructor(owner, type);\n+                case Opcodes.H_INVOKESPECIAL:\n+                    return lookup.findSpecial(owner, handle.getName(), type, owner);\n \n-            } else if (handle.getTag() == Opcodes.H_INVOKEVIRTUAL\n-                    || handle.getTag() == Opcodes.H_INVOKEINTERFACE) {\n-                return lookup.findVirtual(owner, handle.getName(), type);\n+                case Opcodes.H_NEWINVOKESPECIAL:\n+                    return lookup.findConstructor(owner, type);\n \n-            } else {\n-                throw new AssertionError(\"unexpected tag: \" + handle.getTag());\n+                default:\n+                    throw new AssertionError(\"Unexpected handle type: \" + handle);\n             }\n         }\n     }\n"
    },
    {
        "commit_hash": "6aab00333238e4cea85894a85fb5eda9866a781c",
        "previous_commit_hash": "f0f07ad64128e7d424aa144e73edc4d07115f08a",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -93,7 +93,7 @@ public class LambdaTest {\n \n     @Test\n     public void method_references_to_constructors() throws Exception {\n-        Callable<ArrayList<?>> ref = ArrayList::new;\n+        Callable<List<String>> ref = ArrayList<String>::new;\n \n         assertThat(ref.call(), is(instanceOf(ArrayList.class)));\n     }\n"
    },
    {
        "commit_hash": "930db2a5ef8a6cc17e8bcb0ebf020a0c99aa2890",
        "previous_commit_hash": "6aab00333238e4cea85894a85fb5eda9866a781c",
        "diff_stats": {
            "additions": 12,
            "deletions": 0
        },
        "diff_content": "@@ -6,6 +6,7 @@ package net.orfjackal.retrolambda.test;\n \n import org.junit.Test;\n \n+import java.nio.charset.StandardCharsets;\n import java.util.*;\n import java.util.concurrent.Callable;\n \n@@ -29,6 +30,17 @@ public class LambdaTest {\n         lambda.run();\n     }\n \n+    private interface Function1<IN, OUT> {\n+        OUT apply(IN value);\n+    }\n+\n+    @Test\n+    public void lambda_taking_parameters() {\n+        Function1<String, Integer> lambda = (String s) -> s.getBytes(StandardCharsets.UTF_16BE).length;\n+\n+        assertThat(lambda.apply(\"foo\"), is(6));\n+    }\n+\n     private int instanceVar = 0;\n \n     @Test\n"
    },
    {
        "commit_hash": "5f3ff7651e85ffc2b7dd71f6eae0488759debe17",
        "previous_commit_hash": "930db2a5ef8a6cc17e8bcb0ebf020a0c99aa2890",
        "diff_stats": {
            "additions": 0,
            "deletions": 0
        },
        "diff_content": ""
    },
    {
        "commit_hash": "5f3ff7651e85ffc2b7dd71f6eae0488759debe17",
        "previous_commit_hash": "930db2a5ef8a6cc17e8bcb0ebf020a0c99aa2890",
        "diff_stats": {
            "additions": 0,
            "deletions": 0
        },
        "diff_content": ""
    },
    {
        "commit_hash": "5f3ff7651e85ffc2b7dd71f6eae0488759debe17",
        "previous_commit_hash": "930db2a5ef8a6cc17e8bcb0ebf020a0c99aa2890",
        "diff_stats": {
            "additions": 0,
            "deletions": 0
        },
        "diff_content": ""
    },
    {
        "commit_hash": "1b8a2cb5ff70495a002d1b465efb260f7718c9b9",
        "previous_commit_hash": "5f3ff7651e85ffc2b7dd71f6eae0488759debe17",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -4,6 +4,7 @@\n     <output url=\"file://$MODULE_DIR$/target/classes\" />\n     <output-test url=\"file://$MODULE_DIR$/target/test-classes\" />\n     <content url=\"file://$MODULE_DIR$\">\n+      <sourceFolder url=\"file://$MODULE_DIR$/src/main/java\" isTestSource=\"false\" />\n       <sourceFolder url=\"file://$MODULE_DIR$/src/test/java\" isTestSource=\"true\" />\n       <excludeFolder url=\"file://$MODULE_DIR$/target\" />\n     </content>\n"
    },
    {
        "commit_hash": "1b8a2cb5ff70495a002d1b465efb260f7718c9b9",
        "previous_commit_hash": "5f3ff7651e85ffc2b7dd71f6eae0488759debe17",
        "diff_stats": {
            "additions": 22,
            "deletions": 1
        },
        "diff_content": "@@ -51,6 +51,28 @@\n             <plugin>\n                 <artifactId>maven-antrun-plugin</artifactId>\n                 <executions>\n+                    <execution>\n+                        <id>process-classes</id>\n+                        <phase>process-classes</phase>\n+                        <goals>\n+                            <goal>run</goal>\n+                        </goals>\n+                        <configuration>\n+                            <target>\n+                                <property name=\"compile_classpath\" refid=\"maven.compile.classpath\"/>\n+                                <exec executable=\"${env.JAVA8_HOME}/bin/java\" failonerror=\"true\">\n+                                    <arg value=\"-Dretrolambda.inputDir=${project.build.outputDirectory}\"/>\n+                                    <arg value=\"-javaagent:../retrolambda/target/retrolambda-${project.version}.jar\"/>\n+                                    <arg value=\"-cp\"/>\n+                                    <arg value=\"../retrolambda/target/retrolambda-${project.version}.jar${path.separator}${compile_classpath}\"/>\n+                                    <!-- XXX: using -jar overrides any -cp or CLASSPATH env var; try adding a custom property? -->\n+                                    <!--<arg value=\"-jar\"/>-->\n+                                    <!--<arg value=\"../retrolambda/target/retrolambda-${project.version}.jar\"/>-->\n+                                    <arg value=\"net.orfjackal.retrolambda.Main\"/>\n+                                </exec>\n+                            </target>\n+                        </configuration>\n+                    </execution>\n                     <execution>\n                         <id>process-test-classes</id>\n                         <phase>process-test-classes</phase>\n@@ -69,7 +91,6 @@\n                                     <!--<arg value=\"-jar\"/>-->\n                                     <!--<arg value=\"../retrolambda/target/retrolambda-${project.version}.jar\"/>-->\n                                     <arg value=\"net.orfjackal.retrolambda.Main\"/>\n-                                    <arg value=\"${project.build.testOutputDirectory}\"/>\n                                 </exec>\n                             </target>\n                         </configuration>\n"
    },
    {
        "commit_hash": "1b8a2cb5ff70495a002d1b465efb260f7718c9b9",
        "previous_commit_hash": "5f3ff7651e85ffc2b7dd71f6eae0488759debe17",
        "diff_stats": {
            "additions": 15,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,15 @@\n+// Copyright \u00a9 2013 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.test;\n+\n+import java.util.concurrent.Callable;\n+\n+public class InMainSources {\n+\n+    public static int callLambda() throws Exception {\n+        Callable<Integer> lambda = () -> 42;\n+        return lambda.call();\n+    }\n+}\n"
    },
    {
        "commit_hash": "1b8a2cb5ff70495a002d1b465efb260f7718c9b9",
        "previous_commit_hash": "5f3ff7651e85ffc2b7dd71f6eae0488759debe17",
        "diff_stats": {
            "additions": 12,
            "deletions": 7
        },
        "diff_content": "@@ -16,18 +16,18 @@ import static org.hamcrest.Matchers.*;\n public class LambdaTest {\n \n     @Test\n-    public void lambda_returning_value() throws Exception {\n-        Callable<String> lambda = () -> \"some value\";\n+    public void empty_lambda() {\n+        Runnable lambda = () -> {\n+        };\n \n-        assertThat(lambda.call(), is(\"some value\"));\n+        lambda.run();\n     }\n \n     @Test\n-    public void lambda_returning_nothing() {\n-        Runnable lambda = () -> {\n-        };\n+    public void lambda_returning_a_value() throws Exception {\n+        Callable<String> lambda = () -> \"some value\";\n \n-        lambda.run();\n+        assertThat(lambda.call(), is(\"some value\"));\n     }\n \n     private interface Function1<IN, OUT> {\n@@ -41,6 +41,11 @@ public class LambdaTest {\n         assertThat(lambda.apply(\"foo\"), is(6));\n     }\n \n+    @Test\n+    public void lambda_in_project_main_sources() throws Exception {\n+        assertThat(InMainSources.callLambda(), is(42));\n+    }\n+\n     private int instanceVar = 0;\n \n     @Test\n"
    },
    {
        "commit_hash": "4b6a595ccdea131ee5d286f000fef44d6a76eacd",
        "previous_commit_hash": "1b8a2cb5ff70495a002d1b465efb260f7718c9b9",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -3,6 +3,7 @@\n     <words>\n       <w>backport</w>\n       <w>backporter</w>\n+      <w>backporting</w>\n       <w>bytecode</w>\n       <w>insn</w>\n       <w>metafactory</w>\n"
    },
    {
        "commit_hash": "4b6a595ccdea131ee5d286f000fef44d6a76eacd",
        "previous_commit_hash": "1b8a2cb5ff70495a002d1b465efb260f7718c9b9",
        "diff_stats": {
            "additions": 6,
            "deletions": 12
        },
        "diff_content": "@@ -62,13 +62,10 @@\n                                 <property name=\"compile_classpath\" refid=\"maven.compile.classpath\"/>\n                                 <exec executable=\"${env.JAVA8_HOME}/bin/java\" failonerror=\"true\">\n                                     <arg value=\"-Dretrolambda.inputDir=${project.build.outputDirectory}\"/>\n+                                    <arg value=\"-Dretrolambda.classpath=${compile_classpath}\"/>\n                                     <arg value=\"-javaagent:../retrolambda/target/retrolambda-${project.version}.jar\"/>\n-                                    <arg value=\"-cp\"/>\n-                                    <arg value=\"../retrolambda/target/retrolambda-${project.version}.jar${path.separator}${compile_classpath}\"/>\n-                                    <!-- XXX: using -jar overrides any -cp or CLASSPATH env var; try adding a custom property? -->\n-                                    <!--<arg value=\"-jar\"/>-->\n-                                    <!--<arg value=\"../retrolambda/target/retrolambda-${project.version}.jar\"/>-->\n-                                    <arg value=\"net.orfjackal.retrolambda.Main\"/>\n+                                    <arg value=\"-jar\"/>\n+                                    <arg value=\"../retrolambda/target/retrolambda-${project.version}.jar\"/>\n                                 </exec>\n                             </target>\n                         </configuration>\n@@ -84,13 +81,10 @@\n                                 <property name=\"test_classpath\" refid=\"maven.test.classpath\"/>\n                                 <exec executable=\"${env.JAVA8_HOME}/bin/java\" failonerror=\"true\">\n                                     <arg value=\"-Dretrolambda.inputDir=${project.build.testOutputDirectory}\"/>\n+                                    <arg value=\"-Dretrolambda.classpath=${test_classpath}\"/>\n                                     <arg value=\"-javaagent:../retrolambda/target/retrolambda-${project.version}.jar\"/>\n-                                    <arg value=\"-cp\"/>\n-                                    <arg value=\"../retrolambda/target/retrolambda-${project.version}.jar${path.separator}${test_classpath}\"/>\n-                                    <!-- XXX: using -jar overrides any -cp or CLASSPATH env var; try adding a custom property? -->\n-                                    <!--<arg value=\"-jar\"/>-->\n-                                    <!--<arg value=\"../retrolambda/target/retrolambda-${project.version}.jar\"/>-->\n-                                    <arg value=\"net.orfjackal.retrolambda.Main\"/>\n+                                    <arg value=\"-jar\"/>\n+                                    <arg value=\"../retrolambda/target/retrolambda-${project.version}.jar\"/>\n                                 </exec>\n                             </target>\n                         </configuration>\n"
    },
    {
        "commit_hash": "4b6a595ccdea131ee5d286f000fef44d6a76eacd",
        "previous_commit_hash": "1b8a2cb5ff70495a002d1b465efb260f7718c9b9",
        "diff_stats": {
            "additions": 17,
            "deletions": 7
        },
        "diff_content": "@@ -9,8 +9,10 @@ import java.util.Properties;\n \n public class Config {\n \n-    private static final String INPUT_DIR = \"retrolambda.inputDir\";\n-    private static final String OUTPUT_DIR = \"retrolambda.outputDir\";\n+    private static final String PREFIX = \"retrolambda.\";\n+    private static final String INPUT_DIR = PREFIX + \"inputDir\";\n+    private static final String OUTPUT_DIR = PREFIX + \"outputDir\";\n+    private static final String CLASSPATH = PREFIX + \"classpath\";\n \n     private final Properties p;\n \n@@ -19,11 +21,7 @@ public class Config {\n     }\n \n     public Path getInputDir() {\n-        String inputDir = p.getProperty(INPUT_DIR);\n-        if (inputDir == null) {\n-            throw new IllegalArgumentException(\"Missing required property: \" + INPUT_DIR);\n-        }\n-        return Paths.get(inputDir);\n+        return Paths.get(getRequiredProperty(INPUT_DIR));\n     }\n \n     public Path getOutputDir() {\n@@ -33,4 +31,16 @@ public class Config {\n         }\n         return Paths.get(outputDir);\n     }\n+\n+    public String getClasspath() {\n+        return getRequiredProperty(CLASSPATH);\n+    }\n+\n+    private String getRequiredProperty(String key) {\n+        String value = p.getProperty(key);\n+        if (value == null) {\n+            throw new IllegalArgumentException(\"Missing required property: \" + key);\n+        }\n+        return value;\n+    }\n }\n"
    },
    {
        "commit_hash": "4b6a595ccdea131ee5d286f000fef44d6a76eacd",
        "previous_commit_hash": "1b8a2cb5ff70495a002d1b465efb260f7718c9b9",
        "diff_stats": {
            "additions": 17,
            "deletions": 2
        },
        "diff_content": "@@ -8,18 +8,24 @@ import java.io.IOException;\n import java.lang.instrument.*;\n import java.nio.file.*;\n import java.security.ProtectionDomain;\n+import java.util.*;\n import java.util.concurrent.*;\n import java.util.regex.Pattern;\n \n public class LambdaSavingClassFileTransformer implements ClassFileTransformer {\n \n-    private static final Pattern LAMBDA_CLASS = Pattern.compile(\".+\\\\$\\\\$Lambda\\\\$\\\\d+$\");\n+    private static final Pattern LAMBDA_CLASS = Pattern.compile(\"^.+\\\\$\\\\$Lambda\\\\$\\\\d+$\");\n \n     private static final BlockingDeque<String> foundLambdaClasses = new LinkedBlockingDeque<>(1); // we expect only one at a time\n     private final Path outputDir;\n+    private final List<ClassLoader> ignoredClassLoaders = new ArrayList<>();\n \n     public LambdaSavingClassFileTransformer(Path outputDir) {\n         this.outputDir = outputDir;\n+        for (ClassLoader cl = ClassLoader.getSystemClassLoader(); cl != null; cl = cl.getParent()) {\n+            ignoredClassLoaders.add(cl);\n+        }\n+        ignoredClassLoaders.add(null);\n     }\n \n     public static String getLastFoundLambdaClass() {\n@@ -28,7 +34,12 @@ public class LambdaSavingClassFileTransformer implements ClassFileTransformer {\n \n     @Override\n     public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {\n-        if (!LAMBDA_CLASS.matcher(className).matches()) {\n+        if (ignoredClassLoaders.contains(loader)) {\n+            // Avoid saving any classes from the JDK or Retrolambda itself.\n+            // The transformed application classes have their own class loader.\n+            return null;\n+        }\n+        if (!isLambdaClass(className)) {\n             return null;\n         }\n         try {\n@@ -44,4 +55,8 @@ public class LambdaSavingClassFileTransformer implements ClassFileTransformer {\n         }\n         return null;\n     }\n+\n+    private static boolean isLambdaClass(String className) {\n+        return LAMBDA_CLASS.matcher(className).matches();\n+    }\n }\n"
    },
    {
        "commit_hash": "4b6a595ccdea131ee5d286f000fef44d6a76eacd",
        "previous_commit_hash": "1b8a2cb5ff70495a002d1b465efb260f7718c9b9",
        "diff_stats": {
            "additions": 5,
            "deletions": 4
        },
        "diff_content": "@@ -42,8 +42,8 @@ public class LambdaUsageBackporter {\n     }\n \n     private static class MyClassVisitor extends ClassVisitor {\n-        private String myClassName;\n         private final List<LambdaFactoryMethod> lambdaFactoryMethods = new ArrayList<>();\n+        private String className;\n \n         public MyClassVisitor(ClassWriter cw) {\n             super(Opcodes.ASM4, cw);\n@@ -52,7 +52,7 @@ public class LambdaUsageBackporter {\n         @Override\n         public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n             super.visit(version, access, name, signature, superName, interfaces);\n-            this.myClassName = name;\n+            this.className = name;\n         }\n \n         @Override\n@@ -61,7 +61,7 @@ public class LambdaUsageBackporter {\n                 access = Flags.makeNonPrivate(access);\n             }\n             MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n-            return new InvokeDynamicInsnConvertingMethodVisitor(api, mv, myClassName, lambdaFactoryMethods);\n+            return new InvokeDynamicInsnConvertingMethodVisitor(api, mv, className, lambdaFactoryMethods);\n         }\n \n         @Override\n@@ -97,7 +97,8 @@ public class LambdaUsageBackporter {\n         }\n \n         private void backportLambda(String invokedName, Type invokedType, Handle bsm, Object[] bsmArgs) throws Throwable {\n-            Class<?> invoker = Class.forName(myClassName.replace('/', '.'));\n+            ClassLoader cl = Thread.currentThread().getContextClassLoader();\n+            Class<?> invoker = cl.loadClass(myClassName.replace('/', '.'));\n             callBootstrapMethod(invoker, invokedName, invokedType, bsm, bsmArgs);\n             String lambdaClass = LambdaSavingClassFileTransformer.getLastFoundLambdaClass();\n \n"
    },
    {
        "commit_hash": "4b6a595ccdea131ee5d286f000fef44d6a76eacd",
        "previous_commit_hash": "1b8a2cb5ff70495a002d1b465efb260f7718c9b9",
        "diff_stats": {
            "additions": 21,
            "deletions": 1
        },
        "diff_content": "@@ -5,8 +5,9 @@\n package net.orfjackal.retrolambda;\n \n import java.io.*;\n+import java.net.*;\n import java.nio.file.*;\n-import java.util.Properties;\n+import java.util.*;\n \n public class Main {\n \n@@ -16,8 +17,10 @@ public class Main {\n         Config config = new Config(System.getProperties());\n         Path inputDir = config.getInputDir();\n         Path outputDir = config.getOutputDir();\n+        String classpath = config.getClasspath();\n         System.out.println(\"Input directory:  \" + inputDir);\n         System.out.println(\"Output directory: \" + outputDir);\n+        System.out.println(\"Classpath:        \" + classpath);\n \n         if (!Files.isDirectory(inputDir)) {\n             System.out.println(\"Nothing to do; not a directory: \" + inputDir);\n@@ -25,6 +28,7 @@ public class Main {\n         }\n \n         try {\n+            Thread.currentThread().setContextClassLoader(new URLClassLoader(asUrls(classpath)));\n             Files.walkFileTree(inputDir, new BytecodeTransformingFileVisitor(inputDir, outputDir) {\n                 protected byte[] transform(byte[] bytecode) {\n                     return LambdaUsageBackporter.transform(bytecode);\n@@ -38,6 +42,22 @@ public class Main {\n         }\n     }\n \n+    private static URL[] asUrls(String classpath) {\n+        String[] paths = classpath.split(System.getProperty(\"path.separator\"));\n+        return Arrays.asList(paths).stream()\n+                .map(s -> Paths.get(s).toUri())\n+                .map(Main::uriToUrl)\n+                .toArray(URL[]::new);\n+    }\n+\n+    private static URL uriToUrl(URI uri) {\n+        try {\n+            return uri.toURL();\n+        } catch (MalformedURLException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n     private static String getVersion() {\n         Properties p = new Properties();\n         try (InputStream in = ClassLoader.getSystemResourceAsStream(\"META-INF/maven/net.orfjackal.retrolambda/retrolambda/pom.properties\")) {\n"
    },
    {
        "commit_hash": "7f04adf0da68972e057686787b13dd3ca99c3beb",
        "previous_commit_hash": "4b6a595ccdea131ee5d286f000fef44d6a76eacd",
        "diff_stats": {
            "additions": 31,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,31 @@\n+<component name=\"ProjectRunConfigurationManager\">\n+  <configuration default=\"false\" name=\"End-to-end tests (Java 6)\" type=\"MavenRunConfiguration\" factoryName=\"Maven\">\n+    <MavenSettings>\n+      <option name=\"myGeneralSettings\" />\n+      <option name=\"myRunnerSettings\" />\n+      <option name=\"myRunnerParameters\">\n+        <MavenRunnerParameters>\n+          <option name=\"profiles\">\n+            <set />\n+          </option>\n+          <option name=\"goals\">\n+            <list>\n+              <option value=\"clean\" />\n+              <option value=\"verify\" />\n+            </list>\n+          </option>\n+          <option name=\"profilesMap\">\n+            <map>\n+              <entry key=\"java6\" value=\"true\" />\n+            </map>\n+          </option>\n+          <option name=\"resolveToWorkspace\" value=\"false\" />\n+          <option name=\"workingDirPath\" value=\"$PROJECT_DIR$\" />\n+        </MavenRunnerParameters>\n+      </option>\n+    </MavenSettings>\n+    <RunnerSettings RunnerId=\"Run\" />\n+    <ConfigurationWrapper RunnerId=\"Run\" />\n+    <method />\n+  </configuration>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "7f04adf0da68972e057686787b13dd3ca99c3beb",
        "previous_commit_hash": "4b6a595ccdea131ee5d286f000fef44d6a76eacd",
        "diff_stats": {
            "additions": 2,
            "deletions": 0
        },
        "diff_content": "@@ -61,6 +61,7 @@\n                             <target>\n                                 <property name=\"compile_classpath\" refid=\"maven.compile.classpath\"/>\n                                 <exec executable=\"${env.JAVA8_HOME}/bin/java\" failonerror=\"true\">\n+                                    <arg value=\"-Dretrolambda.bytecodeVersion=${testBytecodeVersion}\"/>\n                                     <arg value=\"-Dretrolambda.inputDir=${project.build.outputDirectory}\"/>\n                                     <arg value=\"-Dretrolambda.classpath=${compile_classpath}\"/>\n                                     <arg value=\"-javaagent:../retrolambda/target/retrolambda-${project.version}.jar\"/>\n@@ -80,6 +81,7 @@\n                             <target>\n                                 <property name=\"test_classpath\" refid=\"maven.test.classpath\"/>\n                                 <exec executable=\"${env.JAVA8_HOME}/bin/java\" failonerror=\"true\">\n+                                    <arg value=\"-Dretrolambda.bytecodeVersion=${testBytecodeVersion}\"/>\n                                     <arg value=\"-Dretrolambda.inputDir=${project.build.testOutputDirectory}\"/>\n                                     <arg value=\"-Dretrolambda.classpath=${test_classpath}\"/>\n                                     <arg value=\"-javaagent:../retrolambda/target/retrolambda-${project.version}.jar\"/>\n"
    },
    {
        "commit_hash": "7f04adf0da68972e057686787b13dd3ca99c3beb",
        "previous_commit_hash": "4b6a595ccdea131ee5d286f000fef44d6a76eacd",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -6,7 +6,7 @@ package net.orfjackal.retrolambda.test;\n \n import org.junit.Test;\n \n-import java.nio.charset.StandardCharsets;\n+import java.nio.charset.Charset;\n import java.util.*;\n import java.util.concurrent.Callable;\n \n@@ -36,7 +36,7 @@ public class LambdaTest {\n \n     @Test\n     public void lambda_taking_parameters() {\n-        Function1<String, Integer> lambda = (String s) -> s.getBytes(StandardCharsets.UTF_16BE).length;\n+        Function1<String, Integer> lambda = (String s) -> s.getBytes(Charset.forName(\"UTF-16BE\")).length;\n \n         assertThat(lambda.apply(\"foo\"), is(6));\n     }\n"
    },
    {
        "commit_hash": "7f04adf0da68972e057686787b13dd3ca99c3beb",
        "previous_commit_hash": "4b6a595ccdea131ee5d286f000fef44d6a76eacd",
        "diff_stats": {
            "additions": 41,
            "deletions": 0
        },
        "diff_content": "@@ -43,6 +43,7 @@\n         <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n         <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n         <minimumMavenVersion>3.0.3</minimumMavenVersion>\n+        <testBytecodeVersion>51</testBytecodeVersion>\n     </properties>\n \n     <prerequisites>\n@@ -329,6 +330,46 @@\n     </build>\n \n     <profiles>\n+        <profile>\n+            <id>java6</id>\n+\n+            <properties>\n+                <testBytecodeVersion>50</testBytecodeVersion>\n+            </properties>\n+\n+            <build>\n+                <plugins>\n+\n+                    <plugin>\n+                        <artifactId>maven-failsafe-plugin</artifactId>\n+                        <configuration>\n+                            <jvm>${env.JAVA6_HOME}/bin/java</jvm>\n+                        </configuration>\n+                    </plugin>\n+\n+                    <plugin>\n+                        <artifactId>maven-enforcer-plugin</artifactId>\n+                        <executions>\n+                            <execution>\n+                                <id>enforce-java6</id>\n+                                <goals>\n+                                    <goal>enforce</goal>\n+                                </goals>\n+                                <configuration>\n+                                    <rules>\n+                                        <requireEnvironmentVariable>\n+                                            <variableName>JAVA6_HOME</variableName>\n+                                        </requireEnvironmentVariable>\n+                                    </rules>\n+                                </configuration>\n+                            </execution>\n+                        </executions>\n+                    </plugin>\n+\n+                </plugins>\n+            </build>\n+        </profile>\n+\n         <profile>\n             <id>coverage-report</id>\n             <build>\n"
    },
    {
        "commit_hash": "7f04adf0da68972e057686787b13dd3ca99c3beb",
        "previous_commit_hash": "4b6a595ccdea131ee5d286f000fef44d6a76eacd",
        "diff_stats": {
            "additions": 7,
            "deletions": 0
        },
        "diff_content": "@@ -4,12 +4,15 @@\n \n package net.orfjackal.retrolambda;\n \n+import org.objectweb.asm.Opcodes;\n+\n import java.nio.file.*;\n import java.util.Properties;\n \n public class Config {\n \n     private static final String PREFIX = \"retrolambda.\";\n+    private static final String BYTECODE_VERSION = PREFIX + \"bytecodeVersion\";\n     private static final String INPUT_DIR = PREFIX + \"inputDir\";\n     private static final String OUTPUT_DIR = PREFIX + \"outputDir\";\n     private static final String CLASSPATH = PREFIX + \"classpath\";\n@@ -20,6 +23,10 @@ public class Config {\n         this.p = p;\n     }\n \n+    public int getBytecodeVersion() {\n+        return Integer.parseInt(p.getProperty(BYTECODE_VERSION, \"\" + Opcodes.V1_7));\n+    }\n+\n     public Path getInputDir() {\n         return Paths.get(getRequiredProperty(INPUT_DIR));\n     }\n"
    },
    {
        "commit_hash": "7f04adf0da68972e057686787b13dd3ca99c3beb",
        "previous_commit_hash": "4b6a595ccdea131ee5d286f000fef44d6a76eacd",
        "diff_stats": {
            "additions": 8,
            "deletions": 3
        },
        "diff_content": "@@ -11,20 +11,25 @@ public class LambdaClassBackporter {\n     private static final String MAGIC_LAMBDA_IMPL = \"java/lang/invoke/MagicLambdaImpl\";\n     private static final String JAVA_LANG_OBJECT = \"java/lang/Object\";\n \n-    public static byte[] transform(byte[] bytecode) {\n+    public static byte[] transform(byte[] bytecode, int targetVersion) {\n         ClassWriter writer = new ClassWriter(0);\n-        new ClassReader(bytecode).accept(new MyClassVisitor(writer), 0);\n+        new ClassReader(bytecode).accept(new MyClassVisitor(writer, targetVersion), 0);\n         return writer.toByteArray();\n     }\n \n     private static class MyClassVisitor extends ClassVisitor {\n+        private final int targetVersion;\n \n-        public MyClassVisitor(ClassWriter cw) {\n+        public MyClassVisitor(ClassWriter cw, int targetVersion) {\n             super(Opcodes.ASM4, cw);\n+            this.targetVersion = targetVersion;\n         }\n \n         @Override\n         public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n+            if (version > targetVersion) {\n+                version = targetVersion;\n+            }\n             if (superName.equals(MAGIC_LAMBDA_IMPL)) {\n                 superName = JAVA_LANG_OBJECT;\n             }\n"
    },
    {
        "commit_hash": "7f04adf0da68972e057686787b13dd3ca99c3beb",
        "previous_commit_hash": "4b6a595ccdea131ee5d286f000fef44d6a76eacd",
        "diff_stats": {
            "additions": 4,
            "deletions": 2
        },
        "diff_content": "@@ -18,10 +18,12 @@ public class LambdaSavingClassFileTransformer implements ClassFileTransformer {\n \n     private static final BlockingDeque<String> foundLambdaClasses = new LinkedBlockingDeque<>(1); // we expect only one at a time\n     private final Path outputDir;\n+    private final int targetVersion;\n     private final List<ClassLoader> ignoredClassLoaders = new ArrayList<>();\n \n-    public LambdaSavingClassFileTransformer(Path outputDir) {\n+    public LambdaSavingClassFileTransformer(Path outputDir, int targetVersion) {\n         this.outputDir = outputDir;\n+        this.targetVersion = targetVersion;\n         for (ClassLoader cl = ClassLoader.getSystemClassLoader(); cl != null; cl = cl.getParent()) {\n             ignoredClassLoaders.add(cl);\n         }\n@@ -45,7 +47,7 @@ public class LambdaSavingClassFileTransformer implements ClassFileTransformer {\n         try {\n             System.out.println(\"Saving lambda class: \" + className);\n             foundLambdaClasses.push(className);\n-            byte[] transformedBytes = LambdaClassBackporter.transform(classfileBuffer);\n+            byte[] transformedBytes = LambdaClassBackporter.transform(classfileBuffer,targetVersion);\n             Path savePath = outputDir.resolve(className + \".class\");\n             Files.createDirectories(savePath.getParent());\n             Files.write(savePath, transformedBytes);\n"
    },
    {
        "commit_hash": "7f04adf0da68972e057686787b13dd3ca99c3beb",
        "previous_commit_hash": "4b6a595ccdea131ee5d286f000fef44d6a76eacd",
        "diff_stats": {
            "additions": 10,
            "deletions": 5
        },
        "diff_content": "@@ -20,11 +20,11 @@ public class LambdaUsageBackporter {\n     private static final String LAMBDA_METAFACTORY = \"java/lang/invoke/LambdaMetafactory\";\n     private static final Pattern LAMBDA_IMPL_METHOD = Pattern.compile(\"^lambda\\\\$\\\\d+$\");\n \n-    public static byte[] transform(byte[] bytecode) {\n+    public static byte[] transform(byte[] bytecode, int targetVersion) {\n         asmJava8SupportWorkaround(bytecode);\n-        ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n-        new ClassReader(bytecode).accept(new MyClassVisitor(writer), 0);\n-        return writer.toByteArray();\n+        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n+        new ClassReader(bytecode).accept(new MyClassVisitor(cw, targetVersion), 0);\n+        return cw.toByteArray();\n     }\n \n     private static void asmJava8SupportWorkaround(byte[] bytecode) {\n@@ -43,14 +43,19 @@ public class LambdaUsageBackporter {\n \n     private static class MyClassVisitor extends ClassVisitor {\n         private final List<LambdaFactoryMethod> lambdaFactoryMethods = new ArrayList<>();\n+        private final int targetVersion;\n         private String className;\n \n-        public MyClassVisitor(ClassWriter cw) {\n+        public MyClassVisitor(ClassWriter cw, int targetVersion) {\n             super(Opcodes.ASM4, cw);\n+            this.targetVersion = targetVersion;\n         }\n \n         @Override\n         public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n+            if (version > targetVersion) {\n+                version = targetVersion;\n+            }\n             super.visit(version, access, name, signature, superName, interfaces);\n             this.className = name;\n         }\n"
    },
    {
        "commit_hash": "7f04adf0da68972e057686787b13dd3ca99c3beb",
        "previous_commit_hash": "4b6a595ccdea131ee5d286f000fef44d6a76eacd",
        "diff_stats": {
            "additions": 19,
            "deletions": 1
        },
        "diff_content": "@@ -4,6 +4,8 @@\n \n package net.orfjackal.retrolambda;\n \n+import org.objectweb.asm.Opcodes;\n+\n import java.io.*;\n import java.net.*;\n import java.nio.file.*;\n@@ -11,13 +13,29 @@ import java.util.*;\n \n public class Main {\n \n+    private static Map<Integer, String> bytecodeVersionNames = new HashMap<>();\n+\n+    static {\n+        bytecodeVersionNames.put(Opcodes.V1_1, \"Java 1.1\");\n+        bytecodeVersionNames.put(Opcodes.V1_2, \"Java 1.2\");\n+        bytecodeVersionNames.put(Opcodes.V1_3, \"Java 1.3\");\n+        bytecodeVersionNames.put(Opcodes.V1_4, \"Java 1.4\");\n+        bytecodeVersionNames.put(Opcodes.V1_5, \"Java 5\");\n+        bytecodeVersionNames.put(Opcodes.V1_6, \"Java 6\");\n+        bytecodeVersionNames.put(Opcodes.V1_7, \"Java 7\");\n+        bytecodeVersionNames.put(Opcodes.V1_7 + 1, \"Java 8\");\n+    }\n+\n     public static void main(String[] args) {\n         System.out.println(\"Retrolambda \" + getVersion());\n \n         Config config = new Config(System.getProperties());\n+        int bytecodeVersion = config.getBytecodeVersion();\n         Path inputDir = config.getInputDir();\n         Path outputDir = config.getOutputDir();\n         String classpath = config.getClasspath();\n+        System.out.println(\"Bytecode version: \" + bytecodeVersion\n+                + \" (\" + bytecodeVersionNames.getOrDefault(bytecodeVersion, \"unknown version\") + \")\");\n         System.out.println(\"Input directory:  \" + inputDir);\n         System.out.println(\"Output directory: \" + outputDir);\n         System.out.println(\"Classpath:        \" + classpath);\n@@ -31,7 +49,7 @@ public class Main {\n             Thread.currentThread().setContextClassLoader(new URLClassLoader(asUrls(classpath)));\n             Files.walkFileTree(inputDir, new BytecodeTransformingFileVisitor(inputDir, outputDir) {\n                 protected byte[] transform(byte[] bytecode) {\n-                    return LambdaUsageBackporter.transform(bytecode);\n+                    return LambdaUsageBackporter.transform(bytecode, bytecodeVersion);\n                 }\n             });\n \n"
    },
    {
        "commit_hash": "7f04adf0da68972e057686787b13dd3ca99c3beb",
        "previous_commit_hash": "4b6a595ccdea131ee5d286f000fef44d6a76eacd",
        "diff_stats": {
            "additions": 2,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,8 @@ public class PreMain {\n \n     public static void premain(String agentArgs, Instrumentation inst) {\n         Config config = new Config(System.getProperties());\n+        int bytecodeVersion = config.getBytecodeVersion();\n         Path outputDir = config.getOutputDir();\n-        inst.addTransformer(new LambdaSavingClassFileTransformer(outputDir));\n+        inst.addTransformer(new LambdaSavingClassFileTransformer(outputDir,bytecodeVersion));\n     }\n }\n"
    },
    {
        "commit_hash": "9fe55e33cc0e93c841668aff4cf411ba03076178",
        "previous_commit_hash": "7f04adf0da68972e057686787b13dd3ca99c3beb",
        "diff_stats": {
            "additions": 109,
            "deletions": 1
        },
        "diff_content": "@@ -7,7 +7,7 @@ package net.orfjackal.retrolambda;\n import org.objectweb.asm.Opcodes;\n \n import java.nio.file.*;\n-import java.util.Properties;\n+import java.util.*;\n \n public class Config {\n \n@@ -17,20 +17,76 @@ public class Config {\n     private static final String OUTPUT_DIR = PREFIX + \"outputDir\";\n     private static final String CLASSPATH = PREFIX + \"classpath\";\n \n+    private static final List<String> requiredProperties = new ArrayList<>();\n+    private static final List<String> requiredProperitesHelp = new ArrayList<>();\n+    private static final List<String> optionalPropertiesHelp = new ArrayList<>();\n+    private static final Map<Integer, String> bytecodeVersionNames = new HashMap<>();\n+\n+    static {\n+        bytecodeVersionNames.put(Opcodes.V1_1, \"Java 1.1\");\n+        bytecodeVersionNames.put(Opcodes.V1_2, \"Java 1.2\");\n+        bytecodeVersionNames.put(Opcodes.V1_3, \"Java 1.3\");\n+        bytecodeVersionNames.put(Opcodes.V1_4, \"Java 1.4\");\n+        bytecodeVersionNames.put(Opcodes.V1_5, \"Java 5\");\n+        bytecodeVersionNames.put(Opcodes.V1_6, \"Java 6\");\n+        bytecodeVersionNames.put(Opcodes.V1_7, \"Java 7\");\n+        bytecodeVersionNames.put(Opcodes.V1_7 + 1, \"Java 8\");\n+    }\n+\n     private final Properties p;\n \n     public Config(Properties p) {\n         this.p = p;\n     }\n \n+    public boolean isFullyConfigured() {\n+        for (String requiredParameter : requiredProperties) {\n+            if (p.getProperty(requiredParameter) == null) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+\n+    // bytecode version\n+\n+    static {\n+        optionalParameterHelp(BYTECODE_VERSION,\n+                \"Major version number for the generated bytecode. For a list, see\",\n+                \"offset 7 at http://en.wikipedia.org/wiki/Java_class_file#General_layout\",\n+                \"Default value is \" + Opcodes.V1_7 + \" (i.e. Java 7)\");\n+    }\n+\n     public int getBytecodeVersion() {\n         return Integer.parseInt(p.getProperty(BYTECODE_VERSION, \"\" + Opcodes.V1_7));\n     }\n \n+    public String getJavaVersion() {\n+        return bytecodeVersionNames.getOrDefault(getBytecodeVersion(), \"unknown version\");\n+    }\n+\n+\n+    // input dir\n+\n+    static {\n+        requiredParameterHelp(INPUT_DIR,\n+                \"Input directory from where the original class files are read.\");\n+    }\n+\n     public Path getInputDir() {\n         return Paths.get(getRequiredProperty(INPUT_DIR));\n     }\n \n+\n+    // output dir\n+\n+    static {\n+        optionalParameterHelp(OUTPUT_DIR,\n+                \"Output directory into where the generated class files are written.\",\n+                \"Defaults to same as \" + INPUT_DIR);\n+    }\n+\n     public Path getOutputDir() {\n         String outputDir = p.getProperty(OUTPUT_DIR);\n         if (outputDir == null) {\n@@ -39,6 +95,14 @@ public class Config {\n         return Paths.get(outputDir);\n     }\n \n+\n+    // classpath\n+\n+    static {\n+        requiredParameterHelp(CLASSPATH,\n+                \"Classpath containing the original class files and their dependencies.\");\n+    }\n+\n     public String getClasspath() {\n         return getRequiredProperty(CLASSPATH);\n     }\n@@ -50,4 +114,48 @@ public class Config {\n         }\n         return value;\n     }\n+\n+\n+    // help\n+\n+    public String getHelp() {\n+        String options = requiredProperties.stream()\n+                .map(key -> \"-D\" + key + \"=?\")\n+                .reduce((a, b) -> a + \" \" + b)\n+                .get();\n+        return \"Usage: java \" + options + \" -javaagent:retrolambda.jar -jar retrolambda.jar\\n\" +\n+                \"\\n\" +\n+                \"Retrolambda is a backporting tool for classes which use lambda expressions\\n\" +\n+                \"and have been compiled with Java 8, to run on Java 7 (maybe even Java 5).\\n\" +\n+                \"See https://github.com/orfjackal/retrolambda\\n\" +\n+                \"\\n\" +\n+                \"Copyright (c) 2013  Esko Luontola <www.orfjackal.net>\\n\" +\n+                \"This software is released under the Apache License 2.0.\\n\" +\n+                \"The license text is at http://www.apache.org/licenses/LICENSE-2.0\\n\" +\n+                \"\\n\" +\n+                \"Required system properties:\\n\" +\n+                \"\\n\" +\n+                requiredProperitesHelp.stream().reduce((a, b) -> a + \"\\n\" + b).get() +\n+                \"\\n\" +\n+                \"Optional system properties:\\n\" +\n+                \"\\n\" +\n+                optionalPropertiesHelp.stream().reduce((a, b) -> a + \"\\n\" + b).get();\n+    }\n+\n+    private static void requiredParameterHelp(String key, String... lines) {\n+        requiredProperties.add(key);\n+        requiredProperitesHelp.add(formatPropertyHelp(key, lines));\n+    }\n+\n+    private static void optionalParameterHelp(String key, String... lines) {\n+        optionalPropertiesHelp.add(formatPropertyHelp(key, lines));\n+    }\n+\n+    private static String formatPropertyHelp(String key, String... lines) {\n+        String s = \"  \" + key + \"\\n\";\n+        for (String line : lines) {\n+            s += \"      \" + line + \"\\n\";\n+        }\n+        return s;\n+    }\n }\n"
    },
    {
        "commit_hash": "9fe55e33cc0e93c841668aff4cf411ba03076178",
        "previous_commit_hash": "7f04adf0da68972e057686787b13dd3ca99c3beb",
        "diff_stats": {
            "additions": 5,
            "deletions": 17
        },
        "diff_content": "@@ -4,8 +4,6 @@\n \n package net.orfjackal.retrolambda;\n \n-import org.objectweb.asm.Opcodes;\n-\n import java.io.*;\n import java.net.*;\n import java.nio.file.*;\n@@ -13,29 +11,19 @@ import java.util.*;\n \n public class Main {\n \n-    private static Map<Integer, String> bytecodeVersionNames = new HashMap<>();\n-\n-    static {\n-        bytecodeVersionNames.put(Opcodes.V1_1, \"Java 1.1\");\n-        bytecodeVersionNames.put(Opcodes.V1_2, \"Java 1.2\");\n-        bytecodeVersionNames.put(Opcodes.V1_3, \"Java 1.3\");\n-        bytecodeVersionNames.put(Opcodes.V1_4, \"Java 1.4\");\n-        bytecodeVersionNames.put(Opcodes.V1_5, \"Java 5\");\n-        bytecodeVersionNames.put(Opcodes.V1_6, \"Java 6\");\n-        bytecodeVersionNames.put(Opcodes.V1_7, \"Java 7\");\n-        bytecodeVersionNames.put(Opcodes.V1_7 + 1, \"Java 8\");\n-    }\n-\n     public static void main(String[] args) {\n         System.out.println(\"Retrolambda \" + getVersion());\n \n         Config config = new Config(System.getProperties());\n+        if (!config.isFullyConfigured()) {\n+            System.out.print(config.getHelp());\n+            return;\n+        }\n         int bytecodeVersion = config.getBytecodeVersion();\n         Path inputDir = config.getInputDir();\n         Path outputDir = config.getOutputDir();\n         String classpath = config.getClasspath();\n-        System.out.println(\"Bytecode version: \" + bytecodeVersion\n-                + \" (\" + bytecodeVersionNames.getOrDefault(bytecodeVersion, \"unknown version\") + \")\");\n+        System.out.println(\"Bytecode version: \" + bytecodeVersion + \" (\" + config.getJavaVersion() + \")\");\n         System.out.println(\"Input directory:  \" + inputDir);\n         System.out.println(\"Output directory: \" + outputDir);\n         System.out.println(\"Classpath:        \" + classpath);\n"
    },
    {
        "commit_hash": "71600f1ae3fcd1399de3df95d444cb12626eac28",
        "previous_commit_hash": "9fe55e33cc0e93c841668aff4cf411ba03076178",
        "diff_stats": {
            "additions": 73,
            "deletions": 6
        },
        "diff_content": "@@ -3,12 +3,79 @@ Retrolambda: Use Lambdas on Java 7\n ==================================\n \n Just as there was [Retroweaver](http://retroweaver.sourceforge.net/) et al.\n-for running Java 5 code with generics on Java 1.4, *Retrolambda* lets you\n-run Java 8 code with lambda expressions on Java 7. It does this by\n-transforming your Java 8 compiled bytecode so that it can be run on Java 7\n+for running Java 5 code with generics on Java 1.4, **Retrolambda** lets you\n+run Java 8 code with lambda expressions on Java 7 or lower. It does this by\n+transforming your Java 8 compiled bytecode so that it can run on a Java 7\n runtime.\n \n-This tool backports only lambda expressions - it doesn't let you use the\n-Java APIs that are new in Java 8.\n+Adventurous developers may use Retrolambda to backport lambda expressions\n+even to Java 6 or Java 5. And if you reach Java 5, there are [other\n+backporting tools](http://en.wikipedia.org/wiki/Java_backporting_tools)\n+that may let you go down to Java 1.4.\n \n-**WORK IN PROGRESS**\n+\n+User Guide\n+----------\n+\n+Until downloads are available, follow the instructions in\n+[Compiling](#compiling) to build Retrolambda yourselves.\n+\n+Use JDK 8 to compile your source code.\n+\n+Run Retrolambda on the class files produced by JDK 8. Run `java -jar\n+retrolambda.jar` without any additional options to see the instructions.\n+\n+For an example of how to do this with Maven AntRun Plugin, see [end-to-end-tests/pom.xml](https://github.com/orfjackal/retrolambda/blob/master/end-to-end-tests/pom.xml)\n+Also Maven Dependency Plugin's [dependency:copy](http://maven.apache.org/plugins/maven-dependency-plugin/copy-mojo.html)\n+may be useful for copying retrolambda.jar to a known location.\n+\n+Your class files should now run on Java 7.\n+\n+Be sure to run comprehensive tests on Java 7, in case the code accidentally\n+uses Java 8 APIs or language features that Retrolambda doesn't backport.\n+\n+\n+Compiling\n+---------\n+\n+Set the environment variables `JAVA8_HOME`, `JAVA7_HOME` and optionally\n+also `JAVA6_HOME` point to the installation directories of those particular\n+JDK versions.\n+\n+Compile the project with Maven using the command:\n+\n+    mvn clean verify\n+\n+To run the tests using Java 6, use the command:\n+\n+    mvn clean verify -P java6\n+\n+Finally copy the executable JAR from the `retrolambda/target/` directory.\n+\n+\n+Known Limitations\n+-----------------\n+\n+Does not backport the use of Java 8 APIs.\n+\n+Does not backport Java 8 language features other than lambda expressions.\n+\n+Does not support serializable lambda expressions. Implementing support for\n+them would technically be possible, but it would require projects to have a\n+runtime dependency on a library which would contain a backported copy of\n+the `java.lang.invoke.SerializedLambda` class. If you really need it, make\n+a feature request. ;-)\n+\n+May break if a future JDK 8 build stops generating a new class for each\n+`invokedynamic` call. Retrolambda works so that it captures the bytecode\n+that `java.lang.invoke.LambdaMetafactory` generates dynamically, so\n+optimizations to that mechanism may break Retrolambda.\n+\n+\n+Version History\n+---------------\n+\n+**Next Release**\n+\n+- Backports lambda expressions and method handles to Java 7 and older\n+- Tested to work with JDK 8 Early Access Build b99 (2013-07-19)\n"
    },
    {
        "commit_hash": "766decd2523ac686c017aae2640350181c8bf8db",
        "previous_commit_hash": "71600f1ae3fcd1399de3df95d444cb12626eac28",
        "diff_stats": {
            "additions": 31,
            "deletions": 6
        },
        "diff_content": "@@ -48,11 +48,36 @@\n \n             <!-- Process our byte codes to make them run on Java 7 -->\n \n+            <plugin>\n+                <artifactId>maven-dependency-plugin</artifactId>\n+                <executions>\n+                    <execution>\n+                        <id>copy-retrolambda</id>\n+                        <phase>process-classes</phase>\n+                        <goals>\n+                            <goal>copy</goal>\n+                        </goals>\n+                        <configuration>\n+                            <artifactItems>\n+                                <artifactItem>\n+                                    <groupId>net.orfjackal.retrolambda</groupId>\n+                                    <artifactId>retrolambda</artifactId>\n+                                    <version>${project.version}</version>\n+                                    <overWrite>true</overWrite>\n+                                    <outputDirectory>${project.build.directory}</outputDirectory>\n+                                    <destFileName>retrolambda.jar</destFileName>\n+                                </artifactItem>\n+                            </artifactItems>\n+                        </configuration>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+\n             <plugin>\n                 <artifactId>maven-antrun-plugin</artifactId>\n                 <executions>\n                     <execution>\n-                        <id>process-classes</id>\n+                        <id>retrolambda-classes</id>\n                         <phase>process-classes</phase>\n                         <goals>\n                             <goal>run</goal>\n@@ -64,15 +89,15 @@\n                                     <arg value=\"-Dretrolambda.bytecodeVersion=${testBytecodeVersion}\"/>\n                                     <arg value=\"-Dretrolambda.inputDir=${project.build.outputDirectory}\"/>\n                                     <arg value=\"-Dretrolambda.classpath=${compile_classpath}\"/>\n-                                    <arg value=\"-javaagent:../retrolambda/target/retrolambda-${project.version}.jar\"/>\n+                                    <arg value=\"-javaagent:${project.build.directory}/retrolambda.jar\"/>\n                                     <arg value=\"-jar\"/>\n-                                    <arg value=\"../retrolambda/target/retrolambda-${project.version}.jar\"/>\n+                                    <arg value=\"${project.build.directory}/retrolambda.jar\"/>\n                                 </exec>\n                             </target>\n                         </configuration>\n                     </execution>\n                     <execution>\n-                        <id>process-test-classes</id>\n+                        <id>retrolambda-test-classes</id>\n                         <phase>process-test-classes</phase>\n                         <goals>\n                             <goal>run</goal>\n@@ -84,9 +109,9 @@\n                                     <arg value=\"-Dretrolambda.bytecodeVersion=${testBytecodeVersion}\"/>\n                                     <arg value=\"-Dretrolambda.inputDir=${project.build.testOutputDirectory}\"/>\n                                     <arg value=\"-Dretrolambda.classpath=${test_classpath}\"/>\n-                                    <arg value=\"-javaagent:../retrolambda/target/retrolambda-${project.version}.jar\"/>\n+                                    <arg value=\"-javaagent:${project.build.directory}/retrolambda.jar\"/>\n                                     <arg value=\"-jar\"/>\n-                                    <arg value=\"../retrolambda/target/retrolambda-${project.version}.jar\"/>\n+                                    <arg value=\"${project.build.directory}/retrolambda.jar\"/>\n                                 </exec>\n                             </target>\n                         </configuration>\n"
    },
    {
        "commit_hash": "490936e71ff4f4a81ed39da24cbcf359fc58e7e9",
        "previous_commit_hash": "766decd2523ac686c017aae2640350181c8bf8db",
        "diff_stats": {
            "additions": 0,
            "deletions": 43
        },
        "diff_content": "@@ -319,12 +319,6 @@\n                     <version>1.3.1</version>\n                 </plugin>\n \n-                <plugin>\n-                    <groupId>org.pitest</groupId>\n-                    <artifactId>pitest-maven</artifactId>\n-                    <version>0.29</version>\n-                </plugin>\n-\n             </plugins>\n         </pluginManagement>\n     </build>\n@@ -369,43 +363,6 @@\n                 </plugins>\n             </build>\n         </profile>\n-\n-        <profile>\n-            <id>coverage-report</id>\n-            <build>\n-                <plugins>\n-                    <plugin>\n-                        <groupId>org.pitest</groupId>\n-                        <artifactId>pitest-maven</artifactId>\n-                        <executions>\n-                            <execution>\n-                                <goals>\n-                                    <goal>mutationCoverage</goal>\n-                                </goals>\n-                            </execution>\n-                        </executions>\n-                        <configuration>\n-                            <threads>4</threads>\n-                            <jvmArgs>\n-                                <arg>-ea</arg>\n-                            </jvmArgs>\n-                            <targetClasses>\n-                                <pattern>net.orfjackal.retrolambda.*</pattern>\n-                            </targetClasses>\n-                            <targetTests>\n-                                <pattern>net.orfjackal.retrolambda.*Test</pattern>\n-                            </targetTests>\n-                            <failWhenNoMutations>false</failWhenNoMutations>\n-                            <timestampedReports>false</timestampedReports>\n-                            <mutators>\n-                                <mutator>ALL</mutator>\n-                            </mutators>\n-                            <mutateStaticInitializers>true</mutateStaticInitializers>\n-                        </configuration>\n-                    </plugin>\n-                </plugins>\n-            </build>\n-        </profile>\n     </profiles>\n \n </project>\n"
    },
    {
        "commit_hash": "e45db59b08f8d15ebf22f7737c71c15b21b1886f",
        "previous_commit_hash": "490936e71ff4f4a81ed39da24cbcf359fc58e7e9",
        "diff_stats": {
            "additions": 16,
            "deletions": 11
        },
        "diff_content": "@@ -152,6 +152,8 @@\n \n             <plugin>\n                 <artifactId>maven-source-plugin</artifactId>\n+                <!-- Overrides the version from oss-parent -->\n+                <version>2.2</version>\n                 <executions>\n                     <execution>\n                         <id>attach-sources</id>\n@@ -162,8 +164,21 @@\n                 </executions>\n             </plugin>\n \n+            <plugin>\n+                <artifactId>maven-javadoc-plugin</artifactId>\n+                <!-- Overrides the version from oss-parent -->\n+                <version>2.9.1</version>\n+            </plugin>\n+\n+            <plugin>\n+                <artifactId>maven-release-plugin</artifactId>\n+                <!-- Overrides the version from oss-parent -->\n+                <version>2.4.1</version>\n+            </plugin>\n+\n             <plugin>\n                 <artifactId>maven-enforcer-plugin</artifactId>\n+                <!-- Overrides the version from oss-parent -->\n                 <version>1.3.1</version>\n                 <executions>\n                     <execution>\n@@ -207,7 +222,7 @@\n                              There appears to be some stale state from previous executions of the Shade plugin,\n                              which manifest themselves as \"We have a duplicate\" warnings on build and also as\n                              some classes not being updated on build. -->\n-                        <id>delete-old-artifact</id>\n+                        <id>shade-plugin-workaround</id>\n                         <phase>prepare-package</phase>\n                         <goals>\n                             <goal>run</goal>\n@@ -245,16 +260,6 @@\n                     <version>2.4</version>\n                 </plugin>\n \n-                <plugin>\n-                    <artifactId>maven-source-plugin</artifactId>\n-                    <version>2.1.2</version>\n-                </plugin>\n-\n-                <plugin>\n-                    <artifactId>maven-javadoc-plugin</artifactId>\n-                    <version>2.9.1</version>\n-                </plugin>\n-\n                 <plugin>\n                     <artifactId>maven-install-plugin</artifactId>\n                     <version>2.4</version>\n"
    },
    {
        "commit_hash": "b0f3876b761c1761e6e7dd721728e490456dbdbc",
        "previous_commit_hash": "e45db59b08f8d15ebf22f7737c71c15b21b1886f",
        "diff_stats": {
            "additions": 14,
            "deletions": 0
        },
        "diff_content": "@@ -168,6 +168,9 @@\n                 <artifactId>maven-javadoc-plugin</artifactId>\n                 <!-- Overrides the version from oss-parent -->\n                 <version>2.9.1</version>\n+                <configuration>\n+                    <javadocExecutable>${env.JAVA8_HOME}/bin/javadoc</javadocExecutable>\n+                </configuration>\n             </plugin>\n \n             <plugin>\n@@ -324,6 +327,17 @@\n                     <version>1.3.1</version>\n                 </plugin>\n \n+                <plugin>\n+                    <groupId>org.sonatype.plugins</groupId>\n+                    <artifactId>nexus-staging-maven-plugin</artifactId>\n+                    <version>1.4.4</version>\n+                    <configuration>\n+                        <nexusUrl>https://oss.sonatype.org/</nexusUrl>\n+                        <serverId>ossrh-releases</serverId>\n+                        <stagingProfileId>9e9bbc30f020cf</stagingProfileId>\n+                    </configuration>\n+                </plugin>\n+\n             </plugins>\n         </pluginManagement>\n     </build>\n"
    },
    {
        "commit_hash": "b0f3876b761c1761e6e7dd721728e490456dbdbc",
        "previous_commit_hash": "e45db59b08f8d15ebf22f7737c71c15b21b1886f",
        "diff_stats": {
            "additions": 18,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,18 @@\n+#!/bin/bash\n+set -eu\n+: ${1:? Usage: $0 DESCRIPTION}\n+DESCRIPTION=\"$1\"\n+set -x\n+\n+# TODO: release OSSRH and push to GitHub automatically\n+#mvn nexus-staging:release \\\n+#    --errors \\\n+#    -DaltStagingDirectory=staging \\\n+#    -DstagingDescription=\"$DESCRIPTION\"\n+\n+set +x\n+echo \"\"\n+echo \"Done. Next steps:\"\n+echo \"    open https://oss.sonatype.org/\"\n+echo \"    git push origin HEAD\"\n+echo \"    git push origin --tags\"\n"
    },
    {
        "commit_hash": "b0f3876b761c1761e6e7dd721728e490456dbdbc",
        "previous_commit_hash": "e45db59b08f8d15ebf22f7737c71c15b21b1886f",
        "diff_stats": {
            "additions": 39,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,39 @@\n+#!/bin/bash\n+set -eu\n+: ${1:? Usage: $0 RELEASE_VERSION}\n+SCRIPTS=`dirname \"$0\"`\n+\n+RELEASE_VERSION=\"$1\"\n+if [[ ! \"$RELEASE_VERSION\" =~ ^[0-9]+\\.[0-9]+\\.[0-9]+$ ]]; then\n+    echo \"Error: RELEASE_VERSION must be in X.Y.Z format, but was $RELEASE_VERSION\"\n+    exit 1\n+fi\n+\n+function bump_version()\n+{\n+    local prefix=`echo $1 | sed -n -r 's/([0-9]+\\.[0-9]+\\.)[0-9]+/\\1/p'`\n+    local suffix=`echo $1 | sed -n -r 's/[0-9]+\\.[0-9]+\\.([0-9]+)/\\1/p'`\n+    ((suffix++))\n+    echo \"$prefix$suffix-SNAPSHOT\"\n+}\n+NEXT_VERSION=`bump_version $RELEASE_VERSION`\n+set -x\n+\n+mvn versions:set \\\n+    -DgenerateBackupPoms=false \\\n+    -DnewVersion=\"$RELEASE_VERSION\" \\\n+    --file parent/pom.xml\n+git add -u\n+git commit -m \"Release $RELEASE_VERSION\"\n+git tag -s -m \"Retrolambda $RELEASE_VERSION\" \"v$RELEASE_VERSION\"\n+\n+$SCRIPTS/stage.sh \"Retrolambda $RELEASE_VERSION\"\n+\n+mvn versions:set \\\n+    -DgenerateBackupPoms=false \\\n+    -DnewVersion=\"$NEXT_VERSION\" \\\n+    --file parent/pom.xml\n+git add -u\n+git commit -m \"Prepare for next development iteration\"\n+\n+$SCRIPTS/publish.sh \"Retrolambda $RELEASE_VERSION\"\n"
    },
    {
        "commit_hash": "b0f3876b761c1761e6e7dd721728e490456dbdbc",
        "previous_commit_hash": "e45db59b08f8d15ebf22f7737c71c15b21b1886f",
        "diff_stats": {
            "additions": 21,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,21 @@\n+#!/bin/bash\n+set -eu\n+: ${1:? Usage: $0 DESCRIPTION}\n+DESCRIPTION=\"$1\"\n+set -x\n+\n+rm -rfv staging\n+\n+mvn clean verify \\\n+    --errors \\\n+    -P java6\n+\n+mvn clean deploy \\\n+    --errors \\\n+    -P sonatype-oss-release \\\n+    -DaltDeploymentRepository=\"staging::default::file:staging\"\n+\n+mvn nexus-staging:deploy-staged-repository \\\n+    --errors \\\n+    -DrepositoryDirectory=staging \\\n+    -DstagingDescription=\"$DESCRIPTION\"\n"
    },
    {
        "commit_hash": "8619f0d1cc8a24def2bc1df1bca59742189f312c",
        "previous_commit_hash": "b0f3876b761c1761e6e7dd721728e490456dbdbc",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>0.1-SNAPSHOT</version>\n+        <version>1.0.0</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "8619f0d1cc8a24def2bc1df1bca59742189f312c",
        "previous_commit_hash": "b0f3876b761c1761e6e7dd721728e490456dbdbc",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>0.1-SNAPSHOT</version>\n+    <version>1.0.0</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "8619f0d1cc8a24def2bc1df1bca59742189f312c",
        "previous_commit_hash": "b0f3876b761c1761e6e7dd721728e490456dbdbc",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>0.1-SNAPSHOT</version>\n+        <version>1.0.0</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "8619f0d1cc8a24def2bc1df1bca59742189f312c",
        "previous_commit_hash": "b0f3876b761c1761e6e7dd721728e490456dbdbc",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>0.1-SNAPSHOT</version>\n+        <version>1.0.0</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "09acefbba1f2449f656d5da4a281b4d975571f39",
        "previous_commit_hash": "8619f0d1cc8a24def2bc1df1bca59742189f312c",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.0.0</version>\n+        <version>1.0.1-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "09acefbba1f2449f656d5da4a281b4d975571f39",
        "previous_commit_hash": "8619f0d1cc8a24def2bc1df1bca59742189f312c",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>1.0.0</version>\n+    <version>1.0.1-SNAPSHOT</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "09acefbba1f2449f656d5da4a281b4d975571f39",
        "previous_commit_hash": "8619f0d1cc8a24def2bc1df1bca59742189f312c",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.0.0</version>\n+        <version>1.0.1-SNAPSHOT</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "09acefbba1f2449f656d5da4a281b4d975571f39",
        "previous_commit_hash": "8619f0d1cc8a24def2bc1df1bca59742189f312c",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.0.0</version>\n+        <version>1.0.1-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "86a4471cc0b204fd009934249c7f8a7d0787e718",
        "previous_commit_hash": "09acefbba1f2449f656d5da4a281b4d975571f39",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -75,7 +75,7 @@ optimizations to that mechanism may break Retrolambda.\n Version History\n ---------------\n \n-**Next Release**\n+**Retrolambda 1.0.0 (2013-07-23)**\n \n - Backports lambda expressions and method handles to Java 7 and older\n - Tested to work with JDK 8 Early Access Build b99 (2013-07-19)\n"
    },
    {
        "commit_hash": "92757f6ed292377bd4866fc3178d6190f332b457",
        "previous_commit_hash": "86a4471cc0b204fd009934249c7f8a7d0787e718",
        "diff_stats": {
            "additions": 4,
            "deletions": 6
        },
        "diff_content": "@@ -17,17 +17,15 @@ that may let you go down to Java 1.4.\n User Guide\n ----------\n \n-Until downloads are available, follow the instructions in\n-[Compiling](#compiling) to build Retrolambda yourselves.\n+[Download](https://oss.sonatype.org/content/repositories/releases/net/orfjackal/retrolambda/retrolambda/)\n+the latest retrolambda.jar from Maven Central.\n \n Use JDK 8 to compile your source code.\n \n Run Retrolambda on the class files produced by JDK 8. Run `java -jar\n retrolambda.jar` without any additional options to see the instructions.\n-\n-For an example of how to do this with Maven AntRun Plugin, see [end-to-end-tests/pom.xml](https://github.com/orfjackal/retrolambda/blob/master/end-to-end-tests/pom.xml)\n-Also Maven Dependency Plugin's [dependency:copy](http://maven.apache.org/plugins/maven-dependency-plugin/copy-mojo.html)\n-may be useful for copying retrolambda.jar to a known location.\n+For an example of how to do this with Maven, see how maven-dependency-plugin\n+and maven-antrun-plugin are used in [end-to-end-tests/pom.xml](https://github.com/orfjackal/retrolambda/blob/master/end-to-end-tests/pom.xml)\n \n Your class files should now run on Java 7.\n \n"
    },
    {
        "commit_hash": "b47178dcaf289ad6dd31272bde0f9f29a71777f9",
        "previous_commit_hash": "92757f6ed292377bd4866fc3178d6190f332b457",
        "diff_stats": {
            "additions": 13,
            "deletions": 12
        },
        "diff_content": "@@ -22,31 +22,32 @@ the latest retrolambda.jar from Maven Central.\n \n Use JDK 8 to compile your source code.\n \n-Run Retrolambda on the class files produced by JDK 8. Run `java -jar\n-retrolambda.jar` without any additional options to see the instructions.\n-For an example of how to do this with Maven, see how maven-dependency-plugin\n-and maven-antrun-plugin are used in [end-to-end-tests/pom.xml](https://github.com/orfjackal/retrolambda/blob/master/end-to-end-tests/pom.xml)\n+Run Retrolambda, using Java 8, on the class files produced by JDK 8. Run\n+`java -jar retrolambda.jar` without any additional options to see the\n+instructions. For an example of how to do this with Maven, see how\n+maven-dependency-plugin and maven-antrun-plugin are used in\n+[end-to-end-tests/pom.xml](https://github.com/orfjackal/retrolambda/blob/master/end-to-end-tests/pom.xml)\n \n-Your class files should now run on Java 7.\n-\n-Be sure to run comprehensive tests on Java 7, in case the code accidentally\n-uses Java 8 APIs or language features that Retrolambda doesn't backport.\n+Your class files should now run on Java 7. Be sure to run comprehensive tests on\n+Java 7, in case the code accidentally uses Java 8 APIs or language features that\n+Retrolambda doesn't backport.\n \n \n Compiling\n ---------\n \n-Set the environment variables `JAVA8_HOME`, `JAVA7_HOME` and optionally\n-also `JAVA6_HOME` point to the installation directories of those particular\n-JDK versions.\n+Set the environment variables `JAVA8_HOME` and `JAVA7_HOME` (optionally also\n+`JAVA6_HOME` and `JAVA5_HOME`) point to the installation directories of those\n+particular JDK versions.\n \n Compile the project with Maven using the command:\n \n     mvn clean verify\n \n-To run the tests using Java 6, use the command:\n+To run the tests using Java 6 and Java 5, use the commands:\n \n     mvn clean verify -P java6\n+    mvn clean verify -P java5\n \n Finally copy the executable JAR from the `retrolambda/target/` directory.\n \n"
    },
    {
        "commit_hash": "b47178dcaf289ad6dd31272bde0f9f29a71777f9",
        "previous_commit_hash": "92757f6ed292377bd4866fc3178d6190f332b457",
        "diff_stats": {
            "additions": 2,
            "deletions": 3
        },
        "diff_content": "@@ -6,7 +6,6 @@ package net.orfjackal.retrolambda.test;\n \n import org.junit.Test;\n \n-import java.nio.charset.Charset;\n import java.util.*;\n import java.util.concurrent.Callable;\n \n@@ -36,9 +35,9 @@ public class LambdaTest {\n \n     @Test\n     public void lambda_taking_parameters() {\n-        Function1<String, Integer> lambda = (String s) -> s.getBytes(Charset.forName(\"UTF-16BE\")).length;\n+        Function1<String, Integer> lambda = (String s) -> s.getBytes().length;\n \n-        assertThat(lambda.apply(\"foo\"), is(6));\n+        assertThat(lambda.apply(\"foo\"), is(3));\n     }\n \n     @Test\n"
    },
    {
        "commit_hash": "b47178dcaf289ad6dd31272bde0f9f29a71777f9",
        "previous_commit_hash": "92757f6ed292377bd4866fc3178d6190f332b457",
        "diff_stats": {
            "additions": 23,
            "deletions": 43
        },
        "diff_content": "@@ -43,6 +43,8 @@\n         <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n         <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n         <minimumMavenVersion>3.0.3</minimumMavenVersion>\n+        <compileJavaHome>${env.JAVA8_HOME}</compileJavaHome>\n+        <testJavaHome>${env.JAVA7_HOME}</testJavaHome>\n         <testBytecodeVersion>51</testBytecodeVersion>\n     </properties>\n \n@@ -124,7 +126,7 @@\n                     <source>1.8</source>\n                     <target>1.8</target>\n                     <fork>true</fork>\n-                    <executable>${env.JAVA8_HOME}/bin/javac</executable>\n+                    <executable>${compileJavaHome}/bin/javac</executable>\n                 </configuration>\n             </plugin>\n \n@@ -135,7 +137,7 @@\n                         <include>**/*Test.class</include>\n                     </includes>\n                     <redirectTestOutputToFile>true</redirectTestOutputToFile>\n-                    <jvm>${env.JAVA8_HOME}/bin/java</jvm>\n+                    <jvm>${compileJavaHome}/bin/java</jvm>\n                 </configuration>\n             </plugin>\n \n@@ -146,7 +148,7 @@\n                         <include>**/*Test.class</include>\n                     </includes>\n                     <redirectTestOutputToFile>true</redirectTestOutputToFile>\n-                    <jvm>${env.JAVA7_HOME}/bin/java</jvm>\n+                    <jvm>${testJavaHome}/bin/java</jvm>\n                 </configuration>\n             </plugin>\n \n@@ -169,7 +171,7 @@\n                 <!-- Overrides the version from oss-parent -->\n                 <version>2.9.1</version>\n                 <configuration>\n-                    <javadocExecutable>${env.JAVA8_HOME}/bin/javadoc</javadocExecutable>\n+                    <javadocExecutable>${compileJavaHome}/bin/javadoc</javadocExecutable>\n                 </configuration>\n             </plugin>\n \n@@ -205,12 +207,15 @@\n                         </goals>\n                         <configuration>\n                             <rules>\n-                                <requireEnvironmentVariable>\n-                                    <variableName>JAVA7_HOME</variableName>\n-                                </requireEnvironmentVariable>\n-                                <requireEnvironmentVariable>\n-                                    <variableName>JAVA8_HOME</variableName>\n-                                </requireEnvironmentVariable>\n+                                <requireFilesExist>\n+                                    <message>\n+                                        Java installation directory not found. Set the necessary environment variable.\n+                                    </message>\n+                                    <files>\n+                                        <file>${testJavaHome}</file>\n+                                        <file>${compileJavaHome}</file>\n+                                    </files>\n+                                </requireFilesExist>\n                             </rules>\n                         </configuration>\n                     </execution>\n@@ -345,42 +350,17 @@\n     <profiles>\n         <profile>\n             <id>java6</id>\n-\n             <properties>\n+                <testJavaHome>${env.JAVA6_HOME}</testJavaHome>\n                 <testBytecodeVersion>50</testBytecodeVersion>\n             </properties>\n-\n-            <build>\n-                <plugins>\n-\n-                    <plugin>\n-                        <artifactId>maven-failsafe-plugin</artifactId>\n-                        <configuration>\n-                            <jvm>${env.JAVA6_HOME}/bin/java</jvm>\n-                        </configuration>\n-                    </plugin>\n-\n-                    <plugin>\n-                        <artifactId>maven-enforcer-plugin</artifactId>\n-                        <executions>\n-                            <execution>\n-                                <id>enforce-java6</id>\n-                                <goals>\n-                                    <goal>enforce</goal>\n-                                </goals>\n-                                <configuration>\n-                                    <rules>\n-                                        <requireEnvironmentVariable>\n-                                            <variableName>JAVA6_HOME</variableName>\n-                                        </requireEnvironmentVariable>\n-                                    </rules>\n-                                </configuration>\n-                            </execution>\n-                        </executions>\n-                    </plugin>\n-\n-                </plugins>\n-            </build>\n+        </profile>\n+        <profile>\n+            <id>java5</id>\n+            <properties>\n+                <testJavaHome>${env.JAVA5_HOME}</testJavaHome>\n+                <testBytecodeVersion>49</testBytecodeVersion>\n+            </properties>\n         </profile>\n     </profiles>\n \n"
    },
    {
        "commit_hash": "b47178dcaf289ad6dd31272bde0f9f29a71777f9",
        "previous_commit_hash": "92757f6ed292377bd4866fc3178d6190f332b457",
        "diff_stats": {
            "additions": 4,
            "deletions": 0
        },
        "diff_content": "@@ -10,6 +10,10 @@ mvn clean verify \\\n     --errors \\\n     -P java6\n \n+mvn clean verify \\\n+    --errors \\\n+    -P java5\n+\n mvn clean deploy \\\n     --errors \\\n     -P sonatype-oss-release \\\n"
    },
    {
        "commit_hash": "33dbcf17b0adf9260e6fd01c6bca16fdb2d97072",
        "previous_commit_hash": "b47178dcaf289ad6dd31272bde0f9f29a71777f9",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -17,8 +17,8 @@ that may let you go down to Java 1.4.\n User Guide\n ----------\n \n-[Download](https://oss.sonatype.org/content/repositories/releases/net/orfjackal/retrolambda/retrolambda/)\n-the latest retrolambda.jar from Maven Central.\n+[Download](http://repo.maven.apache.org/maven2/net/orfjackal/retrolambda/retrolambda/)\n+the latest `retrolambda.jar` from Maven Central.\n \n Use JDK 8 to compile your source code.\n \n"
    },
    {
        "commit_hash": "ffb985051b4f61e5e11babf40dcd6746066f37a0",
        "previous_commit_hash": "33dbcf17b0adf9260e6fd01c6bca16fdb2d97072",
        "diff_stats": {
            "additions": 7,
            "deletions": 4
        },
        "diff_content": "@@ -208,14 +208,17 @@\n                         <configuration>\n                             <rules>\n                                 <requireFilesExist>\n-                                    <message>\n-                                        Java installation directory not found. Set the necessary environment variable.\n-                                    </message>\n+                                    <message>Java installation directory not found: ${compileJavaHome}</message>\n                                     <files>\n-                                        <file>${testJavaHome}</file>\n                                         <file>${compileJavaHome}</file>\n                                     </files>\n                                 </requireFilesExist>\n+                                <requireFilesExist>\n+                                    <message>Java installation directory not found: ${testJavaHome}</message>\n+                                    <files>\n+                                        <file>${testJavaHome}</file>\n+                                    </files>\n+                                </requireFilesExist>\n                             </rules>\n                         </configuration>\n                     </execution>\n"
    },
    {
        "commit_hash": "3d2e37afa736f5674b5098f0452007a1e81c1f1e",
        "previous_commit_hash": "ffb985051b4f61e5e11babf40dcd6746066f37a0",
        "diff_stats": {
            "additions": 6,
            "deletions": 1
        },
        "diff_content": "@@ -6,13 +6,18 @@ Just as there was [Retroweaver](http://retroweaver.sourceforge.net/) et al.\n for running Java 5 code with generics on Java 1.4, **Retrolambda** lets you\n run Java 8 code with lambda expressions on Java 7 or lower. It does this by\n transforming your Java 8 compiled bytecode so that it can run on a Java 7\n-runtime.\n+runtime. After the transformation they are just a bunch of normal .class\n+files, without adding any runtime dependencies.\n \n Adventurous developers may use Retrolambda to backport lambda expressions\n even to Java 6 or Java 5. And if you reach Java 5, there are [other\n backporting tools](http://en.wikipedia.org/wiki/Java_backporting_tools)\n that may let you go down to Java 1.4.\n \n+P.S. If you hear about experiences of using Retrolambda for Android\n+development, please [send a message](https://github.com/orfjackal). In\n+theory it should be possible...\n+\n \n User Guide\n ----------\n"
    },
    {
        "commit_hash": "e750dd75fae8d79d67776e17759eeb2b20655e81",
        "previous_commit_hash": "3d2e37afa736f5674b5098f0452007a1e81c1f1e",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -4,13 +4,13 @@\n \n package net.orfjackal.retrolambda;\n \n-import org.objectweb.asm.Opcodes;\n+import static org.objectweb.asm.Opcodes.ACC_PRIVATE;\n \n public class Flags {\n \n     public static int makeNonPrivate(int access) {\n-        if (hasFlag(access, Opcodes.ACC_PRIVATE)) {\n-            return clearFlag(access, Opcodes.ACC_PRIVATE); // make package-private (i.e. no flag)\n+        if (hasFlag(access, ACC_PRIVATE)) {\n+            return clearFlag(access, ACC_PRIVATE); // make package-private (i.e. no flag)\n         }\n         return access;\n     }\n"
    },
    {
        "commit_hash": "e750dd75fae8d79d67776e17759eeb2b20655e81",
        "previous_commit_hash": "3d2e37afa736f5674b5098f0452007a1e81c1f1e",
        "diff_stats": {
            "additions": 5,
            "deletions": 3
        },
        "diff_content": "@@ -6,6 +6,8 @@ package net.orfjackal.retrolambda;\n \n import org.objectweb.asm.*;\n \n+import static org.objectweb.asm.Opcodes.*;\n+\n public class LambdaClassBackporter {\n \n     private static final String MAGIC_LAMBDA_IMPL = \"java/lang/invoke/MagicLambdaImpl\";\n@@ -21,7 +23,7 @@ public class LambdaClassBackporter {\n         private final int targetVersion;\n \n         public MyClassVisitor(ClassWriter cw, int targetVersion) {\n-            super(Opcodes.ASM4, cw);\n+            super(ASM4, cw);\n             this.targetVersion = targetVersion;\n         }\n \n@@ -49,12 +51,12 @@ public class LambdaClassBackporter {\n     private static class MagicLambdaRemovingMethodVisitor extends MethodVisitor {\n \n         public MagicLambdaRemovingMethodVisitor(MethodVisitor mv) {\n-            super(Opcodes.ASM4, mv);\n+            super(ASM4, mv);\n         }\n \n         @Override\n         public void visitMethodInsn(int opcode, String owner, String name, String desc) {\n-            if (opcode == Opcodes.INVOKESPECIAL\n+            if (opcode == INVOKESPECIAL\n                     && owner.equals(MAGIC_LAMBDA_IMPL)\n                     && name.equals(\"<init>\")\n                     && desc.equals(\"()V\")) {\n"
    },
    {
        "commit_hash": "e750dd75fae8d79d67776e17759eeb2b20655e81",
        "previous_commit_hash": "3d2e37afa736f5674b5098f0452007a1e81c1f1e",
        "diff_stats": {
            "additions": 16,
            "deletions": 33
        },
        "diff_content": "@@ -12,6 +12,8 @@ import java.nio.ByteBuffer;\n import java.util.*;\n import java.util.regex.Pattern;\n \n+import static org.objectweb.asm.Opcodes.*;\n+\n public class LambdaUsageBackporter {\n \n     private static final int JAVA_8_BYTECODE_VERSION = 52;\n@@ -47,7 +49,7 @@ public class LambdaUsageBackporter {\n         private String className;\n \n         public MyClassVisitor(ClassWriter cw, int targetVersion) {\n-            super(Opcodes.ASM4, cw);\n+            super(ASM4, cw);\n             this.targetVersion = targetVersion;\n         }\n \n@@ -109,7 +111,7 @@ public class LambdaUsageBackporter {\n \n             LambdaFactoryMethod factoryMethod = new LambdaFactoryMethod(invokedType, lambdaClass);\n             lambdaFactoryMethods.add(factoryMethod);\n-            super.visitMethodInsn(Opcodes.INVOKESTATIC, myClassName, factoryMethod.getName(), invokedType.getDescriptor());\n+            super.visitMethodInsn(INVOKESTATIC, myClassName, factoryMethod.getName(), invokedType.getDescriptor());\n         }\n \n         private static CallSite callBootstrapMethod(Class<?> invoker, String invokedName, Type invokedType, Handle bsm, Object[] bsmArgs) throws Throwable {\n@@ -153,17 +155,17 @@ public class LambdaUsageBackporter {\n             Class<?> owner = classLoader.loadClass(handle.getOwner().replace('/', '.'));\n \n             switch (handle.getTag()) {\n-                case Opcodes.H_INVOKESTATIC:\n+                case H_INVOKESTATIC:\n                     return lookup.findStatic(owner, handle.getName(), type);\n \n-                case Opcodes.H_INVOKEVIRTUAL:\n-                case Opcodes.H_INVOKEINTERFACE:\n+                case H_INVOKEVIRTUAL:\n+                case H_INVOKEINTERFACE:\n                     return lookup.findVirtual(owner, handle.getName(), type);\n \n-                case Opcodes.H_INVOKESPECIAL:\n+                case H_INVOKESPECIAL:\n                     return lookup.findSpecial(owner, handle.getName(), type, owner);\n \n-                case Opcodes.H_NEWINVOKESPECIAL:\n+                case H_NEWINVOKESPECIAL:\n                     return lookup.findConstructor(owner, type);\n \n                 default:\n@@ -182,19 +184,19 @@ public class LambdaUsageBackporter {\n         }\n \n         public void generateMethod(ClassVisitor cv) {\n-            MethodVisitor mv = cv.visitMethod(Opcodes.ACC_PRIVATE | Opcodes.ACC_STATIC | Opcodes.ACC_SYNTHETIC,\n+            MethodVisitor mv = cv.visitMethod(ACC_PRIVATE | ACC_STATIC | ACC_SYNTHETIC,\n                     getName(), invokedType.getDescriptor(), null, null);\n             mv.visitCode();\n-            mv.visitTypeInsn(Opcodes.NEW, lambdaClass);\n-            mv.visitInsn(Opcodes.DUP);\n+            mv.visitTypeInsn(NEW, lambdaClass);\n+            mv.visitInsn(DUP);\n             int varIndex = 0;\n             for (Type type : invokedType.getArgumentTypes()) {\n-                mv.visitVarInsn(getLoadInsn(type), varIndex);\n+                mv.visitVarInsn(type.getOpcode(ILOAD), varIndex);\n                 varIndex += type.getSize();\n             }\n-            mv.visitMethodInsn(Opcodes.INVOKESPECIAL, lambdaClass, \"<init>\", withVoidReturnType(invokedType));\n-            mv.visitInsn(Opcodes.ARETURN);\n-            mv.visitMaxs(0, 0); // rely on COMPUTE_MAXS\n+            mv.visitMethodInsn(INVOKESPECIAL, lambdaClass, \"<init>\", withVoidReturnType(invokedType));\n+            mv.visitInsn(ARETURN);\n+            mv.visitMaxs(-1, -1); // rely on ClassWriter.COMPUTE_MAXS\n             mv.visitEnd();\n         }\n \n@@ -202,25 +204,6 @@ public class LambdaUsageBackporter {\n             return \"lambdaFactory$\" + lambdaClass.replaceFirst(\".+\\\\$\\\\$Lambda\\\\$\", \"\");\n         }\n \n-        private static int getLoadInsn(Type type) {\n-            switch (type.getSort()) {\n-                case Type.BOOLEAN:\n-                case Type.CHAR:\n-                case Type.BYTE:\n-                case Type.SHORT:\n-                case Type.INT:\n-                    return Opcodes.ILOAD;\n-                case Type.LONG:\n-                    return Opcodes.LLOAD;\n-                case Type.FLOAT:\n-                    return Opcodes.FLOAD;\n-                case Type.DOUBLE:\n-                    return Opcodes.DLOAD;\n-                default:\n-                    return Opcodes.ALOAD;\n-            }\n-        }\n-\n         private static String withVoidReturnType(Type type) {\n             return Type.getMethodType(Type.VOID_TYPE, type.getArgumentTypes()).getDescriptor();\n         }\n"
    },
    {
        "commit_hash": "c4863b9a3bcae4cf587a1353fb05fe60402ec923",
        "previous_commit_hash": "e750dd75fae8d79d67776e17759eeb2b20655e81",
        "diff_stats": {
            "additions": 6,
            "deletions": 1
        },
        "diff_content": "@@ -79,7 +79,12 @@ optimizations to that mechanism may break Retrolambda.\n Version History\n ---------------\n \n-**Retrolambda 1.0.0 (2013-07-23)**\n+### Upcoming Changes\n+\n+- Start the sequence number of lambda classes from one (e.g.\n+  `com.example.Foo$$Lambda$1`) for each enclosing class\n+\n+### Retrolambda 1.0.0 (2013-07-23)\n \n - Backports lambda expressions and method handles to Java 7 and older\n - Tested to work with JDK 8 Early Access Build b99 (2013-07-19)\n"
    },
    {
        "commit_hash": "c4863b9a3bcae4cf587a1353fb05fe60402ec923",
        "previous_commit_hash": "e750dd75fae8d79d67776e17759eeb2b20655e81",
        "diff_stats": {
            "additions": 47,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,47 @@\n+// Copyright \u00a9 2013 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.test;\n+\n+import org.junit.Test;\n+\n+public class LambdaClassesTest {\n+\n+    @Test\n+    public void the_sequence_number_starts_from_1_for_each_enclosing_class() {\n+        assertClassExists(Dummy1.class.getName() + \"$$Lambda$1\");\n+        assertClassExists(Dummy1.class.getName() + \"$$Lambda$2\");\n+        assertClassExists(Dummy2.class.getName() + \"$$Lambda$1\");\n+        assertClassExists(Dummy2.class.getName() + \"$$Lambda$2\");\n+    }\n+\n+    private static void assertClassExists(String className) {\n+        try {\n+            Class.forName(className);\n+        } catch (ClassNotFoundException e) {\n+            throw new AssertionError(\"Expected a class to exists, but it did not: \" + className, e);\n+        }\n+    }\n+\n+\n+    @SuppressWarnings(\"UnusedDeclaration\")\n+    private class Dummy1 {\n+        private Dummy1() {\n+            Runnable lambda1 = () -> {\n+            };\n+            Runnable lambda2 = () -> {\n+            };\n+        }\n+    }\n+\n+    @SuppressWarnings(\"UnusedDeclaration\")\n+    private class Dummy2 {\n+        private Dummy2() {\n+            Runnable lambda1 = () -> {\n+            };\n+            Runnable lambda2 = () -> {\n+            };\n+        }\n+    }\n+}\n"
    },
    {
        "commit_hash": "c4863b9a3bcae4cf587a1353fb05fe60402ec923",
        "previous_commit_hash": "e750dd75fae8d79d67776e17759eeb2b20655e81",
        "diff_stats": {
            "additions": 18,
            "deletions": 1
        },
        "diff_content": "@@ -5,11 +5,13 @@\n package net.orfjackal.retrolambda;\n \n import org.objectweb.asm.*;\n+import org.objectweb.asm.Type;\n \n import java.lang.invoke.*;\n-import java.lang.reflect.Constructor;\n+import java.lang.reflect.*;\n import java.nio.ByteBuffer;\n import java.util.*;\n+import java.util.concurrent.atomic.AtomicInteger;\n import java.util.regex.Pattern;\n \n import static org.objectweb.asm.Opcodes.*;\n@@ -24,6 +26,7 @@ public class LambdaUsageBackporter {\n \n     public static byte[] transform(byte[] bytecode, int targetVersion) {\n         asmJava8SupportWorkaround(bytecode);\n+        resetLambdaClassSequenceNumber();\n         ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n         new ClassReader(bytecode).accept(new MyClassVisitor(cw, targetVersion), 0);\n         return cw.toByteArray();\n@@ -43,6 +46,20 @@ public class LambdaUsageBackporter {\n         }\n     }\n \n+    private static void resetLambdaClassSequenceNumber() {\n+        try {\n+            Field counterField = Class.forName(\"java.lang.invoke.InnerClassLambdaMetafactory\").getDeclaredField(\"counter\");\n+            counterField.setAccessible(true);\n+            AtomicInteger counter = (AtomicInteger) counterField.get(null);\n+            counter.set(0);\n+        } catch (Exception e) {\n+            System.err.println(\"WARNING: Failed to start class numbering from one. Don't worry, it's cosmetic, \" +\n+                    \"but please file a bug report and tell on which JDK version this happened.\");\n+            e.printStackTrace();\n+        }\n+    }\n+\n+\n     private static class MyClassVisitor extends ClassVisitor {\n         private final List<LambdaFactoryMethod> lambdaFactoryMethods = new ArrayList<>();\n         private final int targetVersion;\n"
    },
    {
        "commit_hash": "03d7d963f361417a421be2dfb027a03ab277b44e",
        "previous_commit_hash": "c4863b9a3bcae4cf587a1353fb05fe60402ec923",
        "diff_stats": {
            "additions": 2,
            "deletions": 0
        },
        "diff_content": "@@ -81,6 +81,8 @@ Version History\n \n ### Upcoming Changes\n \n+- Create only one instance of lambdas which do not capture arguments; i.e.\n+  the same optimization as what JDK 8 does\n - Start the sequence number of lambda classes from one (e.g.\n   `com.example.Foo$$Lambda$1`) for each enclosing class\n \n"
    },
    {
        "commit_hash": "03d7d963f361417a421be2dfb027a03ab277b44e",
        "previous_commit_hash": "c4863b9a3bcae4cf587a1353fb05fe60402ec923",
        "diff_stats": {
            "additions": 40,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,40 @@\n+// Copyright \u00a9 2013 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.test;\n+\n+import org.junit.Test;\n+\n+import java.util.concurrent.Callable;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.*;\n+\n+public class OptimizationsTest {\n+\n+    @Test\n+    public void lambdas_which_capture_variables_get_a_new_instance_every_time() {\n+        Callable<Integer> lambda1 = createStatefulLambda();\n+        Callable<Integer> lambda2 = createStatefulLambda();\n+\n+        assertThat(lambda1, is(not(sameInstance(lambda2))));\n+    }\n+\n+    private static Callable<Integer> createStatefulLambda() {\n+        int i = 42;\n+        return () -> i;\n+    }\n+\n+    @Test\n+    public void lambdas_which_do_not_capture_variables_have_only_one_singleton_instance() {\n+        Callable<Integer> lambda1 = createStatelessLambda();\n+        Callable<Integer> lambda2 = createStatelessLambda();\n+\n+        assertThat(lambda1, is(sameInstance(lambda2)));\n+    }\n+\n+    private static Callable<Integer> createStatelessLambda() {\n+        return () -> 42;\n+    }\n+}\n"
    },
    {
        "commit_hash": "03d7d963f361417a421be2dfb027a03ab277b44e",
        "previous_commit_hash": "c4863b9a3bcae4cf587a1353fb05fe60402ec923",
        "diff_stats": {
            "additions": 32,
            "deletions": 0
        },
        "diff_content": "@@ -21,6 +21,8 @@ public class LambdaClassBackporter {\n \n     private static class MyClassVisitor extends ClassVisitor {\n         private final int targetVersion;\n+        private String className;\n+        private boolean stateless = false;\n \n         public MyClassVisitor(ClassWriter cw, int targetVersion) {\n             super(ASM4, cw);\n@@ -29,6 +31,7 @@ public class LambdaClassBackporter {\n \n         @Override\n         public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n+            className = name;\n             if (version > targetVersion) {\n                 version = targetVersion;\n             }\n@@ -43,9 +46,38 @@ public class LambdaClassBackporter {\n             if (name.equals(\"<init>\")) {\n                 access = Flags.makeNonPrivate(access);\n             }\n+            if (name.equals(\"<init>\") && desc.equals(\"()V\")) {\n+                stateless = true;\n+            }\n             MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n             return new MagicLambdaRemovingMethodVisitor(mv);\n         }\n+\n+        @Override\n+        public void visitEnd() {\n+            if (stateless) {\n+                makeSingleton();\n+            }\n+            super.visitEnd();\n+        }\n+\n+        private void makeSingleton() {\n+            String fieldName = \"instance\";\n+            String fieldDesc = \"L\" + className + \";\";\n+\n+            FieldVisitor fv = super.visitField(ACC_PUBLIC | ACC_FINAL | ACC_STATIC, fieldName, fieldDesc, null, null);\n+            fv.visitEnd();\n+\n+            MethodVisitor mv = super.visitMethod(ACC_STATIC, \"<clinit>\", \"()V\", null, null);\n+            mv.visitCode();\n+            mv.visitTypeInsn(NEW, className);\n+            mv.visitInsn(DUP);\n+            mv.visitMethodInsn(INVOKESPECIAL, className, \"<init>\", \"()V\");\n+            mv.visitFieldInsn(PUTSTATIC, className, fieldName, fieldDesc);\n+            mv.visitInsn(RETURN);\n+            mv.visitMaxs(2, 0);\n+            mv.visitEnd();\n+        }\n     }\n \n     private static class MagicLambdaRemovingMethodVisitor extends MethodVisitor {\n"
    },
    {
        "commit_hash": "03d7d963f361417a421be2dfb027a03ab277b44e",
        "previous_commit_hash": "c4863b9a3bcae4cf587a1353fb05fe60402ec923",
        "diff_stats": {
            "additions": 18,
            "deletions": 10
        },
        "diff_content": "@@ -91,7 +91,7 @@ public class LambdaUsageBackporter {\n         @Override\n         public void visitEnd() {\n             for (LambdaFactoryMethod factoryMethod : lambdaFactoryMethods) {\n-                factoryMethod.generateMethod(cv);\n+                factoryMethod.generate(cv);\n             }\n             super.visitEnd();\n         }\n@@ -200,19 +200,27 @@ public class LambdaUsageBackporter {\n             this.lambdaClass = lambdaClass;\n         }\n \n-        public void generateMethod(ClassVisitor cv) {\n+        public void generate(ClassVisitor cv) {\n             MethodVisitor mv = cv.visitMethod(ACC_PRIVATE | ACC_STATIC | ACC_SYNTHETIC,\n                     getName(), invokedType.getDescriptor(), null, null);\n             mv.visitCode();\n-            mv.visitTypeInsn(NEW, lambdaClass);\n-            mv.visitInsn(DUP);\n-            int varIndex = 0;\n-            for (Type type : invokedType.getArgumentTypes()) {\n-                mv.visitVarInsn(type.getOpcode(ILOAD), varIndex);\n-                varIndex += type.getSize();\n+\n+            if (invokedType.getArgumentTypes().length == 0) {\n+                // TODO: knowledge about this field is split between here and LambdaClassBackporter; move this factory method there\n+                mv.visitFieldInsn(GETSTATIC, lambdaClass, \"instance\", \"L\" + lambdaClass + \";\");\n+                mv.visitInsn(ARETURN);\n+            } else {\n+                mv.visitTypeInsn(NEW, lambdaClass);\n+                mv.visitInsn(DUP);\n+                int varIndex = 0;\n+                for (Type type : invokedType.getArgumentTypes()) {\n+                    mv.visitVarInsn(type.getOpcode(ILOAD), varIndex);\n+                    varIndex += type.getSize();\n+                }\n+                mv.visitMethodInsn(INVOKESPECIAL, lambdaClass, \"<init>\", withVoidReturnType(invokedType));\n+                mv.visitInsn(ARETURN);\n             }\n-            mv.visitMethodInsn(INVOKESPECIAL, lambdaClass, \"<init>\", withVoidReturnType(invokedType));\n-            mv.visitInsn(ARETURN);\n+\n             mv.visitMaxs(-1, -1); // rely on ClassWriter.COMPUTE_MAXS\n             mv.visitEnd();\n         }\n"
    },
    {
        "commit_hash": "e74a7847b1574e94c57008496d2fc70b90d1d9ed",
        "previous_commit_hash": "03d7d963f361417a421be2dfb027a03ab277b44e",
        "diff_stats": {
            "additions": 60,
            "deletions": 20
        },
        "diff_content": "@@ -10,28 +10,35 @@ import static org.objectweb.asm.Opcodes.*;\n \n public class LambdaClassBackporter {\n \n+    public static final String FACTORY_METHOD_NAME = \"$create\";\n+    private static final String SINGLETON_FIELD_NAME = \"instance\";\n+\n     private static final String MAGIC_LAMBDA_IMPL = \"java/lang/invoke/MagicLambdaImpl\";\n     private static final String JAVA_LANG_OBJECT = \"java/lang/Object\";\n \n     public static byte[] transform(byte[] bytecode, int targetVersion) {\n-        ClassWriter writer = new ClassWriter(0);\n-        new ClassReader(bytecode).accept(new MyClassVisitor(writer, targetVersion), 0);\n+        ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n+        new ClassReader(bytecode).accept(new LambdaClassVisitor(writer, targetVersion), 0);\n         return writer.toByteArray();\n     }\n \n-    private static class MyClassVisitor extends ClassVisitor {\n+    public static String toFactoryMethodDesc(String lambdaClass, Type invocationOrConstructor) {\n+        return Type.getMethodDescriptor(Type.getType(\"L\" + lambdaClass + \";\"), invocationOrConstructor.getArgumentTypes());\n+    }\n+\n+    private static class LambdaClassVisitor extends ClassVisitor {\n         private final int targetVersion;\n-        private String className;\n-        private boolean stateless = false;\n+        private String lambdaClass;\n+        private Type constructor;\n \n-        public MyClassVisitor(ClassWriter cw, int targetVersion) {\n+        public LambdaClassVisitor(ClassWriter cw, int targetVersion) {\n             super(ASM4, cw);\n             this.targetVersion = targetVersion;\n         }\n \n         @Override\n         public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n-            className = name;\n+            lambdaClass = name;\n             if (version > targetVersion) {\n                 version = targetVersion;\n             }\n@@ -44,10 +51,7 @@ public class LambdaClassBackporter {\n         @Override\n         public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n             if (name.equals(\"<init>\")) {\n-                access = Flags.makeNonPrivate(access);\n-            }\n-            if (name.equals(\"<init>\") && desc.equals(\"()V\")) {\n-                stateless = true;\n+                constructor = Type.getMethodType(desc);\n             }\n             MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n             return new MagicLambdaRemovingMethodVisitor(mv);\n@@ -55,29 +59,65 @@ public class LambdaClassBackporter {\n \n         @Override\n         public void visitEnd() {\n-            if (stateless) {\n+            if (isStateless()) {\n                 makeSingleton();\n             }\n+            generateFactoryMethod();\n             super.visitEnd();\n         }\n \n         private void makeSingleton() {\n-            String fieldName = \"instance\";\n-            String fieldDesc = \"L\" + className + \";\";\n-\n-            FieldVisitor fv = super.visitField(ACC_PUBLIC | ACC_FINAL | ACC_STATIC, fieldName, fieldDesc, null, null);\n+            FieldVisitor fv = super.visitField(ACC_PRIVATE | ACC_STATIC | ACC_FINAL,\n+                    SINGLETON_FIELD_NAME, singletonFieldDesc(), null, null);\n             fv.visitEnd();\n \n             MethodVisitor mv = super.visitMethod(ACC_STATIC, \"<clinit>\", \"()V\", null, null);\n             mv.visitCode();\n-            mv.visitTypeInsn(NEW, className);\n+            mv.visitTypeInsn(NEW, lambdaClass);\n             mv.visitInsn(DUP);\n-            mv.visitMethodInsn(INVOKESPECIAL, className, \"<init>\", \"()V\");\n-            mv.visitFieldInsn(PUTSTATIC, className, fieldName, fieldDesc);\n+            mv.visitMethodInsn(INVOKESPECIAL, lambdaClass, \"<init>\", \"()V\");\n+            mv.visitFieldInsn(PUTSTATIC, lambdaClass, SINGLETON_FIELD_NAME, singletonFieldDesc());\n             mv.visitInsn(RETURN);\n-            mv.visitMaxs(2, 0);\n+            mv.visitMaxs(-1, -1); // rely on ClassWriter.COMPUTE_MAXS\n+            mv.visitEnd();\n+        }\n+\n+        private void generateFactoryMethod() {\n+            MethodVisitor mv = cv.visitMethod(ACC_PUBLIC | ACC_STATIC,\n+                    FACTORY_METHOD_NAME, factoryMethodDesc(), null, null);\n+            mv.visitCode();\n+\n+            if (isStateless()) {\n+                mv.visitFieldInsn(GETSTATIC, lambdaClass, SINGLETON_FIELD_NAME, singletonFieldDesc());\n+                mv.visitInsn(ARETURN);\n+\n+            } else {\n+                mv.visitTypeInsn(NEW, lambdaClass);\n+                mv.visitInsn(DUP);\n+                int varIndex = 0;\n+                for (Type type : constructor.getArgumentTypes()) {\n+                    mv.visitVarInsn(type.getOpcode(ILOAD), varIndex);\n+                    varIndex += type.getSize();\n+                }\n+                mv.visitMethodInsn(INVOKESPECIAL, lambdaClass, \"<init>\", constructor.getDescriptor());\n+                mv.visitInsn(ARETURN);\n+            }\n+\n+            mv.visitMaxs(-1, -1); // rely on ClassWriter.COMPUTE_MAXS\n             mv.visitEnd();\n         }\n+\n+        private String factoryMethodDesc() {\n+            return toFactoryMethodDesc(lambdaClass, constructor);\n+        }\n+\n+        private String singletonFieldDesc() {\n+            return \"L\" + lambdaClass + \";\";\n+        }\n+\n+        private boolean isStateless() {\n+            return constructor.getArgumentTypes().length == 0;\n+        }\n     }\n \n     private static class MagicLambdaRemovingMethodVisitor extends MethodVisitor {\n"
    },
    {
        "commit_hash": "e74a7847b1574e94c57008496d2fc70b90d1d9ed",
        "previous_commit_hash": "03d7d963f361417a421be2dfb027a03ab277b44e",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -47,7 +47,7 @@ public class LambdaSavingClassFileTransformer implements ClassFileTransformer {\n         try {\n             System.out.println(\"Saving lambda class: \" + className);\n             foundLambdaClasses.push(className);\n-            byte[] transformedBytes = LambdaClassBackporter.transform(classfileBuffer,targetVersion);\n+            byte[] transformedBytes = LambdaClassBackporter.transform(classfileBuffer, targetVersion);\n             Path savePath = outputDir.resolve(className + \".class\");\n             Files.createDirectories(savePath.getParent());\n             Files.write(savePath, transformedBytes);\n"
    },
    {
        "commit_hash": "e74a7847b1574e94c57008496d2fc70b90d1d9ed",
        "previous_commit_hash": "03d7d963f361417a421be2dfb027a03ab277b44e",
        "diff_stats": {
            "additions": 7,
            "deletions": 61
        },
        "diff_content": "@@ -61,7 +61,6 @@ public class LambdaUsageBackporter {\n \n \n     private static class MyClassVisitor extends ClassVisitor {\n-        private final List<LambdaFactoryMethod> lambdaFactoryMethods = new ArrayList<>();\n         private final int targetVersion;\n         private String className;\n \n@@ -85,26 +84,16 @@ public class LambdaUsageBackporter {\n                 access = Flags.makeNonPrivate(access);\n             }\n             MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n-            return new InvokeDynamicInsnConvertingMethodVisitor(api, mv, className, lambdaFactoryMethods);\n-        }\n-\n-        @Override\n-        public void visitEnd() {\n-            for (LambdaFactoryMethod factoryMethod : lambdaFactoryMethods) {\n-                factoryMethod.generate(cv);\n-            }\n-            super.visitEnd();\n+            return new InvokeDynamicInsnConvertingMethodVisitor(api, mv, className);\n         }\n     }\n \n     private static class InvokeDynamicInsnConvertingMethodVisitor extends MethodVisitor {\n         private final String myClassName;\n-        private final List<LambdaFactoryMethod> lambdaFactoryMethods;\n \n-        public InvokeDynamicInsnConvertingMethodVisitor(int api, MethodVisitor mv, String myClassName, List<LambdaFactoryMethod> lambdaFactoryMethods) {\n+        public InvokeDynamicInsnConvertingMethodVisitor(int api, MethodVisitor mv, String myClassName) {\n             super(api, mv);\n             this.myClassName = myClassName;\n-            this.lambdaFactoryMethods = lambdaFactoryMethods;\n         }\n \n         @Override\n@@ -126,9 +115,9 @@ public class LambdaUsageBackporter {\n             callBootstrapMethod(invoker, invokedName, invokedType, bsm, bsmArgs);\n             String lambdaClass = LambdaSavingClassFileTransformer.getLastFoundLambdaClass();\n \n-            LambdaFactoryMethod factoryMethod = new LambdaFactoryMethod(invokedType, lambdaClass);\n-            lambdaFactoryMethods.add(factoryMethod);\n-            super.visitMethodInsn(INVOKESTATIC, myClassName, factoryMethod.getName(), invokedType.getDescriptor());\n+            // TODO: get rid of toFactoryMethodDesc by changing the method's return type to be same as invokedType\n+            String factoryDesc = LambdaClassBackporter.toFactoryMethodDesc(lambdaClass, invokedType);\n+            super.visitMethodInsn(INVOKESTATIC, lambdaClass, LambdaClassBackporter.FACTORY_METHOD_NAME, factoryDesc);\n         }\n \n         private static CallSite callBootstrapMethod(Class<?> invoker, String invokedName, Type invokedType, Handle bsm, Object[] bsmArgs) throws Throwable {\n@@ -140,7 +129,7 @@ public class LambdaUsageBackporter {\n             args.add(invokedName);\n             args.add(toMethodType(invokedType, cl));\n             for (Object arg : bsmArgs) {\n-                args.add(asmToInvokerType(arg, cl, caller));\n+                args.add(asmToJdkType(arg, cl, caller));\n             }\n \n             MethodHandle bootstrapMethod = toMethodHandle(bsm, cl, caller);\n@@ -153,7 +142,7 @@ public class LambdaUsageBackporter {\n             return ctor.newInstance(targetClass);\n         }\n \n-        private static Object asmToInvokerType(Object arg, ClassLoader classLoader, MethodHandles.Lookup caller) throws Exception {\n+        private static Object asmToJdkType(Object arg, ClassLoader classLoader, MethodHandles.Lookup caller) throws Exception {\n             if (arg instanceof Type) {\n                 return toMethodType((Type) arg, classLoader);\n             } else if (arg instanceof Handle) {\n@@ -190,47 +179,4 @@ public class LambdaUsageBackporter {\n             }\n         }\n     }\n-\n-    private static class LambdaFactoryMethod {\n-        private final Type invokedType;\n-        private final String lambdaClass;\n-\n-        public LambdaFactoryMethod(Type invokedType, String lambdaClass) {\n-            this.invokedType = invokedType;\n-            this.lambdaClass = lambdaClass;\n-        }\n-\n-        public void generate(ClassVisitor cv) {\n-            MethodVisitor mv = cv.visitMethod(ACC_PRIVATE | ACC_STATIC | ACC_SYNTHETIC,\n-                    getName(), invokedType.getDescriptor(), null, null);\n-            mv.visitCode();\n-\n-            if (invokedType.getArgumentTypes().length == 0) {\n-                // TODO: knowledge about this field is split between here and LambdaClassBackporter; move this factory method there\n-                mv.visitFieldInsn(GETSTATIC, lambdaClass, \"instance\", \"L\" + lambdaClass + \";\");\n-                mv.visitInsn(ARETURN);\n-            } else {\n-                mv.visitTypeInsn(NEW, lambdaClass);\n-                mv.visitInsn(DUP);\n-                int varIndex = 0;\n-                for (Type type : invokedType.getArgumentTypes()) {\n-                    mv.visitVarInsn(type.getOpcode(ILOAD), varIndex);\n-                    varIndex += type.getSize();\n-                }\n-                mv.visitMethodInsn(INVOKESPECIAL, lambdaClass, \"<init>\", withVoidReturnType(invokedType));\n-                mv.visitInsn(ARETURN);\n-            }\n-\n-            mv.visitMaxs(-1, -1); // rely on ClassWriter.COMPUTE_MAXS\n-            mv.visitEnd();\n-        }\n-\n-        public String getName() {\n-            return \"lambdaFactory$\" + lambdaClass.replaceFirst(\".+\\\\$\\\\$Lambda\\\\$\", \"\");\n-        }\n-\n-        private static String withVoidReturnType(Type type) {\n-            return Type.getMethodType(Type.VOID_TYPE, type.getArgumentTypes()).getDescriptor();\n-        }\n-    }\n }\n"
    },
    {
        "commit_hash": "e74a7847b1574e94c57008496d2fc70b90d1d9ed",
        "previous_commit_hash": "03d7d963f361417a421be2dfb027a03ab277b44e",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -13,6 +13,6 @@ public class PreMain {\n         Config config = new Config(System.getProperties());\n         int bytecodeVersion = config.getBytecodeVersion();\n         Path outputDir = config.getOutputDir();\n-        inst.addTransformer(new LambdaSavingClassFileTransformer(outputDir,bytecodeVersion));\n+        inst.addTransformer(new LambdaSavingClassFileTransformer(outputDir, bytecodeVersion));\n     }\n }\n"
    },
    {
        "commit_hash": "969cbfaa477a8993cb14c0259a7eeae3c1c4462f",
        "previous_commit_hash": "e74a7847b1574e94c57008496d2fc70b90d1d9ed",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -10,7 +10,7 @@ import static org.objectweb.asm.Opcodes.*;\n \n public class LambdaClassBackporter {\n \n-    public static final String FACTORY_METHOD_NAME = \"$create\";\n+    public static final String FACTORY_METHOD_NAME = \"lambdaFactory$\";\n     private static final String SINGLETON_FIELD_NAME = \"instance\";\n \n     private static final String MAGIC_LAMBDA_IMPL = \"java/lang/invoke/MagicLambdaImpl\";\n"
    },
    {
        "commit_hash": "77fff0330d3e047614c89524298e147644f82fff",
        "previous_commit_hash": "969cbfaa477a8993cb14c0259a7eeae3c1c4462f",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -8,6 +8,7 @@\n       <w>insn</w>\n       <w>metafactory</w>\n       <w>premain</w>\n+      <w>reifier</w>\n       <w>retrolambda</w>\n     </words>\n   </dictionary>\n"
    },
    {
        "commit_hash": "77fff0330d3e047614c89524298e147644f82fff",
        "previous_commit_hash": "969cbfaa477a8993cb14c0259a7eeae3c1c4462f",
        "diff_stats": {
            "additions": 31,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,31 @@\n+// Copyright \u00a9 2013 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda;\n+\n+import org.objectweb.asm.Type;\n+\n+public class LambdaFactoryMethod {\n+\n+    private final String owner;\n+    private final String desc;\n+\n+    public LambdaFactoryMethod(String lambdaClass, Type invokedType) {\n+        owner = lambdaClass;\n+        // TODO: get rid of toFactoryMethodDesc by changing the method's return type to be same as invokedType\n+        desc = LambdaClassBackporter.toFactoryMethodDesc(lambdaClass, invokedType);\n+    }\n+\n+    public String getOwner() {\n+        return owner;\n+    }\n+\n+    public String getName() {\n+        return LambdaClassBackporter.FACTORY_METHOD_NAME;\n+    }\n+\n+    public String getDesc() {\n+        return desc;\n+    }\n+}\n"
    },
    {
        "commit_hash": "77fff0330d3e047614c89524298e147644f82fff",
        "previous_commit_hash": "969cbfaa477a8993cb14c0259a7eeae3c1c4462f",
        "diff_stats": {
            "additions": 85,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,85 @@\n+// Copyright \u00a9 2013 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda;\n+\n+import org.objectweb.asm.*;\n+\n+import java.lang.invoke.*;\n+import java.lang.reflect.Constructor;\n+import java.util.*;\n+\n+import static org.objectweb.asm.Opcodes.*;\n+\n+public class LambdaReifier {\n+\n+    public static LambdaFactoryMethod reifyLambdaClass(Class<?> invoker, String invokedName, Type invokedType, Handle bsm, Object[] bsmArgs) {\n+        try {\n+            callBootstrapMethod(invoker, invokedName, invokedType, bsm, bsmArgs);\n+        } catch (Throwable t) {\n+            throw new RuntimeException(t);\n+        }\n+        String lambdaClass = LambdaSavingClassFileTransformer.getLastFoundLambdaClass();\n+        return new LambdaFactoryMethod(lambdaClass, invokedType);\n+    }\n+\n+    private static CallSite callBootstrapMethod(Class<?> invoker, String invokedName, Type invokedType, Handle bsm, Object[] bsmArgs) throws Throwable {\n+        ClassLoader cl = invoker.getClassLoader();\n+        MethodHandles.Lookup caller = getLookup(invoker);\n+\n+        List<Object> args = new ArrayList<>();\n+        args.add(caller);\n+        args.add(invokedName);\n+        args.add(toMethodType(invokedType, cl));\n+        for (Object arg : bsmArgs) {\n+            args.add(asmToJdkType(arg, cl, caller));\n+        }\n+\n+        MethodHandle bootstrapMethod = toMethodHandle(bsm, cl, caller);\n+        return (CallSite) bootstrapMethod.invokeWithArguments(args);\n+    }\n+\n+    private static MethodHandles.Lookup getLookup(Class<?> targetClass) throws Exception {\n+        Constructor<MethodHandles.Lookup> ctor = MethodHandles.Lookup.class.getDeclaredConstructor(Class.class);\n+        ctor.setAccessible(true);\n+        return ctor.newInstance(targetClass);\n+    }\n+\n+    private static Object asmToJdkType(Object arg, ClassLoader classLoader, MethodHandles.Lookup caller) throws Exception {\n+        if (arg instanceof Type) {\n+            return toMethodType((Type) arg, classLoader);\n+        } else if (arg instanceof Handle) {\n+            return toMethodHandle((Handle) arg, classLoader, caller);\n+        } else {\n+            return arg;\n+        }\n+    }\n+\n+    private static MethodType toMethodType(Type type, ClassLoader classLoader) {\n+        return MethodType.fromMethodDescriptorString(type.getInternalName(), classLoader);\n+    }\n+\n+    private static MethodHandle toMethodHandle(Handle handle, ClassLoader classLoader, MethodHandles.Lookup lookup) throws Exception {\n+        MethodType type = MethodType.fromMethodDescriptorString(handle.getDesc(), classLoader);\n+        Class<?> owner = classLoader.loadClass(handle.getOwner().replace('/', '.'));\n+\n+        switch (handle.getTag()) {\n+            case H_INVOKESTATIC:\n+                return lookup.findStatic(owner, handle.getName(), type);\n+\n+            case H_INVOKEVIRTUAL:\n+            case H_INVOKEINTERFACE:\n+                return lookup.findVirtual(owner, handle.getName(), type);\n+\n+            case H_INVOKESPECIAL:\n+                return lookup.findSpecial(owner, handle.getName(), type, owner);\n+\n+            case H_NEWINVOKESPECIAL:\n+                return lookup.findConstructor(owner, type);\n+\n+            default:\n+                throw new AssertionError(\"Unexpected handle type: \" + handle);\n+        }\n+    }\n+}\n"
    },
    {
        "commit_hash": "77fff0330d3e047614c89524298e147644f82fff",
        "previous_commit_hash": "969cbfaa477a8993cb14c0259a7eeae3c1c4462f",
        "diff_stats": {
            "additions": 12,
            "deletions": 73
        },
        "diff_content": "@@ -5,12 +5,9 @@\n package net.orfjackal.retrolambda;\n \n import org.objectweb.asm.*;\n-import org.objectweb.asm.Type;\n \n-import java.lang.invoke.*;\n-import java.lang.reflect.*;\n+import java.lang.reflect.Field;\n import java.nio.ByteBuffer;\n-import java.util.*;\n import java.util.concurrent.atomic.AtomicInteger;\n import java.util.regex.Pattern;\n \n@@ -99,83 +96,25 @@ public class LambdaUsageBackporter {\n         @Override\n         public void visitInvokeDynamicInsn(String name, String desc, Handle bsm, Object... bsmArgs) {\n             if (bsm.getOwner().equals(LAMBDA_METAFACTORY)) {\n-                try {\n-                    backportLambda(name, Type.getType(desc), bsm, bsmArgs);\n-                } catch (Throwable t) {\n-                    throw new RuntimeException(t);\n-                }\n+                backportLambda(name, Type.getType(desc), bsm, bsmArgs);\n             } else {\n                 super.visitInvokeDynamicInsn(name, desc, bsm, bsmArgs);\n             }\n         }\n \n-        private void backportLambda(String invokedName, Type invokedType, Handle bsm, Object[] bsmArgs) throws Throwable {\n-            ClassLoader cl = Thread.currentThread().getContextClassLoader();\n-            Class<?> invoker = cl.loadClass(myClassName.replace('/', '.'));\n-            callBootstrapMethod(invoker, invokedName, invokedType, bsm, bsmArgs);\n-            String lambdaClass = LambdaSavingClassFileTransformer.getLastFoundLambdaClass();\n+        private void backportLambda(String invokedName, Type invokedType, Handle bsm, Object[] bsmArgs) {\n+            Class<?> invoker = loadClass(myClassName);\n+            LambdaFactoryMethod factory = LambdaReifier.reifyLambdaClass(invoker, invokedName, invokedType, bsm, bsmArgs);\n+            super.visitMethodInsn(INVOKESTATIC, factory.getOwner(), factory.getName(), factory.getDesc());\n \n-            // TODO: get rid of toFactoryMethodDesc by changing the method's return type to be same as invokedType\n-            String factoryDesc = LambdaClassBackporter.toFactoryMethodDesc(lambdaClass, invokedType);\n-            super.visitMethodInsn(INVOKESTATIC, lambdaClass, LambdaClassBackporter.FACTORY_METHOD_NAME, factoryDesc);\n         }\n \n-        private static CallSite callBootstrapMethod(Class<?> invoker, String invokedName, Type invokedType, Handle bsm, Object[] bsmArgs) throws Throwable {\n-            ClassLoader cl = invoker.getClassLoader();\n-            MethodHandles.Lookup caller = getLookup(invoker);\n-\n-            List<Object> args = new ArrayList<>();\n-            args.add(caller);\n-            args.add(invokedName);\n-            args.add(toMethodType(invokedType, cl));\n-            for (Object arg : bsmArgs) {\n-                args.add(asmToJdkType(arg, cl, caller));\n-            }\n-\n-            MethodHandle bootstrapMethod = toMethodHandle(bsm, cl, caller);\n-            return (CallSite) bootstrapMethod.invokeWithArguments(args);\n-        }\n-\n-        private static MethodHandles.Lookup getLookup(Class<?> targetClass) throws Exception {\n-            Constructor<MethodHandles.Lookup> ctor = MethodHandles.Lookup.class.getDeclaredConstructor(Class.class);\n-            ctor.setAccessible(true);\n-            return ctor.newInstance(targetClass);\n-        }\n-\n-        private static Object asmToJdkType(Object arg, ClassLoader classLoader, MethodHandles.Lookup caller) throws Exception {\n-            if (arg instanceof Type) {\n-                return toMethodType((Type) arg, classLoader);\n-            } else if (arg instanceof Handle) {\n-                return toMethodHandle((Handle) arg, classLoader, caller);\n-            } else {\n-                return arg;\n-            }\n-        }\n-\n-        private static MethodType toMethodType(Type type, ClassLoader classLoader) {\n-            return MethodType.fromMethodDescriptorString(type.getInternalName(), classLoader);\n-        }\n-\n-        private static MethodHandle toMethodHandle(Handle handle, ClassLoader classLoader, MethodHandles.Lookup lookup) throws Exception {\n-            MethodType type = MethodType.fromMethodDescriptorString(handle.getDesc(), classLoader);\n-            Class<?> owner = classLoader.loadClass(handle.getOwner().replace('/', '.'));\n-\n-            switch (handle.getTag()) {\n-                case H_INVOKESTATIC:\n-                    return lookup.findStatic(owner, handle.getName(), type);\n-\n-                case H_INVOKEVIRTUAL:\n-                case H_INVOKEINTERFACE:\n-                    return lookup.findVirtual(owner, handle.getName(), type);\n-\n-                case H_INVOKESPECIAL:\n-                    return lookup.findSpecial(owner, handle.getName(), type, owner);\n-\n-                case H_NEWINVOKESPECIAL:\n-                    return lookup.findConstructor(owner, type);\n-\n-                default:\n-                    throw new AssertionError(\"Unexpected handle type: \" + handle);\n+        private static Class<?> loadClass(String className) {\n+            try {\n+                ClassLoader cl = Thread.currentThread().getContextClassLoader();\n+                return cl.loadClass(className.replace('/', '.'));\n+            } catch (ClassNotFoundException e) {\n+                throw new RuntimeException(e);\n             }\n         }\n     }\n"
    },
    {
        "commit_hash": "c316f597d684ca3d183664a38e458386ed67204c",
        "previous_commit_hash": "77fff0330d3e047614c89524298e147644f82fff",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -2,6 +2,7 @@\n   <dictionary name=\"ORFJackal\">\n     <words>\n       <w>backport</w>\n+      <w>backported</w>\n       <w>backporter</w>\n       <w>backporting</w>\n       <w>bytecode</w>\n"
    },
    {
        "commit_hash": "c316f597d684ca3d183664a38e458386ed67204c",
        "previous_commit_hash": "77fff0330d3e047614c89524298e147644f82fff",
        "diff_stats": {
            "additions": 5,
            "deletions": 10
        },
        "diff_content": "@@ -10,7 +10,6 @@ import static org.objectweb.asm.Opcodes.*;\n \n public class LambdaClassBackporter {\n \n-    public static final String FACTORY_METHOD_NAME = \"lambdaFactory$\";\n     private static final String SINGLETON_FIELD_NAME = \"instance\";\n \n     private static final String MAGIC_LAMBDA_IMPL = \"java/lang/invoke/MagicLambdaImpl\";\n@@ -22,14 +21,11 @@ public class LambdaClassBackporter {\n         return writer.toByteArray();\n     }\n \n-    public static String toFactoryMethodDesc(String lambdaClass, Type invocationOrConstructor) {\n-        return Type.getMethodDescriptor(Type.getType(\"L\" + lambdaClass + \";\"), invocationOrConstructor.getArgumentTypes());\n-    }\n-\n     private static class LambdaClassVisitor extends ClassVisitor {\n         private final int targetVersion;\n         private String lambdaClass;\n         private Type constructor;\n+        private LambdaFactoryMethod factoryMethod;\n \n         public LambdaClassVisitor(ClassWriter cw, int targetVersion) {\n             super(ASM4, cw);\n@@ -39,6 +35,9 @@ public class LambdaClassBackporter {\n         @Override\n         public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n             lambdaClass = name;\n+            LambdaReifier.setLambdaClass(lambdaClass);\n+            factoryMethod = LambdaReifier.getLambdaFactoryMethod();\n+\n             if (version > targetVersion) {\n                 version = targetVersion;\n             }\n@@ -84,7 +83,7 @@ public class LambdaClassBackporter {\n \n         private void generateFactoryMethod() {\n             MethodVisitor mv = cv.visitMethod(ACC_PUBLIC | ACC_STATIC,\n-                    FACTORY_METHOD_NAME, factoryMethodDesc(), null, null);\n+                    factoryMethod.getName(), factoryMethod.getDesc(), null, null);\n             mv.visitCode();\n \n             if (isStateless()) {\n@@ -107,10 +106,6 @@ public class LambdaClassBackporter {\n             mv.visitEnd();\n         }\n \n-        private String factoryMethodDesc() {\n-            return toFactoryMethodDesc(lambdaClass, constructor);\n-        }\n-\n         private String singletonFieldDesc() {\n             return \"L\" + lambdaClass + \";\";\n         }\n"
    },
    {
        "commit_hash": "c316f597d684ca3d183664a38e458386ed67204c",
        "previous_commit_hash": "77fff0330d3e047614c89524298e147644f82fff",
        "diff_stats": {
            "additions": 2,
            "deletions": 3
        },
        "diff_content": "@@ -13,8 +13,7 @@ public class LambdaFactoryMethod {\n \n     public LambdaFactoryMethod(String lambdaClass, Type invokedType) {\n         owner = lambdaClass;\n-        // TODO: get rid of toFactoryMethodDesc by changing the method's return type to be same as invokedType\n-        desc = LambdaClassBackporter.toFactoryMethodDesc(lambdaClass, invokedType);\n+        desc = invokedType.getDescriptor();\n     }\n \n     public String getOwner() {\n@@ -22,7 +21,7 @@ public class LambdaFactoryMethod {\n     }\n \n     public String getName() {\n-        return LambdaClassBackporter.FACTORY_METHOD_NAME;\n+        return \"lambdaFactory$\";\n     }\n \n     public String getDesc() {\n"
    },
    {
        "commit_hash": "c316f597d684ca3d183664a38e458386ed67204c",
        "previous_commit_hash": "77fff0330d3e047614c89524298e147644f82fff",
        "diff_stats": {
            "additions": 31,
            "deletions": 1
        },
        "diff_content": "@@ -9,21 +9,51 @@ import org.objectweb.asm.*;\n import java.lang.invoke.*;\n import java.lang.reflect.Constructor;\n import java.util.*;\n+import java.util.concurrent.*;\n \n import static org.objectweb.asm.Opcodes.*;\n \n public class LambdaReifier {\n \n+    // These globals are used for communicating with the Java agent which\n+    // is spying on the LambdaMetafactory's dynamically generated bytecode.\n+    // We expect only one class being processed at a time, so it should\n+    // be an error if these collections contain more than one element.\n+    private static final BlockingDeque<Type> currentInvokedType = new LinkedBlockingDeque<>(1);\n+    private static final BlockingDeque<String> currentLambdaClass = new LinkedBlockingDeque<>(1);\n+\n     public static LambdaFactoryMethod reifyLambdaClass(Class<?> invoker, String invokedName, Type invokedType, Handle bsm, Object[] bsmArgs) {\n         try {\n+            setInvokedType(invokedType);\n             callBootstrapMethod(invoker, invokedName, invokedType, bsm, bsmArgs);\n+            return getLambdaFactoryMethod();\n+\n         } catch (Throwable t) {\n             throw new RuntimeException(t);\n+        } finally {\n+            resetGlobals();\n         }\n-        String lambdaClass = LambdaSavingClassFileTransformer.getLastFoundLambdaClass();\n+    }\n+\n+    private static void setInvokedType(Type invokedType) {\n+        currentInvokedType.push(invokedType);\n+    }\n+\n+    public static void setLambdaClass(String lambdaClass) {\n+        currentLambdaClass.push(lambdaClass);\n+    }\n+\n+    public static LambdaFactoryMethod getLambdaFactoryMethod() {\n+        String lambdaClass = currentLambdaClass.getFirst();\n+        Type invokedType = currentInvokedType.getFirst();\n         return new LambdaFactoryMethod(lambdaClass, invokedType);\n     }\n \n+    private static void resetGlobals() {\n+        currentInvokedType.clear();\n+        currentLambdaClass.clear();\n+    }\n+\n     private static CallSite callBootstrapMethod(Class<?> invoker, String invokedName, Type invokedType, Handle bsm, Object[] bsmArgs) throws Throwable {\n         ClassLoader cl = invoker.getClassLoader();\n         MethodHandles.Lookup caller = getLookup(invoker);\n"
    },
    {
        "commit_hash": "c316f597d684ca3d183664a38e458386ed67204c",
        "previous_commit_hash": "77fff0330d3e047614c89524298e147644f82fff",
        "diff_stats": {
            "additions": 2,
            "deletions": 9
        },
        "diff_content": "@@ -9,14 +9,12 @@ import java.lang.instrument.*;\n import java.nio.file.*;\n import java.security.ProtectionDomain;\n import java.util.*;\n-import java.util.concurrent.*;\n import java.util.regex.Pattern;\n \n public class LambdaSavingClassFileTransformer implements ClassFileTransformer {\n \n     private static final Pattern LAMBDA_CLASS = Pattern.compile(\"^.+\\\\$\\\\$Lambda\\\\$\\\\d+$\");\n \n-    private static final BlockingDeque<String> foundLambdaClasses = new LinkedBlockingDeque<>(1); // we expect only one at a time\n     private final Path outputDir;\n     private final int targetVersion;\n     private final List<ClassLoader> ignoredClassLoaders = new ArrayList<>();\n@@ -30,10 +28,6 @@ public class LambdaSavingClassFileTransformer implements ClassFileTransformer {\n         ignoredClassLoaders.add(null);\n     }\n \n-    public static String getLastFoundLambdaClass() {\n-        return foundLambdaClasses.pop();\n-    }\n-\n     @Override\n     public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {\n         if (ignoredClassLoaders.contains(loader)) {\n@@ -46,11 +40,10 @@ public class LambdaSavingClassFileTransformer implements ClassFileTransformer {\n         }\n         try {\n             System.out.println(\"Saving lambda class: \" + className);\n-            foundLambdaClasses.push(className);\n-            byte[] transformedBytes = LambdaClassBackporter.transform(classfileBuffer, targetVersion);\n+            byte[] backportedBytecode = LambdaClassBackporter.transform(classfileBuffer, targetVersion);\n             Path savePath = outputDir.resolve(className + \".class\");\n             Files.createDirectories(savePath.getParent());\n-            Files.write(savePath, transformedBytes);\n+            Files.write(savePath, backportedBytecode);\n \n         } catch (IOException e) {\n             e.printStackTrace();\n"
    },
    {
        "commit_hash": "5457f9703cceb76fc6d0dd2d4361c402f908e9a3",
        "previous_commit_hash": "c316f597d684ca3d183664a38e458386ed67204c",
        "diff_stats": {
            "additions": 6,
            "deletions": 0
        },
        "diff_content": "@@ -9,6 +9,12 @@ if [[ ! \"$RELEASE_VERSION\" =~ ^[0-9]+\\.[0-9]+\\.[0-9]+$ ]]; then\n     exit 1\n fi\n \n+function contains-line() {\n+    grep --line-regexp --quiet --fixed-strings -e \"$1\"\n+}\n+RELEASE_NOTES_TITLE=\"### Retrolambda $RELEASE_VERSION (`date --iso-8601`)\"\n+cat README.md | contains-line \"$RELEASE_NOTES_TITLE\" || (echo \"Add this line to release notes and try again:\"; echo \"$RELEASE_NOTES_TITLE\"; exit 1)\n+\n function bump_version()\n {\n     local prefix=`echo $1 | sed -n -r 's/([0-9]+\\.[0-9]+\\.)[0-9]+/\\1/p'`\n"
    },
    {
        "commit_hash": "a42b10f53fbc42e3a2b3107fcc1384d6e5d659a4",
        "previous_commit_hash": "5457f9703cceb76fc6d0dd2d4361c402f908e9a3",
        "diff_stats": {
            "additions": 5,
            "deletions": 4
        },
        "diff_content": "@@ -2,6 +2,7 @@\n set -eu\n : ${1:? Usage: $0 RELEASE_VERSION}\n SCRIPTS=`dirname \"$0\"`\n+APP_NAME=\"Retrolambda\"\n \n RELEASE_VERSION=\"$1\"\n if [[ ! \"$RELEASE_VERSION\" =~ ^[0-9]+\\.[0-9]+\\.[0-9]+$ ]]; then\n@@ -12,7 +13,7 @@ fi\n function contains-line() {\n     grep --line-regexp --quiet --fixed-strings -e \"$1\"\n }\n-RELEASE_NOTES_TITLE=\"### Retrolambda $RELEASE_VERSION (`date --iso-8601`)\"\n+RELEASE_NOTES_TITLE=\"### $APP_NAME $RELEASE_VERSION (`date --iso-8601`)\"\n cat README.md | contains-line \"$RELEASE_NOTES_TITLE\" || (echo \"Add this line to release notes and try again:\"; echo \"$RELEASE_NOTES_TITLE\"; exit 1)\n \n function bump_version()\n@@ -31,9 +32,9 @@ mvn versions:set \\\n     --file parent/pom.xml\n git add -u\n git commit -m \"Release $RELEASE_VERSION\"\n-git tag -s -m \"Retrolambda $RELEASE_VERSION\" \"v$RELEASE_VERSION\"\n+git tag -s -m \"$APP_NAME $RELEASE_VERSION\" \"v$RELEASE_VERSION\"\n \n-$SCRIPTS/stage.sh \"Retrolambda $RELEASE_VERSION\"\n+$SCRIPTS/stage.sh \"$APP_NAME $RELEASE_VERSION\"\n \n mvn versions:set \\\n     -DgenerateBackupPoms=false \\\n@@ -42,4 +43,4 @@ mvn versions:set \\\n git add -u\n git commit -m \"Prepare for next development iteration\"\n \n-$SCRIPTS/publish.sh \"Retrolambda $RELEASE_VERSION\"\n+$SCRIPTS/publish.sh \"$APP_NAME $RELEASE_VERSION\"\n"
    },
    {
        "commit_hash": "2d98c9a957e8f619a0c2db451595d52f218ae920",
        "previous_commit_hash": "a42b10f53fbc42e3a2b3107fcc1384d6e5d659a4",
        "diff_stats": {
            "additions": 13,
            "deletions": 6
        },
        "diff_content": "@@ -2,8 +2,6 @@\n set -eu\n : ${1:? Usage: $0 RELEASE_VERSION}\n SCRIPTS=`dirname \"$0\"`\n-APP_NAME=\"Retrolambda\"\n-\n RELEASE_VERSION=\"$1\"\n if [[ ! \"$RELEASE_VERSION\" =~ ^[0-9]+\\.[0-9]+\\.[0-9]+$ ]]; then\n     echo \"Error: RELEASE_VERSION must be in X.Y.Z format, but was $RELEASE_VERSION\"\n@@ -13,17 +11,26 @@ fi\n function contains-line() {\n     grep --line-regexp --quiet --fixed-strings -e \"$1\"\n }\n-RELEASE_NOTES_TITLE=\"### $APP_NAME $RELEASE_VERSION (`date --iso-8601`)\"\n-cat README.md | contains-line \"$RELEASE_NOTES_TITLE\" || (echo \"Add this line to release notes and try again:\"; echo \"$RELEASE_NOTES_TITLE\"; exit 1)\n \n-function bump_version()\n+function assert-file-contains() {\n+    local file=\"$1\"\n+    local expected=\"$2\"\n+    cat \"$file\" | contains-line \"$expected\" || (echo \"Add this line to $file and try again:\"; echo \"$expected\"; exit 1)\n+}\n+\n+function bump-version()\n {\n     local prefix=`echo $1 | sed -n -r 's/([0-9]+\\.[0-9]+\\.)[0-9]+/\\1/p'`\n     local suffix=`echo $1 | sed -n -r 's/[0-9]+\\.[0-9]+\\.([0-9]+)/\\1/p'`\n     ((suffix++))\n     echo \"$prefix$suffix-SNAPSHOT\"\n }\n-NEXT_VERSION=`bump_version $RELEASE_VERSION`\n+\n+APP_NAME=\"Retrolambda\"\n+NEXT_VERSION=`bump-version $RELEASE_VERSION`\n+\n+assert-file-contains README.md \"### $APP_NAME $RELEASE_VERSION (`date --iso-8601`)\"\n+\n set -x\n \n mvn versions:set \\\n"
    },
    {
        "commit_hash": "5964051cb9f210eaa85c3a589e6908888a68bad6",
        "previous_commit_hash": "2d98c9a957e8f619a0c2db451595d52f218ae920",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -79,7 +79,7 @@ optimizations to that mechanism may break Retrolambda.\n Version History\n ---------------\n \n-### Upcoming Changes\n+### Retrolambda 1.1.0 (2013-07-25)\n \n - Create only one instance of lambdas which do not capture arguments; i.e.\n   the same optimization as what JDK 8 does\n"
    },
    {
        "commit_hash": "5964051cb9f210eaa85c3a589e6908888a68bad6",
        "previous_commit_hash": "2d98c9a957e8f619a0c2db451595d52f218ae920",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.0.1-SNAPSHOT</version>\n+        <version>1.1.0</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "5964051cb9f210eaa85c3a589e6908888a68bad6",
        "previous_commit_hash": "2d98c9a957e8f619a0c2db451595d52f218ae920",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>1.0.1-SNAPSHOT</version>\n+    <version>1.1.0</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "5964051cb9f210eaa85c3a589e6908888a68bad6",
        "previous_commit_hash": "2d98c9a957e8f619a0c2db451595d52f218ae920",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.0.1-SNAPSHOT</version>\n+        <version>1.1.0</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "5964051cb9f210eaa85c3a589e6908888a68bad6",
        "previous_commit_hash": "2d98c9a957e8f619a0c2db451595d52f218ae920",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.0.1-SNAPSHOT</version>\n+        <version>1.1.0</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "e1c39f14271e57f08941f031239c73a069d98594",
        "previous_commit_hash": "5964051cb9f210eaa85c3a589e6908888a68bad6",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.1.0</version>\n+        <version>1.1.1-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "e1c39f14271e57f08941f031239c73a069d98594",
        "previous_commit_hash": "5964051cb9f210eaa85c3a589e6908888a68bad6",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>1.1.0</version>\n+    <version>1.1.1-SNAPSHOT</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "e1c39f14271e57f08941f031239c73a069d98594",
        "previous_commit_hash": "5964051cb9f210eaa85c3a589e6908888a68bad6",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.1.0</version>\n+        <version>1.1.1-SNAPSHOT</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "e1c39f14271e57f08941f031239c73a069d98594",
        "previous_commit_hash": "5964051cb9f210eaa85c3a589e6908888a68bad6",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.1.0</version>\n+        <version>1.1.1-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "cc9ebd2f573e7ce7d8517a56909044fdc04fdaac",
        "previous_commit_hash": "e1c39f14271e57f08941f031239c73a069d98594",
        "diff_stats": {
            "additions": 2,
            "deletions": 3
        },
        "diff_content": "@@ -14,9 +14,8 @@ even to Java 6 or Java 5. And if you reach Java 5, there are [other\n backporting tools](http://en.wikipedia.org/wiki/Java_backporting_tools)\n that may let you go down to Java 1.4.\n \n-P.S. If you hear about experiences of using Retrolambda for Android\n-development, please [send a message](https://github.com/orfjackal). In\n-theory it should be possible...\n+Android developers may also use Retrolambda. [There are reports](http://blog.orfjackal.net/2013/07/lambda-expressions-backported-to-java-7.html?showComment=1374655919855#c222763220984063335)\n+of it working on the Dalvik VM.\n \n \n User Guide\n"
    },
    {
        "commit_hash": "eda5855f8c5c472fe0eac26110d20ee182c3119b",
        "previous_commit_hash": "cc9ebd2f573e7ce7d8517a56909044fdc04fdaac",
        "diff_stats": {
            "additions": 0,
            "deletions": 1
        },
        "diff_content": "@@ -106,7 +106,6 @@ public class LambdaUsageBackporter {\n             Class<?> invoker = loadClass(myClassName);\n             LambdaFactoryMethod factory = LambdaReifier.reifyLambdaClass(invoker, invokedName, invokedType, bsm, bsmArgs);\n             super.visitMethodInsn(INVOKESTATIC, factory.getOwner(), factory.getName(), factory.getDesc());\n-\n         }\n \n         private static Class<?> loadClass(String className) {\n"
    },
    {
        "commit_hash": "411579c012cd153351470fd5a828348c6bd99eb2",
        "previous_commit_hash": "eda5855f8c5c472fe0eac26110d20ee182c3119b",
        "diff_stats": {
            "additions": 4,
            "deletions": 4
        },
        "diff_content": "@@ -1,13 +1,13 @@\n <component name=\"libraryTable\">\n-  <library name=\"Maven: org.mockito:mockito-core:1.9.5-rc1\">\n+  <library name=\"Maven: org.mockito:mockito-core:1.9.5\">\n     <CLASSES>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/mockito/mockito-core/1.9.5-rc1/mockito-core-1.9.5-rc1.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/mockito/mockito-core/1.9.5/mockito-core-1.9.5.jar!/\" />\n     </CLASSES>\n     <JAVADOC>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/mockito/mockito-core/1.9.5-rc1/mockito-core-1.9.5-rc1-javadoc.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/mockito/mockito-core/1.9.5/mockito-core-1.9.5-javadoc.jar!/\" />\n     </JAVADOC>\n     <SOURCES>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/mockito/mockito-core/1.9.5-rc1/mockito-core-1.9.5-rc1-sources.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/mockito/mockito-core/1.9.5/mockito-core-1.9.5-sources.jar!/\" />\n     </SOURCES>\n   </library>\n </component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "411579c012cd153351470fd5a828348c6bd99eb2",
        "previous_commit_hash": "eda5855f8c5c472fe0eac26110d20ee182c3119b",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -13,7 +13,7 @@\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.11\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-library:1.3\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-core:1.3\" level=\"project\" />\n-    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.mockito:mockito-core:1.9.5-rc1\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.mockito:mockito-core:1.9.5\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.objenesis:objenesis:1.0\" level=\"project\" />\n   </component>\n </module>\n"
    },
    {
        "commit_hash": "411579c012cd153351470fd5a828348c6bd99eb2",
        "previous_commit_hash": "eda5855f8c5c472fe0eac26110d20ee182c3119b",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.11\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-library:1.3\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-core:1.3\" level=\"project\" />\n-    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.mockito:mockito-core:1.9.5-rc1\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.mockito:mockito-core:1.9.5\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.objenesis:objenesis:1.0\" level=\"project\" />\n   </component>\n </module>\n"
    },
    {
        "commit_hash": "411579c012cd153351470fd5a828348c6bd99eb2",
        "previous_commit_hash": "eda5855f8c5c472fe0eac26110d20ee182c3119b",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -111,7 +111,7 @@\n             <dependency>\n                 <groupId>org.mockito</groupId>\n                 <artifactId>mockito-core</artifactId>\n-                <version>1.9.5-rc1</version>\n+                <version>1.9.5</version>\n             </dependency>\n \n         </dependencies>\n"
    },
    {
        "commit_hash": "411579c012cd153351470fd5a828348c6bd99eb2",
        "previous_commit_hash": "eda5855f8c5c472fe0eac26110d20ee182c3119b",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.11\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-library:1.3\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-core:1.3\" level=\"project\" />\n-    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.mockito:mockito-core:1.9.5-rc1\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.mockito:mockito-core:1.9.5\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.objenesis:objenesis:1.0\" level=\"project\" />\n   </component>\n </module>\n"
    },
    {
        "commit_hash": "411579c012cd153351470fd5a828348c6bd99eb2",
        "previous_commit_hash": "eda5855f8c5c472fe0eac26110d20ee182c3119b",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -13,7 +13,7 @@\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.11\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-library:1.3\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-core:1.3\" level=\"project\" />\n-    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.mockito:mockito-core:1.9.5-rc1\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.mockito:mockito-core:1.9.5\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.objenesis:objenesis:1.0\" level=\"project\" />\n   </component>\n </module>\n"
    },
    {
        "commit_hash": "505f73dfab8c7d64c0d4adcbae6d9931f2df1732",
        "previous_commit_hash": "411579c012cd153351470fd5a828348c6bd99eb2",
        "diff_stats": {
            "additions": 18,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,18 @@\n+\n+Building Retrolambda\n+====================\n+\n+Set the environment variables `JAVA8_HOME` and `JAVA7_HOME` (optionally also\n+`JAVA6_HOME` and `JAVA5_HOME`) point to the installation directories of those\n+particular JDK versions.\n+\n+Compile the project with Maven using the command:\n+\n+    mvn clean verify\n+\n+To run the tests using Java 6 and Java 5, use the commands:\n+\n+    mvn clean verify -P java6\n+    mvn clean verify -P java5\n+\n+Finally copy the executable JAR from the `retrolambda/target/` directory.\n"
    },
    {
        "commit_hash": "505f73dfab8c7d64c0d4adcbae6d9931f2df1732",
        "previous_commit_hash": "411579c012cd153351470fd5a828348c6bd99eb2",
        "diff_stats": {
            "additions": 0,
            "deletions": 18
        },
        "diff_content": "@@ -37,25 +37,6 @@ Java 7, in case the code accidentally uses Java 8 APIs or language features that\n Retrolambda doesn't backport.\n \n \n-Compiling\n----------\n-\n-Set the environment variables `JAVA8_HOME` and `JAVA7_HOME` (optionally also\n-`JAVA6_HOME` and `JAVA5_HOME`) point to the installation directories of those\n-particular JDK versions.\n-\n-Compile the project with Maven using the command:\n-\n-    mvn clean verify\n-\n-To run the tests using Java 6 and Java 5, use the commands:\n-\n-    mvn clean verify -P java6\n-    mvn clean verify -P java5\n-\n-Finally copy the executable JAR from the `retrolambda/target/` directory.\n-\n-\n Known Limitations\n -----------------\n \n"
    },
    {
        "commit_hash": "15b7f1eb33b9b57c2da0505f8b4aa435a60bf523",
        "previous_commit_hash": "505f73dfab8c7d64c0d4adcbae6d9931f2df1732",
        "diff_stats": {
            "additions": 32,
            "deletions": 4
        },
        "diff_content": "@@ -21,6 +21,8 @@ of it working on the Dalvik VM.\n User Guide\n ----------\n \n+### Getting Started\n+\n [Download](http://repo.maven.apache.org/maven2/net/orfjackal/retrolambda/retrolambda/)\n the latest `retrolambda.jar` from Maven Central.\n \n@@ -28,13 +30,39 @@ Use JDK 8 to compile your source code.\n \n Run Retrolambda, using Java 8, on the class files produced by JDK 8. Run\n `java -jar retrolambda.jar` without any additional options to see the\n-instructions. For an example of how to do this with Maven, see how\n+instructions.\n+\n+Your class files should now run on Java 7. Be sure to run comprehensive tests\n+on Java 7, in case the code accidentally uses Java 8 APIs or language features\n+that Retrolambda doesn't backport.\n+\n+\n+### Tips\n+\n+For an example of how to run Retrolambda using Maven, see how\n maven-dependency-plugin and maven-antrun-plugin are used in\n [end-to-end-tests/pom.xml](https://github.com/orfjackal/retrolambda/blob/master/end-to-end-tests/pom.xml)\n+There isn't yet a Maven plugin for doing that with less boilerplate, but maybe\n+later.\n+\n+During development, inside an IDE, it's the easiest to use Java 8, without\n+Retrolamba, to compile and run tests. But in your continuous integration build\n+you should run tests using the target Java version. For example, you can\n+configure Maven Surefire Plugin to run tests\n+[using a different JVM](http://maven.apache.org/surefire/maven-surefire-plugin/test-mojo.html#jvm).\n+\n+I recommend setting up environment variables JAVA8_HOME, JAVA7_HOME etc. and\n+referring to those variables in the build configuration, instead of relying on\n+what happens to be the default Java version in JAVA_HOME.\n+\n+You will need Java 8 for compiling and also for generating Javadocs.\n+\n+\n+### Third Party Tools\n+\n+- [Gradle Retrolamba Plugin](https://github.com/evant/gradle-retrolambda)\n \n-Your class files should now run on Java 7. Be sure to run comprehensive tests on\n-Java 7, in case the code accidentally uses Java 8 APIs or language features that\n-Retrolambda doesn't backport.\n+If you have things to add to this list, [create a pull request](https://github.com/orfjackal/retrolambda/pulls).\n \n \n Known Limitations\n"
    },
    {
        "commit_hash": "e7497206ca3e1f63f8e39b447243bbcc63cd1cc2",
        "previous_commit_hash": "15b7f1eb33b9b57c2da0505f8b4aa435a60bf523",
        "diff_stats": {
            "additions": 5,
            "deletions": 0
        },
        "diff_content": "@@ -87,6 +87,11 @@ optimizations to that mechanism may break Retrolambda.\n Version History\n ---------------\n \n+### Incoming Changes\n+\n+- Show help if the `-javaagent` parameter is missing\n+  ([Issue #2](https://github.com/orfjackal/retrolambda/issues/2))\n+\n ### Retrolambda 1.1.0 (2013-07-25)\n \n - Create only one instance of lambdas which do not capture arguments; i.e.\n"
    },
    {
        "commit_hash": "e7497206ca3e1f63f8e39b447243bbcc63cd1cc2",
        "previous_commit_hash": "15b7f1eb33b9b57c2da0505f8b4aa435a60bf523",
        "diff_stats": {
            "additions": 4,
            "deletions": 0
        },
        "diff_content": "@@ -40,6 +40,10 @@ public class Config {\n     }\n \n     public boolean isFullyConfigured() {\n+        return hasAllRequiredProperties() && PreMain.isAgentLoaded();\n+    }\n+\n+    private boolean hasAllRequiredProperties() {\n         for (String requiredParameter : requiredProperties) {\n             if (p.getProperty(requiredParameter) == null) {\n                 return false;\n"
    },
    {
        "commit_hash": "e7497206ca3e1f63f8e39b447243bbcc63cd1cc2",
        "previous_commit_hash": "15b7f1eb33b9b57c2da0505f8b4aa435a60bf523",
        "diff_stats": {
            "additions": 7,
            "deletions": 0
        },
        "diff_content": "@@ -9,10 +9,17 @@ import java.nio.file.Path;\n \n public class PreMain {\n \n+    private static boolean agentLoaded = false;\n+\n     public static void premain(String agentArgs, Instrumentation inst) {\n         Config config = new Config(System.getProperties());\n         int bytecodeVersion = config.getBytecodeVersion();\n         Path outputDir = config.getOutputDir();\n         inst.addTransformer(new LambdaSavingClassFileTransformer(outputDir, bytecodeVersion));\n+        agentLoaded = true;\n+    }\n+\n+    public static boolean isAgentLoaded() {\n+        return agentLoaded;\n     }\n }\n"
    },
    {
        "commit_hash": "a6a71b59169f4e69dd8431a59badb09f6bf585d0",
        "previous_commit_hash": "e7497206ca3e1f63f8e39b447243bbcc63cd1cc2",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -341,7 +341,7 @@\n                     <version>1.4.4</version>\n                     <configuration>\n                         <nexusUrl>https://oss.sonatype.org/</nexusUrl>\n-                        <serverId>ossrh-releases</serverId>\n+                        <serverId>ossrh-releases-net.orfjackal</serverId>\n                         <stagingProfileId>9e9bbc30f020cf</stagingProfileId>\n                     </configuration>\n                 </plugin>\n"
    },
    {
        "commit_hash": "4b90c1f8da21324bd03ce8cea9f14708a24d9eb6",
        "previous_commit_hash": "a6a71b59169f4e69dd8431a59badb09f6bf585d0",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -87,7 +87,7 @@ optimizations to that mechanism may break Retrolambda.\n Version History\n ---------------\n \n-### Incoming Changes\n+### Retrolambda 1.1.1 (2013-11-27)\n \n - Show help if the `-javaagent` parameter is missing\n   ([Issue #2](https://github.com/orfjackal/retrolambda/issues/2))\n"
    },
    {
        "commit_hash": "4b90c1f8da21324bd03ce8cea9f14708a24d9eb6",
        "previous_commit_hash": "a6a71b59169f4e69dd8431a59badb09f6bf585d0",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.1.1-SNAPSHOT</version>\n+        <version>1.1.1</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "4b90c1f8da21324bd03ce8cea9f14708a24d9eb6",
        "previous_commit_hash": "a6a71b59169f4e69dd8431a59badb09f6bf585d0",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>1.1.1-SNAPSHOT</version>\n+    <version>1.1.1</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "4b90c1f8da21324bd03ce8cea9f14708a24d9eb6",
        "previous_commit_hash": "a6a71b59169f4e69dd8431a59badb09f6bf585d0",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.1.1-SNAPSHOT</version>\n+        <version>1.1.1</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "4b90c1f8da21324bd03ce8cea9f14708a24d9eb6",
        "previous_commit_hash": "a6a71b59169f4e69dd8431a59badb09f6bf585d0",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.1.1-SNAPSHOT</version>\n+        <version>1.1.1</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "a94aaa545aadee705bcb37fff0bc5149fc611511",
        "previous_commit_hash": "4b90c1f8da21324bd03ce8cea9f14708a24d9eb6",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.1.1</version>\n+        <version>1.1.2-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "a94aaa545aadee705bcb37fff0bc5149fc611511",
        "previous_commit_hash": "4b90c1f8da21324bd03ce8cea9f14708a24d9eb6",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>1.1.1</version>\n+    <version>1.1.2-SNAPSHOT</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "a94aaa545aadee705bcb37fff0bc5149fc611511",
        "previous_commit_hash": "4b90c1f8da21324bd03ce8cea9f14708a24d9eb6",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.1.1</version>\n+        <version>1.1.2-SNAPSHOT</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "a94aaa545aadee705bcb37fff0bc5149fc611511",
        "previous_commit_hash": "4b90c1f8da21324bd03ce8cea9f14708a24d9eb6",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.1.1</version>\n+        <version>1.1.2-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "355fbd2802595ed6242199208fb4b4aa8e29017b",
        "previous_commit_hash": "a94aaa545aadee705bcb37fff0bc5149fc611511",
        "diff_stats": {
            "additions": 0,
            "deletions": 4
        },
        "diff_content": "@@ -1,9 +1,5 @@\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <project version=\"4\">\n-  <component name=\"CoverageOptionsProvider\">\n-    <option name=\"myAddOrReplace\" value=\"0\" />\n-    <option name=\"myActivateViewOnRun\" value=\"false\" />\n-  </component>\n   <component name=\"EntryPointsManager\">\n     <entry_points version=\"2.0\" />\n   </component>\n"
    },
    {
        "commit_hash": "355fbd2802595ed6242199208fb4b4aa8e29017b",
        "previous_commit_hash": "a94aaa545aadee705bcb37fff0bc5149fc611511",
        "diff_stats": {
            "additions": 32,
            "deletions": 1
        },
        "diff_content": "@@ -30,12 +30,43 @@ Use JDK 8 to compile your source code.\n \n Run Retrolambda, using Java 8, on the class files produced by JDK 8. Run\n `java -jar retrolambda.jar` without any additional options to see the\n-instructions.\n+instructions. For your convenience it's also shown below.\n \n Your class files should now run on Java 7. Be sure to run comprehensive tests\n on Java 7, in case the code accidentally uses Java 8 APIs or language features\n that Retrolambda doesn't backport.\n \n+```\n+Usage: java -Dretrolambda.inputDir=? -Dretrolambda.classpath=? -javaagent:retrolambda.jar -jar retrolambda.jar\n+\n+Retrolambda is a backporting tool for classes which use lambda expressions\n+and have been compiled with Java 8, to run on Java 7 (maybe even Java 5).\n+See https://github.com/orfjackal/retrolambda\n+\n+Copyright (c) 2013  Esko Luontola <www.orfjackal.net>\n+This software is released under the Apache License 2.0.\n+The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+Required system properties:\n+\n+  retrolambda.inputDir\n+      Input directory from where the original class files are read.\n+\n+  retrolambda.classpath\n+      Classpath containing the original class files and their dependencies.\n+\n+Optional system properties:\n+\n+  retrolambda.bytecodeVersion\n+      Major version number for the generated bytecode. For a list, see\n+      offset 7 at http://en.wikipedia.org/wiki/Java_class_file#General_layout\n+      Default value is 51 (i.e. Java 7)\n+\n+  retrolambda.outputDir\n+      Output directory into where the generated class files are written.\n+      Defaults to same as retrolambda.inputDir\n+```\n+\n \n ### Tips\n \n"
    },
    {
        "commit_hash": "355fbd2802595ed6242199208fb4b4aa8e29017b",
        "previous_commit_hash": "a94aaa545aadee705bcb37fff0bc5149fc611511",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -5,6 +5,7 @@\n     <output-test url=\"file://$MODULE_DIR$/target/test-classes\" />\n     <content url=\"file://$MODULE_DIR$\">\n       <sourceFolder url=\"file://$MODULE_DIR$/src/main/java\" isTestSource=\"false\" />\n+      <sourceFolder url=\"file://$MODULE_DIR$/src/test/java\" isTestSource=\"true\" />\n       <excludeFolder url=\"file://$MODULE_DIR$/target\" />\n     </content>\n     <orderEntry type=\"inheritedJdk\" />\n"
    },
    {
        "commit_hash": "355fbd2802595ed6242199208fb4b4aa8e29017b",
        "previous_commit_hash": "a94aaa545aadee705bcb37fff0bc5149fc611511",
        "diff_stats": {
            "additions": 33,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,33 @@\n+// Copyright \u00a9 2013 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda;\n+\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.*;\n+import java.util.Properties;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+public class DocumentationTest {\n+\n+    @Test\n+    public void README_contains_the_usage_instructions() {\n+        String readme = toString(Paths.get(\"README.md\"));\n+        String help = new Config(new Properties()).getHelp();\n+\n+        assertTrue(\"Expected README to contain the following text:\\n\\n\" + help, readme.contains(help));\n+    }\n+\n+    private static String toString(Path path) {\n+        try {\n+            return new String(Files.readAllBytes(path), StandardCharsets.UTF_8);\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+}\n"
    },
    {
        "commit_hash": "60fc80acce786a1ef9ac217e0ff96c2dcc7a30c6",
        "previous_commit_hash": "355fbd2802595ed6242199208fb4b4aa8e29017b",
        "diff_stats": {
            "additions": 15,
            "deletions": 8
        },
        "diff_content": "@@ -6,7 +6,7 @@ package net.orfjackal.retrolambda;\n \n import org.junit.Test;\n \n-import java.io.IOException;\n+import java.io.*;\n import java.nio.charset.StandardCharsets;\n import java.nio.file.*;\n import java.util.Properties;\n@@ -16,18 +16,25 @@ import static org.junit.Assert.assertTrue;\n public class DocumentationTest {\n \n     @Test\n-    public void README_contains_the_usage_instructions() {\n-        String readme = toString(Paths.get(\"README.md\"));\n+    public void README_contains_the_usage_instructions() throws IOException {\n+        String readme = toString(findInClosestParentDir(\"README.md\"));\n         String help = new Config(new Properties()).getHelp();\n \n         assertTrue(\"Expected README to contain the following text:\\n\\n\" + help, readme.contains(help));\n     }\n \n-    private static String toString(Path path) {\n-        try {\n-            return new String(Files.readAllBytes(path), StandardCharsets.UTF_8);\n-        } catch (IOException e) {\n-            throw new RuntimeException(e);\n+\n+    private static Path findInClosestParentDir(String filename) throws IOException {\n+        for (Path dir = Paths.get(\".\").toRealPath(); dir.getParent() != null; dir = dir.getParent()) {\n+            Path file = dir.resolve(filename);\n+            if (Files.exists(file)) {\n+                return file;\n+            }\n         }\n+        throw new FileNotFoundException(filename);\n+    }\n+\n+    private static String toString(Path path) throws IOException {\n+        return new String(Files.readAllBytes(path), StandardCharsets.UTF_8);\n     }\n }\n"
    },
    {
        "commit_hash": "435b5594b2c6520428a9f7da27747e6fabd6d963",
        "previous_commit_hash": "60fc80acce786a1ef9ac217e0ff96c2dcc7a30c6",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -30,7 +30,7 @@ Use JDK 8 to compile your source code.\n \n Run Retrolambda, using Java 8, on the class files produced by JDK 8. Run\n `java -jar retrolambda.jar` without any additional options to see the\n-instructions. For your convenience it's also shown below.\n+instructions (for your convenience they are also shown below).\n \n Your class files should now run on Java 7. Be sure to run comprehensive tests\n on Java 7, in case the code accidentally uses Java 8 APIs or language features\n"
    },
    {
        "commit_hash": "5d6a02dd4f198d87a56c54752674b184e7498123",
        "previous_commit_hash": "435b5594b2c6520428a9f7da27747e6fabd6d963",
        "diff_stats": {
            "additions": 4,
            "deletions": 2
        },
        "diff_content": "@@ -20,8 +20,10 @@ function assert-file-contains() {\n \n function bump-version()\n {\n-    local prefix=`echo $1 | sed -n -r 's/([0-9]+\\.[0-9]+\\.)[0-9]+/\\1/p'`\n-    local suffix=`echo $1 | sed -n -r 's/[0-9]+\\.[0-9]+\\.([0-9]+)/\\1/p'`\n+    [[ $1 =~ ([0-9]+.[0-9]+.)[0-9]+ ]]\n+    local prefix=${BASH_REMATCH[1]}\n+    [[ $1 =~ [0-9]+.[0-9]+.([0-9]+) ]]\n+    local suffix=${BASH_REMATCH[1]}\n     ((suffix++))\n     echo \"$prefix$suffix-SNAPSHOT\"\n }\n"
    },
    {
        "commit_hash": "59daeff456dfd2b9929dd52e5f6081a6c1e2d826",
        "previous_commit_hash": "5d6a02dd4f198d87a56c54752674b184e7498123",
        "diff_stats": {
            "additions": 4,
            "deletions": 4
        },
        "diff_content": "@@ -1,13 +1,13 @@\n <component name=\"libraryTable\">\n-  <library name=\"Maven: org.ow2.asm:asm-debug-all:4.1\">\n+  <library name=\"Maven: org.ow2.asm:asm-debug-all:5.0_BETA\">\n     <CLASSES>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm-debug-all/4.1/asm-debug-all-4.1.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm-debug-all/5.0_BETA/asm-debug-all-5.0_BETA.jar!/\" />\n     </CLASSES>\n     <JAVADOC>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm-debug-all/4.1/asm-debug-all-4.1-javadoc.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm-debug-all/5.0_BETA/asm-debug-all-5.0_BETA-javadoc.jar!/\" />\n     </JAVADOC>\n     <SOURCES>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm-debug-all/4.1/asm-debug-all-4.1-sources.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm-debug-all/5.0_BETA/asm-debug-all-5.0_BETA-sources.jar!/\" />\n     </SOURCES>\n   </library>\n </component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "59daeff456dfd2b9929dd52e5f6081a6c1e2d826",
        "previous_commit_hash": "5d6a02dd4f198d87a56c54752674b184e7498123",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -84,7 +84,7 @@\n             <dependency>\n                 <groupId>org.ow2.asm</groupId>\n                 <artifactId>asm-debug-all</artifactId>\n-                <version>4.1</version>\n+                <version>5.0_BETA</version>\n             </dependency>\n \n             <!-- Testing -->\n"
    },
    {
        "commit_hash": "59daeff456dfd2b9929dd52e5f6081a6c1e2d826",
        "previous_commit_hash": "5d6a02dd4f198d87a56c54752674b184e7498123",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -10,7 +10,7 @@\n     </content>\n     <orderEntry type=\"inheritedJdk\" />\n     <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n-    <orderEntry type=\"library\" name=\"Maven: org.ow2.asm:asm-debug-all:4.1\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.ow2.asm:asm-debug-all:5.0_BETA\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.11\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-library:1.3\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-core:1.3\" level=\"project\" />\n"
    },
    {
        "commit_hash": "59daeff456dfd2b9929dd52e5f6081a6c1e2d826",
        "previous_commit_hash": "5d6a02dd4f198d87a56c54752674b184e7498123",
        "diff_stats": {
            "additions": 1,
            "deletions": 20
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2014 Esko Luontola <www.orfjackal.net>\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -7,7 +7,6 @@ package net.orfjackal.retrolambda;\n import org.objectweb.asm.*;\n \n import java.lang.reflect.Field;\n-import java.nio.ByteBuffer;\n import java.util.concurrent.atomic.AtomicInteger;\n import java.util.regex.Pattern;\n \n@@ -15,34 +14,16 @@ import static org.objectweb.asm.Opcodes.*;\n \n public class LambdaUsageBackporter {\n \n-    private static final int JAVA_8_BYTECODE_VERSION = 52;\n-    private static final int MAJOR_VERSION_OFFSET = 6;\n-\n     private static final String LAMBDA_METAFACTORY = \"java/lang/invoke/LambdaMetafactory\";\n     private static final Pattern LAMBDA_IMPL_METHOD = Pattern.compile(\"^lambda\\\\$\\\\d+$\");\n \n     public static byte[] transform(byte[] bytecode, int targetVersion) {\n-        asmJava8SupportWorkaround(bytecode);\n         resetLambdaClassSequenceNumber();\n         ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n         new ClassReader(bytecode).accept(new MyClassVisitor(cw, targetVersion), 0);\n         return cw.toByteArray();\n     }\n \n-    private static void asmJava8SupportWorkaround(byte[] bytecode) {\n-        ByteBuffer buffer = ByteBuffer.wrap(bytecode);\n-        short majorVersion = buffer.getShort(MAJOR_VERSION_OFFSET);\n-\n-        if (majorVersion == JAVA_8_BYTECODE_VERSION) {\n-            // XXX: ASM doesn't yet support Java 8, so we must fake the data to be from Java 7\n-            buffer.putShort(MAJOR_VERSION_OFFSET, (short) (majorVersion - 1));\n-            // TODO: once we can remove this workaround, make our ClassVisitor responsible for setting the bytecode version\n-\n-        } else if (majorVersion > JAVA_8_BYTECODE_VERSION) {\n-            throw new IllegalArgumentException(\"Only Java 8 and lower is supported, but bytecode version was \" + majorVersion);\n-        }\n-    }\n-\n     private static void resetLambdaClassSequenceNumber() {\n         try {\n             Field counterField = Class.forName(\"java.lang.invoke.InnerClassLambdaMetafactory\").getDeclaredField(\"counter\");\n"
    },
    {
        "commit_hash": "0a984bc47ca950d7e015bab07100b662be317ebe",
        "previous_commit_hash": "59daeff456dfd2b9929dd52e5f6081a6c1e2d826",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -1,6 +1,6 @@\n <component name=\"CopyrightManager\">\n   <copyright>\n-    <option name=\"notice\" value=\"Copyright \u00a9 &amp;#36;today.year Esko Luontola &lt;www.orfjackal.net&gt;&#10;This software is released under the Apache License 2.0.&#10;The license text is at http://www.apache.org/licenses/LICENSE-2.0\" />\n+    <option name=\"notice\" value=\"Copyright \u00a9 2013-&amp;#36;today.year Esko Luontola &lt;www.orfjackal.net&gt;&#10;This software is released under the Apache License 2.0.&#10;The license text is at http://www.apache.org/licenses/LICENSE-2.0\" />\n     <option name=\"keyword\" value=\"Copyright\" />\n     <option name=\"allowReplaceKeyword\" value=\"\" />\n     <option name=\"myName\" value=\"Apache 2.0\" />\n"
    },
    {
        "commit_hash": "0a984bc47ca950d7e015bab07100b662be317ebe",
        "previous_commit_hash": "59daeff456dfd2b9929dd52e5f6081a6c1e2d826",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -43,7 +43,7 @@ Retrolambda is a backporting tool for classes which use lambda expressions\n and have been compiled with Java 8, to run on Java 7 (maybe even Java 5).\n See https://github.com/orfjackal/retrolambda\n \n-Copyright (c) 2013  Esko Luontola <www.orfjackal.net>\n+Copyright (c) 2013-2014  Esko Luontola <www.orfjackal.net>\n This software is released under the Apache License 2.0.\n The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n"
    },
    {
        "commit_hash": "0a984bc47ca950d7e015bab07100b662be317ebe",
        "previous_commit_hash": "59daeff456dfd2b9929dd52e5f6081a6c1e2d826",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -133,7 +133,7 @@ public class Config {\n                 \"and have been compiled with Java 8, to run on Java 7 (maybe even Java 5).\\n\" +\n                 \"See https://github.com/orfjackal/retrolambda\\n\" +\n                 \"\\n\" +\n-                \"Copyright (c) 2013  Esko Luontola <www.orfjackal.net>\\n\" +\n+                \"Copyright (c) 2013-2014  Esko Luontola <www.orfjackal.net>\\n\" +\n                 \"This software is released under the Apache License 2.0.\\n\" +\n                 \"The license text is at http://www.apache.org/licenses/LICENSE-2.0\\n\" +\n                 \"\\n\" +\n"
    },
    {
        "commit_hash": "0a984bc47ca950d7e015bab07100b662be317ebe",
        "previous_commit_hash": "59daeff456dfd2b9929dd52e5f6081a6c1e2d826",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2014 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n"
    },
    {
        "commit_hash": "fe772bdc5bcf6fa87fcd7ef9f77a531c9f1810ff",
        "previous_commit_hash": "0a984bc47ca950d7e015bab07100b662be317ebe",
        "diff_stats": {
            "additions": 9,
            "deletions": 0
        },
        "diff_content": "@@ -114,10 +114,19 @@ May break if a future JDK 8 build stops generating a new class for each\n that `java.lang.invoke.LambdaMetafactory` generates dynamically, so\n optimizations to that mechanism may break Retrolambda.\n \n+Does not implement JDK 8's safety measure of using `invokespecial` to call\n+lambda implementation methods that are private instance methods (i.e. when\n+the lambda accesses an instance variable).\n+\n \n Version History\n ---------------\n \n+### Upcoming\n+\n+- Updated to work with JDK 8 Early Access Build b121 (2013-12-19)\n+  ([Issue #3](https://github.com/orfjackal/retrolambda/issues/3))\n+\n ### Retrolambda 1.1.1 (2013-11-27)\n \n - Show help if the `-javaagent` parameter is missing\n"
    },
    {
        "commit_hash": "fe772bdc5bcf6fa87fcd7ef9f77a531c9f1810ff",
        "previous_commit_hash": "0a984bc47ca950d7e015bab07100b662be317ebe",
        "diff_stats": {
            "additions": 26,
            "deletions": 6
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -11,8 +11,6 @@ import static org.objectweb.asm.Opcodes.*;\n public class LambdaClassBackporter {\n \n     private static final String SINGLETON_FIELD_NAME = \"instance\";\n-\n-    private static final String MAGIC_LAMBDA_IMPL = \"java/lang/invoke/MagicLambdaImpl\";\n     private static final String JAVA_LANG_OBJECT = \"java/lang/Object\";\n \n     public static byte[] transform(byte[] bytecode, int targetVersion) {\n@@ -41,7 +39,7 @@ public class LambdaClassBackporter {\n             if (version > targetVersion) {\n                 version = targetVersion;\n             }\n-            if (superName.equals(MAGIC_LAMBDA_IMPL)) {\n+            if (superName.equals(LambdaNaming.MAGIC_LAMBDA_IMPL)) {\n                 superName = JAVA_LANG_OBJECT;\n             }\n             super.visit(version, access, name, signature, superName, interfaces);\n@@ -53,7 +51,9 @@ public class LambdaClassBackporter {\n                 constructor = Type.getMethodType(desc);\n             }\n             MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n-            return new MagicLambdaRemovingMethodVisitor(mv);\n+            mv = new MagicLambdaRemovingMethodVisitor(mv);\n+            mv = new PrivateMethodInvocationFixingMethodVisitor(mv, factoryMethod.getInvoker());\n+            return mv;\n         }\n \n         @Override\n@@ -124,7 +124,7 @@ public class LambdaClassBackporter {\n         @Override\n         public void visitMethodInsn(int opcode, String owner, String name, String desc) {\n             if (opcode == INVOKESPECIAL\n-                    && owner.equals(MAGIC_LAMBDA_IMPL)\n+                    && owner.equals(LambdaNaming.MAGIC_LAMBDA_IMPL)\n                     && name.equals(\"<init>\")\n                     && desc.equals(\"()V\")) {\n                 owner = JAVA_LANG_OBJECT;\n@@ -132,4 +132,24 @@ public class LambdaClassBackporter {\n             super.visitMethodInsn(opcode, owner, name, desc);\n         }\n     }\n+\n+    private static class PrivateMethodInvocationFixingMethodVisitor extends MethodVisitor {\n+\n+        private final String invoker;\n+\n+        public PrivateMethodInvocationFixingMethodVisitor(MethodVisitor mv, Class<?> invoker) {\n+            super(ASM4, mv);\n+            this.invoker = Type.getInternalName(invoker);\n+        }\n+\n+        @Override\n+        public void visitMethodInsn(int opcode, String owner, String name, String desc) {\n+            if (opcode == INVOKESPECIAL\n+                    && owner.equals(invoker)\n+                    && LambdaNaming.LAMBDA_IMPL_METHOD.matcher(name).matches()) {\n+                opcode = INVOKEVIRTUAL;\n+            }\n+            super.visitMethodInsn(opcode, owner, name, desc);\n+        }\n+    }\n }\n"
    },
    {
        "commit_hash": "fe772bdc5bcf6fa87fcd7ef9f77a531c9f1810ff",
        "previous_commit_hash": "0a984bc47ca950d7e015bab07100b662be317ebe",
        "diff_stats": {
            "additions": 8,
            "deletions": 2
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -10,10 +10,12 @@ public class LambdaFactoryMethod {\n \n     private final String owner;\n     private final String desc;\n+    private final Class<?> invoker;\n \n-    public LambdaFactoryMethod(String lambdaClass, Type invokedType) {\n+    public LambdaFactoryMethod(String lambdaClass, Type invokedType, Class<?> invoker) {\n         owner = lambdaClass;\n         desc = invokedType.getDescriptor();\n+        this.invoker = invoker;\n     }\n \n     public String getOwner() {\n@@ -27,4 +29,8 @@ public class LambdaFactoryMethod {\n     public String getDesc() {\n         return desc;\n     }\n+\n+    public Class<?> getInvoker() {\n+        return invoker;\n+    }\n }\n"
    },
    {
        "commit_hash": "fe772bdc5bcf6fa87fcd7ef9f77a531c9f1810ff",
        "previous_commit_hash": "0a984bc47ca950d7e015bab07100b662be317ebe",
        "diff_stats": {
            "additions": 15,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,15 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda;\n+\n+import java.util.regex.Pattern;\n+\n+public class LambdaNaming {\n+\n+    public static final String LAMBDA_METAFACTORY = \"java/lang/invoke/LambdaMetafactory\";\n+    public static final String MAGIC_LAMBDA_IMPL = \"java/lang/invoke/MagicLambdaImpl\";\n+    public static final Pattern LAMBDA_CLASS = Pattern.compile(\"^.+\\\\$\\\\$Lambda\\\\$\\\\d+$\");\n+    public static final Pattern LAMBDA_IMPL_METHOD = Pattern.compile(\"^lambda\\\\$.*\\\\$\\\\d+$\");\n+}\n"
    },
    {
        "commit_hash": "fe772bdc5bcf6fa87fcd7ef9f77a531c9f1810ff",
        "previous_commit_hash": "0a984bc47ca950d7e015bab07100b662be317ebe",
        "diff_stats": {
            "additions": 10,
            "deletions": 2
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -19,11 +19,13 @@ public class LambdaReifier {\n     // is spying on the LambdaMetafactory's dynamically generated bytecode.\n     // We expect only one class being processed at a time, so it should\n     // be an error if these collections contain more than one element.\n+    private static final BlockingDeque<Class<?>> currentInvoker = new LinkedBlockingDeque<>(1);\n     private static final BlockingDeque<Type> currentInvokedType = new LinkedBlockingDeque<>(1);\n     private static final BlockingDeque<String> currentLambdaClass = new LinkedBlockingDeque<>(1);\n \n     public static LambdaFactoryMethod reifyLambdaClass(Class<?> invoker, String invokedName, Type invokedType, Handle bsm, Object[] bsmArgs) {\n         try {\n+            setInvoker(invoker);\n             setInvokedType(invokedType);\n             callBootstrapMethod(invoker, invokedName, invokedType, bsm, bsmArgs);\n             return getLambdaFactoryMethod();\n@@ -35,6 +37,10 @@ public class LambdaReifier {\n         }\n     }\n \n+    public static void setInvoker(Class<?> invoker) {\n+        currentInvoker.push(invoker);\n+    }\n+\n     private static void setInvokedType(Type invokedType) {\n         currentInvokedType.push(invokedType);\n     }\n@@ -46,10 +52,12 @@ public class LambdaReifier {\n     public static LambdaFactoryMethod getLambdaFactoryMethod() {\n         String lambdaClass = currentLambdaClass.getFirst();\n         Type invokedType = currentInvokedType.getFirst();\n-        return new LambdaFactoryMethod(lambdaClass, invokedType);\n+        Class<?> invoker = currentInvoker.getFirst();\n+        return new LambdaFactoryMethod(lambdaClass, invokedType, invoker);\n     }\n \n     private static void resetGlobals() {\n+        currentInvoker.clear();\n         currentInvokedType.clear();\n         currentLambdaClass.clear();\n     }\n"
    },
    {
        "commit_hash": "fe772bdc5bcf6fa87fcd7ef9f77a531c9f1810ff",
        "previous_commit_hash": "0a984bc47ca950d7e015bab07100b662be317ebe",
        "diff_stats": {
            "additions": 9,
            "deletions": 5
        },
        "diff_content": "@@ -1,20 +1,19 @@\n-// Copyright \u00a9 2013 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n package net.orfjackal.retrolambda;\n \n+import org.objectweb.asm.ClassReader;\n+\n import java.io.IOException;\n import java.lang.instrument.*;\n import java.nio.file.*;\n import java.security.ProtectionDomain;\n import java.util.*;\n-import java.util.regex.Pattern;\n \n public class LambdaSavingClassFileTransformer implements ClassFileTransformer {\n \n-    private static final Pattern LAMBDA_CLASS = Pattern.compile(\"^.+\\\\$\\\\$Lambda\\\\$\\\\d+$\");\n-\n     private final Path outputDir;\n     private final int targetVersion;\n     private final List<ClassLoader> ignoredClassLoaders = new ArrayList<>();\n@@ -35,6 +34,11 @@ public class LambdaSavingClassFileTransformer implements ClassFileTransformer {\n             // The transformed application classes have their own class loader.\n             return null;\n         }\n+        if (className == null) {\n+            // Since JDK 8 build b121 or so, lambda classes have a null class name,\n+            // but we can read it from the bytecode where the name still exists.\n+            className = new ClassReader(classfileBuffer).getClassName();\n+        }\n         if (!isLambdaClass(className)) {\n             return null;\n         }\n@@ -52,6 +56,6 @@ public class LambdaSavingClassFileTransformer implements ClassFileTransformer {\n     }\n \n     private static boolean isLambdaClass(String className) {\n-        return LAMBDA_CLASS.matcher(className).matches();\n+        return LambdaNaming.LAMBDA_CLASS.matcher(className).matches();\n     }\n }\n"
    },
    {
        "commit_hash": "fe772bdc5bcf6fa87fcd7ef9f77a531c9f1810ff",
        "previous_commit_hash": "0a984bc47ca950d7e015bab07100b662be317ebe",
        "diff_stats": {
            "additions": 2,
            "deletions": 6
        },
        "diff_content": "@@ -8,15 +8,11 @@ import org.objectweb.asm.*;\n \n import java.lang.reflect.Field;\n import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.regex.Pattern;\n \n import static org.objectweb.asm.Opcodes.*;\n \n public class LambdaUsageBackporter {\n \n-    private static final String LAMBDA_METAFACTORY = \"java/lang/invoke/LambdaMetafactory\";\n-    private static final Pattern LAMBDA_IMPL_METHOD = Pattern.compile(\"^lambda\\\\$\\\\d+$\");\n-\n     public static byte[] transform(byte[] bytecode, int targetVersion) {\n         resetLambdaClassSequenceNumber();\n         ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n@@ -58,7 +54,7 @@ public class LambdaUsageBackporter {\n \n         @Override\n         public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n-            if (LAMBDA_IMPL_METHOD.matcher(name).matches()) {\n+            if (LambdaNaming.LAMBDA_IMPL_METHOD.matcher(name).matches()) {\n                 access = Flags.makeNonPrivate(access);\n             }\n             MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n@@ -76,7 +72,7 @@ public class LambdaUsageBackporter {\n \n         @Override\n         public void visitInvokeDynamicInsn(String name, String desc, Handle bsm, Object... bsmArgs) {\n-            if (bsm.getOwner().equals(LAMBDA_METAFACTORY)) {\n+            if (bsm.getOwner().equals(LambdaNaming.LAMBDA_METAFACTORY)) {\n                 backportLambda(name, Type.getType(desc), bsm, bsmArgs);\n             } else {\n                 super.visitInvokeDynamicInsn(name, desc, bsm, bsmArgs);\n"
    },
    {
        "commit_hash": "b57f9bcfeb4f66cf8b6578cc581ef963854768be",
        "previous_commit_hash": "fe772bdc5bcf6fa87fcd7ef9f77a531c9f1810ff",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -122,7 +122,7 @@ the lambda accesses an instance variable).\n Version History\n ---------------\n \n-### Upcoming\n+### Retrolambda 1.1.2 (2014-01-08)\n \n - Updated to work with JDK 8 Early Access Build b121 (2013-12-19)\n   ([Issue #3](https://github.com/orfjackal/retrolambda/issues/3))\n"
    },
    {
        "commit_hash": "b57f9bcfeb4f66cf8b6578cc581ef963854768be",
        "previous_commit_hash": "fe772bdc5bcf6fa87fcd7ef9f77a531c9f1810ff",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.1.2-SNAPSHOT</version>\n+        <version>1.1.2</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "b57f9bcfeb4f66cf8b6578cc581ef963854768be",
        "previous_commit_hash": "fe772bdc5bcf6fa87fcd7ef9f77a531c9f1810ff",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>1.1.2-SNAPSHOT</version>\n+    <version>1.1.2</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "b57f9bcfeb4f66cf8b6578cc581ef963854768be",
        "previous_commit_hash": "fe772bdc5bcf6fa87fcd7ef9f77a531c9f1810ff",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.1.2-SNAPSHOT</version>\n+        <version>1.1.2</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "b57f9bcfeb4f66cf8b6578cc581ef963854768be",
        "previous_commit_hash": "fe772bdc5bcf6fa87fcd7ef9f77a531c9f1810ff",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.1.2-SNAPSHOT</version>\n+        <version>1.1.2</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "0edafee2fd519465279ccafb986f2d4e631edfdf",
        "previous_commit_hash": "b57f9bcfeb4f66cf8b6578cc581ef963854768be",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.1.2</version>\n+        <version>1.1.3-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "0edafee2fd519465279ccafb986f2d4e631edfdf",
        "previous_commit_hash": "b57f9bcfeb4f66cf8b6578cc581ef963854768be",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>1.1.2</version>\n+    <version>1.1.3-SNAPSHOT</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "0edafee2fd519465279ccafb986f2d4e631edfdf",
        "previous_commit_hash": "b57f9bcfeb4f66cf8b6578cc581ef963854768be",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.1.2</version>\n+        <version>1.1.3-SNAPSHOT</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "0edafee2fd519465279ccafb986f2d4e631edfdf",
        "previous_commit_hash": "b57f9bcfeb4f66cf8b6578cc581ef963854768be",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.1.2</version>\n+        <version>1.1.3-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "d71b5f62c87583469b8d70520c656d91b59628f8",
        "previous_commit_hash": "0edafee2fd519465279ccafb986f2d4e631edfdf",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -23,7 +23,7 @@ User Guide\n \n ### Getting Started\n \n-[Download](http://repo.maven.apache.org/maven2/net/orfjackal/retrolambda/retrolambda/)\n+[Download](https://oss.sonatype.org/content/groups/public/net/orfjackal/retrolambda/retrolambda/)\n the latest `retrolambda.jar` from Maven Central.\n \n Use JDK 8 to compile your source code.\n"
    },
    {
        "commit_hash": "7f270a64292d09f66e91d1dc18b62ec84ed41526",
        "previous_commit_hash": "d71b5f62c87583469b8d70520c656d91b59628f8",
        "diff_stats": {
            "additions": 6,
            "deletions": 0
        },
        "diff_content": "@@ -122,6 +122,12 @@ the lambda accesses an instance variable).\n Version History\n ---------------\n \n+### Upcoming\n+\n+- Fixed incompatibility with the Eclipse JDT compiler, version Kepler SR2\n+  with the Java 8 support patch 1.0.0.v20140317-1959\n+  ([Issue #12](https://github.com/orfjackal/retrolambda/issues/12))\n+\n ### Retrolambda 1.1.2 (2014-01-08)\n \n - Updated to work with JDK 8 Early Access Build b121 (2013-12-19)\n"
    },
    {
        "commit_hash": "7f270a64292d09f66e91d1dc18b62ec84ed41526",
        "previous_commit_hash": "d71b5f62c87583469b8d70520c656d91b59628f8",
        "diff_stats": {
            "additions": 37,
            "deletions": 0
        },
        "diff_content": "@@ -122,4 +122,41 @@\n         </plugins>\n     </build>\n \n+    <profiles>\n+        <profile>\n+            <id>eclipse</id>\n+            <build>\n+                <plugins>\n+                    <plugin>\n+                        <artifactId>maven-compiler-plugin</artifactId>\n+                        <version>3.1</version>\n+                        <configuration>\n+                            <compilerId>eclipse</compilerId>\n+                            <!-- TODO: check compatibility with the Eclipse JDT compiler (update release scripts) -->\n+                            <!-- FIXME: we are unable to tell the Eclipse compiler to use Java 1.8\n+                                It just fails with the warning\n+                                \"Unknown version '1.8', no version setting will be given to the compiler.\"\n+                                because the plugin is only aware of Java 7 and below.\n+                                Also we failed at giving custom compiler arguments, after which we\n+                                might have been able to make it use a newer Eclipse compiler) -->\n+                            <!--\n+                            <compilerArguments>\n+                                <org.eclipse.jdt.core.compiler.source>1.5</org.eclipse.jdt.core.compiler.source>\n+                                <org.eclipse.jdt.core.compiler.codegen.targetPlatform>1.5</org.eclipse.jdt.core.compiler.codegen.targetPlatform>\n+                            </compilerArguments>\n+                            -->\n+                        </configuration>\n+                        <dependencies>\n+                            <dependency>\n+                                <groupId>org.codehaus.plexus</groupId>\n+                                <artifactId>plexus-compiler-eclipse</artifactId>\n+                                <version>2.3</version>\n+                            </dependency>\n+                        </dependencies>\n+                    </plugin>\n+                </plugins>\n+            </build>\n+        </profile>\n+    </profiles>\n+\n </project>\n"
    },
    {
        "commit_hash": "7f270a64292d09f66e91d1dc18b62ec84ed41526",
        "previous_commit_hash": "d71b5f62c87583469b8d70520c656d91b59628f8",
        "diff_stats": {
            "additions": 10,
            "deletions": 1
        },
        "diff_content": "@@ -10,6 +10,15 @@ public class LambdaNaming {\n \n     public static final String LAMBDA_METAFACTORY = \"java/lang/invoke/LambdaMetafactory\";\n     public static final String MAGIC_LAMBDA_IMPL = \"java/lang/invoke/MagicLambdaImpl\";\n+\n+    /**\n+     * Java 8 produces at runtime classes named {@code EnclosingClass$$Lambda$1}\n+     */\n     public static final Pattern LAMBDA_CLASS = Pattern.compile(\"^.+\\\\$\\\\$Lambda\\\\$\\\\d+$\");\n-    public static final Pattern LAMBDA_IMPL_METHOD = Pattern.compile(\"^lambda\\\\$.*\\\\$\\\\d+$\");\n+\n+    /**\n+     * Oracle JDK 8 compiler names the methods {@code lambda$methodName$0} but the\n+     * Eclipse JDT compiler names them {@code lambda$0} (similar to older JDK 8 EA builds).\n+     */\n+    public static final Pattern LAMBDA_IMPL_METHOD = Pattern.compile(\"^lambda(\\\\$.*)?\\\\$\\\\d+$\");\n }\n"
    },
    {
        "commit_hash": "d732c9c54319cb369526b88d1303c0b7eeaa5521",
        "previous_commit_hash": "7f270a64292d09f66e91d1dc18b62ec84ed41526",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -122,7 +122,7 @@ the lambda accesses an instance variable).\n Version History\n ---------------\n \n-### Upcoming\n+### Retrolambda 1.1.3 (2014-03-25)\n \n - Fixed incompatibility with the Eclipse JDT compiler, version Kepler SR2\n   with the Java 8 support patch 1.0.0.v20140317-1959\n"
    },
    {
        "commit_hash": "d732c9c54319cb369526b88d1303c0b7eeaa5521",
        "previous_commit_hash": "7f270a64292d09f66e91d1dc18b62ec84ed41526",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.1.3-SNAPSHOT</version>\n+        <version>1.1.3</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "d732c9c54319cb369526b88d1303c0b7eeaa5521",
        "previous_commit_hash": "7f270a64292d09f66e91d1dc18b62ec84ed41526",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>1.1.3-SNAPSHOT</version>\n+    <version>1.1.3</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "d732c9c54319cb369526b88d1303c0b7eeaa5521",
        "previous_commit_hash": "7f270a64292d09f66e91d1dc18b62ec84ed41526",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.1.3-SNAPSHOT</version>\n+        <version>1.1.3</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "d732c9c54319cb369526b88d1303c0b7eeaa5521",
        "previous_commit_hash": "7f270a64292d09f66e91d1dc18b62ec84ed41526",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.1.3-SNAPSHOT</version>\n+        <version>1.1.3</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "e4261736353e960f00d3ede4e945715b88fc96c9",
        "previous_commit_hash": "d732c9c54319cb369526b88d1303c0b7eeaa5521",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.1.3</version>\n+        <version>1.1.4-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "e4261736353e960f00d3ede4e945715b88fc96c9",
        "previous_commit_hash": "d732c9c54319cb369526b88d1303c0b7eeaa5521",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>1.1.3</version>\n+    <version>1.1.4-SNAPSHOT</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "e4261736353e960f00d3ede4e945715b88fc96c9",
        "previous_commit_hash": "d732c9c54319cb369526b88d1303c0b7eeaa5521",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.1.3</version>\n+        <version>1.1.4-SNAPSHOT</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "e4261736353e960f00d3ede4e945715b88fc96c9",
        "previous_commit_hash": "d732c9c54319cb369526b88d1303c0b7eeaa5521",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.1.3</version>\n+        <version>1.1.4-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "97da6519baebe625cd779c578d52ddc87c35f9fd",
        "previous_commit_hash": "e4261736353e960f00d3ede4e945715b88fc96c9",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -14,8 +14,8 @@ even to Java 6 or Java 5. And if you reach Java 5, there are [other\n backporting tools](http://en.wikipedia.org/wiki/Java_backporting_tools)\n that may let you go down to Java 1.4.\n \n-Android developers may also use Retrolambda. [There are reports](http://blog.orfjackal.net/2013/07/lambda-expressions-backported-to-java-7.html?showComment=1374655919855#c222763220984063335)\n-of it working on the Dalvik VM.\n+Android developers may also use Retrolambda. Serge Zaitsev has written [an\n+article about how to do it](http://zserge.com/blog/android-lambda.html).\n \n \n User Guide\n"
    },
    {
        "commit_hash": "7c3402dbe49fbb6fe7a152c700636a48826e94b5",
        "previous_commit_hash": "97da6519baebe625cd779c578d52ddc87c35f9fd",
        "diff_stats": {
            "additions": 6,
            "deletions": 0
        },
        "diff_content": "@@ -122,6 +122,12 @@ the lambda accesses an instance variable).\n Version History\n ---------------\n \n+### Upcoming\n+\n+- Removes from interfaces bridge methods which were generated by JDK 8 e.g.\n+  when an interface overrides a method and refines its return type\n+  ([Issue #13](https://github.com/orfjackal/retrolambda/issues/13))\n+\n ### Retrolambda 1.1.3 (2014-03-25)\n \n - Fixed incompatibility with the Eclipse JDT compiler, version Kepler SR2\n"
    },
    {
        "commit_hash": "7c3402dbe49fbb6fe7a152c700636a48826e94b5",
        "previous_commit_hash": "97da6519baebe625cd779c578d52ddc87c35f9fd",
        "diff_stats": {
            "additions": 38,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,38 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.test;\n+\n+import org.junit.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+\n+public class DefaultMethodsTest {\n+\n+    /**\n+     * JDK 8 adds a bridge method to an interface when it overrides a method\n+     * from the parent interface and refines its return type. This uses Java 8's\n+     * default methods feature, which won't work on Java 7 and below, so we have\n+     * to remove it for it - this makes the bytecode same as what JDK 7 produces.\n+     */\n+    @Test\n+    public void will_remove_non_abstract_methods_from_interfaces() {\n+        class Foo implements Child {\n+            @Override\n+            public String foo() {\n+                return \"foo\";\n+            }\n+        }\n+        assertThat(new Foo().foo(), is(\"foo\"));\n+    }\n+\n+    public interface Parent {\n+        Object foo();\n+    }\n+\n+    public interface Child extends Parent {\n+        String foo(); // refined return type\n+    }\n+}\n"
    },
    {
        "commit_hash": "7c3402dbe49fbb6fe7a152c700636a48826e94b5",
        "previous_commit_hash": "97da6519baebe625cd779c578d52ddc87c35f9fd",
        "diff_stats": {
            "additions": 10,
            "deletions": 0
        },
        "diff_content": "@@ -36,6 +36,7 @@ public class LambdaUsageBackporter {\n \n     private static class MyClassVisitor extends ClassVisitor {\n         private final int targetVersion;\n+        private int classAccess;\n         private String className;\n \n         public MyClassVisitor(ClassWriter cw, int targetVersion) {\n@@ -49,17 +50,26 @@ public class LambdaUsageBackporter {\n                 version = targetVersion;\n             }\n             super.visit(version, access, name, signature, superName, interfaces);\n+            this.classAccess = access;\n             this.className = name;\n         }\n \n         @Override\n         public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+            if (isBridgeMethodOnInterface(access)) {\n+                return null;\n+            }\n             if (LambdaNaming.LAMBDA_IMPL_METHOD.matcher(name).matches()) {\n                 access = Flags.makeNonPrivate(access);\n             }\n             MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n             return new InvokeDynamicInsnConvertingMethodVisitor(api, mv, className);\n         }\n+\n+        private boolean isBridgeMethodOnInterface(int methodAccess) {\n+            return Flags.hasFlag(classAccess, Opcodes.ACC_INTERFACE) &&\n+                    Flags.hasFlag(methodAccess, Opcodes.ACC_BRIDGE);\n+        }\n     }\n \n     private static class InvokeDynamicInsnConvertingMethodVisitor extends MethodVisitor {\n"
    },
    {
        "commit_hash": "7e39739b61be959ccfcf93be6f260f81b3fca37d",
        "previous_commit_hash": "7c3402dbe49fbb6fe7a152c700636a48826e94b5",
        "diff_stats": {
            "additions": 17,
            "deletions": 1
        },
        "diff_content": "@@ -57,7 +57,18 @@ public class LambdaUsageBackporter {\n         @Override\n         public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n             if (isBridgeMethodOnInterface(access)) {\n-                return null;\n+                return null; // remove the bridge method; Java 7 didn't use them\n+            }\n+            if (isNonAbstractMethodOnInterface(access)) {\n+                // We are not aware of other reasons than the bridge methods\n+                // why JDK 8 would produce non-abstract methods on interfaces,\n+                // but we have this warning here to get a bug report sooner\n+                // in case we missed something.\n+                System.out.println(\"WARNING: Method '\" + name + \"' of interface '\" + className + \"' is non-abstract! \" +\n+                        \"This will probably fail to run on Java 7 and below. \" +\n+                        \"If you get this warning _without_ using Java 8's default methods, \" +\n+                        \"please report a bug at https://github.com/orfjackal/retrolambda/issues \" +\n+                        \"together with an SSCCE (http://www.sscce.org/)\");\n             }\n             if (LambdaNaming.LAMBDA_IMPL_METHOD.matcher(name).matches()) {\n                 access = Flags.makeNonPrivate(access);\n@@ -70,6 +81,11 @@ public class LambdaUsageBackporter {\n             return Flags.hasFlag(classAccess, Opcodes.ACC_INTERFACE) &&\n                     Flags.hasFlag(methodAccess, Opcodes.ACC_BRIDGE);\n         }\n+\n+        private boolean isNonAbstractMethodOnInterface(int methodAccess) {\n+            return Flags.hasFlag(classAccess, Opcodes.ACC_INTERFACE) &&\n+                    !Flags.hasFlag(methodAccess, Opcodes.ACC_ABSTRACT);\n+        }\n     }\n \n     private static class InvokeDynamicInsnConvertingMethodVisitor extends MethodVisitor {\n"
    },
    {
        "commit_hash": "048150aa413b1458e81a0aee4b016eedff98707d",
        "previous_commit_hash": "7e39739b61be959ccfcf93be6f260f81b3fca37d",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -122,7 +122,7 @@ the lambda accesses an instance variable).\n Version History\n ---------------\n \n-### Upcoming\n+### Retrolambda 1.1.4 (2014-03-29)\n \n - Removes from interfaces bridge methods which were generated by JDK 8 e.g.\n   when an interface overrides a method and refines its return type\n"
    },
    {
        "commit_hash": "048150aa413b1458e81a0aee4b016eedff98707d",
        "previous_commit_hash": "7e39739b61be959ccfcf93be6f260f81b3fca37d",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.1.4-SNAPSHOT</version>\n+        <version>1.1.4</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "048150aa413b1458e81a0aee4b016eedff98707d",
        "previous_commit_hash": "7e39739b61be959ccfcf93be6f260f81b3fca37d",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>1.1.4-SNAPSHOT</version>\n+    <version>1.1.4</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "048150aa413b1458e81a0aee4b016eedff98707d",
        "previous_commit_hash": "7e39739b61be959ccfcf93be6f260f81b3fca37d",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.1.4-SNAPSHOT</version>\n+        <version>1.1.4</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "048150aa413b1458e81a0aee4b016eedff98707d",
        "previous_commit_hash": "7e39739b61be959ccfcf93be6f260f81b3fca37d",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.1.4-SNAPSHOT</version>\n+        <version>1.1.4</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "80c4837f39762f769c0a68f7b41b5417b1f1581c",
        "previous_commit_hash": "048150aa413b1458e81a0aee4b016eedff98707d",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.1.4</version>\n+        <version>1.1.5-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "80c4837f39762f769c0a68f7b41b5417b1f1581c",
        "previous_commit_hash": "048150aa413b1458e81a0aee4b016eedff98707d",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>1.1.4</version>\n+    <version>1.1.5-SNAPSHOT</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "80c4837f39762f769c0a68f7b41b5417b1f1581c",
        "previous_commit_hash": "048150aa413b1458e81a0aee4b016eedff98707d",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.1.4</version>\n+        <version>1.1.5-SNAPSHOT</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "80c4837f39762f769c0a68f7b41b5417b1f1581c",
        "previous_commit_hash": "048150aa413b1458e81a0aee4b016eedff98707d",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.1.4</version>\n+        <version>1.1.5-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "68c1503c26565506657b0b36974dfeaa1ea9b0d8",
        "previous_commit_hash": "80c4837f39762f769c0a68f7b41b5417b1f1581c",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -18,7 +18,7 @@ public class DefaultMethodsTest {\n      * to remove it for it - this makes the bytecode same as what JDK 7 produces.\n      */\n     @Test\n-    public void will_remove_non_abstract_methods_from_interfaces() {\n+    public void will_remove_bridge_methods_from_interfaces() {\n         class Foo implements Child {\n             @Override\n             public String foo() {\n"
    },
    {
        "commit_hash": "7bc1cba4e7b5e471fc3c89492c2633592a9e3f2d",
        "previous_commit_hash": "68c1503c26565506657b0b36974dfeaa1ea9b0d8",
        "diff_stats": {
            "additions": 2,
            "deletions": 1
        },
        "diff_content": "@@ -25,7 +25,8 @@ public class DefaultMethodsTest {\n                 return \"foo\";\n             }\n         }\n-        assertThat(new Foo().foo(), is(\"foo\"));\n+        assertThat(\"direct call\", new Foo().foo(), is(\"foo\"));\n+        assertThat(\"bridged call\", ((Parent) new Foo()).foo(), is((Object) \"foo\"));\n     }\n \n     public interface Parent {\n"
    },
    {
        "commit_hash": "1b7f8ba25482a74522474b50e78136ee17cd5e64",
        "previous_commit_hash": "7bc1cba4e7b5e471fc3c89492c2633592a9e3f2d",
        "diff_stats": {
            "additions": 111,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,111 @@\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <groupId>net.orfjackal.retrolambda</groupId>\n+  <artifactId>retrolambda-maven-plugin</artifactId>\n+  <version>1.1.5-SNAPSHOT</version>\n+  <packaging>maven-plugin</packaging>\n+\n+  <name>retrolambda-maven-plugin Maven Plugin</name>\n+\n+  <!-- FIXME change it to the project's website -->\n+  <url>http://maven.apache.org</url>\n+\n+  <properties>\n+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+  </properties>\n+\n+  <dependencies>\n+    <dependency>\n+      <groupId>org.apache.maven</groupId>\n+      <artifactId>maven-plugin-api</artifactId>\n+      <version>2.0</version>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.apache.maven.plugin-tools</groupId>\n+      <artifactId>maven-plugin-annotations</artifactId>\n+      <version>3.2</version>\n+      <scope>provided</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.codehaus.plexus</groupId>\n+      <artifactId>plexus-utils</artifactId>\n+      <version>3.0.8</version>\n+    </dependency>\n+    <dependency>\n+      <groupId>junit</groupId>\n+      <artifactId>junit</artifactId>\n+      <version>4.8.2</version>\n+      <scope>test</scope>\n+    </dependency>\n+  </dependencies>\n+\n+  <build>\n+    <plugins>\n+      <plugin>\n+        <groupId>org.apache.maven.plugins</groupId>\n+        <artifactId>maven-plugin-plugin</artifactId>\n+        <version>3.2</version>\n+        <configuration>\n+          <goalPrefix>retrolambda-maven-plugin</goalPrefix>\n+          <skipErrorNoDescriptorsFound>true</skipErrorNoDescriptorsFound>\n+        </configuration>\n+        <executions>\n+          <execution>\n+            <id>mojo-descriptor</id>\n+            <goals>\n+              <goal>descriptor</goal>\n+            </goals>\n+          </execution>\n+          <execution>\n+            <id>help-goal</id>\n+            <goals>\n+              <goal>helpmojo</goal>\n+            </goals>\n+          </execution>\n+        </executions>\n+      </plugin>\n+    </plugins>\n+  </build>\n+  <profiles>\n+    <profile>\n+      <id>run-its</id>\n+      <build>\n+\n+        <plugins>\n+          <plugin>\n+            <groupId>org.apache.maven.plugins</groupId>\n+            <artifactId>maven-invoker-plugin</artifactId>\n+            <version>1.7</version>\n+            <configuration>\n+              <debug>true</debug>\n+              <cloneProjectsTo>${project.build.directory}/it</cloneProjectsTo>\n+              <pomIncludes>\n+                <pomInclude>*/pom.xml</pomInclude>\n+              </pomIncludes>\n+              <postBuildHookScript>verify</postBuildHookScript>\n+              <localRepositoryPath>${project.build.directory}/local-repo</localRepositoryPath>\n+              <settingsFile>src/it/settings.xml</settingsFile>\n+              <goals>\n+                <goal>clean</goal>\n+                <goal>test-compile</goal>\n+              </goals>\n+            </configuration>\n+            <executions>\n+              <execution>\n+                <id>integration-test</id>\n+                <goals>\n+                  <goal>install</goal>\n+                  <goal>integration-test</goal>\n+                  <goal>verify</goal>\n+                </goals>\n+              </execution>\n+            </executions>\n+          </plugin>\n+        </plugins>\n+\n+      </build>\n+    </profile>\n+  </profiles>\n+</project>\n"
    },
    {
        "commit_hash": "1b7f8ba25482a74522474b50e78136ee17cd5e64",
        "previous_commit_hash": "7bc1cba4e7b5e471fc3c89492c2633592a9e3f2d",
        "diff_stats": {
            "additions": 55,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,55 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<!--\n+Licensed to the Apache Software Foundation (ASF) under one\n+or more contributor license agreements.  See the NOTICE file\n+distributed with this work for additional information\n+regarding copyright ownership.  The ASF licenses this file\n+to you under the Apache License, Version 2.0 (the\n+\"License\"); you may not use this file except in compliance\n+with the License.  You may obtain a copy of the License at\n+\n+  http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing,\n+software distributed under the License is distributed on an\n+\"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+KIND, either express or implied.  See the License for the\n+specific language governing permissions and limitations\n+under the License.\n+-->\n+\n+<settings>\n+  <profiles>\n+    <profile>\n+      <id>it-repo</id>\n+      <activation>\n+        <activeByDefault>true</activeByDefault>\n+      </activation>\n+      <repositories>\n+        <repository>\n+          <id>local.central</id>\n+          <url>@localRepositoryUrl@</url>\n+          <releases>\n+            <enabled>true</enabled>\n+          </releases>\n+          <snapshots>\n+            <enabled>true</enabled>\n+          </snapshots>\n+        </repository>\n+      </repositories>\n+      <pluginRepositories>\n+        <pluginRepository>\n+          <id>local.central</id>\n+          <url>@localRepositoryUrl@</url>\n+          <releases>\n+            <enabled>true</enabled>\n+          </releases>\n+          <snapshots>\n+            <enabled>true</enabled>\n+          </snapshots>\n+        </pluginRepository>\n+      </pluginRepositories>\n+    </profile>\n+  </profiles>\n+</settings>\n"
    },
    {
        "commit_hash": "1b7f8ba25482a74522474b50e78136ee17cd5e64",
        "previous_commit_hash": "7bc1cba4e7b5e471fc3c89492c2633592a9e3f2d",
        "diff_stats": {
            "additions": 34,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,34 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <groupId>net.orfjackal.retrolambda.it</groupId>\n+  <artifactId>simple-it</artifactId>\n+  <version>1.0-SNAPSHOT</version>\n+\n+  <description>A simple IT verifying the basic use case.</description>\n+\n+  <properties>\n+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+  </properties>\n+\n+  <build>\n+    <plugins>\n+      <plugin>\n+        <groupId>@project.groupId@</groupId>\n+        <artifactId>@project.artifactId@</artifactId>\n+        <version>@project.version@</version>\n+        <executions>\n+          <execution>\n+            <id>touch</id>\n+            <phase>validate</phase>\n+            <goals>\n+              <goal>touch</goal>\n+            </goals>\n+          </execution>\n+        </executions>\n+      </plugin>\n+    </plugins>\n+  </build>\n+</project>\n"
    },
    {
        "commit_hash": "1b7f8ba25482a74522474b50e78136ee17cd5e64",
        "previous_commit_hash": "7bc1cba4e7b5e471fc3c89492c2633592a9e3f2d",
        "diff_stats": {
            "additions": 3,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,3 @@\n+File touchFile = new File( basedir, \"target/touch.txt\" );\n+\n+assert touchFile.isFile()\n"
    },
    {
        "commit_hash": "1b7f8ba25482a74522474b50e78136ee17cd5e64",
        "previous_commit_hash": "7bc1cba4e7b5e471fc3c89492c2633592a9e3f2d",
        "diff_stats": {
            "additions": 84,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,84 @@\n+package net.orfjackal.retrolambda.maven;\n+\n+/*\n+ * Copyright 2001-2005 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import org.apache.maven.plugin.AbstractMojo;\n+import org.apache.maven.plugin.MojoExecutionException;\n+\n+import org.apache.maven.plugins.annotations.LifecyclePhase;\n+import org.apache.maven.plugins.annotations.Mojo;\n+import org.apache.maven.plugins.annotations.Parameter;\n+import org.apache.maven.plugins.annotations.ResolutionScope;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+\n+/**\n+ * Goal which touches a timestamp file.\n+ *\n+ * @deprecated Don't use!\n+ */\n+@Mojo( name = \"touch\", defaultPhase = LifecyclePhase.PROCESS_SOURCES )\n+public class MyMojo\n+    extends AbstractMojo\n+{\n+    /**\n+     * Location of the file.\n+     */\n+    @Parameter( defaultValue = \"${project.build.directory}\", property = \"outputDir\", required = true )\n+    private File outputDirectory;\n+\n+    public void execute()\n+        throws MojoExecutionException\n+    {\n+        File f = outputDirectory;\n+\n+        if ( !f.exists() )\n+        {\n+            f.mkdirs();\n+        }\n+\n+        File touch = new File( f, \"touch.txt\" );\n+\n+        FileWriter w = null;\n+        try\n+        {\n+            w = new FileWriter( touch );\n+\n+            w.write( \"touch.txt\" );\n+        }\n+        catch ( IOException e )\n+        {\n+            throw new MojoExecutionException( \"Error creating file \" + touch, e );\n+        }\n+        finally\n+        {\n+            if ( w != null )\n+            {\n+                try\n+                {\n+                    w.close();\n+                }\n+                catch ( IOException e )\n+                {\n+                    // ignore\n+                }\n+            }\n+        }\n+    }\n+}\n"
    },
    {
        "commit_hash": "d957c3c8b6761ca53703a6074b033eb0843d2dde",
        "previous_commit_hash": "1b7f8ba25482a74522474b50e78136ee17cd5e64",
        "diff_stats": {
            "additions": 5,
            "deletions": 0
        },
        "diff_content": "@@ -33,6 +33,11 @@\n       <artifactId>plexus-utils</artifactId>\n       <version>3.0.8</version>\n     </dependency>\n+    <dependency>\n+      <groupId>org.twdata.maven</groupId>\n+      <artifactId>mojo-executor</artifactId>\n+      <version>2.2.0</version>\n+    </dependency>\n     <dependency>\n       <groupId>junit</groupId>\n       <artifactId>junit</artifactId>\n"
    },
    {
        "commit_hash": "101e1146d62b78beb0aa07285c1d3caf391ada5c",
        "previous_commit_hash": "d957c3c8b6761ca53703a6074b033eb0843d2dde",
        "diff_stats": {
            "additions": 3,
            "deletions": 0
        },
        "diff_content": "@@ -1,2 +1,5 @@\n /target/\n /*/target/\n+.classpath\n+.settings\n+.project\n"
    },
    {
        "commit_hash": "29e14b2f72bee225d20c94fbf3f72c570fcbcf65",
        "previous_commit_hash": "101e1146d62b78beb0aa07285c1d3caf391ada5c",
        "diff_stats": {
            "additions": 0,
            "deletions": 84
        },
        "diff_content": "@@ -1,84 +0,0 @@\n-package net.orfjackal.retrolambda.maven;\n-\n-/*\n- * Copyright 2001-2005 The Apache Software Foundation.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-import org.apache.maven.plugin.AbstractMojo;\n-import org.apache.maven.plugin.MojoExecutionException;\n-\n-import org.apache.maven.plugins.annotations.LifecyclePhase;\n-import org.apache.maven.plugins.annotations.Mojo;\n-import org.apache.maven.plugins.annotations.Parameter;\n-import org.apache.maven.plugins.annotations.ResolutionScope;\n-\n-import java.io.File;\n-import java.io.FileWriter;\n-import java.io.IOException;\n-\n-/**\n- * Goal which touches a timestamp file.\n- *\n- * @deprecated Don't use!\n- */\n-@Mojo( name = \"touch\", defaultPhase = LifecyclePhase.PROCESS_SOURCES )\n-public class MyMojo\n-    extends AbstractMojo\n-{\n-    /**\n-     * Location of the file.\n-     */\n-    @Parameter( defaultValue = \"${project.build.directory}\", property = \"outputDir\", required = true )\n-    private File outputDirectory;\n-\n-    public void execute()\n-        throws MojoExecutionException\n-    {\n-        File f = outputDirectory;\n-\n-        if ( !f.exists() )\n-        {\n-            f.mkdirs();\n-        }\n-\n-        File touch = new File( f, \"touch.txt\" );\n-\n-        FileWriter w = null;\n-        try\n-        {\n-            w = new FileWriter( touch );\n-\n-            w.write( \"touch.txt\" );\n-        }\n-        catch ( IOException e )\n-        {\n-            throw new MojoExecutionException( \"Error creating file \" + touch, e );\n-        }\n-        finally\n-        {\n-            if ( w != null )\n-            {\n-                try\n-                {\n-                    w.close();\n-                }\n-                catch ( IOException e )\n-                {\n-                    // ignore\n-                }\n-            }\n-        }\n-    }\n-}\n"
    },
    {
        "commit_hash": "29e14b2f72bee225d20c94fbf3f72c570fcbcf65",
        "previous_commit_hash": "101e1146d62b78beb0aa07285c1d3caf391ada5c",
        "diff_stats": {
            "additions": 78,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,78 @@\n+package net.orfjackal.retrolambda.maven;\n+\n+/*\n+ * Copyright 2001-2005 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import static org.twdata.maven.mojoexecutor.MojoExecutor.artifactId;\n+import static org.twdata.maven.mojoexecutor.MojoExecutor.configuration;\n+import static org.twdata.maven.mojoexecutor.MojoExecutor.element;\n+import static org.twdata.maven.mojoexecutor.MojoExecutor.executeMojo;\n+import static org.twdata.maven.mojoexecutor.MojoExecutor.executionEnvironment;\n+import static org.twdata.maven.mojoexecutor.MojoExecutor.goal;\n+import static org.twdata.maven.mojoexecutor.MojoExecutor.groupId;\n+import static org.twdata.maven.mojoexecutor.MojoExecutor.name;\n+import static org.twdata.maven.mojoexecutor.MojoExecutor.plugin;\n+import static org.twdata.maven.mojoexecutor.MojoExecutor.version;\n+\n+import java.io.File;\n+\n+import org.apache.maven.execution.MavenSession;\n+import org.apache.maven.plugin.AbstractMojo;\n+import org.apache.maven.plugin.BuildPluginManager;\n+import org.apache.maven.plugin.MojoExecutionException;\n+import org.apache.maven.plugins.annotations.Component;\n+import org.apache.maven.plugins.annotations.LifecyclePhase;\n+import org.apache.maven.plugins.annotations.Mojo;\n+import org.apache.maven.plugins.annotations.Parameter;\n+import org.apache.maven.project.MavenProject;\n+\n+@Mojo(name = \"process\", defaultPhase = LifecyclePhase.PROCESS_CLASSES)\n+public class RetrolambdaMojo extends AbstractMojo {\n+\n+\t@Component\n+\tprivate MavenSession session;\n+\n+\t@Component\n+\tprivate BuildPluginManager pluginManager;\n+\n+\t@Component\n+\tprivate MavenProject project;\n+\n+\t/**\n+\t * Location of the file.\n+\t */\n+\t@Parameter(defaultValue = \"${project.build.directory}\", property = \"outputDir\", required = true)\n+\tprivate File outputDirectory;\n+\n+\tpublic void execute() throws MojoExecutionException {\n+\t\texecuteMojo(\n+\t\t\t\tplugin(groupId(\"org.apache.maven.plugins\"),\n+\t\t\t\t\t\tartifactId(\"maven-dependency-plugin\"), version(\"2.0\")),\n+\t\t\t\tgoal(\"copy\"),\n+\t\t\t\tconfiguration(element(\n+\t\t\t\t\t\t\"artifactItems\",\n+\t\t\t\t\t\telement(\"artifactItem\",\n+\t\t\t\t\t\t\t\telement(name(\"groupId\"),\n+\t\t\t\t\t\t\t\t\t\t\"net.orfjackal.retrolambda\"),\n+\t\t\t\t\t\t\t\telement(name(\"artifactId\"), \"retrolambda\"),\n+\t\t\t\t\t\t\t\telement(name(\"version\"), \"1.1.4\"),\n+\t\t\t\t\t\t\t\telement(name(\"overwrite\"), \"true\"),\n+\t\t\t\t\t\t\t\telement(name(\"outputDirectory\"), project\n+\t\t\t\t\t\t\t\t\t\t.getBuild().getOutputDirectory()),\n+\t\t\t\t\t\t\t\telement(name(\"destFileName\"), \"retrolambda.jar\")))),\n+\t\t\t\texecutionEnvironment(project, session, pluginManager));\n+\t}\n+}\n"
    },
    {
        "commit_hash": "ec3c55b307ed1738202459decd9026dbbdd009f0",
        "previous_commit_hash": "29e14b2f72bee225d20c94fbf3f72c570fcbcf65",
        "diff_stats": {
            "additions": 2,
            "deletions": 0
        },
        "diff_content": "@@ -18,6 +18,8 @@\n     <modules>\n         <module>parent</module>\n         <module>retrolambda</module>\n+\t\t<module>retrolambda-maven-plugin</module>\n+\t\t<module>retrolambda-maven-plugin-test</module>\n         <module>end-to-end-tests</module>\n     </modules>\n \n"
    },
    {
        "commit_hash": "ec3c55b307ed1738202459decd9026dbbdd009f0",
        "previous_commit_hash": "29e14b2f72bee225d20c94fbf3f72c570fcbcf65",
        "diff_stats": {
            "additions": 29,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,29 @@\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+\t<modelVersion>4.0.0</modelVersion>\n+\t<parent>\n+\t\t<groupId>net.orfjackal.retrolambda</groupId>\n+\t\t<artifactId>parent</artifactId>\n+\t\t<version>1.1.5-SNAPSHOT</version>\n+\t\t<relativePath>../parent/pom.xml</relativePath>\n+\t</parent>\n+\t<artifactId>retrolambda-maven-plugin-test</artifactId>\n+\t<packaging>jar</packaging>\n+\t<name>${project.artifactId}</name>\n+\t<build>\n+\t\t<plugins>\n+\t\t\t<plugin>\n+\t\t\t\t<groupId>net.orfjackal.retrolambda</groupId>\n+\t\t\t\t<artifactId>retrolambda-maven-plugin</artifactId>\n+\t\t\t\t<version>${project.parent.version}</version>\n+\t\t\t\t<executions>\n+\t\t\t\t\t<execution>\n+\t\t\t\t\t\t<goals>\n+\t\t\t\t\t\t\t<goal>process</goal>\n+\t\t\t\t\t\t</goals>\n+\t\t\t\t\t</execution>\n+\t\t\t\t</executions>\n+\t\t\t</plugin>\n+\t\t</plugins>\n+    </build>\n+</project>\n"
    },
    {
        "commit_hash": "ec3c55b307ed1738202459decd9026dbbdd009f0",
        "previous_commit_hash": "29e14b2f72bee225d20c94fbf3f72c570fcbcf65",
        "diff_stats": {
            "additions": 131,
            "deletions": 106
        },
        "diff_content": "@@ -1,116 +1,141 @@\n <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n-  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n-  <modelVersion>4.0.0</modelVersion>\n+\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+\t<modelVersion>4.0.0</modelVersion>\n+\t<parent>\n+\t\t<groupId>net.orfjackal.retrolambda</groupId>\n+\t\t<artifactId>parent</artifactId>\n+\t\t<version>1.1.5-SNAPSHOT</version>\n+\t\t<relativePath>../parent/pom.xml</relativePath>\n+\t</parent>\n+\t<artifactId>retrolambda-maven-plugin</artifactId>\n+\t<packaging>maven-plugin</packaging>\n \n-  <groupId>net.orfjackal.retrolambda</groupId>\n-  <artifactId>retrolambda-maven-plugin</artifactId>\n-  <version>1.1.5-SNAPSHOT</version>\n-  <packaging>maven-plugin</packaging>\n+\t<name>${project.artifactId}</name>\n \n-  <name>retrolambda-maven-plugin Maven Plugin</name>\n+\t<!-- FIXME change it to the project's website -->\n+\t<url>http://maven.apache.org</url>\n \n-  <!-- FIXME change it to the project's website -->\n-  <url>http://maven.apache.org</url>\n+\t<properties>\n+\t\t<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+\t</properties>\n \n-  <properties>\n-    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n-  </properties>\n+\t<dependencies>\n+\t\t<dependency>\n+\t\t\t<groupId>org.apache.maven</groupId>\n+\t\t\t<artifactId>maven-plugin-api</artifactId>\n+\t\t\t<version>2.0</version>\n+\t\t</dependency>\n+\t\t<dependency>\n+\t\t\t<groupId>org.apache.maven.plugin-tools</groupId>\n+\t\t\t<artifactId>maven-plugin-annotations</artifactId>\n+\t\t\t<version>3.2</version>\n+\t\t\t<scope>provided</scope>\n+\t\t</dependency>\n+\t\t<dependency>\n+\t\t\t<groupId>org.codehaus.plexus</groupId>\n+\t\t\t<artifactId>plexus-utils</artifactId>\n+\t\t\t<version>3.0.8</version>\n+\t\t</dependency>\n+\t\t<dependency>\n+\t\t\t<groupId>org.twdata.maven</groupId>\n+\t\t\t<artifactId>mojo-executor</artifactId>\n+\t\t\t<version>2.2.0</version>\n+\t\t</dependency>\n+\t\t<!-- this dep here only to ensure the build order -->\n+\t\t<!-- <dependency> <groupId>net.orfjackal.retrolambda</groupId> <artifactId>retrolambda</artifactId> \n+\t\t\t<version>${project.parent.version}</version> <scope>provided</scope> </dependency> -->\n+\t\t<dependency>\n+\t\t\t<groupId>junit</groupId>\n+\t\t\t<artifactId>junit</artifactId>\n+\t\t\t<scope>test</scope>\n+\t\t</dependency>\n \n-  <dependencies>\n-    <dependency>\n-      <groupId>org.apache.maven</groupId>\n-      <artifactId>maven-plugin-api</artifactId>\n-      <version>2.0</version>\n-    </dependency>\n-    <dependency>\n-      <groupId>org.apache.maven.plugin-tools</groupId>\n-      <artifactId>maven-plugin-annotations</artifactId>\n-      <version>3.2</version>\n-      <scope>provided</scope>\n-    </dependency>\n-    <dependency>\n-      <groupId>org.codehaus.plexus</groupId>\n-      <artifactId>plexus-utils</artifactId>\n-      <version>3.0.8</version>\n-    </dependency>\n-    <dependency>\n-      <groupId>org.twdata.maven</groupId>\n-      <artifactId>mojo-executor</artifactId>\n-      <version>2.2.0</version>\n-    </dependency>\n-    <dependency>\n-      <groupId>junit</groupId>\n-      <artifactId>junit</artifactId>\n-      <version>4.8.2</version>\n-      <scope>test</scope>\n-    </dependency>\n-  </dependencies>\n+\t</dependencies>\n \n-  <build>\n-    <plugins>\n-      <plugin>\n-        <groupId>org.apache.maven.plugins</groupId>\n-        <artifactId>maven-plugin-plugin</artifactId>\n-        <version>3.2</version>\n-        <configuration>\n-          <goalPrefix>retrolambda-maven-plugin</goalPrefix>\n-          <skipErrorNoDescriptorsFound>true</skipErrorNoDescriptorsFound>\n-        </configuration>\n-        <executions>\n-          <execution>\n-            <id>mojo-descriptor</id>\n-            <goals>\n-              <goal>descriptor</goal>\n-            </goals>\n-          </execution>\n-          <execution>\n-            <id>help-goal</id>\n-            <goals>\n-              <goal>helpmojo</goal>\n-            </goals>\n-          </execution>\n-        </executions>\n-      </plugin>\n-    </plugins>\n-  </build>\n-  <profiles>\n-    <profile>\n-      <id>run-its</id>\n-      <build>\n+\t<build>\n+\t\t<resources>\n+\t\t\t<resource>\n+\t\t\t\t<directory>src/main/resources</directory>\n+\t\t\t\t<filtering>true</filtering>\n+\t\t\t</resource>\n+\t\t</resources>\n+\t\t<plugins>\n+\t\t\t<plugin>\n+\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n+\t\t\t\t<artifactId>maven-compiler-plugin</artifactId>\n+\t\t\t\t<version>3.1</version>\n+\t\t\t\t<configuration>\n+\t\t\t\t\t<verbose>true</verbose>\n+\t\t\t\t\t<fork>true</fork>\n+\t\t\t\t\t<source>1.6</source>\n+\t\t\t\t\t<target>1.6</target>\n+\t\t\t\t</configuration>\n+\t\t\t</plugin>\n+\t\t\t<plugin>\n+\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n+\t\t\t\t<artifactId>maven-plugin-plugin</artifactId>\n+\t\t\t\t<version>3.2</version>\n+\t\t\t\t<configuration>\n+\t\t\t\t\t<goalPrefix>retrolambda</goalPrefix>\n+\t\t\t\t\t<skipErrorNoDescriptorsFound>true</skipErrorNoDescriptorsFound>\n+\t\t\t\t</configuration>\n+\t\t\t\t<executions>\n+\t\t\t\t\t<execution>\n+\t\t\t\t\t\t<id>mojo-descriptor</id>\n+\t\t\t\t\t\t<goals>\n+\t\t\t\t\t\t\t<goal>descriptor</goal>\n+\t\t\t\t\t\t</goals>\n+\t\t\t\t\t\t<phase>process-classes</phase>\n+\t\t\t\t\t</execution>\n+\t\t\t\t\t<execution>\n+\t\t\t\t\t\t<id>help-goal</id>\n+\t\t\t\t\t\t<goals>\n+\t\t\t\t\t\t\t<goal>helpmojo</goal>\n+\t\t\t\t\t\t</goals>\n+\t\t\t\t\t\t<phase>process-classes</phase>\n+\t\t\t\t\t</execution>\n+\t\t\t\t</executions>\n+\t\t\t</plugin>\n+\t\t</plugins>\n+\t</build>\n+\t<profiles>\n+\t\t<profile>\n+\t\t\t<id>run-its</id>\n+\t\t\t<build>\n \n-        <plugins>\n-          <plugin>\n-            <groupId>org.apache.maven.plugins</groupId>\n-            <artifactId>maven-invoker-plugin</artifactId>\n-            <version>1.7</version>\n-            <configuration>\n-              <debug>true</debug>\n-              <cloneProjectsTo>${project.build.directory}/it</cloneProjectsTo>\n-              <pomIncludes>\n-                <pomInclude>*/pom.xml</pomInclude>\n-              </pomIncludes>\n-              <postBuildHookScript>verify</postBuildHookScript>\n-              <localRepositoryPath>${project.build.directory}/local-repo</localRepositoryPath>\n-              <settingsFile>src/it/settings.xml</settingsFile>\n-              <goals>\n-                <goal>clean</goal>\n-                <goal>test-compile</goal>\n-              </goals>\n-            </configuration>\n-            <executions>\n-              <execution>\n-                <id>integration-test</id>\n-                <goals>\n-                  <goal>install</goal>\n-                  <goal>integration-test</goal>\n-                  <goal>verify</goal>\n-                </goals>\n-              </execution>\n-            </executions>\n-          </plugin>\n-        </plugins>\n+\t\t\t\t<plugins>\n+\t\t\t\t\t<plugin>\n+\t\t\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n+\t\t\t\t\t\t<artifactId>maven-invoker-plugin</artifactId>\n+\t\t\t\t\t\t<version>1.7</version>\n+\t\t\t\t\t\t<configuration>\n+\t\t\t\t\t\t\t<debug>true</debug>\n+\t\t\t\t\t\t\t<cloneProjectsTo>${project.build.directory}/it</cloneProjectsTo>\n+\t\t\t\t\t\t\t<pomIncludes>\n+\t\t\t\t\t\t\t\t<pomInclude>*/pom.xml</pomInclude>\n+\t\t\t\t\t\t\t</pomIncludes>\n+\t\t\t\t\t\t\t<postBuildHookScript>verify</postBuildHookScript>\n+\t\t\t\t\t\t\t<localRepositoryPath>${project.build.directory}/local-repo</localRepositoryPath>\n+\t\t\t\t\t\t\t<settingsFile>src/it/settings.xml</settingsFile>\n+\t\t\t\t\t\t\t<goals>\n+\t\t\t\t\t\t\t\t<goal>clean</goal>\n+\t\t\t\t\t\t\t\t<goal>test-compile</goal>\n+\t\t\t\t\t\t\t</goals>\n+\t\t\t\t\t\t</configuration>\n+\t\t\t\t\t\t<executions>\n+\t\t\t\t\t\t\t<execution>\n+\t\t\t\t\t\t\t\t<id>integration-test</id>\n+\t\t\t\t\t\t\t\t<goals>\n+\t\t\t\t\t\t\t\t\t<goal>install</goal>\n+\t\t\t\t\t\t\t\t\t<goal>integration-test</goal>\n+\t\t\t\t\t\t\t\t\t<goal>verify</goal>\n+\t\t\t\t\t\t\t\t</goals>\n+\t\t\t\t\t\t\t</execution>\n+\t\t\t\t\t\t</executions>\n+\t\t\t\t\t</plugin>\n+\t\t\t\t</plugins>\n \n-      </build>\n-    </profile>\n-  </profiles>\n+\t\t\t</build>\n+\t\t</profile>\n+\t</profiles>\n </project>\n"
    },
    {
        "commit_hash": "ec3c55b307ed1738202459decd9026dbbdd009f0",
        "previous_commit_hash": "29e14b2f72bee225d20c94fbf3f72c570fcbcf65",
        "diff_stats": {
            "additions": 23,
            "deletions": 3
        },
        "diff_content": "@@ -28,11 +28,15 @@ import static org.twdata.maven.mojoexecutor.MojoExecutor.plugin;\n import static org.twdata.maven.mojoexecutor.MojoExecutor.version;\n \n import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Properties;\n \n import org.apache.maven.execution.MavenSession;\n import org.apache.maven.plugin.AbstractMojo;\n import org.apache.maven.plugin.BuildPluginManager;\n import org.apache.maven.plugin.MojoExecutionException;\n+import org.apache.maven.plugin.logging.Log;\n import org.apache.maven.plugins.annotations.Component;\n import org.apache.maven.plugins.annotations.LifecyclePhase;\n import org.apache.maven.plugins.annotations.Mojo;\n@@ -57,7 +61,11 @@ public class RetrolambdaMojo extends AbstractMojo {\n \t@Parameter(defaultValue = \"${project.build.directory}\", property = \"outputDir\", required = true)\n \tprivate File outputDirectory;\n \n+\t@Override\n \tpublic void execute() throws MojoExecutionException {\n+\t\tLog log = getLog();\n+\t\tlog.info(\"starting execution\");\n+\t\tString retrolambdaVersion = getRetrolambdaVersion();\n \t\texecuteMojo(\n \t\t\t\tplugin(groupId(\"org.apache.maven.plugins\"),\n \t\t\t\t\t\tartifactId(\"maven-dependency-plugin\"), version(\"2.0\")),\n@@ -68,11 +76,23 @@ public class RetrolambdaMojo extends AbstractMojo {\n \t\t\t\t\t\t\t\telement(name(\"groupId\"),\n \t\t\t\t\t\t\t\t\t\t\"net.orfjackal.retrolambda\"),\n \t\t\t\t\t\t\t\telement(name(\"artifactId\"), \"retrolambda\"),\n-\t\t\t\t\t\t\t\telement(name(\"version\"), \"1.1.4\"),\n-\t\t\t\t\t\t\t\telement(name(\"overwrite\"), \"true\"),\n+\t\t\t\t\t\t\t\telement(name(\"version\"), retrolambdaVersion),\n+\t\t\t\t\t\t\t\telement(name(\"overWrite\"), \"true\"),\n \t\t\t\t\t\t\t\telement(name(\"outputDirectory\"), project\n-\t\t\t\t\t\t\t\t\t\t.getBuild().getOutputDirectory()),\n+\t\t\t\t\t\t\t\t\t\t.getBuild().getDirectory()),\n \t\t\t\t\t\t\t\telement(name(\"destFileName\"), \"retrolambda.jar\")))),\n \t\t\t\texecutionEnvironment(project, session, pluginManager));\n \t}\n+\n+\tprivate static String getRetrolambdaVersion() {\n+\t\tInputStream is = RetrolambdaMojo.class\n+\t\t\t\t.getResourceAsStream(\"/retrolambda.properties\");\n+\t\tProperties p = new Properties();\n+\t\ttry {\n+\t\t\tp.load(is);\n+\t\t\treturn p.getProperty(\"retrolambda.version\");\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n+\t}\n }\n"
    },
    {
        "commit_hash": "ec3c55b307ed1738202459decd9026dbbdd009f0",
        "previous_commit_hash": "29e14b2f72bee225d20c94fbf3f72c570fcbcf65",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1 @@\n+retrolambda.version=${project.version}\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "e2f7ad16cd5fb4e22c3b9fc8cdfb48d667bab0f9",
        "previous_commit_hash": "ec3c55b307ed1738202459decd9026dbbdd009f0",
        "diff_stats": {
            "additions": 7,
            "deletions": 1
        },
        "diff_content": "@@ -12,6 +12,12 @@\n \t<name>${project.artifactId}</name>\n \t<build>\n \t\t<plugins>\n+\t\t\t<plugin>\n+\t\t\t\t<artifactId>maven-deploy-plugin</artifactId>\n+\t\t\t\t<configuration>\n+\t\t\t\t\t<skip>true</skip>\n+\t\t\t\t</configuration>\n+\t\t\t</plugin>\n \t\t\t<plugin>\n \t\t\t\t<groupId>net.orfjackal.retrolambda</groupId>\n \t\t\t\t<artifactId>retrolambda-maven-plugin</artifactId>\n@@ -25,5 +31,5 @@\n \t\t\t\t</executions>\n \t\t\t</plugin>\n \t\t</plugins>\n-    </build>\n+\t</build>\n </project>\n"
    },
    {
        "commit_hash": "e2f7ad16cd5fb4e22c3b9fc8cdfb48d667bab0f9",
        "previous_commit_hash": "ec3c55b307ed1738202459decd9026dbbdd009f0",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,13 @@\n+package net.orfjackal.retrolambda;\n+\n+import java.util.function.Consumer;\n+\n+public class Example {\n+\n+\tpublic static void main(String[] args) {\n+\t\tConsumer<Integer> c = (Integer x) -> {\n+\t\t\tSystem.out.println(x);\n+\t\t};\n+\t\tc.accept(12);\n+\t}\n+}\n"
    },
    {
        "commit_hash": "e2f7ad16cd5fb4e22c3b9fc8cdfb48d667bab0f9",
        "previous_commit_hash": "ec3c55b307ed1738202459decd9026dbbdd009f0",
        "diff_stats": {
            "additions": 11,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,11 @@\n+package net.orfjackal.retrolambda;\n+\n+import org.junit.Test;\n+\n+public class ExampleTest {\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tExample.main(null);\n+\t}\n+}\n"
    },
    {
        "commit_hash": "e2f7ad16cd5fb4e22c3b9fc8cdfb48d667bab0f9",
        "previous_commit_hash": "ec3c55b307ed1738202459decd9026dbbdd009f0",
        "diff_stats": {
            "additions": 80,
            "deletions": 6
        },
        "diff_content": "@@ -17,6 +17,8 @@ package net.orfjackal.retrolambda.maven;\n  */\n \n import static org.twdata.maven.mojoexecutor.MojoExecutor.artifactId;\n+import static org.twdata.maven.mojoexecutor.MojoExecutor.attribute;\n+import static org.twdata.maven.mojoexecutor.MojoExecutor.attributes;\n import static org.twdata.maven.mojoexecutor.MojoExecutor.configuration;\n import static org.twdata.maven.mojoexecutor.MojoExecutor.element;\n import static org.twdata.maven.mojoexecutor.MojoExecutor.executeMojo;\n@@ -46,6 +48,8 @@ import org.apache.maven.project.MavenProject;\n @Mojo(name = \"process\", defaultPhase = LifecyclePhase.PROCESS_CLASSES)\n public class RetrolambdaMojo extends AbstractMojo {\n \n+\tprivate static final String RETROLAMBDA_JAR = \"retrolambda.jar\";\n+\n \t@Component\n \tprivate MavenSession session;\n \n@@ -55,11 +59,17 @@ public class RetrolambdaMojo extends AbstractMojo {\n \t@Component\n \tprivate MavenProject project;\n \n-\t/**\n-\t * Location of the file.\n-\t */\n-\t@Parameter(defaultValue = \"${project.build.directory}\", property = \"outputDir\", required = true)\n-\tprivate File outputDirectory;\n+\t@Parameter(required = false, property = \"java8home\")\n+\tprivate String java8home;\n+\n+\t@Parameter(required = false, property = \"bytecodeVersion\")\n+\tprivate String bytecodeVersion;\n+\n+\t@Parameter(required = false, property = \"retrolambdaInputDir\")\n+\tprivate String inputDir;\n+\n+\t@Parameter(required = false, property = \"retrolambdaInputTestDir\")\n+\tprivate String inputTestDir;\n \n \t@Override\n \tpublic void execute() throws MojoExecutionException {\n@@ -80,8 +90,72 @@ public class RetrolambdaMojo extends AbstractMojo {\n \t\t\t\t\t\t\t\telement(name(\"overWrite\"), \"true\"),\n \t\t\t\t\t\t\t\telement(name(\"outputDirectory\"), project\n \t\t\t\t\t\t\t\t\t\t.getBuild().getDirectory()),\n-\t\t\t\t\t\t\t\telement(name(\"destFileName\"), \"retrolambda.jar\")))),\n+\t\t\t\t\t\t\t\telement(name(\"destFileName\"), RETROLAMBDA_JAR)))),\n \t\t\t\texecutionEnvironment(project, session, pluginManager));\n+\t\tlog.info(\"copied retrolambda.jar to build directory\");\n+\n+\t\tif (inputDir == null)\n+\t\t\tinputDir = project.getBuild().getOutputDirectory();\n+\t\tif (inputTestDir == null)\n+\t\t\tinputTestDir = project.getBuild().getTestOutputDirectory();\n+\n+\t\t// process main classes\n+\t\tprocessClasses(inputDir, \"maven.compile.classpath\");\n+\n+\t\t// process test classes\n+\t\tprocessClasses(inputTestDir, \"maven.test.classpath\");\n+\n+\t}\n+\n+\tprivate void processClasses(String input, String classpathId)\n+\t\t\tthrows MojoExecutionException {\n+\t\tif (bytecodeVersion == null)\n+\t\t\tbytecodeVersion = \"51\";\n+\n+\t\texecuteMojo(\n+\t\t\t\tplugin(groupId(\"org.apache.maven.plugins\"),\n+\t\t\t\t\t\tartifactId(\"maven-antrun-plugin\"), version(\"1.7\")),\n+\t\t\t\tgoal(\"run\"),\n+\t\t\t\tconfiguration(element(\n+\t\t\t\t\t\t\"target\",\n+\t\t\t\t\t\telement(\"property\",\n+\t\t\t\t\t\t\t\tattributes(attribute(\"name\", \"the_classpath\"),\n+\t\t\t\t\t\t\t\t\t\tattribute(\"refid\", classpathId))),\n+\t\t\t\t\t\telement(\"exec\",\n+\t\t\t\t\t\t\t\tattributes(\n+\t\t\t\t\t\t\t\t\t\tattribute(\"executable\", java8home()\n+\t\t\t\t\t\t\t\t\t\t\t\t+ \"/bin/java\"),\n+\t\t\t\t\t\t\t\t\t\tattribute(\"failonerror\", \"true\")),\n+\t\t\t\t\t\t\t\telement(\"arg\",\n+\t\t\t\t\t\t\t\t\t\tattribute(\"value\",\n+\t\t\t\t\t\t\t\t\t\t\t\t\"-Dretrolambda.bytecodeVersion=\"\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ bytecodeVersion)),\n+\t\t\t\t\t\t\t\telement(\"arg\",\n+\t\t\t\t\t\t\t\t\t\tattribute(\"value\",\n+\t\t\t\t\t\t\t\t\t\t\t\t\"-Dretrolambda.inputDir=\"\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ input)),\n+\t\t\t\t\t\t\t\telement(\"arg\",\n+\t\t\t\t\t\t\t\t\t\tattribute(\"value\",\n+\t\t\t\t\t\t\t\t\t\t\t\t\"-Dretrolambda.classpath=${the_classpath}\")),\n+\t\t\t\t\t\t\t\telement(\"arg\",\n+\t\t\t\t\t\t\t\t\t\tattribute(\"value\", \"-javaagent:\"\n+\t\t\t\t\t\t\t\t\t\t\t\t+ project.getBuild()\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t.getDirectory() + \"/\"\n+\t\t\t\t\t\t\t\t\t\t\t\t+ RETROLAMBDA_JAR)),\n+\t\t\t\t\t\t\t\telement(\"arg\", attribute(\"value\", \"-jar\")),\n+\t\t\t\t\t\t\t\telement(\"arg\",\n+\t\t\t\t\t\t\t\t\t\tattribute(\"value\", project.getBuild()\n+\t\t\t\t\t\t\t\t\t\t\t\t.getDirectory()\n+\t\t\t\t\t\t\t\t\t\t\t\t+ \"/\"\n+\t\t\t\t\t\t\t\t\t\t\t\t+ RETROLAMBDA_JAR))))),\n+\t\t\t\texecutionEnvironment(project, session, pluginManager));\n+\t}\n+\n+\tprivate String java8home() {\n+\t\tif (java8home != null)\n+\t\t\treturn new File(java8home).getAbsolutePath();\n+\t\telse\n+\t\t\treturn System.getenv(\"JAVA8_HOME\");\n \t}\n \n \tprivate static String getRetrolambdaVersion() {\n"
    },
    {
        "commit_hash": "be8c3b3d4f4cf330f1417dd7a231939107042f93",
        "previous_commit_hash": "e2f7ad16cd5fb4e22c3b9fc8cdfb48d667bab0f9",
        "diff_stats": {
            "additions": 17,
            "deletions": 1
        },
        "diff_content": "@@ -47,7 +47,23 @@\n             </plugin>\n \n             <!-- Process our byte codes to make them run on Java 7 -->\n+\t\t\t<plugin>\n+\t\t\t\t<groupId>net.orfjackal.retrolambda</groupId>\n+\t\t\t\t<artifactId>retrolambda-maven-plugin</artifactId>\n+\t\t\t\t<version>${project.parent.version}</version>\n+\t\t\t\t<executions>\n+\t\t\t\t\t<execution>\n+\t\t\t\t\t\t<goals>\n+\t\t\t\t\t\t\t<goal>process-main</goal>\n+\t\t\t\t\t\t\t<goal>process-test</goal>\n+\t\t\t\t\t\t</goals>\n+\t\t\t\t\t</execution>\n+\t\t\t\t</executions>\n+\t\t\t</plugin>\n \n+\t<!-- alternatively, can use a call to the dependency plugin and antrun plugins for fine control of retrolambda parameters -->\n+    <!-- although optimally all such use should be through the maven plugin above. Request changes if you need them -->\n+\t<!--\n             <plugin>\n                 <artifactId>maven-dependency-plugin</artifactId>\n                 <executions>\n@@ -118,7 +134,7 @@\n                     </execution>\n                 </executions>\n             </plugin>\n-\n+-->\n         </plugins>\n     </build>\n \n"
    },
    {
        "commit_hash": "be8c3b3d4f4cf330f1417dd7a231939107042f93",
        "previous_commit_hash": "e2f7ad16cd5fb4e22c3b9fc8cdfb48d667bab0f9",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -283,12 +283,12 @@\n \n                 <plugin>\n                     <artifactId>maven-plugin-plugin</artifactId>\n-                    <version>3.1</version>\n+                    <version>3.2</version>\n                 </plugin>\n \n                 <plugin>\n                     <artifactId>maven-site-plugin</artifactId>\n-                    <version>3.1</version>\n+                    <version>3.3</version>\n                 </plugin>\n \n                 <plugin>\n"
    },
    {
        "commit_hash": "be8c3b3d4f4cf330f1417dd7a231939107042f93",
        "previous_commit_hash": "e2f7ad16cd5fb4e22c3b9fc8cdfb48d667bab0f9",
        "diff_stats": {
            "additions": 2,
            "deletions": 1
        },
        "diff_content": "@@ -25,7 +25,8 @@\n \t\t\t\t<executions>\n \t\t\t\t\t<execution>\n \t\t\t\t\t\t<goals>\n-\t\t\t\t\t\t\t<goal>process</goal>\n+\t\t\t\t\t\t\t<goal>process-main</goal>\n+\t\t\t\t\t\t\t<goal>process-test</goal>\n \t\t\t\t\t\t</goals>\n \t\t\t\t\t</execution>\n \t\t\t\t</executions>\n"
    },
    {
        "commit_hash": "be8c3b3d4f4cf330f1417dd7a231939107042f93",
        "previous_commit_hash": "e2f7ad16cd5fb4e22c3b9fc8cdfb48d667bab0f9",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-package net.orfjackal.retrolambda;\n+package net.orfjackal.retrolambda.test;\n \n import java.util.function.Consumer;\n \n"
    },
    {
        "commit_hash": "be8c3b3d4f4cf330f1417dd7a231939107042f93",
        "previous_commit_hash": "e2f7ad16cd5fb4e22c3b9fc8cdfb48d667bab0f9",
        "diff_stats": {
            "additions": 3,
            "deletions": 1
        },
        "diff_content": "@@ -1,4 +1,6 @@\n-package net.orfjackal.retrolambda;\n+package net.orfjackal.retrolambda.test;\n+\n+import net.orfjackal.retrolambda.test.Example;\n \n import org.junit.Test;\n \n"
    },
    {
        "commit_hash": "be8c3b3d4f4cf330f1417dd7a231939107042f93",
        "previous_commit_hash": "e2f7ad16cd5fb4e22c3b9fc8cdfb48d667bab0f9",
        "diff_stats": {
            "additions": 0,
            "deletions": 1
        },
        "diff_content": "@@ -63,7 +63,6 @@\n \t\t\t<plugin>\n \t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n \t\t\t\t<artifactId>maven-compiler-plugin</artifactId>\n-\t\t\t\t<version>3.1</version>\n \t\t\t\t<configuration>\n \t\t\t\t\t<verbose>true</verbose>\n \t\t\t\t\t<fork>true</fork>\n"
    },
    {
        "commit_hash": "be8c3b3d4f4cf330f1417dd7a231939107042f93",
        "previous_commit_hash": "e2f7ad16cd5fb4e22c3b9fc8cdfb48d667bab0f9",
        "diff_stats": {
            "additions": 5,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,5 @@\n+package net.orfjackal.retrolambda.maven;\n+\n+enum ClassesType {\n+\tMAIN, TEST;\n+}\n"
    },
    {
        "commit_hash": "be8c3b3d4f4cf330f1417dd7a231939107042f93",
        "previous_commit_hash": "e2f7ad16cd5fb4e22c3b9fc8cdfb48d667bab0f9",
        "diff_stats": {
            "additions": 33,
            "deletions": 53
        },
        "diff_content": "@@ -1,21 +1,5 @@\n package net.orfjackal.retrolambda.maven;\n \n-/*\n- * Copyright 2001-2005 The Apache Software Foundation.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n import static org.twdata.maven.mojoexecutor.MojoExecutor.artifactId;\n import static org.twdata.maven.mojoexecutor.MojoExecutor.attribute;\n import static org.twdata.maven.mojoexecutor.MojoExecutor.attributes;\n@@ -29,7 +13,6 @@ import static org.twdata.maven.mojoexecutor.MojoExecutor.name;\n import static org.twdata.maven.mojoexecutor.MojoExecutor.plugin;\n import static org.twdata.maven.mojoexecutor.MojoExecutor.version;\n \n-import java.io.File;\n import java.io.IOException;\n import java.io.InputStream;\n import java.util.Properties;\n@@ -40,16 +23,21 @@ import org.apache.maven.plugin.BuildPluginManager;\n import org.apache.maven.plugin.MojoExecutionException;\n import org.apache.maven.plugin.logging.Log;\n import org.apache.maven.plugins.annotations.Component;\n-import org.apache.maven.plugins.annotations.LifecyclePhase;\n-import org.apache.maven.plugins.annotations.Mojo;\n import org.apache.maven.plugins.annotations.Parameter;\n import org.apache.maven.project.MavenProject;\n \n-@Mojo(name = \"process\", defaultPhase = LifecyclePhase.PROCESS_CLASSES)\n-public class RetrolambdaMojo extends AbstractMojo {\n+abstract class ProcessClassesMojo extends AbstractMojo {\n+\n+\tprivate static final String VERSION_ANTRUN = \"1.7\";\n+\n+\tprivate static final String ARTIFACT_ID_ANTRUN = \"maven-antrun-plugin\";\n+\n+\tprivate static final String GROUP_ID_ANTRUN = \"org.apache.maven.plugins\";\n \n \tprivate static final String RETROLAMBDA_JAR = \"retrolambda.jar\";\n \n+\tprivate static final int DEFAULT_BYTE_CODE_VERSION = 51;\n+\n \t@Component\n \tprivate MavenSession session;\n \n@@ -59,17 +47,24 @@ public class RetrolambdaMojo extends AbstractMojo {\n \t@Component\n \tprivate MavenProject project;\n \n-\t@Parameter(required = false, property = \"java8home\")\n+\t@Parameter(required = false, property = \"java8home\", defaultValue = \"${env.JAVA8_HOME}\")\n \tprivate String java8home;\n \n-\t@Parameter(required = false, property = \"bytecodeVersion\")\n+\t@Parameter(required = false, property = \"bytecodeVersion\", defaultValue = DEFAULT_BYTE_CODE_VERSION\n+\t\t\t+ \"\")\n \tprivate String bytecodeVersion;\n \n-\t@Parameter(required = false, property = \"retrolambdaInputDir\")\n-\tprivate String inputDir;\n+\t@Parameter(required = false, property = \"retrolambdaMainClassesDir\", defaultValue = \"${project.build.outputDirectory}\")\n+\tprivate String mainClassesDir;\n+\n+\t@Parameter(required = false, property = \"retrolambdaTestClassesDir\", defaultValue = \"${project.build.testOutputDirectory}\")\n+\tprivate String testClassesDir;\n \n-\t@Parameter(required = false, property = \"retrolambdaInputTestDir\")\n-\tprivate String inputTestDir;\n+\tprivate final ClassesType classesType;\n+\n+\tProcessClassesMojo(ClassesType classesType) {\n+\t\tthis.classesType = classesType;\n+\t}\n \n \t@Override\n \tpublic void execute() throws MojoExecutionException {\n@@ -77,7 +72,7 @@ public class RetrolambdaMojo extends AbstractMojo {\n \t\tlog.info(\"starting execution\");\n \t\tString retrolambdaVersion = getRetrolambdaVersion();\n \t\texecuteMojo(\n-\t\t\t\tplugin(groupId(\"org.apache.maven.plugins\"),\n+\t\t\t\tplugin(groupId(GROUP_ID_ANTRUN),\n \t\t\t\t\t\tartifactId(\"maven-dependency-plugin\"), version(\"2.0\")),\n \t\t\t\tgoal(\"copy\"),\n \t\t\t\tconfiguration(element(\n@@ -93,28 +88,20 @@ public class RetrolambdaMojo extends AbstractMojo {\n \t\t\t\t\t\t\t\telement(name(\"destFileName\"), RETROLAMBDA_JAR)))),\n \t\t\t\texecutionEnvironment(project, session, pluginManager));\n \t\tlog.info(\"copied retrolambda.jar to build directory\");\n-\n-\t\tif (inputDir == null)\n-\t\t\tinputDir = project.getBuild().getOutputDirectory();\n-\t\tif (inputTestDir == null)\n-\t\t\tinputTestDir = project.getBuild().getTestOutputDirectory();\n-\n-\t\t// process main classes\n-\t\tprocessClasses(inputDir, \"maven.compile.classpath\");\n-\n-\t\t// process test classes\n-\t\tprocessClasses(inputTestDir, \"maven.test.classpath\");\n-\n+\t\tlog.info(\"processing classes\");\n+\t\tif (classesType == ClassesType.MAIN)\n+\t\t\tprocessClasses(mainClassesDir, \"maven.compile.classpath\");\n+\t\telse\n+\t\t\tprocessClasses(testClassesDir, \"maven.test.classpath\");\n+\t\tlog.info(\"processed classes\");\n \t}\n \n \tprivate void processClasses(String input, String classpathId)\n \t\t\tthrows MojoExecutionException {\n-\t\tif (bytecodeVersion == null)\n-\t\t\tbytecodeVersion = \"51\";\n \n \t\texecuteMojo(\n-\t\t\t\tplugin(groupId(\"org.apache.maven.plugins\"),\n-\t\t\t\t\t\tartifactId(\"maven-antrun-plugin\"), version(\"1.7\")),\n+\t\t\t\tplugin(groupId(GROUP_ID_ANTRUN),\n+\t\t\t\t\t\tartifactId(ARTIFACT_ID_ANTRUN), version(VERSION_ANTRUN)),\n \t\t\t\tgoal(\"run\"),\n \t\t\t\tconfiguration(element(\n \t\t\t\t\t\t\"target\",\n@@ -123,7 +110,7 @@ public class RetrolambdaMojo extends AbstractMojo {\n \t\t\t\t\t\t\t\t\t\tattribute(\"refid\", classpathId))),\n \t\t\t\t\t\telement(\"exec\",\n \t\t\t\t\t\t\t\tattributes(\n-\t\t\t\t\t\t\t\t\t\tattribute(\"executable\", java8home()\n+\t\t\t\t\t\t\t\t\t\tattribute(\"executable\", java8home\n \t\t\t\t\t\t\t\t\t\t\t\t+ \"/bin/java\"),\n \t\t\t\t\t\t\t\t\t\tattribute(\"failonerror\", \"true\")),\n \t\t\t\t\t\t\t\telement(\"arg\",\n@@ -151,15 +138,8 @@ public class RetrolambdaMojo extends AbstractMojo {\n \t\t\t\texecutionEnvironment(project, session, pluginManager));\n \t}\n \n-\tprivate String java8home() {\n-\t\tif (java8home != null)\n-\t\t\treturn new File(java8home).getAbsolutePath();\n-\t\telse\n-\t\t\treturn System.getenv(\"JAVA8_HOME\");\n-\t}\n-\n \tprivate static String getRetrolambdaVersion() {\n-\t\tInputStream is = RetrolambdaMojo.class\n+\t\tInputStream is = ProcessClassesMojo.class\n \t\t\t\t.getResourceAsStream(\"/retrolambda.properties\");\n \t\tProperties p = new Properties();\n \t\ttry {\n"
    },
    {
        "commit_hash": "be8c3b3d4f4cf330f1417dd7a231939107042f93",
        "previous_commit_hash": "e2f7ad16cd5fb4e22c3b9fc8cdfb48d667bab0f9",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,13 @@\n+package net.orfjackal.retrolambda.maven;\n+\n+import org.apache.maven.plugins.annotations.LifecyclePhase;\n+import org.apache.maven.plugins.annotations.Mojo;\n+\n+@Mojo(name = \"process-main\", defaultPhase = LifecyclePhase.PROCESS_CLASSES)\n+public class ProcessMainClassesMojo extends ProcessClassesMojo {\n+\n+\tpublic ProcessMainClassesMojo() {\n+\t\tsuper(ClassesType.MAIN);\n+\t}\n+\n+}\n"
    },
    {
        "commit_hash": "be8c3b3d4f4cf330f1417dd7a231939107042f93",
        "previous_commit_hash": "e2f7ad16cd5fb4e22c3b9fc8cdfb48d667bab0f9",
        "diff_stats": {
            "additions": 12,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,12 @@\n+package net.orfjackal.retrolambda.maven;\n+\n+import org.apache.maven.plugins.annotations.LifecyclePhase;\n+import org.apache.maven.plugins.annotations.Mojo;\n+\n+@Mojo(name = \"process-test\", defaultPhase = LifecyclePhase.PROCESS_TEST_CLASSES)\n+public class ProcessTestClassesMojo extends ProcessClassesMojo {\n+\n+\tpublic ProcessTestClassesMojo() {\n+\t\tsuper(ClassesType.TEST);\n+\t}\n+}\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "92a4a83ac6e7c05bc3b263debf75516658691bc2",
        "previous_commit_hash": "be8c3b3d4f4cf330f1417dd7a231939107042f93",
        "diff_stats": {
            "additions": 27,
            "deletions": 7
        },
        "diff_content": "@@ -12,13 +12,16 @@\n \n \t<name>${project.artifactId}</name>\n \n-\t<!-- FIXME change it to the project's website -->\n-\t<url>http://maven.apache.org</url>\n+\t<url>https://github.com/orfjackal/retrolambda</url>\n \n \t<properties>\n \t\t<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n \t</properties>\n \n+\t<prerequisites>\n+\t\t<maven>${minimumMavenVersion}</maven>\n+\t</prerequisites>\n+\n \t<dependencies>\n \t\t<dependency>\n \t\t\t<groupId>org.apache.maven</groupId>\n@@ -41,9 +44,6 @@\n \t\t\t<artifactId>mojo-executor</artifactId>\n \t\t\t<version>2.2.0</version>\n \t\t</dependency>\n-\t\t<!-- this dep here only to ensure the build order -->\n-\t\t<!-- <dependency> <groupId>net.orfjackal.retrolambda</groupId> <artifactId>retrolambda</artifactId> \n-\t\t\t<version>${project.parent.version}</version> <scope>provided</scope> </dependency> -->\n \t\t<dependency>\n \t\t\t<groupId>junit</groupId>\n \t\t\t<artifactId>junit</artifactId>\n@@ -95,13 +95,34 @@\n \t\t\t\t\t</execution>\n \t\t\t\t</executions>\n \t\t\t</plugin>\n+\t\t\t<plugin>\n+\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n+\t\t\t\t<artifactId>maven-site-plugin</artifactId>\n+\t\t\t\t<version>3.3</version>\n+\t\t\t\t<executions>\n+\t\t\t\t\t<execution>\n+\t\t\t\t\t\t<id>attach-descriptor</id>\n+\t\t\t\t\t\t<goals>\n+\t\t\t\t\t\t\t<goal>attach-descriptor</goal>\n+\t\t\t\t\t\t</goals>\n+\t\t\t\t\t</execution>\n+\t\t\t\t</executions>\n+\t\t\t\t<configuration>\n+\t\t\t\t\t<reportPlugins>\n+\t\t\t\t\t\t<plugin>\n+\t\t\t\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n+\t\t\t\t\t\t\t<artifactId>maven-plugin-plugin</artifactId>\n+\t\t\t\t\t\t\t<version>3.2</version>\n+\t\t\t\t\t\t</plugin>\n+\t\t\t\t\t</reportPlugins>\n+\t\t\t\t</configuration>\n+\t\t\t</plugin>\n \t\t</plugins>\n \t</build>\n \t<profiles>\n \t\t<profile>\n \t\t\t<id>run-its</id>\n \t\t\t<build>\n-\n \t\t\t\t<plugins>\n \t\t\t\t\t<plugin>\n \t\t\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n@@ -133,7 +154,6 @@\n \t\t\t\t\t\t</executions>\n \t\t\t\t\t</plugin>\n \t\t\t\t</plugins>\n-\n \t\t\t</build>\n \t\t</profile>\n \t</profiles>\n"
    },
    {
        "commit_hash": "92a4a83ac6e7c05bc3b263debf75516658691bc2",
        "previous_commit_hash": "be8c3b3d4f4cf330f1417dd7a231939107042f93",
        "diff_stats": {
            "additions": 22,
            "deletions": 0
        },
        "diff_content": "@@ -47,21 +47,43 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n \t@Component\n \tprivate MavenProject project;\n \n+\t/**\n+\t * The location of the java 8 jdk (not jre).\n+\t */\n \t@Parameter(required = false, property = \"java8home\", defaultValue = \"${env.JAVA8_HOME}\")\n \tprivate String java8home;\n \n+\t/**\n+\t * The version of the bytecode to be produced by retrolamda. Defaults to 51\n+\t * which is java 7 compatible bytecode.\n+\t */\n \t@Parameter(required = false, property = \"bytecodeVersion\", defaultValue = DEFAULT_BYTE_CODE_VERSION\n \t\t\t+ \"\")\n \tprivate String bytecodeVersion;\n \n+\t/**\n+\t * The directory containing the main (non-test) compiled classes. These\n+\t * classes will be overwritten with bytecode changes to obtain compatibility\n+\t * with java 7 runtime.\n+\t */\n \t@Parameter(required = false, property = \"retrolambdaMainClassesDir\", defaultValue = \"${project.build.outputDirectory}\")\n \tprivate String mainClassesDir;\n \n+\t/**\n+\t * The directory containing the compiled test classes. These classes will be\n+\t * overwritten with bytecode changes to obtain compatibility with java 7\n+\t * runtime.\n+\t */\n \t@Parameter(required = false, property = \"retrolambdaTestClassesDir\", defaultValue = \"${project.build.testOutputDirectory}\")\n \tprivate String testClassesDir;\n \n \tprivate final ClassesType classesType;\n \n+\t/**\n+\t * Constructor.\n+\t * \n+\t * @param classesType\n+\t */\n \tProcessClassesMojo(ClassesType classesType) {\n \t\tthis.classesType = classesType;\n \t}\n"
    },
    {
        "commit_hash": "92a4a83ac6e7c05bc3b263debf75516658691bc2",
        "previous_commit_hash": "be8c3b3d4f4cf330f1417dd7a231939107042f93",
        "diff_stats": {
            "additions": 4,
            "deletions": 0
        },
        "diff_content": "@@ -3,6 +3,10 @@ package net.orfjackal.retrolambda.maven;\n import org.apache.maven.plugins.annotations.LifecyclePhase;\n import org.apache.maven.plugins.annotations.Mojo;\n \n+/**\n+ * Processes main (non-test) classes compiled with java 8 so that they are\n+ * compatible with java 7 runtime.\n+ */\n @Mojo(name = \"process-main\", defaultPhase = LifecyclePhase.PROCESS_CLASSES)\n public class ProcessMainClassesMojo extends ProcessClassesMojo {\n \n"
    },
    {
        "commit_hash": "92a4a83ac6e7c05bc3b263debf75516658691bc2",
        "previous_commit_hash": "be8c3b3d4f4cf330f1417dd7a231939107042f93",
        "diff_stats": {
            "additions": 4,
            "deletions": 0
        },
        "diff_content": "@@ -3,6 +3,10 @@ package net.orfjackal.retrolambda.maven;\n import org.apache.maven.plugins.annotations.LifecyclePhase;\n import org.apache.maven.plugins.annotations.Mojo;\n \n+/**\n+ * Processes test classes compiled with java 8 so that they are compatible with\n+ * java 7 runtime.\n+ */\n @Mojo(name = \"process-test\", defaultPhase = LifecyclePhase.PROCESS_TEST_CLASSES)\n public class ProcessTestClassesMojo extends ProcessClassesMojo {\n \n"
    },
    {
        "commit_hash": "f5807dec9c1488d52a1bb0a8ec15a83ce6adc7ec",
        "previous_commit_hash": "92a4a83ac6e7c05bc3b263debf75516658691bc2",
        "diff_stats": {
            "additions": 0,
            "deletions": 1
        },
        "diff_content": "@@ -19,7 +19,6 @@\n         <module>parent</module>\n         <module>retrolambda</module>\n \t\t<module>retrolambda-maven-plugin</module>\n-\t\t<module>retrolambda-maven-plugin-test</module>\n         <module>end-to-end-tests</module>\n     </modules>\n \n"
    },
    {
        "commit_hash": "f5807dec9c1488d52a1bb0a8ec15a83ce6adc7ec",
        "previous_commit_hash": "92a4a83ac6e7c05bc3b263debf75516658691bc2",
        "diff_stats": {
            "additions": 0,
            "deletions": 36
        },
        "diff_content": "@@ -1,36 +0,0 @@\n-<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n-\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n-\t<modelVersion>4.0.0</modelVersion>\n-\t<parent>\n-\t\t<groupId>net.orfjackal.retrolambda</groupId>\n-\t\t<artifactId>parent</artifactId>\n-\t\t<version>1.1.5-SNAPSHOT</version>\n-\t\t<relativePath>../parent/pom.xml</relativePath>\n-\t</parent>\n-\t<artifactId>retrolambda-maven-plugin-test</artifactId>\n-\t<packaging>jar</packaging>\n-\t<name>${project.artifactId}</name>\n-\t<build>\n-\t\t<plugins>\n-\t\t\t<plugin>\n-\t\t\t\t<artifactId>maven-deploy-plugin</artifactId>\n-\t\t\t\t<configuration>\n-\t\t\t\t\t<skip>true</skip>\n-\t\t\t\t</configuration>\n-\t\t\t</plugin>\n-\t\t\t<plugin>\n-\t\t\t\t<groupId>net.orfjackal.retrolambda</groupId>\n-\t\t\t\t<artifactId>retrolambda-maven-plugin</artifactId>\n-\t\t\t\t<version>${project.parent.version}</version>\n-\t\t\t\t<executions>\n-\t\t\t\t\t<execution>\n-\t\t\t\t\t\t<goals>\n-\t\t\t\t\t\t\t<goal>process-main</goal>\n-\t\t\t\t\t\t\t<goal>process-test</goal>\n-\t\t\t\t\t\t</goals>\n-\t\t\t\t\t</execution>\n-\t\t\t\t</executions>\n-\t\t\t</plugin>\n-\t\t</plugins>\n-\t</build>\n-</project>\n"
    },
    {
        "commit_hash": "f5807dec9c1488d52a1bb0a8ec15a83ce6adc7ec",
        "previous_commit_hash": "92a4a83ac6e7c05bc3b263debf75516658691bc2",
        "diff_stats": {
            "additions": 0,
            "deletions": 13
        },
        "diff_content": "@@ -1,13 +0,0 @@\n-package net.orfjackal.retrolambda.test;\n-\n-import java.util.function.Consumer;\n-\n-public class Example {\n-\n-\tpublic static void main(String[] args) {\n-\t\tConsumer<Integer> c = (Integer x) -> {\n-\t\t\tSystem.out.println(x);\n-\t\t};\n-\t\tc.accept(12);\n-\t}\n-}\n"
    },
    {
        "commit_hash": "f5807dec9c1488d52a1bb0a8ec15a83ce6adc7ec",
        "previous_commit_hash": "92a4a83ac6e7c05bc3b263debf75516658691bc2",
        "diff_stats": {
            "additions": 0,
            "deletions": 13
        },
        "diff_content": "@@ -1,13 +0,0 @@\n-package net.orfjackal.retrolambda.test;\n-\n-import net.orfjackal.retrolambda.test.Example;\n-\n-import org.junit.Test;\n-\n-public class ExampleTest {\n-\n-\t@Test\n-\tpublic void test() {\n-\t\tExample.main(null);\n-\t}\n-}\n"
    },
    {
        "commit_hash": "a7588bbb99991bdc46097f6685b2dbb4e7ff1dc1",
        "previous_commit_hash": "f5807dec9c1488d52a1bb0a8ec15a83ce6adc7ec",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -62,7 +62,7 @@\n \t\t\t</plugin>\n \n \t<!-- alternatively, can use a call to the dependency plugin and antrun plugins for fine control of retrolambda parameters -->\n-    <!-- although optimally all such use should be through the maven plugin above. Request changes if you need them -->\n+    <!-- although optimally all such use should be through the maven plugin above. Request changes if you need them! -->\n \t<!--\n             <plugin>\n                 <artifactId>maven-dependency-plugin</artifactId>\n"
    },
    {
        "commit_hash": "e62479c6cae97cb3404323389d6ef8a18d750514",
        "previous_commit_hash": "a7588bbb99991bdc46097f6685b2dbb4e7ff1dc1",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -63,6 +63,7 @@\n \n \t<!-- alternatively, can use a call to the dependency plugin and antrun plugins for fine control of retrolambda parameters -->\n     <!-- although optimally all such use should be through the maven plugin above. Request changes if you need them! -->\n+\t<!-- if people are happy we could delete this block now -->\n \t<!--\n             <plugin>\n                 <artifactId>maven-dependency-plugin</artifactId>\n"
    },
    {
        "commit_hash": "e62479c6cae97cb3404323389d6ef8a18d750514",
        "previous_commit_hash": "a7588bbb99991bdc46097f6685b2dbb4e7ff1dc1",
        "diff_stats": {
            "additions": 0,
            "deletions": 5
        },
        "diff_content": "@@ -44,11 +44,6 @@\n \t\t\t<artifactId>mojo-executor</artifactId>\n \t\t\t<version>2.2.0</version>\n \t\t</dependency>\n-\t\t<dependency>\n-\t\t\t<groupId>junit</groupId>\n-\t\t\t<artifactId>junit</artifactId>\n-\t\t\t<scope>test</scope>\n-\t\t</dependency>\n \n \t</dependencies>\n \n"
    },
    {
        "commit_hash": "152cc18d32a4c383d9fa612881f2b96c32635082",
        "previous_commit_hash": "e62479c6cae97cb3404323389d6ef8a18d750514",
        "diff_stats": {
            "additions": 0,
            "deletions": 2
        },
        "diff_content": "@@ -68,7 +68,6 @@\n \t\t\t<plugin>\n \t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n \t\t\t\t<artifactId>maven-plugin-plugin</artifactId>\n-\t\t\t\t<version>3.2</version>\n \t\t\t\t<configuration>\n \t\t\t\t\t<goalPrefix>retrolambda</goalPrefix>\n \t\t\t\t\t<skipErrorNoDescriptorsFound>true</skipErrorNoDescriptorsFound>\n@@ -93,7 +92,6 @@\n \t\t\t<plugin>\n \t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n \t\t\t\t<artifactId>maven-site-plugin</artifactId>\n-\t\t\t\t<version>3.3</version>\n \t\t\t\t<executions>\n \t\t\t\t\t<execution>\n \t\t\t\t\t\t<id>attach-descriptor</id>\n"
    },
    {
        "commit_hash": "e4a889a1ee31f1c1fddcc1c5a71cd3073cecf5d8",
        "previous_commit_hash": "152cc18d32a4c383d9fa612881f2b96c32635082",
        "diff_stats": {
            "additions": 23,
            "deletions": 6
        },
        "diff_content": "@@ -66,16 +66,33 @@ Optional system properties:\n       Output directory into where the generated class files are written.\n       Defaults to same as retrolambda.inputDir\n ```\n+### Maven plugin\n+To run Retrolambda using Maven add the following to your pom.xml:\n+```xml\n+<build>\n+  <plugins>\n+    ...\n+    <plugin>\n+      <groupId>net.orfjackal.retrolambda</groupId>\n+      <artifactId>retrolambda-maven-plugin</artifactId>\n+      <version>0.1.15-SNAPSHOT</version>\n+      <executions>\n+        <execution>\n+          <goals>\n+            <goal>process-main</goal>\n+            <goal>process-test</goal>\n+          </goals>\n+        </execution>\n+      </executions>\n+    </plugin>\n+    ...\n+```\n+See [end-to-end-tests/pom.xml](https://github.com/orfjackal/retrolambda/blob/master/end-to-end-tests/pom.xml) for an example.\n \n+Plugin documentation is [here](). (TODO decide where to put the site report)\n \n ### Tips\n \n-For an example of how to run Retrolambda using Maven, see how\n-maven-dependency-plugin and maven-antrun-plugin are used in\n-[end-to-end-tests/pom.xml](https://github.com/orfjackal/retrolambda/blob/master/end-to-end-tests/pom.xml)\n-There isn't yet a Maven plugin for doing that with less boilerplate, but maybe\n-later.\n-\n During development, inside an IDE, it's the easiest to use Java 8, without\n Retrolamba, to compile and run tests. But in your continuous integration build\n you should run tests using the target Java version. For example, you can\n"
    },
    {
        "commit_hash": "40985c0c0f5ac4874095a8b28532464e6a8800fd",
        "previous_commit_hash": "e4a889a1ee31f1c1fddcc1c5a71cd3073cecf5d8",
        "diff_stats": {
            "additions": 10,
            "deletions": 0
        },
        "diff_content": "@@ -13,6 +13,7 @@ import static org.twdata.maven.mojoexecutor.MojoExecutor.name;\n import static org.twdata.maven.mojoexecutor.MojoExecutor.plugin;\n import static org.twdata.maven.mojoexecutor.MojoExecutor.version;\n \n+import java.io.File;\n import java.io.IOException;\n import java.io.InputStream;\n import java.util.Properties;\n@@ -92,6 +93,7 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n \tpublic void execute() throws MojoExecutionException {\n \t\tLog log = getLog();\n \t\tlog.info(\"starting execution\");\n+\t\tvalidateJava8home();\n \t\tString retrolambdaVersion = getRetrolambdaVersion();\n \t\texecuteMojo(\n \t\t\t\tplugin(groupId(GROUP_ID_ANTRUN),\n@@ -118,6 +120,14 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n \t\tlog.info(\"processed classes\");\n \t}\n \n+\tprivate void validateJava8home() throws MojoExecutionException {\n+\t\tFile jdk = new File(java8home);\n+\t\tif (!jdk.exists() || !jdk.isDirectory()) {\n+\t\t\tthrow new MojoExecutionException(\n+\t\t\t\t\t\"must set configuration element java8home or environment variable JAVA8_HOME to a valid jdk location\");\n+\t\t}\n+\t}\n+\n \tprivate void processClasses(String input, String classpathId)\n \t\t\tthrows MojoExecutionException {\n \n"
    },
    {
        "commit_hash": "28341bbed6f6210ed12cc9f1af84ca21919a2c31",
        "previous_commit_hash": "40985c0c0f5ac4874095a8b28532464e6a8800fd",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -124,7 +124,7 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n \t\tFile jdk = new File(java8home);\n \t\tif (!jdk.exists() || !jdk.isDirectory()) {\n \t\t\tthrow new MojoExecutionException(\n-\t\t\t\t\t\"must set configuration element java8home or environment variable JAVA8_HOME to a valid jdk location\");\n+\t\t\t\t\t\"must set configuration element java8home or environment variable JAVA8_HOME to a valid jdk 8 location\");\n \t\t}\n \t}\n \n"
    },
    {
        "commit_hash": "8be3092acf40c2f4c8f2e85cf6319508e2e17551",
        "previous_commit_hash": "28341bbed6f6210ed12cc9f1af84ca21919a2c31",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -1,5 +1,5 @@\n package net.orfjackal.retrolambda.maven;\n \n enum ClassesType {\n-\tMAIN, TEST;\n+    MAIN, TEST;\n }\n"
    },
    {
        "commit_hash": "8be3092acf40c2f4c8f2e85cf6319508e2e17551",
        "previous_commit_hash": "28341bbed6f6210ed12cc9f1af84ca21919a2c31",
        "diff_stats": {
            "additions": 140,
            "deletions": 152
        },
        "diff_content": "@@ -29,156 +29,144 @@ import org.apache.maven.project.MavenProject;\n \n abstract class ProcessClassesMojo extends AbstractMojo {\n \n-\tprivate static final String VERSION_ANTRUN = \"1.7\";\n-\n-\tprivate static final String ARTIFACT_ID_ANTRUN = \"maven-antrun-plugin\";\n-\n-\tprivate static final String GROUP_ID_ANTRUN = \"org.apache.maven.plugins\";\n-\n-\tprivate static final String RETROLAMBDA_JAR = \"retrolambda.jar\";\n-\n-\tprivate static final int DEFAULT_BYTE_CODE_VERSION = 51;\n-\n-\t@Component\n-\tprivate MavenSession session;\n-\n-\t@Component\n-\tprivate BuildPluginManager pluginManager;\n-\n-\t@Component\n-\tprivate MavenProject project;\n-\n-\t/**\n-\t * The location of the java 8 jdk (not jre).\n-\t */\n-\t@Parameter(required = false, property = \"java8home\", defaultValue = \"${env.JAVA8_HOME}\")\n-\tprivate String java8home;\n-\n-\t/**\n-\t * The version of the bytecode to be produced by retrolamda. Defaults to 51\n-\t * which is java 7 compatible bytecode.\n-\t */\n-\t@Parameter(required = false, property = \"bytecodeVersion\", defaultValue = DEFAULT_BYTE_CODE_VERSION\n-\t\t\t+ \"\")\n-\tprivate String bytecodeVersion;\n-\n-\t/**\n-\t * The directory containing the main (non-test) compiled classes. These\n-\t * classes will be overwritten with bytecode changes to obtain compatibility\n-\t * with java 7 runtime.\n-\t */\n-\t@Parameter(required = false, property = \"retrolambdaMainClassesDir\", defaultValue = \"${project.build.outputDirectory}\")\n-\tprivate String mainClassesDir;\n-\n-\t/**\n-\t * The directory containing the compiled test classes. These classes will be\n-\t * overwritten with bytecode changes to obtain compatibility with java 7\n-\t * runtime.\n-\t */\n-\t@Parameter(required = false, property = \"retrolambdaTestClassesDir\", defaultValue = \"${project.build.testOutputDirectory}\")\n-\tprivate String testClassesDir;\n-\n-\tprivate final ClassesType classesType;\n-\n-\t/**\n-\t * Constructor.\n-\t * \n-\t * @param classesType\n-\t */\n-\tProcessClassesMojo(ClassesType classesType) {\n-\t\tthis.classesType = classesType;\n-\t}\n-\n-\t@Override\n-\tpublic void execute() throws MojoExecutionException {\n-\t\tLog log = getLog();\n-\t\tlog.info(\"starting execution\");\n-\t\tvalidateJava8home();\n-\t\tString retrolambdaVersion = getRetrolambdaVersion();\n-\t\texecuteMojo(\n-\t\t\t\tplugin(groupId(GROUP_ID_ANTRUN),\n-\t\t\t\t\t\tartifactId(\"maven-dependency-plugin\"), version(\"2.0\")),\n-\t\t\t\tgoal(\"copy\"),\n-\t\t\t\tconfiguration(element(\n-\t\t\t\t\t\t\"artifactItems\",\n-\t\t\t\t\t\telement(\"artifactItem\",\n-\t\t\t\t\t\t\t\telement(name(\"groupId\"),\n-\t\t\t\t\t\t\t\t\t\t\"net.orfjackal.retrolambda\"),\n-\t\t\t\t\t\t\t\telement(name(\"artifactId\"), \"retrolambda\"),\n-\t\t\t\t\t\t\t\telement(name(\"version\"), retrolambdaVersion),\n-\t\t\t\t\t\t\t\telement(name(\"overWrite\"), \"true\"),\n-\t\t\t\t\t\t\t\telement(name(\"outputDirectory\"), project\n-\t\t\t\t\t\t\t\t\t\t.getBuild().getDirectory()),\n-\t\t\t\t\t\t\t\telement(name(\"destFileName\"), RETROLAMBDA_JAR)))),\n-\t\t\t\texecutionEnvironment(project, session, pluginManager));\n-\t\tlog.info(\"copied retrolambda.jar to build directory\");\n-\t\tlog.info(\"processing classes\");\n-\t\tif (classesType == ClassesType.MAIN)\n-\t\t\tprocessClasses(mainClassesDir, \"maven.compile.classpath\");\n-\t\telse\n-\t\t\tprocessClasses(testClassesDir, \"maven.test.classpath\");\n-\t\tlog.info(\"processed classes\");\n-\t}\n-\n-\tprivate void validateJava8home() throws MojoExecutionException {\n-\t\tFile jdk = new File(java8home);\n-\t\tif (!jdk.exists() || !jdk.isDirectory()) {\n-\t\t\tthrow new MojoExecutionException(\n-\t\t\t\t\t\"must set configuration element java8home or environment variable JAVA8_HOME to a valid jdk 8 location\");\n-\t\t}\n-\t}\n-\n-\tprivate void processClasses(String input, String classpathId)\n-\t\t\tthrows MojoExecutionException {\n-\n-\t\texecuteMojo(\n-\t\t\t\tplugin(groupId(GROUP_ID_ANTRUN),\n-\t\t\t\t\t\tartifactId(ARTIFACT_ID_ANTRUN), version(VERSION_ANTRUN)),\n-\t\t\t\tgoal(\"run\"),\n-\t\t\t\tconfiguration(element(\n-\t\t\t\t\t\t\"target\",\n-\t\t\t\t\t\telement(\"property\",\n-\t\t\t\t\t\t\t\tattributes(attribute(\"name\", \"the_classpath\"),\n-\t\t\t\t\t\t\t\t\t\tattribute(\"refid\", classpathId))),\n-\t\t\t\t\t\telement(\"exec\",\n-\t\t\t\t\t\t\t\tattributes(\n-\t\t\t\t\t\t\t\t\t\tattribute(\"executable\", java8home\n-\t\t\t\t\t\t\t\t\t\t\t\t+ \"/bin/java\"),\n-\t\t\t\t\t\t\t\t\t\tattribute(\"failonerror\", \"true\")),\n-\t\t\t\t\t\t\t\telement(\"arg\",\n-\t\t\t\t\t\t\t\t\t\tattribute(\"value\",\n-\t\t\t\t\t\t\t\t\t\t\t\t\"-Dretrolambda.bytecodeVersion=\"\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ bytecodeVersion)),\n-\t\t\t\t\t\t\t\telement(\"arg\",\n-\t\t\t\t\t\t\t\t\t\tattribute(\"value\",\n-\t\t\t\t\t\t\t\t\t\t\t\t\"-Dretrolambda.inputDir=\"\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ input)),\n-\t\t\t\t\t\t\t\telement(\"arg\",\n-\t\t\t\t\t\t\t\t\t\tattribute(\"value\",\n-\t\t\t\t\t\t\t\t\t\t\t\t\"-Dretrolambda.classpath=${the_classpath}\")),\n-\t\t\t\t\t\t\t\telement(\"arg\",\n-\t\t\t\t\t\t\t\t\t\tattribute(\"value\", \"-javaagent:\"\n-\t\t\t\t\t\t\t\t\t\t\t\t+ project.getBuild()\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t.getDirectory() + \"/\"\n-\t\t\t\t\t\t\t\t\t\t\t\t+ RETROLAMBDA_JAR)),\n-\t\t\t\t\t\t\t\telement(\"arg\", attribute(\"value\", \"-jar\")),\n-\t\t\t\t\t\t\t\telement(\"arg\",\n-\t\t\t\t\t\t\t\t\t\tattribute(\"value\", project.getBuild()\n-\t\t\t\t\t\t\t\t\t\t\t\t.getDirectory()\n-\t\t\t\t\t\t\t\t\t\t\t\t+ \"/\"\n-\t\t\t\t\t\t\t\t\t\t\t\t+ RETROLAMBDA_JAR))))),\n-\t\t\t\texecutionEnvironment(project, session, pluginManager));\n-\t}\n-\n-\tprivate static String getRetrolambdaVersion() {\n-\t\tInputStream is = ProcessClassesMojo.class\n-\t\t\t\t.getResourceAsStream(\"/retrolambda.properties\");\n-\t\tProperties p = new Properties();\n-\t\ttry {\n-\t\t\tp.load(is);\n-\t\t\treturn p.getProperty(\"retrolambda.version\");\n-\t\t} catch (IOException e) {\n-\t\t\tthrow new RuntimeException(e);\n-\t\t}\n-\t}\n+    private static final String VERSION_ANTRUN = \"1.7\";\n+\n+    private static final String ARTIFACT_ID_ANTRUN = \"maven-antrun-plugin\";\n+\n+    private static final String GROUP_ID_ANTRUN = \"org.apache.maven.plugins\";\n+\n+    private static final String RETROLAMBDA_JAR = \"retrolambda.jar\";\n+\n+    private static final int DEFAULT_BYTE_CODE_VERSION = 51;\n+\n+    @Component\n+    private MavenSession session;\n+\n+    @Component\n+    private BuildPluginManager pluginManager;\n+\n+    @Component\n+    private MavenProject project;\n+\n+    /**\n+     * The location of the java 8 jdk (not jre).\n+     */\n+    @Parameter(required = false, property = \"java8home\", defaultValue = \"${env.JAVA8_HOME}\")\n+    private String java8home;\n+\n+    /**\n+     * The version of the bytecode to be produced by retrolamda. Defaults to 51\n+     * which is java 7 compatible bytecode.\n+     */\n+    @Parameter(required = false, property = \"bytecodeVersion\", defaultValue = DEFAULT_BYTE_CODE_VERSION\n+            + \"\")\n+    private String bytecodeVersion;\n+\n+    /**\n+     * The directory containing the main (non-test) compiled classes. These\n+     * classes will be overwritten with bytecode changes to obtain compatibility\n+     * with java 7 runtime.\n+     */\n+    @Parameter(required = false, property = \"retrolambdaMainClassesDir\", defaultValue = \"${project.build.outputDirectory}\")\n+    private String mainClassesDir;\n+\n+    /**\n+     * The directory containing the compiled test classes. These classes will be\n+     * overwritten with bytecode changes to obtain compatibility with java 7\n+     * runtime.\n+     */\n+    @Parameter(required = false, property = \"retrolambdaTestClassesDir\", defaultValue = \"${project.build.testOutputDirectory}\")\n+    private String testClassesDir;\n+\n+    private final ClassesType classesType;\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param classesType\n+     */\n+    ProcessClassesMojo(ClassesType classesType) {\n+        this.classesType = classesType;\n+    }\n+\n+    @Override\n+    public void execute() throws MojoExecutionException {\n+        Log log = getLog();\n+        log.info(\"starting execution\");\n+        validateJava8home();\n+        String retrolambdaVersion = getRetrolambdaVersion();\n+        executeMojo(\n+                plugin(groupId(GROUP_ID_ANTRUN), artifactId(\"maven-dependency-plugin\"),\n+                        version(\"2.0\")),\n+                goal(\"copy\"),\n+                configuration(element(\n+                        \"artifactItems\",\n+                        element(\"artifactItem\",\n+                                element(name(\"groupId\"), \"net.orfjackal.retrolambda\"),\n+                                element(name(\"artifactId\"), \"retrolambda\"),\n+                                element(name(\"version\"), retrolambdaVersion),\n+                                element(name(\"overWrite\"), \"true\"),\n+                                element(name(\"outputDirectory\"), project.getBuild().getDirectory()),\n+                                element(name(\"destFileName\"), RETROLAMBDA_JAR)))),\n+                executionEnvironment(project, session, pluginManager));\n+        log.info(\"copied retrolambda.jar to build directory\");\n+        log.info(\"processing classes\");\n+        if (classesType == ClassesType.MAIN)\n+            processClasses(mainClassesDir, \"maven.compile.classpath\");\n+        else\n+            processClasses(testClassesDir, \"maven.test.classpath\");\n+        log.info(\"processed classes\");\n+    }\n+\n+    private void validateJava8home() throws MojoExecutionException {\n+        File jdk = new File(java8home);\n+        if (!jdk.exists() || !jdk.isDirectory()) {\n+            throw new MojoExecutionException(\n+                    \"must set configuration element java8home or environment variable JAVA8_HOME to a valid jdk 8 location\");\n+        }\n+    }\n+\n+    private void processClasses(String input, String classpathId) throws MojoExecutionException {\n+\n+        executeMojo(\n+                plugin(groupId(GROUP_ID_ANTRUN), artifactId(ARTIFACT_ID_ANTRUN),\n+                        version(VERSION_ANTRUN)),\n+                goal(\"run\"),\n+                configuration(element(\n+                        \"target\",\n+                        element(\"property\",\n+                                attributes(attribute(\"name\", \"the_classpath\"),\n+                                        attribute(\"refid\", classpathId))),\n+                        element(\"exec\",\n+                                attributes(attribute(\"executable\", java8home + \"/bin/java\"),\n+                                        attribute(\"failonerror\", \"true\")),\n+                                element(\"arg\",\n+                                        attribute(\"value\", \"-Dretrolambda.bytecodeVersion=\"\n+                                                + bytecodeVersion)),\n+                                element(\"arg\",\n+                                        attribute(\"value\", \"-Dretrolambda.inputDir=\" + input)),\n+                                element(\"arg\",\n+                                        attribute(\"value\",\n+                                                \"-Dretrolambda.classpath=${the_classpath}\")),\n+                                element(\"arg\",\n+                                        attribute(\"value\", \"-javaagent:\"\n+                                                + project.getBuild().getDirectory() + \"/\"\n+                                                + RETROLAMBDA_JAR)),\n+                                element(\"arg\", attribute(\"value\", \"-jar\")),\n+                                element(\"arg\",\n+                                        attribute(\"value\", project.getBuild().getDirectory() + \"/\"\n+                                                + RETROLAMBDA_JAR))))),\n+                executionEnvironment(project, session, pluginManager));\n+    }\n+\n+    private static String getRetrolambdaVersion() {\n+        InputStream is = ProcessClassesMojo.class.getResourceAsStream(\"/retrolambda.properties\");\n+        Properties p = new Properties();\n+        try {\n+            p.load(is);\n+            return p.getProperty(\"retrolambda.version\");\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n }\n"
    },
    {
        "commit_hash": "8be3092acf40c2f4c8f2e85cf6319508e2e17551",
        "previous_commit_hash": "28341bbed6f6210ed12cc9f1af84ca21919a2c31",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -10,8 +10,8 @@ import org.apache.maven.plugins.annotations.Mojo;\n @Mojo(name = \"process-main\", defaultPhase = LifecyclePhase.PROCESS_CLASSES)\n public class ProcessMainClassesMojo extends ProcessClassesMojo {\n \n-\tpublic ProcessMainClassesMojo() {\n-\t\tsuper(ClassesType.MAIN);\n-\t}\n+    public ProcessMainClassesMojo() {\n+        super(ClassesType.MAIN);\n+    }\n \n }\n"
    },
    {
        "commit_hash": "8be3092acf40c2f4c8f2e85cf6319508e2e17551",
        "previous_commit_hash": "28341bbed6f6210ed12cc9f1af84ca21919a2c31",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -10,7 +10,7 @@ import org.apache.maven.plugins.annotations.Mojo;\n @Mojo(name = \"process-test\", defaultPhase = LifecyclePhase.PROCESS_TEST_CLASSES)\n public class ProcessTestClassesMojo extends ProcessClassesMojo {\n \n-\tpublic ProcessTestClassesMojo() {\n-\t\tsuper(ClassesType.TEST);\n-\t}\n+    public ProcessTestClassesMojo() {\n+        super(ClassesType.TEST);\n+    }\n }\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "a8b857c28a85c0bd6460accf8326bedb7c8f19b6",
        "previous_commit_hash": "8be3092acf40c2f4c8f2e85cf6319508e2e17551",
        "diff_stats": {
            "additions": 144,
            "deletions": 144
        },
        "diff_content": "@@ -1,153 +1,153 @@\n <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n-\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n-\t<modelVersion>4.0.0</modelVersion>\n-\t<parent>\n-\t\t<groupId>net.orfjackal.retrolambda</groupId>\n-\t\t<artifactId>parent</artifactId>\n-\t\t<version>1.1.5-SNAPSHOT</version>\n-\t\t<relativePath>../parent/pom.xml</relativePath>\n-\t</parent>\n-\t<artifactId>retrolambda-maven-plugin</artifactId>\n-\t<packaging>maven-plugin</packaging>\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+    <parent>\n+        <groupId>net.orfjackal.retrolambda</groupId>\n+        <artifactId>parent</artifactId>\n+        <version>1.1.5-SNAPSHOT</version>\n+        <relativePath>../parent/pom.xml</relativePath>\n+    </parent>\n+    <artifactId>retrolambda-maven-plugin</artifactId>\n+    <packaging>maven-plugin</packaging>\n \n-\t<name>${project.artifactId}</name>\n+    <name>${project.artifactId}</name>\n \n-\t<url>https://github.com/orfjackal/retrolambda</url>\n+    <url>https://github.com/orfjackal/retrolambda</url>\n \n-\t<properties>\n-\t\t<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n-\t</properties>\n+    <properties>\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+    </properties>\n \n-\t<prerequisites>\n-\t\t<maven>${minimumMavenVersion}</maven>\n-\t</prerequisites>\n+    <prerequisites>\n+        <maven>${minimumMavenVersion}</maven>\n+    </prerequisites>\n \n-\t<dependencies>\n-\t\t<dependency>\n-\t\t\t<groupId>org.apache.maven</groupId>\n-\t\t\t<artifactId>maven-plugin-api</artifactId>\n-\t\t\t<version>2.0</version>\n-\t\t</dependency>\n-\t\t<dependency>\n-\t\t\t<groupId>org.apache.maven.plugin-tools</groupId>\n-\t\t\t<artifactId>maven-plugin-annotations</artifactId>\n-\t\t\t<version>3.2</version>\n-\t\t\t<scope>provided</scope>\n-\t\t</dependency>\n-\t\t<dependency>\n-\t\t\t<groupId>org.codehaus.plexus</groupId>\n-\t\t\t<artifactId>plexus-utils</artifactId>\n-\t\t\t<version>3.0.8</version>\n-\t\t</dependency>\n-\t\t<dependency>\n-\t\t\t<groupId>org.twdata.maven</groupId>\n-\t\t\t<artifactId>mojo-executor</artifactId>\n-\t\t\t<version>2.2.0</version>\n-\t\t</dependency>\n+    <dependencies>\n+        <dependency>\n+            <groupId>org.apache.maven</groupId>\n+            <artifactId>maven-plugin-api</artifactId>\n+            <version>2.0</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.apache.maven.plugin-tools</groupId>\n+            <artifactId>maven-plugin-annotations</artifactId>\n+            <version>3.2</version>\n+            <scope>provided</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.codehaus.plexus</groupId>\n+            <artifactId>plexus-utils</artifactId>\n+            <version>3.0.8</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.twdata.maven</groupId>\n+            <artifactId>mojo-executor</artifactId>\n+            <version>2.2.0</version>\n+        </dependency>\n \n-\t</dependencies>\n+    </dependencies>\n \n-\t<build>\n-\t\t<resources>\n-\t\t\t<resource>\n-\t\t\t\t<directory>src/main/resources</directory>\n-\t\t\t\t<filtering>true</filtering>\n-\t\t\t</resource>\n-\t\t</resources>\n-\t\t<plugins>\n-\t\t\t<plugin>\n-\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n-\t\t\t\t<artifactId>maven-compiler-plugin</artifactId>\n-\t\t\t\t<configuration>\n-\t\t\t\t\t<verbose>true</verbose>\n-\t\t\t\t\t<fork>true</fork>\n-\t\t\t\t\t<source>1.6</source>\n-\t\t\t\t\t<target>1.6</target>\n-\t\t\t\t</configuration>\n-\t\t\t</plugin>\n-\t\t\t<plugin>\n-\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n-\t\t\t\t<artifactId>maven-plugin-plugin</artifactId>\n-\t\t\t\t<configuration>\n-\t\t\t\t\t<goalPrefix>retrolambda</goalPrefix>\n-\t\t\t\t\t<skipErrorNoDescriptorsFound>true</skipErrorNoDescriptorsFound>\n-\t\t\t\t</configuration>\n-\t\t\t\t<executions>\n-\t\t\t\t\t<execution>\n-\t\t\t\t\t\t<id>mojo-descriptor</id>\n-\t\t\t\t\t\t<goals>\n-\t\t\t\t\t\t\t<goal>descriptor</goal>\n-\t\t\t\t\t\t</goals>\n-\t\t\t\t\t\t<phase>process-classes</phase>\n-\t\t\t\t\t</execution>\n-\t\t\t\t\t<execution>\n-\t\t\t\t\t\t<id>help-goal</id>\n-\t\t\t\t\t\t<goals>\n-\t\t\t\t\t\t\t<goal>helpmojo</goal>\n-\t\t\t\t\t\t</goals>\n-\t\t\t\t\t\t<phase>process-classes</phase>\n-\t\t\t\t\t</execution>\n-\t\t\t\t</executions>\n-\t\t\t</plugin>\n-\t\t\t<plugin>\n-\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n-\t\t\t\t<artifactId>maven-site-plugin</artifactId>\n-\t\t\t\t<executions>\n-\t\t\t\t\t<execution>\n-\t\t\t\t\t\t<id>attach-descriptor</id>\n-\t\t\t\t\t\t<goals>\n-\t\t\t\t\t\t\t<goal>attach-descriptor</goal>\n-\t\t\t\t\t\t</goals>\n-\t\t\t\t\t</execution>\n-\t\t\t\t</executions>\n-\t\t\t\t<configuration>\n-\t\t\t\t\t<reportPlugins>\n-\t\t\t\t\t\t<plugin>\n-\t\t\t\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n-\t\t\t\t\t\t\t<artifactId>maven-plugin-plugin</artifactId>\n-\t\t\t\t\t\t\t<version>3.2</version>\n-\t\t\t\t\t\t</plugin>\n-\t\t\t\t\t</reportPlugins>\n-\t\t\t\t</configuration>\n-\t\t\t</plugin>\n-\t\t</plugins>\n-\t</build>\n-\t<profiles>\n-\t\t<profile>\n-\t\t\t<id>run-its</id>\n-\t\t\t<build>\n-\t\t\t\t<plugins>\n-\t\t\t\t\t<plugin>\n-\t\t\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n-\t\t\t\t\t\t<artifactId>maven-invoker-plugin</artifactId>\n-\t\t\t\t\t\t<version>1.7</version>\n-\t\t\t\t\t\t<configuration>\n-\t\t\t\t\t\t\t<debug>true</debug>\n-\t\t\t\t\t\t\t<cloneProjectsTo>${project.build.directory}/it</cloneProjectsTo>\n-\t\t\t\t\t\t\t<pomIncludes>\n-\t\t\t\t\t\t\t\t<pomInclude>*/pom.xml</pomInclude>\n-\t\t\t\t\t\t\t</pomIncludes>\n-\t\t\t\t\t\t\t<postBuildHookScript>verify</postBuildHookScript>\n-\t\t\t\t\t\t\t<localRepositoryPath>${project.build.directory}/local-repo</localRepositoryPath>\n-\t\t\t\t\t\t\t<settingsFile>src/it/settings.xml</settingsFile>\n-\t\t\t\t\t\t\t<goals>\n-\t\t\t\t\t\t\t\t<goal>clean</goal>\n-\t\t\t\t\t\t\t\t<goal>test-compile</goal>\n-\t\t\t\t\t\t\t</goals>\n-\t\t\t\t\t\t</configuration>\n-\t\t\t\t\t\t<executions>\n-\t\t\t\t\t\t\t<execution>\n-\t\t\t\t\t\t\t\t<id>integration-test</id>\n-\t\t\t\t\t\t\t\t<goals>\n-\t\t\t\t\t\t\t\t\t<goal>install</goal>\n-\t\t\t\t\t\t\t\t\t<goal>integration-test</goal>\n-\t\t\t\t\t\t\t\t\t<goal>verify</goal>\n-\t\t\t\t\t\t\t\t</goals>\n-\t\t\t\t\t\t\t</execution>\n-\t\t\t\t\t\t</executions>\n-\t\t\t\t\t</plugin>\n-\t\t\t\t</plugins>\n-\t\t\t</build>\n-\t\t</profile>\n-\t</profiles>\n+    <build>\n+        <resources>\n+            <resource>\n+                <directory>src/main/resources</directory>\n+                <filtering>true</filtering>\n+            </resource>\n+        </resources>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-compiler-plugin</artifactId>\n+                <configuration>\n+                    <verbose>true</verbose>\n+                    <fork>true</fork>\n+                    <source>1.6</source>\n+                    <target>1.6</target>\n+                </configuration>\n+            </plugin>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-plugin-plugin</artifactId>\n+                <configuration>\n+                    <goalPrefix>retrolambda</goalPrefix>\n+                    <skipErrorNoDescriptorsFound>true</skipErrorNoDescriptorsFound>\n+                </configuration>\n+                <executions>\n+                    <execution>\n+                        <id>mojo-descriptor</id>\n+                        <goals>\n+                            <goal>descriptor</goal>\n+                        </goals>\n+                        <phase>process-classes</phase>\n+                    </execution>\n+                    <execution>\n+                        <id>help-goal</id>\n+                        <goals>\n+                            <goal>helpmojo</goal>\n+                        </goals>\n+                        <phase>process-classes</phase>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-site-plugin</artifactId>\n+                <executions>\n+                    <execution>\n+                        <id>attach-descriptor</id>\n+                        <goals>\n+                            <goal>attach-descriptor</goal>\n+                        </goals>\n+                    </execution>\n+                </executions>\n+                <configuration>\n+                    <reportPlugins>\n+                        <plugin>\n+                            <groupId>org.apache.maven.plugins</groupId>\n+                            <artifactId>maven-plugin-plugin</artifactId>\n+                            <version>3.2</version>\n+                        </plugin>\n+                    </reportPlugins>\n+                </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+    <profiles>\n+        <profile>\n+            <id>run-its</id>\n+            <build>\n+                <plugins>\n+                    <plugin>\n+                        <groupId>org.apache.maven.plugins</groupId>\n+                        <artifactId>maven-invoker-plugin</artifactId>\n+                        <version>1.7</version>\n+                        <configuration>\n+                            <debug>true</debug>\n+                            <cloneProjectsTo>${project.build.directory}/it</cloneProjectsTo>\n+                            <pomIncludes>\n+                                <pomInclude>*/pom.xml</pomInclude>\n+                            </pomIncludes>\n+                            <postBuildHookScript>verify</postBuildHookScript>\n+                            <localRepositoryPath>${project.build.directory}/local-repo</localRepositoryPath>\n+                            <settingsFile>src/it/settings.xml</settingsFile>\n+                            <goals>\n+                                <goal>clean</goal>\n+                                <goal>test-compile</goal>\n+                            </goals>\n+                        </configuration>\n+                        <executions>\n+                            <execution>\n+                                <id>integration-test</id>\n+                                <goals>\n+                                    <goal>install</goal>\n+                                    <goal>integration-test</goal>\n+                                    <goal>verify</goal>\n+                                </goals>\n+                            </execution>\n+                        </executions>\n+                    </plugin>\n+                </plugins>\n+            </build>\n+        </profile>\n+    </profiles>\n </project>\n"
    },
    {
        "commit_hash": "b681452ccbe11fb19db433c95fa7a2236796b4c8",
        "previous_commit_hash": "a8b857c28a85c0bd6460accf8326bedb7c8f19b6",
        "diff_stats": {
            "additions": 6,
            "deletions": 4
        },
        "diff_content": "@@ -29,11 +29,13 @@ import org.apache.maven.project.MavenProject;\n \n abstract class ProcessClassesMojo extends AbstractMojo {\n \n+    private static final String VERSION_DEPENDENCY = \"2.0\";\n+    private static final String GROUP_ID_DEPENDENCY = \"org.apache.maven.plugins\";\n+    private static final String ARTIFACT_ID_DEPENDENCY = \"maven-dependency-plugin\";\n     private static final String VERSION_ANTRUN = \"1.7\";\n \n-    private static final String ARTIFACT_ID_ANTRUN = \"maven-antrun-plugin\";\n-\n     private static final String GROUP_ID_ANTRUN = \"org.apache.maven.plugins\";\n+    private static final String ARTIFACT_ID_ANTRUN = \"maven-antrun-plugin\";\n \n     private static final String RETROLAMBDA_JAR = \"retrolambda.jar\";\n \n@@ -96,8 +98,8 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n         validateJava8home();\n         String retrolambdaVersion = getRetrolambdaVersion();\n         executeMojo(\n-                plugin(groupId(GROUP_ID_ANTRUN), artifactId(\"maven-dependency-plugin\"),\n-                        version(\"2.0\")),\n+                plugin(groupId(GROUP_ID_DEPENDENCY), artifactId(ARTIFACT_ID_DEPENDENCY),\n+                        version(VERSION_DEPENDENCY)),\n                 goal(\"copy\"),\n                 configuration(element(\n                         \"artifactItems\",\n"
    },
    {
        "commit_hash": "b8c4575280d9182be93dd62853c5e3afb6b6e520",
        "previous_commit_hash": "b681452ccbe11fb19db433c95fa7a2236796b4c8",
        "diff_stats": {
            "additions": 174,
            "deletions": 142
        },
        "diff_content": "@@ -16,6 +16,8 @@ import static org.twdata.maven.mojoexecutor.MojoExecutor.version;\n import java.io.File;\n import java.io.IOException;\n import java.io.InputStream;\n+import java.util.HashMap;\n+import java.util.Map;\n import java.util.Properties;\n \n import org.apache.maven.execution.MavenSession;\n@@ -29,146 +31,176 @@ import org.apache.maven.project.MavenProject;\n \n abstract class ProcessClassesMojo extends AbstractMojo {\n \n-    private static final String VERSION_DEPENDENCY = \"2.0\";\n-    private static final String GROUP_ID_DEPENDENCY = \"org.apache.maven.plugins\";\n-    private static final String ARTIFACT_ID_DEPENDENCY = \"maven-dependency-plugin\";\n-    private static final String VERSION_ANTRUN = \"1.7\";\n-\n-    private static final String GROUP_ID_ANTRUN = \"org.apache.maven.plugins\";\n-    private static final String ARTIFACT_ID_ANTRUN = \"maven-antrun-plugin\";\n-\n-    private static final String RETROLAMBDA_JAR = \"retrolambda.jar\";\n-\n-    private static final int DEFAULT_BYTE_CODE_VERSION = 51;\n-\n-    @Component\n-    private MavenSession session;\n-\n-    @Component\n-    private BuildPluginManager pluginManager;\n-\n-    @Component\n-    private MavenProject project;\n-\n-    /**\n-     * The location of the java 8 jdk (not jre).\n-     */\n-    @Parameter(required = false, property = \"java8home\", defaultValue = \"${env.JAVA8_HOME}\")\n-    private String java8home;\n-\n-    /**\n-     * The version of the bytecode to be produced by retrolamda. Defaults to 51\n-     * which is java 7 compatible bytecode.\n-     */\n-    @Parameter(required = false, property = \"bytecodeVersion\", defaultValue = DEFAULT_BYTE_CODE_VERSION\n-            + \"\")\n-    private String bytecodeVersion;\n-\n-    /**\n-     * The directory containing the main (non-test) compiled classes. These\n-     * classes will be overwritten with bytecode changes to obtain compatibility\n-     * with java 7 runtime.\n-     */\n-    @Parameter(required = false, property = \"retrolambdaMainClassesDir\", defaultValue = \"${project.build.outputDirectory}\")\n-    private String mainClassesDir;\n-\n-    /**\n-     * The directory containing the compiled test classes. These classes will be\n-     * overwritten with bytecode changes to obtain compatibility with java 7\n-     * runtime.\n-     */\n-    @Parameter(required = false, property = \"retrolambdaTestClassesDir\", defaultValue = \"${project.build.testOutputDirectory}\")\n-    private String testClassesDir;\n-\n-    private final ClassesType classesType;\n-\n-    /**\n-     * Constructor.\n-     * \n-     * @param classesType\n-     */\n-    ProcessClassesMojo(ClassesType classesType) {\n-        this.classesType = classesType;\n-    }\n-\n-    @Override\n-    public void execute() throws MojoExecutionException {\n-        Log log = getLog();\n-        log.info(\"starting execution\");\n-        validateJava8home();\n-        String retrolambdaVersion = getRetrolambdaVersion();\n-        executeMojo(\n-                plugin(groupId(GROUP_ID_DEPENDENCY), artifactId(ARTIFACT_ID_DEPENDENCY),\n-                        version(VERSION_DEPENDENCY)),\n-                goal(\"copy\"),\n-                configuration(element(\n-                        \"artifactItems\",\n-                        element(\"artifactItem\",\n-                                element(name(\"groupId\"), \"net.orfjackal.retrolambda\"),\n-                                element(name(\"artifactId\"), \"retrolambda\"),\n-                                element(name(\"version\"), retrolambdaVersion),\n-                                element(name(\"overWrite\"), \"true\"),\n-                                element(name(\"outputDirectory\"), project.getBuild().getDirectory()),\n-                                element(name(\"destFileName\"), RETROLAMBDA_JAR)))),\n-                executionEnvironment(project, session, pluginManager));\n-        log.info(\"copied retrolambda.jar to build directory\");\n-        log.info(\"processing classes\");\n-        if (classesType == ClassesType.MAIN)\n-            processClasses(mainClassesDir, \"maven.compile.classpath\");\n-        else\n-            processClasses(testClassesDir, \"maven.test.classpath\");\n-        log.info(\"processed classes\");\n-    }\n-\n-    private void validateJava8home() throws MojoExecutionException {\n-        File jdk = new File(java8home);\n-        if (!jdk.exists() || !jdk.isDirectory()) {\n-            throw new MojoExecutionException(\n-                    \"must set configuration element java8home or environment variable JAVA8_HOME to a valid jdk 8 location\");\n-        }\n-    }\n-\n-    private void processClasses(String input, String classpathId) throws MojoExecutionException {\n-\n-        executeMojo(\n-                plugin(groupId(GROUP_ID_ANTRUN), artifactId(ARTIFACT_ID_ANTRUN),\n-                        version(VERSION_ANTRUN)),\n-                goal(\"run\"),\n-                configuration(element(\n-                        \"target\",\n-                        element(\"property\",\n-                                attributes(attribute(\"name\", \"the_classpath\"),\n-                                        attribute(\"refid\", classpathId))),\n-                        element(\"exec\",\n-                                attributes(attribute(\"executable\", java8home + \"/bin/java\"),\n-                                        attribute(\"failonerror\", \"true\")),\n-                                element(\"arg\",\n-                                        attribute(\"value\", \"-Dretrolambda.bytecodeVersion=\"\n-                                                + bytecodeVersion)),\n-                                element(\"arg\",\n-                                        attribute(\"value\", \"-Dretrolambda.inputDir=\" + input)),\n-                                element(\"arg\",\n-                                        attribute(\"value\",\n-                                                \"-Dretrolambda.classpath=${the_classpath}\")),\n-                                element(\"arg\",\n-                                        attribute(\"value\", \"-javaagent:\"\n-                                                + project.getBuild().getDirectory() + \"/\"\n-                                                + RETROLAMBDA_JAR)),\n-                                element(\"arg\", attribute(\"value\", \"-jar\")),\n-                                element(\"arg\",\n-                                        attribute(\"value\", project.getBuild().getDirectory() + \"/\"\n-                                                + RETROLAMBDA_JAR))))),\n-                executionEnvironment(project, session, pluginManager));\n-    }\n-\n-    private static String getRetrolambdaVersion() {\n-        InputStream is = ProcessClassesMojo.class.getResourceAsStream(\"/retrolambda.properties\");\n-        Properties p = new Properties();\n-        try {\n-            p.load(is);\n-            return p.getProperty(\"retrolambda.version\");\n-        } catch (IOException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n+\tprivate static final String VERSION_DEPENDENCY = \"2.0\";\n+\tprivate static final String GROUP_ID_DEPENDENCY = \"org.apache.maven.plugins\";\n+\tprivate static final String ARTIFACT_ID_DEPENDENCY = \"maven-dependency-plugin\";\n+\tprivate static final String VERSION_ANTRUN = \"1.7\";\n+\n+\tprivate static final String GROUP_ID_ANTRUN = \"org.apache.maven.plugins\";\n+\tprivate static final String ARTIFACT_ID_ANTRUN = \"maven-antrun-plugin\";\n+\n+\tprivate static final String RETROLAMBDA_JAR = \"retrolambda.jar\";\n+\n+\tprivate final Map<String, Integer> targetBytecodeVersions = new HashMap<String, Integer>();\n+\n+\t@Component\n+\tprivate MavenSession session;\n+\n+\t@Component\n+\tprivate BuildPluginManager pluginManager;\n+\n+\t@Component\n+\tprivate MavenProject project;\n+\n+\t/**\n+\t * The location of the java 8 jdk (not jre).\n+\t */\n+\t@Parameter(required = false, property = \"java8home\", defaultValue = \"${env.JAVA8_HOME}\")\n+\tprivate String java8home;\n+\n+\t/**\n+\t * The java version targeted by the bytecode processing. Possible values are\n+\t * 1.5, 1.6, 1.7 and 1.8. After processing the classes will be compatible\n+\t * with the target jvm provided the known limitations are considered. See <a\n+\t * href=\"https://github.com/orfjackal/retrolambda\">project documentation</a>\n+\t * for more details.\n+\t */\n+\t@Parameter(required = false, property = \"retrolambdaTarget\", defaultValue = \"1.7\")\n+\tprivate String target;\n+\n+\t/**\n+\t * The directory containing the main (non-test) compiled classes. These\n+\t * classes will be overwritten with bytecode changes to obtain compatibility\n+\t * with target java runtime.\n+\t */\n+\t@Parameter(required = false, property = \"retrolambdaMainClassesDir\", defaultValue = \"${project.build.outputDirectory}\")\n+\tprivate String mainClassesDir;\n+\n+\t/**\n+\t * The directory containing the compiled test classes. These classes will be\n+\t * overwritten with bytecode changes to obtain compatibility with target\n+\t * java runtime.\n+\t */\n+\t@Parameter(required = false, property = \"retrolambdaTestClassesDir\", defaultValue = \"${project.build.testOutputDirectory}\")\n+\tprivate String testClassesDir;\n+\n+\tprivate final ClassesType classesType;\n+\n+\t/**\n+\t * Constructor.\n+\t * \n+\t * @param classesType\n+\t */\n+\tProcessClassesMojo(ClassesType classesType) {\n+\t\tthis.classesType = classesType;\n+\t\ttargetBytecodeVersions.put(\"1.5\", 49);\n+\t\ttargetBytecodeVersions.put(\"1.6\", 50);\n+\t\ttargetBytecodeVersions.put(\"1.7\", 51);\n+\t\ttargetBytecodeVersions.put(\"1.8\", 52);\n+\t}\n+\n+\t@Override\n+\tpublic void execute() throws MojoExecutionException {\n+\t\tLog log = getLog();\n+\t\tlog.info(\"starting execution\");\n+\t\tvalidateJava8home();\n+\t\tvalidateTarget();\n+\t\tString retrolambdaVersion = getRetrolambdaVersion();\n+\t\texecuteMojo(\n+\t\t\t\tplugin(groupId(GROUP_ID_DEPENDENCY),\n+\t\t\t\t\t\tartifactId(ARTIFACT_ID_DEPENDENCY),\n+\t\t\t\t\t\tversion(VERSION_DEPENDENCY)),\n+\t\t\t\tgoal(\"copy\"),\n+\t\t\t\tconfiguration(element(\n+\t\t\t\t\t\t\"artifactItems\",\n+\t\t\t\t\t\telement(\"artifactItem\",\n+\t\t\t\t\t\t\t\telement(name(\"groupId\"),\n+\t\t\t\t\t\t\t\t\t\t\"net.orfjackal.retrolambda\"),\n+\t\t\t\t\t\t\t\telement(name(\"artifactId\"), \"retrolambda\"),\n+\t\t\t\t\t\t\t\telement(name(\"version\"), retrolambdaVersion),\n+\t\t\t\t\t\t\t\telement(name(\"overWrite\"), \"true\"),\n+\t\t\t\t\t\t\t\telement(name(\"outputDirectory\"), project\n+\t\t\t\t\t\t\t\t\t\t.getBuild().getDirectory()),\n+\t\t\t\t\t\t\t\telement(name(\"destFileName\"), RETROLAMBDA_JAR)))),\n+\t\t\t\texecutionEnvironment(project, session, pluginManager));\n+\t\tlog.info(\"copied retrolambda.jar to build directory\");\n+\t\tlog.info(\"processing classes\");\n+\t\tif (classesType == ClassesType.MAIN)\n+\t\t\tprocessClasses(mainClassesDir, \"maven.compile.classpath\");\n+\t\telse\n+\t\t\tprocessClasses(testClassesDir, \"maven.test.classpath\");\n+\t\tlog.info(\"processed classes\");\n+\t}\n+\n+\tprivate void validateTarget() throws MojoExecutionException {\n+\t\tif (!targetBytecodeVersions.containsKey(target))\n+\t\t\tthrow new MojoExecutionException(\n+\t\t\t\t\t\"unrecognized target '\"\n+\t\t\t\t\t\t\t+ target\n+\t\t\t\t\t\t\t+ \"'. Possible values are 1.5, 1.6 ,1.7 ,1.8 representing those versions of java.\");\n+\t}\n+\n+\tprivate void validateJava8home() throws MojoExecutionException {\n+\t\tFile jdk = new File(java8home);\n+\t\tif (!jdk.exists() || !jdk.isDirectory()) {\n+\t\t\tthrow new MojoExecutionException(\n+\t\t\t\t\t\"must set configuration element java8home or environment variable JAVA8_HOME to a valid jdk 8 location\");\n+\t\t}\n+\t}\n+\n+\tprivate void processClasses(String input, String classpathId)\n+\t\t\tthrows MojoExecutionException {\n+\n+\t\texecuteMojo(\n+\t\t\t\tplugin(groupId(GROUP_ID_ANTRUN),\n+\t\t\t\t\t\tartifactId(ARTIFACT_ID_ANTRUN), version(VERSION_ANTRUN)),\n+\t\t\t\tgoal(\"run\"),\n+\t\t\t\tconfiguration(element(\n+\t\t\t\t\t\t\"target\",\n+\t\t\t\t\t\telement(\"property\",\n+\t\t\t\t\t\t\t\tattributes(attribute(\"name\", \"the_classpath\"),\n+\t\t\t\t\t\t\t\t\t\tattribute(\"refid\", classpathId))),\n+\t\t\t\t\t\telement(\"exec\",\n+\t\t\t\t\t\t\t\tattributes(\n+\t\t\t\t\t\t\t\t\t\tattribute(\"executable\", java8home\n+\t\t\t\t\t\t\t\t\t\t\t\t+ \"/bin/java\"),\n+\t\t\t\t\t\t\t\t\t\tattribute(\"failonerror\", \"true\")),\n+\t\t\t\t\t\t\t\telement(\"arg\",\n+\t\t\t\t\t\t\t\t\t\tattribute(\n+\t\t\t\t\t\t\t\t\t\t\t\t\"value\",\n+\t\t\t\t\t\t\t\t\t\t\t\t\"-Dretrolambda.bytecodeVersion=\"\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ targetBytecodeVersions\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.get(target))),\n+\t\t\t\t\t\t\t\telement(\"arg\",\n+\t\t\t\t\t\t\t\t\t\tattribute(\"value\",\n+\t\t\t\t\t\t\t\t\t\t\t\t\"-Dretrolambda.inputDir=\"\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ input)),\n+\t\t\t\t\t\t\t\telement(\"arg\",\n+\t\t\t\t\t\t\t\t\t\tattribute(\"value\",\n+\t\t\t\t\t\t\t\t\t\t\t\t\"-Dretrolambda.classpath=${the_classpath}\")),\n+\t\t\t\t\t\t\t\telement(\"arg\",\n+\t\t\t\t\t\t\t\t\t\tattribute(\"value\", \"-javaagent:\"\n+\t\t\t\t\t\t\t\t\t\t\t\t+ project.getBuild()\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t.getDirectory() + \"/\"\n+\t\t\t\t\t\t\t\t\t\t\t\t+ RETROLAMBDA_JAR)),\n+\t\t\t\t\t\t\t\telement(\"arg\", attribute(\"value\", \"-jar\")),\n+\t\t\t\t\t\t\t\telement(\"arg\",\n+\t\t\t\t\t\t\t\t\t\tattribute(\"value\", project.getBuild()\n+\t\t\t\t\t\t\t\t\t\t\t\t.getDirectory()\n+\t\t\t\t\t\t\t\t\t\t\t\t+ \"/\"\n+\t\t\t\t\t\t\t\t\t\t\t\t+ RETROLAMBDA_JAR))))),\n+\t\t\t\texecutionEnvironment(project, session, pluginManager));\n+\t}\n+\n+\tprivate static String getRetrolambdaVersion() {\n+\t\tInputStream is = ProcessClassesMojo.class\n+\t\t\t\t.getResourceAsStream(\"/retrolambda.properties\");\n+\t\tProperties p = new Properties();\n+\t\ttry {\n+\t\t\tp.load(is);\n+\t\t\treturn p.getProperty(\"retrolambda.version\");\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n+\t}\n }\n"
    },
    {
        "commit_hash": "b8c4575280d9182be93dd62853c5e3afb6b6e520",
        "previous_commit_hash": "b681452ccbe11fb19db433c95fa7a2236796b4c8",
        "diff_stats": {
            "additions": 4,
            "deletions": 4
        },
        "diff_content": "@@ -5,13 +5,13 @@ import org.apache.maven.plugins.annotations.Mojo;\n \n /**\n  * Processes main (non-test) classes compiled with java 8 so that they are\n- * compatible with java 7 runtime.\n+ * compatible with java 5,6 or 7 runtime.\n  */\n @Mojo(name = \"process-main\", defaultPhase = LifecyclePhase.PROCESS_CLASSES)\n public class ProcessMainClassesMojo extends ProcessClassesMojo {\n \n-    public ProcessMainClassesMojo() {\n-        super(ClassesType.MAIN);\n-    }\n+\tpublic ProcessMainClassesMojo() {\n+\t\tsuper(ClassesType.MAIN);\n+\t}\n \n }\n"
    },
    {
        "commit_hash": "b8c4575280d9182be93dd62853c5e3afb6b6e520",
        "previous_commit_hash": "b681452ccbe11fb19db433c95fa7a2236796b4c8",
        "diff_stats": {
            "additions": 4,
            "deletions": 4
        },
        "diff_content": "@@ -5,12 +5,12 @@ import org.apache.maven.plugins.annotations.Mojo;\n \n /**\n  * Processes test classes compiled with java 8 so that they are compatible with\n- * java 7 runtime.\n+ * java 5,6 or 7 runtime.\n  */\n @Mojo(name = \"process-test\", defaultPhase = LifecyclePhase.PROCESS_TEST_CLASSES)\n public class ProcessTestClassesMojo extends ProcessClassesMojo {\n \n-    public ProcessTestClassesMojo() {\n-        super(ClassesType.TEST);\n-    }\n+\tpublic ProcessTestClassesMojo() {\n+\t\tsuper(ClassesType.TEST);\n+\t}\n }\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "c32db1a20e5b81133f8980360931eec02749215e",
        "previous_commit_hash": "b8c4575280d9182be93dd62853c5e3afb6b6e520",
        "diff_stats": {
            "additions": 13,
            "deletions": 13
        },
        "diff_content": "@@ -47,19 +47,19 @@\n             </plugin>\n \n             <!-- Process our byte codes to make them run on Java 7 -->\n-\t\t\t<plugin>\n-\t\t\t\t<groupId>net.orfjackal.retrolambda</groupId>\n-\t\t\t\t<artifactId>retrolambda-maven-plugin</artifactId>\n-\t\t\t\t<version>${project.parent.version}</version>\n-\t\t\t\t<executions>\n-\t\t\t\t\t<execution>\n-\t\t\t\t\t\t<goals>\n-\t\t\t\t\t\t\t<goal>process-main</goal>\n-\t\t\t\t\t\t\t<goal>process-test</goal>\n-\t\t\t\t\t\t</goals>\n-\t\t\t\t\t</execution>\n-\t\t\t\t</executions>\n-\t\t\t</plugin>\n+            <plugin>\n+                <groupId>net.orfjackal.retrolambda</groupId>\n+                <artifactId>retrolambda-maven-plugin</artifactId>\n+                <version>${project.parent.version}</version>\n+                <executions>\n+                    <execution>\n+                        <goals>\n+                            <goal>process-main</goal>\n+                            <goal>process-test</goal>\n+                        </goals>\n+                    </execution>\n+                </executions>\n+            </plugin>\n \n \t<!-- alternatively, can use a call to the dependency plugin and antrun plugins for fine control of retrolambda parameters -->\n     <!-- although optimally all such use should be through the maven plugin above. Request changes if you need them! -->\n"
    },
    {
        "commit_hash": "d9e7614203f73b4b8519f7a0b35caf149c33ac2c",
        "previous_commit_hash": "5f14a5e7bc1fd4e465ff333f4574808fbb5c5bb8",
        "diff_stats": {
            "additions": 10,
            "deletions": 16
        },
        "diff_content": "@@ -1,27 +1,17 @@\n <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n-    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n     <modelVersion>4.0.0</modelVersion>\n+\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n         <version>1.1.5-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n+\n     <artifactId>retrolambda-maven-plugin</artifactId>\n     <packaging>maven-plugin</packaging>\n \n-    <name>${project.artifactId}</name>\n-\n-    <url>https://github.com/orfjackal/retrolambda</url>\n-\n-    <properties>\n-        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n-    </properties>\n-\n-    <prerequisites>\n-        <maven>${minimumMavenVersion}</maven>\n-    </prerequisites>\n-\n     <dependencies>\n         <dependency>\n             <groupId>org.apache.maven</groupId>\n@@ -44,7 +34,6 @@\n             <artifactId>mojo-executor</artifactId>\n             <version>2.2.0</version>\n         </dependency>\n-\n     </dependencies>\n \n     <build>\n@@ -54,9 +43,10 @@\n                 <filtering>true</filtering>\n             </resource>\n         </resources>\n+\n         <plugins>\n+\n             <plugin>\n-                <groupId>org.apache.maven.plugins</groupId>\n                 <artifactId>maven-compiler-plugin</artifactId>\n                 <configuration>\n                     <verbose>true</verbose>\n@@ -65,8 +55,8 @@\n                     <target>1.6</target>\n                 </configuration>\n             </plugin>\n+\n             <plugin>\n-                <groupId>org.apache.maven.plugins</groupId>\n                 <artifactId>maven-plugin-plugin</artifactId>\n                 <configuration>\n                     <goalPrefix>retrolambda</goalPrefix>\n@@ -89,6 +79,7 @@\n                     </execution>\n                 </executions>\n             </plugin>\n+\n             <plugin>\n                 <groupId>org.apache.maven.plugins</groupId>\n                 <artifactId>maven-site-plugin</artifactId>\n@@ -110,8 +101,10 @@\n                     </reportPlugins>\n                 </configuration>\n             </plugin>\n+\n         </plugins>\n     </build>\n+\n     <profiles>\n         <profile>\n             <id>run-its</id>\n@@ -150,4 +143,5 @@\n             </build>\n         </profile>\n     </profiles>\n+\n </project>\n"
    },
    {
        "commit_hash": "d9e7614203f73b4b8519f7a0b35caf149c33ac2c",
        "previous_commit_hash": "5f14a5e7bc1fd4e465ff333f4574808fbb5c5bb8",
        "diff_stats": {
            "additions": 32,
            "deletions": 32
        },
        "diff_content": "@@ -20,36 +20,36 @@ under the License.\n -->\n \n <settings>\n-  <profiles>\n-    <profile>\n-      <id>it-repo</id>\n-      <activation>\n-        <activeByDefault>true</activeByDefault>\n-      </activation>\n-      <repositories>\n-        <repository>\n-          <id>local.central</id>\n-          <url>@localRepositoryUrl@</url>\n-          <releases>\n-            <enabled>true</enabled>\n-          </releases>\n-          <snapshots>\n-            <enabled>true</enabled>\n-          </snapshots>\n-        </repository>\n-      </repositories>\n-      <pluginRepositories>\n-        <pluginRepository>\n-          <id>local.central</id>\n-          <url>@localRepositoryUrl@</url>\n-          <releases>\n-            <enabled>true</enabled>\n-          </releases>\n-          <snapshots>\n-            <enabled>true</enabled>\n-          </snapshots>\n-        </pluginRepository>\n-      </pluginRepositories>\n-    </profile>\n-  </profiles>\n+    <profiles>\n+        <profile>\n+            <id>it-repo</id>\n+            <activation>\n+                <activeByDefault>true</activeByDefault>\n+            </activation>\n+            <repositories>\n+                <repository>\n+                    <id>local.central</id>\n+                    <url>@localRepositoryUrl@</url>\n+                    <releases>\n+                        <enabled>true</enabled>\n+                    </releases>\n+                    <snapshots>\n+                        <enabled>true</enabled>\n+                    </snapshots>\n+                </repository>\n+            </repositories>\n+            <pluginRepositories>\n+                <pluginRepository>\n+                    <id>local.central</id>\n+                    <url>@localRepositoryUrl@</url>\n+                    <releases>\n+                        <enabled>true</enabled>\n+                    </releases>\n+                    <snapshots>\n+                        <enabled>true</enabled>\n+                    </snapshots>\n+                </pluginRepository>\n+            </pluginRepositories>\n+        </profile>\n+    </profiles>\n </settings>\n"
    },
    {
        "commit_hash": "d9e7614203f73b4b8519f7a0b35caf149c33ac2c",
        "previous_commit_hash": "5f14a5e7bc1fd4e465ff333f4574808fbb5c5bb8",
        "diff_stats": {
            "additions": 27,
            "deletions": 27
        },
        "diff_content": "@@ -1,34 +1,34 @@\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n-  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n-  <modelVersion>4.0.0</modelVersion>\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n \n-  <groupId>net.orfjackal.retrolambda.it</groupId>\n-  <artifactId>simple-it</artifactId>\n-  <version>1.0-SNAPSHOT</version>\n+    <groupId>net.orfjackal.retrolambda.it</groupId>\n+    <artifactId>simple-it</artifactId>\n+    <version>1.0-SNAPSHOT</version>\n \n-  <description>A simple IT verifying the basic use case.</description>\n+    <description>A simple IT verifying the basic use case.</description>\n \n-  <properties>\n-    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n-  </properties>\n+    <properties>\n+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+    </properties>\n \n-  <build>\n-    <plugins>\n-      <plugin>\n-        <groupId>@project.groupId@</groupId>\n-        <artifactId>@project.artifactId@</artifactId>\n-        <version>@project.version@</version>\n-        <executions>\n-          <execution>\n-            <id>touch</id>\n-            <phase>validate</phase>\n-            <goals>\n-              <goal>touch</goal>\n-            </goals>\n-          </execution>\n-        </executions>\n-      </plugin>\n-    </plugins>\n-  </build>\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <groupId>@project.groupId@</groupId>\n+                <artifactId>@project.artifactId@</artifactId>\n+                <version>@project.version@</version>\n+                <executions>\n+                    <execution>\n+                        <id>touch</id>\n+                        <phase>validate</phase>\n+                        <goals>\n+                            <goal>touch</goal>\n+                        </goals>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+        </plugins>\n+    </build>\n </project>\n"
    },
    {
        "commit_hash": "d9e7614203f73b4b8519f7a0b35caf149c33ac2c",
        "previous_commit_hash": "5f14a5e7bc1fd4e465ff333f4574808fbb5c5bb8",
        "diff_stats": {
            "additions": 5,
            "deletions": 1
        },
        "diff_content": "@@ -1,3 +1,7 @@\n-File touchFile = new File( basedir, \"target/touch.txt\" );\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+File touchFile = new File(basedir, \"target/touch.txt\");\n \n assert touchFile.isFile()\n"
    },
    {
        "commit_hash": "d9e7614203f73b4b8519f7a0b35caf149c33ac2c",
        "previous_commit_hash": "5f14a5e7bc1fd4e465ff333f4574808fbb5c5bb8",
        "diff_stats": {
            "additions": 5,
            "deletions": 1
        },
        "diff_content": "@@ -1,5 +1,9 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n package net.orfjackal.retrolambda.maven;\n \n enum ClassesType {\n-    MAIN, TEST;\n+    MAIN, TEST\n }\n"
    },
    {
        "commit_hash": "d9e7614203f73b4b8519f7a0b35caf149c33ac2c",
        "previous_commit_hash": "5f14a5e7bc1fd4e465ff333f4574808fbb5c5bb8",
        "diff_stats": {
            "additions": 154,
            "deletions": 197
        },
        "diff_content": "@@ -1,206 +1,163 @@\n-package net.orfjackal.retrolambda.maven;\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n-import static org.twdata.maven.mojoexecutor.MojoExecutor.artifactId;\n-import static org.twdata.maven.mojoexecutor.MojoExecutor.attribute;\n-import static org.twdata.maven.mojoexecutor.MojoExecutor.attributes;\n-import static org.twdata.maven.mojoexecutor.MojoExecutor.configuration;\n-import static org.twdata.maven.mojoexecutor.MojoExecutor.element;\n-import static org.twdata.maven.mojoexecutor.MojoExecutor.executeMojo;\n-import static org.twdata.maven.mojoexecutor.MojoExecutor.executionEnvironment;\n-import static org.twdata.maven.mojoexecutor.MojoExecutor.goal;\n-import static org.twdata.maven.mojoexecutor.MojoExecutor.groupId;\n-import static org.twdata.maven.mojoexecutor.MojoExecutor.name;\n-import static org.twdata.maven.mojoexecutor.MojoExecutor.plugin;\n-import static org.twdata.maven.mojoexecutor.MojoExecutor.version;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.Properties;\n+package net.orfjackal.retrolambda.maven;\n \n import org.apache.maven.execution.MavenSession;\n-import org.apache.maven.plugin.AbstractMojo;\n-import org.apache.maven.plugin.BuildPluginManager;\n-import org.apache.maven.plugin.MojoExecutionException;\n+import org.apache.maven.plugin.*;\n import org.apache.maven.plugin.logging.Log;\n-import org.apache.maven.plugins.annotations.Component;\n-import org.apache.maven.plugins.annotations.Parameter;\n+import org.apache.maven.plugins.annotations.*;\n import org.apache.maven.project.MavenProject;\n \n+import java.io.*;\n+import java.util.*;\n+\n+import static org.twdata.maven.mojoexecutor.MojoExecutor.*;\n+\n abstract class ProcessClassesMojo extends AbstractMojo {\n \n-\tprivate static final String VERSION_DEPENDENCY = \"2.0\";\n-\tprivate static final String GROUP_ID_DEPENDENCY = \"org.apache.maven.plugins\";\n-\tprivate static final String ARTIFACT_ID_DEPENDENCY = \"maven-dependency-plugin\";\n-\tprivate static final String VERSION_ANTRUN = \"1.7\";\n-\n-\tprivate static final String GROUP_ID_ANTRUN = \"org.apache.maven.plugins\";\n-\tprivate static final String ARTIFACT_ID_ANTRUN = \"maven-antrun-plugin\";\n-\n-\tprivate static final String RETROLAMBDA_JAR = \"retrolambda.jar\";\n-\n-\tprivate final Map<String, Integer> targetBytecodeVersions = new HashMap<String, Integer>();\n-\n-\t@Component\n-\tprivate MavenSession session;\n-\n-\t@Component\n-\tprivate BuildPluginManager pluginManager;\n-\n-\t@Component\n-\tprivate MavenProject project;\n-\n-\t/**\n-\t * The location of the java 8 jdk (not jre).\n-\t */\n-\t@Parameter(required = false, property = \"java8home\", defaultValue = \"${env.JAVA8_HOME}\")\n-\tprivate String java8home;\n-\n-\t/**\n-\t * The java version targeted by the bytecode processing. Possible values are\n-\t * 1.5, 1.6, 1.7 and 1.8. After processing the classes will be compatible\n-\t * with the target jvm provided the known limitations are considered. See <a\n-\t * href=\"https://github.com/orfjackal/retrolambda\">project documentation</a>\n-\t * for more details.\n-\t */\n-\t@Parameter(required = false, property = \"retrolambdaTarget\", defaultValue = \"1.7\")\n-\tprivate String target;\n-\n-\t/**\n-\t * The directory containing the main (non-test) compiled classes. These\n-\t * classes will be overwritten with bytecode changes to obtain compatibility\n-\t * with target java runtime.\n-\t */\n-\t@Parameter(required = false, property = \"retrolambdaMainClassesDir\", defaultValue = \"${project.build.outputDirectory}\")\n-\tprivate String mainClassesDir;\n-\n-\t/**\n-\t * The directory containing the compiled test classes. These classes will be\n-\t * overwritten with bytecode changes to obtain compatibility with target\n-\t * java runtime.\n-\t */\n-\t@Parameter(required = false, property = \"retrolambdaTestClassesDir\", defaultValue = \"${project.build.testOutputDirectory}\")\n-\tprivate String testClassesDir;\n-\n-\tprivate final ClassesType classesType;\n-\n-\t/**\n-\t * Constructor.\n-\t * \n-\t * @param classesType\n-\t */\n-\tProcessClassesMojo(ClassesType classesType) {\n-\t\tthis.classesType = classesType;\n-\t\ttargetBytecodeVersions.put(\"1.5\", 49);\n-\t\ttargetBytecodeVersions.put(\"1.6\", 50);\n-\t\ttargetBytecodeVersions.put(\"1.7\", 51);\n-\t\ttargetBytecodeVersions.put(\"1.8\", 52);\n-\t}\n-\n-\t@Override\n-\tpublic void execute() throws MojoExecutionException {\n-\t\tLog log = getLog();\n-\t\tlog.info(\"starting execution\");\n-\t\tvalidateJava8home();\n-\t\tvalidateTarget();\n-\t\tString retrolambdaVersion = getRetrolambdaVersion();\n-\t\texecuteMojo(\n-\t\t\t\tplugin(groupId(GROUP_ID_DEPENDENCY),\n-\t\t\t\t\t\tartifactId(ARTIFACT_ID_DEPENDENCY),\n-\t\t\t\t\t\tversion(VERSION_DEPENDENCY)),\n-\t\t\t\tgoal(\"copy\"),\n-\t\t\t\tconfiguration(element(\n-\t\t\t\t\t\t\"artifactItems\",\n-\t\t\t\t\t\telement(\"artifactItem\",\n-\t\t\t\t\t\t\t\telement(name(\"groupId\"),\n-\t\t\t\t\t\t\t\t\t\t\"net.orfjackal.retrolambda\"),\n-\t\t\t\t\t\t\t\telement(name(\"artifactId\"), \"retrolambda\"),\n-\t\t\t\t\t\t\t\telement(name(\"version\"), retrolambdaVersion),\n-\t\t\t\t\t\t\t\telement(name(\"overWrite\"), \"true\"),\n-\t\t\t\t\t\t\t\telement(name(\"outputDirectory\"), project\n-\t\t\t\t\t\t\t\t\t\t.getBuild().getDirectory()),\n-\t\t\t\t\t\t\t\telement(name(\"destFileName\"), RETROLAMBDA_JAR)))),\n-\t\t\t\texecutionEnvironment(project, session, pluginManager));\n-\t\tlog.info(\"copied retrolambda.jar to build directory\");\n-\t\tlog.info(\"processing classes\");\n-\t\tif (classesType == ClassesType.MAIN)\n-\t\t\tprocessClasses(mainClassesDir, \"maven.compile.classpath\");\n-\t\telse\n-\t\t\tprocessClasses(testClassesDir, \"maven.test.classpath\");\n-\t\tlog.info(\"processed classes\");\n-\t}\n-\n-\tprivate void validateTarget() throws MojoExecutionException {\n-\t\tif (!targetBytecodeVersions.containsKey(target))\n-\t\t\tthrow new MojoExecutionException(\n-\t\t\t\t\t\"unrecognized target '\"\n-\t\t\t\t\t\t\t+ target\n-\t\t\t\t\t\t\t+ \"'. Possible values are 1.5, 1.6 ,1.7 ,1.8 representing those versions of java.\");\n-\t}\n-\n-\tprivate void validateJava8home() throws MojoExecutionException {\n-\t\tFile jdk = new File(java8home);\n-\t\tif (!jdk.exists() || !jdk.isDirectory()) {\n-\t\t\tthrow new MojoExecutionException(\n-\t\t\t\t\t\"must set configuration element java8home or environment variable JAVA8_HOME to a valid jdk 8 location\");\n-\t\t}\n-\t}\n-\n-\tprivate void processClasses(String input, String classpathId)\n-\t\t\tthrows MojoExecutionException {\n-\n-\t\texecuteMojo(\n-\t\t\t\tplugin(groupId(GROUP_ID_ANTRUN),\n-\t\t\t\t\t\tartifactId(ARTIFACT_ID_ANTRUN), version(VERSION_ANTRUN)),\n-\t\t\t\tgoal(\"run\"),\n-\t\t\t\tconfiguration(element(\n-\t\t\t\t\t\t\"target\",\n-\t\t\t\t\t\telement(\"property\",\n-\t\t\t\t\t\t\t\tattributes(attribute(\"name\", \"the_classpath\"),\n-\t\t\t\t\t\t\t\t\t\tattribute(\"refid\", classpathId))),\n-\t\t\t\t\t\telement(\"exec\",\n-\t\t\t\t\t\t\t\tattributes(\n-\t\t\t\t\t\t\t\t\t\tattribute(\"executable\", java8home\n-\t\t\t\t\t\t\t\t\t\t\t\t+ \"/bin/java\"),\n-\t\t\t\t\t\t\t\t\t\tattribute(\"failonerror\", \"true\")),\n-\t\t\t\t\t\t\t\telement(\"arg\",\n-\t\t\t\t\t\t\t\t\t\tattribute(\n-\t\t\t\t\t\t\t\t\t\t\t\t\"value\",\n-\t\t\t\t\t\t\t\t\t\t\t\t\"-Dretrolambda.bytecodeVersion=\"\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ targetBytecodeVersions\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.get(target))),\n-\t\t\t\t\t\t\t\telement(\"arg\",\n-\t\t\t\t\t\t\t\t\t\tattribute(\"value\",\n-\t\t\t\t\t\t\t\t\t\t\t\t\"-Dretrolambda.inputDir=\"\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ input)),\n-\t\t\t\t\t\t\t\telement(\"arg\",\n-\t\t\t\t\t\t\t\t\t\tattribute(\"value\",\n-\t\t\t\t\t\t\t\t\t\t\t\t\"-Dretrolambda.classpath=${the_classpath}\")),\n-\t\t\t\t\t\t\t\telement(\"arg\",\n-\t\t\t\t\t\t\t\t\t\tattribute(\"value\", \"-javaagent:\"\n-\t\t\t\t\t\t\t\t\t\t\t\t+ project.getBuild()\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t.getDirectory() + \"/\"\n-\t\t\t\t\t\t\t\t\t\t\t\t+ RETROLAMBDA_JAR)),\n-\t\t\t\t\t\t\t\telement(\"arg\", attribute(\"value\", \"-jar\")),\n-\t\t\t\t\t\t\t\telement(\"arg\",\n-\t\t\t\t\t\t\t\t\t\tattribute(\"value\", project.getBuild()\n-\t\t\t\t\t\t\t\t\t\t\t\t.getDirectory()\n-\t\t\t\t\t\t\t\t\t\t\t\t+ \"/\"\n-\t\t\t\t\t\t\t\t\t\t\t\t+ RETROLAMBDA_JAR))))),\n-\t\t\t\texecutionEnvironment(project, session, pluginManager));\n-\t}\n-\n-\tprivate static String getRetrolambdaVersion() {\n-\t\tInputStream is = ProcessClassesMojo.class\n-\t\t\t\t.getResourceAsStream(\"/retrolambda.properties\");\n-\t\tProperties p = new Properties();\n-\t\ttry {\n-\t\t\tp.load(is);\n-\t\t\treturn p.getProperty(\"retrolambda.version\");\n-\t\t} catch (IOException e) {\n-\t\t\tthrow new RuntimeException(e);\n-\t\t}\n-\t}\n+    private static final String VERSION_DEPENDENCY = \"2.0\";\n+    private static final String GROUP_ID_DEPENDENCY = \"org.apache.maven.plugins\";\n+    private static final String ARTIFACT_ID_DEPENDENCY = \"maven-dependency-plugin\";\n+    private static final String VERSION_ANTRUN = \"1.7\";\n+\n+    private static final String GROUP_ID_ANTRUN = \"org.apache.maven.plugins\";\n+    private static final String ARTIFACT_ID_ANTRUN = \"maven-antrun-plugin\";\n+\n+    private static final String RETROLAMBDA_JAR = \"retrolambda.jar\";\n+\n+    private final Map<String, Integer> targetBytecodeVersions = new HashMap<String, Integer>();\n+\n+    @Component\n+    private MavenSession session;\n+\n+    @Component\n+    private BuildPluginManager pluginManager;\n+\n+    @Component\n+    private MavenProject project;\n+\n+    /**\n+     * The location of the Java 8 JDK (not JRE).\n+     */\n+    @Parameter(required = false, property = \"java8home\", defaultValue = \"${env.JAVA8_HOME}\")\n+    private String java8home;\n+\n+    /**\n+     * The Java version targeted by the bytecode processing. Possible values are\n+     * 1.5, 1.6, 1.7 and 1.8. After processing the classes will be compatible\n+     * with the target JVM provided the known limitations are considered. See <a\n+     * href=\"https://github.com/orfjackal/retrolambda\">project documentation</a>\n+     * for more details.\n+     */\n+    @Parameter(required = false, property = \"retrolambdaTarget\", defaultValue = \"1.7\")\n+    private String target;\n+\n+    /**\n+     * The directory containing the main (non-test) compiled classes. These\n+     * classes will be overwritten with bytecode changes to obtain compatibility\n+     * with target Java runtime.\n+     */\n+    @Parameter(required = false, property = \"retrolambdaMainClassesDir\", defaultValue = \"${project.build.outputDirectory}\")\n+    private String mainClassesDir;\n+\n+    /**\n+     * The directory containing the compiled test classes. These classes will be\n+     * overwritten with bytecode changes to obtain compatibility with target\n+     * Java runtime.\n+     */\n+    @Parameter(required = false, property = \"retrolambdaTestClassesDir\", defaultValue = \"${project.build.testOutputDirectory}\")\n+    private String testClassesDir;\n+\n+    private final ClassesType classesType;\n+\n+    ProcessClassesMojo(ClassesType classesType) {\n+        this.classesType = classesType;\n+        targetBytecodeVersions.put(\"1.5\", 49);\n+        targetBytecodeVersions.put(\"1.6\", 50);\n+        targetBytecodeVersions.put(\"1.7\", 51);\n+        targetBytecodeVersions.put(\"1.8\", 52);\n+    }\n+\n+    @Override\n+    public void execute() throws MojoExecutionException {\n+        Log log = getLog();\n+        log.info(\"starting execution\");\n+        validateJava8home();\n+        validateTarget();\n+        String retrolambdaVersion = getRetrolambdaVersion();\n+        executeMojo(\n+                plugin(groupId(GROUP_ID_DEPENDENCY),\n+                        artifactId(ARTIFACT_ID_DEPENDENCY),\n+                        version(VERSION_DEPENDENCY)),\n+                goal(\"copy\"),\n+                configuration(element(\"artifactItems\",\n+                        element(\"artifactItem\",\n+                                element(name(\"groupId\"), \"net.orfjackal.retrolambda\"),\n+                                element(name(\"artifactId\"), \"retrolambda\"),\n+                                element(name(\"version\"), retrolambdaVersion),\n+                                element(name(\"overWrite\"), \"true\"),\n+                                element(name(\"outputDirectory\"), project.getBuild().getDirectory()),\n+                                element(name(\"destFileName\"), RETROLAMBDA_JAR)))),\n+                executionEnvironment(project, session, pluginManager));\n+        log.info(\"copied retrolambda.jar to build directory\");\n+        log.info(\"processing classes\");\n+        if (classesType == ClassesType.MAIN) {\n+            processClasses(mainClassesDir, \"maven.compile.classpath\");\n+        } else {\n+            processClasses(testClassesDir, \"maven.test.classpath\");\n+        }\n+        log.info(\"processed classes\");\n+    }\n+\n+    private void validateTarget() throws MojoExecutionException {\n+        if (!targetBytecodeVersions.containsKey(target)) {\n+            throw new MojoExecutionException(\n+                    \"Unrecognized target '\" + target + \"'. Possible values are 1.5, 1.6, 1.7, 1.8 representing those versions of Java.\");\n+        }\n+    }\n+\n+    private void validateJava8home() throws MojoExecutionException {\n+        File jdk = new File(java8home);\n+        if (!jdk.exists() || !jdk.isDirectory()) {\n+            throw new MojoExecutionException(\"Must set configuration element java8home or environment variable JAVA8_HOME to a valid JDK 8 location\");\n+        }\n+    }\n+\n+    private void processClasses(String input, String classpathId)\n+            throws MojoExecutionException {\n+\n+        executeMojo(\n+                plugin(groupId(GROUP_ID_ANTRUN),\n+                        artifactId(ARTIFACT_ID_ANTRUN), version(VERSION_ANTRUN)),\n+                goal(\"run\"),\n+                configuration(element(\n+                        \"target\",\n+                        element(\"property\",\n+                                attributes(attribute(\"name\", \"the_classpath\"),\n+                                        attribute(\"refid\", classpathId))),\n+                        element(\"exec\",\n+                                attributes(\n+                                        attribute(\"executable\", java8home + \"/bin/java\"),\n+                                        attribute(\"failonerror\", \"true\")),\n+                                element(\"arg\", attribute(\"value\", \"-Dretrolambda.bytecodeVersion=\" + targetBytecodeVersions.get(target))),\n+                                element(\"arg\", attribute(\"value\", \"-Dretrolambda.inputDir=\" + input)),\n+                                element(\"arg\", attribute(\"value\", \"-Dretrolambda.classpath=${the_classpath}\")),\n+                                element(\"arg\", attribute(\"value\", \"-javaagent:\" + project.getBuild().getDirectory() + \"/\" + RETROLAMBDA_JAR)),\n+                                element(\"arg\", attribute(\"value\", \"-jar\")),\n+                                element(\"arg\", attribute(\"value\", project.getBuild().getDirectory() + \"/\" + RETROLAMBDA_JAR))))),\n+                executionEnvironment(project, session, pluginManager));\n+    }\n+\n+    private static String getRetrolambdaVersion() {\n+        InputStream is = ProcessClassesMojo.class.getResourceAsStream(\"/retrolambda.properties\");\n+        Properties p = new Properties();\n+        try {\n+            p.load(is);\n+            return p.getProperty(\"retrolambda.version\");\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n }\n"
    },
    {
        "commit_hash": "d9e7614203f73b4b8519f7a0b35caf149c33ac2c",
        "previous_commit_hash": "5f14a5e7bc1fd4e465ff333f4574808fbb5c5bb8",
        "diff_stats": {
            "additions": 10,
            "deletions": 8
        },
        "diff_content": "@@ -1,17 +1,19 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n package net.orfjackal.retrolambda.maven;\n \n-import org.apache.maven.plugins.annotations.LifecyclePhase;\n-import org.apache.maven.plugins.annotations.Mojo;\n+import org.apache.maven.plugins.annotations.*;\n \n /**\n- * Processes main (non-test) classes compiled with java 8 so that they are\n- * compatible with java 5,6 or 7 runtime.\n+ * Processes main (non-test) classes compiled with Java 8 so that they will be\n+ * compatible with Java 5, 6 or 7 runtime.\n  */\n @Mojo(name = \"process-main\", defaultPhase = LifecyclePhase.PROCESS_CLASSES)\n public class ProcessMainClassesMojo extends ProcessClassesMojo {\n \n-\tpublic ProcessMainClassesMojo() {\n-\t\tsuper(ClassesType.MAIN);\n-\t}\n-\n+    public ProcessMainClassesMojo() {\n+        super(ClassesType.MAIN);\n+    }\n }\n"
    },
    {
        "commit_hash": "d9e7614203f73b4b8519f7a0b35caf149c33ac2c",
        "previous_commit_hash": "5f14a5e7bc1fd4e465ff333f4574808fbb5c5bb8",
        "diff_stats": {
            "additions": 10,
            "deletions": 7
        },
        "diff_content": "@@ -1,16 +1,19 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n package net.orfjackal.retrolambda.maven;\n \n-import org.apache.maven.plugins.annotations.LifecyclePhase;\n-import org.apache.maven.plugins.annotations.Mojo;\n+import org.apache.maven.plugins.annotations.*;\n \n /**\n- * Processes test classes compiled with java 8 so that they are compatible with\n- * java 5,6 or 7 runtime.\n+ * Processes test classes compiled with Java 8 so that they will be compatible with\n+ * Java 5, 6 or 7 runtime.\n  */\n @Mojo(name = \"process-test\", defaultPhase = LifecyclePhase.PROCESS_TEST_CLASSES)\n public class ProcessTestClassesMojo extends ProcessClassesMojo {\n \n-\tpublic ProcessTestClassesMojo() {\n-\t\tsuper(ClassesType.TEST);\n-\t}\n+    public ProcessTestClassesMojo() {\n+        super(ClassesType.TEST);\n+    }\n }\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "c5063922735d7428b82c4b68f4fda6acf9f7443f",
        "previous_commit_hash": "d9e7614203f73b4b8519f7a0b35caf149c33ac2c",
        "diff_stats": {
            "additions": 0,
            "deletions": 39
        },
        "diff_content": "@@ -105,43 +105,4 @@\n         </plugins>\n     </build>\n \n-    <profiles>\n-        <profile>\n-            <id>run-its</id>\n-            <build>\n-                <plugins>\n-                    <plugin>\n-                        <groupId>org.apache.maven.plugins</groupId>\n-                        <artifactId>maven-invoker-plugin</artifactId>\n-                        <version>1.7</version>\n-                        <configuration>\n-                            <debug>true</debug>\n-                            <cloneProjectsTo>${project.build.directory}/it</cloneProjectsTo>\n-                            <pomIncludes>\n-                                <pomInclude>*/pom.xml</pomInclude>\n-                            </pomIncludes>\n-                            <postBuildHookScript>verify</postBuildHookScript>\n-                            <localRepositoryPath>${project.build.directory}/local-repo</localRepositoryPath>\n-                            <settingsFile>src/it/settings.xml</settingsFile>\n-                            <goals>\n-                                <goal>clean</goal>\n-                                <goal>test-compile</goal>\n-                            </goals>\n-                        </configuration>\n-                        <executions>\n-                            <execution>\n-                                <id>integration-test</id>\n-                                <goals>\n-                                    <goal>install</goal>\n-                                    <goal>integration-test</goal>\n-                                    <goal>verify</goal>\n-                                </goals>\n-                            </execution>\n-                        </executions>\n-                    </plugin>\n-                </plugins>\n-            </build>\n-        </profile>\n-    </profiles>\n-\n </project>\n"
    },
    {
        "commit_hash": "c5063922735d7428b82c4b68f4fda6acf9f7443f",
        "previous_commit_hash": "d9e7614203f73b4b8519f7a0b35caf149c33ac2c",
        "diff_stats": {
            "additions": 0,
            "deletions": 54
        },
        "diff_content": "@@ -1,55 +0,0 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n-\n-<!--\n-Licensed to the Apache Software Foundation (ASF) under one\n-or more contributor license agreements.  See the NOTICE file\n-distributed with this work for additional information\n-regarding copyright ownership.  The ASF licenses this file\n-to you under the Apache License, Version 2.0 (the\n-\"License\"); you may not use this file except in compliance\n-with the License.  You may obtain a copy of the License at\n-\n-  http://www.apache.org/licenses/LICENSE-2.0\n-\n-Unless required by applicable law or agreed to in writing,\n-software distributed under the License is distributed on an\n-\"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n-KIND, either express or implied.  See the License for the\n-specific language governing permissions and limitations\n-under the License.\n--->\n-\n-<settings>\n-    <profiles>\n-        <profile>\n-            <id>it-repo</id>\n-            <activation>\n-                <activeByDefault>true</activeByDefault>\n-            </activation>\n-            <repositories>\n-                <repository>\n-                    <id>local.central</id>\n-                    <url>@localRepositoryUrl@</url>\n-                    <releases>\n-                        <enabled>true</enabled>\n-                    </releases>\n-                    <snapshots>\n-                        <enabled>true</enabled>\n-                    </snapshots>\n-                </repository>\n-            </repositories>\n-            <pluginRepositories>\n-                <pluginRepository>\n-                    <id>local.central</id>\n-                    <url>@localRepositoryUrl@</url>\n-                    <releases>\n-                        <enabled>true</enabled>\n-                    </releases>\n-                    <snapshots>\n-                        <enabled>true</enabled>\n-                    </snapshots>\n-                </pluginRepository>\n-            </pluginRepositories>\n-        </profile>\n-    </profiles>\n-</settings>\n"
    },
    {
        "commit_hash": "c5063922735d7428b82c4b68f4fda6acf9f7443f",
        "previous_commit_hash": "d9e7614203f73b4b8519f7a0b35caf149c33ac2c",
        "diff_stats": {
            "additions": 0,
            "deletions": 34
        },
        "diff_content": "@@ -1,34 +0,0 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n-<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n-         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n-    <modelVersion>4.0.0</modelVersion>\n-\n-    <groupId>net.orfjackal.retrolambda.it</groupId>\n-    <artifactId>simple-it</artifactId>\n-    <version>1.0-SNAPSHOT</version>\n-\n-    <description>A simple IT verifying the basic use case.</description>\n-\n-    <properties>\n-        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n-    </properties>\n-\n-    <build>\n-        <plugins>\n-            <plugin>\n-                <groupId>@project.groupId@</groupId>\n-                <artifactId>@project.artifactId@</artifactId>\n-                <version>@project.version@</version>\n-                <executions>\n-                    <execution>\n-                        <id>touch</id>\n-                        <phase>validate</phase>\n-                        <goals>\n-                            <goal>touch</goal>\n-                        </goals>\n-                    </execution>\n-                </executions>\n-            </plugin>\n-        </plugins>\n-    </build>\n-</project>\n"
    },
    {
        "commit_hash": "c5063922735d7428b82c4b68f4fda6acf9f7443f",
        "previous_commit_hash": "d9e7614203f73b4b8519f7a0b35caf149c33ac2c",
        "diff_stats": {
            "additions": 0,
            "deletions": 7
        },
        "diff_content": "@@ -1,7 +0,0 @@\n-// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n-// This software is released under the Apache License 2.0.\n-// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n-\n-File touchFile = new File(basedir, \"target/touch.txt\");\n-\n-assert touchFile.isFile()\n"
    },
    {
        "commit_hash": "5be7362f4998f13bac623f95afed7d35eb4490a8",
        "previous_commit_hash": "c5063922735d7428b82c4b68f4fda6acf9f7443f",
        "diff_stats": {
            "additions": 4,
            "deletions": 1
        },
        "diff_content": "@@ -17,10 +17,13 @@\n         <processorPath useClasspath=\"true\" />\n         <module name=\"end-to-end-tests\" />\n         <module name=\"retrolambda\" />\n+        <module name=\"retrolambda-maven-plugin\" />\n         <module name=\"retrolambda-runtime (1)\" />\n       </profile>\n     </annotationProcessing>\n-    <bytecodeTargetLevel target=\"1.8\" />\n+    <bytecodeTargetLevel target=\"1.8\">\n+      <module name=\"retrolambda-maven-plugin\" target=\"1.6\" />\n+    </bytecodeTargetLevel>\n   </component>\n </project>\n \n"
    },
    {
        "commit_hash": "5be7362f4998f13bac623f95afed7d35eb4490a8",
        "previous_commit_hash": "c5063922735d7428b82c4b68f4fda6acf9f7443f",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -5,6 +5,7 @@\n     <file url=\"file://$PROJECT_DIR$/end-to-end-tests\" charset=\"UTF-8\" />\n     <file url=\"file://$PROJECT_DIR$/parent\" charset=\"UTF-8\" />\n     <file url=\"file://$PROJECT_DIR$/retrolambda\" charset=\"UTF-8\" />\n+    <file url=\"file://$PROJECT_DIR$/retrolambda-maven-plugin\" charset=\"UTF-8\" />\n     <file url=\"PROJECT\" charset=\"UTF-8\" />\n   </component>\n </project>\n"
    },
    {
        "commit_hash": "5be7362f4998f13bac623f95afed7d35eb4490a8",
        "previous_commit_hash": "c5063922735d7428b82c4b68f4fda6acf9f7443f",
        "diff_stats": {
            "additions": 5,
            "deletions": 0
        },
        "diff_content": "@@ -2,6 +2,11 @@\n <project version=\"4\">\n   <component name=\"EntryPointsManager\">\n     <entry_points version=\"2.0\" />\n+    <list size=\"3\">\n+      <item index=\"0\" class=\"java.lang.String\" itemvalue=\"org.apache.maven.plugins.annotations.Component\" />\n+      <item index=\"1\" class=\"java.lang.String\" itemvalue=\"org.apache.maven.plugins.annotations.Mojo\" />\n+      <item index=\"2\" class=\"java.lang.String\" itemvalue=\"org.apache.maven.plugins.annotations.Parameter\" />\n+    </list>\n   </component>\n   <component name=\"JavadocGenerationManager\">\n     <option name=\"OUTPUT_DIRECTORY\" />\n"
    },
    {
        "commit_hash": "5be7362f4998f13bac623f95afed7d35eb4490a8",
        "previous_commit_hash": "c5063922735d7428b82c4b68f4fda6acf9f7443f",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -6,6 +6,7 @@\n       <module fileurl=\"file://$PROJECT_DIR$/parent/parent.iml\" filepath=\"$PROJECT_DIR$/parent/parent.iml\" />\n       <module fileurl=\"file://$PROJECT_DIR$/project.iml\" filepath=\"$PROJECT_DIR$/project.iml\" />\n       <module fileurl=\"file://$PROJECT_DIR$/retrolambda/retrolambda.iml\" filepath=\"$PROJECT_DIR$/retrolambda/retrolambda.iml\" />\n+      <module fileurl=\"file://$PROJECT_DIR$/retrolambda-maven-plugin/retrolambda-maven-plugin.iml\" filepath=\"$PROJECT_DIR$/retrolambda-maven-plugin/retrolambda-maven-plugin.iml\" />\n     </modules>\n   </component>\n </project>\n"
    },
    {
        "commit_hash": "a0a960fbf53d0f9866d33d16151b8679688cd9f2",
        "previous_commit_hash": "5be7362f4998f13bac623f95afed7d35eb4490a8",
        "diff_stats": {
            "additions": 2,
            "deletions": 73
        },
        "diff_content": "@@ -50,92 +50,20 @@\n             <plugin>\n                 <groupId>net.orfjackal.retrolambda</groupId>\n                 <artifactId>retrolambda-maven-plugin</artifactId>\n-                <version>${project.parent.version}</version>\n+                <version>${project.version}</version>\n                 <executions>\n                     <execution>\n                         <goals>\n                             <goal>process-main</goal>\n                             <goal>process-test</goal>\n                         </goals>\n-                    </execution>\n-                </executions>\n-            </plugin>\n-\n-\t<!-- alternatively, can use a call to the dependency plugin and antrun plugins for fine control of retrolambda parameters -->\n-    <!-- although optimally all such use should be through the maven plugin above. Request changes if you need them! -->\n-\t<!-- if people are happy we could delete this block now -->\n-\t<!--\n-            <plugin>\n-                <artifactId>maven-dependency-plugin</artifactId>\n-                <executions>\n-                    <execution>\n-                        <id>copy-retrolambda</id>\n-                        <phase>process-classes</phase>\n-                        <goals>\n-                            <goal>copy</goal>\n-                        </goals>\n                         <configuration>\n-                            <artifactItems>\n-                                <artifactItem>\n-                                    <groupId>net.orfjackal.retrolambda</groupId>\n-                                    <artifactId>retrolambda</artifactId>\n-                                    <version>${project.version}</version>\n-                                    <overWrite>true</overWrite>\n-                                    <outputDirectory>${project.build.directory}</outputDirectory>\n-                                    <destFileName>retrolambda.jar</destFileName>\n-                                </artifactItem>\n-                            </artifactItems>\n+                            <target>${testBytecodeTarget}</target>\n                         </configuration>\n                     </execution>\n                 </executions>\n             </plugin>\n \n-            <plugin>\n-                <artifactId>maven-antrun-plugin</artifactId>\n-                <executions>\n-                    <execution>\n-                        <id>retrolambda-classes</id>\n-                        <phase>process-classes</phase>\n-                        <goals>\n-                            <goal>run</goal>\n-                        </goals>\n-                        <configuration>\n-                            <target>\n-                                <property name=\"compile_classpath\" refid=\"maven.compile.classpath\"/>\n-                                <exec executable=\"${env.JAVA8_HOME}/bin/java\" failonerror=\"true\">\n-                                    <arg value=\"-Dretrolambda.bytecodeVersion=${testBytecodeVersion}\"/>\n-                                    <arg value=\"-Dretrolambda.inputDir=${project.build.outputDirectory}\"/>\n-                                    <arg value=\"-Dretrolambda.classpath=${compile_classpath}\"/>\n-                                    <arg value=\"-javaagent:${project.build.directory}/retrolambda.jar\"/>\n-                                    <arg value=\"-jar\"/>\n-                                    <arg value=\"${project.build.directory}/retrolambda.jar\"/>\n-                                </exec>\n-                            </target>\n-                        </configuration>\n-                    </execution>\n-                    <execution>\n-                        <id>retrolambda-test-classes</id>\n-                        <phase>process-test-classes</phase>\n-                        <goals>\n-                            <goal>run</goal>\n-                        </goals>\n-                        <configuration>\n-                            <target>\n-                                <property name=\"test_classpath\" refid=\"maven.test.classpath\"/>\n-                                <exec executable=\"${env.JAVA8_HOME}/bin/java\" failonerror=\"true\">\n-                                    <arg value=\"-Dretrolambda.bytecodeVersion=${testBytecodeVersion}\"/>\n-                                    <arg value=\"-Dretrolambda.inputDir=${project.build.testOutputDirectory}\"/>\n-                                    <arg value=\"-Dretrolambda.classpath=${test_classpath}\"/>\n-                                    <arg value=\"-javaagent:${project.build.directory}/retrolambda.jar\"/>\n-                                    <arg value=\"-jar\"/>\n-                                    <arg value=\"${project.build.directory}/retrolambda.jar\"/>\n-                                </exec>\n-                            </target>\n-                        </configuration>\n-                    </execution>\n-                </executions>\n-            </plugin>\n--->\n         </plugins>\n     </build>\n \n"
    },
    {
        "commit_hash": "a0a960fbf53d0f9866d33d16151b8679688cd9f2",
        "previous_commit_hash": "5be7362f4998f13bac623f95afed7d35eb4490a8",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -45,7 +45,7 @@\n         <minimumMavenVersion>3.0.3</minimumMavenVersion>\n         <compileJavaHome>${env.JAVA8_HOME}</compileJavaHome>\n         <testJavaHome>${env.JAVA7_HOME}</testJavaHome>\n-        <testBytecodeVersion>51</testBytecodeVersion>\n+        <testBytecodeTarget>1.7</testBytecodeTarget>\n     </properties>\n \n     <prerequisites>\n@@ -355,14 +355,14 @@\n             <id>java6</id>\n             <properties>\n                 <testJavaHome>${env.JAVA6_HOME}</testJavaHome>\n-                <testBytecodeVersion>50</testBytecodeVersion>\n+                <testBytecodeTarget>1.6</testBytecodeTarget>\n             </properties>\n         </profile>\n         <profile>\n             <id>java5</id>\n             <properties>\n                 <testJavaHome>${env.JAVA5_HOME}</testJavaHome>\n-                <testBytecodeVersion>49</testBytecodeVersion>\n+                <testBytecodeTarget>1.5</testBytecodeTarget>\n             </properties>\n         </profile>\n     </profiles>\n"
    },
    {
        "commit_hash": "7b4f515b2640e7ae2daa72a3ace1f98321c55e26",
        "previous_commit_hash": "a0a960fbf53d0f9866d33d16151b8679688cd9f2",
        "diff_stats": {
            "additions": 10,
            "deletions": 7
        },
        "diff_content": "@@ -13,6 +13,7 @@\n     <packaging>maven-plugin</packaging>\n \n     <dependencies>\n+\n         <dependency>\n             <groupId>org.apache.maven</groupId>\n             <artifactId>maven-plugin-api</artifactId>\n@@ -24,26 +25,28 @@\n             <version>3.2</version>\n             <scope>provided</scope>\n         </dependency>\n+\n         <dependency>\n             <groupId>org.codehaus.plexus</groupId>\n             <artifactId>plexus-utils</artifactId>\n             <version>3.0.8</version>\n         </dependency>\n+\n         <dependency>\n             <groupId>org.twdata.maven</groupId>\n             <artifactId>mojo-executor</artifactId>\n             <version>2.2.0</version>\n         </dependency>\n+\n+        <dependency>\n+            <groupId>com.google.guava</groupId>\n+            <artifactId>guava</artifactId>\n+            <version>17.0</version>\n+        </dependency>\n+\n     </dependencies>\n \n     <build>\n-        <resources>\n-            <resource>\n-                <directory>src/main/resources</directory>\n-                <filtering>true</filtering>\n-            </resource>\n-        </resources>\n-\n         <plugins>\n \n             <plugin>\n"
    },
    {
        "commit_hash": "7b4f515b2640e7ae2daa72a3ace1f98321c55e26",
        "previous_commit_hash": "a0a960fbf53d0f9866d33d16151b8679688cd9f2",
        "diff_stats": {
            "additions": 36,
            "deletions": 41
        },
        "diff_content": "@@ -4,9 +4,9 @@\n \n package net.orfjackal.retrolambda.maven;\n \n+import com.google.common.base.Joiner;\n import org.apache.maven.execution.MavenSession;\n import org.apache.maven.plugin.*;\n-import org.apache.maven.plugin.logging.Log;\n import org.apache.maven.plugins.annotations.*;\n import org.apache.maven.project.MavenProject;\n \n@@ -17,14 +17,6 @@ import static org.twdata.maven.mojoexecutor.MojoExecutor.*;\n \n abstract class ProcessClassesMojo extends AbstractMojo {\n \n-    private static final String VERSION_DEPENDENCY = \"2.0\";\n-    private static final String GROUP_ID_DEPENDENCY = \"org.apache.maven.plugins\";\n-    private static final String ARTIFACT_ID_DEPENDENCY = \"maven-dependency-plugin\";\n-    private static final String VERSION_ANTRUN = \"1.7\";\n-\n-    private static final String GROUP_ID_ANTRUN = \"org.apache.maven.plugins\";\n-    private static final String ARTIFACT_ID_ANTRUN = \"maven-antrun-plugin\";\n-\n     private static final String RETROLAMBDA_JAR = \"retrolambda.jar\";\n \n     private final Map<String, Integer> targetBytecodeVersions = new HashMap<String, Integer>();\n@@ -42,17 +34,17 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n      * The location of the Java 8 JDK (not JRE).\n      */\n     @Parameter(required = false, property = \"java8home\", defaultValue = \"${env.JAVA8_HOME}\")\n-    private String java8home;\n+    public String java8home;\n \n     /**\n      * The Java version targeted by the bytecode processing. Possible values are\n      * 1.5, 1.6, 1.7 and 1.8. After processing the classes will be compatible\n-     * with the target JVM provided the known limitations are considered. See <a\n-     * href=\"https://github.com/orfjackal/retrolambda\">project documentation</a>\n+     * with the target JVM provided the known limitations are considered. See\n+     * <a href=\"https://github.com/orfjackal/retrolambda\">project documentation</a>\n      * for more details.\n      */\n     @Parameter(required = false, property = \"retrolambdaTarget\", defaultValue = \"1.7\")\n-    private String target;\n+    public String target;\n \n     /**\n      * The directory containing the main (non-test) compiled classes. These\n@@ -60,7 +52,7 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n      * with target Java runtime.\n      */\n     @Parameter(required = false, property = \"retrolambdaMainClassesDir\", defaultValue = \"${project.build.outputDirectory}\")\n-    private String mainClassesDir;\n+    public String mainClassesDir;\n \n     /**\n      * The directory containing the compiled test classes. These classes will be\n@@ -68,7 +60,7 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n      * Java runtime.\n      */\n     @Parameter(required = false, property = \"retrolambdaTestClassesDir\", defaultValue = \"${project.build.testOutputDirectory}\")\n-    private String testClassesDir;\n+    public String testClassesDir;\n \n     private final ClassesType classesType;\n \n@@ -82,55 +74,53 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n \n     @Override\n     public void execute() throws MojoExecutionException {\n-        Log log = getLog();\n-        log.info(\"starting execution\");\n         validateJava8home();\n         validateTarget();\n-        String retrolambdaVersion = getRetrolambdaVersion();\n+\n+        getLog().info(\"Retrieving the Retrolambda JAR\");\n         executeMojo(\n-                plugin(groupId(GROUP_ID_DEPENDENCY),\n-                        artifactId(ARTIFACT_ID_DEPENDENCY),\n-                        version(VERSION_DEPENDENCY)),\n+                plugin(groupId(\"org.apache.maven.plugins\"),\n+                        artifactId(\"maven-dependency-plugin\"),\n+                        version(\"2.0\")),\n                 goal(\"copy\"),\n                 configuration(element(\"artifactItems\",\n                         element(\"artifactItem\",\n                                 element(name(\"groupId\"), \"net.orfjackal.retrolambda\"),\n                                 element(name(\"artifactId\"), \"retrolambda\"),\n-                                element(name(\"version\"), retrolambdaVersion),\n+                                element(name(\"version\"), getRetrolambdaVersion()),\n                                 element(name(\"overWrite\"), \"true\"),\n                                 element(name(\"outputDirectory\"), project.getBuild().getDirectory()),\n                                 element(name(\"destFileName\"), RETROLAMBDA_JAR)))),\n                 executionEnvironment(project, session, pluginManager));\n-        log.info(\"copied retrolambda.jar to build directory\");\n-        log.info(\"processing classes\");\n+\n+        getLog().info(\"Processing classes with Retrolambda\");\n         if (classesType == ClassesType.MAIN) {\n             processClasses(mainClassesDir, \"maven.compile.classpath\");\n         } else {\n             processClasses(testClassesDir, \"maven.test.classpath\");\n         }\n-        log.info(\"processed classes\");\n     }\n \n     private void validateTarget() throws MojoExecutionException {\n         if (!targetBytecodeVersions.containsKey(target)) {\n+            String possibleValues = Joiner.on(\", \").join(new ArrayList<String>(targetBytecodeVersions.keySet()));\n             throw new MojoExecutionException(\n-                    \"Unrecognized target '\" + target + \"'. Possible values are 1.5, 1.6, 1.7, 1.8 representing those versions of Java.\");\n+                    \"Unrecognized target '\" + target + \"'. Possible values are \" + possibleValues);\n         }\n     }\n \n     private void validateJava8home() throws MojoExecutionException {\n-        File jdk = new File(java8home);\n-        if (!jdk.exists() || !jdk.isDirectory()) {\n-            throw new MojoExecutionException(\"Must set configuration element java8home or environment variable JAVA8_HOME to a valid JDK 8 location\");\n+        if (!new File(java8home).isDirectory()) {\n+            throw new MojoExecutionException(\n+                    \"Must set configuration element java8home or environment variable JAVA8_HOME to a valid JDK 8 location: \" + java8home);\n         }\n     }\n \n-    private void processClasses(String input, String classpathId)\n-            throws MojoExecutionException {\n-\n+    private void processClasses(String inputDir, String classpathId) throws MojoExecutionException {\n         executeMojo(\n-                plugin(groupId(GROUP_ID_ANTRUN),\n-                        artifactId(ARTIFACT_ID_ANTRUN), version(VERSION_ANTRUN)),\n+                plugin(groupId(\"org.apache.maven.plugins\"),\n+                        artifactId(\"maven-antrun-plugin\"),\n+                        version(\"1.7\")),\n                 goal(\"run\"),\n                 configuration(element(\n                         \"target\",\n@@ -142,7 +132,7 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n                                         attribute(\"executable\", java8home + \"/bin/java\"),\n                                         attribute(\"failonerror\", \"true\")),\n                                 element(\"arg\", attribute(\"value\", \"-Dretrolambda.bytecodeVersion=\" + targetBytecodeVersions.get(target))),\n-                                element(\"arg\", attribute(\"value\", \"-Dretrolambda.inputDir=\" + input)),\n+                                element(\"arg\", attribute(\"value\", \"-Dretrolambda.inputDir=\" + inputDir)),\n                                 element(\"arg\", attribute(\"value\", \"-Dretrolambda.classpath=${the_classpath}\")),\n                                 element(\"arg\", attribute(\"value\", \"-javaagent:\" + project.getBuild().getDirectory() + \"/\" + RETROLAMBDA_JAR)),\n                                 element(\"arg\", attribute(\"value\", \"-jar\")),\n@@ -150,14 +140,19 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n                 executionEnvironment(project, session, pluginManager));\n     }\n \n-    private static String getRetrolambdaVersion() {\n-        InputStream is = ProcessClassesMojo.class.getResourceAsStream(\"/retrolambda.properties\");\n-        Properties p = new Properties();\n+    private static String getRetrolambdaVersion() throws MojoExecutionException {\n         try {\n-            p.load(is);\n-            return p.getProperty(\"retrolambda.version\");\n+            InputStream is = ProcessClassesMojo.class.getResourceAsStream(\n+                    \"/META-INF/maven/net.orfjackal.retrolambda/retrolambda-maven-plugin/pom.properties\");\n+            try {\n+                Properties p = new Properties();\n+                p.load(is);\n+                return p.getProperty(\"version\");\n+            } finally {\n+                is.close();\n+            }\n         } catch (IOException e) {\n-            throw new RuntimeException(e);\n+            throw new MojoExecutionException(\"Failed to detect the Retrolambda version\", e);\n         }\n     }\n }\n"
    },
    {
        "commit_hash": "7b4f515b2640e7ae2daa72a3ace1f98321c55e26",
        "previous_commit_hash": "a0a960fbf53d0f9866d33d16151b8679688cd9f2",
        "diff_stats": {
            "additions": 0,
            "deletions": 1
        },
        "diff_content": "@@ -1 +0,0 @@\n-retrolambda.version=${project.version}\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "7b4f515b2640e7ae2daa72a3ace1f98321c55e26",
        "previous_commit_hash": "a0a960fbf53d0f9866d33d16151b8679688cd9f2",
        "diff_stats": {
            "additions": 32,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,32 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.maven;\n+\n+import org.apache.maven.plugin.MojoExecutionException;\n+import org.junit.*;\n+import org.junit.rules.ExpectedException;\n+\n+public class ProcessClassesMojoTest {\n+\n+    private final ProcessMainClassesMojo mojo = new ProcessMainClassesMojo();\n+\n+    @Rule\n+    public final ExpectedException thrown = ExpectedException.none();\n+\n+    @Before\n+    public void sensibleDefaults() {\n+        mojo.target = \"1.7\";\n+        mojo.java8home = System.getProperty(\"java.home\");\n+    }\n+\n+    @Test\n+    public void error_message_lists_the_accepted_targets() throws MojoExecutionException {\n+        mojo.target = \"1.0\";\n+\n+        thrown.expect(MojoExecutionException.class);\n+        thrown.expectMessage(\"1.5, 1.6, 1.7, 1.8\");\n+        mojo.execute();\n+    }\n+}\n"
    },
    {
        "commit_hash": "f82106170a10b118baf06be1d068826a4b5a69dc",
        "previous_commit_hash": "7b4f515b2640e7ae2daa72a3ace1f98321c55e26",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,13 @@\n+<component name=\"libraryTable\">\n+  <library name=\"Maven: com.google.guava:guava:17.0\">\n+    <CLASSES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/com/google/guava/guava/17.0/guava-17.0.jar!/\" />\n+    </CLASSES>\n+    <JAVADOC>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/com/google/guava/guava/17.0/guava-17.0-javadoc.jar!/\" />\n+    </JAVADOC>\n+    <SOURCES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/com/google/guava/guava/17.0/guava-17.0-sources.jar!/\" />\n+    </SOURCES>\n+  </library>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "f82106170a10b118baf06be1d068826a4b5a69dc",
        "previous_commit_hash": "7b4f515b2640e7ae2daa72a3ace1f98321c55e26",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,13 @@\n+<component name=\"libraryTable\">\n+  <library name=\"Maven: org.apache.maven:maven-aether-provider:3.0\">\n+    <CLASSES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/maven/maven-aether-provider/3.0/maven-aether-provider-3.0.jar!/\" />\n+    </CLASSES>\n+    <JAVADOC>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/maven/maven-aether-provider/3.0/maven-aether-provider-3.0-javadoc.jar!/\" />\n+    </JAVADOC>\n+    <SOURCES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/maven/maven-aether-provider/3.0/maven-aether-provider-3.0-sources.jar!/\" />\n+    </SOURCES>\n+  </library>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "f82106170a10b118baf06be1d068826a4b5a69dc",
        "previous_commit_hash": "7b4f515b2640e7ae2daa72a3ace1f98321c55e26",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,13 @@\n+<component name=\"libraryTable\">\n+  <library name=\"Maven: org.apache.maven:maven-artifact:3.0\">\n+    <CLASSES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/maven/maven-artifact/3.0/maven-artifact-3.0.jar!/\" />\n+    </CLASSES>\n+    <JAVADOC>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/maven/maven-artifact/3.0/maven-artifact-3.0-javadoc.jar!/\" />\n+    </JAVADOC>\n+    <SOURCES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/maven/maven-artifact/3.0/maven-artifact-3.0-sources.jar!/\" />\n+    </SOURCES>\n+  </library>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "f82106170a10b118baf06be1d068826a4b5a69dc",
        "previous_commit_hash": "7b4f515b2640e7ae2daa72a3ace1f98321c55e26",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,13 @@\n+<component name=\"libraryTable\">\n+  <library name=\"Maven: org.apache.maven:maven-core:3.0\">\n+    <CLASSES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/maven/maven-core/3.0/maven-core-3.0.jar!/\" />\n+    </CLASSES>\n+    <JAVADOC>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/maven/maven-core/3.0/maven-core-3.0-javadoc.jar!/\" />\n+    </JAVADOC>\n+    <SOURCES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/maven/maven-core/3.0/maven-core-3.0-sources.jar!/\" />\n+    </SOURCES>\n+  </library>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "f82106170a10b118baf06be1d068826a4b5a69dc",
        "previous_commit_hash": "7b4f515b2640e7ae2daa72a3ace1f98321c55e26",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,13 @@\n+<component name=\"libraryTable\">\n+  <library name=\"Maven: org.apache.maven:maven-model:3.0\">\n+    <CLASSES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/maven/maven-model/3.0/maven-model-3.0.jar!/\" />\n+    </CLASSES>\n+    <JAVADOC>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/maven/maven-model/3.0/maven-model-3.0-javadoc.jar!/\" />\n+    </JAVADOC>\n+    <SOURCES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/maven/maven-model/3.0/maven-model-3.0-sources.jar!/\" />\n+    </SOURCES>\n+  </library>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "f82106170a10b118baf06be1d068826a4b5a69dc",
        "previous_commit_hash": "7b4f515b2640e7ae2daa72a3ace1f98321c55e26",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,13 @@\n+<component name=\"libraryTable\">\n+  <library name=\"Maven: org.apache.maven:maven-model-builder:3.0\">\n+    <CLASSES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/maven/maven-model-builder/3.0/maven-model-builder-3.0.jar!/\" />\n+    </CLASSES>\n+    <JAVADOC>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/maven/maven-model-builder/3.0/maven-model-builder-3.0-javadoc.jar!/\" />\n+    </JAVADOC>\n+    <SOURCES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/maven/maven-model-builder/3.0/maven-model-builder-3.0-sources.jar!/\" />\n+    </SOURCES>\n+  </library>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "f82106170a10b118baf06be1d068826a4b5a69dc",
        "previous_commit_hash": "7b4f515b2640e7ae2daa72a3ace1f98321c55e26",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,13 @@\n+<component name=\"libraryTable\">\n+  <library name=\"Maven: org.apache.maven:maven-plugin-api:2.0\">\n+    <CLASSES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/maven/maven-plugin-api/2.0/maven-plugin-api-2.0.jar!/\" />\n+    </CLASSES>\n+    <JAVADOC>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/maven/maven-plugin-api/2.0/maven-plugin-api-2.0-javadoc.jar!/\" />\n+    </JAVADOC>\n+    <SOURCES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/maven/maven-plugin-api/2.0/maven-plugin-api-2.0-sources.jar!/\" />\n+    </SOURCES>\n+  </library>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "f82106170a10b118baf06be1d068826a4b5a69dc",
        "previous_commit_hash": "7b4f515b2640e7ae2daa72a3ace1f98321c55e26",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,13 @@\n+<component name=\"libraryTable\">\n+  <library name=\"Maven: org.apache.maven:maven-repository-metadata:3.0\">\n+    <CLASSES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/maven/maven-repository-metadata/3.0/maven-repository-metadata-3.0.jar!/\" />\n+    </CLASSES>\n+    <JAVADOC>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/maven/maven-repository-metadata/3.0/maven-repository-metadata-3.0-javadoc.jar!/\" />\n+    </JAVADOC>\n+    <SOURCES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/maven/maven-repository-metadata/3.0/maven-repository-metadata-3.0-sources.jar!/\" />\n+    </SOURCES>\n+  </library>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "f82106170a10b118baf06be1d068826a4b5a69dc",
        "previous_commit_hash": "7b4f515b2640e7ae2daa72a3ace1f98321c55e26",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,13 @@\n+<component name=\"libraryTable\">\n+  <library name=\"Maven: org.apache.maven:maven-settings:3.0\">\n+    <CLASSES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/maven/maven-settings/3.0/maven-settings-3.0.jar!/\" />\n+    </CLASSES>\n+    <JAVADOC>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/maven/maven-settings/3.0/maven-settings-3.0-javadoc.jar!/\" />\n+    </JAVADOC>\n+    <SOURCES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/maven/maven-settings/3.0/maven-settings-3.0-sources.jar!/\" />\n+    </SOURCES>\n+  </library>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "f82106170a10b118baf06be1d068826a4b5a69dc",
        "previous_commit_hash": "7b4f515b2640e7ae2daa72a3ace1f98321c55e26",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,13 @@\n+<component name=\"libraryTable\">\n+  <library name=\"Maven: org.apache.maven:maven-settings-builder:3.0\">\n+    <CLASSES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/maven/maven-settings-builder/3.0/maven-settings-builder-3.0.jar!/\" />\n+    </CLASSES>\n+    <JAVADOC>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/maven/maven-settings-builder/3.0/maven-settings-builder-3.0-javadoc.jar!/\" />\n+    </JAVADOC>\n+    <SOURCES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/maven/maven-settings-builder/3.0/maven-settings-builder-3.0-sources.jar!/\" />\n+    </SOURCES>\n+  </library>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "f82106170a10b118baf06be1d068826a4b5a69dc",
        "previous_commit_hash": "7b4f515b2640e7ae2daa72a3ace1f98321c55e26",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,13 @@\n+<component name=\"libraryTable\">\n+  <library name=\"Maven: org.apache.maven.plugin-tools:maven-plugin-annotations:3.2\">\n+    <CLASSES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/maven/plugin-tools/maven-plugin-annotations/3.2/maven-plugin-annotations-3.2.jar!/\" />\n+    </CLASSES>\n+    <JAVADOC>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/maven/plugin-tools/maven-plugin-annotations/3.2/maven-plugin-annotations-3.2-javadoc.jar!/\" />\n+    </JAVADOC>\n+    <SOURCES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/maven/plugin-tools/maven-plugin-annotations/3.2/maven-plugin-annotations-3.2-sources.jar!/\" />\n+    </SOURCES>\n+  </library>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "f82106170a10b118baf06be1d068826a4b5a69dc",
        "previous_commit_hash": "7b4f515b2640e7ae2daa72a3ace1f98321c55e26",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,13 @@\n+<component name=\"libraryTable\">\n+  <library name=\"Maven: org.codehaus.plexus:plexus-classworlds:2.2.3\">\n+    <CLASSES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/codehaus/plexus/plexus-classworlds/2.2.3/plexus-classworlds-2.2.3.jar!/\" />\n+    </CLASSES>\n+    <JAVADOC>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/codehaus/plexus/plexus-classworlds/2.2.3/plexus-classworlds-2.2.3-javadoc.jar!/\" />\n+    </JAVADOC>\n+    <SOURCES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/codehaus/plexus/plexus-classworlds/2.2.3/plexus-classworlds-2.2.3-sources.jar!/\" />\n+    </SOURCES>\n+  </library>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "f82106170a10b118baf06be1d068826a4b5a69dc",
        "previous_commit_hash": "7b4f515b2640e7ae2daa72a3ace1f98321c55e26",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,13 @@\n+<component name=\"libraryTable\">\n+  <library name=\"Maven: org.codehaus.plexus:plexus-component-annotations:1.5.5\">\n+    <CLASSES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/codehaus/plexus/plexus-component-annotations/1.5.5/plexus-component-annotations-1.5.5.jar!/\" />\n+    </CLASSES>\n+    <JAVADOC>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/codehaus/plexus/plexus-component-annotations/1.5.5/plexus-component-annotations-1.5.5-javadoc.jar!/\" />\n+    </JAVADOC>\n+    <SOURCES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/codehaus/plexus/plexus-component-annotations/1.5.5/plexus-component-annotations-1.5.5-sources.jar!/\" />\n+    </SOURCES>\n+  </library>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "f82106170a10b118baf06be1d068826a4b5a69dc",
        "previous_commit_hash": "7b4f515b2640e7ae2daa72a3ace1f98321c55e26",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,13 @@\n+<component name=\"libraryTable\">\n+  <library name=\"Maven: org.codehaus.plexus:plexus-interpolation:1.14\">\n+    <CLASSES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/codehaus/plexus/plexus-interpolation/1.14/plexus-interpolation-1.14.jar!/\" />\n+    </CLASSES>\n+    <JAVADOC>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/codehaus/plexus/plexus-interpolation/1.14/plexus-interpolation-1.14-javadoc.jar!/\" />\n+    </JAVADOC>\n+    <SOURCES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/codehaus/plexus/plexus-interpolation/1.14/plexus-interpolation-1.14-sources.jar!/\" />\n+    </SOURCES>\n+  </library>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "f82106170a10b118baf06be1d068826a4b5a69dc",
        "previous_commit_hash": "7b4f515b2640e7ae2daa72a3ace1f98321c55e26",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,13 @@\n+<component name=\"libraryTable\">\n+  <library name=\"Maven: org.codehaus.plexus:plexus-utils:3.0.8\">\n+    <CLASSES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/codehaus/plexus/plexus-utils/3.0.8/plexus-utils-3.0.8.jar!/\" />\n+    </CLASSES>\n+    <JAVADOC>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/codehaus/plexus/plexus-utils/3.0.8/plexus-utils-3.0.8-javadoc.jar!/\" />\n+    </JAVADOC>\n+    <SOURCES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/codehaus/plexus/plexus-utils/3.0.8/plexus-utils-3.0.8-sources.jar!/\" />\n+    </SOURCES>\n+  </library>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "f82106170a10b118baf06be1d068826a4b5a69dc",
        "previous_commit_hash": "7b4f515b2640e7ae2daa72a3ace1f98321c55e26",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,13 @@\n+<component name=\"libraryTable\">\n+  <library name=\"Maven: org.sonatype.aether:aether-api:1.7\">\n+    <CLASSES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/sonatype/aether/aether-api/1.7/aether-api-1.7.jar!/\" />\n+    </CLASSES>\n+    <JAVADOC>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/sonatype/aether/aether-api/1.7/aether-api-1.7-javadoc.jar!/\" />\n+    </JAVADOC>\n+    <SOURCES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/sonatype/aether/aether-api/1.7/aether-api-1.7-sources.jar!/\" />\n+    </SOURCES>\n+  </library>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "f82106170a10b118baf06be1d068826a4b5a69dc",
        "previous_commit_hash": "7b4f515b2640e7ae2daa72a3ace1f98321c55e26",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,13 @@\n+<component name=\"libraryTable\">\n+  <library name=\"Maven: org.sonatype.aether:aether-impl:1.7\">\n+    <CLASSES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/sonatype/aether/aether-impl/1.7/aether-impl-1.7.jar!/\" />\n+    </CLASSES>\n+    <JAVADOC>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/sonatype/aether/aether-impl/1.7/aether-impl-1.7-javadoc.jar!/\" />\n+    </JAVADOC>\n+    <SOURCES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/sonatype/aether/aether-impl/1.7/aether-impl-1.7-sources.jar!/\" />\n+    </SOURCES>\n+  </library>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "f82106170a10b118baf06be1d068826a4b5a69dc",
        "previous_commit_hash": "7b4f515b2640e7ae2daa72a3ace1f98321c55e26",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,13 @@\n+<component name=\"libraryTable\">\n+  <library name=\"Maven: org.sonatype.aether:aether-spi:1.7\">\n+    <CLASSES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/sonatype/aether/aether-spi/1.7/aether-spi-1.7.jar!/\" />\n+    </CLASSES>\n+    <JAVADOC>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/sonatype/aether/aether-spi/1.7/aether-spi-1.7-javadoc.jar!/\" />\n+    </JAVADOC>\n+    <SOURCES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/sonatype/aether/aether-spi/1.7/aether-spi-1.7-sources.jar!/\" />\n+    </SOURCES>\n+  </library>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "f82106170a10b118baf06be1d068826a4b5a69dc",
        "previous_commit_hash": "7b4f515b2640e7ae2daa72a3ace1f98321c55e26",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,13 @@\n+<component name=\"libraryTable\">\n+  <library name=\"Maven: org.sonatype.aether:aether-util:1.7\">\n+    <CLASSES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/sonatype/aether/aether-util/1.7/aether-util-1.7.jar!/\" />\n+    </CLASSES>\n+    <JAVADOC>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/sonatype/aether/aether-util/1.7/aether-util-1.7-javadoc.jar!/\" />\n+    </JAVADOC>\n+    <SOURCES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/sonatype/aether/aether-util/1.7/aether-util-1.7-sources.jar!/\" />\n+    </SOURCES>\n+  </library>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "f82106170a10b118baf06be1d068826a4b5a69dc",
        "previous_commit_hash": "7b4f515b2640e7ae2daa72a3ace1f98321c55e26",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,13 @@\n+<component name=\"libraryTable\">\n+  <library name=\"Maven: org.sonatype.plexus:plexus-cipher:1.4\">\n+    <CLASSES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/sonatype/plexus/plexus-cipher/1.4/plexus-cipher-1.4.jar!/\" />\n+    </CLASSES>\n+    <JAVADOC>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/sonatype/plexus/plexus-cipher/1.4/plexus-cipher-1.4-javadoc.jar!/\" />\n+    </JAVADOC>\n+    <SOURCES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/sonatype/plexus/plexus-cipher/1.4/plexus-cipher-1.4-sources.jar!/\" />\n+    </SOURCES>\n+  </library>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "f82106170a10b118baf06be1d068826a4b5a69dc",
        "previous_commit_hash": "7b4f515b2640e7ae2daa72a3ace1f98321c55e26",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,13 @@\n+<component name=\"libraryTable\">\n+  <library name=\"Maven: org.sonatype.plexus:plexus-sec-dispatcher:1.3\">\n+    <CLASSES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/sonatype/plexus/plexus-sec-dispatcher/1.3/plexus-sec-dispatcher-1.3.jar!/\" />\n+    </CLASSES>\n+    <JAVADOC>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/sonatype/plexus/plexus-sec-dispatcher/1.3/plexus-sec-dispatcher-1.3-javadoc.jar!/\" />\n+    </JAVADOC>\n+    <SOURCES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/sonatype/plexus/plexus-sec-dispatcher/1.3/plexus-sec-dispatcher-1.3-sources.jar!/\" />\n+    </SOURCES>\n+  </library>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "f82106170a10b118baf06be1d068826a4b5a69dc",
        "previous_commit_hash": "7b4f515b2640e7ae2daa72a3ace1f98321c55e26",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,13 @@\n+<component name=\"libraryTable\">\n+  <library name=\"Maven: org.sonatype.sisu:sisu-guice:noaop:2.1.7\">\n+    <CLASSES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/sonatype/sisu/sisu-guice/2.1.7/sisu-guice-2.1.7-noaop.jar!/\" />\n+    </CLASSES>\n+    <JAVADOC>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/sonatype/sisu/sisu-guice/2.1.7/sisu-guice-2.1.7-javadoc.jar!/\" />\n+    </JAVADOC>\n+    <SOURCES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/sonatype/sisu/sisu-guice/2.1.7/sisu-guice-2.1.7-sources.jar!/\" />\n+    </SOURCES>\n+  </library>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "f82106170a10b118baf06be1d068826a4b5a69dc",
        "previous_commit_hash": "7b4f515b2640e7ae2daa72a3ace1f98321c55e26",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,13 @@\n+<component name=\"libraryTable\">\n+  <library name=\"Maven: org.sonatype.sisu:sisu-inject-bean:1.4.2\">\n+    <CLASSES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/sonatype/sisu/sisu-inject-bean/1.4.2/sisu-inject-bean-1.4.2.jar!/\" />\n+    </CLASSES>\n+    <JAVADOC>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/sonatype/sisu/sisu-inject-bean/1.4.2/sisu-inject-bean-1.4.2-javadoc.jar!/\" />\n+    </JAVADOC>\n+    <SOURCES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/sonatype/sisu/sisu-inject-bean/1.4.2/sisu-inject-bean-1.4.2-sources.jar!/\" />\n+    </SOURCES>\n+  </library>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "f82106170a10b118baf06be1d068826a4b5a69dc",
        "previous_commit_hash": "7b4f515b2640e7ae2daa72a3ace1f98321c55e26",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,13 @@\n+<component name=\"libraryTable\">\n+  <library name=\"Maven: org.sonatype.sisu:sisu-inject-plexus:1.4.2\">\n+    <CLASSES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/sonatype/sisu/sisu-inject-plexus/1.4.2/sisu-inject-plexus-1.4.2.jar!/\" />\n+    </CLASSES>\n+    <JAVADOC>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/sonatype/sisu/sisu-inject-plexus/1.4.2/sisu-inject-plexus-1.4.2-javadoc.jar!/\" />\n+    </JAVADOC>\n+    <SOURCES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/sonatype/sisu/sisu-inject-plexus/1.4.2/sisu-inject-plexus-1.4.2-sources.jar!/\" />\n+    </SOURCES>\n+  </library>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "f82106170a10b118baf06be1d068826a4b5a69dc",
        "previous_commit_hash": "7b4f515b2640e7ae2daa72a3ace1f98321c55e26",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,13 @@\n+<component name=\"libraryTable\">\n+  <library name=\"Maven: org.twdata.maven:mojo-executor:2.2.0\">\n+    <CLASSES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/twdata/maven/mojo-executor/2.2.0/mojo-executor-2.2.0.jar!/\" />\n+    </CLASSES>\n+    <JAVADOC>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/twdata/maven/mojo-executor/2.2.0/mojo-executor-2.2.0-javadoc.jar!/\" />\n+    </JAVADOC>\n+    <SOURCES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/twdata/maven/mojo-executor/2.2.0/mojo-executor-2.2.0-sources.jar!/\" />\n+    </SOURCES>\n+  </library>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "f82106170a10b118baf06be1d068826a4b5a69dc",
        "previous_commit_hash": "7b4f515b2640e7ae2daa72a3ace1f98321c55e26",
        "diff_stats": {
            "additions": 51,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,51 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<module org.jetbrains.idea.maven.project.MavenProjectsManager.isMavenModule=\"true\" type=\"JAVA_MODULE\" version=\"4\">\n+  <component name=\"NewModuleRootManager\" LANGUAGE_LEVEL=\"JDK_1_6\" inherit-compiler-output=\"false\">\n+    <output url=\"file://$MODULE_DIR$/target/classes\" />\n+    <output-test url=\"file://$MODULE_DIR$/target/test-classes\" />\n+    <content url=\"file://$MODULE_DIR$\">\n+      <sourceFolder url=\"file://$MODULE_DIR$/target/generated-sources/plugin\" isTestSource=\"false\" />\n+      <sourceFolder url=\"file://$MODULE_DIR$/src/main/resources\" isTestSource=\"false\" />\n+      <sourceFolder url=\"file://$MODULE_DIR$/src/main/java\" isTestSource=\"false\" />\n+      <sourceFolder url=\"file://$MODULE_DIR$/src/test/java\" isTestSource=\"true\" />\n+      <excludeFolder url=\"file://$MODULE_DIR$/target/antrun\" />\n+      <excludeFolder url=\"file://$MODULE_DIR$/target/classes\" />\n+      <excludeFolder url=\"file://$MODULE_DIR$/target/maven-archiver\" />\n+      <excludeFolder url=\"file://$MODULE_DIR$/target/maven-status\" />\n+      <excludeFolder url=\"file://$MODULE_DIR$/target/test-classes\" />\n+    </content>\n+    <orderEntry type=\"inheritedJdk\" />\n+    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-plugin-api:2.0\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"PROVIDED\" name=\"Maven: org.apache.maven.plugin-tools:maven-plugin-annotations:3.2\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-artifact:3.0\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.codehaus.plexus:plexus-utils:3.0.8\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.twdata.maven:mojo-executor:2.2.0\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-core:3.0\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-model:3.0\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-settings:3.0\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-settings-builder:3.0\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.codehaus.plexus:plexus-interpolation:1.14\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.codehaus.plexus:plexus-component-annotations:1.5.5\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.sonatype.plexus:plexus-sec-dispatcher:1.3\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.sonatype.plexus:plexus-cipher:1.4\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-repository-metadata:3.0\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-model-builder:3.0\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"RUNTIME\" name=\"Maven: org.apache.maven:maven-aether-provider:3.0\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.sonatype.aether:aether-api:1.7\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.sonatype.aether:aether-util:1.7\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.sonatype.aether:aether-impl:1.7\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.sonatype.aether:aether-spi:1.7\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.sonatype.sisu:sisu-inject-plexus:1.4.2\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.codehaus.plexus:plexus-classworlds:2.2.3\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.sonatype.sisu:sisu-inject-bean:1.4.2\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.sonatype.sisu:sisu-guice:noaop:2.1.7\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: com.google.guava:guava:17.0\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.11\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-library:1.3\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-core:1.3\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.mockito:mockito-core:1.9.5\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.objenesis:objenesis:1.0\" level=\"project\" />\n+  </component>\n+</module>\n+\n"
    },
    {
        "commit_hash": "60504f29b74a91eac970b2ec9418dc385aaac1ce",
        "previous_commit_hash": "f82106170a10b118baf06be1d068826a4b5a69dc",
        "diff_stats": {
            "additions": 20,
            "deletions": 19
        },
        "diff_content": "@@ -66,30 +66,31 @@ Optional system properties:\n       Output directory into where the generated class files are written.\n       Defaults to same as retrolambda.inputDir\n ```\n-### Maven plugin\n-To run Retrolambda using Maven add the following to your pom.xml:\n+\n+\n+### Maven Plugin\n+\n+To run Retrolambda using Maven, add the following to your pom.xml:\n+\n ```xml\n-<build>\n-  <plugins>\n-    ...\n-    <plugin>\n-      <groupId>net.orfjackal.retrolambda</groupId>\n-      <artifactId>retrolambda-maven-plugin</artifactId>\n-      <version>0.1.15-SNAPSHOT</version>\n-      <executions>\n+<plugin>\n+    <groupId>net.orfjackal.retrolambda</groupId>\n+    <artifactId>retrolambda-maven-plugin</artifactId>\n+    <version>1.1.5-SNAPSHOT</version>\n+    <executions>\n         <execution>\n-          <goals>\n-            <goal>process-main</goal>\n-            <goal>process-test</goal>\n-          </goals>\n+            <goals>\n+                <goal>process-main</goal>\n+                <goal>process-test</goal>\n+            </goals>\n         </execution>\n-      </executions>\n-    </plugin>\n-    ...\n+    </executions>\n+</plugin>\n ```\n-See [end-to-end-tests/pom.xml](https://github.com/orfjackal/retrolambda/blob/master/end-to-end-tests/pom.xml) for an example.\n \n-Plugin documentation is [here](). (TODO decide where to put the site report)\n+See the [plugin documentation](http://orfjackal.github.io/retrolambda/retrolambda-maven-plugin/plugin-info.html)\n+for all possible parameters. There is also a usage example in [end-to-end-tests/pom.xml](https://github.com/orfjackal/retrolambda/blob/master/end-to-end-tests/pom.xml)\n+\n \n ### Tips\n \n"
    },
    {
        "commit_hash": "684954ff08b9d7bf78d47dffd43bbdf58d181c60",
        "previous_commit_hash": "60504f29b74a91eac970b2ec9418dc385aaac1ce",
        "diff_stats": {
            "additions": 0,
            "deletions": 55
        },
        "diff_content": "@@ -1,55 +0,0 @@\n-#!/bin/bash\n-set -eu\n-: ${1:? Usage: $0 RELEASE_VERSION}\n-SCRIPTS=`dirname \"$0\"`\n-RELEASE_VERSION=\"$1\"\n-if [[ ! \"$RELEASE_VERSION\" =~ ^[0-9]+\\.[0-9]+\\.[0-9]+$ ]]; then\n-    echo \"Error: RELEASE_VERSION must be in X.Y.Z format, but was $RELEASE_VERSION\"\n-    exit 1\n-fi\n-\n-function contains-line() {\n-    grep --line-regexp --quiet --fixed-strings -e \"$1\"\n-}\n-\n-function assert-file-contains() {\n-    local file=\"$1\"\n-    local expected=\"$2\"\n-    cat \"$file\" | contains-line \"$expected\" || (echo \"Add this line to $file and try again:\"; echo \"$expected\"; exit 1)\n-}\n-\n-function bump-version()\n-{\n-    [[ $1 =~ ([0-9]+.[0-9]+.)[0-9]+ ]]\n-    local prefix=${BASH_REMATCH[1]}\n-    [[ $1 =~ [0-9]+.[0-9]+.([0-9]+) ]]\n-    local suffix=${BASH_REMATCH[1]}\n-    ((suffix++))\n-    echo \"$prefix$suffix-SNAPSHOT\"\n-}\n-\n-APP_NAME=\"Retrolambda\"\n-NEXT_VERSION=`bump-version $RELEASE_VERSION`\n-\n-assert-file-contains README.md \"### $APP_NAME $RELEASE_VERSION (`date --iso-8601`)\"\n-\n-set -x\n-\n-mvn versions:set \\\n-    -DgenerateBackupPoms=false \\\n-    -DnewVersion=\"$RELEASE_VERSION\" \\\n-    --file parent/pom.xml\n-git add -u\n-git commit -m \"Release $RELEASE_VERSION\"\n-git tag -s -m \"$APP_NAME $RELEASE_VERSION\" \"v$RELEASE_VERSION\"\n-\n-$SCRIPTS/stage.sh \"$APP_NAME $RELEASE_VERSION\"\n-\n-mvn versions:set \\\n-    -DgenerateBackupPoms=false \\\n-    -DnewVersion=\"$NEXT_VERSION\" \\\n-    --file parent/pom.xml\n-git add -u\n-git commit -m \"Prepare for next development iteration\"\n-\n-$SCRIPTS/publish.sh \"$APP_NAME $RELEASE_VERSION\"\n"
    },
    {
        "commit_hash": "684954ff08b9d7bf78d47dffd43bbdf58d181c60",
        "previous_commit_hash": "60504f29b74a91eac970b2ec9418dc385aaac1ce",
        "diff_stats": {
            "additions": 71,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,71 @@\n+#!/bin/bash\n+set -eu\n+: ${1:? Usage: $0 RELEASE_VERSION}\n+SCRIPTS=`dirname \"$0\"`\n+\n+RELEASE_VERSION=\"$1\"\n+if [[ ! \"$RELEASE_VERSION\" =~ ^[0-9]+\\.[0-9]+\\.[0-9]+$ ]]; then\n+    echo \"Error: RELEASE_VERSION must be in X.Y.Z format, but was $RELEASE_VERSION\"\n+    exit 1\n+fi\n+\n+function contains-line() {\n+    grep --line-regexp --quiet --fixed-strings -e \"$1\"\n+}\n+\n+function demand-file-contains-line() {\n+    local file=\"$1\"\n+    local expected=\"$2\"\n+    cat \"$file\" | contains-line \"$expected\" || (echo \"Add this line to $file and try again:\"; echo \"$expected\"; exit 1)\n+}\n+\n+function assert-file-contains-substring() {\n+    local file=\"$1\"\n+    local expected=\"$2\"\n+    cat \"$file\" | grep --quiet --fixed-strings -e \"$expected\" || (echo \"Error: file $file did not contain $expected\"; exit 1)\n+}\n+\n+function set-project-version() {\n+    local file=\"parent/pom.xml\"\n+    local version=\"$1\"\n+    mvn versions:set \\\n+        -DgenerateBackupPoms=false \\\n+        -DnewVersion=\"$version\" \\\n+        --file \"$file\"\n+    assert-file-contains-substring \"$file\" \"<version>$version</version>\"\n+}\n+\n+function set-documentation-version() {\n+    local file=\"README.md\"\n+    local version=\"$1\"\n+    sed -i -r -e \"s/^(\\\\s*<version>).+(<\\\\/version>)\\$/\\1$version\\2/\" \"$file\"\n+    assert-file-contains-substring \"$file\" \"<version>$version</version>\"\n+}\n+\n+function next-snapshot-version() {\n+    local prefix=`echo $1 | sed -n -r 's/([0-9]+\\.[0-9]+\\.)[0-9]+/\\1/p'`\n+    local suffix=`echo $1 | sed -n -r 's/[0-9]+\\.[0-9]+\\.([0-9]+)/\\1/p'`\n+    ((suffix++))\n+    echo \"$prefix$suffix-SNAPSHOT\"\n+}\n+\n+APP_NAME=\"Retrolambda\"\n+NEXT_VERSION=`next-snapshot-version $RELEASE_VERSION`\n+\n+demand-file-contains-line README.md \"### $APP_NAME $RELEASE_VERSION (`date --iso-8601`)\"\n+\n+set -x\n+\n+set-project-version \"$RELEASE_VERSION\"\n+set-documentation-version \"$RELEASE_VERSION\"\n+git add -u\n+git commit -m \"Release $RELEASE_VERSION\"\n+git tag -s -m \"$APP_NAME $RELEASE_VERSION\" \"v$RELEASE_VERSION\"\n+\n+$SCRIPTS/stage.sh \"$APP_NAME $RELEASE_VERSION\"\n+\n+set-project-version \"$NEXT_VERSION\"\n+git add -u\n+git commit -m \"Prepare for next development iteration\"\n+\n+$SCRIPTS/publish.sh \"$APP_NAME $RELEASE_VERSION\"\n"
    },
    {
        "commit_hash": "a50d9e4f86d0f1db3aa866c01e151632ae3a8d19",
        "previous_commit_hash": "684954ff08b9d7bf78d47dffd43bbdf58d181c60",
        "diff_stats": {
            "additions": 9,
            "deletions": 3
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.1.5-SNAPSHOT</version>\n+        <version>1.2.0</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n@@ -52,10 +52,16 @@\n             <plugin>\n                 <artifactId>maven-compiler-plugin</artifactId>\n                 <configuration>\n-                    <verbose>true</verbose>\n-                    <fork>true</fork>\n                     <source>1.6</source>\n                     <target>1.6</target>\n+                    <fork>true</fork>\n+                </configuration>\n+            </plugin>\n+\n+            <plugin>\n+                <artifactId>maven-javadoc-plugin</artifactId>\n+                <configuration>\n+                    <javadocExecutable>${env.JAVA6_HOME}/bin/javadoc</javadocExecutable>\n                 </configuration>\n             </plugin>\n \n"
    },
    {
        "commit_hash": "e495adc199288e55eae756a9475c64fee7181394",
        "previous_commit_hash": "a50d9e4f86d0f1db3aa866c01e151632ae3a8d19",
        "diff_stats": {
            "additions": 5,
            "deletions": 1
        },
        "diff_content": "@@ -76,7 +76,7 @@ To run Retrolambda using Maven, add the following to your pom.xml:\n <plugin>\n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>retrolambda-maven-plugin</artifactId>\n-    <version>1.1.5-SNAPSHOT</version>\n+    <version>1.2.0</version>\n     <executions>\n         <execution>\n             <goals>\n@@ -140,6 +140,10 @@ the lambda accesses an instance variable).\n Version History\n ---------------\n \n+### Retrolambda 1.2.0 (2014-05-02)\n+\n+- Maven plugin for running Retrolambda (by Dave Moten)\n+\n ### Retrolambda 1.1.4 (2014-03-29)\n \n - Removes from interfaces bridge methods which were generated by JDK 8 e.g.\n"
    },
    {
        "commit_hash": "e495adc199288e55eae756a9475c64fee7181394",
        "previous_commit_hash": "a50d9e4f86d0f1db3aa866c01e151632ae3a8d19",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.1.5-SNAPSHOT</version>\n+        <version>1.2.0</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "e495adc199288e55eae756a9475c64fee7181394",
        "previous_commit_hash": "a50d9e4f86d0f1db3aa866c01e151632ae3a8d19",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>1.1.5-SNAPSHOT</version>\n+    <version>1.2.0</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "e495adc199288e55eae756a9475c64fee7181394",
        "previous_commit_hash": "a50d9e4f86d0f1db3aa866c01e151632ae3a8d19",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.1.5-SNAPSHOT</version>\n+        <version>1.2.0</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "e495adc199288e55eae756a9475c64fee7181394",
        "previous_commit_hash": "a50d9e4f86d0f1db3aa866c01e151632ae3a8d19",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.1.5-SNAPSHOT</version>\n+        <version>1.2.0</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "1ff46fe19c0ce45a6427bc93b328642959a211f3",
        "previous_commit_hash": "e495adc199288e55eae756a9475c64fee7181394",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.2.0</version>\n+        <version>1.2.1-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "1ff46fe19c0ce45a6427bc93b328642959a211f3",
        "previous_commit_hash": "e495adc199288e55eae756a9475c64fee7181394",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>1.2.0</version>\n+    <version>1.2.1-SNAPSHOT</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "1ff46fe19c0ce45a6427bc93b328642959a211f3",
        "previous_commit_hash": "e495adc199288e55eae756a9475c64fee7181394",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.2.0</version>\n+        <version>1.2.1-SNAPSHOT</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "1ff46fe19c0ce45a6427bc93b328642959a211f3",
        "previous_commit_hash": "e495adc199288e55eae756a9475c64fee7181394",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.2.0</version>\n+        <version>1.2.1-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "1ff46fe19c0ce45a6427bc93b328642959a211f3",
        "previous_commit_hash": "e495adc199288e55eae756a9475c64fee7181394",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.2.0</version>\n+        <version>1.2.1-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "b748fa6e76c1cdce0d4bed6eb6f0906c6391b191",
        "previous_commit_hash": "1ff46fe19c0ce45a6427bc93b328642959a211f3",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -10,6 +10,7 @@\n     </content>\n     <orderEntry type=\"inheritedJdk\" />\n     <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n+    <orderEntry type=\"library\" name=\"Maven: com.google.guava:guava:17.0\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.11\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-library:1.3\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-core:1.3\" level=\"project\" />\n"
    },
    {
        "commit_hash": "b748fa6e76c1cdce0d4bed6eb6f0906c6391b191",
        "previous_commit_hash": "1ff46fe19c0ce45a6427bc93b328642959a211f3",
        "diff_stats": {
            "additions": 10,
            "deletions": 0
        },
        "diff_content": "@@ -13,6 +13,16 @@\n     <artifactId>end-to-end-tests</artifactId>\n     <packaging>jar</packaging>\n \n+    <dependencies>\n+\n+        <dependency>\n+            <groupId>com.google.guava</groupId>\n+            <artifactId>guava</artifactId>\n+            <version>17.0</version>\n+        </dependency>\n+\n+    </dependencies>\n+\n     <build>\n         <plugins>\n \n"
    },
    {
        "commit_hash": "b748fa6e76c1cdce0d4bed6eb6f0906c6391b191",
        "previous_commit_hash": "1ff46fe19c0ce45a6427bc93b328642959a211f3",
        "diff_stats": {
            "additions": 8,
            "deletions": 1
        },
        "diff_content": "@@ -1,9 +1,12 @@\n-// Copyright \u00a9 2013 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n package net.orfjackal.retrolambda.test;\n \n+import com.google.common.collect.Lists;\n+\n+import java.util.List;\n import java.util.concurrent.Callable;\n \n public class InMainSources {\n@@ -12,4 +15,8 @@ public class InMainSources {\n         Callable<Integer> lambda = () -> 42;\n         return lambda.call();\n     }\n+\n+    public static List<String> useLambdaOfImportedType(List<String> items) {\n+        return Lists.transform(items, String::toUpperCase);\n+    }\n }\n"
    },
    {
        "commit_hash": "b748fa6e76c1cdce0d4bed6eb6f0906c6391b191",
        "previous_commit_hash": "1ff46fe19c0ce45a6427bc93b328642959a211f3",
        "diff_stats": {
            "additions": 30,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,30 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.test;\n+\n+import org.hamcrest.*;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+\n+public class ClasspathTest {\n+\n+    @Test\n+    public void maven_plugin_sets_classpath_for_main_dependencies() {\n+        assertThat(InMainSources.useLambdaOfImportedType(Arrays.asList(\"a\", \"b\")), is(Arrays.asList(\"A\", \"B\")));\n+    }\n+\n+    @Test\n+    public void maven_plugin_sets_classpath_for_test_dependencies() {\n+        SelfDescribing lambda = (desc) -> desc.appendText(\"foo\");\n+\n+        StringDescription result = new StringDescription();\n+        lambda.describeTo(result);\n+        assertThat(result.toString(), is(\"foo\"));\n+    }\n+}\n"
    },
    {
        "commit_hash": "7953ae008357937c7fada24f986828a9f3e28f13",
        "previous_commit_hash": "b748fa6e76c1cdce0d4bed6eb6f0906c6391b191",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -103,7 +103,7 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n \n     private void validateTarget() throws MojoExecutionException {\n         if (!targetBytecodeVersions.containsKey(target)) {\n-            String possibleValues = Joiner.on(\", \").join(new ArrayList<String>(targetBytecodeVersions.keySet()));\n+            String possibleValues = Joiner.on(\", \").join(new TreeSet<String>(targetBytecodeVersions.keySet()));\n             throw new MojoExecutionException(\n                     \"Unrecognized target '\" + target + \"'. Possible values are \" + possibleValues);\n         }\n"
    },
    {
        "commit_hash": "5e1f868361bd7ce34178082d3892fb110c843dac",
        "previous_commit_hash": "7953ae008357937c7fada24f986828a9f3e28f13",
        "diff_stats": {
            "additions": 30,
            "deletions": 22
        },
        "diff_content": "@@ -42,7 +42,7 @@\n     <properties>\n         <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n         <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n-        <minimumMavenVersion>3.0.3</minimumMavenVersion>\n+        <minimumMavenVersion>3.1</minimumMavenVersion>\n         <compileJavaHome>${env.JAVA8_HOME}</compileJavaHome>\n         <testJavaHome>${env.JAVA7_HOME}</testJavaHome>\n         <testBytecodeTarget>1.7</testBytecodeTarget>\n@@ -154,8 +154,6 @@\n \n             <plugin>\n                 <artifactId>maven-source-plugin</artifactId>\n-                <!-- Overrides the version from oss-parent -->\n-                <version>2.2</version>\n                 <executions>\n                     <execution>\n                         <id>attach-sources</id>\n@@ -168,23 +166,13 @@\n \n             <plugin>\n                 <artifactId>maven-javadoc-plugin</artifactId>\n-                <!-- Overrides the version from oss-parent -->\n-                <version>2.9.1</version>\n                 <configuration>\n                     <javadocExecutable>${compileJavaHome}/bin/javadoc</javadocExecutable>\n                 </configuration>\n             </plugin>\n \n-            <plugin>\n-                <artifactId>maven-release-plugin</artifactId>\n-                <!-- Overrides the version from oss-parent -->\n-                <version>2.4.1</version>\n-            </plugin>\n-\n             <plugin>\n                 <artifactId>maven-enforcer-plugin</artifactId>\n-                <!-- Overrides the version from oss-parent -->\n-                <version>1.3.1</version>\n                 <executions>\n                     <execution>\n                         <!-- XXX: Using a different ID than in oss-parent to avoid overriding its checks by accident. See https://issues.sonatype.org/browse/OSSRH-2004 -->\n@@ -271,14 +259,19 @@\n                     <version>2.4</version>\n                 </plugin>\n \n+                <plugin>\n+                    <artifactId>maven-javadoc-plugin</artifactId>\n+                    <version>2.9.1</version>\n+                </plugin>\n+\n                 <plugin>\n                     <artifactId>maven-install-plugin</artifactId>\n-                    <version>2.4</version>\n+                    <version>2.5.1</version>\n                 </plugin>\n \n                 <plugin>\n                     <artifactId>maven-deploy-plugin</artifactId>\n-                    <version>2.7</version>\n+                    <version>2.8.1</version>\n                 </plugin>\n \n                 <plugin>\n@@ -291,9 +284,24 @@\n                     <version>3.3</version>\n                 </plugin>\n \n+                <plugin>\n+                    <artifactId>maven-source-plugin</artifactId>\n+                    <version>2.2.1</version>\n+                </plugin>\n+\n+                <plugin>\n+                    <artifactId>maven-release-plugin</artifactId>\n+                    <version>2.5</version>\n+                </plugin>\n+\n+                <plugin>\n+                    <artifactId>maven-enforcer-plugin</artifactId>\n+                    <version>1.3.1</version>\n+                </plugin>\n+\n                 <plugin>\n                     <artifactId>maven-shade-plugin</artifactId>\n-                    <version>2.1</version>\n+                    <version>2.3</version>\n                     <configuration>\n                         <!-- XXX: we cannot relocate the classes or minimize the JAR, because the shade plugin doesn't yet support Java 8 -->\n                         <!--<minimizeJar>true</minimizeJar>-->\n@@ -306,22 +314,22 @@\n \n                 <plugin>\n                     <artifactId>maven-surefire-plugin</artifactId>\n-                    <version>2.12.3</version>\n+                    <version>2.16</version>\n                 </plugin>\n \n                 <plugin>\n                     <artifactId>maven-failsafe-plugin</artifactId>\n-                    <version>2.12.3</version>\n+                    <version>2.17</version>\n                 </plugin>\n \n                 <plugin>\n                     <artifactId>maven-invoker-plugin</artifactId>\n-                    <version>1.7</version>\n+                    <version>1.8</version>\n                 </plugin>\n \n                 <plugin>\n                     <artifactId>maven-dependency-plugin</artifactId>\n-                    <version>2.5.1</version>\n+                    <version>2.8</version>\n                 </plugin>\n \n                 <plugin>\n@@ -332,13 +340,13 @@\n                 <plugin>\n                     <groupId>org.codehaus.mojo</groupId>\n                     <artifactId>versions-maven-plugin</artifactId>\n-                    <version>1.3.1</version>\n+                    <version>2.1</version>\n                 </plugin>\n \n                 <plugin>\n                     <groupId>org.sonatype.plugins</groupId>\n                     <artifactId>nexus-staging-maven-plugin</artifactId>\n-                    <version>1.4.4</version>\n+                    <version>1.6.1</version>\n                     <configuration>\n                         <nexusUrl>https://oss.sonatype.org/</nexusUrl>\n                         <serverId>ossrh-releases-net.orfjackal</serverId>\n"
    },
    {
        "commit_hash": "5e1f868361bd7ce34178082d3892fb110c843dac",
        "previous_commit_hash": "7953ae008357937c7fada24f986828a9f3e28f13",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -81,7 +81,7 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n         executeMojo(\n                 plugin(groupId(\"org.apache.maven.plugins\"),\n                         artifactId(\"maven-dependency-plugin\"),\n-                        version(\"2.0\")),\n+                        version(\"2.8\")),\n                 goal(\"copy\"),\n                 configuration(element(\"artifactItems\",\n                         element(\"artifactItem\",\n"
    },
    {
        "commit_hash": "8937901d6e32f88944776f541421257a1baa0359",
        "previous_commit_hash": "5e1f868361bd7ce34178082d3892fb110c843dac",
        "diff_stats": {
            "additions": 0,
            "deletions": 2
        },
        "diff_content": "@@ -303,8 +303,6 @@\n                     <artifactId>maven-shade-plugin</artifactId>\n                     <version>2.3</version>\n                     <configuration>\n-                        <!-- XXX: we cannot relocate the classes or minimize the JAR, because the shade plugin doesn't yet support Java 8 -->\n-                        <!--<minimizeJar>true</minimizeJar>-->\n                         <!-- Keep the generated POM file out of the base directory -->\n                         <dependencyReducedPomLocation>\n                             ${project.build.directory}/dependency-reduced-pom.xml\n"
    },
    {
        "commit_hash": "8937901d6e32f88944776f541421257a1baa0359",
        "previous_commit_hash": "5e1f868361bd7ce34178082d3892fb110c843dac",
        "diff_stats": {
            "additions": 18,
            "deletions": 1
        },
        "diff_content": "@@ -41,7 +41,6 @@\n             </plugin>\n \n             <!-- Create an uber jar containing all dependencies -->\n-            <!-- XXX: we cannot relocate the classes or minimize the JAR, because the shade plugin doesn't yet support Java 8 -->\n \n             <plugin>\n                 <artifactId>maven-shade-plugin</artifactId>\n@@ -52,6 +51,24 @@\n                         </goals>\n                     </execution>\n                 </executions>\n+                <configuration>\n+                    <minimizeJar>true</minimizeJar>\n+                    <relocations>\n+                        <relocation>\n+                            <pattern>org.objectweb.asm</pattern>\n+                            <shadedPattern>net.orfjackal.retrolambda.asm</shadedPattern>\n+                        </relocation>\n+                    </relocations>\n+                    <filters>\n+                        <filter>\n+                            <artifact>org.ow2.asm:asm-debug-all</artifact>\n+                            <excludes>\n+                                <exclude>**/*.html</exclude>\n+                                <exclude>**/*.dtd</exclude>\n+                            </excludes>\n+                        </filter>\n+                    </filters>\n+                </configuration>\n             </plugin>\n \n         </plugins>\n"
    },
    {
        "commit_hash": "8f23d3ab4ce7aa5f72b6b33a6aa1f3cf3c372dcb",
        "previous_commit_hash": "8937901d6e32f88944776f541421257a1baa0359",
        "diff_stats": {
            "additions": 4,
            "deletions": 4
        },
        "diff_content": "@@ -1,13 +1,13 @@\n <component name=\"libraryTable\">\n-  <library name=\"Maven: org.codehaus.plexus:plexus-utils:3.0.8\">\n+  <library name=\"Maven: org.codehaus.plexus:plexus-utils:3.0.17\">\n     <CLASSES>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/codehaus/plexus/plexus-utils/3.0.8/plexus-utils-3.0.8.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/codehaus/plexus/plexus-utils/3.0.17/plexus-utils-3.0.17.jar!/\" />\n     </CLASSES>\n     <JAVADOC>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/codehaus/plexus/plexus-utils/3.0.8/plexus-utils-3.0.8-javadoc.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/codehaus/plexus/plexus-utils/3.0.17/plexus-utils-3.0.17-javadoc.jar!/\" />\n     </JAVADOC>\n     <SOURCES>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/codehaus/plexus/plexus-utils/3.0.8/plexus-utils-3.0.8-sources.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/codehaus/plexus/plexus-utils/3.0.17/plexus-utils-3.0.17-sources.jar!/\" />\n     </SOURCES>\n   </library>\n </component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "8f23d3ab4ce7aa5f72b6b33a6aa1f3cf3c372dcb",
        "previous_commit_hash": "8937901d6e32f88944776f541421257a1baa0359",
        "diff_stats": {
            "additions": 4,
            "deletions": 4
        },
        "diff_content": "@@ -1,13 +1,13 @@\n <component name=\"libraryTable\">\n-  <library name=\"Maven: org.ow2.asm:asm-debug-all:5.0_BETA\">\n+  <library name=\"Maven: org.ow2.asm:asm-debug-all:5.0.2\">\n     <CLASSES>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm-debug-all/5.0_BETA/asm-debug-all-5.0_BETA.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm-debug-all/5.0.2/asm-debug-all-5.0.2.jar!/\" />\n     </CLASSES>\n     <JAVADOC>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm-debug-all/5.0_BETA/asm-debug-all-5.0_BETA-javadoc.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm-debug-all/5.0.2/asm-debug-all-5.0.2-javadoc.jar!/\" />\n     </JAVADOC>\n     <SOURCES>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm-debug-all/5.0_BETA/asm-debug-all-5.0_BETA-sources.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm-debug-all/5.0.2/asm-debug-all-5.0.2-sources.jar!/\" />\n     </SOURCES>\n   </library>\n </component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "8f23d3ab4ce7aa5f72b6b33a6aa1f3cf3c372dcb",
        "previous_commit_hash": "8937901d6e32f88944776f541421257a1baa0359",
        "diff_stats": {
            "additions": 0,
            "deletions": 1
        },
        "diff_content": "@@ -18,7 +18,6 @@\n         <dependency>\n             <groupId>com.google.guava</groupId>\n             <artifactId>guava</artifactId>\n-            <version>17.0</version>\n         </dependency>\n \n     </dependencies>\n"
    },
    {
        "commit_hash": "8f23d3ab4ce7aa5f72b6b33a6aa1f3cf3c372dcb",
        "previous_commit_hash": "8937901d6e32f88944776f541421257a1baa0359",
        "diff_stats": {
            "additions": 9,
            "deletions": 1
        },
        "diff_content": "@@ -84,7 +84,7 @@\n             <dependency>\n                 <groupId>org.ow2.asm</groupId>\n                 <artifactId>asm-debug-all</artifactId>\n-                <version>5.0_BETA</version>\n+                <version>5.0.2</version>\n             </dependency>\n \n             <!-- Testing -->\n@@ -114,6 +114,14 @@\n                 <version>1.9.5</version>\n             </dependency>\n \n+            <!-- Utils -->\n+\n+            <dependency>\n+                <groupId>com.google.guava</groupId>\n+                <artifactId>guava</artifactId>\n+                <version>17.0</version>\n+            </dependency>\n+\n         </dependencies>\n     </dependencyManagement>\n \n"
    },
    {
        "commit_hash": "8f23d3ab4ce7aa5f72b6b33a6aa1f3cf3c372dcb",
        "previous_commit_hash": "8937901d6e32f88944776f541421257a1baa0359",
        "diff_stats": {
            "additions": 1,
            "deletions": 2
        },
        "diff_content": "@@ -29,7 +29,7 @@\n         <dependency>\n             <groupId>org.codehaus.plexus</groupId>\n             <artifactId>plexus-utils</artifactId>\n-            <version>3.0.8</version>\n+            <version>3.0.17</version>\n         </dependency>\n \n         <dependency>\n@@ -41,7 +41,6 @@\n         <dependency>\n             <groupId>com.google.guava</groupId>\n             <artifactId>guava</artifactId>\n-            <version>17.0</version>\n         </dependency>\n \n     </dependencies>\n"
    },
    {
        "commit_hash": "8f23d3ab4ce7aa5f72b6b33a6aa1f3cf3c372dcb",
        "previous_commit_hash": "8937901d6e32f88944776f541421257a1baa0359",
        "diff_stats": {
            "additions": 2,
            "deletions": 1
        },
        "diff_content": "@@ -12,6 +12,7 @@\n       <excludeFolder url=\"file://$MODULE_DIR$/target/classes\" />\n       <excludeFolder url=\"file://$MODULE_DIR$/target/maven-archiver\" />\n       <excludeFolder url=\"file://$MODULE_DIR$/target/maven-status\" />\n+      <excludeFolder url=\"file://$MODULE_DIR$/target/surefire-reports\" />\n       <excludeFolder url=\"file://$MODULE_DIR$/target/test-classes\" />\n     </content>\n     <orderEntry type=\"inheritedJdk\" />\n@@ -19,7 +20,7 @@\n     <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-plugin-api:2.0\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"PROVIDED\" name=\"Maven: org.apache.maven.plugin-tools:maven-plugin-annotations:3.2\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-artifact:3.0\" level=\"project\" />\n-    <orderEntry type=\"library\" name=\"Maven: org.codehaus.plexus:plexus-utils:3.0.8\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.codehaus.plexus:plexus-utils:3.0.17\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.twdata.maven:mojo-executor:2.2.0\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-core:3.0\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-model:3.0\" level=\"project\" />\n"
    },
    {
        "commit_hash": "8f23d3ab4ce7aa5f72b6b33a6aa1f3cf3c372dcb",
        "previous_commit_hash": "8937901d6e32f88944776f541421257a1baa0359",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -10,7 +10,7 @@\n     </content>\n     <orderEntry type=\"inheritedJdk\" />\n     <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n-    <orderEntry type=\"library\" name=\"Maven: org.ow2.asm:asm-debug-all:5.0_BETA\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.ow2.asm:asm-debug-all:5.0.2\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.11\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-library:1.3\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-core:1.3\" level=\"project\" />\n"
    },
    {
        "commit_hash": "51f85a6292a8c8c1bb5d58273e8ca0ffafa4d2d2",
        "previous_commit_hash": "8f23d3ab4ce7aa5f72b6b33a6aa1f3cf3c372dcb",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -3,3 +3,4 @@\n .classpath\n .settings\n .project\n+.DS_Store\n"
    },
    {
        "commit_hash": "643b216ebc02178ba6bf936f9bb8c0d83850d9e6",
        "previous_commit_hash": "51f85a6292a8c8c1bb5d58273e8ca0ffafa4d2d2",
        "diff_stats": {
            "additions": 5,
            "deletions": 0
        },
        "diff_content": "@@ -292,6 +292,11 @@\n                     <version>3.3</version>\n                 </plugin>\n \n+                <plugin>\n+                    <artifactId>maven-project-info-reports-plugin</artifactId>\n+                    <version>2.7</version>\n+                </plugin>\n+\n                 <plugin>\n                     <artifactId>maven-source-plugin</artifactId>\n                     <version>2.2.1</version>\n"
    },
    {
        "commit_hash": "643b216ebc02178ba6bf936f9bb8c0d83850d9e6",
        "previous_commit_hash": "51f85a6292a8c8c1bb5d58273e8ca0ffafa4d2d2",
        "diff_stats": {
            "additions": 21,
            "deletions": 10
        },
        "diff_content": "@@ -89,7 +89,6 @@\n             </plugin>\n \n             <plugin>\n-                <groupId>org.apache.maven.plugins</groupId>\n                 <artifactId>maven-site-plugin</artifactId>\n                 <executions>\n                     <execution>\n@@ -99,18 +98,30 @@\n                         </goals>\n                     </execution>\n                 </executions>\n-                <configuration>\n-                    <reportPlugins>\n-                        <plugin>\n-                            <groupId>org.apache.maven.plugins</groupId>\n-                            <artifactId>maven-plugin-plugin</artifactId>\n-                            <version>3.2</version>\n-                        </plugin>\n-                    </reportPlugins>\n-                </configuration>\n             </plugin>\n \n         </plugins>\n     </build>\n \n+    <reporting>\n+        <plugins>\n+\n+            <plugin>\n+                <artifactId>maven-plugin-plugin</artifactId>\n+            </plugin>\n+\n+            <plugin>\n+                <artifactId>maven-project-info-reports-plugin</artifactId>\n+                <reportSets>\n+                    <reportSet>\n+                        <reports>\n+                            <!-- We want no stinky generic reports -->\n+                        </reports>\n+                    </reportSet>\n+                </reportSets>\n+            </plugin>\n+\n+        </plugins>\n+    </reporting>\n+\n </project>\n"
    },
    {
        "commit_hash": "919bc69140d5d11e89c48a00feeec0eb12ce7c45",
        "previous_commit_hash": "643b216ebc02178ba6bf936f9bb8c0d83850d9e6",
        "diff_stats": {
            "additions": 5,
            "deletions": 0
        },
        "diff_content": "@@ -140,6 +140,11 @@ the lambda accesses an instance variable).\n Version History\n ---------------\n \n+### Upcoming\n+\n+- Fixed the Retrolambda Maven plugin not using the project's classpath\n+  ([Issue #16](https://github.com/orfjackal/retrolambda/issues/16))\n+\n ### Retrolambda 1.2.0 (2014-05-02)\n \n - Maven plugin for running Retrolambda (by Dave Moten)\n"
    },
    {
        "commit_hash": "919bc69140d5d11e89c48a00feeec0eb12ce7c45",
        "previous_commit_hash": "643b216ebc02178ba6bf936f9bb8c0d83850d9e6",
        "diff_stats": {
            "additions": 3,
            "deletions": 1
        },
        "diff_content": "@@ -10,7 +10,9 @@ import org.apache.maven.plugins.annotations.*;\n  * Processes main (non-test) classes compiled with Java 8 so that they will be\n  * compatible with Java 5, 6 or 7 runtime.\n  */\n-@Mojo(name = \"process-main\", defaultPhase = LifecyclePhase.PROCESS_CLASSES)\n+@Mojo(name = \"process-main\",\n+        defaultPhase = LifecyclePhase.PROCESS_CLASSES,\n+        requiresDependencyResolution = ResolutionScope.COMPILE)\n public class ProcessMainClassesMojo extends ProcessClassesMojo {\n \n     public ProcessMainClassesMojo() {\n"
    },
    {
        "commit_hash": "919bc69140d5d11e89c48a00feeec0eb12ce7c45",
        "previous_commit_hash": "643b216ebc02178ba6bf936f9bb8c0d83850d9e6",
        "diff_stats": {
            "additions": 3,
            "deletions": 1
        },
        "diff_content": "@@ -10,7 +10,9 @@ import org.apache.maven.plugins.annotations.*;\n  * Processes test classes compiled with Java 8 so that they will be compatible with\n  * Java 5, 6 or 7 runtime.\n  */\n-@Mojo(name = \"process-test\", defaultPhase = LifecyclePhase.PROCESS_TEST_CLASSES)\n+@Mojo(name = \"process-test\",\n+        defaultPhase = LifecyclePhase.PROCESS_TEST_CLASSES,\n+        requiresDependencyResolution = ResolutionScope.TEST)\n public class ProcessTestClassesMojo extends ProcessClassesMojo {\n \n     public ProcessTestClassesMojo() {\n"
    },
    {
        "commit_hash": "18ce9a9f208012c9a86ea8f8e66b923efb4a6eca",
        "previous_commit_hash": "919bc69140d5d11e89c48a00feeec0eb12ce7c45",
        "diff_stats": {
            "additions": 1,
            "deletions": 2
        },
        "diff_content": "@@ -68,6 +68,7 @@\n                 <artifactId>maven-plugin-plugin</artifactId>\n                 <configuration>\n                     <goalPrefix>retrolambda</goalPrefix>\n+                    <!-- See http://jira.codehaus.org/browse/MNG-5346 -->\n                     <skipErrorNoDescriptorsFound>true</skipErrorNoDescriptorsFound>\n                 </configuration>\n                 <executions>\n@@ -76,14 +77,12 @@\n                         <goals>\n                             <goal>descriptor</goal>\n                         </goals>\n-                        <phase>process-classes</phase>\n                     </execution>\n                     <execution>\n                         <id>help-goal</id>\n                         <goals>\n                             <goal>helpmojo</goal>\n                         </goals>\n-                        <phase>process-classes</phase>\n                     </execution>\n                 </executions>\n             </plugin>\n"
    },
    {
        "commit_hash": "b5bb57caac7b6da8b1bc26bbb7dec6c903814155",
        "previous_commit_hash": "18ce9a9f208012c9a86ea8f8e66b923efb4a6eca",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -144,6 +144,7 @@ Version History\n \n - Fixed the Retrolambda Maven plugin not using the project's classpath\n   ([Issue #16](https://github.com/orfjackal/retrolambda/issues/16))\n+- Maven plugin: save `retrolambda.jar` under `target/retrolambda/`\n \n ### Retrolambda 1.2.0 (2014-05-02)\n \n"
    },
    {
        "commit_hash": "b5bb57caac7b6da8b1bc26bbb7dec6c903814155",
        "previous_commit_hash": "18ce9a9f208012c9a86ea8f8e66b923efb4a6eca",
        "diff_stats": {
            "additions": 21,
            "deletions": 8
        },
        "diff_content": "@@ -17,8 +17,6 @@ import static org.twdata.maven.mojoexecutor.MojoExecutor.*;\n \n abstract class ProcessClassesMojo extends AbstractMojo {\n \n-    private static final String RETROLAMBDA_JAR = \"retrolambda.jar\";\n-\n     private final Map<String, Integer> targetBytecodeVersions = new HashMap<String, Integer>();\n \n     @Component\n@@ -77,7 +75,9 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n         validateJava8home();\n         validateTarget();\n \n-        getLog().info(\"Retrieving the Retrolambda JAR\");\n+        // TODO: use Maven's built-in artifact resolving, so that we can refer to retrolambda.jar in the local repository without copying it\n+        String version = getRetrolambdaVersion();\n+        getLog().info(\"Retrieving Retrolambda \" + version);\n         executeMojo(\n                 plugin(groupId(\"org.apache.maven.plugins\"),\n                         artifactId(\"maven-dependency-plugin\"),\n@@ -87,10 +87,10 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n                         element(\"artifactItem\",\n                                 element(name(\"groupId\"), \"net.orfjackal.retrolambda\"),\n                                 element(name(\"artifactId\"), \"retrolambda\"),\n-                                element(name(\"version\"), getRetrolambdaVersion()),\n+                                element(name(\"version\"), version),\n                                 element(name(\"overWrite\"), \"true\"),\n-                                element(name(\"outputDirectory\"), project.getBuild().getDirectory()),\n-                                element(name(\"destFileName\"), RETROLAMBDA_JAR)))),\n+                                element(name(\"outputDirectory\"), getRetrolambdaJarDir()),\n+                                element(name(\"destFileName\"), getRetrolambdaJarName())))),\n                 executionEnvironment(project, session, pluginManager));\n \n         getLog().info(\"Processing classes with Retrolambda\");\n@@ -117,6 +117,7 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n     }\n \n     private void processClasses(String inputDir, String classpathId) throws MojoExecutionException {\n+        String retrolambdaJar = getRetrolambdaJarPath();\n         executeMojo(\n                 plugin(groupId(\"org.apache.maven.plugins\"),\n                         artifactId(\"maven-antrun-plugin\"),\n@@ -134,12 +135,24 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n                                 element(\"arg\", attribute(\"value\", \"-Dretrolambda.bytecodeVersion=\" + targetBytecodeVersions.get(target))),\n                                 element(\"arg\", attribute(\"value\", \"-Dretrolambda.inputDir=\" + inputDir)),\n                                 element(\"arg\", attribute(\"value\", \"-Dretrolambda.classpath=${the_classpath}\")),\n-                                element(\"arg\", attribute(\"value\", \"-javaagent:\" + project.getBuild().getDirectory() + \"/\" + RETROLAMBDA_JAR)),\n+                                element(\"arg\", attribute(\"value\", \"-javaagent:\" + retrolambdaJar)),\n                                 element(\"arg\", attribute(\"value\", \"-jar\")),\n-                                element(\"arg\", attribute(\"value\", project.getBuild().getDirectory() + \"/\" + RETROLAMBDA_JAR))))),\n+                                element(\"arg\", attribute(\"value\", retrolambdaJar))))),\n                 executionEnvironment(project, session, pluginManager));\n     }\n \n+    private String getRetrolambdaJarPath() {\n+        return getRetrolambdaJarDir() + \"/\" + getRetrolambdaJarName();\n+    }\n+\n+    private String getRetrolambdaJarDir() {\n+        return project.getBuild().getDirectory() + \"/retrolambda\";\n+    }\n+\n+    private String getRetrolambdaJarName() {\n+        return \"retrolambda.jar\";\n+    }\n+\n     private static String getRetrolambdaVersion() throws MojoExecutionException {\n         try {\n             InputStream is = ProcessClassesMojo.class.getResourceAsStream(\n"
    },
    {
        "commit_hash": "37a6211f8998b3ad754712ccb782c5995832db4b",
        "previous_commit_hash": "b5bb57caac7b6da8b1bc26bbb7dec6c903814155",
        "diff_stats": {
            "additions": 7,
            "deletions": 5
        },
        "diff_content": "@@ -5,6 +5,7 @@\n package net.orfjackal.retrolambda.maven;\n \n import com.google.common.base.Joiner;\n+import com.google.common.collect.ImmutableMap;\n import org.apache.maven.execution.MavenSession;\n import org.apache.maven.plugin.*;\n import org.apache.maven.plugins.annotations.*;\n@@ -17,7 +18,12 @@ import static org.twdata.maven.mojoexecutor.MojoExecutor.*;\n \n abstract class ProcessClassesMojo extends AbstractMojo {\n \n-    private final Map<String, Integer> targetBytecodeVersions = new HashMap<String, Integer>();\n+    private static final Map<String, Integer> targetBytecodeVersions = ImmutableMap.of(\n+            \"1.5\", 49,\n+            \"1.6\", 50,\n+            \"1.7\", 51,\n+            \"1.8\", 52\n+    );\n \n     @Component\n     private MavenSession session;\n@@ -64,10 +70,6 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n \n     ProcessClassesMojo(ClassesType classesType) {\n         this.classesType = classesType;\n-        targetBytecodeVersions.put(\"1.5\", 49);\n-        targetBytecodeVersions.put(\"1.6\", 50);\n-        targetBytecodeVersions.put(\"1.7\", 51);\n-        targetBytecodeVersions.put(\"1.8\", 52);\n     }\n \n     @Override\n"
    },
    {
        "commit_hash": "71d91be2834e8726e2a57807847a4836cd0b30e3",
        "previous_commit_hash": "37a6211f8998b3ad754712ccb782c5995832db4b",
        "diff_stats": {
            "additions": 2,
            "deletions": 1
        },
        "diff_content": "@@ -148,7 +148,8 @@ Version History\n \n ### Retrolambda 1.2.0 (2014-05-02)\n \n-- Maven plugin for running Retrolambda (by Dave Moten)\n+- Maven plugin for running Retrolambda\n+  (thanks, [Dave Moten](https://github.com/davidmoten))\n \n ### Retrolambda 1.1.4 (2014-03-29)\n \n"
    },
    {
        "commit_hash": "63d94844820800e61bee1f5c4f39ad6923bc4e41",
        "previous_commit_hash": "71d91be2834e8726e2a57807847a4836cd0b30e3",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -145,6 +145,7 @@ Version History\n - Fixed the Retrolambda Maven plugin not using the project's classpath\n   ([Issue #16](https://github.com/orfjackal/retrolambda/issues/16))\n - Maven plugin: save `retrolambda.jar` under `target/retrolambda/`\n+- Suppress false warning about class initializer methods on interfaces\n \n ### Retrolambda 1.2.0 (2014-05-02)\n \n"
    },
    {
        "commit_hash": "63d94844820800e61bee1f5c4f39ad6923bc4e41",
        "previous_commit_hash": "71d91be2834e8726e2a57807847a4836cd0b30e3",
        "diff_stats": {
            "additions": 16,
            "deletions": 5
        },
        "diff_content": "@@ -59,11 +59,16 @@ public class LambdaUsageBackporter {\n             if (isBridgeMethodOnInterface(access)) {\n                 return null; // remove the bridge method; Java 7 didn't use them\n             }\n-            if (isNonAbstractMethodOnInterface(access)) {\n-                // We are not aware of other reasons than the bridge methods\n-                // why JDK 8 would produce non-abstract methods on interfaces,\n-                // but we have this warning here to get a bug report sooner\n-                // in case we missed something.\n+            if (isNonAbstractMethodOnInterface(access)\n+                    && !isClassInitializerMethod(name, desc, access)) {\n+                // In case we have missed a case of Java 8 producing non-abstract methods\n+                // on interfaces, we have this warning here to get a bug report sooner.\n+                // Not allowed by Java 7:\n+                // - default methods\n+                // - static methods\n+                // - bridge methods\n+                // Allowed by Java 7:\n+                // - class initializer methods (for initializing constants)\n                 System.out.println(\"WARNING: Method '\" + name + \"' of interface '\" + className + \"' is non-abstract! \" +\n                         \"This will probably fail to run on Java 7 and below. \" +\n                         \"If you get this warning _without_ using Java 8's default methods, \" +\n@@ -86,6 +91,12 @@ public class LambdaUsageBackporter {\n             return Flags.hasFlag(classAccess, Opcodes.ACC_INTERFACE) &&\n                     !Flags.hasFlag(methodAccess, Opcodes.ACC_ABSTRACT);\n         }\n+\n+        private static boolean isClassInitializerMethod(String name, String desc, int methodAccess) {\n+            return name.equals(\"<clinit>\") &&\n+                    desc.equals(\"()V\") &&\n+                    Flags.hasFlag(methodAccess, Opcodes.ACC_STATIC);\n+        }\n     }\n \n     private static class InvokeDynamicInsnConvertingMethodVisitor extends MethodVisitor {\n"
    },
    {
        "commit_hash": "cb13e6c5f9e64ad0cfab2dd8bc6ded3222a8a892",
        "previous_commit_hash": "63d94844820800e61bee1f5c4f39ad6923bc4e41",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,13 @@\n+<component name=\"libraryTable\">\n+  <library name=\"Maven: com.google.code.findbugs:jsr305:1.3.9\">\n+    <CLASSES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/com/google/code/findbugs/jsr305/1.3.9/jsr305-1.3.9.jar!/\" />\n+    </CLASSES>\n+    <JAVADOC>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/com/google/code/findbugs/jsr305/1.3.9/jsr305-1.3.9-javadoc.jar!/\" />\n+    </JAVADOC>\n+    <SOURCES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/com/google/code/findbugs/jsr305/1.3.9/jsr305-1.3.9-sources.jar!/\" />\n+    </SOURCES>\n+  </library>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "cb13e6c5f9e64ad0cfab2dd8bc6ded3222a8a892",
        "previous_commit_hash": "63d94844820800e61bee1f5c4f39ad6923bc4e41",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,13 @@\n+<component name=\"libraryTable\">\n+  <library name=\"Maven: com.google.guava:guava:11.0.2\">\n+    <CLASSES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/com/google/guava/guava/11.0.2/guava-11.0.2.jar!/\" />\n+    </CLASSES>\n+    <JAVADOC>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/com/google/guava/guava/11.0.2/guava-11.0.2-javadoc.jar!/\" />\n+    </JAVADOC>\n+    <SOURCES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/com/google/guava/guava/11.0.2/guava-11.0.2-sources.jar!/\" />\n+    </SOURCES>\n+  </library>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "cb13e6c5f9e64ad0cfab2dd8bc6ded3222a8a892",
        "previous_commit_hash": "63d94844820800e61bee1f5c4f39ad6923bc4e41",
        "diff_stats": {
            "additions": 2,
            "deletions": 1
        },
        "diff_content": "@@ -10,7 +10,8 @@\n     </content>\n     <orderEntry type=\"inheritedJdk\" />\n     <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n-    <orderEntry type=\"library\" name=\"Maven: com.google.guava:guava:17.0\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: com.google.guava:guava:11.0.2\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: com.google.code.findbugs:jsr305:1.3.9\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.11\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-library:1.3\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-core:1.3\" level=\"project\" />\n"
    },
    {
        "commit_hash": "cb13e6c5f9e64ad0cfab2dd8bc6ded3222a8a892",
        "previous_commit_hash": "63d94844820800e61bee1f5c4f39ad6923bc4e41",
        "diff_stats": {
            "additions": 2,
            "deletions": 0
        },
        "diff_content": "@@ -18,6 +18,8 @@\n         <dependency>\n             <groupId>com.google.guava</groupId>\n             <artifactId>guava</artifactId>\n+            <!-- We must use an older version of the library,  so that we can run our tests on Java 5 -->\n+            <version>11.0.2</version>\n         </dependency>\n \n     </dependencies>\n"
    },
    {
        "commit_hash": "7e1247700228dd3a46173240532b493251817c9e",
        "previous_commit_hash": "cb13e6c5f9e64ad0cfab2dd8bc6ded3222a8a892",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -357,7 +357,7 @@\n                 <plugin>\n                     <groupId>org.sonatype.plugins</groupId>\n                     <artifactId>nexus-staging-maven-plugin</artifactId>\n-                    <version>1.6.1</version>\n+                    <version>1.5.1</version>\n                     <configuration>\n                         <nexusUrl>https://oss.sonatype.org/</nexusUrl>\n                         <serverId>ossrh-releases-net.orfjackal</serverId>\n"
    },
    {
        "commit_hash": "929b7a5047a72640f007f346243df5f30b6c3122",
        "previous_commit_hash": "7e1247700228dd3a46173240532b493251817c9e",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -76,7 +76,7 @@ To run Retrolambda using Maven, add the following to your pom.xml:\n <plugin>\n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>retrolambda-maven-plugin</artifactId>\n-    <version>1.2.0</version>\n+    <version>1.2.1</version>\n     <executions>\n         <execution>\n             <goals>\n@@ -140,7 +140,7 @@ the lambda accesses an instance variable).\n Version History\n ---------------\n \n-### Upcoming\n+### Retrolambda 1.2.1 (2014-05-04)\n \n - Fixed the Retrolambda Maven plugin not using the project's classpath\n   ([Issue #16](https://github.com/orfjackal/retrolambda/issues/16))\n"
    },
    {
        "commit_hash": "929b7a5047a72640f007f346243df5f30b6c3122",
        "previous_commit_hash": "7e1247700228dd3a46173240532b493251817c9e",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.2.1-SNAPSHOT</version>\n+        <version>1.2.1</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "929b7a5047a72640f007f346243df5f30b6c3122",
        "previous_commit_hash": "7e1247700228dd3a46173240532b493251817c9e",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>1.2.1-SNAPSHOT</version>\n+    <version>1.2.1</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "929b7a5047a72640f007f346243df5f30b6c3122",
        "previous_commit_hash": "7e1247700228dd3a46173240532b493251817c9e",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.2.1-SNAPSHOT</version>\n+        <version>1.2.1</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "929b7a5047a72640f007f346243df5f30b6c3122",
        "previous_commit_hash": "7e1247700228dd3a46173240532b493251817c9e",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.2.1-SNAPSHOT</version>\n+        <version>1.2.1</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "929b7a5047a72640f007f346243df5f30b6c3122",
        "previous_commit_hash": "7e1247700228dd3a46173240532b493251817c9e",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.2.1-SNAPSHOT</version>\n+        <version>1.2.1</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "5adcbf35d3e445723053159b18e517093f2cff27",
        "previous_commit_hash": "929b7a5047a72640f007f346243df5f30b6c3122",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.2.1</version>\n+        <version>1.2.2-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "5adcbf35d3e445723053159b18e517093f2cff27",
        "previous_commit_hash": "929b7a5047a72640f007f346243df5f30b6c3122",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>1.2.1</version>\n+    <version>1.2.2-SNAPSHOT</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "5adcbf35d3e445723053159b18e517093f2cff27",
        "previous_commit_hash": "929b7a5047a72640f007f346243df5f30b6c3122",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.2.1</version>\n+        <version>1.2.2-SNAPSHOT</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "5adcbf35d3e445723053159b18e517093f2cff27",
        "previous_commit_hash": "929b7a5047a72640f007f346243df5f30b6c3122",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.2.1</version>\n+        <version>1.2.2-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "5adcbf35d3e445723053159b18e517093f2cff27",
        "previous_commit_hash": "929b7a5047a72640f007f346243df5f30b6c3122",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.2.1</version>\n+        <version>1.2.2-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "c6ded02405b2c61dae59b00bc4a93ba22477a4c3",
        "previous_commit_hash": "5adcbf35d3e445723053159b18e517093f2cff27",
        "diff_stats": {
            "additions": 12,
            "deletions": 1
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -113,4 +113,15 @@ public class LambdaTest {\n \n         assertThat(ref.call(), is(instanceOf(ArrayList.class)));\n     }\n+\n+    @Test\n+    public void method_references_to_private_methods() throws Exception {\n+        Callable<String> ref = this::privateMethod;\n+\n+        assertThat(ref.call(), is(\"foo\"));\n+    }\n+\n+    private String privateMethod() {\n+        return \"foo\";\n+    }\n }\n"
    },
    {
        "commit_hash": "80a9872e12303f6a4984fb1c7fae3ad6ad9df6e7",
        "previous_commit_hash": "c6ded02405b2c61dae59b00bc4a93ba22477a4c3",
        "diff_stats": {
            "additions": 5,
            "deletions": 0
        },
        "diff_content": "@@ -27,7 +27,12 @@ public class LambdaReifier {\n         try {\n             setInvoker(invoker);\n             setInvokedType(invokedType);\n+\n+            // Causes the lambda class to be loaded. Retrolambda's Java agent\n+            // will detect it, save it to a file and tell us (via the globals\n+            // in this class) that what the name of the lambda class was.\n             callBootstrapMethod(invoker, invokedName, invokedType, bsm, bsmArgs);\n+\n             return getLambdaFactoryMethod();\n \n         } catch (Throwable t) {\n"
    },
    {
        "commit_hash": "e265e3ac7e04dc1b70689d03004974fcb139ac19",
        "previous_commit_hash": "80a9872e12303f6a4984fb1c7fae3ad6ad9df6e7",
        "diff_stats": {
            "additions": 31,
            "deletions": 3
        },
        "diff_content": "@@ -6,11 +6,13 @@ package net.orfjackal.retrolambda.test;\n \n import org.junit.Test;\n \n+import java.lang.reflect.*;\n import java.util.*;\n import java.util.concurrent.Callable;\n \n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.*;\n+import static org.junit.Assert.assertTrue;\n \n public class LambdaTest {\n \n@@ -116,12 +118,38 @@ public class LambdaTest {\n \n     @Test\n     public void method_references_to_private_methods() throws Exception {\n-        Callable<String> ref = this::privateMethod;\n+        Callable<String> ref1 = this::privateInstanceMethod;\n+        Callable<String> ref2 = LambdaTest::privateClassMethod;\n \n-        assertThat(ref.call(), is(\"foo\"));\n+        assertThat(ref1.call(), is(\"foo\"));\n+        assertThat(ref2.call(), is(\"foo\"));\n     }\n \n-    private String privateMethod() {\n+    private String privateInstanceMethod() {\n+        return \"foo\";\n+    }\n+\n+    private static String privateClassMethod() {\n+        return \"foo\";\n+    }\n+\n+    /**\n+     * We must make private lambda implementation methods package-private,\n+     * so that the lambda class may call them, but we should not make any\n+     * more methods non-private than is absolutely necessary.\n+     */\n+    @Test\n+    public void will_not_change_the_visibility_of_unrelated_methods() throws Exception {\n+        assertThat(unrelatedPrivateMethod(), is(\"foo\"));\n+\n+        Method method = getClass().getDeclaredMethod(\"unrelatedPrivateMethod\");\n+        int modifiers = method.getModifiers();\n+\n+        assertTrue(\"expected \" + method.getName() + \" to be private, but modifiers were: \" + Modifier.toString(modifiers),\n+                Modifier.isPrivate(modifiers));\n+    }\n+\n+    private String unrelatedPrivateMethod() {\n         return \"foo\";\n     }\n }\n"
    },
    {
        "commit_hash": "7c10751a30cb69887a47f39a25cddfcf9ec2a25a",
        "previous_commit_hash": "e265e3ac7e04dc1b70689d03004974fcb139ac19",
        "diff_stats": {
            "additions": 6,
            "deletions": 0
        },
        "diff_content": "@@ -140,6 +140,12 @@ the lambda accesses an instance variable).\n Version History\n ---------------\n \n+### Upcoming\n+\n+- Fixed method references to private methods; will now make them\n+  package-private the same way as lambda implementation methods\n+  ([Issue #17](https://github.com/orfjackal/retrolambda/issues/17))\n+\n ### Retrolambda 1.2.1 (2014-05-04)\n \n - Fixed the Retrolambda Maven plugin not using the project's classpath\n"
    },
    {
        "commit_hash": "7c10751a30cb69887a47f39a25cddfcf9ec2a25a",
        "previous_commit_hash": "e265e3ac7e04dc1b70689d03004974fcb139ac19",
        "diff_stats": {
            "additions": 44,
            "deletions": 9
        },
        "diff_content": "@@ -5,8 +5,10 @@\n package net.orfjackal.retrolambda;\n \n import org.objectweb.asm.*;\n+import org.objectweb.asm.tree.*;\n \n import java.lang.reflect.Field;\n+import java.util.*;\n import java.util.concurrent.atomic.AtomicInteger;\n \n import static org.objectweb.asm.Opcodes.*;\n@@ -15,8 +17,14 @@ public class LambdaUsageBackporter {\n \n     public static byte[] transform(byte[] bytecode, int targetVersion) {\n         resetLambdaClassSequenceNumber();\n+\n+        MethodVisibilityAdjuster stage2 = new MethodVisibilityAdjuster();\n+        InvokeDynamicInsnConverter stage1 = new InvokeDynamicInsnConverter(stage2, targetVersion);\n+        new ClassReader(bytecode).accept(stage1, 0);\n+        stage2.makePackagePrivate(stage1.lambdaImplMethods);\n+\n         ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n-        new ClassReader(bytecode).accept(new MyClassVisitor(cw, targetVersion), 0);\n+        stage2.accept(cw);\n         return cw.toByteArray();\n     }\n \n@@ -34,13 +42,14 @@ public class LambdaUsageBackporter {\n     }\n \n \n-    private static class MyClassVisitor extends ClassVisitor {\n+    private static class InvokeDynamicInsnConverter extends ClassVisitor {\n         private final int targetVersion;\n         private int classAccess;\n         private String className;\n+        public final List<Handle> lambdaImplMethods = new ArrayList<>();\n \n-        public MyClassVisitor(ClassWriter cw, int targetVersion) {\n-            super(ASM4, cw);\n+        public InvokeDynamicInsnConverter(ClassVisitor next, int targetVersion) {\n+            super(ASM4, next);\n             this.targetVersion = targetVersion;\n         }\n \n@@ -75,11 +84,8 @@ public class LambdaUsageBackporter {\n                         \"please report a bug at https://github.com/orfjackal/retrolambda/issues \" +\n                         \"together with an SSCCE (http://www.sscce.org/)\");\n             }\n-            if (LambdaNaming.LAMBDA_IMPL_METHOD.matcher(name).matches()) {\n-                access = Flags.makeNonPrivate(access);\n-            }\n             MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n-            return new InvokeDynamicInsnConvertingMethodVisitor(api, mv, className);\n+            return new InvokeDynamicInsnConvertingMethodVisitor(api, mv, className, lambdaImplMethods);\n         }\n \n         private boolean isBridgeMethodOnInterface(int methodAccess) {\n@@ -101,15 +107,18 @@ public class LambdaUsageBackporter {\n \n     private static class InvokeDynamicInsnConvertingMethodVisitor extends MethodVisitor {\n         private final String myClassName;\n+        private final List<Handle> lambdaImplMethods;\n \n-        public InvokeDynamicInsnConvertingMethodVisitor(int api, MethodVisitor mv, String myClassName) {\n+        public InvokeDynamicInsnConvertingMethodVisitor(int api, MethodVisitor mv, String myClassName, List<Handle> lambdaImplMethods) {\n             super(api, mv);\n             this.myClassName = myClassName;\n+            this.lambdaImplMethods = lambdaImplMethods;\n         }\n \n         @Override\n         public void visitInvokeDynamicInsn(String name, String desc, Handle bsm, Object... bsmArgs) {\n             if (bsm.getOwner().equals(LambdaNaming.LAMBDA_METAFACTORY)) {\n+                lambdaImplMethods.add((Handle) bsmArgs[1]);\n                 backportLambda(name, Type.getType(desc), bsm, bsmArgs);\n             } else {\n                 super.visitInvokeDynamicInsn(name, desc, bsm, bsmArgs);\n@@ -131,4 +140,30 @@ public class LambdaUsageBackporter {\n             }\n         }\n     }\n+\n+    private static class MethodVisibilityAdjuster extends ClassNode {\n+\n+        public MethodVisibilityAdjuster() {\n+            super(Opcodes.ASM4);\n+        }\n+\n+        public void makePackagePrivate(List<Handle> targetMethods) {\n+            for (MethodNode method : this.methods) {\n+                if (contains(method, targetMethods)) {\n+                    method.access = Flags.makeNonPrivate(method.access);\n+                }\n+            }\n+        }\n+\n+        private boolean contains(MethodNode needle, List<Handle> haystack) {\n+            for (Handle handle : haystack) {\n+                if (handle.getOwner().equals(this.name) &&\n+                        handle.getName().equals(needle.name) &&\n+                        handle.getDesc().equals(needle.desc)) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n }\n"
    },
    {
        "commit_hash": "313613e1d56b67d19e95b52d35d671580f11913a",
        "previous_commit_hash": "7c10751a30cb69887a47f39a25cddfcf9ec2a25a",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -118,10 +118,10 @@ public class LambdaTest {\n \n     @Test\n     public void method_references_to_private_methods() throws Exception {\n-        Callable<String> ref1 = this::privateInstanceMethod;\n-        Callable<String> ref2 = LambdaTest::privateClassMethod;\n-\n+        Callable<String> ref1 = LambdaTest::privateClassMethod;\n         assertThat(ref1.call(), is(\"foo\"));\n+\n+        Callable<String> ref2 = this::privateInstanceMethod;\n         assertThat(ref2.call(), is(\"foo\"));\n     }\n \n"
    },
    {
        "commit_hash": "9df8ed4b5917a66f874af70c6e2de31a512446c6",
        "previous_commit_hash": "313613e1d56b67d19e95b52d35d671580f11913a",
        "diff_stats": {
            "additions": 14,
            "deletions": 6
        },
        "diff_content": "@@ -23,6 +23,7 @@ public class LambdaClassBackporter {\n         private final int targetVersion;\n         private String lambdaClass;\n         private Type constructor;\n+        private Handle implMethod;\n         private LambdaFactoryMethod factoryMethod;\n \n         public LambdaClassVisitor(ClassWriter cw, int targetVersion) {\n@@ -34,6 +35,7 @@ public class LambdaClassBackporter {\n         public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n             lambdaClass = name;\n             LambdaReifier.setLambdaClass(lambdaClass);\n+            implMethod = LambdaReifier.getLambdaImplMethod();\n             factoryMethod = LambdaReifier.getLambdaFactoryMethod();\n \n             if (version > targetVersion) {\n@@ -52,7 +54,7 @@ public class LambdaClassBackporter {\n             }\n             MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n             mv = new MagicLambdaRemovingMethodVisitor(mv);\n-            mv = new PrivateMethodInvocationFixingMethodVisitor(mv, factoryMethod.getInvoker());\n+            mv = new PrivateMethodInvocationFixingMethodVisitor(mv, implMethod);\n             return mv;\n         }\n \n@@ -135,18 +137,24 @@ public class LambdaClassBackporter {\n \n     private static class PrivateMethodInvocationFixingMethodVisitor extends MethodVisitor {\n \n-        private final String invoker;\n+        private final Handle implMethod;\n \n-        public PrivateMethodInvocationFixingMethodVisitor(MethodVisitor mv, Class<?> invoker) {\n+        public PrivateMethodInvocationFixingMethodVisitor(MethodVisitor mv, Handle implMethod) {\n             super(ASM4, mv);\n-            this.invoker = Type.getInternalName(invoker);\n+            this.implMethod = implMethod;\n         }\n \n         @Override\n         public void visitMethodInsn(int opcode, String owner, String name, String desc) {\n+            // Java 8's lambda classes get away with calling private virtual methods\n+            // by using invokespecial because the JVM relaxes the bytecode validation\n+            // of the lambda classes it generates. We must however use invokevirtual\n+            // for them (which is possible because we also make them non-private).\n             if (opcode == INVOKESPECIAL\n-                    && owner.equals(invoker)\n-                    && LambdaNaming.LAMBDA_IMPL_METHOD.matcher(name).matches()) {\n+                    && !name.equals(\"<init>\")\n+                    && owner.equals(implMethod.getOwner())\n+                    && name.equals(implMethod.getName())\n+                    && desc.equals(implMethod.getDesc())) {\n                 opcode = INVOKEVIRTUAL;\n             }\n             super.visitMethodInsn(opcode, owner, name, desc);\n"
    },
    {
        "commit_hash": "9df8ed4b5917a66f874af70c6e2de31a512446c6",
        "previous_commit_hash": "313613e1d56b67d19e95b52d35d671580f11913a",
        "diff_stats": {
            "additions": 1,
            "deletions": 7
        },
        "diff_content": "@@ -10,12 +10,10 @@ public class LambdaFactoryMethod {\n \n     private final String owner;\n     private final String desc;\n-    private final Class<?> invoker;\n \n-    public LambdaFactoryMethod(String lambdaClass, Type invokedType, Class<?> invoker) {\n+    public LambdaFactoryMethod(String lambdaClass, Type invokedType) {\n         owner = lambdaClass;\n         desc = invokedType.getDescriptor();\n-        this.invoker = invoker;\n     }\n \n     public String getOwner() {\n@@ -29,8 +27,4 @@ public class LambdaFactoryMethod {\n     public String getDesc() {\n         return desc;\n     }\n-\n-    public Class<?> getInvoker() {\n-        return invoker;\n-    }\n }\n"
    },
    {
        "commit_hash": "9df8ed4b5917a66f874af70c6e2de31a512446c6",
        "previous_commit_hash": "313613e1d56b67d19e95b52d35d671580f11913a",
        "diff_stats": {
            "additions": 0,
            "deletions": 6
        },
        "diff_content": "@@ -15,10 +15,4 @@ public class LambdaNaming {\n      * Java 8 produces at runtime classes named {@code EnclosingClass$$Lambda$1}\n      */\n     public static final Pattern LAMBDA_CLASS = Pattern.compile(\"^.+\\\\$\\\\$Lambda\\\\$\\\\d+$\");\n-\n-    /**\n-     * Oracle JDK 8 compiler names the methods {@code lambda$methodName$0} but the\n-     * Eclipse JDT compiler names them {@code lambda$0} (similar to older JDK 8 EA builds).\n-     */\n-    public static final Pattern LAMBDA_IMPL_METHOD = Pattern.compile(\"^lambda(\\\\$.*)?\\\\$\\\\d+$\");\n }\n"
    },
    {
        "commit_hash": "9df8ed4b5917a66f874af70c6e2de31a512446c6",
        "previous_commit_hash": "313613e1d56b67d19e95b52d35d671580f11913a",
        "diff_stats": {
            "additions": 11,
            "deletions": 8
        },
        "diff_content": "@@ -19,13 +19,13 @@ public class LambdaReifier {\n     // is spying on the LambdaMetafactory's dynamically generated bytecode.\n     // We expect only one class being processed at a time, so it should\n     // be an error if these collections contain more than one element.\n-    private static final BlockingDeque<Class<?>> currentInvoker = new LinkedBlockingDeque<>(1);\n+    private static final BlockingDeque<Handle> currentLambdaImplMethod = new LinkedBlockingDeque<>(1);\n     private static final BlockingDeque<Type> currentInvokedType = new LinkedBlockingDeque<>(1);\n     private static final BlockingDeque<String> currentLambdaClass = new LinkedBlockingDeque<>(1);\n \n-    public static LambdaFactoryMethod reifyLambdaClass(Class<?> invoker, String invokedName, Type invokedType, Handle bsm, Object[] bsmArgs) {\n+    public static LambdaFactoryMethod reifyLambdaClass(Handle lambdaImplMethod, Class<?> invoker, String invokedName, Type invokedType, Handle bsm, Object[] bsmArgs) {\n         try {\n-            setInvoker(invoker);\n+            setLambdaImplMethod(lambdaImplMethod);\n             setInvokedType(invokedType);\n \n             // Causes the lambda class to be loaded. Retrolambda's Java agent\n@@ -42,8 +42,8 @@ public class LambdaReifier {\n         }\n     }\n \n-    public static void setInvoker(Class<?> invoker) {\n-        currentInvoker.push(invoker);\n+    private static void setLambdaImplMethod(Handle lambdaImplMethod) {\n+        currentLambdaImplMethod.push(lambdaImplMethod);\n     }\n \n     private static void setInvokedType(Type invokedType) {\n@@ -54,15 +54,18 @@ public class LambdaReifier {\n         currentLambdaClass.push(lambdaClass);\n     }\n \n+    public static Handle getLambdaImplMethod() {\n+        return currentLambdaImplMethod.getFirst();\n+    }\n+\n     public static LambdaFactoryMethod getLambdaFactoryMethod() {\n         String lambdaClass = currentLambdaClass.getFirst();\n         Type invokedType = currentInvokedType.getFirst();\n-        Class<?> invoker = currentInvoker.getFirst();\n-        return new LambdaFactoryMethod(lambdaClass, invokedType, invoker);\n+        return new LambdaFactoryMethod(lambdaClass, invokedType);\n     }\n \n     private static void resetGlobals() {\n-        currentInvoker.clear();\n+        currentLambdaImplMethod.clear();\n         currentInvokedType.clear();\n         currentLambdaClass.clear();\n     }\n"
    },
    {
        "commit_hash": "9df8ed4b5917a66f874af70c6e2de31a512446c6",
        "previous_commit_hash": "313613e1d56b67d19e95b52d35d671580f11913a",
        "diff_stats": {
            "additions": 3,
            "deletions": 2
        },
        "diff_content": "@@ -118,7 +118,6 @@ public class LambdaUsageBackporter {\n         @Override\n         public void visitInvokeDynamicInsn(String name, String desc, Handle bsm, Object... bsmArgs) {\n             if (bsm.getOwner().equals(LambdaNaming.LAMBDA_METAFACTORY)) {\n-                lambdaImplMethods.add((Handle) bsmArgs[1]);\n                 backportLambda(name, Type.getType(desc), bsm, bsmArgs);\n             } else {\n                 super.visitInvokeDynamicInsn(name, desc, bsm, bsmArgs);\n@@ -127,7 +126,9 @@ public class LambdaUsageBackporter {\n \n         private void backportLambda(String invokedName, Type invokedType, Handle bsm, Object[] bsmArgs) {\n             Class<?> invoker = loadClass(myClassName);\n-            LambdaFactoryMethod factory = LambdaReifier.reifyLambdaClass(invoker, invokedName, invokedType, bsm, bsmArgs);\n+            Handle lambdaImplMethod = (Handle) bsmArgs[1];\n+            lambdaImplMethods.add(lambdaImplMethod);\n+            LambdaFactoryMethod factory = LambdaReifier.reifyLambdaClass(lambdaImplMethod, invoker, invokedName, invokedType, bsm, bsmArgs);\n             super.visitMethodInsn(INVOKESTATIC, factory.getOwner(), factory.getName(), factory.getDesc());\n         }\n \n"
    },
    {
        "commit_hash": "0aee78d04114deb065736cdba89444b15552c011",
        "previous_commit_hash": "9df8ed4b5917a66f874af70c6e2de31a512446c6",
        "diff_stats": {
            "additions": 19,
            "deletions": 1
        },
        "diff_content": "@@ -14,7 +14,7 @@ import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.*;\n import static org.junit.Assert.assertTrue;\n \n-public class LambdaTest {\n+public class LambdaTest extends SuperClass {\n \n     @Test\n     public void empty_lambda() {\n@@ -116,6 +116,18 @@ public class LambdaTest {\n         assertThat(ref.call(), is(instanceOf(ArrayList.class)));\n     }\n \n+    @Test\n+    public void method_references_to_overridden_inherited_methods_with_super() throws Exception {\n+        Callable<String> ref = super::inheritedMethod;\n+\n+        assertThat(ref.call(), is(\"superclass version\"));\n+    }\n+\n+    @Override\n+    String inheritedMethod() {\n+        return \"overridden version\";\n+    }\n+\n     @Test\n     public void method_references_to_private_methods() throws Exception {\n         Callable<String> ref1 = LambdaTest::privateClassMethod;\n@@ -153,3 +165,9 @@ public class LambdaTest {\n         return \"foo\";\n     }\n }\n+\n+class SuperClass {\n+    String inheritedMethod() {\n+        return \"superclass version\";\n+    }\n+}\n"
    },
    {
        "commit_hash": "81cf45c5823ee489c270c7c2abebccf54e741887",
        "previous_commit_hash": "0aee78d04114deb065736cdba89444b15552c011",
        "diff_stats": {
            "additions": 4,
            "deletions": 2
        },
        "diff_content": "@@ -133,8 +133,10 @@ that `java.lang.invoke.LambdaMetafactory` generates dynamically, so\n optimizations to that mechanism may break Retrolambda.\n \n Does not implement JDK 8's safety measure of using `invokespecial` to call\n-lambda implementation methods that are private instance methods (i.e. when\n-the lambda accesses an instance variable).\n+lambda implementation methods that are private instance methods (such as\n+when the lambda accesses an instance variable, or the lambda is a method\n+reference to a private instance method), but instead makes those methods\n+package-private.\n \n \n Version History\n"
    },
    {
        "commit_hash": "b84e310e27c01e929cf76e0c57610dd96c857308",
        "previous_commit_hash": "81cf45c5823ee489c270c7c2abebccf54e741887",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -76,7 +76,7 @@ To run Retrolambda using Maven, add the following to your pom.xml:\n <plugin>\n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>retrolambda-maven-plugin</artifactId>\n-    <version>1.2.1</version>\n+    <version>1.2.2</version>\n     <executions>\n         <execution>\n             <goals>\n@@ -142,7 +142,7 @@ package-private.\n Version History\n ---------------\n \n-### Upcoming\n+### Retrolambda 1.2.2 (2014-05-15)\n \n - Fixed method references to private methods; will now make them\n   package-private the same way as lambda implementation methods\n"
    },
    {
        "commit_hash": "b84e310e27c01e929cf76e0c57610dd96c857308",
        "previous_commit_hash": "81cf45c5823ee489c270c7c2abebccf54e741887",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.2.2-SNAPSHOT</version>\n+        <version>1.2.2</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "b84e310e27c01e929cf76e0c57610dd96c857308",
        "previous_commit_hash": "81cf45c5823ee489c270c7c2abebccf54e741887",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>1.2.2-SNAPSHOT</version>\n+    <version>1.2.2</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "b84e310e27c01e929cf76e0c57610dd96c857308",
        "previous_commit_hash": "81cf45c5823ee489c270c7c2abebccf54e741887",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.2.2-SNAPSHOT</version>\n+        <version>1.2.2</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "b84e310e27c01e929cf76e0c57610dd96c857308",
        "previous_commit_hash": "81cf45c5823ee489c270c7c2abebccf54e741887",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.2.2-SNAPSHOT</version>\n+        <version>1.2.2</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "b84e310e27c01e929cf76e0c57610dd96c857308",
        "previous_commit_hash": "81cf45c5823ee489c270c7c2abebccf54e741887",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.2.2-SNAPSHOT</version>\n+        <version>1.2.2</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "d213752b155cefd90ff109ffb8cf05fec1da1d38",
        "previous_commit_hash": "b84e310e27c01e929cf76e0c57610dd96c857308",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.2.2</version>\n+        <version>1.2.3-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "d213752b155cefd90ff109ffb8cf05fec1da1d38",
        "previous_commit_hash": "b84e310e27c01e929cf76e0c57610dd96c857308",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>1.2.2</version>\n+    <version>1.2.3-SNAPSHOT</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "d213752b155cefd90ff109ffb8cf05fec1da1d38",
        "previous_commit_hash": "b84e310e27c01e929cf76e0c57610dd96c857308",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.2.2</version>\n+        <version>1.2.3-SNAPSHOT</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "d213752b155cefd90ff109ffb8cf05fec1da1d38",
        "previous_commit_hash": "b84e310e27c01e929cf76e0c57610dd96c857308",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.2.2</version>\n+        <version>1.2.3-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "d213752b155cefd90ff109ffb8cf05fec1da1d38",
        "previous_commit_hash": "b84e310e27c01e929cf76e0c57610dd96c857308",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.2.2</version>\n+        <version>1.2.3-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "9bc1def147706d0d6a3f638628b16159b66a17ec",
        "previous_commit_hash": "d213752b155cefd90ff109ffb8cf05fec1da1d38",
        "diff_stats": {
            "additions": 40,
            "deletions": 1
        },
        "diff_content": "@@ -135,6 +135,11 @@ public class LambdaTest extends SuperClass {\n \n         Callable<String> ref2 = this::privateInstanceMethod;\n         assertThat(ref2.call(), is(\"foo\"));\n+\n+        // Normal method calls should still work after our magic\n+        // of making them them accessible from the lambda classes.\n+        assertThat(privateClassMethod(), is(\"foo\"));\n+        assertThat(privateInstanceMethod(), is(\"foo\"));\n     }\n \n     private String privateInstanceMethod() {\n@@ -146,7 +151,7 @@ public class LambdaTest extends SuperClass {\n     }\n \n     /**\n-     * We must make private lambda implementation methods package-private,\n+     * We could make private lambda implementation methods package-private,\n      * so that the lambda class may call them, but we should not make any\n      * more methods non-private than is absolutely necessary.\n      */\n@@ -164,10 +169,44 @@ public class LambdaTest extends SuperClass {\n     private String unrelatedPrivateMethod() {\n         return \"foo\";\n     }\n+\n+    /**\n+     * We cannot just make the private methods package-private for the\n+     * lambda class to call them, because that may cause a method in subclass\n+     * to override them.\n+     */\n+    @Test\n+    public void will_not_cause_private_methods_to_be_overridable() throws Exception {\n+        // Our test assumes that there exists a private method with\n+        // the same name and signature in super and sub classes.\n+        String name = \"privateMethod\";\n+        assertThat(getClass().getDeclaredMethod(name), is(notNullValue()));\n+        assertThat(getClass().getSuperclass().getDeclaredMethod(name), is(notNullValue()));\n+\n+        assertThat(privateMethod(), is(\"subclass version\"));\n+\n+        Callable<String> ref1 = this::privateMethod;\n+        assertThat(ref1.call(), is(\"subclass version\"));\n+\n+        Callable<String> ref2 = privateMethodInSuperAsMethodReference();\n+        assertThat(ref2.call(), is(\"superclass version\"));\n+    }\n+\n+    private String privateMethod() {\n+        return \"subclass version\";\n+    }\n }\n \n class SuperClass {\n     String inheritedMethod() {\n         return \"superclass version\";\n     }\n+\n+    Callable<String> privateMethodInSuperAsMethodReference() {\n+        return this::privateMethod;\n+    }\n+\n+    private String privateMethod() {\n+        return \"superclass version\";\n+    }\n }\n"
    },
    {
        "commit_hash": "d006afdd9e118d4feaa2426a97ad53c5dbd74398",
        "previous_commit_hash": "9bc1def147706d0d6a3f638628b16159b66a17ec",
        "diff_stats": {
            "additions": 27,
            "deletions": 20
        },
        "diff_content": "@@ -177,23 +177,38 @@ public class LambdaTest extends SuperClass {\n      */\n     @Test\n     public void will_not_cause_private_methods_to_be_overridable() throws Exception {\n+        class Parent {\n+            private String privateMethod() {\n+                return \"parent version\";\n+            }\n+\n+            Callable<String> parentRef() {\n+                return this::privateMethod;\n+            }\n+        }\n+        class Child extends Parent {\n+            private String privateMethod() { // would override if were not private\n+                return \"child version\";\n+            }\n+\n+            Callable<String> childRef() {\n+                return this::privateMethod;\n+            }\n+        }\n+\n+        Child child = new Child();\n+\n         // Our test assumes that there exists a private method with\n         // the same name and signature in super and sub classes.\n         String name = \"privateMethod\";\n-        assertThat(getClass().getDeclaredMethod(name), is(notNullValue()));\n-        assertThat(getClass().getSuperclass().getDeclaredMethod(name), is(notNullValue()));\n-\n-        assertThat(privateMethod(), is(\"subclass version\"));\n+        assertThat(child.getClass().getDeclaredMethod(name), is(notNullValue()));\n+        assertThat(child.getClass().getSuperclass().getDeclaredMethod(name), is(notNullValue()));\n \n-        Callable<String> ref1 = this::privateMethod;\n-        assertThat(ref1.call(), is(\"subclass version\"));\n+        Callable<String> ref1 = child.childRef();\n+        assertThat(ref1.call(), is(\"child version\"));\n \n-        Callable<String> ref2 = privateMethodInSuperAsMethodReference();\n-        assertThat(ref2.call(), is(\"superclass version\"));\n-    }\n-\n-    private String privateMethod() {\n-        return \"subclass version\";\n+        Callable<String> ref2 = child.parentRef();\n+        assertThat(ref2.call(), is(\"parent version\"));\n     }\n }\n \n@@ -201,12 +216,4 @@ class SuperClass {\n     String inheritedMethod() {\n         return \"superclass version\";\n     }\n-\n-    Callable<String> privateMethodInSuperAsMethodReference() {\n-        return this::privateMethod;\n-    }\n-\n-    private String privateMethod() {\n-        return \"superclass version\";\n-    }\n }\n"
    },
    {
        "commit_hash": "d5b822fe85cd96696ced51c001ff43e1a84e88aa",
        "previous_commit_hash": "d006afdd9e118d4feaa2426a97ad53c5dbd74398",
        "diff_stats": {
            "additions": 9,
            "deletions": 9
        },
        "diff_content": "@@ -27,7 +27,7 @@ public class LambdaClassBackporter {\n         private LambdaFactoryMethod factoryMethod;\n \n         public LambdaClassVisitor(ClassWriter cw, int targetVersion) {\n-            super(ASM4, cw);\n+            super(ASM5, cw);\n             this.targetVersion = targetVersion;\n         }\n \n@@ -76,7 +76,7 @@ public class LambdaClassBackporter {\n             mv.visitCode();\n             mv.visitTypeInsn(NEW, lambdaClass);\n             mv.visitInsn(DUP);\n-            mv.visitMethodInsn(INVOKESPECIAL, lambdaClass, \"<init>\", \"()V\");\n+            mv.visitMethodInsn(INVOKESPECIAL, lambdaClass, \"<init>\", \"()V\", false);\n             mv.visitFieldInsn(PUTSTATIC, lambdaClass, SINGLETON_FIELD_NAME, singletonFieldDesc());\n             mv.visitInsn(RETURN);\n             mv.visitMaxs(-1, -1); // rely on ClassWriter.COMPUTE_MAXS\n@@ -100,7 +100,7 @@ public class LambdaClassBackporter {\n                     mv.visitVarInsn(type.getOpcode(ILOAD), varIndex);\n                     varIndex += type.getSize();\n                 }\n-                mv.visitMethodInsn(INVOKESPECIAL, lambdaClass, \"<init>\", constructor.getDescriptor());\n+                mv.visitMethodInsn(INVOKESPECIAL, lambdaClass, \"<init>\", constructor.getDescriptor(), false);\n                 mv.visitInsn(ARETURN);\n             }\n \n@@ -120,18 +120,18 @@ public class LambdaClassBackporter {\n     private static class MagicLambdaRemovingMethodVisitor extends MethodVisitor {\n \n         public MagicLambdaRemovingMethodVisitor(MethodVisitor mv) {\n-            super(ASM4, mv);\n+            super(ASM5, mv);\n         }\n \n         @Override\n-        public void visitMethodInsn(int opcode, String owner, String name, String desc) {\n+        public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\n             if (opcode == INVOKESPECIAL\n                     && owner.equals(LambdaNaming.MAGIC_LAMBDA_IMPL)\n                     && name.equals(\"<init>\")\n                     && desc.equals(\"()V\")) {\n                 owner = JAVA_LANG_OBJECT;\n             }\n-            super.visitMethodInsn(opcode, owner, name, desc);\n+            super.visitMethodInsn(opcode, owner, name, desc, itf);\n         }\n     }\n \n@@ -140,12 +140,12 @@ public class LambdaClassBackporter {\n         private final Handle implMethod;\n \n         public PrivateMethodInvocationFixingMethodVisitor(MethodVisitor mv, Handle implMethod) {\n-            super(ASM4, mv);\n+            super(ASM5, mv);\n             this.implMethod = implMethod;\n         }\n \n         @Override\n-        public void visitMethodInsn(int opcode, String owner, String name, String desc) {\n+        public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\n             // Java 8's lambda classes get away with calling private virtual methods\n             // by using invokespecial because the JVM relaxes the bytecode validation\n             // of the lambda classes it generates. We must however use invokevirtual\n@@ -157,7 +157,7 @@ public class LambdaClassBackporter {\n                     && desc.equals(implMethod.getDesc())) {\n                 opcode = INVOKEVIRTUAL;\n             }\n-            super.visitMethodInsn(opcode, owner, name, desc);\n+            super.visitMethodInsn(opcode, owner, name, desc, itf);\n         }\n     }\n }\n"
    },
    {
        "commit_hash": "d5b822fe85cd96696ced51c001ff43e1a84e88aa",
        "previous_commit_hash": "d006afdd9e118d4feaa2426a97ad53c5dbd74398",
        "diff_stats": {
            "additions": 11,
            "deletions": 11
        },
        "diff_content": "@@ -49,7 +49,7 @@ public class LambdaUsageBackporter {\n         public final List<Handle> lambdaImplMethods = new ArrayList<>();\n \n         public InvokeDynamicInsnConverter(ClassVisitor next, int targetVersion) {\n-            super(ASM4, next);\n+            super(ASM5, next);\n             this.targetVersion = targetVersion;\n         }\n \n@@ -85,23 +85,23 @@ public class LambdaUsageBackporter {\n                         \"together with an SSCCE (http://www.sscce.org/)\");\n             }\n             MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n-            return new InvokeDynamicInsnConvertingMethodVisitor(api, mv, className, lambdaImplMethods);\n+            return new InvokeDynamicInsnConvertingMethodVisitor(mv, className, lambdaImplMethods);\n         }\n \n         private boolean isBridgeMethodOnInterface(int methodAccess) {\n-            return Flags.hasFlag(classAccess, Opcodes.ACC_INTERFACE) &&\n-                    Flags.hasFlag(methodAccess, Opcodes.ACC_BRIDGE);\n+            return Flags.hasFlag(classAccess, ACC_INTERFACE) &&\n+                    Flags.hasFlag(methodAccess, ACC_BRIDGE);\n         }\n \n         private boolean isNonAbstractMethodOnInterface(int methodAccess) {\n-            return Flags.hasFlag(classAccess, Opcodes.ACC_INTERFACE) &&\n-                    !Flags.hasFlag(methodAccess, Opcodes.ACC_ABSTRACT);\n+            return Flags.hasFlag(classAccess, ACC_INTERFACE) &&\n+                    !Flags.hasFlag(methodAccess, ACC_ABSTRACT);\n         }\n \n         private static boolean isClassInitializerMethod(String name, String desc, int methodAccess) {\n             return name.equals(\"<clinit>\") &&\n                     desc.equals(\"()V\") &&\n-                    Flags.hasFlag(methodAccess, Opcodes.ACC_STATIC);\n+                    Flags.hasFlag(methodAccess, ACC_STATIC);\n         }\n     }\n \n@@ -109,8 +109,8 @@ public class LambdaUsageBackporter {\n         private final String myClassName;\n         private final List<Handle> lambdaImplMethods;\n \n-        public InvokeDynamicInsnConvertingMethodVisitor(int api, MethodVisitor mv, String myClassName, List<Handle> lambdaImplMethods) {\n-            super(api, mv);\n+        public InvokeDynamicInsnConvertingMethodVisitor(MethodVisitor mv, String myClassName, List<Handle> lambdaImplMethods) {\n+            super(ASM5, mv);\n             this.myClassName = myClassName;\n             this.lambdaImplMethods = lambdaImplMethods;\n         }\n@@ -129,7 +129,7 @@ public class LambdaUsageBackporter {\n             Handle lambdaImplMethod = (Handle) bsmArgs[1];\n             lambdaImplMethods.add(lambdaImplMethod);\n             LambdaFactoryMethod factory = LambdaReifier.reifyLambdaClass(lambdaImplMethod, invoker, invokedName, invokedType, bsm, bsmArgs);\n-            super.visitMethodInsn(INVOKESTATIC, factory.getOwner(), factory.getName(), factory.getDesc());\n+            super.visitMethodInsn(INVOKESTATIC, factory.getOwner(), factory.getName(), factory.getDesc(), false);\n         }\n \n         private static Class<?> loadClass(String className) {\n@@ -145,7 +145,7 @@ public class LambdaUsageBackporter {\n     private static class MethodVisibilityAdjuster extends ClassNode {\n \n         public MethodVisibilityAdjuster() {\n-            super(Opcodes.ASM4);\n+            super(ASM5);\n         }\n \n         public void makePackagePrivate(List<Handle> targetMethods) {\n"
    },
    {
        "commit_hash": "2e9ecf358bbb337cd1cf2a5d10d1b83adbfac9d6",
        "previous_commit_hash": "d5b822fe85cd96696ced51c001ff43e1a84e88aa",
        "diff_stats": {
            "additions": 4,
            "deletions": 4
        },
        "diff_content": "@@ -204,11 +204,11 @@ public class LambdaTest extends SuperClass {\n         assertThat(child.getClass().getDeclaredMethod(name), is(notNullValue()));\n         assertThat(child.getClass().getSuperclass().getDeclaredMethod(name), is(notNullValue()));\n \n-        Callable<String> ref1 = child.childRef();\n-        assertThat(ref1.call(), is(\"child version\"));\n+        assertThat(child.privateMethod(), is(\"child version\"));\n+        assertThat(child.childRef().call(), is(\"child version\"));\n \n-        Callable<String> ref2 = child.parentRef();\n-        assertThat(ref2.call(), is(\"parent version\"));\n+        assertThat(((Parent) child).privateMethod(), is(\"parent version\"));\n+        assertThat(child.parentRef().call(), is(\"parent version\"));\n     }\n }\n \n"
    },
    {
        "commit_hash": "bccd9b235ab201469a9d4e7851d0cb7aaed31aba",
        "previous_commit_hash": "2e9ecf358bbb337cd1cf2a5d10d1b83adbfac9d6",
        "diff_stats": {
            "additions": 9,
            "deletions": 0
        },
        "diff_content": "@@ -142,6 +142,15 @@ package-private.\n Version History\n ---------------\n \n+### Upcoming\n+\n+- Android: Fixed NoSuchMethodError when calling a private method to which\n+  there is a method reference\n+  ([Issue #18](https://github.com/orfjackal/retrolambda/issues/18))\n+- Fixed the possibility of accidentally overriding private methods to which\n+  there is method reference\n+  ([Issue #19](https://github.com/orfjackal/retrolambda/issues/19))\n+\n ### Retrolambda 1.2.2 (2014-05-15)\n \n - Fixed method references to private methods; will now make them\n"
    },
    {
        "commit_hash": "bccd9b235ab201469a9d4e7851d0cb7aaed31aba",
        "previous_commit_hash": "2e9ecf358bbb337cd1cf2a5d10d1b83adbfac9d6",
        "diff_stats": {
            "additions": 1,
            "deletions": 14
        },
        "diff_content": "@@ -1,25 +1,12 @@\n-// Copyright \u00a9 2013 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n package net.orfjackal.retrolambda;\n \n-import static org.objectweb.asm.Opcodes.ACC_PRIVATE;\n-\n public class Flags {\n \n-    public static int makeNonPrivate(int access) {\n-        if (hasFlag(access, ACC_PRIVATE)) {\n-            return clearFlag(access, ACC_PRIVATE); // make package-private (i.e. no flag)\n-        }\n-        return access;\n-    }\n-\n     public static boolean hasFlag(int subject, int flag) {\n         return (subject & flag) == flag;\n     }\n-\n-    public static int clearFlag(int subject, int flag) {\n-        return subject & ~flag;\n-    }\n }\n"
    },
    {
        "commit_hash": "bccd9b235ab201469a9d4e7851d0cb7aaed31aba",
        "previous_commit_hash": "2e9ecf358bbb337cd1cf2a5d10d1b83adbfac9d6",
        "diff_stats": {
            "additions": 30,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,30 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda;\n+\n+import org.objectweb.asm.Handle;\n+\n+import static org.objectweb.asm.Opcodes.*;\n+\n+public class Handles {\n+\n+    public static int getOpcode(Handle handle) {\n+        int tag = handle.getTag();\n+        switch (tag) {\n+            case H_INVOKEVIRTUAL:\n+                return INVOKEVIRTUAL;\n+            case H_INVOKESTATIC:\n+                return INVOKESTATIC;\n+            case H_INVOKESPECIAL:\n+                return INVOKESPECIAL;\n+            case H_NEWINVOKESPECIAL:\n+                return INVOKESPECIAL; // we assume that the caller takes care of the NEW instruction\n+            case H_INVOKEINTERFACE:\n+                return INVOKEINTERFACE;\n+            default:\n+                throw new IllegalArgumentException(\"Unsupported tag \" + tag + \" in \" + handle);\n+        }\n+    }\n+}\n"
    },
    {
        "commit_hash": "bccd9b235ab201469a9d4e7851d0cb7aaed31aba",
        "previous_commit_hash": "2e9ecf358bbb337cd1cf2a5d10d1b83adbfac9d6",
        "diff_stats": {
            "additions": 18,
            "deletions": 10
        },
        "diff_content": "@@ -24,6 +24,7 @@ public class LambdaClassBackporter {\n         private String lambdaClass;\n         private Type constructor;\n         private Handle implMethod;\n+        private Handle bridgeMethod;\n         private LambdaFactoryMethod factoryMethod;\n \n         public LambdaClassVisitor(ClassWriter cw, int targetVersion) {\n@@ -36,6 +37,7 @@ public class LambdaClassBackporter {\n             lambdaClass = name;\n             LambdaReifier.setLambdaClass(lambdaClass);\n             implMethod = LambdaReifier.getLambdaImplMethod();\n+            bridgeMethod = LambdaReifier.getLambdaBridgeMethod();\n             factoryMethod = LambdaReifier.getLambdaFactoryMethod();\n \n             if (version > targetVersion) {\n@@ -54,7 +56,7 @@ public class LambdaClassBackporter {\n             }\n             MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n             mv = new MagicLambdaRemovingMethodVisitor(mv);\n-            mv = new PrivateMethodInvocationFixingMethodVisitor(mv, implMethod);\n+            mv = new PrivateMethodInvocationFixingMethodVisitor(mv, this);\n             return mv;\n         }\n \n@@ -138,26 +140,32 @@ public class LambdaClassBackporter {\n     private static class PrivateMethodInvocationFixingMethodVisitor extends MethodVisitor {\n \n         private final Handle implMethod;\n+        private final Handle bridgeMethod;\n \n-        public PrivateMethodInvocationFixingMethodVisitor(MethodVisitor mv, Handle implMethod) {\n+        public PrivateMethodInvocationFixingMethodVisitor(MethodVisitor mv, LambdaClassVisitor context) {\n             super(ASM5, mv);\n-            this.implMethod = implMethod;\n+            this.implMethod = context.implMethod;\n+            this.bridgeMethod = context.bridgeMethod;\n         }\n \n         @Override\n         public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\n             // Java 8's lambda classes get away with calling private virtual methods\n             // by using invokespecial because the JVM relaxes the bytecode validation\n-            // of the lambda classes it generates. We must however use invokevirtual\n-            // for them (which is possible because we also make them non-private).\n-            if (opcode == INVOKESPECIAL\n-                    && !name.equals(\"<init>\")\n-                    && owner.equals(implMethod.getOwner())\n+            // of the lambda classes it generates. We must however call them through\n+            // a non-private bridge method which we have generated.\n+            if (owner.equals(implMethod.getOwner())\n                     && name.equals(implMethod.getName())\n                     && desc.equals(implMethod.getDesc())) {\n-                opcode = INVOKEVIRTUAL;\n+                super.visitMethodInsn(\n+                        Handles.getOpcode(bridgeMethod),\n+                        bridgeMethod.getOwner(),\n+                        bridgeMethod.getName(),\n+                        bridgeMethod.getDesc(),\n+                        bridgeMethod.getTag() == H_INVOKEINTERFACE);\n+            } else {\n+                super.visitMethodInsn(opcode, owner, name, desc, itf);\n             }\n-            super.visitMethodInsn(opcode, owner, name, desc, itf);\n         }\n     }\n }\n"
    },
    {
        "commit_hash": "bccd9b235ab201469a9d4e7851d0cb7aaed31aba",
        "previous_commit_hash": "2e9ecf358bbb337cd1cf2a5d10d1b83adbfac9d6",
        "diff_stats": {
            "additions": 16,
            "deletions": 43
        },
        "diff_content": "@@ -11,8 +11,6 @@ import java.lang.reflect.Constructor;\n import java.util.*;\n import java.util.concurrent.*;\n \n-import static org.objectweb.asm.Opcodes.*;\n-\n public class LambdaReifier {\n \n     // These globals are used for communicating with the Java agent which\n@@ -20,12 +18,15 @@ public class LambdaReifier {\n     // We expect only one class being processed at a time, so it should\n     // be an error if these collections contain more than one element.\n     private static final BlockingDeque<Handle> currentLambdaImplMethod = new LinkedBlockingDeque<>(1);\n+    private static final BlockingDeque<Handle> currentLambdaBridgeMethod = new LinkedBlockingDeque<>(1);\n     private static final BlockingDeque<Type> currentInvokedType = new LinkedBlockingDeque<>(1);\n     private static final BlockingDeque<String> currentLambdaClass = new LinkedBlockingDeque<>(1);\n \n-    public static LambdaFactoryMethod reifyLambdaClass(Handle lambdaImplMethod, Class<?> invoker, String invokedName, Type invokedType, Handle bsm, Object[] bsmArgs) {\n+    public static LambdaFactoryMethod reifyLambdaClass(Handle lambdaImplMethod, Handle lambdaBridgeMethod,\n+                                                       Class<?> invoker, String invokedName, Type invokedType, Handle bsm, Object[] bsmArgs) {\n         try {\n             setLambdaImplMethod(lambdaImplMethod);\n+            setLambdaBridgeMethod(lambdaBridgeMethod);\n             setInvokedType(invokedType);\n \n             // Causes the lambda class to be loaded. Retrolambda's Java agent\n@@ -46,6 +47,10 @@ public class LambdaReifier {\n         currentLambdaImplMethod.push(lambdaImplMethod);\n     }\n \n+    private static void setLambdaBridgeMethod(Handle lambdaBridgeMethod) {\n+        currentLambdaBridgeMethod.push(lambdaBridgeMethod);\n+    }\n+\n     private static void setInvokedType(Type invokedType) {\n         currentInvokedType.push(invokedType);\n     }\n@@ -58,6 +63,10 @@ public class LambdaReifier {\n         return currentLambdaImplMethod.getFirst();\n     }\n \n+    public static Handle getLambdaBridgeMethod() {\n+        return currentLambdaBridgeMethod.getFirst();\n+    }\n+\n     public static LambdaFactoryMethod getLambdaFactoryMethod() {\n         String lambdaClass = currentLambdaClass.getFirst();\n         Type invokedType = currentInvokedType.getFirst();\n@@ -66,6 +75,7 @@ public class LambdaReifier {\n \n     private static void resetGlobals() {\n         currentLambdaImplMethod.clear();\n+        currentLambdaBridgeMethod.clear();\n         currentInvokedType.clear();\n         currentLambdaClass.clear();\n     }\n@@ -77,12 +87,12 @@ public class LambdaReifier {\n         List<Object> args = new ArrayList<>();\n         args.add(caller);\n         args.add(invokedName);\n-        args.add(toMethodType(invokedType, cl));\n+        args.add(Types.toMethodType(invokedType, cl));\n         for (Object arg : bsmArgs) {\n-            args.add(asmToJdkType(arg, cl, caller));\n+            args.add(Types.asmToJdkType(arg, cl, caller));\n         }\n \n-        MethodHandle bootstrapMethod = toMethodHandle(bsm, cl, caller);\n+        MethodHandle bootstrapMethod = Types.toMethodHandle(bsm, cl, caller);\n         return (CallSite) bootstrapMethod.invokeWithArguments(args);\n     }\n \n@@ -91,41 +101,4 @@ public class LambdaReifier {\n         ctor.setAccessible(true);\n         return ctor.newInstance(targetClass);\n     }\n-\n-    private static Object asmToJdkType(Object arg, ClassLoader classLoader, MethodHandles.Lookup caller) throws Exception {\n-        if (arg instanceof Type) {\n-            return toMethodType((Type) arg, classLoader);\n-        } else if (arg instanceof Handle) {\n-            return toMethodHandle((Handle) arg, classLoader, caller);\n-        } else {\n-            return arg;\n-        }\n-    }\n-\n-    private static MethodType toMethodType(Type type, ClassLoader classLoader) {\n-        return MethodType.fromMethodDescriptorString(type.getInternalName(), classLoader);\n-    }\n-\n-    private static MethodHandle toMethodHandle(Handle handle, ClassLoader classLoader, MethodHandles.Lookup lookup) throws Exception {\n-        MethodType type = MethodType.fromMethodDescriptorString(handle.getDesc(), classLoader);\n-        Class<?> owner = classLoader.loadClass(handle.getOwner().replace('/', '.'));\n-\n-        switch (handle.getTag()) {\n-            case H_INVOKESTATIC:\n-                return lookup.findStatic(owner, handle.getName(), type);\n-\n-            case H_INVOKEVIRTUAL:\n-            case H_INVOKEINTERFACE:\n-                return lookup.findVirtual(owner, handle.getName(), type);\n-\n-            case H_INVOKESPECIAL:\n-                return lookup.findSpecial(owner, handle.getName(), type, owner);\n-\n-            case H_NEWINVOKESPECIAL:\n-                return lookup.findConstructor(owner, type);\n-\n-            default:\n-                throw new AssertionError(\"Unexpected handle type: \" + handle);\n-        }\n-    }\n }\n"
    },
    {
        "commit_hash": "bccd9b235ab201469a9d4e7851d0cb7aaed31aba",
        "previous_commit_hash": "2e9ecf358bbb337cd1cf2a5d10d1b83adbfac9d6",
        "diff_stats": {
            "additions": 4,
            "deletions": 3
        },
        "diff_content": "@@ -6,7 +6,6 @@ package net.orfjackal.retrolambda;\n \n import org.objectweb.asm.ClassReader;\n \n-import java.io.IOException;\n import java.lang.instrument.*;\n import java.nio.file.*;\n import java.security.ProtectionDomain;\n@@ -49,8 +48,10 @@ public class LambdaSavingClassFileTransformer implements ClassFileTransformer {\n             Files.createDirectories(savePath.getParent());\n             Files.write(savePath, backportedBytecode);\n \n-        } catch (IOException e) {\n-            e.printStackTrace();\n+        } catch (Throwable t) {\n+            // print to stdout to keep in sync with other log output\n+            System.out.println(\"ERROR: Failed so backport lambda class: \" + className);\n+            t.printStackTrace(System.out);\n         }\n         return null;\n     }\n"
    },
    {
        "commit_hash": "bccd9b235ab201469a9d4e7851d0cb7aaed31aba",
        "previous_commit_hash": "2e9ecf358bbb337cd1cf2a5d10d1b83adbfac9d6",
        "diff_stats": {
            "additions": 57,
            "deletions": 48
        },
        "diff_content": "@@ -5,7 +5,6 @@\n package net.orfjackal.retrolambda;\n \n import org.objectweb.asm.*;\n-import org.objectweb.asm.tree.*;\n \n import java.lang.reflect.Field;\n import java.util.*;\n@@ -18,14 +17,10 @@ public class LambdaUsageBackporter {\n     public static byte[] transform(byte[] bytecode, int targetVersion) {\n         resetLambdaClassSequenceNumber();\n \n-        MethodVisibilityAdjuster stage2 = new MethodVisibilityAdjuster();\n+        ClassWriter stage2 = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n         InvokeDynamicInsnConverter stage1 = new InvokeDynamicInsnConverter(stage2, targetVersion);\n         new ClassReader(bytecode).accept(stage1, 0);\n-        stage2.makePackagePrivate(stage1.lambdaImplMethods);\n-\n-        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n-        stage2.accept(cw);\n-        return cw.toByteArray();\n+        return stage2.toByteArray();\n     }\n \n     private static void resetLambdaClassSequenceNumber() {\n@@ -34,10 +29,11 @@ public class LambdaUsageBackporter {\n             counterField.setAccessible(true);\n             AtomicInteger counter = (AtomicInteger) counterField.get(null);\n             counter.set(0);\n-        } catch (Exception e) {\n-            System.err.println(\"WARNING: Failed to start class numbering from one. Don't worry, it's cosmetic, \" +\n+        } catch (Throwable t) {\n+            // print to stdout to keep in sync with other log output\n+            System.out.println(\"WARNING: Failed to start class numbering from one. Don't worry, it's cosmetic, \" +\n                     \"but please file a bug report and tell on which JDK version this happened.\");\n-            e.printStackTrace();\n+            t.printStackTrace(System.out);\n         }\n     }\n \n@@ -45,8 +41,8 @@ public class LambdaUsageBackporter {\n     private static class InvokeDynamicInsnConverter extends ClassVisitor {\n         private final int targetVersion;\n         private int classAccess;\n-        private String className;\n-        public final List<Handle> lambdaImplMethods = new ArrayList<>();\n+        String className;\n+        private final Map<Handle, Handle> lambdaBridgesToImplMethods = new LinkedHashMap<>();\n \n         public InvokeDynamicInsnConverter(ClassVisitor next, int targetVersion) {\n             super(ASM5, next);\n@@ -85,7 +81,7 @@ public class LambdaUsageBackporter {\n                         \"together with an SSCCE (http://www.sscce.org/)\");\n             }\n             MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n-            return new InvokeDynamicInsnConvertingMethodVisitor(mv, className, lambdaImplMethods);\n+            return new InvokeDynamicInsnConvertingMethodVisitor(mv, this);\n         }\n \n         private boolean isBridgeMethodOnInterface(int methodAccess) {\n@@ -103,16 +99,53 @@ public class LambdaUsageBackporter {\n                     desc.equals(\"()V\") &&\n                     Flags.hasFlag(methodAccess, ACC_STATIC);\n         }\n+\n+        Handle getLambdaBridgeMethod(Handle implMethod) {\n+            if (!implMethod.getOwner().equals(className)) {\n+                return implMethod;\n+            }\n+            // TODO: do not generate a bridge method if the impl method is not private (probably not implementable with a single pass)\n+            String name = \"access$lambda$\" + lambdaBridgesToImplMethods.size();\n+            String desc = implMethod.getTag() == H_INVOKESTATIC\n+                    ? implMethod.getDesc()\n+                    : Types.prependArgumentType(Type.getType(\"L\" + className + \";\"), implMethod.getDesc());\n+            Handle bridgeMethod = new Handle(H_INVOKESTATIC, className, name, desc);\n+            lambdaBridgesToImplMethods.put(bridgeMethod, implMethod);\n+            return bridgeMethod;\n+        }\n+\n+        @Override\n+        public void visitEnd() {\n+            for (Map.Entry<Handle, Handle> entry : lambdaBridgesToImplMethods.entrySet()) {\n+                Handle bridgeMethod = entry.getKey();\n+                Handle implMethod = entry.getValue();\n+                generateLambdaBridgeMethod(bridgeMethod, implMethod);\n+            }\n+            super.visitEnd();\n+        }\n+\n+        private void generateLambdaBridgeMethod(Handle bridge, Handle impl) {\n+            MethodVisitor mv = super.visitMethod(ACC_STATIC | ACC_SYNTHETIC | ACC_BRIDGE,\n+                    bridge.getName(), bridge.getDesc(), null, null);\n+            mv.visitCode();\n+            int varIndex = 0;\n+            for (Type type : Type.getArgumentTypes(bridge.getDesc())) {\n+                mv.visitVarInsn(type.getOpcode(ILOAD), varIndex);\n+                varIndex += type.getSize();\n+            }\n+            mv.visitMethodInsn(Handles.getOpcode(impl), impl.getOwner(), impl.getName(), impl.getDesc(), impl.getTag() == H_INVOKEINTERFACE);\n+            mv.visitInsn(Type.getReturnType(bridge.getDesc()).getOpcode(IRETURN));\n+            mv.visitMaxs(-1, -1); // rely on ClassWriter.COMPUTE_MAXS\n+            mv.visitEnd();\n+        }\n     }\n \n     private static class InvokeDynamicInsnConvertingMethodVisitor extends MethodVisitor {\n-        private final String myClassName;\n-        private final List<Handle> lambdaImplMethods;\n+        private final InvokeDynamicInsnConverter context;\n \n-        public InvokeDynamicInsnConvertingMethodVisitor(MethodVisitor mv, String myClassName, List<Handle> lambdaImplMethods) {\n+        public InvokeDynamicInsnConvertingMethodVisitor(MethodVisitor mv, InvokeDynamicInsnConverter context) {\n             super(ASM5, mv);\n-            this.myClassName = myClassName;\n-            this.lambdaImplMethods = lambdaImplMethods;\n+            this.context = context;\n         }\n \n         @Override\n@@ -125,10 +158,12 @@ public class LambdaUsageBackporter {\n         }\n \n         private void backportLambda(String invokedName, Type invokedType, Handle bsm, Object[] bsmArgs) {\n-            Class<?> invoker = loadClass(myClassName);\n-            Handle lambdaImplMethod = (Handle) bsmArgs[1];\n-            lambdaImplMethods.add(lambdaImplMethod);\n-            LambdaFactoryMethod factory = LambdaReifier.reifyLambdaClass(lambdaImplMethod, invoker, invokedName, invokedType, bsm, bsmArgs);\n+            Class<?> invoker = loadClass(context.className);\n+            Handle implMethod = (Handle) bsmArgs[1];\n+            Handle bridgeMethod = context.getLambdaBridgeMethod(implMethod);\n+\n+            LambdaFactoryMethod factory = LambdaReifier.reifyLambdaClass(implMethod, bridgeMethod,\n+                    invoker, invokedName, invokedType, bsm, bsmArgs);\n             super.visitMethodInsn(INVOKESTATIC, factory.getOwner(), factory.getName(), factory.getDesc(), false);\n         }\n \n@@ -141,30 +176,4 @@ public class LambdaUsageBackporter {\n             }\n         }\n     }\n-\n-    private static class MethodVisibilityAdjuster extends ClassNode {\n-\n-        public MethodVisibilityAdjuster() {\n-            super(ASM5);\n-        }\n-\n-        public void makePackagePrivate(List<Handle> targetMethods) {\n-            for (MethodNode method : this.methods) {\n-                if (contains(method, targetMethods)) {\n-                    method.access = Flags.makeNonPrivate(method.access);\n-                }\n-            }\n-        }\n-\n-        private boolean contains(MethodNode needle, List<Handle> haystack) {\n-            for (Handle handle : haystack) {\n-                if (handle.getOwner().equals(this.name) &&\n-                        handle.getName().equals(needle.name) &&\n-                        handle.getDesc().equals(needle.desc)) {\n-                    return true;\n-                }\n-            }\n-            return false;\n-        }\n-    }\n }\n"
    },
    {
        "commit_hash": "bccd9b235ab201469a9d4e7851d0cb7aaed31aba",
        "previous_commit_hash": "2e9ecf358bbb337cd1cf2a5d10d1b83adbfac9d6",
        "diff_stats": {
            "additions": 64,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,64 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda;\n+\n+import org.objectweb.asm.*;\n+\n+import java.lang.invoke.*;\n+\n+import static org.objectweb.asm.Opcodes.*;\n+\n+public class Types {\n+\n+    public static Object asmToJdkType(Object arg, ClassLoader classLoader, MethodHandles.Lookup caller) throws Exception {\n+        if (arg instanceof Type) {\n+            return toMethodType((Type) arg, classLoader);\n+        } else if (arg instanceof Handle) {\n+            return toMethodHandle((Handle) arg, classLoader, caller);\n+        } else {\n+            return arg;\n+        }\n+    }\n+\n+    public static MethodType toMethodType(Type type, ClassLoader classLoader) {\n+        return MethodType.fromMethodDescriptorString(type.getInternalName(), classLoader);\n+    }\n+\n+    public static MethodHandle toMethodHandle(Handle handle, ClassLoader classLoader, MethodHandles.Lookup lookup) throws Exception {\n+        MethodType type = MethodType.fromMethodDescriptorString(handle.getDesc(), classLoader);\n+        Class<?> owner = classLoader.loadClass(handle.getOwner().replace('/', '.'));\n+\n+        switch (handle.getTag()) {\n+            case H_INVOKESTATIC:\n+                return lookup.findStatic(owner, handle.getName(), type);\n+\n+            case H_INVOKEVIRTUAL:\n+            case H_INVOKEINTERFACE:\n+                return lookup.findVirtual(owner, handle.getName(), type);\n+\n+            case H_INVOKESPECIAL:\n+                return lookup.findSpecial(owner, handle.getName(), type, owner);\n+\n+            case H_NEWINVOKESPECIAL:\n+                return lookup.findConstructor(owner, type);\n+\n+            default:\n+                throw new AssertionError(\"Unexpected handle type: \" + handle);\n+        }\n+    }\n+\n+    public static String prependArgumentType(Type argumentType, String methodDescriptor) {\n+        Type returnType = Type.getReturnType(methodDescriptor);\n+        Type[] argumentTypes = Type.getArgumentTypes(methodDescriptor);\n+        return Type.getMethodDescriptor(returnType, conj(argumentType, argumentTypes));\n+    }\n+\n+    private static Type[] conj(Type type, Type[] types) {\n+        Type[] result = new Type[types.length + 1];\n+        result[0] = type;\n+        System.arraycopy(types, 0, result, 1, types.length);\n+        return result;\n+    }\n+}\n"
    },
    {
        "commit_hash": "b98df9da42390a25475911ad4de80ec8800e1f3a",
        "previous_commit_hash": "bccd9b235ab201469a9d4e7851d0cb7aaed31aba",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -76,7 +76,7 @@ To run Retrolambda using Maven, add the following to your pom.xml:\n <plugin>\n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>retrolambda-maven-plugin</artifactId>\n-    <version>1.2.2</version>\n+    <version>1.2.3</version>\n     <executions>\n         <execution>\n             <goals>\n@@ -142,7 +142,7 @@ package-private.\n Version History\n ---------------\n \n-### Upcoming\n+### Retrolambda 1.2.3 (2014-05-19)\n \n - Android: Fixed NoSuchMethodError when calling a private method to which\n   there is a method reference\n"
    },
    {
        "commit_hash": "b98df9da42390a25475911ad4de80ec8800e1f3a",
        "previous_commit_hash": "bccd9b235ab201469a9d4e7851d0cb7aaed31aba",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.2.3-SNAPSHOT</version>\n+        <version>1.2.3</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "b98df9da42390a25475911ad4de80ec8800e1f3a",
        "previous_commit_hash": "bccd9b235ab201469a9d4e7851d0cb7aaed31aba",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>1.2.3-SNAPSHOT</version>\n+    <version>1.2.3</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "b98df9da42390a25475911ad4de80ec8800e1f3a",
        "previous_commit_hash": "bccd9b235ab201469a9d4e7851d0cb7aaed31aba",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.2.3-SNAPSHOT</version>\n+        <version>1.2.3</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "b98df9da42390a25475911ad4de80ec8800e1f3a",
        "previous_commit_hash": "bccd9b235ab201469a9d4e7851d0cb7aaed31aba",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.2.3-SNAPSHOT</version>\n+        <version>1.2.3</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "b98df9da42390a25475911ad4de80ec8800e1f3a",
        "previous_commit_hash": "bccd9b235ab201469a9d4e7851d0cb7aaed31aba",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.2.3-SNAPSHOT</version>\n+        <version>1.2.3</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "5c6fb20bd11d543cb6fdb97a76974e67f7c683ad",
        "previous_commit_hash": "b98df9da42390a25475911ad4de80ec8800e1f3a",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.2.3</version>\n+        <version>1.2.4-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "5c6fb20bd11d543cb6fdb97a76974e67f7c683ad",
        "previous_commit_hash": "b98df9da42390a25475911ad4de80ec8800e1f3a",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>1.2.3</version>\n+    <version>1.2.4-SNAPSHOT</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "5c6fb20bd11d543cb6fdb97a76974e67f7c683ad",
        "previous_commit_hash": "b98df9da42390a25475911ad4de80ec8800e1f3a",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.2.3</version>\n+        <version>1.2.4-SNAPSHOT</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "5c6fb20bd11d543cb6fdb97a76974e67f7c683ad",
        "previous_commit_hash": "b98df9da42390a25475911ad4de80ec8800e1f3a",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.2.3</version>\n+        <version>1.2.4-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "5c6fb20bd11d543cb6fdb97a76974e67f7c683ad",
        "previous_commit_hash": "b98df9da42390a25475911ad4de80ec8800e1f3a",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.2.3</version>\n+        <version>1.2.4-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "b51bbfa564481e7b27968ce8c9c765da961201da",
        "previous_commit_hash": "5c6fb20bd11d543cb6fdb97a76974e67f7c683ad",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -50,7 +50,7 @@ public class LambdaSavingClassFileTransformer implements ClassFileTransformer {\n \n         } catch (Throwable t) {\n             // print to stdout to keep in sync with other log output\n-            System.out.println(\"ERROR: Failed so backport lambda class: \" + className);\n+            System.out.println(\"ERROR: Failed to backport lambda class: \" + className);\n             t.printStackTrace(System.out);\n         }\n         return null;\n"
    },
    {
        "commit_hash": "3f8210d75f9daeaeb3d1d710845b11c4c31cfb0e",
        "previous_commit_hash": "b51bbfa564481e7b27968ce8c9c765da961201da",
        "diff_stats": {
            "additions": 5,
            "deletions": 0
        },
        "diff_content": "@@ -142,6 +142,11 @@ package-private.\n Version History\n ---------------\n \n+### Upcoming\n+\n+- Maven plugin: made the input and output directories configurable\n+  ([Issue #20](https://github.com/orfjackal/retrolambda/issues/20))\n+\n ### Retrolambda 1.2.3 (2014-05-19)\n \n - Android: Fixed NoSuchMethodError when calling a private method to which\n"
    },
    {
        "commit_hash": "3f8210d75f9daeaeb3d1d710845b11c4c31cfb0e",
        "previous_commit_hash": "b51bbfa564481e7b27968ce8c9c765da961201da",
        "diff_stats": {
            "additions": 15,
            "deletions": 22
        },
        "diff_content": "@@ -36,8 +36,10 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n \n     /**\n      * The location of the Java 8 JDK (not JRE).\n+     *\n+     * @since 1.2.0\n      */\n-    @Parameter(required = false, property = \"java8home\", defaultValue = \"${env.JAVA8_HOME}\")\n+    @Parameter(defaultValue = \"${env.JAVA8_HOME}\", property = \"java8home\", required = true)\n     public String java8home;\n \n     /**\n@@ -46,32 +48,22 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n      * with the target JVM provided the known limitations are considered. See\n      * <a href=\"https://github.com/orfjackal/retrolambda\">project documentation</a>\n      * for more details.\n+     *\n+     * @since 1.2.0\n      */\n-    @Parameter(required = false, property = \"retrolambdaTarget\", defaultValue = \"1.7\")\n+    @Parameter(defaultValue = \"1.7\", property = \"retrolambdaTarget\", required = true)\n     public String target;\n \n-    /**\n-     * The directory containing the main (non-test) compiled classes. These\n-     * classes will be overwritten with bytecode changes to obtain compatibility\n-     * with target Java runtime.\n-     */\n-    @Parameter(required = false, property = \"retrolambdaMainClassesDir\", defaultValue = \"${project.build.outputDirectory}\")\n-    public String mainClassesDir;\n-\n-    /**\n-     * The directory containing the compiled test classes. These classes will be\n-     * overwritten with bytecode changes to obtain compatibility with target\n-     * Java runtime.\n-     */\n-    @Parameter(required = false, property = \"retrolambdaTestClassesDir\", defaultValue = \"${project.build.testOutputDirectory}\")\n-    public String testClassesDir;\n-\n     private final ClassesType classesType;\n \n     ProcessClassesMojo(ClassesType classesType) {\n         this.classesType = classesType;\n     }\n \n+    protected abstract File getInputDir();\n+\n+    protected abstract File getOutputDir();\n+\n     @Override\n     public void execute() throws MojoExecutionException {\n         validateJava8home();\n@@ -97,9 +89,9 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n \n         getLog().info(\"Processing classes with Retrolambda\");\n         if (classesType == ClassesType.MAIN) {\n-            processClasses(mainClassesDir, \"maven.compile.classpath\");\n+            processClasses(\"maven.compile.classpath\");\n         } else {\n-            processClasses(testClassesDir, \"maven.test.classpath\");\n+            processClasses(\"maven.test.classpath\");\n         }\n     }\n \n@@ -118,7 +110,7 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n         }\n     }\n \n-    private void processClasses(String inputDir, String classpathId) throws MojoExecutionException {\n+    private void processClasses(String classpathId) throws MojoExecutionException {\n         String retrolambdaJar = getRetrolambdaJarPath();\n         executeMojo(\n                 plugin(groupId(\"org.apache.maven.plugins\"),\n@@ -135,7 +127,8 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n                                         attribute(\"executable\", java8home + \"/bin/java\"),\n                                         attribute(\"failonerror\", \"true\")),\n                                 element(\"arg\", attribute(\"value\", \"-Dretrolambda.bytecodeVersion=\" + targetBytecodeVersions.get(target))),\n-                                element(\"arg\", attribute(\"value\", \"-Dretrolambda.inputDir=\" + inputDir)),\n+                                element(\"arg\", attribute(\"value\", \"-Dretrolambda.inputDir=\" + getInputDir().getAbsolutePath())),\n+                                element(\"arg\", attribute(\"value\", \"-Dretrolambda.outputDir=\" + getOutputDir().getAbsolutePath())),\n                                 element(\"arg\", attribute(\"value\", \"-Dretrolambda.classpath=${the_classpath}\")),\n                                 element(\"arg\", attribute(\"value\", \"-javaagent:\" + retrolambdaJar)),\n                                 element(\"arg\", attribute(\"value\", \"-jar\")),\n"
    },
    {
        "commit_hash": "3f8210d75f9daeaeb3d1d710845b11c4c31cfb0e",
        "previous_commit_hash": "b51bbfa564481e7b27968ce8c9c765da961201da",
        "diff_stats": {
            "additions": 29,
            "deletions": 0
        },
        "diff_content": "@@ -6,6 +6,8 @@ package net.orfjackal.retrolambda.maven;\n \n import org.apache.maven.plugins.annotations.*;\n \n+import java.io.File;\n+\n /**\n  * Processes main (non-test) classes compiled with Java 8 so that they will be\n  * compatible with Java 5, 6 or 7 runtime.\n@@ -15,7 +17,34 @@ import org.apache.maven.plugins.annotations.*;\n         requiresDependencyResolution = ResolutionScope.COMPILE)\n public class ProcessMainClassesMojo extends ProcessClassesMojo {\n \n+    /**\n+     * Directory containing the original classes compiled with Java 8.\n+     *\n+     * @since 1.3.0\n+     */\n+    @Parameter(defaultValue = \"${project.build.outputDirectory}\", property = \"retrolambdaMainInputDir\", required = true)\n+    public File mainInputDir;\n+\n+    /**\n+     * Directory where to write the backported main classes.\n+     * If same as the input directory, will overwrite the original classes.\n+     *\n+     * @since 1.3.0\n+     */\n+    @Parameter(defaultValue = \"${project.build.outputDirectory}\", property = \"retrolambdaMainOutputDir\", required = true)\n+    public File mainOutputDir;\n+\n     public ProcessMainClassesMojo() {\n         super(ClassesType.MAIN);\n     }\n+\n+    @Override\n+    protected File getInputDir() {\n+        return mainInputDir;\n+    }\n+\n+    @Override\n+    protected File getOutputDir() {\n+        return mainOutputDir;\n+    }\n }\n"
    },
    {
        "commit_hash": "3f8210d75f9daeaeb3d1d710845b11c4c31cfb0e",
        "previous_commit_hash": "b51bbfa564481e7b27968ce8c9c765da961201da",
        "diff_stats": {
            "additions": 29,
            "deletions": 0
        },
        "diff_content": "@@ -6,6 +6,8 @@ package net.orfjackal.retrolambda.maven;\n \n import org.apache.maven.plugins.annotations.*;\n \n+import java.io.File;\n+\n /**\n  * Processes test classes compiled with Java 8 so that they will be compatible with\n  * Java 5, 6 or 7 runtime.\n@@ -18,4 +20,31 @@ public class ProcessTestClassesMojo extends ProcessClassesMojo {\n     public ProcessTestClassesMojo() {\n         super(ClassesType.TEST);\n     }\n+\n+    /**\n+     * Directory containing the original classes compiled with Java 8.\n+     *\n+     * @since 1.3.0\n+     */\n+    @Parameter(defaultValue = \"${project.build.testOutputDirectory}\", property = \"retrolambdaTestInputDir\", required = true)\n+    public File testInputDir;\n+\n+    /**\n+     * Directory where to write the backported main classes.\n+     * If same as the input directory, will overwrite the original classes.\n+     *\n+     * @since 1.3.0\n+     */\n+    @Parameter(defaultValue = \"${project.build.testOutputDirectory}\", property = \"retrolambdaTestOutputDir\", required = true)\n+    public File testOutputDir;\n+\n+    @Override\n+    protected File getInputDir() {\n+        return testInputDir;\n+    }\n+\n+    @Override\n+    protected File getOutputDir() {\n+        return testOutputDir;\n+    }\n }\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "a1ea9db5ceee049e79d5792cfc22d4196e9e02a8",
        "previous_commit_hash": "3f8210d75f9daeaeb3d1d710845b11c4c31cfb0e",
        "diff_stats": {
            "additions": 3,
            "deletions": 0
        },
        "diff_content": "@@ -146,6 +146,9 @@ Version History\n \n - Maven plugin: made the input and output directories configurable\n   ([Issue #20](https://github.com/orfjackal/retrolambda/issues/20))\n+- Maven plugin: by default use the current JVM for running Retrolambda.\n+  For the old behavior, add `<java8home>${env.JAVA8_HOME}</java8home>`\n+  to the plugin configuration\n \n ### Retrolambda 1.2.3 (2014-05-19)\n \n"
    },
    {
        "commit_hash": "a1ea9db5ceee049e79d5792cfc22d4196e9e02a8",
        "previous_commit_hash": "3f8210d75f9daeaeb3d1d710845b11c4c31cfb0e",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -70,6 +70,7 @@\n                         </goals>\n                         <configuration>\n                             <target>${testBytecodeTarget}</target>\n+                            <java8home>${env.JAVA8_HOME}</java8home>\n                         </configuration>\n                     </execution>\n                 </executions>\n"
    },
    {
        "commit_hash": "a1ea9db5ceee049e79d5792cfc22d4196e9e02a8",
        "previous_commit_hash": "3f8210d75f9daeaeb3d1d710845b11c4c31cfb0e",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -39,8 +39,8 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n      *\n      * @since 1.2.0\n      */\n-    @Parameter(defaultValue = \"${env.JAVA8_HOME}\", property = \"java8home\", required = true)\n-    public String java8home;\n+    @Parameter(defaultValue = \"${java.home}\", property = \"java8home\", required = true)\n+    public File java8home;\n \n     /**\n      * The Java version targeted by the bytecode processing. Possible values are\n@@ -104,7 +104,7 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n     }\n \n     private void validateJava8home() throws MojoExecutionException {\n-        if (!new File(java8home).isDirectory()) {\n+        if (!java8home.isDirectory()) {\n             throw new MojoExecutionException(\n                     \"Must set configuration element java8home or environment variable JAVA8_HOME to a valid JDK 8 location: \" + java8home);\n         }\n"
    },
    {
        "commit_hash": "a1ea9db5ceee049e79d5792cfc22d4196e9e02a8",
        "previous_commit_hash": "3f8210d75f9daeaeb3d1d710845b11c4c31cfb0e",
        "diff_stats": {
            "additions": 3,
            "deletions": 1
        },
        "diff_content": "@@ -8,6 +8,8 @@ import org.apache.maven.plugin.MojoExecutionException;\n import org.junit.*;\n import org.junit.rules.ExpectedException;\n \n+import java.io.File;\n+\n public class ProcessClassesMojoTest {\n \n     private final ProcessMainClassesMojo mojo = new ProcessMainClassesMojo();\n@@ -18,7 +20,7 @@ public class ProcessClassesMojoTest {\n     @Before\n     public void sensibleDefaults() {\n         mojo.target = \"1.7\";\n-        mojo.java8home = System.getProperty(\"java.home\");\n+        mojo.java8home = new File(System.getProperty(\"java.home\"));\n     }\n \n     @Test\n"
    },
    {
        "commit_hash": "badcf901932aee32250a19fc84895568e06bcb94",
        "previous_commit_hash": "a1ea9db5ceee049e79d5792cfc22d4196e9e02a8",
        "diff_stats": {
            "additions": 0,
            "deletions": 9
        },
        "diff_content": "@@ -1,9 +0,0 @@\n-// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n-// This software is released under the Apache License 2.0.\n-// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n-\n-package net.orfjackal.retrolambda.maven;\n-\n-enum ClassesType {\n-    MAIN, TEST\n-}\n"
    },
    {
        "commit_hash": "badcf901932aee32250a19fc84895568e06bcb94",
        "previous_commit_hash": "a1ea9db5ceee049e79d5792cfc22d4196e9e02a8",
        "diff_stats": {
            "additions": 24,
            "deletions": 28
        },
        "diff_content": "@@ -54,45 +54,23 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n     @Parameter(defaultValue = \"1.7\", property = \"retrolambdaTarget\", required = true)\n     public String target;\n \n-    private final ClassesType classesType;\n-\n-    ProcessClassesMojo(ClassesType classesType) {\n-        this.classesType = classesType;\n-    }\n-\n     protected abstract File getInputDir();\n \n     protected abstract File getOutputDir();\n \n+    protected abstract String getClasspathId();\n+\n     @Override\n     public void execute() throws MojoExecutionException {\n         validateJava8home();\n         validateTarget();\n \n-        // TODO: use Maven's built-in artifact resolving, so that we can refer to retrolambda.jar in the local repository without copying it\n         String version = getRetrolambdaVersion();\n         getLog().info(\"Retrieving Retrolambda \" + version);\n-        executeMojo(\n-                plugin(groupId(\"org.apache.maven.plugins\"),\n-                        artifactId(\"maven-dependency-plugin\"),\n-                        version(\"2.8\")),\n-                goal(\"copy\"),\n-                configuration(element(\"artifactItems\",\n-                        element(\"artifactItem\",\n-                                element(name(\"groupId\"), \"net.orfjackal.retrolambda\"),\n-                                element(name(\"artifactId\"), \"retrolambda\"),\n-                                element(name(\"version\"), version),\n-                                element(name(\"overWrite\"), \"true\"),\n-                                element(name(\"outputDirectory\"), getRetrolambdaJarDir()),\n-                                element(name(\"destFileName\"), getRetrolambdaJarName())))),\n-                executionEnvironment(project, session, pluginManager));\n+        retrieveRetrolambdaJar(version);\n \n         getLog().info(\"Processing classes with Retrolambda\");\n-        if (classesType == ClassesType.MAIN) {\n-            processClasses(\"maven.compile.classpath\");\n-        } else {\n-            processClasses(\"maven.test.classpath\");\n-        }\n+        processClasses();\n     }\n \n     private void validateTarget() throws MojoExecutionException {\n@@ -110,7 +88,25 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n         }\n     }\n \n-    private void processClasses(String classpathId) throws MojoExecutionException {\n+    private void retrieveRetrolambdaJar(String version) throws MojoExecutionException {\n+        // TODO: use Maven's built-in artifact resolving, so that we can refer to retrolambda.jar in the local repository without copying it\n+        executeMojo(\n+                plugin(groupId(\"org.apache.maven.plugins\"),\n+                        artifactId(\"maven-dependency-plugin\"),\n+                        version(\"2.8\")),\n+                goal(\"copy\"),\n+                configuration(element(\"artifactItems\",\n+                        element(\"artifactItem\",\n+                                element(name(\"groupId\"), \"net.orfjackal.retrolambda\"),\n+                                element(name(\"artifactId\"), \"retrolambda\"),\n+                                element(name(\"version\"), version),\n+                                element(name(\"overWrite\"), \"true\"),\n+                                element(name(\"outputDirectory\"), getRetrolambdaJarDir()),\n+                                element(name(\"destFileName\"), getRetrolambdaJarName())))),\n+                executionEnvironment(project, session, pluginManager));\n+    }\n+\n+    private void processClasses() throws MojoExecutionException {\n         String retrolambdaJar = getRetrolambdaJarPath();\n         executeMojo(\n                 plugin(groupId(\"org.apache.maven.plugins\"),\n@@ -121,7 +117,7 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n                         \"target\",\n                         element(\"property\",\n                                 attributes(attribute(\"name\", \"the_classpath\"),\n-                                        attribute(\"refid\", classpathId))),\n+                                        attribute(\"refid\", getClasspathId()))),\n                         element(\"exec\",\n                                 attributes(\n                                         attribute(\"executable\", java8home + \"/bin/java\"),\n"
    },
    {
        "commit_hash": "badcf901932aee32250a19fc84895568e06bcb94",
        "previous_commit_hash": "a1ea9db5ceee049e79d5792cfc22d4196e9e02a8",
        "diff_stats": {
            "additions": 5,
            "deletions": 4
        },
        "diff_content": "@@ -34,10 +34,6 @@ public class ProcessMainClassesMojo extends ProcessClassesMojo {\n     @Parameter(defaultValue = \"${project.build.outputDirectory}\", property = \"retrolambdaMainOutputDir\", required = true)\n     public File mainOutputDir;\n \n-    public ProcessMainClassesMojo() {\n-        super(ClassesType.MAIN);\n-    }\n-\n     @Override\n     protected File getInputDir() {\n         return mainInputDir;\n@@ -47,4 +43,9 @@ public class ProcessMainClassesMojo extends ProcessClassesMojo {\n     protected File getOutputDir() {\n         return mainOutputDir;\n     }\n+\n+    @Override\n+    protected String getClasspathId() {\n+        return \"maven.compile.classpath\";\n+    }\n }\n"
    },
    {
        "commit_hash": "badcf901932aee32250a19fc84895568e06bcb94",
        "previous_commit_hash": "a1ea9db5ceee049e79d5792cfc22d4196e9e02a8",
        "diff_stats": {
            "additions": 5,
            "deletions": 4
        },
        "diff_content": "@@ -17,10 +17,6 @@ import java.io.File;\n         requiresDependencyResolution = ResolutionScope.TEST)\n public class ProcessTestClassesMojo extends ProcessClassesMojo {\n \n-    public ProcessTestClassesMojo() {\n-        super(ClassesType.TEST);\n-    }\n-\n     /**\n      * Directory containing the original classes compiled with Java 8.\n      *\n@@ -47,4 +43,9 @@ public class ProcessTestClassesMojo extends ProcessClassesMojo {\n     protected File getOutputDir() {\n         return testOutputDir;\n     }\n+\n+    @Override\n+    protected String getClasspathId() {\n+        return \"maven.test.classpath\";\n+    }\n }\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "41fea7b2193f62262767db2d5755bc6b46549ddd",
        "previous_commit_hash": "badcf901932aee32250a19fc84895568e06bcb94",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -146,7 +146,7 @@ Version History\n \n - Maven plugin: made the input and output directories configurable\n   ([Issue #20](https://github.com/orfjackal/retrolambda/issues/20))\n-- Maven plugin: by default use the current JVM for running Retrolambda.\n+- Maven plugin: by default use the current JRE for running Retrolambda.\n   For the old behavior, add `<java8home>${env.JAVA8_HOME}</java8home>`\n   to the plugin configuration\n \n"
    },
    {
        "commit_hash": "41fea7b2193f62262767db2d5755bc6b46549ddd",
        "previous_commit_hash": "badcf901932aee32250a19fc84895568e06bcb94",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -35,7 +35,7 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n     private MavenProject project;\n \n     /**\n-     * The location of the Java 8 JDK (not JRE).\n+     * Directory of the Java 8 installation for running Retrolambda.\n      *\n      * @since 1.2.0\n      */\n"
    },
    {
        "commit_hash": "e48dfb2474d696798ad43d32d986d652adfb92c9",
        "previous_commit_hash": "41fea7b2193f62262767db2d5755bc6b46549ddd",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -9,8 +9,8 @@ import org.apache.maven.plugins.annotations.*;\n import java.io.File;\n \n /**\n- * Processes main (non-test) classes compiled with Java 8 so that they will be\n- * compatible with Java 5, 6 or 7 runtime.\n+ * Processes main classes compiled with Java 8 so that they will be compatible with\n+ * Java 5, 6 or 7 runtime.\n  */\n @Mojo(name = \"process-main\",\n         defaultPhase = LifecyclePhase.PROCESS_CLASSES,\n"
    },
    {
        "commit_hash": "aab487b5d017e1bd9eca898611f0ce56f92105bd",
        "previous_commit_hash": "e48dfb2474d696798ad43d32d986d652adfb92c9",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -76,7 +76,7 @@ To run Retrolambda using Maven, add the following to your pom.xml:\n <plugin>\n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>retrolambda-maven-plugin</artifactId>\n-    <version>1.2.3</version>\n+    <version>1.3.0</version>\n     <executions>\n         <execution>\n             <goals>\n@@ -142,7 +142,7 @@ package-private.\n Version History\n ---------------\n \n-### Upcoming\n+### Retrolambda 1.3.0 (2014-06-04)\n \n - Maven plugin: made the input and output directories configurable\n   ([Issue #20](https://github.com/orfjackal/retrolambda/issues/20))\n"
    },
    {
        "commit_hash": "aab487b5d017e1bd9eca898611f0ce56f92105bd",
        "previous_commit_hash": "e48dfb2474d696798ad43d32d986d652adfb92c9",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.2.4-SNAPSHOT</version>\n+        <version>1.3.0</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "aab487b5d017e1bd9eca898611f0ce56f92105bd",
        "previous_commit_hash": "e48dfb2474d696798ad43d32d986d652adfb92c9",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>1.2.4-SNAPSHOT</version>\n+    <version>1.3.0</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "aab487b5d017e1bd9eca898611f0ce56f92105bd",
        "previous_commit_hash": "e48dfb2474d696798ad43d32d986d652adfb92c9",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.2.4-SNAPSHOT</version>\n+        <version>1.3.0</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "aab487b5d017e1bd9eca898611f0ce56f92105bd",
        "previous_commit_hash": "e48dfb2474d696798ad43d32d986d652adfb92c9",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.2.4-SNAPSHOT</version>\n+        <version>1.3.0</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "aab487b5d017e1bd9eca898611f0ce56f92105bd",
        "previous_commit_hash": "e48dfb2474d696798ad43d32d986d652adfb92c9",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.2.4-SNAPSHOT</version>\n+        <version>1.3.0</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "67142c7f3a8f9f439e58e8508078f25c0325c26a",
        "previous_commit_hash": "aab487b5d017e1bd9eca898611f0ce56f92105bd",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.3.0</version>\n+        <version>1.3.1-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "67142c7f3a8f9f439e58e8508078f25c0325c26a",
        "previous_commit_hash": "aab487b5d017e1bd9eca898611f0ce56f92105bd",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>1.3.0</version>\n+    <version>1.3.1-SNAPSHOT</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "67142c7f3a8f9f439e58e8508078f25c0325c26a",
        "previous_commit_hash": "aab487b5d017e1bd9eca898611f0ce56f92105bd",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.3.0</version>\n+        <version>1.3.1-SNAPSHOT</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "67142c7f3a8f9f439e58e8508078f25c0325c26a",
        "previous_commit_hash": "aab487b5d017e1bd9eca898611f0ce56f92105bd",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.3.0</version>\n+        <version>1.3.1-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "67142c7f3a8f9f439e58e8508078f25c0325c26a",
        "previous_commit_hash": "aab487b5d017e1bd9eca898611f0ce56f92105bd",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.3.0</version>\n+        <version>1.3.1-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "c81f777925a88c9cab25ce8f6e0dc273bce33554",
        "previous_commit_hash": "67142c7f3a8f9f439e58e8508078f25c0325c26a",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -26,7 +26,7 @@ public class ProcessMainClassesMojo extends ProcessClassesMojo {\n     public File mainInputDir;\n \n     /**\n-     * Directory where to write the backported main classes.\n+     * Directory where to write the backported classes.\n      * If same as the input directory, will overwrite the original classes.\n      *\n      * @since 1.3.0\n"
    },
    {
        "commit_hash": "c81f777925a88c9cab25ce8f6e0dc273bce33554",
        "previous_commit_hash": "67142c7f3a8f9f439e58e8508078f25c0325c26a",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -26,7 +26,7 @@ public class ProcessTestClassesMojo extends ProcessClassesMojo {\n     public File testInputDir;\n \n     /**\n-     * Directory where to write the backported main classes.\n+     * Directory where to write the backported classes.\n      * If same as the input directory, will overwrite the original classes.\n      *\n      * @since 1.3.0\n@@ -48,4 +48,4 @@ public class ProcessTestClassesMojo extends ProcessClassesMojo {\n     protected String getClasspathId() {\n         return \"maven.test.classpath\";\n     }\n-}\n\\ No newline at end of file\n+}\n"
    },
    {
        "commit_hash": "70cdac4c8d6bc43601f72a2d0f4cb2d296b284b1",
        "previous_commit_hash": "c81f777925a88c9cab25ce8f6e0dc273bce33554",
        "diff_stats": {
            "additions": 5,
            "deletions": 0
        },
        "diff_content": "@@ -65,6 +65,11 @@ Optional system properties:\n   retrolambda.outputDir\n       Output directory into where the generated class files are written.\n       Defaults to same as retrolambda.inputDir\n+\n+  retrolambda.changed\n+      A list of all the files that have changed since last run.\n+      This is useful for a build tool to support incremental compilation.\n+\n ```\n \n \n"
    },
    {
        "commit_hash": "70cdac4c8d6bc43601f72a2d0f4cb2d296b284b1",
        "previous_commit_hash": "c81f777925a88c9cab25ce8f6e0dc273bce33554",
        "diff_stats": {
            "additions": 19,
            "deletions": 1
        },
        "diff_content": "@@ -6,8 +6,11 @@ package net.orfjackal.retrolambda;\n \n import org.objectweb.asm.Opcodes;\n \n-import java.nio.file.*;\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n import java.util.*;\n+import java.util.stream.Collectors;\n \n public class Config {\n \n@@ -16,6 +19,7 @@ public class Config {\n     private static final String INPUT_DIR = PREFIX + \"inputDir\";\n     private static final String OUTPUT_DIR = PREFIX + \"outputDir\";\n     private static final String CLASSPATH = PREFIX + \"classpath\";\n+    private static final String CHANGED = PREFIX + \"changed\";\n \n     private static final List<String> requiredProperties = new ArrayList<>();\n     private static final List<String> requiredProperitesHelp = new ArrayList<>();\n@@ -119,6 +123,20 @@ public class Config {\n         return value;\n     }\n \n+    // incremental files\n+\n+    static {\n+        optionalParameterHelp(CHANGED,\n+                \"A list of all the files that have changed since last run.\",\n+                \"This is useful for a build tool to support incremental compilation.\");\n+    }\n+\n+    public List<Path> getChangedFiles() {\n+        String files = p.getProperty(CHANGED);\n+        if (files == null) return null;\n+        return Arrays.asList(files.split(File.pathSeparator)).stream()\n+                .map(Paths::get).collect(Collectors.toList());\n+    }\n \n     // help\n \n"
    },
    {
        "commit_hash": "70cdac4c8d6bc43601f72a2d0f4cb2d296b284b1",
        "previous_commit_hash": "c81f777925a88c9cab25ce8f6e0dc273bce33554",
        "diff_stats": {
            "additions": 28,
            "deletions": 6
        },
        "diff_content": "@@ -4,10 +4,19 @@\n \n package net.orfjackal.retrolambda;\n \n-import java.io.*;\n-import java.net.*;\n-import java.nio.file.*;\n-import java.util.*;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URI;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n \n public class Main {\n \n@@ -23,10 +32,14 @@ public class Main {\n         Path inputDir = config.getInputDir();\n         Path outputDir = config.getOutputDir();\n         String classpath = config.getClasspath();\n+        List<Path> changedFiles = config.getChangedFiles();\n         System.out.println(\"Bytecode version: \" + bytecodeVersion + \" (\" + config.getJavaVersion() + \")\");\n         System.out.println(\"Input directory:  \" + inputDir);\n         System.out.println(\"Output directory: \" + outputDir);\n         System.out.println(\"Classpath:        \" + classpath);\n+        if (changedFiles != null) {\n+            System.out.println(\"Changed:          \" + changedFiles.size() + \" files\");\n+        }\n \n         if (!Files.isDirectory(inputDir)) {\n             System.out.println(\"Nothing to do; not a directory: \" + inputDir);\n@@ -35,12 +48,21 @@ public class Main {\n \n         try {\n             Thread.currentThread().setContextClassLoader(new URLClassLoader(asUrls(classpath)));\n-            Files.walkFileTree(inputDir, new BytecodeTransformingFileVisitor(inputDir, outputDir) {\n+\n+            BytecodeTransformingFileVisitor visitor = new BytecodeTransformingFileVisitor(inputDir, outputDir) {\n+                @Override\n                 protected byte[] transform(byte[] bytecode) {\n                     return LambdaUsageBackporter.transform(bytecode, bytecodeVersion);\n                 }\n-            });\n+            };\n \n+            if (changedFiles == null) {\n+                Files.walkFileTree(inputDir, visitor);\n+            } else {\n+                for (Path inputFile : changedFiles) {\n+                    visitor.visitFile(inputFile, Files.readAttributes(inputFile, BasicFileAttributes.class));\n+                }\n+            }\n         } catch (Throwable t) {\n             System.out.println(\"Error! Failed to transform some classes\");\n             t.printStackTrace(System.out);\n"
    },
    {
        "commit_hash": "0cb0f7fa2c773004abc74708d29a9fa9640b0fdc",
        "previous_commit_hash": "2a54ad3c2ad10c135e0ac10dd4e51e7c7f2000a0",
        "diff_stats": {
            "additions": 7,
            "deletions": 5
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -7,8 +7,7 @@ package net.orfjackal.retrolambda;\n import org.objectweb.asm.Opcodes;\n \n import java.io.File;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n+import java.nio.file.*;\n import java.util.*;\n import java.util.stream.Collectors;\n \n@@ -133,9 +132,12 @@ public class Config {\n \n     public List<Path> getChangedFiles() {\n         String files = p.getProperty(CHANGED);\n-        if (files == null) return null;\n+        if (files == null) {\n+            return null;\n+        }\n         return Arrays.asList(files.split(File.pathSeparator)).stream()\n-                .map(Paths::get).collect(Collectors.toList());\n+                .map(Paths::get)\n+                .collect(Collectors.toList());\n     }\n \n     // help\n"
    },
    {
        "commit_hash": "0cb0f7fa2c773004abc74708d29a9fa9640b0fdc",
        "previous_commit_hash": "2a54ad3c2ad10c135e0ac10dd4e51e7c7f2000a0",
        "diff_stats": {
            "additions": 5,
            "deletions": 13
        },
        "diff_content": "@@ -1,22 +1,14 @@\n-// Copyright \u00a9 2013 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n package net.orfjackal.retrolambda;\n \n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.net.MalformedURLException;\n-import java.net.URI;\n-import java.net.URL;\n-import java.net.URLClassLoader;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n+import java.io.*;\n+import java.net.*;\n+import java.nio.file.*;\n import java.nio.file.attribute.BasicFileAttributes;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Properties;\n+import java.util.*;\n \n public class Main {\n \n"
    },
    {
        "commit_hash": "667a9885f8ebd1f1d3661868e7bb5af2e7578ca7",
        "previous_commit_hash": "0cb0f7fa2c773004abc74708d29a9fa9640b0fdc",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -66,8 +66,8 @@ Optional system properties:\n       Output directory into where the generated class files are written.\n       Defaults to same as retrolambda.inputDir\n \n-  retrolambda.changed\n-      A list of all the files that have changed since last run.\n+  retrolambda.includedFiles\n+      List of files to process, instead of processing all files.\n       This is useful for a build tool to support incremental compilation.\n \n ```\n"
    },
    {
        "commit_hash": "667a9885f8ebd1f1d3661868e7bb5af2e7578ca7",
        "previous_commit_hash": "0cb0f7fa2c773004abc74708d29a9fa9640b0fdc",
        "diff_stats": {
            "additions": 5,
            "deletions": 5
        },
        "diff_content": "@@ -18,7 +18,7 @@ public class Config {\n     private static final String INPUT_DIR = PREFIX + \"inputDir\";\n     private static final String OUTPUT_DIR = PREFIX + \"outputDir\";\n     private static final String CLASSPATH = PREFIX + \"classpath\";\n-    private static final String CHANGED = PREFIX + \"changed\";\n+    private static final String INCLUDED_FILES = PREFIX + \"includedFiles\";\n \n     private static final List<String> requiredProperties = new ArrayList<>();\n     private static final List<String> requiredProperitesHelp = new ArrayList<>();\n@@ -125,13 +125,13 @@ public class Config {\n     // incremental files\n \n     static {\n-        optionalParameterHelp(CHANGED,\n-                \"A list of all the files that have changed since last run.\",\n+        optionalParameterHelp(INCLUDED_FILES,\n+                \"List of files to process, instead of processing all files.\",\n                 \"This is useful for a build tool to support incremental compilation.\");\n     }\n \n-    public List<Path> getChangedFiles() {\n-        String files = p.getProperty(CHANGED);\n+    public List<Path> getIncludedFiles() {\n+        String files = p.getProperty(INCLUDED_FILES);\n         if (files == null) {\n             return null;\n         }\n"
    },
    {
        "commit_hash": "667a9885f8ebd1f1d3661868e7bb5af2e7578ca7",
        "previous_commit_hash": "0cb0f7fa2c773004abc74708d29a9fa9640b0fdc",
        "diff_stats": {
            "additions": 5,
            "deletions": 5
        },
        "diff_content": "@@ -24,13 +24,13 @@ public class Main {\n         Path inputDir = config.getInputDir();\n         Path outputDir = config.getOutputDir();\n         String classpath = config.getClasspath();\n-        List<Path> changedFiles = config.getChangedFiles();\n+        List<Path> includedFiles = config.getIncludedFiles();\n         System.out.println(\"Bytecode version: \" + bytecodeVersion + \" (\" + config.getJavaVersion() + \")\");\n         System.out.println(\"Input directory:  \" + inputDir);\n         System.out.println(\"Output directory: \" + outputDir);\n         System.out.println(\"Classpath:        \" + classpath);\n-        if (changedFiles != null) {\n-            System.out.println(\"Changed:          \" + changedFiles.size() + \" files\");\n+        if (includedFiles != null) {\n+            System.out.println(\"Included files:   \" + includedFiles.size());\n         }\n \n         if (!Files.isDirectory(inputDir)) {\n@@ -48,10 +48,10 @@ public class Main {\n                 }\n             };\n \n-            if (changedFiles == null) {\n+            if (includedFiles == null) {\n                 Files.walkFileTree(inputDir, visitor);\n             } else {\n-                for (Path inputFile : changedFiles) {\n+                for (Path inputFile : includedFiles) {\n                     visitor.visitFile(inputFile, Files.readAttributes(inputFile, BasicFileAttributes.class));\n                 }\n             }\n"
    },
    {
        "commit_hash": "4f0affdc17d307b069b186e7c0d75f71efb1d1a0",
        "previous_commit_hash": "667a9885f8ebd1f1d3661868e7bb5af2e7578ca7",
        "diff_stats": {
            "additions": 7,
            "deletions": 6
        },
        "diff_content": "@@ -14,11 +14,11 @@ import java.util.stream.Collectors;\n public class Config {\n \n     private static final String PREFIX = \"retrolambda.\";\n-    private static final String BYTECODE_VERSION = PREFIX + \"bytecodeVersion\";\n-    private static final String INPUT_DIR = PREFIX + \"inputDir\";\n-    private static final String OUTPUT_DIR = PREFIX + \"outputDir\";\n-    private static final String CLASSPATH = PREFIX + \"classpath\";\n-    private static final String INCLUDED_FILES = PREFIX + \"includedFiles\";\n+    public static final String BYTECODE_VERSION = PREFIX + \"bytecodeVersion\";\n+    public static final String INPUT_DIR = PREFIX + \"inputDir\";\n+    public static final String OUTPUT_DIR = PREFIX + \"outputDir\";\n+    public static final String CLASSPATH = PREFIX + \"classpath\";\n+    public static final String INCLUDED_FILES = PREFIX + \"includedFiles\";\n \n     private static final List<String> requiredProperties = new ArrayList<>();\n     private static final List<String> requiredProperitesHelp = new ArrayList<>();\n@@ -33,7 +33,7 @@ public class Config {\n         bytecodeVersionNames.put(Opcodes.V1_5, \"Java 5\");\n         bytecodeVersionNames.put(Opcodes.V1_6, \"Java 6\");\n         bytecodeVersionNames.put(Opcodes.V1_7, \"Java 7\");\n-        bytecodeVersionNames.put(Opcodes.V1_7 + 1, \"Java 8\");\n+        bytecodeVersionNames.put(Opcodes.V1_8, \"Java 8\");\n     }\n \n     private final Properties p;\n@@ -136,6 +136,7 @@ public class Config {\n             return null;\n         }\n         return Arrays.asList(files.split(File.pathSeparator)).stream()\n+                .filter(s -> !s.isEmpty())\n                 .map(Paths::get)\n                 .collect(Collectors.toList());\n     }\n"
    },
    {
        "commit_hash": "4f0affdc17d307b069b186e7c0d75f71efb1d1a0",
        "previous_commit_hash": "667a9885f8ebd1f1d3661868e7bb5af2e7578ca7",
        "diff_stats": {
            "additions": 67,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,67 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda;\n+\n+import org.junit.*;\n+import org.junit.rules.ExpectedException;\n+\n+import java.io.File;\n+import java.nio.file.Paths;\n+import java.util.*;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.*;\n+\n+public class ConfigTest {\n+\n+    @Rule\n+    public final ExpectedException thrown = ExpectedException.none();\n+\n+    private final Properties systemProperties = new Properties();\n+\n+    private Config config() {\n+        return new Config(systemProperties);\n+    }\n+\n+    @Test\n+    public void bytecode_version() {\n+        assertThat(\"defaults to Java 7\", config().getBytecodeVersion(), is(51));\n+        assertThat(\"human printable format\", config().getJavaVersion(), is(\"Java 7\"));\n+\n+        systemProperties.setProperty(Config.BYTECODE_VERSION, \"50\");\n+        assertThat(\"can override the default\", config().getBytecodeVersion(), is(50));\n+        assertThat(\"human printable format\", config().getJavaVersion(), is(\"Java 6\"));\n+    }\n+\n+    @Test\n+    public void input_directory_is_required() {\n+        thrown.expect(IllegalArgumentException.class);\n+        thrown.expectMessage(\"Missing required property: retrolambda.inputDir\");\n+        config().getInputDir();\n+    }\n+\n+    @Test\n+    public void output_directory() {\n+        systemProperties.setProperty(Config.INPUT_DIR, \"input dir\");\n+        assertThat(\"defaults to input dir\", config().getOutputDir(), is(Paths.get(\"input dir\")));\n+\n+        systemProperties.setProperty(Config.OUTPUT_DIR, \"output dir\");\n+        assertThat(\"can override the default\", config().getOutputDir(), is(Paths.get(\"output dir\")));\n+    }\n+\n+    @Test\n+    public void included_files() {\n+        assertThat(\"not set\", config().getIncludedFiles(), is(nullValue()));\n+\n+        systemProperties.setProperty(Config.INCLUDED_FILES, \"\");\n+        assertThat(\"zero values\", config().getIncludedFiles(), is(empty()));\n+\n+        systemProperties.setProperty(Config.INCLUDED_FILES, \"/foo/one.class\");\n+        assertThat(\"one value\", config().getIncludedFiles(), is(Arrays.asList(Paths.get(\"/foo/one.class\"))));\n+\n+        systemProperties.setProperty(Config.INCLUDED_FILES, \"/foo/one.class\" + File.pathSeparator + \"/foo/two.class\");\n+        assertThat(\"multiple values\", config().getIncludedFiles(), is(Arrays.asList(Paths.get(\"/foo/one.class\"), Paths.get(\"/foo/two.class\"))));\n+    }\n+}\n"
    },
    {
        "commit_hash": "de86266cc7d6b0004c7e51596b13ab1323a2a9d4",
        "previous_commit_hash": "4f0affdc17d307b069b186e7c0d75f71efb1d1a0",
        "diff_stats": {
            "additions": 41,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,41 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda;\n+\n+import java.io.IOException;\n+import java.nio.file.*;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.*;\n+\n+public class FilteringFileVisitor implements FileVisitor<Path> {\n+\n+    private final Set<Path> fileFilter;\n+    private final FileVisitor<? super Path> target;\n+\n+    public FilteringFileVisitor(Collection<Path> fileFilter, FileVisitor<Path> target) {\n+        this.fileFilter = new HashSet<>(fileFilter);\n+        this.target = target;\n+    }\n+\n+    public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {\n+        return target.postVisitDirectory(dir, exc);\n+    }\n+\n+    public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {\n+        return target.preVisitDirectory(dir, attrs);\n+    }\n+\n+    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n+        if (fileFilter.contains(file)) {\n+            return target.visitFile(file, attrs);\n+        } else {\n+            return FileVisitResult.CONTINUE;\n+        }\n+    }\n+\n+    public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {\n+        return target.visitFileFailed(file, exc);\n+    }\n+}\n"
    },
    {
        "commit_hash": "de86266cc7d6b0004c7e51596b13ab1323a2a9d4",
        "previous_commit_hash": "4f0affdc17d307b069b186e7c0d75f71efb1d1a0",
        "diff_stats": {
            "additions": 9,
            "deletions": 11
        },
        "diff_content": "@@ -7,7 +7,6 @@ package net.orfjackal.retrolambda;\n import java.io.*;\n import java.net.*;\n import java.nio.file.*;\n-import java.nio.file.attribute.BasicFileAttributes;\n import java.util.*;\n \n public class Main {\n@@ -41,20 +40,12 @@ public class Main {\n         try {\n             Thread.currentThread().setContextClassLoader(new URLClassLoader(asUrls(classpath)));\n \n-            BytecodeTransformingFileVisitor visitor = new BytecodeTransformingFileVisitor(inputDir, outputDir) {\n+            visitFiles(inputDir, includedFiles, new BytecodeTransformingFileVisitor(inputDir, outputDir) {\n                 @Override\n                 protected byte[] transform(byte[] bytecode) {\n                     return LambdaUsageBackporter.transform(bytecode, bytecodeVersion);\n                 }\n-            };\n-\n-            if (includedFiles == null) {\n-                Files.walkFileTree(inputDir, visitor);\n-            } else {\n-                for (Path inputFile : includedFiles) {\n-                    visitor.visitFile(inputFile, Files.readAttributes(inputFile, BasicFileAttributes.class));\n-                }\n-            }\n+            });\n         } catch (Throwable t) {\n             System.out.println(\"Error! Failed to transform some classes\");\n             t.printStackTrace(System.out);\n@@ -62,6 +53,13 @@ public class Main {\n         }\n     }\n \n+    static void visitFiles(Path inputDir, List<Path> includedFiles, FileVisitor<Path> visitor) throws IOException {\n+        if (includedFiles != null) {\n+            visitor = new FilteringFileVisitor(includedFiles, visitor);\n+        }\n+        Files.walkFileTree(inputDir, visitor);\n+    }\n+\n     private static URL[] asUrls(String classpath) {\n         String[] paths = classpath.split(System.getProperty(\"path.separator\"));\n         return Arrays.asList(paths).stream()\n"
    },
    {
        "commit_hash": "de86266cc7d6b0004c7e51596b13ab1323a2a9d4",
        "previous_commit_hash": "4f0affdc17d307b069b186e7c0d75f71efb1d1a0",
        "diff_stats": {
            "additions": 73,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,73 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda;\n+\n+import org.junit.*;\n+import org.junit.rules.TemporaryFolder;\n+\n+import java.io.IOException;\n+import java.nio.file.*;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.*;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+\n+public class MainTest {\n+\n+    @Rule\n+    public final TemporaryFolder tempDir = new TemporaryFolder();\n+\n+    private Path inputDir;\n+\n+    private final List<Path> visitedFiles = new ArrayList<>();\n+    private final FileVisitor<Path> visitor = new SimpleFileVisitor<Path>() {\n+        @Override\n+        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {\n+            visitedFiles.add(file);\n+            return FileVisitResult.CONTINUE;\n+        }\n+    };\n+    private Path file1;\n+    private Path file2;\n+    private Path fileInSubdir;\n+    private Path outsider;\n+\n+    @Before\n+    public void setup() throws IOException {\n+        inputDir = tempDir.newFolder(\"inputDir\").toPath();\n+        file1 = Files.createFile(inputDir.resolve(\"file1.txt\"));\n+        file2 = Files.createFile(inputDir.resolve(\"file2.txt\"));\n+        Path subdir = inputDir.resolve(\"subdir\");\n+        Files.createDirectory(subdir);\n+        fileInSubdir = Files.createFile(subdir.resolve(\"file.txt\"));\n+        outsider = tempDir.newFile(\"outsider.txt\").toPath();\n+    }\n+\n+    @Test\n+    public void by_default_visits_all_files_recursively() throws IOException {\n+        Main.visitFiles(inputDir, null, visitor);\n+\n+        assertThat(visitedFiles, containsInAnyOrder(file1, file2, fileInSubdir));\n+    }\n+\n+    @Test\n+    public void when_included_files_is_set_then_visits_only_those_files() throws IOException {\n+        List<Path> includedFiles = Arrays.asList(file1, fileInSubdir);\n+\n+        Main.visitFiles(inputDir, includedFiles, visitor);\n+\n+        assertThat(visitedFiles, containsInAnyOrder(file1, fileInSubdir));\n+    }\n+\n+    @Test\n+    public void ignores_included_files_that_are_outside_the_input_directory() throws IOException {\n+        List<Path> includedFiles = Arrays.asList(file1, outsider);\n+\n+        Main.visitFiles(inputDir, includedFiles, visitor);\n+\n+        assertThat(visitedFiles, containsInAnyOrder(file1));\n+    }\n+}\n"
    },
    {
        "commit_hash": "663be5d64888fa58010b95fc29636ac66bdd22ea",
        "previous_commit_hash": "de86266cc7d6b0004c7e51596b13ab1323a2a9d4",
        "diff_stats": {
            "additions": 6,
            "deletions": 0
        },
        "diff_content": "@@ -147,6 +147,12 @@ package-private.\n Version History\n ---------------\n \n+### Upcoming\n+\n+- Added an optional `-Dretrolambda.includedFiles` parameter to support the\n+  incremental compilers of build tools\n+  ([Issue #23](https://github.com/orfjackal/retrolambda/pull/23))\n+\n ### Retrolambda 1.3.0 (2014-06-04)\n \n - Maven plugin: made the input and output directories configurable\n"
    },
    {
        "commit_hash": "2317d92ff3860614d67fe4807922a890df38ceff",
        "previous_commit_hash": "663be5d64888fa58010b95fc29636ac66bdd22ea",
        "diff_stats": {
            "additions": 3,
            "deletions": 0
        },
        "diff_content": "@@ -152,6 +152,9 @@ Version History\n - Added an optional `-Dretrolambda.includedFiles` parameter to support the\n   incremental compilers of build tools\n   ([Issue #23](https://github.com/orfjackal/retrolambda/pull/23))\n+- Decides which lambda classes to save based on the current class being\n+  processed, instead of the class loader that loaded the lambda class\n+  ([Issue #21](https://github.com/orfjackal/retrolambda/issues/21))\n \n ### Retrolambda 1.3.0 (2014-06-04)\n \n"
    },
    {
        "commit_hash": "2317d92ff3860614d67fe4807922a890df38ceff",
        "previous_commit_hash": "663be5d64888fa58010b95fc29636ac66bdd22ea",
        "diff_stats": {
            "additions": 14,
            "deletions": 0
        },
        "diff_content": "@@ -19,6 +19,7 @@ public class LambdaReifier {\n     // be an error if these collections contain more than one element.\n     private static final BlockingDeque<Handle> currentLambdaImplMethod = new LinkedBlockingDeque<>(1);\n     private static final BlockingDeque<Handle> currentLambdaBridgeMethod = new LinkedBlockingDeque<>(1);\n+    private static final BlockingDeque<Class<?>> currentInvoker = new LinkedBlockingDeque<>(1);\n     private static final BlockingDeque<Type> currentInvokedType = new LinkedBlockingDeque<>(1);\n     private static final BlockingDeque<String> currentLambdaClass = new LinkedBlockingDeque<>(1);\n \n@@ -27,6 +28,7 @@ public class LambdaReifier {\n         try {\n             setLambdaImplMethod(lambdaImplMethod);\n             setLambdaBridgeMethod(lambdaBridgeMethod);\n+            setInvoker(invoker);\n             setInvokedType(invokedType);\n \n             // Causes the lambda class to be loaded. Retrolambda's Java agent\n@@ -51,6 +53,10 @@ public class LambdaReifier {\n         currentLambdaBridgeMethod.push(lambdaBridgeMethod);\n     }\n \n+    private static void setInvoker(Class<?> lambdaInvoker) {\n+        currentInvoker.push(lambdaInvoker);\n+    }\n+\n     private static void setInvokedType(Type invokedType) {\n         currentInvokedType.push(invokedType);\n     }\n@@ -59,6 +65,13 @@ public class LambdaReifier {\n         currentLambdaClass.push(lambdaClass);\n     }\n \n+    public static boolean isLambdaClassToReify(String className) {\n+        Class<?> invoker = currentInvoker.peekFirst();\n+        return invoker != null\n+                && className.startsWith(Type.getInternalName(invoker))\n+                && LambdaNaming.LAMBDA_CLASS.matcher(className).matches();\n+    }\n+\n     public static Handle getLambdaImplMethod() {\n         return currentLambdaImplMethod.getFirst();\n     }\n@@ -76,6 +89,7 @@ public class LambdaReifier {\n     private static void resetGlobals() {\n         currentLambdaImplMethod.clear();\n         currentLambdaBridgeMethod.clear();\n+        currentInvoker.clear();\n         currentInvokedType.clear();\n         currentLambdaClass.clear();\n     }\n"
    },
    {
        "commit_hash": "2317d92ff3860614d67fe4807922a890df38ceff",
        "previous_commit_hash": "663be5d64888fa58010b95fc29636ac66bdd22ea",
        "diff_stats": {
            "additions": 6,
            "deletions": 18
        },
        "diff_content": "@@ -9,38 +9,31 @@ import org.objectweb.asm.ClassReader;\n import java.lang.instrument.*;\n import java.nio.file.*;\n import java.security.ProtectionDomain;\n-import java.util.*;\n \n public class LambdaSavingClassFileTransformer implements ClassFileTransformer {\n \n     private final Path outputDir;\n     private final int targetVersion;\n-    private final List<ClassLoader> ignoredClassLoaders = new ArrayList<>();\n \n     public LambdaSavingClassFileTransformer(Path outputDir, int targetVersion) {\n         this.outputDir = outputDir;\n         this.targetVersion = targetVersion;\n-        for (ClassLoader cl = ClassLoader.getSystemClassLoader(); cl != null; cl = cl.getParent()) {\n-            ignoredClassLoaders.add(cl);\n-        }\n-        ignoredClassLoaders.add(null);\n     }\n \n     @Override\n     public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {\n-        if (ignoredClassLoaders.contains(loader)) {\n-            // Avoid saving any classes from the JDK or Retrolambda itself.\n-            // The transformed application classes have their own class loader.\n-            return null;\n-        }\n         if (className == null) {\n             // Since JDK 8 build b121 or so, lambda classes have a null class name,\n             // but we can read it from the bytecode where the name still exists.\n             className = new ClassReader(classfileBuffer).getClassName();\n         }\n-        if (!isLambdaClass(className)) {\n-            return null;\n+        if (LambdaReifier.isLambdaClassToReify(className)) {\n+            reifyLambdaClass(className, classfileBuffer);\n         }\n+        return null;\n+    }\n+\n+    private void reifyLambdaClass(String className, byte[] classfileBuffer) {\n         try {\n             System.out.println(\"Saving lambda class: \" + className);\n             byte[] backportedBytecode = LambdaClassBackporter.transform(classfileBuffer, targetVersion);\n@@ -53,10 +46,5 @@ public class LambdaSavingClassFileTransformer implements ClassFileTransformer {\n             System.out.println(\"ERROR: Failed to backport lambda class: \" + className);\n             t.printStackTrace(System.out);\n         }\n-        return null;\n-    }\n-\n-    private static boolean isLambdaClass(String className) {\n-        return LambdaNaming.LAMBDA_CLASS.matcher(className).matches();\n     }\n }\n"
    },
    {
        "commit_hash": "286b4d50f86f8a1f1a769249803db5f0c5dfece7",
        "previous_commit_hash": "2317d92ff3860614d67fe4807922a890df38ceff",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -81,7 +81,7 @@ To run Retrolambda using Maven, add the following to your pom.xml:\n <plugin>\n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>retrolambda-maven-plugin</artifactId>\n-    <version>1.3.0</version>\n+    <version>1.4.0</version>\n     <executions>\n         <execution>\n             <goals>\n@@ -147,7 +147,7 @@ package-private.\n Version History\n ---------------\n \n-### Upcoming\n+### Retrolambda 1.4.0 (2014-07-04)\n \n - Added an optional `-Dretrolambda.includedFiles` parameter to support the\n   incremental compilers of build tools\n"
    },
    {
        "commit_hash": "286b4d50f86f8a1f1a769249803db5f0c5dfece7",
        "previous_commit_hash": "2317d92ff3860614d67fe4807922a890df38ceff",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.3.1-SNAPSHOT</version>\n+        <version>1.4.0</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "286b4d50f86f8a1f1a769249803db5f0c5dfece7",
        "previous_commit_hash": "2317d92ff3860614d67fe4807922a890df38ceff",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>1.3.1-SNAPSHOT</version>\n+    <version>1.4.0</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "286b4d50f86f8a1f1a769249803db5f0c5dfece7",
        "previous_commit_hash": "2317d92ff3860614d67fe4807922a890df38ceff",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.3.1-SNAPSHOT</version>\n+        <version>1.4.0</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "286b4d50f86f8a1f1a769249803db5f0c5dfece7",
        "previous_commit_hash": "2317d92ff3860614d67fe4807922a890df38ceff",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.3.1-SNAPSHOT</version>\n+        <version>1.4.0</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "286b4d50f86f8a1f1a769249803db5f0c5dfece7",
        "previous_commit_hash": "2317d92ff3860614d67fe4807922a890df38ceff",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.3.1-SNAPSHOT</version>\n+        <version>1.4.0</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "2e5df9a5540f3b1f46857318e6ff4829c9a4e4cb",
        "previous_commit_hash": "286b4d50f86f8a1f1a769249803db5f0c5dfece7",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.4.0</version>\n+        <version>1.4.1-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "2e5df9a5540f3b1f46857318e6ff4829c9a4e4cb",
        "previous_commit_hash": "286b4d50f86f8a1f1a769249803db5f0c5dfece7",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>1.4.0</version>\n+    <version>1.4.1-SNAPSHOT</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "2e5df9a5540f3b1f46857318e6ff4829c9a4e4cb",
        "previous_commit_hash": "286b4d50f86f8a1f1a769249803db5f0c5dfece7",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.4.0</version>\n+        <version>1.4.1-SNAPSHOT</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "2e5df9a5540f3b1f46857318e6ff4829c9a4e4cb",
        "previous_commit_hash": "286b4d50f86f8a1f1a769249803db5f0c5dfece7",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.4.0</version>\n+        <version>1.4.1-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "2e5df9a5540f3b1f46857318e6ff4829c9a4e4cb",
        "previous_commit_hash": "286b4d50f86f8a1f1a769249803db5f0c5dfece7",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.4.0</version>\n+        <version>1.4.1-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "a136ccdd8a7b43d2ce5f0df9fc15d57674a2c7fc",
        "previous_commit_hash": "2e5df9a5540f3b1f46857318e6ff4829c9a4e4cb",
        "diff_stats": {
            "additions": 5,
            "deletions": 7
        },
        "diff_content": "@@ -97,6 +97,11 @@ See the [plugin documentation](http://orfjackal.github.io/retrolambda/retrolambd\n for all possible parameters. There is also a usage example in [end-to-end-tests/pom.xml](https://github.com/orfjackal/retrolambda/blob/master/end-to-end-tests/pom.xml)\n \n \n+### Gradle Plugin\n+\n+[Gradle Retrolamba Plugin](https://github.com/evant/gradle-retrolambda) is developed by Evan Tatarka. See its site for usage instructions.\n+\n+\n ### Tips\n \n During development, inside an IDE, it's the easiest to use Java 8, without\n@@ -112,13 +117,6 @@ what happens to be the default Java version in JAVA_HOME.\n You will need Java 8 for compiling and also for generating Javadocs.\n \n \n-### Third Party Tools\n-\n-- [Gradle Retrolamba Plugin](https://github.com/evant/gradle-retrolambda)\n-\n-If you have things to add to this list, [create a pull request](https://github.com/orfjackal/retrolambda/pulls).\n-\n-\n Known Limitations\n -----------------\n \n"
    },
    {
        "commit_hash": "b2f4451315678d2044bea5c4d060c55d0bf7199f",
        "previous_commit_hash": "a136ccdd8a7b43d2ce5f0df9fc15d57674a2c7fc",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -16,3 +16,4 @@ echo \"Done. Next steps:\"\n echo \"    open https://oss.sonatype.org/\"\n echo \"    git push origin HEAD\"\n echo \"    git push origin --tags\"\n+echo \"    cd ../retrolambda.pages; ./update-maven-site.sh\"\n"
    },
    {
        "commit_hash": "c97d496f07b93e763f87c8d03bde302b224966aa",
        "previous_commit_hash": "b2f4451315678d2044bea5c4d060c55d0bf7199f",
        "diff_stats": {
            "additions": 42,
            "deletions": 8
        },
        "diff_content": "@@ -7,14 +7,34 @@ package net.orfjackal.retrolambda.maven;\n import com.google.common.base.Joiner;\n import com.google.common.collect.ImmutableMap;\n import org.apache.maven.execution.MavenSession;\n-import org.apache.maven.plugin.*;\n-import org.apache.maven.plugins.annotations.*;\n+import org.apache.maven.plugin.AbstractMojo;\n+import org.apache.maven.plugin.BuildPluginManager;\n+import org.apache.maven.plugin.MojoExecutionException;\n+import org.apache.maven.plugins.annotations.Component;\n+import org.apache.maven.plugins.annotations.Parameter;\n import org.apache.maven.project.MavenProject;\n-\n-import java.io.*;\n-import java.util.*;\n-\n-import static org.twdata.maven.mojoexecutor.MojoExecutor.*;\n+import org.apache.maven.toolchain.Toolchain;\n+import org.apache.maven.toolchain.ToolchainManager;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.TreeSet;\n+\n+import static org.twdata.maven.mojoexecutor.MojoExecutor.artifactId;\n+import static org.twdata.maven.mojoexecutor.MojoExecutor.attribute;\n+import static org.twdata.maven.mojoexecutor.MojoExecutor.attributes;\n+import static org.twdata.maven.mojoexecutor.MojoExecutor.configuration;\n+import static org.twdata.maven.mojoexecutor.MojoExecutor.element;\n+import static org.twdata.maven.mojoexecutor.MojoExecutor.executeMojo;\n+import static org.twdata.maven.mojoexecutor.MojoExecutor.executionEnvironment;\n+import static org.twdata.maven.mojoexecutor.MojoExecutor.goal;\n+import static org.twdata.maven.mojoexecutor.MojoExecutor.groupId;\n+import static org.twdata.maven.mojoexecutor.MojoExecutor.name;\n+import static org.twdata.maven.mojoexecutor.MojoExecutor.plugin;\n+import static org.twdata.maven.mojoexecutor.MojoExecutor.version;\n \n abstract class ProcessClassesMojo extends AbstractMojo {\n \n@@ -25,6 +45,9 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n             \"1.8\", 52\n     );\n \n+    @Component\n+    private ToolchainManager toolchainManager;\n+\n     @Component\n     private MavenSession session;\n \n@@ -73,6 +96,17 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n         processClasses();\n     }\n \n+    private String getJavaCommandViaToolChain() {\n+        Toolchain tc = toolchainManager.getToolchainFromBuildContext( \"jdk\", session);\n+        if (tc != null) {\n+            getLog().info(\"Using JDK Toolchain: \" + tc );\n+            String javaCommand = tc.findTool(\"java\");\n+            return javaCommand;\n+        } else {\n+            return java8home + \"/bin/java\";\n+        }\n+    }\n+\n     private void validateTarget() throws MojoExecutionException {\n         if (!targetBytecodeVersions.containsKey(target)) {\n             String possibleValues = Joiner.on(\", \").join(new TreeSet<String>(targetBytecodeVersions.keySet()));\n@@ -120,7 +154,7 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n                                         attribute(\"refid\", getClasspathId()))),\n                         element(\"exec\",\n                                 attributes(\n-                                        attribute(\"executable\", java8home + \"/bin/java\"),\n+                                        attribute(\"executable\", getJavaCommandViaToolChain()),\n                                         attribute(\"failonerror\", \"true\")),\n                                 element(\"arg\", attribute(\"value\", \"-Dretrolambda.bytecodeVersion=\" + targetBytecodeVersions.get(target))),\n                                 element(\"arg\", attribute(\"value\", \"-Dretrolambda.inputDir=\" + getInputDir().getAbsolutePath())),\n"
    },
    {
        "commit_hash": "8497436520ec50664cf1162e6f17d3fcbaf2e90c",
        "previous_commit_hash": "5a46b8e171b4111d36bdd197180f1f3fdf6b2742",
        "diff_stats": {
            "additions": 6,
            "deletions": 3
        },
        "diff_content": "@@ -2,9 +2,12 @@\n Building Retrolambda\n ====================\n \n-Set the environment variables `JAVA8_HOME` and `JAVA7_HOME` (optionally also\n-`JAVA6_HOME` and `JAVA5_HOME`) point to the installation directories of those\n-particular JDK versions.\n+Set the following environment variables to point to the installation\n+directories of those particular JDK versions:\n+`JAVA8_HOME`, `JAVA7_HOME`, `JAVA6_HOME`, `JAVA5_HOME`\n+\n+Create ~/.m2/toolchains.xml and list all the JDKs there as shown in\n+http://maven.apache.org/plugins/maven-toolchains-plugin/toolchains/jdk.html\n \n Compile the project with Maven using the command:\n \n"
    },
    {
        "commit_hash": "8497436520ec50664cf1162e6f17d3fcbaf2e90c",
        "previous_commit_hash": "5a46b8e171b4111d36bdd197180f1f3fdf6b2742",
        "diff_stats": {
            "additions": 3,
            "deletions": 4
        },
        "diff_content": "@@ -68,12 +68,11 @@\n                             <goal>process-main</goal>\n                             <goal>process-test</goal>\n                         </goals>\n-                        <configuration>\n-                            <target>${testBytecodeTarget}</target>\n-                            <java8home>${env.JAVA8_HOME}</java8home>\n-                        </configuration>\n                     </execution>\n                 </executions>\n+                <configuration>\n+                    <target>${testBytecodeTarget}</target>\n+                </configuration>\n             </plugin>\n \n         </plugins>\n"
    },
    {
        "commit_hash": "8497436520ec50664cf1162e6f17d3fcbaf2e90c",
        "previous_commit_hash": "5a46b8e171b4111d36bdd197180f1f3fdf6b2742",
        "diff_stats": {
            "additions": 23,
            "deletions": 17
        },
        "diff_content": "@@ -43,7 +43,6 @@\n         <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n         <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n         <minimumMavenVersion>3.1</minimumMavenVersion>\n-        <compileJavaHome>${env.JAVA8_HOME}</compileJavaHome>\n         <testJavaHome>${env.JAVA7_HOME}</testJavaHome>\n         <testBytecodeTarget>1.7</testBytecodeTarget>\n     </properties>\n@@ -128,13 +127,29 @@\n     <build>\n         <plugins>\n \n+            <plugin>\n+                <artifactId>maven-toolchains-plugin</artifactId>\n+                <executions>\n+                    <execution>\n+                        <goals>\n+                            <goal>toolchain</goal>\n+                        </goals>\n+                    </execution>\n+                </executions>\n+                <configuration>\n+                    <toolchains>\n+                        <jdk>\n+                            <version>1.8</version>\n+                        </jdk>\n+                    </toolchains>\n+                </configuration>\n+            </plugin>\n+\n             <plugin>\n                 <artifactId>maven-compiler-plugin</artifactId>\n                 <configuration>\n                     <source>1.8</source>\n                     <target>1.8</target>\n-                    <fork>true</fork>\n-                    <executable>${compileJavaHome}/bin/javac</executable>\n                 </configuration>\n             </plugin>\n \n@@ -145,7 +160,6 @@\n                         <include>**/*Test.class</include>\n                     </includes>\n                     <redirectTestOutputToFile>true</redirectTestOutputToFile>\n-                    <jvm>${compileJavaHome}/bin/java</jvm>\n                 </configuration>\n             </plugin>\n \n@@ -172,13 +186,6 @@\n                 </executions>\n             </plugin>\n \n-            <plugin>\n-                <artifactId>maven-javadoc-plugin</artifactId>\n-                <configuration>\n-                    <javadocExecutable>${compileJavaHome}/bin/javadoc</javadocExecutable>\n-                </configuration>\n-            </plugin>\n-\n             <plugin>\n                 <artifactId>maven-enforcer-plugin</artifactId>\n                 <executions>\n@@ -203,12 +210,6 @@\n                         </goals>\n                         <configuration>\n                             <rules>\n-                                <requireFilesExist>\n-                                    <message>Java installation directory not found: ${compileJavaHome}</message>\n-                                    <files>\n-                                        <file>${compileJavaHome}</file>\n-                                    </files>\n-                                </requireFilesExist>\n                                 <requireFilesExist>\n                                     <message>Java installation directory not found: ${testJavaHome}</message>\n                                     <files>\n@@ -247,6 +248,11 @@\n         <pluginManagement>\n             <plugins>\n \n+                <plugin>\n+                    <artifactId>maven-toolchains-plugin</artifactId>\n+                    <version>1.0</version>\n+                </plugin>\n+\n                 <plugin>\n                     <artifactId>maven-clean-plugin</artifactId>\n                     <version>2.5</version>\n"
    },
    {
        "commit_hash": "8497436520ec50664cf1162e6f17d3fcbaf2e90c",
        "previous_commit_hash": "5a46b8e171b4111d36bdd197180f1f3fdf6b2742",
        "diff_stats": {
            "additions": 9,
            "deletions": 6
        },
        "diff_content": "@@ -49,18 +49,21 @@\n         <plugins>\n \n             <plugin>\n-                <artifactId>maven-compiler-plugin</artifactId>\n+                <artifactId>maven-toolchains-plugin</artifactId>\n                 <configuration>\n-                    <source>1.6</source>\n-                    <target>1.6</target>\n-                    <fork>true</fork>\n+                    <toolchains>\n+                        <jdk>\n+                            <version>1.6</version>\n+                        </jdk>\n+                    </toolchains>\n                 </configuration>\n             </plugin>\n \n             <plugin>\n-                <artifactId>maven-javadoc-plugin</artifactId>\n+                <artifactId>maven-compiler-plugin</artifactId>\n                 <configuration>\n-                    <javadocExecutable>${env.JAVA6_HOME}/bin/javadoc</javadocExecutable>\n+                    <source>1.6</source>\n+                    <target>1.6</target>\n                 </configuration>\n             </plugin>\n \n"
    },
    {
        "commit_hash": "67dd8307a4f65b91797765d15dec3bddec967a30",
        "previous_commit_hash": "8497436520ec50664cf1162e6f17d3fcbaf2e90c",
        "diff_stats": {
            "additions": 6,
            "deletions": 0
        },
        "diff_content": "@@ -145,6 +145,12 @@ package-private.\n Version History\n ---------------\n \n+### Upcoming\n+\n+- Maven plugin: use the [JDK from Maven Toolchains](http://maven.apache.org/plugins/maven-toolchains-plugin/toolchains/jdk.html)\n+  if available. The `java8home` configuration parameter overrides this\n+  ([Issue #24](https://github.com/orfjackal/retrolambda/pull/24))\n+\n ### Retrolambda 1.4.0 (2014-07-04)\n \n - Added an optional `-Dretrolambda.includedFiles` parameter to support the\n"
    },
    {
        "commit_hash": "67dd8307a4f65b91797765d15dec3bddec967a30",
        "previous_commit_hash": "8497436520ec50664cf1162e6f17d3fcbaf2e90c",
        "diff_stats": {
            "additions": 35,
            "deletions": 45
        },
        "diff_content": "@@ -7,34 +7,15 @@ package net.orfjackal.retrolambda.maven;\n import com.google.common.base.Joiner;\n import com.google.common.collect.ImmutableMap;\n import org.apache.maven.execution.MavenSession;\n-import org.apache.maven.plugin.AbstractMojo;\n-import org.apache.maven.plugin.BuildPluginManager;\n-import org.apache.maven.plugin.MojoExecutionException;\n-import org.apache.maven.plugins.annotations.Component;\n-import org.apache.maven.plugins.annotations.Parameter;\n+import org.apache.maven.plugin.*;\n+import org.apache.maven.plugins.annotations.*;\n import org.apache.maven.project.MavenProject;\n-import org.apache.maven.toolchain.Toolchain;\n-import org.apache.maven.toolchain.ToolchainManager;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.util.Map;\n-import java.util.Properties;\n-import java.util.TreeSet;\n-\n-import static org.twdata.maven.mojoexecutor.MojoExecutor.artifactId;\n-import static org.twdata.maven.mojoexecutor.MojoExecutor.attribute;\n-import static org.twdata.maven.mojoexecutor.MojoExecutor.attributes;\n-import static org.twdata.maven.mojoexecutor.MojoExecutor.configuration;\n-import static org.twdata.maven.mojoexecutor.MojoExecutor.element;\n-import static org.twdata.maven.mojoexecutor.MojoExecutor.executeMojo;\n-import static org.twdata.maven.mojoexecutor.MojoExecutor.executionEnvironment;\n-import static org.twdata.maven.mojoexecutor.MojoExecutor.goal;\n-import static org.twdata.maven.mojoexecutor.MojoExecutor.groupId;\n-import static org.twdata.maven.mojoexecutor.MojoExecutor.name;\n-import static org.twdata.maven.mojoexecutor.MojoExecutor.plugin;\n-import static org.twdata.maven.mojoexecutor.MojoExecutor.version;\n+import org.apache.maven.toolchain.*;\n+\n+import java.io.*;\n+import java.util.*;\n+\n+import static org.twdata.maven.mojoexecutor.MojoExecutor.*;\n \n abstract class ProcessClassesMojo extends AbstractMojo {\n \n@@ -46,7 +27,7 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n     );\n \n     @Component\n-    private ToolchainManager toolchainManager;\n+    ToolchainManager toolchainManager;\n \n     @Component\n     private MavenSession session;\n@@ -59,10 +40,16 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n \n     /**\n      * Directory of the Java 8 installation for running Retrolambda.\n+     * The JRE to be used will be determined in priority order:\n+     * <ol>\n+     * <li>This parameter</li>\n+     * <li><a href=\"http://maven.apache.org/plugins/maven-toolchains-plugin/toolchains/jdk.html\">JDK toolchain</a></li>\n+     * <li>Same as Maven</li>\n+     * </ol>\n      *\n      * @since 1.2.0\n      */\n-    @Parameter(defaultValue = \"${java.home}\", property = \"java8home\", required = true)\n+    @Parameter(property = \"java8home\", required = false)\n     public File java8home;\n \n     /**\n@@ -85,7 +72,6 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n \n     @Override\n     public void execute() throws MojoExecutionException {\n-        validateJava8home();\n         validateTarget();\n \n         String version = getRetrolambdaVersion();\n@@ -96,15 +82,26 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n         processClasses();\n     }\n \n-    private String getJavaCommandViaToolChain() {\n-        Toolchain tc = toolchainManager.getToolchainFromBuildContext( \"jdk\", session);\n+    String getJavaCommand() {\n+        String javaCommand = getJavaCommand(new File(System.getProperty(\"java.home\")));\n+\n+        Toolchain tc = toolchainManager.getToolchainFromBuildContext(\"jdk\", session);\n         if (tc != null) {\n-            getLog().info(\"Using JDK Toolchain: \" + tc );\n-            String javaCommand = tc.findTool(\"java\");\n-            return javaCommand;\n-        } else {\n-            return java8home + \"/bin/java\";\n+            getLog().info(\"Toolchain in retrolambda-maven-plugin: \" + tc);\n+            javaCommand = tc.findTool(\"java\");\n+        }\n+\n+        if (java8home != null) {\n+            if (tc != null) {\n+                getLog().warn(\"Toolchains are ignored, 'java8home' parameter is set to \" + java8home);\n+            }\n+            javaCommand = getJavaCommand(java8home);\n         }\n+        return javaCommand;\n+    }\n+\n+    private static String getJavaCommand(File javaHome) {\n+        return new File(javaHome, \"bin/java\").getPath();\n     }\n \n     private void validateTarget() throws MojoExecutionException {\n@@ -115,13 +112,6 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n         }\n     }\n \n-    private void validateJava8home() throws MojoExecutionException {\n-        if (!java8home.isDirectory()) {\n-            throw new MojoExecutionException(\n-                    \"Must set configuration element java8home or environment variable JAVA8_HOME to a valid JDK 8 location: \" + java8home);\n-        }\n-    }\n-\n     private void retrieveRetrolambdaJar(String version) throws MojoExecutionException {\n         // TODO: use Maven's built-in artifact resolving, so that we can refer to retrolambda.jar in the local repository without copying it\n         executeMojo(\n@@ -154,7 +144,7 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n                                         attribute(\"refid\", getClasspathId()))),\n                         element(\"exec\",\n                                 attributes(\n-                                        attribute(\"executable\", getJavaCommandViaToolChain()),\n+                                        attribute(\"executable\", getJavaCommand()),\n                                         attribute(\"failonerror\", \"true\")),\n                                 element(\"arg\", attribute(\"value\", \"-Dretrolambda.bytecodeVersion=\" + targetBytecodeVersions.get(target))),\n                                 element(\"arg\", attribute(\"value\", \"-Dretrolambda.inputDir=\" + getInputDir().getAbsolutePath())),\n"
    },
    {
        "commit_hash": "67dd8307a4f65b91797765d15dec3bddec967a30",
        "previous_commit_hash": "8497436520ec50664cf1162e6f17d3fcbaf2e90c",
        "diff_stats": {
            "additions": 65,
            "deletions": 3
        },
        "diff_content": "@@ -4,23 +4,35 @@\n \n package net.orfjackal.retrolambda.maven;\n \n+import org.apache.maven.execution.MavenSession;\n import org.apache.maven.plugin.MojoExecutionException;\n+import org.apache.maven.plugin.logging.Log;\n+import org.apache.maven.toolchain.*;\n+import org.apache.maven.toolchain.java.*;\n import org.junit.*;\n import org.junit.rules.ExpectedException;\n \n import java.io.File;\n+import java.util.*;\n \n-public class ProcessClassesMojoTest {\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.*;\n \n-    private final ProcessMainClassesMojo mojo = new ProcessMainClassesMojo();\n+public class ProcessClassesMojoTest {\n \n     @Rule\n     public final ExpectedException thrown = ExpectedException.none();\n \n+    private final Log log = mock(Log.class);\n+    private final FakeToolchainManager toolchainManager = new FakeToolchainManager();\n+    private final ProcessMainClassesMojo mojo = new ProcessMainClassesMojo();\n+\n     @Before\n     public void sensibleDefaults() {\n+        mojo.setLog(log);\n+        mojo.toolchainManager = toolchainManager;\n         mojo.target = \"1.7\";\n-        mojo.java8home = new File(System.getProperty(\"java.home\"));\n     }\n \n     @Test\n@@ -31,4 +43,54 @@ public class ProcessClassesMojoTest {\n         thrown.expectMessage(\"1.5, 1.6, 1.7, 1.8\");\n         mojo.execute();\n     }\n+\n+    @Test\n+    public void java_command_defaults_to_current_jvm() {\n+        assertThat(mojo.getJavaCommand(), is(new File(System.getProperty(\"java.home\"), \"bin/java\").getAbsolutePath()));\n+    }\n+\n+    @Test\n+    public void java_command_from_toolchain_overrides_the_current_jvm() {\n+        toolchainManager.setJdkToolChain(new FakeJavaToolChain(\"jdk-from-toolchain\"));\n+\n+        assertThat(mojo.getJavaCommand(), is(\"jdk-from-toolchain/bin/java\"));\n+        verify(log).info(\"Toolchain in retrolambda-maven-plugin: JDK[jdk-from-toolchain]\");\n+    }\n+\n+    @Test\n+    public void java_command_from_local_configuration_overrides_the_toolchain() {\n+        toolchainManager.setJdkToolChain(new FakeJavaToolChain(\"jdk-from-toolchain\"));\n+        mojo.java8home = new File(\"jdk-from-local-configuration\");\n+\n+        assertThat(mojo.getJavaCommand().replace('\\\\', '/'), is(\"jdk-from-local-configuration/bin/java\"));\n+        verify(log).warn(\"Toolchains are ignored, 'java8home' parameter is set to jdk-from-local-configuration\");\n+    }\n+\n+\n+    private static class FakeToolchainManager implements ToolchainManager {\n+\n+        private final Map<String, Toolchain> toolChainsByType = new HashMap<String, Toolchain>();\n+\n+        @Override\n+        public Toolchain getToolchainFromBuildContext(String type, MavenSession context) {\n+            return toolChainsByType.get(type);\n+        }\n+\n+        public void setJdkToolChain(JavaToolChain toolChain) {\n+            toolChainsByType.put(\"jdk\", toolChain);\n+        }\n+    }\n+\n+    private static class FakeJavaToolChain extends DefaultJavaToolChain {\n+\n+        public FakeJavaToolChain(String javaHome) {\n+            super(null, null);\n+            setJavaHome(javaHome);\n+        }\n+\n+        @Override\n+        public String findTool(String toolName) {\n+            return getJavaHome() + \"/bin/\" + toolName;\n+        }\n+    }\n }\n"
    },
    {
        "commit_hash": "a1d376a05a31a426744d24cc6e5c9d50b407b6cc",
        "previous_commit_hash": "67dd8307a4f65b91797765d15dec3bddec967a30",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -81,7 +81,7 @@ To run Retrolambda using Maven, add the following to your pom.xml:\n <plugin>\n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>retrolambda-maven-plugin</artifactId>\n-    <version>1.4.0</version>\n+    <version>1.5.0</version>\n     <executions>\n         <execution>\n             <goals>\n@@ -145,7 +145,7 @@ package-private.\n Version History\n ---------------\n \n-### Upcoming\n+### Retrolambda 1.5.0 (2014-07-19)\n \n - Maven plugin: use the [JDK from Maven Toolchains](http://maven.apache.org/plugins/maven-toolchains-plugin/toolchains/jdk.html)\n   if available. The `java8home` configuration parameter overrides this\n"
    },
    {
        "commit_hash": "a1d376a05a31a426744d24cc6e5c9d50b407b6cc",
        "previous_commit_hash": "67dd8307a4f65b91797765d15dec3bddec967a30",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.4.1-SNAPSHOT</version>\n+        <version>1.5.0</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "a1d376a05a31a426744d24cc6e5c9d50b407b6cc",
        "previous_commit_hash": "67dd8307a4f65b91797765d15dec3bddec967a30",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>1.4.1-SNAPSHOT</version>\n+    <version>1.5.0</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "a1d376a05a31a426744d24cc6e5c9d50b407b6cc",
        "previous_commit_hash": "67dd8307a4f65b91797765d15dec3bddec967a30",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.4.1-SNAPSHOT</version>\n+        <version>1.5.0</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "a1d376a05a31a426744d24cc6e5c9d50b407b6cc",
        "previous_commit_hash": "67dd8307a4f65b91797765d15dec3bddec967a30",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.4.1-SNAPSHOT</version>\n+        <version>1.5.0</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "a1d376a05a31a426744d24cc6e5c9d50b407b6cc",
        "previous_commit_hash": "67dd8307a4f65b91797765d15dec3bddec967a30",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.4.1-SNAPSHOT</version>\n+        <version>1.5.0</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "1ebbd6adaf9e64597f3236ce4e399d6cadfcf95b",
        "previous_commit_hash": "a1d376a05a31a426744d24cc6e5c9d50b407b6cc",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.5.0</version>\n+        <version>1.5.1-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "1ebbd6adaf9e64597f3236ce4e399d6cadfcf95b",
        "previous_commit_hash": "a1d376a05a31a426744d24cc6e5c9d50b407b6cc",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>1.5.0</version>\n+    <version>1.5.1-SNAPSHOT</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "1ebbd6adaf9e64597f3236ce4e399d6cadfcf95b",
        "previous_commit_hash": "a1d376a05a31a426744d24cc6e5c9d50b407b6cc",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.5.0</version>\n+        <version>1.5.1-SNAPSHOT</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "1ebbd6adaf9e64597f3236ce4e399d6cadfcf95b",
        "previous_commit_hash": "a1d376a05a31a426744d24cc6e5c9d50b407b6cc",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.5.0</version>\n+        <version>1.5.1-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "1ebbd6adaf9e64597f3236ce4e399d6cadfcf95b",
        "previous_commit_hash": "a1d376a05a31a426744d24cc6e5c9d50b407b6cc",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.5.0</version>\n+        <version>1.5.1-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "374c4f27f931526e216b47a29437c6e03104a964",
        "previous_commit_hash": "1ebbd6adaf9e64597f3236ce4e399d6cadfcf95b",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -16,4 +16,4 @@ echo \"Done. Next steps:\"\n echo \"    open https://oss.sonatype.org/\"\n echo \"    git push origin HEAD\"\n echo \"    git push origin --tags\"\n-echo \"    cd ../retrolambda.pages; ./update-maven-site.sh\"\n+echo \"    cd ../retrolambda.pages; ./update-maven-site.sh VERSION; git push\"\n"
    },
    {
        "commit_hash": "277342100909e5b6709481db68a91acd04714ba0",
        "previous_commit_hash": "374c4f27f931526e216b47a29437c6e03104a964",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -18,7 +18,7 @@\n     <modules>\n         <module>parent</module>\n         <module>retrolambda</module>\n-\t\t<module>retrolambda-maven-plugin</module>\n+        <module>retrolambda-maven-plugin</module>\n         <module>end-to-end-tests</module>\n     </modules>\n \n"
    },
    {
        "commit_hash": "367003021c90f5e8918b985ee4da37e2d14ff0d8",
        "previous_commit_hash": "277342100909e5b6709481db68a91acd04714ba0",
        "diff_stats": {
            "additions": 49,
            "deletions": 4
        },
        "diff_content": "@@ -6,14 +6,18 @@ package net.orfjackal.retrolambda.maven;\n \n import com.google.common.base.Joiner;\n import com.google.common.collect.ImmutableMap;\n+import java.io.*;\n+import java.lang.reflect.Method;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.util.*;\n+import org.apache.maven.artifact.Artifact;\n import org.apache.maven.execution.MavenSession;\n import org.apache.maven.plugin.*;\n import org.apache.maven.plugins.annotations.*;\n import org.apache.maven.project.MavenProject;\n import org.apache.maven.toolchain.*;\n \n-import java.io.*;\n-import java.util.*;\n \n import static org.twdata.maven.mojoexecutor.MojoExecutor.*;\n \n@@ -63,6 +67,16 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n      */\n     @Parameter(defaultValue = \"1.7\", property = \"retrolambdaTarget\", required = true)\n     public String target;\n+    \n+    /**\n+     * Should we start new process or perform the retrolambdafication in the \n+     * same VM as Maven runs in (which has to be 1.8 then)? If the VM is\n+     * forked, it uses -javaagent argument to intercept class definitions.\n+     * When we run in the same process, we hook into the class generation\n+     * by internal \"lambda dumping\" API.\n+     */\n+    @Parameter(defaultValue = \"false\")\n+    public boolean fork;\n \n     protected abstract File getInputDir();\n \n@@ -79,7 +93,11 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n         retrieveRetrolambdaJar(version);\n \n         getLog().info(\"Processing classes with Retrolambda\");\n-        processClasses();\n+        if (fork) {\n+            processClassesWithAgent();\n+        } else {\n+            processClasses();\n+        }\n     }\n \n     String getJavaCommand() {\n@@ -130,7 +148,7 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n                 executionEnvironment(project, session, pluginManager));\n     }\n \n-    private void processClasses() throws MojoExecutionException {\n+    private void processClassesWithAgent() throws MojoExecutionException {\n         String retrolambdaJar = getRetrolambdaJarPath();\n         executeMojo(\n                 plugin(groupId(\"org.apache.maven.plugins\"),\n@@ -155,6 +173,33 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n                                 element(\"arg\", attribute(\"value\", retrolambdaJar))))),\n                 executionEnvironment(project, session, pluginManager));\n     }\n+    \n+    private void processClasses() throws MojoExecutionException {\n+        String retrolambdaJar = getRetrolambdaJarPath();\n+        File jar = new File(retrolambdaJar);\n+        \n+        try {\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(getInputDir());\n+            for (Artifact a : project.getArtifacts()) {\n+                if (a.getFile() != null) {\n+                    sb.append(File.pathSeparator);\n+                    sb.append(a.getFile());\n+                }\n+            }\n+        \n+            URLClassLoader url = new URLClassLoader(new URL[] { jar.toURI().toURL() });\n+            Class<?> mainClass = Class.forName(\"net.orfjackal.retrolambda.Main\", true, url);\n+            System.setProperty(\"retrolambda.bytecodeVersion\", \"\" + targetBytecodeVersions.get(target));\n+            System.setProperty(\"retrolambda.inputDir\", getInputDir().getAbsolutePath());\n+            System.setProperty(\"retrolambda.outputDir\", getOutputDir().getAbsolutePath());\n+            System.setProperty(\"retrolambda.classpath\", sb.toString());\n+            Method main = mainClass.getMethod(\"main\", String[].class);\n+            main.invoke(null, (Object) new String[0]);\n+        } catch (Exception ex) {\n+            throw new MojoExecutionException(\"Cannot initialize classloader for \" + retrolambdaJar, ex);\n+        }\n+    }\n \n     private String getRetrolambdaJarPath() {\n         return getRetrolambdaJarDir() + \"/\" + getRetrolambdaJarName();\n"
    },
    {
        "commit_hash": "367003021c90f5e8918b985ee4da37e2d14ff0d8",
        "previous_commit_hash": "277342100909e5b6709481db68a91acd04714ba0",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -43,7 +43,7 @@ public class Config {\n     }\n \n     public boolean isFullyConfigured() {\n-        return hasAllRequiredProperties() && PreMain.isAgentLoaded();\n+        return hasAllRequiredProperties();\n     }\n \n     private boolean hasAllRequiredProperties() {\n"
    },
    {
        "commit_hash": "367003021c90f5e8918b985ee4da37e2d14ff0d8",
        "previous_commit_hash": "277342100909e5b6709481db68a91acd04714ba0",
        "diff_stats": {
            "additions": 440,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,440 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.Channels;\n+import java.nio.channels.SeekableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.file.*;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileAttribute;\n+import java.nio.file.attribute.FileAttributeView;\n+import java.nio.file.attribute.UserPrincipalLookupService;\n+import java.nio.file.spi.FileSystemProvider;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+\n+final class LambdaClassDumper {\n+\n+    private final Path outputDir;\n+    private final int targetVersion;\n+\n+    public LambdaClassDumper(Path outputDir, int targetVersion) {\n+        this.outputDir = outputDir;\n+        this.targetVersion = targetVersion;\n+    }\n+\n+    private Field field;\n+    void registerDumper() {\n+        try {\n+            Class<?> dumper = Class.forName(\"java.lang.invoke.ProxyClassesDumper\");\n+            Constructor<?> cnstr = dumper.getDeclaredConstructor(Path.class);\n+            cnstr.setAccessible(true);\n+            Class<?> mf = Class.forName(\"java.lang.invoke.InnerClassLambdaMetafactory\");\n+            field = mf.getDeclaredField(\"dumper\");\n+            Field m = field.getClass().getDeclaredField(\"modifiers\");\n+            m.setAccessible(true);\n+            int mod = m.getInt(field);\n+            m.setInt(field, mod & ~Modifier.FINAL);\n+            field.setAccessible(true);\n+            \n+            Path p = new VirtualPath(\"\");\n+            field.set(null, cnstr.newInstance(p));\n+        } catch (Exception ex) {\n+            throw new IllegalStateException(\"Cannot initialize dumper\", ex);\n+        }\n+    }\n+    \n+    void unregisterDumper() {\n+        if (field != null) {\n+            try {\n+                field.set(null, null);\n+            } catch (Exception ex) {\n+                throw new IllegalArgumentException(ex);\n+            }\n+        }\n+    }\n+\n+    private void reifyLambdaClass(String className, byte[] classfileBuffer) {\n+        try {\n+            System.out.println(\"Saving lambda class: \" + className);\n+            byte[] backportedBytecode = LambdaClassBackporter.transform(classfileBuffer, targetVersion);\n+            Path savePath = outputDir.resolve(className + \".class\");\n+            Files.createDirectories(savePath.getParent());\n+            Files.write(savePath, backportedBytecode);\n+\n+        } catch (Throwable t) {\n+            // print to stdout to keep in sync with other log output\n+            System.out.println(\"ERROR: Failed to backport lambda class: \" + className);\n+            t.printStackTrace(System.out);\n+        }\n+    }\n+    \n+    private final class VirtualProvider extends FileSystemProvider {\n+\n+        @Override\n+        public String getScheme() {\n+            throw new IllegalStateException();\n+        }\n+\n+        @Override\n+        public FileSystem newFileSystem(URI uri, Map<String, ?> env) throws IOException {\n+            throw new IllegalStateException();\n+        }\n+\n+        @Override\n+        public FileSystem getFileSystem(URI uri) {\n+            throw new IllegalStateException();\n+        }\n+\n+        @Override\n+        public Path getPath(URI uri) {\n+            throw new IllegalStateException();\n+        }\n+\n+        @Override\n+        public SeekableByteChannel newByteChannel(Path path, Set<? extends OpenOption> options, FileAttribute<?>... attrs) throws IOException {\n+            return new ClassChannel(path);\n+        }\n+\n+        @Override\n+        public DirectoryStream<Path> newDirectoryStream(Path dir, DirectoryStream.Filter<? super Path> filter) throws IOException {\n+            throw new IllegalStateException();\n+        }\n+\n+        @Override\n+        public void createDirectory(Path dir, FileAttribute<?>... attrs) throws IOException {\n+        }\n+\n+        @Override\n+        public void delete(Path path) throws IOException {\n+            throw new IllegalStateException();\n+        }\n+\n+        @Override\n+        public void copy(Path source, Path target, CopyOption... options) throws IOException {\n+            throw new IllegalStateException();\n+        }\n+\n+        @Override\n+        public void move(Path source, Path target, CopyOption... options) throws IOException {\n+            throw new IllegalStateException();\n+        }\n+\n+        @Override\n+        public boolean isSameFile(Path path, Path path2) throws IOException {\n+            throw new IllegalStateException();\n+        }\n+\n+        @Override\n+        public boolean isHidden(Path path) throws IOException {\n+            throw new IllegalStateException();\n+        }\n+\n+        @Override\n+        public FileStore getFileStore(Path path) throws IOException {\n+            throw new IllegalStateException();\n+        }\n+\n+        @Override\n+        public void checkAccess(Path path, AccessMode... modes) throws IOException {\n+            throw new IllegalStateException();\n+        }\n+\n+        @Override\n+        public <V extends FileAttributeView> V getFileAttributeView(Path path, Class<V> type, LinkOption... options) {\n+            throw new IllegalStateException();\n+        }\n+\n+        @Override\n+        public <A extends BasicFileAttributes> A readAttributes(Path path, Class<A> type, LinkOption... options) throws IOException {\n+            throw new IllegalStateException();\n+        }\n+\n+        @Override\n+        public Map<String, Object> readAttributes(Path path, String attributes, LinkOption... options) throws IOException {\n+            throw new IllegalStateException();\n+        }\n+\n+        @Override\n+        public void setAttribute(Path path, String attribute, Object value, LinkOption... options) throws IOException {\n+            throw new IllegalStateException();\n+        }\n+        \n+    }\n+    \n+    private final class VirtualFS extends FileSystem {\n+\n+        @Override\n+        public FileSystemProvider provider() {\n+            return new VirtualProvider();\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            throw new IllegalStateException();\n+        }\n+\n+        @Override\n+        public boolean isOpen() {\n+            throw new IllegalStateException();\n+        }\n+\n+        @Override\n+        public boolean isReadOnly() {\n+            throw new IllegalStateException();\n+        }\n+\n+        @Override\n+        public String getSeparator() {\n+            throw new IllegalStateException();\n+        }\n+\n+        @Override\n+        public Iterable<Path> getRootDirectories() {\n+            throw new IllegalStateException();\n+        }\n+\n+        @Override\n+        public Iterable<FileStore> getFileStores() {\n+            throw new IllegalStateException();\n+        }\n+\n+        @Override\n+        public Set<String> supportedFileAttributeViews() {\n+            throw new IllegalStateException();\n+        }\n+\n+        @Override\n+        public Path getPath(String first, String... more) {\n+            throw new IllegalStateException();\n+        }\n+\n+        @Override\n+        public PathMatcher getPathMatcher(String syntaxAndPattern) {\n+            throw new IllegalStateException();\n+        }\n+\n+        @Override\n+        public UserPrincipalLookupService getUserPrincipalLookupService() {\n+            throw new IllegalStateException();\n+        }\n+\n+        @Override\n+        public WatchService newWatchService() throws IOException {\n+            throw new IllegalStateException();\n+        }\n+        \n+    }\n+    \n+    private final class VirtualPath implements Path {\n+        private final String path;\n+\n+        public VirtualPath(String path) {\n+            this.path = path;\n+        }\n+\n+        @Override\n+        public FileSystem getFileSystem() {\n+            return new VirtualFS();\n+        }\n+\n+        @Override\n+        public boolean isAbsolute() {\n+            throw new IllegalStateException();\n+        }\n+\n+        @Override\n+        public Path getRoot() {\n+            throw new IllegalStateException();\n+        }\n+\n+        @Override\n+        public Path getFileName() {\n+            throw new IllegalStateException();\n+        }\n+\n+        @Override\n+        public Path getParent() {\n+            return this;\n+        }\n+\n+        @Override\n+        public int getNameCount() {\n+            throw new IllegalStateException();\n+        }\n+\n+        @Override\n+        public Path getName(int index) {\n+            throw new IllegalStateException();\n+        }\n+\n+        @Override\n+        public Path subpath(int beginIndex, int endIndex) {\n+            throw new IllegalStateException();\n+        }\n+\n+        @Override\n+        public boolean startsWith(Path other) {\n+            throw new IllegalStateException();\n+        }\n+\n+        @Override\n+        public boolean startsWith(String other) {\n+            throw new IllegalStateException();\n+        }\n+\n+        @Override\n+        public boolean endsWith(Path other) {\n+            throw new IllegalStateException();\n+        }\n+\n+        @Override\n+        public boolean endsWith(String other) {\n+            throw new IllegalStateException();\n+        }\n+\n+        @Override\n+        public Path normalize() {\n+            throw new IllegalStateException();\n+        }\n+\n+        @Override\n+        public Path resolve(Path other) {\n+            throw new IllegalStateException();\n+        }\n+\n+        @Override\n+        public Path resolve(String other) {\n+            assert path.isEmpty();\n+            return new VirtualPath(other);\n+        }\n+\n+        @Override\n+        public Path resolveSibling(Path other) {\n+            throw new IllegalStateException();\n+        }\n+\n+        @Override\n+        public Path resolveSibling(String other) {\n+            throw new IllegalStateException();\n+        }\n+\n+        @Override\n+        public Path relativize(Path other) {\n+            throw new IllegalStateException();\n+        }\n+\n+        @Override\n+        public URI toUri() {\n+            throw new IllegalStateException();\n+        }\n+\n+        @Override\n+        public Path toAbsolutePath() {\n+            throw new IllegalStateException();\n+        }\n+\n+        @Override\n+        public Path toRealPath(LinkOption... options) throws IOException {\n+            throw new IllegalStateException();\n+        }\n+\n+        @Override\n+        public File toFile() {\n+            throw new IllegalStateException();\n+        }\n+\n+        @Override\n+        public WatchKey register(WatchService watcher, WatchEvent.Kind<?>[] events, WatchEvent.Modifier... modifiers) throws IOException {\n+            throw new IllegalStateException();\n+        }\n+\n+        @Override\n+        public WatchKey register(WatchService watcher, WatchEvent.Kind<?>... events) throws IOException {\n+            throw new IllegalStateException();\n+        }\n+\n+        @Override\n+        public Iterator<Path> iterator() {\n+            throw new IllegalStateException();\n+        }\n+\n+        @Override\n+        public int compareTo(Path other) {\n+            throw new IllegalStateException();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return path;\n+        }\n+    }\n+    \n+    private final class ClassChannel implements SeekableByteChannel {\n+        private final Path path;\n+        private final ByteArrayOutputStream os;\n+        private final WritableByteChannel ch;\n+\n+        public ClassChannel(Path path) {\n+            this.path = path;\n+            this.os = new ByteArrayOutputStream();\n+            this.ch = Channels.newChannel(os);\n+        }\n+        \n+        @Override\n+        public int read(ByteBuffer dst) throws IOException {\n+            throw new IOException();\n+        }\n+\n+        @Override\n+        public int write(ByteBuffer src) throws IOException {\n+            return ch.write(src);\n+        }\n+\n+        @Override\n+        public long position() throws IOException {\n+            throw new IOException();\n+        }\n+\n+        @Override\n+        public SeekableByteChannel position(long newPosition) throws IOException {\n+            throw new IOException();\n+        }\n+\n+        @Override\n+        public long size() throws IOException {\n+            throw new IOException();\n+        }\n+\n+        @Override\n+        public SeekableByteChannel truncate(long size) throws IOException {\n+            throw new IOException();\n+        }\n+\n+        @Override\n+        public boolean isOpen() {\n+            return true;\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            String className = path.toString();\n+            className = className.substring(0, className.length() - 6);\n+            if (LambdaReifier.isLambdaClassToReify(className)) {\n+                reifyLambdaClass(className, os.toByteArray());\n+            }\n+        }\n+    } // end of ClassCastException\n+}\n"
    },
    {
        "commit_hash": "367003021c90f5e8918b985ee4da37e2d14ff0d8",
        "previous_commit_hash": "277342100909e5b6709481db68a91acd04714ba0",
        "diff_stats": {
            "additions": 9,
            "deletions": 1
        },
        "diff_content": "@@ -43,7 +43,15 @@ public class Main {\n             visitFiles(inputDir, includedFiles, new BytecodeTransformingFileVisitor(inputDir, outputDir) {\n                 @Override\n                 protected byte[] transform(byte[] bytecode) {\n-                    return LambdaUsageBackporter.transform(bytecode, bytecodeVersion);\n+                    if (PreMain.isAgentLoaded()) {\n+                        return LambdaUsageBackporter.transform(bytecode, bytecodeVersion);\n+                    } else {\n+                        final LambdaClassDumper trans = new LambdaClassDumper(outputDir, bytecodeVersion);\n+                        trans.registerDumper();\n+                        byte[] ret = LambdaUsageBackporter.transform(bytecode, bytecodeVersion);\n+                        trans.unregisterDumper();\n+                        return ret;\n+                    }\n                 }\n             });\n         } catch (Throwable t) {\n"
    },
    {
        "commit_hash": "00b4c0520831e198497576bef8b42a8cac6cb427",
        "previous_commit_hash": "2e46b84e79eda7cc68527b59274c74d3b7ef0749",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -72,6 +72,7 @@\n                 </executions>\n                 <configuration>\n                     <target>${testBytecodeTarget}</target>\n+                    <fork>${testFork}</fork>\n                 </configuration>\n             </plugin>\n \n"
    },
    {
        "commit_hash": "00b4c0520831e198497576bef8b42a8cac6cb427",
        "previous_commit_hash": "2e46b84e79eda7cc68527b59274c74d3b7ef0749",
        "diff_stats": {
            "additions": 7,
            "deletions": 0
        },
        "diff_content": "@@ -45,6 +45,7 @@\n         <minimumMavenVersion>3.1</minimumMavenVersion>\n         <testJavaHome>${env.JAVA7_HOME}</testJavaHome>\n         <testBytecodeTarget>1.7</testBytecodeTarget>\n+        <testFork>false</testFork>\n     </properties>\n \n     <prerequisites>\n@@ -390,6 +391,12 @@\n                 <testBytecodeTarget>1.5</testBytecodeTarget>\n             </properties>\n         </profile>\n+        <profile>\n+            <id>fork</id>\n+            <properties>\n+                <testFork>true</testFork>\n+            </properties>\n+        </profile>\n     </profiles>\n \n </project>\n"
    },
    {
        "commit_hash": "00b4c0520831e198497576bef8b42a8cac6cb427",
        "previous_commit_hash": "2e46b84e79eda7cc68527b59274c74d3b7ef0749",
        "diff_stats": {
            "additions": 4,
            "deletions": 0
        },
        "diff_content": "@@ -6,6 +6,10 @@ set -x\n \n rm -rfv staging\n \n+mvn clean verify \\\n+    --errors \\\n+    -P fork\n+\n mvn clean verify \\\n     --errors \\\n     -P java6\n"
    },
    {
        "commit_hash": "25014618e671f2eb9922756332da4879bb472d06",
        "previous_commit_hash": "00b4c0520831e198497576bef8b42a8cac6cb427",
        "diff_stats": {
            "additions": 6,
            "deletions": 0
        },
        "diff_content": "@@ -14,6 +14,12 @@\n \n     <dependencies>\n \n+        <dependency>\n+            <groupId>net.orfjackal.retrolambda</groupId>\n+            <artifactId>retrolambda</artifactId>\n+            <version>${project.version}</version>\n+        </dependency>\n+\n         <dependency>\n             <groupId>org.apache.maven</groupId>\n             <artifactId>maven-plugin-api</artifactId>\n"
    },
    {
        "commit_hash": "25014618e671f2eb9922756332da4879bb472d06",
        "previous_commit_hash": "00b4c0520831e198497576bef8b42a8cac6cb427",
        "diff_stats": {
            "additions": 2,
            "deletions": 0
        },
        "diff_content": "@@ -17,6 +17,8 @@\n     </content>\n     <orderEntry type=\"inheritedJdk\" />\n     <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n+    <orderEntry type=\"module\" module-name=\"retrolambda\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.ow2.asm:asm-debug-all:5.0.2\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-plugin-api:2.0\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"PROVIDED\" name=\"Maven: org.apache.maven.plugin-tools:maven-plugin-annotations:3.2\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-artifact:3.0\" level=\"project\" />\n"
    },
    {
        "commit_hash": "25014618e671f2eb9922756332da4879bb472d06",
        "previous_commit_hash": "00b4c0520831e198497576bef8b42a8cac6cb427",
        "diff_stats": {
            "additions": 30,
            "deletions": 37
        },
        "diff_content": "@@ -6,11 +6,7 @@ package net.orfjackal.retrolambda.maven;\n \n import com.google.common.base.Joiner;\n import com.google.common.collect.ImmutableMap;\n-import java.io.*;\n-import java.lang.reflect.Method;\n-import java.net.URL;\n-import java.net.URLClassLoader;\n-import java.util.*;\n+import net.orfjackal.retrolambda.Main;\n import org.apache.maven.artifact.Artifact;\n import org.apache.maven.execution.MavenSession;\n import org.apache.maven.plugin.*;\n@@ -18,6 +14,8 @@ import org.apache.maven.plugins.annotations.*;\n import org.apache.maven.project.MavenProject;\n import org.apache.maven.toolchain.*;\n \n+import java.io.*;\n+import java.util.*;\n \n import static org.twdata.maven.mojoexecutor.MojoExecutor.*;\n \n@@ -67,9 +65,9 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n      */\n     @Parameter(defaultValue = \"1.7\", property = \"retrolambdaTarget\", required = true)\n     public String target;\n-    \n+\n     /**\n-     * Should we start new process or perform the retrolambdafication in the \n+     * Should we start new process or perform the retrolambdafication in the\n      * same VM as Maven runs in (which has to be 1.8 then)? If the VM is\n      * forked, it uses -javaagent argument to intercept class definitions.\n      * When we run in the same process, we hook into the class generation\n@@ -88,15 +86,17 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n     public void execute() throws MojoExecutionException {\n         validateTarget();\n \n-        String version = getRetrolambdaVersion();\n-        getLog().info(\"Retrieving Retrolambda \" + version);\n-        retrieveRetrolambdaJar(version);\n+        if (fork) {\n+            String version = getRetrolambdaVersion();\n+            getLog().info(\"Retrieving Retrolambda \" + version);\n+            retrieveRetrolambdaJar(version);\n+        }\n \n         getLog().info(\"Processing classes with Retrolambda\");\n         if (fork) {\n-            processClassesWithAgent();\n+            processClassesWithAgentHook();\n         } else {\n-            processClasses();\n+            processClassesWithDumperHook();\n         }\n     }\n \n@@ -148,7 +148,7 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n                 executionEnvironment(project, session, pluginManager));\n     }\n \n-    private void processClassesWithAgent() throws MojoExecutionException {\n+    private void processClassesWithAgentHook() throws MojoExecutionException {\n         String retrolambdaJar = getRetrolambdaJarPath();\n         executeMojo(\n                 plugin(groupId(\"org.apache.maven.plugins\"),\n@@ -173,32 +173,25 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n                                 element(\"arg\", attribute(\"value\", retrolambdaJar))))),\n                 executionEnvironment(project, session, pluginManager));\n     }\n-    \n-    private void processClasses() throws MojoExecutionException {\n-        String retrolambdaJar = getRetrolambdaJarPath();\n-        File jar = new File(retrolambdaJar);\n-        \n-        try {\n-            StringBuilder sb = new StringBuilder();\n-            sb.append(getInputDir());\n-            for (Artifact a : project.getArtifacts()) {\n-                if (a.getFile() != null) {\n-                    sb.append(File.pathSeparator);\n-                    sb.append(a.getFile());\n-                }\n+\n+    private void processClassesWithDumperHook() {\n+        System.setProperty(\"retrolambda.bytecodeVersion\", \"\" + targetBytecodeVersions.get(target));\n+        System.setProperty(\"retrolambda.inputDir\", getInputDir().getAbsolutePath());\n+        System.setProperty(\"retrolambda.outputDir\", getOutputDir().getAbsolutePath());\n+        System.setProperty(\"retrolambda.classpath\", getProjectClasspath());\n+        Main.main(new String[0]);\n+    }\n+\n+    private String getProjectClasspath() {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(getInputDir());\n+        for (Artifact a : project.getArtifacts()) {\n+            if (a.getFile() != null) {\n+                sb.append(File.pathSeparator);\n+                sb.append(a.getFile());\n             }\n-        \n-            URLClassLoader url = new URLClassLoader(new URL[] { jar.toURI().toURL() });\n-            Class<?> mainClass = Class.forName(\"net.orfjackal.retrolambda.Main\", true, url);\n-            System.setProperty(\"retrolambda.bytecodeVersion\", \"\" + targetBytecodeVersions.get(target));\n-            System.setProperty(\"retrolambda.inputDir\", getInputDir().getAbsolutePath());\n-            System.setProperty(\"retrolambda.outputDir\", getOutputDir().getAbsolutePath());\n-            System.setProperty(\"retrolambda.classpath\", sb.toString());\n-            Method main = mainClass.getMethod(\"main\", String[].class);\n-            main.invoke(null, (Object) new String[0]);\n-        } catch (Exception ex) {\n-            throw new MojoExecutionException(\"Cannot initialize classloader for \" + retrolambdaJar, ex);\n         }\n+        return sb.toString();\n     }\n \n     private String getRetrolambdaJarPath() {\n"
    },
    {
        "commit_hash": "25014618e671f2eb9922756332da4879bb472d06",
        "previous_commit_hash": "00b4c0520831e198497576bef8b42a8cac6cb427",
        "diff_stats": {
            "additions": 31,
            "deletions": 0
        },
        "diff_content": "@@ -40,6 +40,37 @@\n                 </configuration>\n             </plugin>\n \n+            <!-- To allow the Maven plugin be directly compiled against Retrolamdba,\n+                 we must backport Retrolambda itself to Java 6 -->\n+\n+            <plugin>\n+                <artifactId>maven-antrun-plugin</artifactId>\n+                <executions>\n+                    <execution>\n+                        <id>retrolambda-inception</id>\n+                        <phase>process-classes</phase>\n+                        <goals>\n+                            <goal>run</goal>\n+                        </goals>\n+                        <configuration>\n+                            <target>\n+                                <property name=\"compile_classpath\" refid=\"maven.compile.classpath\"/>\n+                                <exec executable=\"${env.JAVA8_HOME}/bin/java\" failonerror=\"true\">\n+                                    <arg value=\"-Dretrolambda.bytecodeVersion=50\"/>\n+                                    <arg value=\"-Dretrolambda.inputDir=${project.build.outputDirectory}\"/>\n+                                    <arg value=\"-Dretrolambda.classpath=${compile_classpath}\"/>\n+                                    <arg value=\"-cp\"/>\n+                                    <arg value=\"${project.build.outputDirectory}\"/>\n+                                    <arg value=\"-cp\"/>\n+                                    <arg value=\"${compile_classpath}\"/>\n+                                    <arg value=\"net.orfjackal.retrolambda.Main\"/>\n+                                </exec>\n+                            </target>\n+                        </configuration>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+\n             <!-- Create an uber jar containing all dependencies -->\n \n             <plugin>\n"
    },
    {
        "commit_hash": "25014618e671f2eb9922756332da4879bb472d06",
        "previous_commit_hash": "00b4c0520831e198497576bef8b42a8cac6cb427",
        "diff_stats": {
            "additions": 15,
            "deletions": 1
        },
        "diff_content": "@@ -14,6 +14,11 @@ public class Main {\n     public static void main(String[] args) {\n         System.out.println(\"Retrolambda \" + getVersion());\n \n+        if (!isRunningJava8()) {\n+            System.out.println(\"Error! Not running under Java 8\");\n+            System.exit(1);\n+        }\n+\n         Config config = new Config(System.getProperties());\n         if (!config.isFullyConfigured()) {\n             System.out.print(config.getHelp());\n@@ -61,6 +66,15 @@ public class Main {\n         }\n     }\n \n+    private static boolean isRunningJava8() {\n+        try {\n+            Class.forName(\"java.util.stream.Stream\");\n+            return true;\n+        } catch (ClassNotFoundException e) {\n+            return false;\n+        }\n+    }\n+\n     static void visitFiles(Path inputDir, List<Path> includedFiles, FileVisitor<Path> visitor) throws IOException {\n         if (includedFiles != null) {\n             visitor = new FilteringFileVisitor(includedFiles, visitor);\n@@ -86,7 +100,7 @@ public class Main {\n \n     private static String getVersion() {\n         Properties p = new Properties();\n-        try (InputStream in = ClassLoader.getSystemResourceAsStream(\"META-INF/maven/net.orfjackal.retrolambda/retrolambda/pom.properties\")) {\n+        try (InputStream in = Main.class.getResourceAsStream(\"/META-INF/maven/net.orfjackal.retrolambda/retrolambda/pom.properties\")) {\n             if (in != null) {\n                 p.load(in);\n             }\n"
    },
    {
        "commit_hash": "0b08370176bc89726ae3af182a8be43d8d94cf39",
        "previous_commit_hash": "25014618e671f2eb9922756332da4879bb472d06",
        "diff_stats": {
            "additions": 64,
            "deletions": 66
        },
        "diff_content": "@@ -4,68 +4,66 @@\n \n package net.orfjackal.retrolambda;\n \n-import java.io.ByteArrayOutputStream;\n-import java.io.File;\n-import java.io.IOException;\n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Modifier;\n+import java.io.*;\n+import java.lang.reflect.*;\n import java.net.URI;\n import java.nio.ByteBuffer;\n-import java.nio.channels.Channels;\n-import java.nio.channels.SeekableByteChannel;\n-import java.nio.channels.WritableByteChannel;\n+import java.nio.channels.*;\n import java.nio.file.*;\n-import java.nio.file.attribute.BasicFileAttributes;\n-import java.nio.file.attribute.FileAttribute;\n-import java.nio.file.attribute.FileAttributeView;\n-import java.nio.file.attribute.UserPrincipalLookupService;\n+import java.nio.file.FileSystem;\n+import java.nio.file.attribute.*;\n import java.nio.file.spi.FileSystemProvider;\n-import java.util.Iterator;\n-import java.util.Map;\n-import java.util.Set;\n+import java.util.*;\n \n-final class LambdaClassDumper {\n+public class LambdaClassDumper {\n \n     private final Path outputDir;\n     private final int targetVersion;\n+    private Field dumperField;\n \n     public LambdaClassDumper(Path outputDir, int targetVersion) {\n         this.outputDir = outputDir;\n         this.targetVersion = targetVersion;\n     }\n \n-    private Field field;\n-    void registerDumper() {\n+    public void registerDumper() {\n         try {\n-            Class<?> dumper = Class.forName(\"java.lang.invoke.ProxyClassesDumper\");\n-            Constructor<?> cnstr = dumper.getDeclaredConstructor(Path.class);\n-            cnstr.setAccessible(true);\n             Class<?> mf = Class.forName(\"java.lang.invoke.InnerClassLambdaMetafactory\");\n-            field = mf.getDeclaredField(\"dumper\");\n-            Field m = field.getClass().getDeclaredField(\"modifiers\");\n-            m.setAccessible(true);\n-            int mod = m.getInt(field);\n-            m.setInt(field, mod & ~Modifier.FINAL);\n-            field.setAccessible(true);\n-            \n+            dumperField = mf.getDeclaredField(\"dumper\");\n+            makeNonFinal(dumperField);\n+            dumperField.setAccessible(true);\n+\n             Path p = new VirtualPath(\"\");\n-            field.set(null, cnstr.newInstance(p));\n-        } catch (Exception ex) {\n-            throw new IllegalStateException(\"Cannot initialize dumper\", ex);\n+            dumperField.set(null, newProxyClassesDumper(p));\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Cannot initialize dumper\", e);\n         }\n     }\n-    \n-    void unregisterDumper() {\n-        if (field != null) {\n+\n+    public void unregisterDumper() {\n+        if (dumperField != null) {\n             try {\n-                field.set(null, null);\n-            } catch (Exception ex) {\n-                throw new IllegalArgumentException(ex);\n+                dumperField.set(null, null);\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n             }\n         }\n     }\n \n+    private static void makeNonFinal(Field field) throws Exception {\n+        Field modifiers = field.getClass().getDeclaredField(\"modifiers\");\n+        modifiers.setAccessible(true);\n+        int mod = modifiers.getInt(field);\n+        modifiers.setInt(field, mod & ~Modifier.FINAL);\n+    }\n+\n+    private static Object newProxyClassesDumper(Path dumpDir) throws Exception {\n+        Class<?> dumper = Class.forName(\"java.lang.invoke.ProxyClassesDumper\");\n+        Constructor<?> c = dumper.getDeclaredConstructor(Path.class);\n+        c.setAccessible(true);\n+        return c.newInstance(dumpDir);\n+    }\n+\n     private void reifyLambdaClass(String className, byte[] classfileBuffer) {\n         try {\n             System.out.println(\"Saving lambda class: \" + className);\n@@ -80,7 +78,8 @@ final class LambdaClassDumper {\n             t.printStackTrace(System.out);\n         }\n     }\n-    \n+\n+\n     private final class VirtualProvider extends FileSystemProvider {\n \n         @Override\n@@ -89,7 +88,7 @@ final class LambdaClassDumper {\n         }\n \n         @Override\n-        public FileSystem newFileSystem(URI uri, Map<String, ?> env) throws IOException {\n+        public FileSystem newFileSystem(URI uri, Map<String, ?> env) {\n             throw new IllegalStateException();\n         }\n \n@@ -104,51 +103,51 @@ final class LambdaClassDumper {\n         }\n \n         @Override\n-        public SeekableByteChannel newByteChannel(Path path, Set<? extends OpenOption> options, FileAttribute<?>... attrs) throws IOException {\n+        public SeekableByteChannel newByteChannel(Path path, Set<? extends OpenOption> options, FileAttribute<?>... attrs) {\n             return new ClassChannel(path);\n         }\n \n         @Override\n-        public DirectoryStream<Path> newDirectoryStream(Path dir, DirectoryStream.Filter<? super Path> filter) throws IOException {\n+        public DirectoryStream<Path> newDirectoryStream(Path dir, DirectoryStream.Filter<? super Path> filter) {\n             throw new IllegalStateException();\n         }\n \n         @Override\n-        public void createDirectory(Path dir, FileAttribute<?>... attrs) throws IOException {\n+        public void createDirectory(Path dir, FileAttribute<?>... attrs) {\n         }\n \n         @Override\n-        public void delete(Path path) throws IOException {\n+        public void delete(Path path) {\n             throw new IllegalStateException();\n         }\n \n         @Override\n-        public void copy(Path source, Path target, CopyOption... options) throws IOException {\n+        public void copy(Path source, Path target, CopyOption... options) {\n             throw new IllegalStateException();\n         }\n \n         @Override\n-        public void move(Path source, Path target, CopyOption... options) throws IOException {\n+        public void move(Path source, Path target, CopyOption... options) {\n             throw new IllegalStateException();\n         }\n \n         @Override\n-        public boolean isSameFile(Path path, Path path2) throws IOException {\n+        public boolean isSameFile(Path path, Path path2) {\n             throw new IllegalStateException();\n         }\n \n         @Override\n-        public boolean isHidden(Path path) throws IOException {\n+        public boolean isHidden(Path path) {\n             throw new IllegalStateException();\n         }\n \n         @Override\n-        public FileStore getFileStore(Path path) throws IOException {\n+        public FileStore getFileStore(Path path) {\n             throw new IllegalStateException();\n         }\n \n         @Override\n-        public void checkAccess(Path path, AccessMode... modes) throws IOException {\n+        public void checkAccess(Path path, AccessMode... modes) {\n             throw new IllegalStateException();\n         }\n \n@@ -158,22 +157,21 @@ final class LambdaClassDumper {\n         }\n \n         @Override\n-        public <A extends BasicFileAttributes> A readAttributes(Path path, Class<A> type, LinkOption... options) throws IOException {\n+        public <A extends BasicFileAttributes> A readAttributes(Path path, Class<A> type, LinkOption... options) {\n             throw new IllegalStateException();\n         }\n \n         @Override\n-        public Map<String, Object> readAttributes(Path path, String attributes, LinkOption... options) throws IOException {\n+        public Map<String, Object> readAttributes(Path path, String attributes, LinkOption... options) {\n             throw new IllegalStateException();\n         }\n \n         @Override\n-        public void setAttribute(Path path, String attribute, Object value, LinkOption... options) throws IOException {\n+        public void setAttribute(Path path, String attribute, Object value, LinkOption... options) {\n             throw new IllegalStateException();\n         }\n-        \n     }\n-    \n+\n     private final class VirtualFS extends FileSystem {\n \n         @Override\n@@ -182,7 +180,7 @@ final class LambdaClassDumper {\n         }\n \n         @Override\n-        public void close() throws IOException {\n+        public void close() {\n             throw new IllegalStateException();\n         }\n \n@@ -232,13 +230,13 @@ final class LambdaClassDumper {\n         }\n \n         @Override\n-        public WatchService newWatchService() throws IOException {\n+        public WatchService newWatchService() {\n             throw new IllegalStateException();\n         }\n-        \n     }\n-    \n+\n     private final class VirtualPath implements Path {\n+\n         private final String path;\n \n         public VirtualPath(String path) {\n@@ -347,7 +345,7 @@ final class LambdaClassDumper {\n         }\n \n         @Override\n-        public Path toRealPath(LinkOption... options) throws IOException {\n+        public Path toRealPath(LinkOption... options) {\n             throw new IllegalStateException();\n         }\n \n@@ -357,12 +355,12 @@ final class LambdaClassDumper {\n         }\n \n         @Override\n-        public WatchKey register(WatchService watcher, WatchEvent.Kind<?>[] events, WatchEvent.Modifier... modifiers) throws IOException {\n+        public WatchKey register(WatchService watcher, WatchEvent.Kind<?>[] events, WatchEvent.Modifier... modifiers) {\n             throw new IllegalStateException();\n         }\n \n         @Override\n-        public WatchKey register(WatchService watcher, WatchEvent.Kind<?>... events) throws IOException {\n+        public WatchKey register(WatchService watcher, WatchEvent.Kind<?>... events) {\n             throw new IllegalStateException();\n         }\n \n@@ -381,7 +379,7 @@ final class LambdaClassDumper {\n             return path;\n         }\n     }\n-    \n+\n     private final class ClassChannel implements SeekableByteChannel {\n         private final Path path;\n         private final ByteArrayOutputStream os;\n@@ -392,7 +390,7 @@ final class LambdaClassDumper {\n             this.os = new ByteArrayOutputStream();\n             this.ch = Channels.newChannel(os);\n         }\n-        \n+\n         @Override\n         public int read(ByteBuffer dst) throws IOException {\n             throw new IOException();\n@@ -429,12 +427,12 @@ final class LambdaClassDumper {\n         }\n \n         @Override\n-        public void close() throws IOException {\n+        public void close() {\n             String className = path.toString();\n             className = className.substring(0, className.length() - 6);\n             if (LambdaReifier.isLambdaClassToReify(className)) {\n                 reifyLambdaClass(className, os.toByteArray());\n             }\n         }\n-    } // end of ClassCastException\n+    }\n }\n"
    },
    {
        "commit_hash": "34cec6491a0010a678a7add2726b02bd8bb55c6b",
        "previous_commit_hash": "0b08370176bc89726ae3af182a8be43d8d94cf39",
        "diff_stats": {
            "additions": 72,
            "deletions": 61
        },
        "diff_content": "@@ -6,7 +6,7 @@ package net.orfjackal.retrolambda.maven;\n \n import com.google.common.base.Joiner;\n import com.google.common.collect.ImmutableMap;\n-import net.orfjackal.retrolambda.Main;\n+import net.orfjackal.retrolambda.*;\n import org.apache.maven.artifact.Artifact;\n import org.apache.maven.execution.MavenSession;\n import org.apache.maven.plugin.*;\n@@ -67,11 +67,11 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n     public String target;\n \n     /**\n-     * Should we start new process or perform the retrolambdafication in the\n-     * same VM as Maven runs in (which has to be 1.8 then)? If the VM is\n-     * forked, it uses -javaagent argument to intercept class definitions.\n-     * When we run in the same process, we hook into the class generation\n-     * by internal \"lambda dumping\" API.\n+     * Forces Retrolambda to run a separate process. The default is not to fork,\n+     * in which case Maven has to run under Java 8. The forked process uses a\n+     * Java Agent hook for capturing the lambda classes generated by Java 8,\n+     * whereas the non-forked version hooks into internal Java APIs, making it\n+     * more susceptible to breaking between Java releases.\n      */\n     @Parameter(defaultValue = \"false\")\n     public boolean fork;\n@@ -85,43 +85,14 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n     @Override\n     public void execute() throws MojoExecutionException {\n         validateTarget();\n-\n-        if (fork) {\n-            String version = getRetrolambdaVersion();\n-            getLog().info(\"Retrieving Retrolambda \" + version);\n-            retrieveRetrolambdaJar(version);\n-        }\n-\n-        getLog().info(\"Processing classes with Retrolambda\");\n+        validateFork();\n         if (fork) {\n-            processClassesWithAgentHook();\n+            processClassesInForkedProcess();\n         } else {\n-            processClassesWithDumperHook();\n+            processClassesInCurrentProcess();\n         }\n     }\n \n-    String getJavaCommand() {\n-        String javaCommand = getJavaCommand(new File(System.getProperty(\"java.home\")));\n-\n-        Toolchain tc = toolchainManager.getToolchainFromBuildContext(\"jdk\", session);\n-        if (tc != null) {\n-            getLog().info(\"Toolchain in retrolambda-maven-plugin: \" + tc);\n-            javaCommand = tc.findTool(\"java\");\n-        }\n-\n-        if (java8home != null) {\n-            if (tc != null) {\n-                getLog().warn(\"Toolchains are ignored, 'java8home' parameter is set to \" + java8home);\n-            }\n-            javaCommand = getJavaCommand(java8home);\n-        }\n-        return javaCommand;\n-    }\n-\n-    private static String getJavaCommand(File javaHome) {\n-        return new File(javaHome, \"bin/java\").getPath();\n-    }\n-\n     private void validateTarget() throws MojoExecutionException {\n         if (!targetBytecodeVersions.containsKey(target)) {\n             String possibleValues = Joiner.on(\", \").join(new TreeSet<String>(targetBytecodeVersions.keySet()));\n@@ -130,25 +101,33 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n         }\n     }\n \n-    private void retrieveRetrolambdaJar(String version) throws MojoExecutionException {\n-        // TODO: use Maven's built-in artifact resolving, so that we can refer to retrolambda.jar in the local repository without copying it\n-        executeMojo(\n-                plugin(groupId(\"org.apache.maven.plugins\"),\n-                        artifactId(\"maven-dependency-plugin\"),\n-                        version(\"2.8\")),\n-                goal(\"copy\"),\n-                configuration(element(\"artifactItems\",\n-                        element(\"artifactItem\",\n-                                element(name(\"groupId\"), \"net.orfjackal.retrolambda\"),\n-                                element(name(\"artifactId\"), \"retrolambda\"),\n-                                element(name(\"version\"), version),\n-                                element(name(\"overWrite\"), \"true\"),\n-                                element(name(\"outputDirectory\"), getRetrolambdaJarDir()),\n-                                element(name(\"destFileName\"), getRetrolambdaJarName())))),\n-                executionEnvironment(project, session, pluginManager));\n+    private void validateFork() {\n+        if (!fork && !Main.isRunningJava8()) {\n+            getLog().warn(\"Maven is not running under Java 8 - forced to fork the process\");\n+            fork = true;\n+        }\n     }\n \n-    private void processClassesWithAgentHook() throws MojoExecutionException {\n+    private void processClassesInCurrentProcess() throws MojoExecutionException {\n+        getLog().info(\"Processing classes with Retrolambda\");\n+        try {\n+            Properties p = new Properties();\n+            p.setProperty(Config.BYTECODE_VERSION, \"\" + targetBytecodeVersions.get(target));\n+            p.setProperty(Config.INPUT_DIR, getInputDir().getAbsolutePath());\n+            p.setProperty(Config.OUTPUT_DIR, getOutputDir().getAbsolutePath());\n+            p.setProperty(Config.CLASSPATH, getProjectClasspath());\n+            Retrolambda.run(new Config(p));\n+        } catch (Throwable t) {\n+            throw new MojoExecutionException(\"Failed to run Retrolambda\", t);\n+        }\n+    }\n+\n+    private void processClassesInForkedProcess() throws MojoExecutionException {\n+        String version = getRetrolambdaVersion();\n+        getLog().info(\"Retrieving Retrolambda \" + version);\n+        retrieveRetrolambdaJar(version);\n+\n+        getLog().info(\"Processing classes with Retrolambda\");\n         String retrolambdaJar = getRetrolambdaJarPath();\n         executeMojo(\n                 plugin(groupId(\"org.apache.maven.plugins\"),\n@@ -174,12 +153,44 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n                 executionEnvironment(project, session, pluginManager));\n     }\n \n-    private void processClassesWithDumperHook() {\n-        System.setProperty(\"retrolambda.bytecodeVersion\", \"\" + targetBytecodeVersions.get(target));\n-        System.setProperty(\"retrolambda.inputDir\", getInputDir().getAbsolutePath());\n-        System.setProperty(\"retrolambda.outputDir\", getOutputDir().getAbsolutePath());\n-        System.setProperty(\"retrolambda.classpath\", getProjectClasspath());\n-        Main.main(new String[0]);\n+    private void retrieveRetrolambdaJar(String version) throws MojoExecutionException {\n+        // TODO: use Maven's built-in artifact resolving, so that we can refer to retrolambda.jar in the local repository without copying it\n+        executeMojo(\n+                plugin(groupId(\"org.apache.maven.plugins\"),\n+                        artifactId(\"maven-dependency-plugin\"),\n+                        version(\"2.8\")),\n+                goal(\"copy\"),\n+                configuration(element(\"artifactItems\",\n+                        element(\"artifactItem\",\n+                                element(name(\"groupId\"), \"net.orfjackal.retrolambda\"),\n+                                element(name(\"artifactId\"), \"retrolambda\"),\n+                                element(name(\"version\"), version),\n+                                element(name(\"overWrite\"), \"true\"),\n+                                element(name(\"outputDirectory\"), getRetrolambdaJarDir()),\n+                                element(name(\"destFileName\"), getRetrolambdaJarName())))),\n+                executionEnvironment(project, session, pluginManager));\n+    }\n+\n+    String getJavaCommand() {\n+        String javaCommand = getJavaCommand(new File(System.getProperty(\"java.home\")));\n+\n+        Toolchain tc = toolchainManager.getToolchainFromBuildContext(\"jdk\", session);\n+        if (tc != null) {\n+            getLog().info(\"Toolchain in retrolambda-maven-plugin: \" + tc);\n+            javaCommand = tc.findTool(\"java\");\n+        }\n+\n+        if (java8home != null) {\n+            if (tc != null) {\n+                getLog().warn(\"Toolchains are ignored, 'java8home' parameter is set to \" + java8home);\n+            }\n+            javaCommand = getJavaCommand(java8home);\n+        }\n+        return javaCommand;\n+    }\n+\n+    private static String getJavaCommand(File javaHome) {\n+        return new File(javaHome, \"bin/java\").getPath();\n     }\n \n     private String getProjectClasspath() {\n"
    },
    {
        "commit_hash": "34cec6491a0010a678a7add2726b02bd8bb55c6b",
        "previous_commit_hash": "0b08370176bc89726ae3af182a8be43d8d94cf39",
        "diff_stats": {
            "additions": 3,
            "deletions": 61
        },
        "diff_content": "@@ -5,9 +5,7 @@\n package net.orfjackal.retrolambda;\n \n import java.io.*;\n-import java.net.*;\n-import java.nio.file.*;\n-import java.util.*;\n+import java.util.Properties;\n \n public class Main {\n \n@@ -24,41 +22,8 @@ public class Main {\n             System.out.print(config.getHelp());\n             return;\n         }\n-        int bytecodeVersion = config.getBytecodeVersion();\n-        Path inputDir = config.getInputDir();\n-        Path outputDir = config.getOutputDir();\n-        String classpath = config.getClasspath();\n-        List<Path> includedFiles = config.getIncludedFiles();\n-        System.out.println(\"Bytecode version: \" + bytecodeVersion + \" (\" + config.getJavaVersion() + \")\");\n-        System.out.println(\"Input directory:  \" + inputDir);\n-        System.out.println(\"Output directory: \" + outputDir);\n-        System.out.println(\"Classpath:        \" + classpath);\n-        if (includedFiles != null) {\n-            System.out.println(\"Included files:   \" + includedFiles.size());\n-        }\n-\n-        if (!Files.isDirectory(inputDir)) {\n-            System.out.println(\"Nothing to do; not a directory: \" + inputDir);\n-            return;\n-        }\n-\n         try {\n-            Thread.currentThread().setContextClassLoader(new URLClassLoader(asUrls(classpath)));\n-\n-            visitFiles(inputDir, includedFiles, new BytecodeTransformingFileVisitor(inputDir, outputDir) {\n-                @Override\n-                protected byte[] transform(byte[] bytecode) {\n-                    if (PreMain.isAgentLoaded()) {\n-                        return LambdaUsageBackporter.transform(bytecode, bytecodeVersion);\n-                    } else {\n-                        final LambdaClassDumper trans = new LambdaClassDumper(outputDir, bytecodeVersion);\n-                        trans.registerDumper();\n-                        byte[] ret = LambdaUsageBackporter.transform(bytecode, bytecodeVersion);\n-                        trans.unregisterDumper();\n-                        return ret;\n-                    }\n-                }\n-            });\n+            Retrolambda.run(config);\n         } catch (Throwable t) {\n             System.out.println(\"Error! Failed to transform some classes\");\n             t.printStackTrace(System.out);\n@@ -66,7 +31,7 @@ public class Main {\n         }\n     }\n \n-    private static boolean isRunningJava8() {\n+    public static boolean isRunningJava8() {\n         try {\n             Class.forName(\"java.util.stream.Stream\");\n             return true;\n@@ -75,29 +40,6 @@ public class Main {\n         }\n     }\n \n-    static void visitFiles(Path inputDir, List<Path> includedFiles, FileVisitor<Path> visitor) throws IOException {\n-        if (includedFiles != null) {\n-            visitor = new FilteringFileVisitor(includedFiles, visitor);\n-        }\n-        Files.walkFileTree(inputDir, visitor);\n-    }\n-\n-    private static URL[] asUrls(String classpath) {\n-        String[] paths = classpath.split(System.getProperty(\"path.separator\"));\n-        return Arrays.asList(paths).stream()\n-                .map(s -> Paths.get(s).toUri())\n-                .map(Main::uriToUrl)\n-                .toArray(URL[]::new);\n-    }\n-\n-    private static URL uriToUrl(URI uri) {\n-        try {\n-            return uri.toURL();\n-        } catch (MalformedURLException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n     private static String getVersion() {\n         Properties p = new Properties();\n         try (InputStream in = Main.class.getResourceAsStream(\"/META-INF/maven/net.orfjackal.retrolambda/retrolambda/pom.properties\")) {\n"
    },
    {
        "commit_hash": "34cec6491a0010a678a7add2726b02bd8bb55c6b",
        "previous_commit_hash": "0b08370176bc89726ae3af182a8be43d8d94cf39",
        "diff_stats": {
            "additions": 73,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,73 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda;\n+\n+import java.io.IOException;\n+import java.net.*;\n+import java.nio.file.*;\n+import java.util.*;\n+\n+public class Retrolambda {\n+\n+    public static void run(Config config) throws Throwable {\n+        int bytecodeVersion = config.getBytecodeVersion();\n+        Path inputDir = config.getInputDir();\n+        Path outputDir = config.getOutputDir();\n+        String classpath = config.getClasspath();\n+        List<Path> includedFiles = config.getIncludedFiles();\n+        System.out.println(\"Bytecode version: \" + bytecodeVersion + \" (\" + config.getJavaVersion() + \")\");\n+        System.out.println(\"Input directory:  \" + inputDir);\n+        System.out.println(\"Output directory: \" + outputDir);\n+        System.out.println(\"Classpath:        \" + classpath);\n+        if (includedFiles != null) {\n+            System.out.println(\"Included files:   \" + includedFiles.size());\n+        }\n+\n+        if (!Files.isDirectory(inputDir)) {\n+            System.out.println(\"Nothing to do; not a directory: \" + inputDir);\n+            return;\n+        }\n+\n+        Thread.currentThread().setContextClassLoader(new URLClassLoader(asUrls(classpath)));\n+\n+        visitFiles(inputDir, includedFiles, new BytecodeTransformingFileVisitor(inputDir, outputDir) {\n+            @Override\n+            protected byte[] transform(byte[] bytecode) {\n+                if (PreMain.isAgentLoaded()) {\n+                    return LambdaUsageBackporter.transform(bytecode, bytecodeVersion);\n+                } else {\n+                    LambdaClassDumper dumper = new LambdaClassDumper(outputDir, bytecodeVersion);\n+                    dumper.registerDumper();\n+                    byte[] ret = LambdaUsageBackporter.transform(bytecode, bytecodeVersion);\n+                    dumper.unregisterDumper();\n+                    return ret;\n+                }\n+            }\n+        });\n+    }\n+\n+    static void visitFiles(Path inputDir, List<Path> includedFiles, FileVisitor<Path> visitor) throws IOException {\n+        if (includedFiles != null) {\n+            visitor = new FilteringFileVisitor(includedFiles, visitor);\n+        }\n+        Files.walkFileTree(inputDir, visitor);\n+    }\n+\n+    private static URL[] asUrls(String classpath) {\n+        String[] paths = classpath.split(System.getProperty(\"path.separator\"));\n+        return Arrays.asList(paths).stream()\n+                .map(s -> Paths.get(s).toUri())\n+                .map(Retrolambda::uriToUrl)\n+                .toArray(URL[]::new);\n+    }\n+\n+    private static URL uriToUrl(URI uri) {\n+        try {\n+            return uri.toURL();\n+        } catch (MalformedURLException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+}\n"
    },
    {
        "commit_hash": "34cec6491a0010a678a7add2726b02bd8bb55c6b",
        "previous_commit_hash": "0b08370176bc89726ae3af182a8be43d8d94cf39",
        "diff_stats": {
            "additions": 4,
            "deletions": 4
        },
        "diff_content": "@@ -15,7 +15,7 @@ import java.util.*;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.containsInAnyOrder;\n \n-public class MainTest {\n+public class RetrolambdaTest {\n \n     @Rule\n     public final TemporaryFolder tempDir = new TemporaryFolder();\n@@ -48,7 +48,7 @@ public class MainTest {\n \n     @Test\n     public void by_default_visits_all_files_recursively() throws IOException {\n-        Main.visitFiles(inputDir, null, visitor);\n+        Retrolambda.visitFiles(inputDir, null, visitor);\n \n         assertThat(visitedFiles, containsInAnyOrder(file1, file2, fileInSubdir));\n     }\n@@ -57,7 +57,7 @@ public class MainTest {\n     public void when_included_files_is_set_then_visits_only_those_files() throws IOException {\n         List<Path> includedFiles = Arrays.asList(file1, fileInSubdir);\n \n-        Main.visitFiles(inputDir, includedFiles, visitor);\n+        Retrolambda.visitFiles(inputDir, includedFiles, visitor);\n \n         assertThat(visitedFiles, containsInAnyOrder(file1, fileInSubdir));\n     }\n@@ -66,7 +66,7 @@ public class MainTest {\n     public void ignores_included_files_that_are_outside_the_input_directory() throws IOException {\n         List<Path> includedFiles = Arrays.asList(file1, outsider);\n \n-        Main.visitFiles(inputDir, includedFiles, visitor);\n+        Retrolambda.visitFiles(inputDir, includedFiles, visitor);\n \n         assertThat(visitedFiles, containsInAnyOrder(file1));\n     }\n"
    },
    {
        "commit_hash": "34cec6491a0010a678a7add2726b02bd8bb55c6b",
        "previous_commit_hash": "0b08370176bc89726ae3af182a8be43d8d94cf39",
        "diff_stats": {
            "additions": 11,
            "deletions": 0
        },
        "diff_content": "@@ -6,10 +6,21 @@ set -x\n \n rm -rfv staging\n \n+# Test that also the forking mechanism works\n+\n mvn clean verify \\\n     --errors \\\n     -P fork\n \n+# The Maven plugin's minimum requirement is Java 6,\n+# but then the plugin must force forking the process\n+\n+JAVA_HOME=\"$JAVA6_HOME\" mvn clean verify \\\n+    --errors \\\n+    -P java6\n+\n+# Run end-to-end tests against all supported Java versions\n+\n mvn clean verify \\\n     --errors \\\n     -P java6\n"
    },
    {
        "commit_hash": "e006249663697725e51fe06afe9d18b73344a1bb",
        "previous_commit_hash": "34cec6491a0010a678a7add2726b02bd8bb55c6b",
        "diff_stats": {
            "additions": 13,
            "deletions": 1
        },
        "diff_content": "@@ -37,7 +37,7 @@ on Java 7, in case the code accidentally uses Java 8 APIs or language features\n that Retrolambda doesn't backport.\n \n ```\n-Usage: java -Dretrolambda.inputDir=? -Dretrolambda.classpath=? -javaagent:retrolambda.jar -jar retrolambda.jar\n+Usage: java -Dretrolambda.inputDir=? -Dretrolambda.classpath=? [-javaagent:retrolambda.jar] -jar retrolambda.jar\n \n Retrolambda is a backporting tool for classes which use lambda expressions\n and have been compiled with Java 8, to run on Java 7 (maybe even Java 5).\n@@ -70,6 +70,10 @@ Optional system properties:\n       List of files to process, instead of processing all files.\n       This is useful for a build tool to support incremental compilation.\n \n+If the Java agent is used, then Retrolambda will use it to capture the\n+lambda classes generated by Java. Otherwise Retrolambda will hook into\n+Java's internal lambda dumping API, which is more susceptible to suddenly\n+stopping to work between Java releases.\n ```\n \n \n@@ -145,6 +149,14 @@ package-private.\n Version History\n ---------------\n \n+### Upcoming\n+\n+- Does not anymore require the use of a Java agent\n+  ([Issue #27](https://github.com/orfjackal/retrolambda/issues/27))\n+- Maven plugin: by default run Retrolambda in the same process as Maven,\n+  making it a bit faster. If Maven is not running under Java 8, then will\n+  fall back to forking the process and using the Java agent mechanism\n+\n ### Retrolambda 1.5.0 (2014-07-19)\n \n - Maven plugin: use the [JDK from Maven Toolchains](http://maven.apache.org/plugins/maven-toolchains-plugin/toolchains/jdk.html)\n"
    },
    {
        "commit_hash": "e006249663697725e51fe06afe9d18b73344a1bb",
        "previous_commit_hash": "34cec6491a0010a678a7add2726b02bd8bb55c6b",
        "diff_stats": {
            "additions": 7,
            "deletions": 2
        },
        "diff_content": "@@ -148,7 +148,7 @@ public class Config {\n                 .map(key -> \"-D\" + key + \"=?\")\n                 .reduce((a, b) -> a + \" \" + b)\n                 .get();\n-        return \"Usage: java \" + options + \" -javaagent:retrolambda.jar -jar retrolambda.jar\\n\" +\n+        return \"Usage: java \" + options + \" [-javaagent:retrolambda.jar] -jar retrolambda.jar\\n\" +\n                 \"\\n\" +\n                 \"Retrolambda is a backporting tool for classes which use lambda expressions\\n\" +\n                 \"and have been compiled with Java 8, to run on Java 7 (maybe even Java 5).\\n\" +\n@@ -164,7 +164,12 @@ public class Config {\n                 \"\\n\" +\n                 \"Optional system properties:\\n\" +\n                 \"\\n\" +\n-                optionalPropertiesHelp.stream().reduce((a, b) -> a + \"\\n\" + b).get();\n+                optionalPropertiesHelp.stream().reduce((a, b) -> a + \"\\n\" + b).get() +\n+                \"\\n\" +\n+                \"If the Java agent is used, then Retrolambda will use it to capture the\\n\" +\n+                \"lambda classes generated by Java. Otherwise Retrolambda will hook into\\n\" +\n+                \"Java's internal lambda dumping API, which is more susceptible to suddenly\\n\" +\n+                \"stopping to work between Java releases.\\n\";\n     }\n \n     private static void requiredParameterHelp(String key, String... lines) {\n"
    },
    {
        "commit_hash": "a22bb5a39d3ed7020b7820a1893fff84b138f33a",
        "previous_commit_hash": "e006249663697725e51fe06afe9d18b73344a1bb",
        "diff_stats": {
            "additions": 8,
            "deletions": 3
        },
        "diff_content": "@@ -15,7 +15,7 @@ import java.nio.file.attribute.*;\n import java.nio.file.spi.FileSystemProvider;\n import java.util.*;\n \n-public class LambdaClassDumper {\n+public class LambdaClassDumper implements AutoCloseable {\n \n     private final Path outputDir;\n     private final int targetVersion;\n@@ -26,7 +26,7 @@ public class LambdaClassDumper {\n         this.targetVersion = targetVersion;\n     }\n \n-    public void registerDumper() {\n+    public void install() {\n         try {\n             Class<?> mf = Class.forName(\"java.lang.invoke.InnerClassLambdaMetafactory\");\n             dumperField = mf.getDeclaredField(\"dumper\");\n@@ -40,7 +40,7 @@ public class LambdaClassDumper {\n         }\n     }\n \n-    public void unregisterDumper() {\n+    public void uninstall() {\n         if (dumperField != null) {\n             try {\n                 dumperField.set(null, null);\n@@ -50,6 +50,11 @@ public class LambdaClassDumper {\n         }\n     }\n \n+    @Override\n+    public void close() {\n+        uninstall();\n+    }\n+\n     private static void makeNonFinal(Field field) throws Exception {\n         Field modifiers = field.getClass().getDeclaredField(\"modifiers\");\n         modifiers.setAccessible(true);\n"
    },
    {
        "commit_hash": "a22bb5a39d3ed7020b7820a1893fff84b138f33a",
        "previous_commit_hash": "e006249663697725e51fe06afe9d18b73344a1bb",
        "diff_stats": {
            "additions": 9,
            "deletions": 12
        },
        "diff_content": "@@ -32,20 +32,17 @@ public class Retrolambda {\n \n         Thread.currentThread().setContextClassLoader(new URLClassLoader(asUrls(classpath)));\n \n-        visitFiles(inputDir, includedFiles, new BytecodeTransformingFileVisitor(inputDir, outputDir) {\n-            @Override\n-            protected byte[] transform(byte[] bytecode) {\n-                if (PreMain.isAgentLoaded()) {\n+        try (LambdaClassDumper dumper = new LambdaClassDumper(outputDir, bytecodeVersion)) {\n+            if (!PreMain.isAgentLoaded()) {\n+                dumper.install();\n+            }\n+            visitFiles(inputDir, includedFiles, new BytecodeTransformingFileVisitor(inputDir, outputDir) {\n+                @Override\n+                protected byte[] transform(byte[] bytecode) {\n                     return LambdaUsageBackporter.transform(bytecode, bytecodeVersion);\n-                } else {\n-                    LambdaClassDumper dumper = new LambdaClassDumper(outputDir, bytecodeVersion);\n-                    dumper.registerDumper();\n-                    byte[] ret = LambdaUsageBackporter.transform(bytecode, bytecodeVersion);\n-                    dumper.unregisterDumper();\n-                    return ret;\n                 }\n-            }\n-        });\n+            });\n+        }\n     }\n \n     static void visitFiles(Path inputDir, List<Path> includedFiles, FileVisitor<Path> visitor) throws IOException {\n"
    },
    {
        "commit_hash": "53dea8d7bbc6658b575bd51a15a909522e5716f0",
        "previous_commit_hash": "a22bb5a39d3ed7020b7820a1893fff84b138f33a",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -21,7 +21,7 @@ public class Config {\n     public static final String INCLUDED_FILES = PREFIX + \"includedFiles\";\n \n     private static final List<String> requiredProperties = new ArrayList<>();\n-    private static final List<String> requiredProperitesHelp = new ArrayList<>();\n+    private static final List<String> requiredPropertiesHelp = new ArrayList<>();\n     private static final List<String> optionalPropertiesHelp = new ArrayList<>();\n     private static final Map<Integer, String> bytecodeVersionNames = new HashMap<>();\n \n@@ -160,7 +160,7 @@ public class Config {\n                 \"\\n\" +\n                 \"Required system properties:\\n\" +\n                 \"\\n\" +\n-                requiredProperitesHelp.stream().reduce((a, b) -> a + \"\\n\" + b).get() +\n+                requiredPropertiesHelp.stream().reduce((a, b) -> a + \"\\n\" + b).get() +\n                 \"\\n\" +\n                 \"Optional system properties:\\n\" +\n                 \"\\n\" +\n@@ -174,7 +174,7 @@ public class Config {\n \n     private static void requiredParameterHelp(String key, String... lines) {\n         requiredProperties.add(key);\n-        requiredProperitesHelp.add(formatPropertyHelp(key, lines));\n+        requiredPropertiesHelp.add(formatPropertyHelp(key, lines));\n     }\n \n     private static void optionalParameterHelp(String key, String... lines) {\n"
    },
    {
        "commit_hash": "65c3be5347312cde046517520afcec5032f1feff",
        "previous_commit_hash": "53dea8d7bbc6658b575bd51a15a909522e5716f0",
        "diff_stats": {
            "additions": 13,
            "deletions": 290
        },
        "diff_content": "@@ -4,16 +4,17 @@\n \n package net.orfjackal.retrolambda;\n \n+import net.orfjackal.retrolambda.fs.*;\n+\n import java.io.*;\n import java.lang.reflect.*;\n-import java.net.URI;\n import java.nio.ByteBuffer;\n import java.nio.channels.*;\n-import java.nio.file.*;\n import java.nio.file.FileSystem;\n-import java.nio.file.attribute.*;\n+import java.nio.file.*;\n+import java.nio.file.attribute.FileAttribute;\n import java.nio.file.spi.FileSystemProvider;\n-import java.util.*;\n+import java.util.Set;\n \n public class LambdaClassDumper implements AutoCloseable {\n \n@@ -85,162 +86,27 @@ public class LambdaClassDumper implements AutoCloseable {\n     }\n \n \n-    private final class VirtualProvider extends FileSystemProvider {\n-\n-        @Override\n-        public String getScheme() {\n-            throw new IllegalStateException();\n-        }\n-\n-        @Override\n-        public FileSystem newFileSystem(URI uri, Map<String, ?> env) {\n-            throw new IllegalStateException();\n-        }\n-\n-        @Override\n-        public FileSystem getFileSystem(URI uri) {\n-            throw new IllegalStateException();\n-        }\n-\n-        @Override\n-        public Path getPath(URI uri) {\n-            throw new IllegalStateException();\n-        }\n+    private final class VirtualFSProvider extends FakeFileSystemProvider {\n \n         @Override\n         public SeekableByteChannel newByteChannel(Path path, Set<? extends OpenOption> options, FileAttribute<?>... attrs) {\n             return new ClassChannel(path);\n         }\n \n-        @Override\n-        public DirectoryStream<Path> newDirectoryStream(Path dir, DirectoryStream.Filter<? super Path> filter) {\n-            throw new IllegalStateException();\n-        }\n-\n         @Override\n         public void createDirectory(Path dir, FileAttribute<?>... attrs) {\n         }\n-\n-        @Override\n-        public void delete(Path path) {\n-            throw new IllegalStateException();\n-        }\n-\n-        @Override\n-        public void copy(Path source, Path target, CopyOption... options) {\n-            throw new IllegalStateException();\n-        }\n-\n-        @Override\n-        public void move(Path source, Path target, CopyOption... options) {\n-            throw new IllegalStateException();\n-        }\n-\n-        @Override\n-        public boolean isSameFile(Path path, Path path2) {\n-            throw new IllegalStateException();\n-        }\n-\n-        @Override\n-        public boolean isHidden(Path path) {\n-            throw new IllegalStateException();\n-        }\n-\n-        @Override\n-        public FileStore getFileStore(Path path) {\n-            throw new IllegalStateException();\n-        }\n-\n-        @Override\n-        public void checkAccess(Path path, AccessMode... modes) {\n-            throw new IllegalStateException();\n-        }\n-\n-        @Override\n-        public <V extends FileAttributeView> V getFileAttributeView(Path path, Class<V> type, LinkOption... options) {\n-            throw new IllegalStateException();\n-        }\n-\n-        @Override\n-        public <A extends BasicFileAttributes> A readAttributes(Path path, Class<A> type, LinkOption... options) {\n-            throw new IllegalStateException();\n-        }\n-\n-        @Override\n-        public Map<String, Object> readAttributes(Path path, String attributes, LinkOption... options) {\n-            throw new IllegalStateException();\n-        }\n-\n-        @Override\n-        public void setAttribute(Path path, String attribute, Object value, LinkOption... options) {\n-            throw new IllegalStateException();\n-        }\n     }\n \n-    private final class VirtualFS extends FileSystem {\n+    private final class VirtualFS extends FakeFileSystem {\n \n         @Override\n         public FileSystemProvider provider() {\n-            return new VirtualProvider();\n-        }\n-\n-        @Override\n-        public void close() {\n-            throw new IllegalStateException();\n-        }\n-\n-        @Override\n-        public boolean isOpen() {\n-            throw new IllegalStateException();\n-        }\n-\n-        @Override\n-        public boolean isReadOnly() {\n-            throw new IllegalStateException();\n-        }\n-\n-        @Override\n-        public String getSeparator() {\n-            throw new IllegalStateException();\n-        }\n-\n-        @Override\n-        public Iterable<Path> getRootDirectories() {\n-            throw new IllegalStateException();\n-        }\n-\n-        @Override\n-        public Iterable<FileStore> getFileStores() {\n-            throw new IllegalStateException();\n-        }\n-\n-        @Override\n-        public Set<String> supportedFileAttributeViews() {\n-            throw new IllegalStateException();\n-        }\n-\n-        @Override\n-        public Path getPath(String first, String... more) {\n-            throw new IllegalStateException();\n-        }\n-\n-        @Override\n-        public PathMatcher getPathMatcher(String syntaxAndPattern) {\n-            throw new IllegalStateException();\n-        }\n-\n-        @Override\n-        public UserPrincipalLookupService getUserPrincipalLookupService() {\n-            throw new IllegalStateException();\n-        }\n-\n-        @Override\n-        public WatchService newWatchService() {\n-            throw new IllegalStateException();\n+            return new VirtualFSProvider();\n         }\n     }\n \n-    private final class VirtualPath implements Path {\n+    private final class VirtualPath extends FakePath {\n \n         private final String path;\n \n@@ -253,139 +119,26 @@ public class LambdaClassDumper implements AutoCloseable {\n             return new VirtualFS();\n         }\n \n-        @Override\n-        public boolean isAbsolute() {\n-            throw new IllegalStateException();\n-        }\n-\n-        @Override\n-        public Path getRoot() {\n-            throw new IllegalStateException();\n-        }\n-\n-        @Override\n-        public Path getFileName() {\n-            throw new IllegalStateException();\n-        }\n-\n         @Override\n         public Path getParent() {\n             return this;\n         }\n \n-        @Override\n-        public int getNameCount() {\n-            throw new IllegalStateException();\n-        }\n-\n-        @Override\n-        public Path getName(int index) {\n-            throw new IllegalStateException();\n-        }\n-\n-        @Override\n-        public Path subpath(int beginIndex, int endIndex) {\n-            throw new IllegalStateException();\n-        }\n-\n-        @Override\n-        public boolean startsWith(Path other) {\n-            throw new IllegalStateException();\n-        }\n-\n-        @Override\n-        public boolean startsWith(String other) {\n-            throw new IllegalStateException();\n-        }\n-\n-        @Override\n-        public boolean endsWith(Path other) {\n-            throw new IllegalStateException();\n-        }\n-\n-        @Override\n-        public boolean endsWith(String other) {\n-            throw new IllegalStateException();\n-        }\n-\n-        @Override\n-        public Path normalize() {\n-            throw new IllegalStateException();\n-        }\n-\n-        @Override\n-        public Path resolve(Path other) {\n-            throw new IllegalStateException();\n-        }\n-\n         @Override\n         public Path resolve(String other) {\n-            assert path.isEmpty();\n+            if (!path.isEmpty()) {\n+                throw new IllegalStateException();\n+            }\n             return new VirtualPath(other);\n         }\n \n-        @Override\n-        public Path resolveSibling(Path other) {\n-            throw new IllegalStateException();\n-        }\n-\n-        @Override\n-        public Path resolveSibling(String other) {\n-            throw new IllegalStateException();\n-        }\n-\n-        @Override\n-        public Path relativize(Path other) {\n-            throw new IllegalStateException();\n-        }\n-\n-        @Override\n-        public URI toUri() {\n-            throw new IllegalStateException();\n-        }\n-\n-        @Override\n-        public Path toAbsolutePath() {\n-            throw new IllegalStateException();\n-        }\n-\n-        @Override\n-        public Path toRealPath(LinkOption... options) {\n-            throw new IllegalStateException();\n-        }\n-\n-        @Override\n-        public File toFile() {\n-            throw new IllegalStateException();\n-        }\n-\n-        @Override\n-        public WatchKey register(WatchService watcher, WatchEvent.Kind<?>[] events, WatchEvent.Modifier... modifiers) {\n-            throw new IllegalStateException();\n-        }\n-\n-        @Override\n-        public WatchKey register(WatchService watcher, WatchEvent.Kind<?>... events) {\n-            throw new IllegalStateException();\n-        }\n-\n-        @Override\n-        public Iterator<Path> iterator() {\n-            throw new IllegalStateException();\n-        }\n-\n-        @Override\n-        public int compareTo(Path other) {\n-            throw new IllegalStateException();\n-        }\n-\n         @Override\n         public String toString() {\n             return path;\n         }\n     }\n \n-    private final class ClassChannel implements SeekableByteChannel {\n+    private final class ClassChannel extends FakeSeekableByteChannel {\n         private final Path path;\n         private final ByteArrayOutputStream os;\n         private final WritableByteChannel ch;\n@@ -396,41 +149,11 @@ public class LambdaClassDumper implements AutoCloseable {\n             this.ch = Channels.newChannel(os);\n         }\n \n-        @Override\n-        public int read(ByteBuffer dst) throws IOException {\n-            throw new IOException();\n-        }\n-\n         @Override\n         public int write(ByteBuffer src) throws IOException {\n             return ch.write(src);\n         }\n \n-        @Override\n-        public long position() throws IOException {\n-            throw new IOException();\n-        }\n-\n-        @Override\n-        public SeekableByteChannel position(long newPosition) throws IOException {\n-            throw new IOException();\n-        }\n-\n-        @Override\n-        public long size() throws IOException {\n-            throw new IOException();\n-        }\n-\n-        @Override\n-        public SeekableByteChannel truncate(long size) throws IOException {\n-            throw new IOException();\n-        }\n-\n-        @Override\n-        public boolean isOpen() {\n-            return true;\n-        }\n-\n         @Override\n         public void close() {\n             String className = path.toString();\n"
    },
    {
        "commit_hash": "65c3be5347312cde046517520afcec5032f1feff",
        "previous_commit_hash": "53dea8d7bbc6658b575bd51a15a909522e5716f0",
        "diff_stats": {
            "additions": 74,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,74 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.fs;\n+\n+import java.io.IOException;\n+import java.nio.file.*;\n+import java.nio.file.attribute.UserPrincipalLookupService;\n+import java.nio.file.spi.FileSystemProvider;\n+import java.util.Set;\n+\n+public class FakeFileSystem extends FileSystem {\n+\n+    @Override\n+    public FileSystemProvider provider() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean isOpen() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean isReadOnly() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public String getSeparator() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Iterable<Path> getRootDirectories() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Iterable<FileStore> getFileStores() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Set<String> supportedFileAttributeViews() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Path getPath(String first, String... more) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public PathMatcher getPathMatcher(String syntaxAndPattern) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public UserPrincipalLookupService getUserPrincipalLookupService() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public WatchService newWatchService() throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+}\n"
    },
    {
        "commit_hash": "65c3be5347312cde046517520afcec5032f1feff",
        "previous_commit_hash": "53dea8d7bbc6658b575bd51a15a909522e5716f0",
        "diff_stats": {
            "additions": 106,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,106 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.fs;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.channels.SeekableByteChannel;\n+import java.nio.file.*;\n+import java.nio.file.attribute.*;\n+import java.nio.file.spi.FileSystemProvider;\n+import java.util.*;\n+\n+public class FakeFileSystemProvider extends FileSystemProvider {\n+\n+    @Override\n+    public String getScheme() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public FileSystem newFileSystem(URI uri, Map<String, ?> env) throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public FileSystem getFileSystem(URI uri) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Path getPath(URI uri) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public SeekableByteChannel newByteChannel(Path path, Set<? extends OpenOption> options, FileAttribute<?>... attrs) throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public DirectoryStream<Path> newDirectoryStream(Path dir, DirectoryStream.Filter<? super Path> filter) throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void createDirectory(Path dir, FileAttribute<?>... attrs) throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void delete(Path path) throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void copy(Path source, Path target, CopyOption... options) throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void move(Path source, Path target, CopyOption... options) throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean isSameFile(Path path, Path path2) throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean isHidden(Path path) throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public FileStore getFileStore(Path path) throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void checkAccess(Path path, AccessMode... modes) throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public <V extends FileAttributeView> V getFileAttributeView(Path path, Class<V> type, LinkOption... options) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public <A extends BasicFileAttributes> A readAttributes(Path path, Class<A> type, LinkOption... options) throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Map<String, Object> readAttributes(Path path, String attributes, LinkOption... options) throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void setAttribute(Path path, String attribute, Object value, LinkOption... options) throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+}\n"
    },
    {
        "commit_hash": "65c3be5347312cde046517520afcec5032f1feff",
        "previous_commit_hash": "53dea8d7bbc6658b575bd51a15a909522e5716f0",
        "diff_stats": {
            "additions": 144,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,144 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.fs;\n+\n+import java.io.*;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.*;\n+import java.util.Iterator;\n+\n+public class FakePath implements Path {\n+\n+    @Override\n+    public FileSystem getFileSystem() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean isAbsolute() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Path getRoot() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Path getFileName() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Path getParent() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public int getNameCount() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Path getName(int index) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Path subpath(int beginIndex, int endIndex) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean startsWith(Path other) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean startsWith(String other) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean endsWith(Path other) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean endsWith(String other) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Path normalize() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Path resolve(Path other) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Path resolve(String other) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Path resolveSibling(Path other) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Path resolveSibling(String other) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Path relativize(Path other) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public URI toUri() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Path toAbsolutePath() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Path toRealPath(LinkOption... options) throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public File toFile() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public WatchKey register(WatchService watcher, WatchEvent.Kind<?>[] events, WatchEvent.Modifier... modifiers) throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public WatchKey register(WatchService watcher, WatchEvent.Kind<?>... events) throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Iterator<Path> iterator() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public int compareTo(Path other) {\n+        throw new UnsupportedOperationException();\n+    }\n+}\n"
    },
    {
        "commit_hash": "65c3be5347312cde046517520afcec5032f1feff",
        "previous_commit_hash": "53dea8d7bbc6658b575bd51a15a909522e5716f0",
        "diff_stats": {
            "additions": 52,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,52 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.fs;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.SeekableByteChannel;\n+\n+public class FakeSeekableByteChannel implements SeekableByteChannel {\n+\n+    @Override\n+    public int read(ByteBuffer dst) throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public int write(ByteBuffer src) throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public long position() throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public SeekableByteChannel position(long newPosition) throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public long size() throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public SeekableByteChannel truncate(long size) throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean isOpen() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+}\n"
    },
    {
        "commit_hash": "62199098ce9afbeb693c582c532af27adac78928",
        "previous_commit_hash": "65c3be5347312cde046517520afcec5032f1feff",
        "diff_stats": {
            "additions": 11,
            "deletions": 1
        },
        "diff_content": "@@ -2,7 +2,17 @@\n   <configuration default=\"false\" name=\"End-to-end tests (Java 6)\" type=\"MavenRunConfiguration\" factoryName=\"Maven\">\n     <MavenSettings>\n       <option name=\"myGeneralSettings\" />\n-      <option name=\"myRunnerSettings\" />\n+      <option name=\"myRunnerSettings\">\n+        <MavenRunnerSettings>\n+          <option name=\"jreName\" value=\"1.6\" />\n+          <option name=\"mavenProperties\">\n+            <map />\n+          </option>\n+          <option name=\"runMavenInBackground\" value=\"true\" />\n+          <option name=\"skipTests\" value=\"false\" />\n+          <option name=\"vmOptions\" value=\"\" />\n+        </MavenRunnerSettings>\n+      </option>\n       <option name=\"myRunnerParameters\">\n         <MavenRunnerParameters>\n           <option name=\"profiles\">\n"
    },
    {
        "commit_hash": "03ab4b0d53b5f2e74bd7443b7e0b1389745ec804",
        "previous_commit_hash": "62199098ce9afbeb693c582c532af27adac78928",
        "diff_stats": {
            "additions": 5,
            "deletions": 24
        },
        "diff_content": "@@ -18,13 +18,11 @@ import java.util.Set;\n \n public class LambdaClassDumper implements AutoCloseable {\n \n-    private final Path outputDir;\n-    private final int targetVersion;\n+    private final LambdaClassSaver lambdaClassSaver;\n     private Field dumperField;\n \n-    public LambdaClassDumper(Path outputDir, int targetVersion) {\n-        this.outputDir = outputDir;\n-        this.targetVersion = targetVersion;\n+    public LambdaClassDumper(LambdaClassSaver lambdaClassSaver) {\n+        this.lambdaClassSaver = lambdaClassSaver;\n     }\n \n     public void install() {\n@@ -70,21 +68,6 @@ public class LambdaClassDumper implements AutoCloseable {\n         return c.newInstance(dumpDir);\n     }\n \n-    private void reifyLambdaClass(String className, byte[] classfileBuffer) {\n-        try {\n-            System.out.println(\"Saving lambda class: \" + className);\n-            byte[] backportedBytecode = LambdaClassBackporter.transform(classfileBuffer, targetVersion);\n-            Path savePath = outputDir.resolve(className + \".class\");\n-            Files.createDirectories(savePath.getParent());\n-            Files.write(savePath, backportedBytecode);\n-\n-        } catch (Throwable t) {\n-            // print to stdout to keep in sync with other log output\n-            System.out.println(\"ERROR: Failed to backport lambda class: \" + className);\n-            t.printStackTrace(System.out);\n-        }\n-    }\n-\n \n     private final class VirtualFSProvider extends FakeFileSystemProvider {\n \n@@ -157,10 +140,8 @@ public class LambdaClassDumper implements AutoCloseable {\n         @Override\n         public void close() {\n             String className = path.toString();\n-            className = className.substring(0, className.length() - 6);\n-            if (LambdaReifier.isLambdaClassToReify(className)) {\n-                reifyLambdaClass(className, os.toByteArray());\n-            }\n+            className = className.substring(0, className.lastIndexOf(\".class\"));\n+            lambdaClassSaver.saveIfLambda(className, os.toByteArray());\n         }\n     }\n }\n"
    },
    {
        "commit_hash": "03ab4b0d53b5f2e74bd7443b7e0b1389745ec804",
        "previous_commit_hash": "62199098ce9afbeb693c582c532af27adac78928",
        "diff_stats": {
            "additions": 39,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,39 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda;\n+\n+import java.nio.file.*;\n+\n+public class LambdaClassSaver {\n+\n+    private final Path outputDir;\n+    private final int bytecodeVersion;\n+\n+    public LambdaClassSaver(Path outputDir, int bytecodeVersion) {\n+        this.outputDir = outputDir;\n+        this.bytecodeVersion = bytecodeVersion;\n+    }\n+\n+    public void saveIfLambda(String className, byte[] bytecode) {\n+        if (LambdaReifier.isLambdaClassToReify(className)) {\n+            reifyLambdaClass(className, bytecode);\n+        }\n+    }\n+\n+    private void reifyLambdaClass(String className, byte[] originalBytecode) {\n+        try {\n+            System.out.println(\"Saving lambda class: \" + className);\n+            byte[] backportedBytecode = LambdaClassBackporter.transform(originalBytecode, bytecodeVersion);\n+            Path savePath = outputDir.resolve(className + \".class\");\n+            Files.createDirectories(savePath.getParent());\n+            Files.write(savePath, backportedBytecode);\n+\n+        } catch (Throwable t) {\n+            // print to stdout to keep in sync with other log output\n+            System.out.println(\"ERROR: Failed to backport lambda class: \" + className);\n+            t.printStackTrace(System.out);\n+        }\n+    }\n+}\n"
    },
    {
        "commit_hash": "03ab4b0d53b5f2e74bd7443b7e0b1389745ec804",
        "previous_commit_hash": "62199098ce9afbeb693c582c532af27adac78928",
        "diff_stats": {
            "additions": 4,
            "deletions": 24
        },
        "diff_content": "@@ -7,17 +7,14 @@ package net.orfjackal.retrolambda;\n import org.objectweb.asm.ClassReader;\n \n import java.lang.instrument.*;\n-import java.nio.file.*;\n import java.security.ProtectionDomain;\n \n public class LambdaSavingClassFileTransformer implements ClassFileTransformer {\n \n-    private final Path outputDir;\n-    private final int targetVersion;\n+    private final LambdaClassSaver lambdaClassSaver;\n \n-    public LambdaSavingClassFileTransformer(Path outputDir, int targetVersion) {\n-        this.outputDir = outputDir;\n-        this.targetVersion = targetVersion;\n+    public LambdaSavingClassFileTransformer(LambdaClassSaver lambdaClassSaver) {\n+        this.lambdaClassSaver = lambdaClassSaver;\n     }\n \n     @Override\n@@ -27,24 +24,7 @@ public class LambdaSavingClassFileTransformer implements ClassFileTransformer {\n             // but we can read it from the bytecode where the name still exists.\n             className = new ClassReader(classfileBuffer).getClassName();\n         }\n-        if (LambdaReifier.isLambdaClassToReify(className)) {\n-            reifyLambdaClass(className, classfileBuffer);\n-        }\n+        lambdaClassSaver.saveIfLambda(className, classfileBuffer);\n         return null;\n     }\n-\n-    private void reifyLambdaClass(String className, byte[] classfileBuffer) {\n-        try {\n-            System.out.println(\"Saving lambda class: \" + className);\n-            byte[] backportedBytecode = LambdaClassBackporter.transform(classfileBuffer, targetVersion);\n-            Path savePath = outputDir.resolve(className + \".class\");\n-            Files.createDirectories(savePath.getParent());\n-            Files.write(savePath, backportedBytecode);\n-\n-        } catch (Throwable t) {\n-            // print to stdout to keep in sync with other log output\n-            System.out.println(\"ERROR: Failed to backport lambda class: \" + className);\n-            t.printStackTrace(System.out);\n-        }\n-    }\n }\n"
    },
    {
        "commit_hash": "03ab4b0d53b5f2e74bd7443b7e0b1389745ec804",
        "previous_commit_hash": "62199098ce9afbeb693c582c532af27adac78928",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -15,7 +15,7 @@ public class PreMain {\n         Config config = new Config(System.getProperties());\n         int bytecodeVersion = config.getBytecodeVersion();\n         Path outputDir = config.getOutputDir();\n-        inst.addTransformer(new LambdaSavingClassFileTransformer(outputDir, bytecodeVersion));\n+        inst.addTransformer(new LambdaSavingClassFileTransformer(new LambdaClassSaver(outputDir, bytecodeVersion)));\n         agentLoaded = true;\n     }\n \n"
    },
    {
        "commit_hash": "03ab4b0d53b5f2e74bd7443b7e0b1389745ec804",
        "previous_commit_hash": "62199098ce9afbeb693c582c532af27adac78928",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -32,7 +32,7 @@ public class Retrolambda {\n \n         Thread.currentThread().setContextClassLoader(new URLClassLoader(asUrls(classpath)));\n \n-        try (LambdaClassDumper dumper = new LambdaClassDumper(outputDir, bytecodeVersion)) {\n+        try (LambdaClassDumper dumper = new LambdaClassDumper(new LambdaClassSaver(outputDir, bytecodeVersion))) {\n             if (!PreMain.isAgentLoaded()) {\n                 dumper.install();\n             }\n"
    },
    {
        "commit_hash": "d80c9101bce945598a95ccbf8b721b6539a8af63",
        "previous_commit_hash": "03ab4b0d53b5f2e74bd7443b7e0b1389745ec804",
        "diff_stats": {
            "additions": 18,
            "deletions": 0
        },
        "diff_content": "@@ -27,4 +27,22 @@ public class ClasspathTest {\n         lambda.describeTo(result);\n         assertThat(result.toString(), is(\"foo\"));\n     }\n+\n+    /**\n+     * This is to reproduce a bug where the Maven plugin does not include\n+     * the main classes on the test classpath, causing Retrolambda to fail\n+     * in loading test classes such as this one (i.e. test classes which\n+     * depend on main classes at class loading time).\n+     */\n+    @Test\n+    public void maven_plugin_includes_the_main_classes_in_the_test_classpath() {\n+        class RequiresMainClassesInTestClasspath extends InMainSources {\n+            public Runnable foo() {\n+                // Any lambda, to make Retrolambda try to process this class\n+                return () -> {\n+                };\n+            }\n+        }\n+        new RequiresMainClassesInTestClasspath().foo();\n+    }\n }\n"
    },
    {
        "commit_hash": "d80c9101bce945598a95ccbf8b721b6539a8af63",
        "previous_commit_hash": "03ab4b0d53b5f2e74bd7443b7e0b1389745ec804",
        "diff_stats": {
            "additions": 16,
            "deletions": 16
        },
        "diff_content": "@@ -7,7 +7,7 @@ package net.orfjackal.retrolambda.maven;\n import com.google.common.base.Joiner;\n import com.google.common.collect.ImmutableMap;\n import net.orfjackal.retrolambda.*;\n-import org.apache.maven.artifact.Artifact;\n+import org.apache.maven.artifact.DependencyResolutionRequiredException;\n import org.apache.maven.execution.MavenSession;\n import org.apache.maven.plugin.*;\n import org.apache.maven.plugins.annotations.*;\n@@ -38,7 +38,7 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n     private BuildPluginManager pluginManager;\n \n     @Component\n-    private MavenProject project;\n+    protected MavenProject project;\n \n     /**\n      * Directory of the Java 8 installation for running Retrolambda.\n@@ -80,7 +80,7 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n \n     protected abstract File getOutputDir();\n \n-    protected abstract String getClasspathId();\n+    protected abstract List<String> getClasspathElements() throws DependencyResolutionRequiredException;\n \n     @Override\n     public void execute() throws MojoExecutionException {\n@@ -115,7 +115,7 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n             p.setProperty(Config.BYTECODE_VERSION, \"\" + targetBytecodeVersions.get(target));\n             p.setProperty(Config.INPUT_DIR, getInputDir().getAbsolutePath());\n             p.setProperty(Config.OUTPUT_DIR, getOutputDir().getAbsolutePath());\n-            p.setProperty(Config.CLASSPATH, getProjectClasspath());\n+            p.setProperty(Config.CLASSPATH, getClasspath());\n             Retrolambda.run(new Config(p));\n         } catch (Throwable t) {\n             throw new MojoExecutionException(\"Failed to run Retrolambda\", t);\n@@ -136,9 +136,6 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n                 goal(\"run\"),\n                 configuration(element(\n                         \"target\",\n-                        element(\"property\",\n-                                attributes(attribute(\"name\", \"the_classpath\"),\n-                                        attribute(\"refid\", getClasspathId()))),\n                         element(\"exec\",\n                                 attributes(\n                                         attribute(\"executable\", getJavaCommand()),\n@@ -146,7 +143,7 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n                                 element(\"arg\", attribute(\"value\", \"-Dretrolambda.bytecodeVersion=\" + targetBytecodeVersions.get(target))),\n                                 element(\"arg\", attribute(\"value\", \"-Dretrolambda.inputDir=\" + getInputDir().getAbsolutePath())),\n                                 element(\"arg\", attribute(\"value\", \"-Dretrolambda.outputDir=\" + getOutputDir().getAbsolutePath())),\n-                                element(\"arg\", attribute(\"value\", \"-Dretrolambda.classpath=${the_classpath}\")),\n+                                element(\"arg\", attribute(\"value\", \"-Dretrolambda.classpath=\" + getClasspath())),\n                                 element(\"arg\", attribute(\"value\", \"-javaagent:\" + retrolambdaJar)),\n                                 element(\"arg\", attribute(\"value\", \"-jar\")),\n                                 element(\"arg\", attribute(\"value\", retrolambdaJar))))),\n@@ -193,16 +190,19 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n         return new File(javaHome, \"bin/java\").getPath();\n     }\n \n-    private String getProjectClasspath() {\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(getInputDir());\n-        for (Artifact a : project.getArtifacts()) {\n-            if (a.getFile() != null) {\n-                sb.append(File.pathSeparator);\n-                sb.append(a.getFile());\n+    private String getClasspath() {\n+        try {\n+            StringBuilder sb = new StringBuilder();\n+            for (String classpathElement : getClasspathElements()) {\n+                if (sb.length() > 0) {\n+                    sb.append(File.pathSeparator);\n+                }\n+                sb.append(classpathElement);\n             }\n+            return sb.toString();\n+        } catch (DependencyResolutionRequiredException e) {\n+            throw new RuntimeException(e);\n         }\n-        return sb.toString();\n     }\n \n     private String getRetrolambdaJarPath() {\n"
    },
    {
        "commit_hash": "d80c9101bce945598a95ccbf8b721b6539a8af63",
        "previous_commit_hash": "03ab4b0d53b5f2e74bd7443b7e0b1389745ec804",
        "diff_stats": {
            "additions": 4,
            "deletions": 2
        },
        "diff_content": "@@ -4,9 +4,11 @@\n \n package net.orfjackal.retrolambda.maven;\n \n+import org.apache.maven.artifact.DependencyResolutionRequiredException;\n import org.apache.maven.plugins.annotations.*;\n \n import java.io.File;\n+import java.util.List;\n \n /**\n  * Processes main classes compiled with Java 8 so that they will be compatible with\n@@ -45,7 +47,7 @@ public class ProcessMainClassesMojo extends ProcessClassesMojo {\n     }\n \n     @Override\n-    protected String getClasspathId() {\n-        return \"maven.compile.classpath\";\n+    protected List<String> getClasspathElements() throws DependencyResolutionRequiredException {\n+        return project.getCompileClasspathElements();\n     }\n }\n"
    },
    {
        "commit_hash": "d80c9101bce945598a95ccbf8b721b6539a8af63",
        "previous_commit_hash": "03ab4b0d53b5f2e74bd7443b7e0b1389745ec804",
        "diff_stats": {
            "additions": 4,
            "deletions": 2
        },
        "diff_content": "@@ -4,9 +4,11 @@\n \n package net.orfjackal.retrolambda.maven;\n \n+import org.apache.maven.artifact.DependencyResolutionRequiredException;\n import org.apache.maven.plugins.annotations.*;\n \n import java.io.File;\n+import java.util.List;\n \n /**\n  * Processes test classes compiled with Java 8 so that they will be compatible with\n@@ -45,7 +47,7 @@ public class ProcessTestClassesMojo extends ProcessClassesMojo {\n     }\n \n     @Override\n-    protected String getClasspathId() {\n-        return \"maven.test.classpath\";\n+    protected List<String> getClasspathElements() throws DependencyResolutionRequiredException {\n+        return project.getTestClasspathElements();\n     }\n }\n"
    },
    {
        "commit_hash": "d98456c7f28c5a60759c7413c3c27d9b64933eab",
        "previous_commit_hash": "d80c9101bce945598a95ccbf8b721b6539a8af63",
        "diff_stats": {
            "additions": 2,
            "deletions": 0
        },
        "diff_content": "@@ -72,6 +72,8 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n      * Java Agent hook for capturing the lambda classes generated by Java 8,\n      * whereas the non-forked version hooks into internal Java APIs, making it\n      * more susceptible to breaking between Java releases.\n+     *\n+     * @since 1.6.0\n      */\n     @Parameter(defaultValue = \"false\")\n     public boolean fork;\n"
    },
    {
        "commit_hash": "b307960286dfb9e198f199143a2d4548996c8144",
        "previous_commit_hash": "d98456c7f28c5a60759c7413c3c27d9b64933eab",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -85,7 +85,7 @@ To run Retrolambda using Maven, add the following to your pom.xml:\n <plugin>\n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>retrolambda-maven-plugin</artifactId>\n-    <version>1.5.0</version>\n+    <version>1.6.0</version>\n     <executions>\n         <execution>\n             <goals>\n@@ -149,7 +149,7 @@ package-private.\n Version History\n ---------------\n \n-### Upcoming\n+### Retrolambda 1.6.0 (2014-08-20)\n \n - Does not anymore require the use of a Java agent\n   ([Issue #27](https://github.com/orfjackal/retrolambda/issues/27))\n"
    },
    {
        "commit_hash": "b307960286dfb9e198f199143a2d4548996c8144",
        "previous_commit_hash": "d98456c7f28c5a60759c7413c3c27d9b64933eab",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.5.1-SNAPSHOT</version>\n+        <version>1.6.0</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "b307960286dfb9e198f199143a2d4548996c8144",
        "previous_commit_hash": "d98456c7f28c5a60759c7413c3c27d9b64933eab",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>1.5.1-SNAPSHOT</version>\n+    <version>1.6.0</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "b307960286dfb9e198f199143a2d4548996c8144",
        "previous_commit_hash": "d98456c7f28c5a60759c7413c3c27d9b64933eab",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.5.1-SNAPSHOT</version>\n+        <version>1.6.0</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "b307960286dfb9e198f199143a2d4548996c8144",
        "previous_commit_hash": "d98456c7f28c5a60759c7413c3c27d9b64933eab",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.5.1-SNAPSHOT</version>\n+        <version>1.6.0</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "b307960286dfb9e198f199143a2d4548996c8144",
        "previous_commit_hash": "d98456c7f28c5a60759c7413c3c27d9b64933eab",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.5.1-SNAPSHOT</version>\n+        <version>1.6.0</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "363bfba6c59d66c92fd9e36d6d51ab01b01bde26",
        "previous_commit_hash": "b307960286dfb9e198f199143a2d4548996c8144",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.6.0</version>\n+        <version>1.6.1-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "363bfba6c59d66c92fd9e36d6d51ab01b01bde26",
        "previous_commit_hash": "b307960286dfb9e198f199143a2d4548996c8144",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>1.6.0</version>\n+    <version>1.6.1-SNAPSHOT</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "363bfba6c59d66c92fd9e36d6d51ab01b01bde26",
        "previous_commit_hash": "b307960286dfb9e198f199143a2d4548996c8144",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.6.0</version>\n+        <version>1.6.1-SNAPSHOT</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "363bfba6c59d66c92fd9e36d6d51ab01b01bde26",
        "previous_commit_hash": "b307960286dfb9e198f199143a2d4548996c8144",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.6.0</version>\n+        <version>1.6.1-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "363bfba6c59d66c92fd9e36d6d51ab01b01bde26",
        "previous_commit_hash": "b307960286dfb9e198f199143a2d4548996c8144",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.6.0</version>\n+        <version>1.6.1-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "8d5b86d4066bf52db2680ae115593ae5d72bad34",
        "previous_commit_hash": "363bfba6c59d66c92fd9e36d6d51ab01b01bde26",
        "diff_stats": {
            "additions": 5,
            "deletions": 5
        },
        "diff_content": "@@ -67,11 +67,11 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n     public String target;\n \n     /**\n-     * Forces Retrolambda to run a separate process. The default is not to fork,\n-     * in which case Maven has to run under Java 8. The forked process uses a\n-     * Java Agent hook for capturing the lambda classes generated by Java 8,\n-     * whereas the non-forked version hooks into internal Java APIs, making it\n-     * more susceptible to breaking between Java releases.\n+     * Forces Retrolambda to run in a separate process. The default is not to fork,\n+     * in which case Maven has to run under Java 8, or this plugin will fall back\n+     * to forking. The forked process uses a Java agent hook for capturing the lambda\n+     * classes generated by Java 8, whereas the non-forked version hooks into internal\n+     * Java APIs, making it more susceptible to breaking between Java releases.\n      *\n      * @since 1.6.0\n      */\n"
    },
    {
        "commit_hash": "0ec45c6c1bab9db425dd91533478ad8ed2c697c6",
        "previous_commit_hash": "8d5b86d4066bf52db2680ae115593ae5d72bad34",
        "diff_stats": {
            "additions": 6,
            "deletions": 0
        },
        "diff_content": "@@ -149,6 +149,12 @@ package-private.\n Version History\n ---------------\n \n+### Upcoming\n+\n+- Fixed a crash when trying backport classes that are part of the JRE, but\n+  the JRE's class differs from the class being backported\n+  ([Issue #29](https://github.com/orfjackal/retrolambda/issues/29))\n+\n ### Retrolambda 1.6.0 (2014-08-20)\n \n - Does not anymore require the use of a Java agent\n"
    },
    {
        "commit_hash": "0ec45c6c1bab9db425dd91533478ad8ed2c697c6",
        "previous_commit_hash": "8d5b86d4066bf52db2680ae115593ae5d72bad34",
        "diff_stats": {
            "additions": 19,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,19 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package com.sun.javafx.application;\n+\n+import net.orfjackal.retrolambda.test.ClasspathTest;\n+\n+/**\n+ * @see ClasspathTest#prefers_classes_in_explicit_classpath_over_classes_in_the_JRE\n+ */\n+@SuppressWarnings(\"UnusedDeclaration\")\n+public class LauncherImpl {\n+\n+    public Runnable foo() {\n+        return () -> {\n+        };\n+    }\n+}\n"
    },
    {
        "commit_hash": "0ec45c6c1bab9db425dd91533478ad8ed2c697c6",
        "previous_commit_hash": "8d5b86d4066bf52db2680ae115593ae5d72bad34",
        "diff_stats": {
            "additions": 12,
            "deletions": 0
        },
        "diff_content": "@@ -11,6 +11,7 @@ import java.util.Arrays;\n \n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertNotNull;\n \n public class ClasspathTest {\n \n@@ -45,4 +46,15 @@ public class ClasspathTest {\n         }\n         new RequiresMainClassesInTestClasspath().foo();\n     }\n+\n+    /**\n+     * This is to reproduce a bug where trying to backport a development\n+     * version of JavaFX classes fails because the same classes also exist in\n+     * the JRE's extension directory and Retrolambda accidentally loads the\n+     * old built-in class instead of the new class that is being transformed.\n+     */\n+    @Test\n+    public void prefers_classes_in_explicit_classpath_over_classes_in_the_JRE() {\n+        assertNotNull(getClass().getResource(\"/com/sun/javafx/application/LauncherImpl$$Lambda$1.class\"));\n+    }\n }\n"
    },
    {
        "commit_hash": "0ec45c6c1bab9db425dd91533478ad8ed2c697c6",
        "previous_commit_hash": "8d5b86d4066bf52db2680ae115593ae5d72bad34",
        "diff_stats": {
            "additions": 27,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,27 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda;\n+\n+import java.net.*;\n+\n+public class NonDelegatingClassLoader extends URLClassLoader {\n+\n+    public NonDelegatingClassLoader(URL[] urls) {\n+        super(urls);\n+    }\n+\n+    @Override\n+    public Class<?> loadClass(String name) throws ClassNotFoundException {\n+        Class<?> c = findLoadedClass(name);\n+        if (c != null) {\n+            return c;\n+        }\n+        try {\n+            return findClass(name);\n+        } catch (ClassNotFoundException e) {\n+            return super.loadClass(name);\n+        }\n+    }\n+}\n"
    },
    {
        "commit_hash": "0ec45c6c1bab9db425dd91533478ad8ed2c697c6",
        "previous_commit_hash": "8d5b86d4066bf52db2680ae115593ae5d72bad34",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -30,7 +30,7 @@ public class Retrolambda {\n             return;\n         }\n \n-        Thread.currentThread().setContextClassLoader(new URLClassLoader(asUrls(classpath)));\n+        Thread.currentThread().setContextClassLoader(new NonDelegatingClassLoader(asUrls(classpath)));\n \n         try (LambdaClassDumper dumper = new LambdaClassDumper(new LambdaClassSaver(outputDir, bytecodeVersion))) {\n             if (!PreMain.isAgentLoaded()) {\n"
    },
    {
        "commit_hash": "1c0c4c430b1465e6bc2b8ce891545d634954d350",
        "previous_commit_hash": "374c4f27f931526e216b47a29437c6e03104a964",
        "diff_stats": {
            "additions": 6,
            "deletions": 2
        },
        "diff_content": "@@ -4,8 +4,11 @@\n \n package net.orfjackal.retrolambda;\n \n+import net.orfjackal.retrolambda.defaultmethods.ClassModifier;\n import org.objectweb.asm.*;\n \n+import java.util.Arrays;\n+\n import static org.objectweb.asm.Opcodes.*;\n \n public class LambdaClassBackporter {\n@@ -15,7 +18,8 @@ public class LambdaClassBackporter {\n \n     public static byte[] transform(byte[] bytecode, int targetVersion) {\n         ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n-        new ClassReader(bytecode).accept(new LambdaClassVisitor(writer, targetVersion), 0);\n+\t\tClassModifier stage2 = new ClassModifier(targetVersion, writer);\n+        new ClassReader(bytecode).accept(new LambdaClassVisitor(stage2, targetVersion), 0);\n         return writer.toByteArray();\n     }\n \n@@ -27,7 +31,7 @@ public class LambdaClassBackporter {\n         private Handle bridgeMethod;\n         private LambdaFactoryMethod factoryMethod;\n \n-        public LambdaClassVisitor(ClassWriter cw, int targetVersion) {\n+        public LambdaClassVisitor(ClassVisitor cw, int targetVersion) {\n             super(ASM5, cw);\n             this.targetVersion = targetVersion;\n         }\n"
    },
    {
        "commit_hash": "1c0c4c430b1465e6bc2b8ce891545d634954d350",
        "previous_commit_hash": "374c4f27f931526e216b47a29437c6e03104a964",
        "diff_stats": {
            "additions": 8,
            "deletions": 29
        },
        "diff_content": "@@ -4,6 +4,9 @@\n \n package net.orfjackal.retrolambda;\n \n+import net.orfjackal.retrolambda.defaultmethods.ClassModifier;\n+import net.orfjackal.retrolambda.defaultmethods.Helpers;\n+import net.orfjackal.retrolambda.defaultmethods.InterfaceModifier;\n import org.objectweb.asm.*;\n \n import java.lang.reflect.Field;\n@@ -16,9 +19,10 @@ public class LambdaUsageBackporter {\n \n     public static byte[] transform(byte[] bytecode, int targetVersion) {\n         resetLambdaClassSequenceNumber();\n-\n         ClassWriter stage2 = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n-        InvokeDynamicInsnConverter stage1 = new InvokeDynamicInsnConverter(stage2, targetVersion);\n+\t\tClassModifier stage3 = new ClassModifier(targetVersion, stage2);\n+\t\tInterfaceModifier stage4 = new InterfaceModifier(stage3, targetVersion);\n+        InvokeDynamicInsnConverter stage1 = new InvokeDynamicInsnConverter(stage4, targetVersion);\n         new ClassReader(bytecode).accept(stage1, 0);\n         return stage2.toByteArray();\n     }\n@@ -64,22 +68,6 @@ public class LambdaUsageBackporter {\n             if (isBridgeMethodOnInterface(access)) {\n                 return null; // remove the bridge method; Java 7 didn't use them\n             }\n-            if (isNonAbstractMethodOnInterface(access)\n-                    && !isClassInitializerMethod(name, desc, access)) {\n-                // In case we have missed a case of Java 8 producing non-abstract methods\n-                // on interfaces, we have this warning here to get a bug report sooner.\n-                // Not allowed by Java 7:\n-                // - default methods\n-                // - static methods\n-                // - bridge methods\n-                // Allowed by Java 7:\n-                // - class initializer methods (for initializing constants)\n-                System.out.println(\"WARNING: Method '\" + name + \"' of interface '\" + className + \"' is non-abstract! \" +\n-                        \"This will probably fail to run on Java 7 and below. \" +\n-                        \"If you get this warning _without_ using Java 8's default methods, \" +\n-                        \"please report a bug at https://github.com/orfjackal/retrolambda/issues \" +\n-                        \"together with an SSCCE (http://www.sscce.org/)\");\n-            }\n             MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n             return new InvokeDynamicInsnConvertingMethodVisitor(mv, this);\n         }\n@@ -158,7 +146,7 @@ public class LambdaUsageBackporter {\n         }\n \n         private void backportLambda(String invokedName, Type invokedType, Handle bsm, Object[] bsmArgs) {\n-            Class<?> invoker = loadClass(context.className);\n+            Class<?> invoker = Helpers.loadClass(context.className);\n             Handle implMethod = (Handle) bsmArgs[1];\n             Handle bridgeMethod = context.getLambdaBridgeMethod(implMethod);\n \n@@ -166,14 +154,5 @@ public class LambdaUsageBackporter {\n                     invoker, invokedName, invokedType, bsm, bsmArgs);\n             super.visitMethodInsn(INVOKESTATIC, factory.getOwner(), factory.getName(), factory.getDesc(), false);\n         }\n-\n-        private static Class<?> loadClass(String className) {\n-            try {\n-                ClassLoader cl = Thread.currentThread().getContextClassLoader();\n-                return cl.loadClass(className.replace('/', '.'));\n-            } catch (ClassNotFoundException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-    }\n+\t}\n }\n"
    },
    {
        "commit_hash": "1c0c4c430b1465e6bc2b8ce891545d634954d350",
        "previous_commit_hash": "374c4f27f931526e216b47a29437c6e03104a964",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -39,6 +39,19 @@ public class Main {\n \n         try {\n             Thread.currentThread().setContextClassLoader(new URLClassLoader(asUrls(classpath)));\n+\t\t\t/**\n+\t\t\t * {\n+\t\t\t\t@Override\n+\t\t\t\tpublic Class<?> loadClass(String name) throws ClassNotFoundException {\n+\t\t\t\t\tClass<?> loadedClass = findLoadedClass(name);\n+\t\t\t\t\tif(loadedClass != null) {\n+\t\t\t\t\t\treturn loadedClass;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\treturn super.loadClass(name);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\t */\n \n             visitFiles(inputDir, includedFiles, new BytecodeTransformingFileVisitor(inputDir, outputDir) {\n                 @Override\n"
    },
    {
        "commit_hash": "1c0c4c430b1465e6bc2b8ce891545d634954d350",
        "previous_commit_hash": "374c4f27f931526e216b47a29437c6e03104a964",
        "diff_stats": {
            "additions": 178,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,178 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.defaultmethods;\n+\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.MethodVisitor;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.Type;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.*;\n+import java.util.stream.Stream;\n+\n+/**\n+ * Created by arneball on 2014-08-12.\n+ */\n+public class ClassModifier extends ClassVisitor implements Opcodes {\n+\tprivate final int bytecodeVersion;\n+\tprivate String[] interfaces;\n+\n+\tprivate Set<VisitedMethod> visitedMethods = new HashSet<>();\n+\tprivate Set<MethodContainer> defaultMethods = new HashSet<>();\n+\n+\tpublic ClassModifier(int bytecodeVersion, ClassVisitor cv) {\n+\t\tsuper(ASM5, cv);\n+\t\tthis.bytecodeVersion = bytecodeVersion;\n+\t}\n+\n+\t@Override\n+\tpublic void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n+\t\tboolean isClass = (access & ACC_INTERFACE) == 0;\n+\t\tif(isClass) {\n+\t\t\tdefaultMethods = getMethodsToImplement(interfaces, signature);\n+\t\t}\n+\t\tthis.interfaces = interfaces;\n+\t\tSystem.out.println(\"Class is \" + name + \", non abstract \" + isClass + \", Interfaces are \" + Arrays.toString(interfaces) + \"\" +\n+\t\t\t\t\", default methods are \" + defaultMethods);\n+\t\tsuper.visit(bytecodeVersion, access, name, signature, superName, interfaces);\n+\t}\n+\n+\tprivate static Set<MethodContainer> getMethodsToImplement(String[] interfaces, String sig) {\n+\t\tSet<MethodContainer> tmp = new HashSet<>();\n+\t\tfor(String iff : interfaces) {\n+\t\t\ttmp.addAll(getMethodsToImplement(iff, sig));\n+\t\t}\n+\t\treturn tmp;\n+\t}\n+\n+\tprivate static Set<MethodContainer> getMethodsToImplement(String interfac, String sig) {\n+\t\tClass<?> ifClass = Helpers.loadClass(interfac);\n+\t\tMethod[] tmp = ifClass.getMethods();\n+\t\tSystem.out.println(\"Interface: \" + interfac + \", methods: \" + Arrays.toString(tmp));\n+\t\tSet<MethodContainer> toReturn = new HashSet<>();\n+\t\tfor(Method m : tmp) {\n+\t\t\tif(!Modifier.isAbstract(m.getModifiers())) {\n+\t\t\t\tSystem.out.println(\"NEED TO CREATE PROXY TO \" + interfac + sig + \"\\n\" + m.getDeclaringClass());\n+\t\t\t\tMethodContainer e = new MethodContainer(m.getName(), Type.getMethodDescriptor(m), m.getDeclaringClass().getName().replace(\".\", \"/\"), sig, getExceptions(m));\n+\t\t\t\ttoReturn.add(e);\n+\t\t\t}\n+\t\t}\n+\t\treturn toReturn;\n+\t}\n+\n+\tprivate static String[] getExceptions(Method m) {\n+\t\tClass<?>[] exceptionTypes = m.getExceptionTypes();\n+\t\tString[] tmp = new String[exceptionTypes.length];\n+\t\tfor(int i = 0; i < exceptionTypes.length; i++) {\n+\t\t\ttmp[i] = exceptionTypes[i].getName().replace(\".\", \"/\");\n+\t\t}\n+\t\treturn tmp;\n+\t}\n+\n+\t@Override\n+\tpublic MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+\t\tvisitedMethods.add(new VisitedMethod(name, desc));\n+\t\treturn new InterfaceToHelperRewriter(super.visitMethod(access, name, desc, signature, exceptions));\n+\t}\n+\n+\t@Override\n+\tpublic void visitEnd() {\n+\t\tfor(MethodContainer m : defaultMethods) {\n+\t\t\tif(visitedMethods.contains(new VisitedMethod(m.methodName, m.methodDesc))) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tSystem.out.println(\"VISITEND, CREATING PROXY \" + m);\n+\t\t\tMethodVisitor tmp = super.visitMethod(ACC_PUBLIC, m.methodName, m.methodDesc, m.signature, m.exceptions);\n+\t\t\ttmp.visitVarInsn(ALOAD, 0);\n+\t\t\tint i = 1;\n+\t\t\tfor(Type arg : Type.getArgumentTypes(m.methodDesc)) {\n+\t\t\t\ttmp.visitVarInsn(getVarIns(arg), i++);\n+\t\t\t}\n+\t\t\tString rightInterace = findRightInterace(m, interfaces);\n+\t\t\tSystem.out.println(\"It thinks that the right interface is \" + rightInterace);\n+\t\t\tString mDesc = Helpers.addParam(m.methodDesc, rightInterace);\n+\t\t\ttmp.visitMethodInsn(INVOKESTATIC, rightInterace + \"$helper\", m.methodName, mDesc, false);\n+\t\t\ttmp.visitInsn(getReturnIns(Type.getReturnType(m.methodDesc)));\n+\t\t\ttmp.visitMaxs(0, 0);\n+\t\t\ttmp.visitEnd();\n+\t\t}\n+\t\tsuper.visitEnd();\n+\t}\n+\n+\tpublic static final Comparator<Method> COMPARATOR = (o1, o2) -> {\n+\t\tboolean o1iso2 = o1.getDeclaringClass().isAssignableFrom(o2.getDeclaringClass());\n+\t\tboolean o2iso1 = o2.getDeclaringClass().isAssignableFrom(o1.getDeclaringClass());\n+\t\tif(o1iso2 && o2iso1) {\n+\t\t\treturn 0;\n+\t\t} else if(o2iso1)\n+\t\t\treturn -1;\n+\t\telse return 1;\n+\t};\n+\n+\tpublic static String findRightInterace(MethodContainer methodContainer, String[] interfaces) {\n+\t\tSystem.out.println(\"Find right interfaces for \" + methodContainer + \" \" + Arrays.toString(interfaces));\n+\t\treturn Stream.of(interfaces)\n+\t\t\t\t.map(Helpers::loadClass)\n+\t\t\t\t.flatMap(i -> flattenInterfaces(i).stream())\n+\t\t\t\t.flatMap(i -> Stream.of(i.getMethods()))\n+\t\t\t\t.filter(Method::isDefault)\n+\t\t\t\t.filter(m -> Type.getMethodDescriptor(m).equals(methodContainer.methodDesc))\n+\t\t\t\t.min(COMPARATOR)\n+\t\t\t\t.map(Method::getDeclaringClass)\n+\t\t\t\t.map(Class::getName)\n+\t\t\t\t.map(s -> s.replace(\".\", \"/\"))\n+\t\t\t\t.orElseThrow(NullPointerException::new);\n+\t}\n+\n+\tprivate static List<Class<?>> flattenInterfaces(Class<?> iff) {\n+\t\tList<Class<?>> tmp = new ArrayList<>();\n+\t\tif(iff != null){\n+\t\t\ttmp.add(iff);\n+\t\t\tfor(Class<?> stream : iff.getInterfaces()) {\n+\t\t\t\ttmp.addAll(flattenInterfaces(stream));\n+\t\t\t}\n+\t\t}\n+\t\treturn tmp;\n+\t}\n+\n+\tstatic int getReturnIns(Type arg) {\n+\t\tif(arg == Type.INT_TYPE || arg == Type.BOOLEAN_TYPE || arg == Type.SHORT_TYPE) {\n+\t\t\treturn IRETURN;\n+\t\t}\n+\t\telse if(arg == Type.LONG_TYPE) {\n+\t\t\treturn LRETURN;\n+\t\t}\n+\t\telse if(arg == Type.DOUBLE_TYPE) {\n+\t\t\treturn DRETURN;\n+\t\t}\n+\t\telse if(arg == Type.FLOAT_TYPE) {\n+\t\t\treturn FRETURN;\n+\t\t}\n+\t\telse if(arg == Type.VOID_TYPE) {\n+\t\t\treturn RETURN;\n+\t\t}\n+\t\telse {\n+\t\t\treturn ARETURN;\n+\t\t}\n+\t}\n+\n+\tstatic int getVarIns(Type arg) {\n+\t\tif(arg == Type.INT_TYPE || arg == Type.BOOLEAN_TYPE || arg == Type.SHORT_TYPE) {\n+\t\t\treturn ILOAD;\n+\t\t}\n+\t\telse if(arg == Type.DOUBLE_TYPE) {\n+\t\t\treturn DLOAD;\n+\t\t}\n+\t\telse if(arg == Type.FLOAT_TYPE) {\n+\t\t\treturn FLOAD;\n+\t\t}\n+\t\telse {\n+\t\t\treturn ALOAD;\n+\t\t}\n+\t}\n+\n+}\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "1c0c4c430b1465e6bc2b8ce891545d634954d350",
        "previous_commit_hash": "374c4f27f931526e216b47a29437c6e03104a964",
        "diff_stats": {
            "additions": 51,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,51 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.defaultmethods;\n+\n+import org.objectweb.asm.Type;\n+\n+import java.lang.reflect.Method;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+import static org.objectweb.asm.Type.*;\n+/**\n+ * Created by arneball on 2014-08-12.\n+ */\n+public class Helpers {\n+\tprivate static final Pattern pattern = Pattern.compile(\"\\\\((.*)\\\\)(.*)\");\n+\n+\tpublic static String addParam(String desc, String className) {\n+\t\tMatcher m = pattern.matcher(desc);\n+\t\tm.find();\n+\t\tString rest = m.group(1);\n+\t\tString returntype = m.group(2);\n+\t\treturn String.format(\"(L%s;%s)%s\", className, rest, returntype);\n+\t}\n+\n+\tpublic static String changeReturnType(String desc, String returnType) {\n+\t\tMatcher m = pattern.matcher(desc);\n+\t\tm.find();\n+\t\tString rest = m.group(1);\n+\t\treturn String.format(\"(%s)L%s;\", rest, returnType);\n+\t}\n+\n+\tpublic static Class<?> loadClass(String className) {\n+\t\ttry {\n+\t\t\tClassLoader cl = Thread.currentThread().getContextClassLoader();\n+\t\t\treturn cl.loadClass(className.replace('/', '.'));\n+\t\t} catch (ClassNotFoundException e) {\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n+\t}\n+\n+\tpublic static boolean isPrimitive(Type containerReturnType) {\n+\t\treturn Stream.of(BYTE_TYPE, SHORT_TYPE, INT_TYPE, LONG_TYPE, FLOAT_TYPE, DOUBLE_TYPE, VOID_TYPE, BOOLEAN_TYPE)\n+\t\t\t\t.filter(containerReturnType::equals)\n+\t\t\t\t.findAny()\n+\t\t\t\t.isPresent();\n+\n+\t}\n+}\n"
    },
    {
        "commit_hash": "1c0c4c430b1465e6bc2b8ce891545d634954d350",
        "previous_commit_hash": "374c4f27f931526e216b47a29437c6e03104a964",
        "diff_stats": {
            "additions": 177,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,177 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.defaultmethods;\n+\n+import net.orfjackal.retrolambda.Config;\n+import org.objectweb.asm.*;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Method;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * Created by arneball on 2014-08-12.\n+ */\n+public class InterfaceModifier  extends ClassVisitor implements Opcodes{\n+\tprivate final int targetByteCode;\n+\tprivate String className;\n+\tprivate boolean isInterface;\n+\tprivate ClassWriter helperClassVisitor;\n+\tprivate String[] interfaces;\n+\tprivate List<MethodContainer> methodContainers = new ArrayList<>();\n+\n+\tpublic InterfaceModifier(ClassVisitor classWriter, int targetBytodeCode) {\n+\t\tsuper(ASM5, classWriter);\n+\t\tthis.targetByteCode = targetBytodeCode;\n+\t}\n+\n+\t@Override\n+\tpublic void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n+\t\tisInterface = (access & ACC_INTERFACE) != 0;\n+\t\tclassName = name;\n+\t\tthis.interfaces = interfaces;\n+\t\t// force load this class, if not, we are overwriting the interface and succeeding loads will see the purely abstract onoe\n+\t\tHelpers.loadClass(name);\n+\t\tSystem.out.println(\"Visiting interface \" + name);\n+\t\tsuper.visit(version, access, name, signature, superName, interfaces);\n+\t}\n+\n+\t@Override\n+\tpublic MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+\t\tboolean isConcrete = (access & ACC_ABSTRACT) == 0;\n+\t\tboolean isStatic = (access & ACC_STATIC) != 0;\n+\t\tif(isConcrete && isInterface && !isStatic) {\n+\t\t\tsuper.visitMethod(access | ACC_ABSTRACT, name, desc, signature, exceptions);\n+\t\t\tMethodVisitor tmp = getHelperClassVisitor().visitMethod(\n+\t\t\t\t\taccess | ACC_STATIC,\n+\t\t\t\t\tname,\n+\t\t\t\t\tHelpers.addParam(desc, className),\n+\t\t\t\t\tsignature,\n+\t\t\t\t\texceptions);\n+\t\t\tmethodContainers.add(new MethodContainer(name, desc, null, signature, exceptions));\n+\t\t\treturn new InterfaceToHelperRewriter(new BodyMover(tmp));\n+\t\t} else if(isStatic && isInterface) {\n+\t\t\treturn getHelperClassVisitor().visitMethod(access, name + \"$static\", desc, signature, exceptions);\n+\t\t} else {\n+\t\t\treturn super.visitMethod(access, name, desc, signature, exceptions);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void visitEnd() {\n+\t\tPath newPath = new Config(System.getProperties()).getOutputDir();\n+\t\tArrayList<Method> allMethods = Stream.of(interfaces)\n+\t\t\t\t.map(Helpers::loadClass)\n+\t\t\t\t.flatMap(c -> Stream.of(c.getMethods()))\n+\t\t\t\t.collect(Collectors.toCollection(ArrayList::new));\n+\t\tmethodContainers.stream().forEach(m -> {\n+\t\t\tallMethods.stream()\n+\t\t\t\t\t.filter(meth -> bridgeNeeded(meth, m))\n+\t\t\t\t\t.forEach(meth -> createBridge(meth, m));\n+\t\t});\n+\t\tgetHelperClassVisitor().visitEnd();\n+\t\tsuper.visitEnd();\n+\t\ttry {\n+\t\t\tFiles.createDirectories(newPath.getParent());\n+\t\t\tFiles.write(newPath.resolve(helperClassName() + \".class\"), getHelperClassVisitor().toByteArray());\n+\t\t} catch (IOException e) {\n+\t\t\te.printStackTrace();\n+\t\t}\n+\t}\n+\n+\tprivate void createBridge(Method meth, MethodContainer m) {\n+\t\tint access = ACC_PUBLIC | ACC_STATIC | ACC_BRIDGE;\n+\t\tString desc = Helpers.addParam(m.methodDesc, className);\n+\t\tString returnType = Type.getReturnType(meth).getInternalName();\n+\t\tdesc = Helpers.changeReturnType(desc, returnType);\n+\t\tMethodVisitor tmp = getHelperClassVisitor().visitMethod(access, m.methodName, desc, m.signature, m.exceptions);\n+\t\ttmp.visitVarInsn(ALOAD, 0);\n+\t\tint i = 1;\n+\t\tfor(Type arg : Type.getArgumentTypes(m.methodDesc)) {\n+\t\t\ttmp.visitVarInsn(ClassModifier.getVarIns(arg), i++);\n+\t\t}\n+\t\tString mDesc = Helpers.addParam(m.methodDesc, className);\n+\t\ttmp.visitMethodInsn(INVOKESTATIC, className + \"$helper\", m.methodName, mDesc, false);\n+\t\ttmp.visitInsn(ARETURN);\n+\t\ttmp.visitMaxs(0, 0);\n+\t\ttmp.visitEnd();\n+\t}\n+\n+\tprivate static boolean bridgeNeeded(Method method, MethodContainer methodContainer) {\n+\t\tType[] methodArgumentns = Type.getArgumentTypes(method);\n+\t\tType[] containerArguments = Type.getArgumentTypes(methodContainer.methodDesc);\n+\t\tboolean argsEquals = Arrays.equals(methodArgumentns, containerArguments);\n+\t\tboolean nameEquals = method.getName().equals(methodContainer.methodName);\n+\t\tlog(\"\" + method + \" should be equal to \" + methodContainer);\n+\t\tlog(\"Args equal = \" + argsEquals + \", nameEquals = \" + nameEquals);\n+\t\tif(!argsEquals || !nameEquals) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tType containerReturnType = Type.getReturnType(methodContainer.methodDesc);\n+\t\tType methodReturnType = Type.getReturnType(method);\n+\t\tboolean containerRetPrimite = Helpers.isPrimitive(containerReturnType);\n+\t\tboolean methodRetPrimitive = Helpers.isPrimitive(methodReturnType);\n+\t\tlog(\"Container ret primitive = \" + containerRetPrimite + \", methodRetPrimitive = \" + methodRetPrimitive);\n+\t\tif(containerRetPrimite || methodRetPrimitive) {\n+\t\t\tlog(\"Either one primitive, no bridge needed\");\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tClass<?> returnType = method.getReturnType();\n+\t\tlog(\"returnType = \" + returnType + \", isPrimitive = \" + returnType.isPrimitive());\n+\t\treturn returnType.isAssignableFrom(Helpers.loadClass(containerReturnType.getClassName()));\n+\t}\n+\n+\tprivate static void log(String s) {\n+\t\tSystem.out.println(\"interfaceModifier ======= \" + s);\n+\t}\n+\n+\tprivate ClassWriter getHelperClassVisitor() {\n+\t\treturn helperClassVisitor == null ? helperClassVisitor = mkHelperClassVisitor() : helperClassVisitor;\n+\t}\n+\n+\tprivate ClassWriter mkHelperClassVisitor() {\n+\t\tClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n+\t\tcw.visit(targetByteCode,\n+\t\t\t\tACC_PUBLIC + ACC_SUPER,\n+\t\t\t\thelperClassName(),\n+\t\t\t\tnull,\n+\t\t\t\t\"java/lang/Object\",\n+\t\t\t\tnull);\n+\t\tMethodVisitor mv = cw.visitMethod(ACC_PRIVATE, \"<init>\", \"()V\", null, null);\n+\t\tmv.visitVarInsn(ALOAD, 0);\n+\t\tmv.visitMethodInsn(INVOKESPECIAL, \"java/lang/Object\", \"<init>\", \"()V\", false);\n+\t\tmv.visitInsn(RETURN);\n+\t\tmv.visitMaxs(0, 0);\n+\t\tmv.visitEnd();\n+    \treturn cw;\n+\t}\n+\n+\tprivate String helperClassName() {\n+\t\treturn className + \"$helper\";\n+\t}\n+\n+\tprivate static class BodyMover extends MethodVisitor{\n+\t\tBodyMover(MethodVisitor newMethod) {\n+\t\t\tsuper(ASM5, newMethod);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\n+\t\t\tif(opcode == INVOKESPECIAL && itf) {\n+\t\t\t\tsuper.visitMethodInsn(INVOKESTATIC, owner + \"$helper\", name, Helpers.addParam(desc, owner), false);\n+\t\t\t} else {\n+\t\t\t\tsuper.visitMethodInsn(opcode, owner, name, desc, itf);\n+\t\t\t}\n+\t\t}\n+\n+\t}\n+}\n"
    },
    {
        "commit_hash": "1c0c4c430b1465e6bc2b8ce891545d634954d350",
        "previous_commit_hash": "374c4f27f931526e216b47a29437c6e03104a964",
        "diff_stats": {
            "additions": 28,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,28 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.defaultmethods;\n+\n+import org.objectweb.asm.MethodVisitor;\n+import org.objectweb.asm.Opcodes;\n+\n+/**\n+* Created by arneball on 2014-08-24.\n+*/\n+class InterfaceToHelperRewriter extends MethodVisitor implements Opcodes {\n+\tpublic InterfaceToHelperRewriter(MethodVisitor mv) {\n+\t\tsuper(ASM5, mv);\n+\t}\n+\n+\t@Override\n+\tpublic void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\n+\t\tif(opcode == INVOKESPECIAL && itf){\n+\t\t\tsuper.visitMethodInsn(INVOKESTATIC, owner + \"$helper\", name, Helpers.addParam(desc, owner), false);\n+\t\t} else if(opcode == INVOKESTATIC && itf) {\n+\t\t\tsuper.visitMethodInsn(INVOKESTATIC, owner + \"$helper\", name + \"$static\", desc, false);\n+\t\t} else {\n+\t\t\tsuper.visitMethodInsn(opcode, owner, name, desc, itf);\n+\t\t}\n+\t}\n+}\n"
    },
    {
        "commit_hash": "1c0c4c430b1465e6bc2b8ce891545d634954d350",
        "previous_commit_hash": "374c4f27f931526e216b47a29437c6e03104a964",
        "diff_stats": {
            "additions": 58,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,58 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.defaultmethods;\n+\n+import java.util.Arrays;\n+\n+/**\n+* Created by arneball on 2014-08-23.\n+*/\n+class MethodContainer {\n+\tpublic final String methodName, methodDesc, interfce, signature;\n+\tpublic final String[] exceptions;\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn \"MethodContainer{\" +\n+\t\t\t\t\"methodName='\" + methodName + '\\'' +\n+\t\t\t\t\", methodDesc='\" + methodDesc + '\\'' +\n+\t\t\t\t\", interfce='\" + interfce + '\\'' +\n+\t\t\t\t\", signature='\" + signature + '\\'' +\n+\t\t\t\t\", exceptions=\" + Arrays.toString(exceptions) +\n+\t\t\t\t'}';\n+\t}\n+\n+\tMethodContainer(String methodName, String methodDesc, String interfce, String signature, String[] exceptions) {\n+\t\tthis.methodName = methodName;\n+\t\tthis.methodDesc = methodDesc;\n+\t\tthis.interfce = interfce;\n+\t\tthis.signature = signature;\n+\t\tthis.exceptions = exceptions;\n+\t}\n+\n+\t@Override\n+\tpublic boolean equals(Object o) {\n+\t\tif (this == o) return true;\n+\t\tif (o == null || getClass() != o.getClass()) return false;\n+\n+\t\tMethodContainer that = (MethodContainer) o;\n+\n+\t\tif (!Arrays.equals(exceptions, that.exceptions)) return false;\n+\t\tif (methodDesc != null ? !methodDesc.equals(that.methodDesc) : that.methodDesc != null) return false;\n+\t\tif (methodName != null ? !methodName.equals(that.methodName) : that.methodName != null) return false;\n+\t\tif (signature != null ? !signature.equals(that.signature) : that.signature != null) return false;\n+\n+\t\treturn true;\n+\t}\n+\n+\t@Override\n+\tpublic int hashCode() {\n+\t\tint result = methodName != null ? methodName.hashCode() : 0;\n+\t\tresult = 31 * result + (methodDesc != null ? methodDesc.hashCode() : 0);\n+\t\tresult = 31 * result + (signature != null ? signature.hashCode() : 0);\n+\t\tresult = 31 * result + (exceptions != null ? Arrays.hashCode(exceptions) : 0);\n+\t\treturn result;\n+\t}\n+}\n"
    },
    {
        "commit_hash": "1c0c4c430b1465e6bc2b8ce891545d634954d350",
        "previous_commit_hash": "374c4f27f931526e216b47a29437c6e03104a964",
        "diff_stats": {
            "additions": 37,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,37 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.defaultmethods;\n+\n+/**\n+* Created by arneball on 2014-08-23.\n+*/\n+class VisitedMethod {\n+\tpublic final String name, desc;\n+\n+\tVisitedMethod(String name, String desc) {\n+\t\tthis.name = name;\n+\t\tthis.desc = desc;\n+\t}\n+\n+\t@Override\n+\tpublic boolean equals(Object o) {\n+\t\tif (this == o) return true;\n+\t\tif (o == null || getClass() != o.getClass()) return false;\n+\n+\t\tVisitedMethod that = (VisitedMethod) o;\n+\n+\t\tif (!desc.equals(that.desc)) return false;\n+\t\tif (!name.equals(that.name)) return false;\n+\n+\t\treturn true;\n+\t}\n+\n+\t@Override\n+\tpublic int hashCode() {\n+\t\tint result = name.hashCode();\n+\t\tresult = 31 * result + desc.hashCode();\n+\t\treturn result;\n+\t}\n+}\n"
    },
    {
        "commit_hash": "643820b80598a4eb2255e3837983a4ad060cdcad",
        "previous_commit_hash": "1c0c4c430b1465e6bc2b8ce891545d634954d350",
        "diff_stats": {
            "additions": 270,
            "deletions": 0
        },
        "diff_content": "@@ -6,6 +6,8 @@ package net.orfjackal.retrolambda.test;\n \n import org.junit.Test;\n \n+import java.util.Comparator;\n+\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.is;\n \n@@ -36,4 +38,272 @@ public class DefaultMethodsTest {\n     public interface Child extends Parent {\n         String foo(); // refined return type\n     }\n+\n+\tpublic interface Parent2 {\n+\t\tdefault Object method() {\n+\t\t\treturn \"Parent\";\n+\t\t}\n+\t}\n+\n+\tpublic interface Child2 extends Parent2{\n+\t\t@Override\n+\t\tdefault String method() {\n+\t\t\treturn \"Child2\";\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void will_return_right_string() {\n+\t\tboolean sameStrings = new Child2() {\n+\n+\t\t}.method().equals(\"Child2\");\n+\t\tassertThat(\"they are equal\", sameStrings);\n+\t}\n+\n+\tinterface Primitives {\n+\t\tdefault int anInt() {\n+\t\t\treturn 1;\n+\t\t}\n+\t\tdefault short aShort() {\n+\t\t\treturn 2;\n+\t\t}\n+\t\tdefault long aLong() {\n+\t\t\treturn 1L << 50;\n+\t\t}\n+\t\tdefault boolean aBoolean() {\n+\t\t\treturn true;\n+\t\t}\n+\t\tdefault float aFloat() {\n+\t\t\treturn 0f;\n+\t\t}\n+\t\tdefault double aDouble() {\n+\t\t\treturn 0.0;\n+\t\t}\n+\t\tdefault void aVoid() {\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void primitives_run() {\n+\t\tPrimitives p = new Primitives() {\n+\t\t};\n+\t\tassertThat(\"booleans ok\", p.aBoolean());\n+\t\tassertThat(\"ints ok\", p.anInt() == 1);\n+\t\tassertThat(\"shorts ok\", p.aShort() == 2);\n+\t\tassertThat(\"longs ok\", p.aLong() == 1L << 50);\n+\t\tassertThat(\"floats ok\", p.aFloat() == 0f);\n+\t\tassertThat(\"doubles ok\", p.aDouble() == 0.0);\n+\t\tp.aVoid(); // would crash\n+\t}\n+\n+\tinterface Chaining {\n+\t\tdefault String myString() {\n+\t\t\treturn \"Interface\";\n+\t\t}\n+\t\tdefault String join(Chaining other) {\n+\t\t\treturn myString() + other.myString();\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void anonymous_instances() {\n+\t\tChaining c1 = new Chaining() {\n+\n+\t\t};\n+\t\tChaining c2 = new Chaining() {\n+\n+\t\t};\n+\t\tassertThat(\"Strings equals\", c1.join(c2).equals(\"InterfaceInterface\"));\n+\t\tChaining anon = new Chaining() {\n+\t\t\t@Override\n+\t\t\tpublic String myString() {\n+\t\t\t\treturn \"Anon\";\n+\t\t\t}\n+\t\t};\n+\t\tassertThat(\"Anonymous override equals\", c1.join(anon).equals(\"InterfaceAnon\"));\n+\t}\n+\n+\tinterface DeepParent {\n+\t\tdefault int level() {\n+\t\t\treturn 1;\n+\t\t}\n+\t}\n+\tinterface DeepChild extends DeepParent {\n+\t\t@Override\n+\t\tdefault int level() {\n+\t\t\treturn DeepParent.super.level() + 1;\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test_override_primitive() {\n+\t\tDeepChild d1 = new DeepChild() {\n+\n+\t\t};\n+\t\tassertThat(\"override works\", d1.level() == 2);\n+\t\tDeepChild d2 = new DeepChild() {\n+\t\t\t@Override\n+\t\t\tpublic int level() {\n+\t\t\t\treturn 1 + DeepChild.super.level();\n+\t\t\t}\n+\t\t};\n+\t\tassertThat(\"super call interface works\", d2.level() == 3);\n+\t}\n+\n+\tinterface Conflict1 {\n+\t\tdefault String confl() {\n+\t\t\treturn \"1\";\n+\t\t}\n+\t}\n+\n+\tinterface Conflict2 {\n+\t\tdefault String confl() {\n+\t\t\treturn \"2\";\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void will_handle_override_proprly() {\n+\t\tclass C implements Conflict1, Conflict2 {\n+\t\t\tpublic String confl() {\n+\t\t\t\treturn Conflict1.super.confl() + Conflict2.super.confl();\n+\t\t\t}\n+\t\t}\n+\t\tassertThat(\"Handles method conflict\", new C().confl().equals(\"12\"));\n+\t}\n+\n+\tinterface DeepParent2 {\n+\t\tint anInt();\n+\t\tdefault int method(DeepParent2 p1, DeepParent2 p2, DeepParent2 p3) {\n+\t\t\treturn p1.anInt() + p2.anInt() + p3.anInt() + anInt();\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void will_handle_long_paramlist() {\n+\t\tDeepParent2 dp = new DeepParent2() {\n+\t\t\t@Override\n+\t\t\tpublic int anInt() {\n+\t\t\t\treturn 2;\n+\t\t\t}\n+\t\t};\n+\t\tassertThat(\"Long call parameter list works\", dp.method(dp, dp, dp) == 8);\n+\t}\n+\n+\t\t@Test\n+\tpublic void will_handle_lambda() {\n+\t\tDeepParent2 dp = () -> 2;\n+\t\tassertThat(\"Long call parameter list with lambda works\", dp.method(dp, dp, dp) == 8);\n+\t}\n+\n+\tinterface BridgeTest<T> {\n+\t\tdefault T max(T t1, T t2, Comparator<? super T> comparator) {\n+\t\t\treturn comparator.compare(t1, t2) > 0 ? t1 : t2;\n+\t\t}\n+\t}\n+\n+\tinterface StringBridge extends BridgeTest<String> {\n+\t\tdefault boolean compare() {\n+\t\t\treturn max(\"A\", \"B\", String.CASE_INSENSITIVE_ORDER).equals(\"B\");\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void handles_bridge_methods() {\n+\t\tStringBridge sb = new StringBridge() {\n+\t\t};\n+\t\tassertThat(\"returns true\", sb.compare());\n+\t\tBridgeTest<String> sb2 = sb;\n+\t\tassertThat(\"still returns true\", sb2.max(\"A\", \"B\", String.CASE_INSENSITIVE_ORDER).equals(\"B\"));\n+\t}\n+\n+\tinterface MiddleParent {\n+\t\tdefault int anInt() {\n+\t\t\treturn 1;\n+\t\t}\n+\t}\n+\tinterface Middle2Parent extends MiddleParent{\n+\t\t@Override\n+\t\tdefault int anInt() {\n+\t\t\treturn 2;\n+\t\t}\n+\t}\n+\tinterface Middle3aParent extends MiddleParent, Middle2Parent {\n+\n+\t}\n+\tinterface Middle3bParent extends Middle2Parent, MiddleParent {\n+\n+\t}\n+\t@Test\n+\tpublic void right_method_chosen() {\n+\t\tassertThat(new Middle3aParent() {\n+\n+\t\t}.anInt(), is(2));\n+\n+\t\tassertThat(new Middle3bParent() {\n+\n+\t\t}.anInt(), is(2));\n+\t}\n+\n+\tinterface Top<T>  {\n+\t\tT anObject();\n+\t\tdefault int anInt() {\n+\t\t\treturn 1;\n+\t\t}\n+\t}\n+\n+\tinterface SubTop<T extends CharSequence> extends Top<T> {\n+\t\tdefault int anInt() {\n+\t\t\treturn Top.super.anInt() + 1;\n+\t\t}\n+\t}\n+\tinterface SubSub extends SubTop<String> {\n+\t\tdefault int anInt() {\n+\t\t\treturn SubTop.super.anInt() + 1;\n+\t\t}\n+\t\tdefault String anObject() {\n+\t\t\treturn \"0\";\n+\t\t}\n+\t}\n+\tinterface SubSub2 extends SubTop<String> {\n+\t\tdefault String anObject() {\n+\t\t\treturn \"1\";\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void yet_another_deep_hiearchy_test_with_bridges() {\n+\t\tassertThat(new SubSub2() {\n+\n+\t\t}.anInt(), is(2));\n+\n+\t\tassertThat(new SubSub() {\n+\n+\t\t}.anInt(), is(3));\n+\t\tSubSub sub = new SubSub() {\n+\n+\t\t};\n+\t\tassertThat(sub.anInt(), is(3));\n+\t\tTop<?> top = sub;\n+\t\tassertThat(\"is instanceof string\", top.anObject() instanceof String);\n+\t}\n+\n+\tinterface DefaultToStatic {\n+\t\tdefault int ifMeth() {\n+\t\t\treturn staticMeth();\n+\t\t}\n+\n+\t\tstatic int staticMeth() {\n+\t\t\treturn 3;\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void call_static_methods_from_default() {\n+\t\tDefaultToStatic i = new DefaultToStatic() {\n+\t\t};\n+\t\tassertThat(i.ifMeth(), is(3));\n+\t\tassertThat(DefaultToStatic.staticMeth(), is(3));\n+\t}\n+//\n }\n"
    },
    {
        "commit_hash": "e39c3f4c755485a6ed6fa9213d664bcf078488fc",
        "previous_commit_hash": "643820b80598a4eb2255e3837983a4ad060cdcad",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -49,7 +49,7 @@ public class ProcessClassesMojoTest {\n         assertThat(mojo.getJavaCommand(), is(new File(System.getProperty(\"java.home\"), \"bin/java\").getAbsolutePath()));\n     }\n \n-    @Test\n+/*    @Test\n     public void java_command_from_toolchain_overrides_the_current_jvm() {\n         toolchainManager.setJdkToolChain(new FakeJavaToolChain(\"jdk-from-toolchain\"));\n \n@@ -66,7 +66,7 @@ public class ProcessClassesMojoTest {\n         verify(log).warn(\"Toolchains are ignored, 'java8home' parameter is set to jdk-from-local-configuration\");\n     }\n \n-\n+*/\n     private static class FakeToolchainManager implements ToolchainManager {\n \n         private final Map<String, Toolchain> toolChainsByType = new HashMap<String, Toolchain>();\n"
    },
    {
        "commit_hash": "e39c3f4c755485a6ed6fa9213d664bcf078488fc",
        "previous_commit_hash": "643820b80598a4eb2255e3837983a4ad060cdcad",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -52,7 +52,7 @@\n                     </execution>\n                 </executions>\n                 <configuration>\n-                    <minimizeJar>true</minimizeJar>\n+                    <!-- <minimizeJar>true</minimizeJar>  --> <!-- http://jira.codehaus.org/browse/MSHADE-174 -->\n                     <relocations>\n                         <relocation>\n                             <pattern>org.objectweb.asm</pattern>\n"
    },
    {
        "commit_hash": "6792c3ef9b1ac7e473ecf7ca14d8d6967d3e9ace",
        "previous_commit_hash": "e39c3f4c755485a6ed6fa9213d664bcf078488fc",
        "diff_stats": {
            "additions": 6,
            "deletions": 6
        },
        "diff_content": "@@ -87,12 +87,12 @@ public class DefaultMethodsTest {\n \tpublic void primitives_run() {\n \t\tPrimitives p = new Primitives() {\n \t\t};\n-\t\tassertThat(\"booleans ok\", p.aBoolean());\n-\t\tassertThat(\"ints ok\", p.anInt() == 1);\n-\t\tassertThat(\"shorts ok\", p.aShort() == 2);\n-\t\tassertThat(\"longs ok\", p.aLong() == 1L << 50);\n-\t\tassertThat(\"floats ok\", p.aFloat() == 0f);\n-\t\tassertThat(\"doubles ok\", p.aDouble() == 0.0);\n+\t\tassertThat(p.aBoolean(), is(true));\n+\t\tassertThat(p.anInt(), is(1));\n+\t\tassertThat(p.aShort(), is((short)2));\n+\t\tassertThat(p.aLong(), is(1L << 50));\n+\t\tassertThat(p.aFloat(), is(0f));\n+\t\tassertThat(p.aDouble(), is(0.0));\n \t\tp.aVoid(); // would crash\n \t}\n \n"
    },
    {
        "commit_hash": "9038a86a72396e44b6f2d493b19cea63626f9c9c",
        "previous_commit_hash": "6792c3ef9b1ac7e473ecf7ca14d8d6967d3e9ace",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -49,7 +49,7 @@ public class ProcessClassesMojoTest {\n         assertThat(mojo.getJavaCommand(), is(new File(System.getProperty(\"java.home\"), \"bin/java\").getAbsolutePath()));\n     }\n \n-/*    @Test\n+    @Test\n     public void java_command_from_toolchain_overrides_the_current_jvm() {\n         toolchainManager.setJdkToolChain(new FakeJavaToolChain(\"jdk-from-toolchain\"));\n \n@@ -66,7 +66,7 @@ public class ProcessClassesMojoTest {\n         verify(log).warn(\"Toolchains are ignored, 'java8home' parameter is set to jdk-from-local-configuration\");\n     }\n \n-*/\n+\n     private static class FakeToolchainManager implements ToolchainManager {\n \n         private final Map<String, Toolchain> toolChainsByType = new HashMap<String, Toolchain>();\n"
    },
    {
        "commit_hash": "9038a86a72396e44b6f2d493b19cea63626f9c9c",
        "previous_commit_hash": "6792c3ef9b1ac7e473ecf7ca14d8d6967d3e9ace",
        "diff_stats": {
            "additions": 0,
            "deletions": 13
        },
        "diff_content": "@@ -39,19 +39,6 @@ public class Main {\n \n         try {\n             Thread.currentThread().setContextClassLoader(new URLClassLoader(asUrls(classpath)));\n-\t\t\t/**\n-\t\t\t * {\n-\t\t\t\t@Override\n-\t\t\t\tpublic Class<?> loadClass(String name) throws ClassNotFoundException {\n-\t\t\t\t\tClass<?> loadedClass = findLoadedClass(name);\n-\t\t\t\t\tif(loadedClass != null) {\n-\t\t\t\t\t\treturn loadedClass;\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\treturn super.loadClass(name);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\t */\n \n             visitFiles(inputDir, includedFiles, new BytecodeTransformingFileVisitor(inputDir, outputDir) {\n                 @Override\n"
    },
    {
        "commit_hash": "86028d1e52f98b6f3c31113e3cbdca5ff44efd98",
        "previous_commit_hash": "0ec45c6c1bab9db425dd91533478ad8ed2c697c6",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -85,7 +85,7 @@ To run Retrolambda using Maven, add the following to your pom.xml:\n <plugin>\n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>retrolambda-maven-plugin</artifactId>\n-    <version>1.6.0</version>\n+    <version>1.6.1</version>\n     <executions>\n         <execution>\n             <goals>\n@@ -149,7 +149,7 @@ package-private.\n Version History\n ---------------\n \n-### Upcoming\n+### Retrolambda 1.6.1 (2014-08-25)\n \n - Fixed a crash when trying backport classes that are part of the JRE, but\n   the JRE's class differs from the class being backported\n"
    },
    {
        "commit_hash": "86028d1e52f98b6f3c31113e3cbdca5ff44efd98",
        "previous_commit_hash": "0ec45c6c1bab9db425dd91533478ad8ed2c697c6",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.6.1-SNAPSHOT</version>\n+        <version>1.6.1</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "86028d1e52f98b6f3c31113e3cbdca5ff44efd98",
        "previous_commit_hash": "0ec45c6c1bab9db425dd91533478ad8ed2c697c6",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>1.6.1-SNAPSHOT</version>\n+    <version>1.6.1</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "86028d1e52f98b6f3c31113e3cbdca5ff44efd98",
        "previous_commit_hash": "0ec45c6c1bab9db425dd91533478ad8ed2c697c6",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.6.1-SNAPSHOT</version>\n+        <version>1.6.1</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "86028d1e52f98b6f3c31113e3cbdca5ff44efd98",
        "previous_commit_hash": "0ec45c6c1bab9db425dd91533478ad8ed2c697c6",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.6.1-SNAPSHOT</version>\n+        <version>1.6.1</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "86028d1e52f98b6f3c31113e3cbdca5ff44efd98",
        "previous_commit_hash": "0ec45c6c1bab9db425dd91533478ad8ed2c697c6",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.6.1-SNAPSHOT</version>\n+        <version>1.6.1</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "681a7c8bcb5f4ec694afea05e64df5cd09494ebc",
        "previous_commit_hash": "86028d1e52f98b6f3c31113e3cbdca5ff44efd98",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.6.1</version>\n+        <version>1.6.2-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "681a7c8bcb5f4ec694afea05e64df5cd09494ebc",
        "previous_commit_hash": "86028d1e52f98b6f3c31113e3cbdca5ff44efd98",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>1.6.1</version>\n+    <version>1.6.2-SNAPSHOT</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "681a7c8bcb5f4ec694afea05e64df5cd09494ebc",
        "previous_commit_hash": "86028d1e52f98b6f3c31113e3cbdca5ff44efd98",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.6.1</version>\n+        <version>1.6.2-SNAPSHOT</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "681a7c8bcb5f4ec694afea05e64df5cd09494ebc",
        "previous_commit_hash": "86028d1e52f98b6f3c31113e3cbdca5ff44efd98",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.6.1</version>\n+        <version>1.6.2-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "681a7c8bcb5f4ec694afea05e64df5cd09494ebc",
        "previous_commit_hash": "86028d1e52f98b6f3c31113e3cbdca5ff44efd98",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.6.1</version>\n+        <version>1.6.2-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "97b6bf7e102cd9d0fb4df34fd25ff2ee1b1695f6",
        "previous_commit_hash": "681a7c8bcb5f4ec694afea05e64df5cd09494ebc",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -151,8 +151,8 @@ Version History\n \n ### Retrolambda 1.6.1 (2014-08-25)\n \n-- Fixed a crash when trying backport classes that are part of the JRE, but\n-  the JRE's class differs from the class being backported\n+- Fixed a crash when trying backport classes which are nominally the same\n+  as those included in the JRE, but which have different bytecode\n   ([Issue #29](https://github.com/orfjackal/retrolambda/issues/29))\n \n ### Retrolambda 1.6.0 (2014-08-20)\n"
    },
    {
        "commit_hash": "7e6748492532fa972378086f69af4b25965e7524",
        "previous_commit_hash": "97b6bf7e102cd9d0fb4df34fd25ff2ee1b1695f6",
        "diff_stats": {
            "additions": 88,
            "deletions": 0
        },
        "diff_content": "@@ -3,16 +3,104 @@\n   <component name=\"ProjectCodeStyleSettingsManager\">\n     <option name=\"PER_PROJECT_SETTINGS\">\n       <value>\n+        <option name=\"OTHER_INDENT_OPTIONS\">\n+          <value>\n+            <option name=\"INDENT_SIZE\" value=\"4\" />\n+            <option name=\"CONTINUATION_INDENT_SIZE\" value=\"8\" />\n+            <option name=\"TAB_SIZE\" value=\"8\" />\n+            <option name=\"USE_TAB_CHARACTER\" value=\"false\" />\n+            <option name=\"SMART_TABS\" value=\"false\" />\n+            <option name=\"LABEL_INDENT_SIZE\" value=\"0\" />\n+            <option name=\"LABEL_INDENT_ABSOLUTE\" value=\"false\" />\n+            <option name=\"USE_RELATIVE_INDENTS\" value=\"false\" />\n+          </value>\n+        </option>\n+        <option name=\"LINE_SEPARATOR\" value=\"&#10;\" />\n+        <option name=\"CLASS_COUNT_TO_USE_IMPORT_ON_DEMAND\" value=\"2\" />\n+        <option name=\"NAMES_COUNT_TO_USE_IMPORT_ON_DEMAND\" value=\"2\" />\n+        <option name=\"HTML_ATTRIBUTE_WRAP\" value=\"0\" />\n+        <option name=\"IF_BRACE_FORCE\" value=\"3\" />\n+        <option name=\"DOWHILE_BRACE_FORCE\" value=\"3\" />\n+        <option name=\"WHILE_BRACE_FORCE\" value=\"3\" />\n+        <option name=\"FOR_BRACE_FORCE\" value=\"3\" />\n+        <option name=\"FIELD_ANNOTATION_WRAP\" value=\"0\" />\n         <XML>\n           <option name=\"XML_LEGACY_SETTINGS_IMPORTED\" value=\"true\" />\n         </XML>\n+        <ADDITIONAL_INDENT_OPTIONS fileType=\"txt\">\n+          <option name=\"INDENT_SIZE\" value=\"2\" />\n+        </ADDITIONAL_INDENT_OPTIONS>\n+        <codeStyleSettings language=\"ECMA Script Level 4\">\n+          <option name=\"IF_BRACE_FORCE\" value=\"3\" />\n+          <option name=\"DOWHILE_BRACE_FORCE\" value=\"3\" />\n+          <option name=\"WHILE_BRACE_FORCE\" value=\"3\" />\n+          <option name=\"FOR_BRACE_FORCE\" value=\"3\" />\n+          <option name=\"PARENT_SETTINGS_INSTALLED\" value=\"true\" />\n+        </codeStyleSettings>\n+        <codeStyleSettings language=\"GSP\">\n+          <indentOptions>\n+            <option name=\"INDENT_SIZE\" value=\"2\" />\n+          </indentOptions>\n+        </codeStyleSettings>\n+        <codeStyleSettings language=\"Groovy\">\n+          <option name=\"IF_BRACE_FORCE\" value=\"3\" />\n+          <option name=\"DOWHILE_BRACE_FORCE\" value=\"3\" />\n+          <option name=\"WHILE_BRACE_FORCE\" value=\"3\" />\n+          <option name=\"FOR_BRACE_FORCE\" value=\"3\" />\n+          <option name=\"FIELD_ANNOTATION_WRAP\" value=\"0\" />\n+          <option name=\"PARENT_SETTINGS_INSTALLED\" value=\"true\" />\n+          <indentOptions>\n+            <option name=\"INDENT_SIZE\" value=\"2\" />\n+          </indentOptions>\n+        </codeStyleSettings>\n         <codeStyleSettings language=\"JAVA\">\n+          <option name=\"IF_BRACE_FORCE\" value=\"3\" />\n+          <option name=\"DOWHILE_BRACE_FORCE\" value=\"3\" />\n+          <option name=\"WHILE_BRACE_FORCE\" value=\"3\" />\n+          <option name=\"FOR_BRACE_FORCE\" value=\"3\" />\n+          <option name=\"FIELD_ANNOTATION_WRAP\" value=\"0\" />\n+          <option name=\"PARENT_SETTINGS_INSTALLED\" value=\"true\" />\n+          <indentOptions>\n+            <option name=\"TAB_SIZE\" value=\"8\" />\n+          </indentOptions>\n+        </codeStyleSettings>\n+        <codeStyleSettings language=\"JavaScript\">\n+          <option name=\"IF_BRACE_FORCE\" value=\"3\" />\n+          <option name=\"DOWHILE_BRACE_FORCE\" value=\"3\" />\n+          <option name=\"WHILE_BRACE_FORCE\" value=\"3\" />\n+          <option name=\"FOR_BRACE_FORCE\" value=\"3\" />\n+          <option name=\"PARENT_SETTINGS_INSTALLED\" value=\"true\" />\n           <indentOptions>\n             <option name=\"TAB_SIZE\" value=\"8\" />\n           </indentOptions>\n         </codeStyleSettings>\n+        <codeStyleSettings language=\"Scala\">\n+          <option name=\"IF_BRACE_FORCE\" value=\"3\" />\n+          <option name=\"DOWHILE_BRACE_FORCE\" value=\"3\" />\n+          <option name=\"WHILE_BRACE_FORCE\" value=\"3\" />\n+          <option name=\"FOR_BRACE_FORCE\" value=\"3\" />\n+          <option name=\"FIELD_ANNOTATION_WRAP\" value=\"0\" />\n+          <option name=\"PARENT_SETTINGS_INSTALLED\" value=\"true\" />\n+          <indentOptions>\n+            <option name=\"CONTINUATION_INDENT_SIZE\" value=\"8\" />\n+            <option name=\"TAB_SIZE\" value=\"8\" />\n+          </indentOptions>\n+        </codeStyleSettings>\n+        <codeStyleSettings language=\"XML\">\n+          <indentOptions>\n+            <option name=\"TAB_SIZE\" value=\"8\" />\n+          </indentOptions>\n+        </codeStyleSettings>\n+        <codeStyleSettings language=\"ruby\">\n+          <indentOptions>\n+            <option name=\"CONTINUATION_INDENT_SIZE\" value=\"8\" />\n+            <option name=\"TAB_SIZE\" value=\"4\" />\n+            <option name=\"USE_RELATIVE_INDENTS\" value=\"false\" />\n+          </indentOptions>\n+        </codeStyleSettings>\n       </value>\n     </option>\n+    <option name=\"USE_PER_PROJECT_SETTINGS\" value=\"true\" />\n   </component>\n </project>\n \n"
    },
    {
        "commit_hash": "67d9a74829232fd62e45901baa462c71ccd9d827",
        "previous_commit_hash": "7e6748492532fa972378086f69af4b25965e7524",
        "diff_stats": {
            "additions": 12,
            "deletions": 13
        },
        "diff_content": "@@ -1,19 +1,18 @@\n #!/bin/bash\n set -eu\n-: ${1:? Usage: $0 DESCRIPTION}\n+: ${2:? Usage: $0 DESCRIPTION VERSION}\n DESCRIPTION=\"$1\"\n+VERSION=\"$2\"\n set -x\n \n-# TODO: release OSSRH and push to GitHub automatically\n-#mvn nexus-staging:release \\\n-#    --errors \\\n-#    -DaltStagingDirectory=staging \\\n-#    -DstagingDescription=\"$DESCRIPTION\"\n+mvn nexus-staging:release \\\n+    --errors \\\n+    -DaltStagingDirectory=staging \\\n+    -DstagingDescription=\"$DESCRIPTION\"\n \n-set +x\n-echo \"\"\n-echo \"Done. Next steps:\"\n-echo \"    open https://oss.sonatype.org/\"\n-echo \"    git push origin HEAD\"\n-echo \"    git push origin --tags\"\n-echo \"    cd ../retrolambda.pages; ./update-maven-site.sh VERSION; git push\"\n+git push origin HEAD\n+git push origin --tags\n+\n+cd ../retrolambda.pages\n+./update-maven-site.sh \"$VERSION\"\n+git push\n"
    },
    {
        "commit_hash": "67d9a74829232fd62e45901baa462c71ccd9d827",
        "previous_commit_hash": "7e6748492532fa972378086f69af4b25965e7524",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -68,4 +68,4 @@ set-project-version \"$NEXT_VERSION\"\n git add -u\n git commit -m \"Prepare for next development iteration\"\n \n-$SCRIPTS/publish.sh \"$APP_NAME $RELEASE_VERSION\"\n+$SCRIPTS/publish.sh \"$APP_NAME $RELEASE_VERSION\" \"$RELEASE_VERSION\"\n"
    },
    {
        "commit_hash": "85426672cd8ddb0a29d65df226cb4e430684660d",
        "previous_commit_hash": "9038a86a72396e44b6f2d493b19cea63626f9c9c",
        "diff_stats": {
            "additions": 283,
            "deletions": 267
        },
        "diff_content": "@@ -39,271 +39,287 @@ public class DefaultMethodsTest {\n         String foo(); // refined return type\n     }\n \n-\tpublic interface Parent2 {\n-\t\tdefault Object method() {\n-\t\t\treturn \"Parent\";\n-\t\t}\n-\t}\n-\n-\tpublic interface Child2 extends Parent2{\n-\t\t@Override\n-\t\tdefault String method() {\n-\t\t\treturn \"Child2\";\n-\t\t}\n-\t}\n-\n-\t@Test\n-\tpublic void will_return_right_string() {\n-\t\tboolean sameStrings = new Child2() {\n-\n-\t\t}.method().equals(\"Child2\");\n-\t\tassertThat(\"they are equal\", sameStrings);\n-\t}\n-\n-\tinterface Primitives {\n-\t\tdefault int anInt() {\n-\t\t\treturn 1;\n-\t\t}\n-\t\tdefault short aShort() {\n-\t\t\treturn 2;\n-\t\t}\n-\t\tdefault long aLong() {\n-\t\t\treturn 1L << 50;\n-\t\t}\n-\t\tdefault boolean aBoolean() {\n-\t\t\treturn true;\n-\t\t}\n-\t\tdefault float aFloat() {\n-\t\t\treturn 0f;\n-\t\t}\n-\t\tdefault double aDouble() {\n-\t\t\treturn 0.0;\n-\t\t}\n-\t\tdefault void aVoid() {\n-\t\t}\n-\t}\n-\n-\t@Test\n-\tpublic void primitives_run() {\n-\t\tPrimitives p = new Primitives() {\n-\t\t};\n-\t\tassertThat(p.aBoolean(), is(true));\n-\t\tassertThat(p.anInt(), is(1));\n-\t\tassertThat(p.aShort(), is((short)2));\n-\t\tassertThat(p.aLong(), is(1L << 50));\n-\t\tassertThat(p.aFloat(), is(0f));\n-\t\tassertThat(p.aDouble(), is(0.0));\n-\t\tp.aVoid(); // would crash\n-\t}\n-\n-\tinterface Chaining {\n-\t\tdefault String myString() {\n-\t\t\treturn \"Interface\";\n-\t\t}\n-\t\tdefault String join(Chaining other) {\n-\t\t\treturn myString() + other.myString();\n-\t\t}\n-\t}\n-\n-\t@Test\n-\tpublic void anonymous_instances() {\n-\t\tChaining c1 = new Chaining() {\n-\n-\t\t};\n-\t\tChaining c2 = new Chaining() {\n-\n-\t\t};\n-\t\tassertThat(\"Strings equals\", c1.join(c2).equals(\"InterfaceInterface\"));\n-\t\tChaining anon = new Chaining() {\n-\t\t\t@Override\n-\t\t\tpublic String myString() {\n-\t\t\t\treturn \"Anon\";\n-\t\t\t}\n-\t\t};\n-\t\tassertThat(\"Anonymous override equals\", c1.join(anon).equals(\"InterfaceAnon\"));\n-\t}\n-\n-\tinterface DeepParent {\n-\t\tdefault int level() {\n-\t\t\treturn 1;\n-\t\t}\n-\t}\n-\tinterface DeepChild extends DeepParent {\n-\t\t@Override\n-\t\tdefault int level() {\n-\t\t\treturn DeepParent.super.level() + 1;\n-\t\t}\n-\t}\n-\n-\t@Test\n-\tpublic void test_override_primitive() {\n-\t\tDeepChild d1 = new DeepChild() {\n-\n-\t\t};\n-\t\tassertThat(\"override works\", d1.level() == 2);\n-\t\tDeepChild d2 = new DeepChild() {\n-\t\t\t@Override\n-\t\t\tpublic int level() {\n-\t\t\t\treturn 1 + DeepChild.super.level();\n-\t\t\t}\n-\t\t};\n-\t\tassertThat(\"super call interface works\", d2.level() == 3);\n-\t}\n-\n-\tinterface Conflict1 {\n-\t\tdefault String confl() {\n-\t\t\treturn \"1\";\n-\t\t}\n-\t}\n-\n-\tinterface Conflict2 {\n-\t\tdefault String confl() {\n-\t\t\treturn \"2\";\n-\t\t}\n-\t}\n-\n-\t@Test\n-\tpublic void will_handle_override_proprly() {\n-\t\tclass C implements Conflict1, Conflict2 {\n-\t\t\tpublic String confl() {\n-\t\t\t\treturn Conflict1.super.confl() + Conflict2.super.confl();\n-\t\t\t}\n-\t\t}\n-\t\tassertThat(\"Handles method conflict\", new C().confl().equals(\"12\"));\n-\t}\n-\n-\tinterface DeepParent2 {\n-\t\tint anInt();\n-\t\tdefault int method(DeepParent2 p1, DeepParent2 p2, DeepParent2 p3) {\n-\t\t\treturn p1.anInt() + p2.anInt() + p3.anInt() + anInt();\n-\t\t}\n-\t}\n-\n-\t@Test\n-\tpublic void will_handle_long_paramlist() {\n-\t\tDeepParent2 dp = new DeepParent2() {\n-\t\t\t@Override\n-\t\t\tpublic int anInt() {\n-\t\t\t\treturn 2;\n-\t\t\t}\n-\t\t};\n-\t\tassertThat(\"Long call parameter list works\", dp.method(dp, dp, dp) == 8);\n-\t}\n-\n-\t\t@Test\n-\tpublic void will_handle_lambda() {\n-\t\tDeepParent2 dp = () -> 2;\n-\t\tassertThat(\"Long call parameter list with lambda works\", dp.method(dp, dp, dp) == 8);\n-\t}\n-\n-\tinterface BridgeTest<T> {\n-\t\tdefault T max(T t1, T t2, Comparator<? super T> comparator) {\n-\t\t\treturn comparator.compare(t1, t2) > 0 ? t1 : t2;\n-\t\t}\n-\t}\n-\n-\tinterface StringBridge extends BridgeTest<String> {\n-\t\tdefault boolean compare() {\n-\t\t\treturn max(\"A\", \"B\", String.CASE_INSENSITIVE_ORDER).equals(\"B\");\n-\t\t}\n-\t}\n-\n-\t@Test\n-\tpublic void handles_bridge_methods() {\n-\t\tStringBridge sb = new StringBridge() {\n-\t\t};\n-\t\tassertThat(\"returns true\", sb.compare());\n-\t\tBridgeTest<String> sb2 = sb;\n-\t\tassertThat(\"still returns true\", sb2.max(\"A\", \"B\", String.CASE_INSENSITIVE_ORDER).equals(\"B\"));\n-\t}\n-\n-\tinterface MiddleParent {\n-\t\tdefault int anInt() {\n-\t\t\treturn 1;\n-\t\t}\n-\t}\n-\tinterface Middle2Parent extends MiddleParent{\n-\t\t@Override\n-\t\tdefault int anInt() {\n-\t\t\treturn 2;\n-\t\t}\n-\t}\n-\tinterface Middle3aParent extends MiddleParent, Middle2Parent {\n-\n-\t}\n-\tinterface Middle3bParent extends Middle2Parent, MiddleParent {\n-\n-\t}\n-\t@Test\n-\tpublic void right_method_chosen() {\n-\t\tassertThat(new Middle3aParent() {\n-\n-\t\t}.anInt(), is(2));\n-\n-\t\tassertThat(new Middle3bParent() {\n-\n-\t\t}.anInt(), is(2));\n-\t}\n-\n-\tinterface Top<T>  {\n-\t\tT anObject();\n-\t\tdefault int anInt() {\n-\t\t\treturn 1;\n-\t\t}\n-\t}\n-\n-\tinterface SubTop<T extends CharSequence> extends Top<T> {\n-\t\tdefault int anInt() {\n-\t\t\treturn Top.super.anInt() + 1;\n-\t\t}\n-\t}\n-\tinterface SubSub extends SubTop<String> {\n-\t\tdefault int anInt() {\n-\t\t\treturn SubTop.super.anInt() + 1;\n-\t\t}\n-\t\tdefault String anObject() {\n-\t\t\treturn \"0\";\n-\t\t}\n-\t}\n-\tinterface SubSub2 extends SubTop<String> {\n-\t\tdefault String anObject() {\n-\t\t\treturn \"1\";\n-\t\t}\n-\t}\n-\n-\t@Test\n-\tpublic void yet_another_deep_hiearchy_test_with_bridges() {\n-\t\tassertThat(new SubSub2() {\n-\n-\t\t}.anInt(), is(2));\n-\n-\t\tassertThat(new SubSub() {\n-\n-\t\t}.anInt(), is(3));\n-\t\tSubSub sub = new SubSub() {\n-\n-\t\t};\n-\t\tassertThat(sub.anInt(), is(3));\n-\t\tTop<?> top = sub;\n-\t\tassertThat(\"is instanceof string\", top.anObject() instanceof String);\n-\t}\n-\n-\tinterface DefaultToStatic {\n-\t\tdefault int ifMeth() {\n-\t\t\treturn staticMeth();\n-\t\t}\n-\n-\t\tstatic int staticMeth() {\n-\t\t\treturn 3;\n-\t\t}\n-\t}\n-\n-\t@Test\n-\tpublic void call_static_methods_from_default() {\n-\t\tDefaultToStatic i = new DefaultToStatic() {\n-\t\t};\n-\t\tassertThat(i.ifMeth(), is(3));\n-\t\tassertThat(DefaultToStatic.staticMeth(), is(3));\n-\t}\n-//\n+    public interface Parent2 {\n+        default Object method() {\n+            return \"Parent\";\n+        }\n+    }\n+\n+    public interface Child2 extends Parent2 {\n+        @Override\n+        default String method() {\n+            return \"Child2\";\n+        }\n+    }\n+\n+    @Test\n+    public void will_return_right_string() {\n+        boolean sameStrings = new Child2() {\n+\n+        }.method().equals(\"Child2\");\n+        assertThat(\"they are equal\", sameStrings);\n+    }\n+\n+    interface Primitives {\n+        default int anInt() {\n+            return 1;\n+        }\n+\n+        default short aShort() {\n+            return 2;\n+        }\n+\n+        default long aLong() {\n+            return 1L << 50;\n+        }\n+\n+        default boolean aBoolean() {\n+            return true;\n+        }\n+\n+        default float aFloat() {\n+            return 0f;\n+        }\n+\n+        default double aDouble() {\n+            return 0.0;\n+        }\n+\n+        default void aVoid() {\n+        }\n+    }\n+\n+    @Test\n+    public void primitives_run() {\n+        Primitives p = new Primitives() {\n+        };\n+        assertThat(p.aBoolean(), is(true));\n+        assertThat(p.anInt(), is(1));\n+        assertThat(p.aShort(), is((short) 2));\n+        assertThat(p.aLong(), is(1L << 50));\n+        assertThat(p.aFloat(), is(0f));\n+        assertThat(p.aDouble(), is(0.0));\n+        p.aVoid(); // would crash\n+    }\n+\n+    interface Chaining {\n+        default String myString() {\n+            return \"Interface\";\n+        }\n+\n+        default String join(Chaining other) {\n+            return myString() + other.myString();\n+        }\n+    }\n+\n+    @Test\n+    public void anonymous_instances() {\n+        Chaining c1 = new Chaining() {\n+\n+        };\n+        Chaining c2 = new Chaining() {\n+\n+        };\n+        assertThat(\"Strings equals\", c1.join(c2).equals(\"InterfaceInterface\"));\n+        Chaining anon = new Chaining() {\n+            @Override\n+            public String myString() {\n+                return \"Anon\";\n+            }\n+        };\n+        assertThat(\"Anonymous override equals\", c1.join(anon).equals(\"InterfaceAnon\"));\n+    }\n+\n+    interface DeepParent {\n+        default int level() {\n+            return 1;\n+        }\n+    }\n+\n+    interface DeepChild extends DeepParent {\n+        @Override\n+        default int level() {\n+            return DeepParent.super.level() + 1;\n+        }\n+    }\n+\n+    @Test\n+    public void test_override_primitive() {\n+        DeepChild d1 = new DeepChild() {\n+\n+        };\n+        assertThat(\"override works\", d1.level() == 2);\n+        DeepChild d2 = new DeepChild() {\n+            @Override\n+            public int level() {\n+                return 1 + DeepChild.super.level();\n+            }\n+        };\n+        assertThat(\"super call interface works\", d2.level() == 3);\n+    }\n+\n+    interface Conflict1 {\n+        default String confl() {\n+            return \"1\";\n+        }\n+    }\n+\n+    interface Conflict2 {\n+        default String confl() {\n+            return \"2\";\n+        }\n+    }\n+\n+    @Test\n+    public void will_handle_override_proprly() {\n+        class C implements Conflict1, Conflict2 {\n+            public String confl() {\n+                return Conflict1.super.confl() + Conflict2.super.confl();\n+            }\n+        }\n+        assertThat(\"Handles method conflict\", new C().confl().equals(\"12\"));\n+    }\n+\n+    interface DeepParent2 {\n+        int anInt();\n+\n+        default int method(DeepParent2 p1, DeepParent2 p2, DeepParent2 p3) {\n+            return p1.anInt() + p2.anInt() + p3.anInt() + anInt();\n+        }\n+    }\n+\n+    @Test\n+    public void will_handle_long_paramlist() {\n+        DeepParent2 dp = new DeepParent2() {\n+            @Override\n+            public int anInt() {\n+                return 2;\n+            }\n+        };\n+        assertThat(\"Long call parameter list works\", dp.method(dp, dp, dp) == 8);\n+    }\n+\n+    @Test\n+    public void will_handle_lambda() {\n+        DeepParent2 dp = () -> 2;\n+        assertThat(\"Long call parameter list with lambda works\", dp.method(dp, dp, dp) == 8);\n+    }\n+\n+    interface BridgeTest<T> {\n+        default T max(T t1, T t2, Comparator<? super T> comparator) {\n+            return comparator.compare(t1, t2) > 0 ? t1 : t2;\n+        }\n+    }\n+\n+    interface StringBridge extends BridgeTest<String> {\n+        default boolean compare() {\n+            return max(\"A\", \"B\", String.CASE_INSENSITIVE_ORDER).equals(\"B\");\n+        }\n+    }\n+\n+    @Test\n+    public void handles_bridge_methods() {\n+        StringBridge sb = new StringBridge() {\n+        };\n+        assertThat(\"returns true\", sb.compare());\n+        BridgeTest<String> sb2 = sb;\n+        assertThat(\"still returns true\", sb2.max(\"A\", \"B\", String.CASE_INSENSITIVE_ORDER).equals(\"B\"));\n+    }\n+\n+    interface MiddleParent {\n+        default int anInt() {\n+            return 1;\n+        }\n+    }\n+\n+    interface Middle2Parent extends MiddleParent {\n+        @Override\n+        default int anInt() {\n+            return 2;\n+        }\n+    }\n+\n+    interface Middle3aParent extends MiddleParent, Middle2Parent {\n+\n+    }\n+\n+    interface Middle3bParent extends Middle2Parent, MiddleParent {\n+\n+    }\n+\n+    @Test\n+    public void right_method_chosen() {\n+        assertThat(new Middle3aParent() {\n+\n+        }.anInt(), is(2));\n+\n+        assertThat(new Middle3bParent() {\n+\n+        }.anInt(), is(2));\n+    }\n+\n+    interface Top<T> {\n+        T anObject();\n+\n+        default int anInt() {\n+            return 1;\n+        }\n+    }\n+\n+    interface SubTop<T extends CharSequence> extends Top<T> {\n+        default int anInt() {\n+            return Top.super.anInt() + 1;\n+        }\n+    }\n+\n+    interface SubSub extends SubTop<String> {\n+        default int anInt() {\n+            return SubTop.super.anInt() + 1;\n+        }\n+\n+        default String anObject() {\n+            return \"0\";\n+        }\n+    }\n+\n+    interface SubSub2 extends SubTop<String> {\n+        default String anObject() {\n+            return \"1\";\n+        }\n+    }\n+\n+    @Test\n+    public void yet_another_deep_hiearchy_test_with_bridges() {\n+        assertThat(new SubSub2() {\n+\n+        }.anInt(), is(2));\n+\n+        assertThat(new SubSub() {\n+\n+        }.anInt(), is(3));\n+        SubSub sub = new SubSub() {\n+\n+        };\n+        assertThat(sub.anInt(), is(3));\n+        Top<?> top = sub;\n+        assertThat(\"is instanceof string\", top.anObject() instanceof String);\n+    }\n+\n+    interface DefaultToStatic {\n+        default int ifMeth() {\n+            return staticMeth();\n+        }\n+\n+        static int staticMeth() {\n+            return 3;\n+        }\n+    }\n+\n+    @Test\n+    public void call_static_methods_from_default() {\n+        DefaultToStatic i = new DefaultToStatic() {\n+        };\n+        assertThat(i.ifMeth(), is(3));\n+        assertThat(DefaultToStatic.staticMeth(), is(3));\n+    }\n }\n"
    },
    {
        "commit_hash": "a4bdd6f054c3e3a119c0b8df3d8b5fde5ca5f61d",
        "previous_commit_hash": "85426672cd8ddb0a29d65df226cb4e430684660d",
        "diff_stats": {
            "additions": 97,
            "deletions": 88
        },
        "diff_content": "@@ -39,6 +39,15 @@ public class DefaultMethodsTest {\n         String foo(); // refined return type\n     }\n \n+\n+    @Test\n+    public void will_return_right_string() {\n+        boolean sameStrings = new Child2() {\n+\n+        }.method().equals(\"Child2\");\n+        assertThat(\"they are equal\", sameStrings);\n+    }\n+\n     public interface Parent2 {\n         default Object method() {\n             return \"Parent\";\n@@ -52,15 +61,21 @@ public class DefaultMethodsTest {\n         }\n     }\n \n-    @Test\n-    public void will_return_right_string() {\n-        boolean sameStrings = new Child2() {\n \n-        }.method().equals(\"Child2\");\n-        assertThat(\"they are equal\", sameStrings);\n+    @Test\n+    public void primitives_run() {\n+        Primitives p = new Primitives() {\n+        };\n+        assertThat(p.aBoolean(), is(true));\n+        assertThat(p.anInt(), is(1));\n+        assertThat(p.aShort(), is((short) 2));\n+        assertThat(p.aLong(), is(1L << 50));\n+        assertThat(p.aFloat(), is(0f));\n+        assertThat(p.aDouble(), is(0.0));\n+        p.aVoid(); // would crash\n     }\n \n-    interface Primitives {\n+    public interface Primitives {\n         default int anInt() {\n             return 1;\n         }\n@@ -89,28 +104,6 @@ public class DefaultMethodsTest {\n         }\n     }\n \n-    @Test\n-    public void primitives_run() {\n-        Primitives p = new Primitives() {\n-        };\n-        assertThat(p.aBoolean(), is(true));\n-        assertThat(p.anInt(), is(1));\n-        assertThat(p.aShort(), is((short) 2));\n-        assertThat(p.aLong(), is(1L << 50));\n-        assertThat(p.aFloat(), is(0f));\n-        assertThat(p.aDouble(), is(0.0));\n-        p.aVoid(); // would crash\n-    }\n-\n-    interface Chaining {\n-        default String myString() {\n-            return \"Interface\";\n-        }\n-\n-        default String join(Chaining other) {\n-            return myString() + other.myString();\n-        }\n-    }\n \n     @Test\n     public void anonymous_instances() {\n@@ -130,19 +123,17 @@ public class DefaultMethodsTest {\n         assertThat(\"Anonymous override equals\", c1.join(anon).equals(\"InterfaceAnon\"));\n     }\n \n-    interface DeepParent {\n-        default int level() {\n-            return 1;\n+    public interface Chaining {\n+        default String myString() {\n+            return \"Interface\";\n         }\n-    }\n \n-    interface DeepChild extends DeepParent {\n-        @Override\n-        default int level() {\n-            return DeepParent.super.level() + 1;\n+        default String join(Chaining other) {\n+            return myString() + other.myString();\n         }\n     }\n \n+\n     @Test\n     public void test_override_primitive() {\n         DeepChild d1 = new DeepChild() {\n@@ -158,18 +149,20 @@ public class DefaultMethodsTest {\n         assertThat(\"super call interface works\", d2.level() == 3);\n     }\n \n-    interface Conflict1 {\n-        default String confl() {\n-            return \"1\";\n+    public interface DeepParent {\n+        default int level() {\n+            return 1;\n         }\n     }\n \n-    interface Conflict2 {\n-        default String confl() {\n-            return \"2\";\n+    public interface DeepChild extends DeepParent {\n+        @Override\n+        default int level() {\n+            return DeepParent.super.level() + 1;\n         }\n     }\n \n+\n     @Test\n     public void will_handle_override_proprly() {\n         class C implements Conflict1, Conflict2 {\n@@ -180,14 +173,19 @@ public class DefaultMethodsTest {\n         assertThat(\"Handles method conflict\", new C().confl().equals(\"12\"));\n     }\n \n-    interface DeepParent2 {\n-        int anInt();\n+    interface Conflict1 {\n+        default String confl() {\n+            return \"1\";\n+        }\n+    }\n \n-        default int method(DeepParent2 p1, DeepParent2 p2, DeepParent2 p3) {\n-            return p1.anInt() + p2.anInt() + p3.anInt() + anInt();\n+    interface Conflict2 {\n+        default String confl() {\n+            return \"2\";\n         }\n     }\n \n+\n     @Test\n     public void will_handle_long_paramlist() {\n         DeepParent2 dp = new DeepParent2() {\n@@ -199,12 +197,31 @@ public class DefaultMethodsTest {\n         assertThat(\"Long call parameter list works\", dp.method(dp, dp, dp) == 8);\n     }\n \n+    public interface DeepParent2 {\n+        int anInt();\n+\n+        default int method(DeepParent2 p1, DeepParent2 p2, DeepParent2 p3) {\n+            return p1.anInt() + p2.anInt() + p3.anInt() + anInt();\n+        }\n+    }\n+\n+\n     @Test\n     public void will_handle_lambda() {\n         DeepParent2 dp = () -> 2;\n         assertThat(\"Long call parameter list with lambda works\", dp.method(dp, dp, dp) == 8);\n     }\n \n+\n+    @Test\n+    public void handles_bridge_methods() {\n+        StringBridge sb = new StringBridge() {\n+        };\n+        assertThat(\"returns true\", sb.compare());\n+        BridgeTest<String> sb2 = sb;\n+        assertThat(\"still returns true\", sb2.max(\"A\", \"B\", String.CASE_INSENSITIVE_ORDER).equals(\"B\"));\n+    }\n+\n     interface BridgeTest<T> {\n         default T max(T t1, T t2, Comparator<? super T> comparator) {\n             return comparator.compare(t1, t2) > 0 ? t1 : t2;\n@@ -217,48 +234,56 @@ public class DefaultMethodsTest {\n         }\n     }\n \n+\n     @Test\n-    public void handles_bridge_methods() {\n-        StringBridge sb = new StringBridge() {\n-        };\n-        assertThat(\"returns true\", sb.compare());\n-        BridgeTest<String> sb2 = sb;\n-        assertThat(\"still returns true\", sb2.max(\"A\", \"B\", String.CASE_INSENSITIVE_ORDER).equals(\"B\"));\n+    public void right_method_chosen() {\n+        assertThat(new Middle3aParent() {\n+\n+        }.anInt(), is(2));\n+\n+        assertThat(new Middle3bParent() {\n+\n+        }.anInt(), is(2));\n     }\n \n-    interface MiddleParent {\n+    public interface MiddleParent {\n         default int anInt() {\n             return 1;\n         }\n     }\n \n-    interface Middle2Parent extends MiddleParent {\n+    public interface Middle2Parent extends MiddleParent {\n         @Override\n         default int anInt() {\n             return 2;\n         }\n     }\n \n-    interface Middle3aParent extends MiddleParent, Middle2Parent {\n-\n+    public interface Middle3aParent extends MiddleParent, Middle2Parent {\n     }\n \n-    interface Middle3bParent extends Middle2Parent, MiddleParent {\n-\n+    public interface Middle3bParent extends Middle2Parent, MiddleParent {\n     }\n \n+\n     @Test\n-    public void right_method_chosen() {\n-        assertThat(new Middle3aParent() {\n+    public void yet_another_deep_hiearchy_test_with_bridges() {\n+        assertThat(new SubSub2() {\n \n         }.anInt(), is(2));\n \n-        assertThat(new Middle3bParent() {\n+        assertThat(new SubSub() {\n \n-        }.anInt(), is(2));\n+        }.anInt(), is(3));\n+        SubSub sub = new SubSub() {\n+\n+        };\n+        assertThat(sub.anInt(), is(3));\n+        Top<?> top = sub;\n+        assertThat(\"is instanceof string\", top.anObject() instanceof String);\n     }\n \n-    interface Top<T> {\n+    public interface Top<T> {\n         T anObject();\n \n         default int anInt() {\n@@ -266,13 +291,13 @@ public class DefaultMethodsTest {\n         }\n     }\n \n-    interface SubTop<T extends CharSequence> extends Top<T> {\n+    public interface SubTop<T extends CharSequence> extends Top<T> {\n         default int anInt() {\n             return Top.super.anInt() + 1;\n         }\n     }\n \n-    interface SubSub extends SubTop<String> {\n+    public interface SubSub extends SubTop<String> {\n         default int anInt() {\n             return SubTop.super.anInt() + 1;\n         }\n@@ -282,30 +307,22 @@ public class DefaultMethodsTest {\n         }\n     }\n \n-    interface SubSub2 extends SubTop<String> {\n+    public interface SubSub2 extends SubTop<String> {\n         default String anObject() {\n             return \"1\";\n         }\n     }\n \n-    @Test\n-    public void yet_another_deep_hiearchy_test_with_bridges() {\n-        assertThat(new SubSub2() {\n-\n-        }.anInt(), is(2));\n-\n-        assertThat(new SubSub() {\n-\n-        }.anInt(), is(3));\n-        SubSub sub = new SubSub() {\n \n+    @Test\n+    public void call_static_methods_from_default() {\n+        DefaultToStatic i = new DefaultToStatic() {\n         };\n-        assertThat(sub.anInt(), is(3));\n-        Top<?> top = sub;\n-        assertThat(\"is instanceof string\", top.anObject() instanceof String);\n+        assertThat(i.ifMeth(), is(3));\n+        assertThat(DefaultToStatic.staticMeth(), is(3));\n     }\n \n-    interface DefaultToStatic {\n+    public interface DefaultToStatic {\n         default int ifMeth() {\n             return staticMeth();\n         }\n@@ -314,12 +331,4 @@ public class DefaultMethodsTest {\n             return 3;\n         }\n     }\n-\n-    @Test\n-    public void call_static_methods_from_default() {\n-        DefaultToStatic i = new DefaultToStatic() {\n-        };\n-        assertThat(i.ifMeth(), is(3));\n-        assertThat(DefaultToStatic.staticMeth(), is(3));\n-    }\n }\n"
    },
    {
        "commit_hash": "bc99e75c2fa4b56325910e445283d1b24cb2618d",
        "previous_commit_hash": "a4bdd6f054c3e3a119c0b8df3d8b5fde5ca5f61d",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,13 @@\n+<component name=\"libraryTable\">\n+  <library name=\"Maven: commons-lang:commons-lang:2.6\">\n+    <CLASSES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/commons-lang/commons-lang/2.6/commons-lang-2.6.jar!/\" />\n+    </CLASSES>\n+    <JAVADOC>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/commons-lang/commons-lang/2.6/commons-lang-2.6-javadoc.jar!/\" />\n+    </JAVADOC>\n+    <SOURCES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/commons-lang/commons-lang/2.6/commons-lang-2.6-sources.jar!/\" />\n+    </SOURCES>\n+  </library>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "bc99e75c2fa4b56325910e445283d1b24cb2618d",
        "previous_commit_hash": "a4bdd6f054c3e3a119c0b8df3d8b5fde5ca5f61d",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -12,6 +12,7 @@\n     <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n     <orderEntry type=\"library\" name=\"Maven: com.google.guava:guava:11.0.2\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: com.google.code.findbugs:jsr305:1.3.9\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: commons-lang:commons-lang:2.6\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.11\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-library:1.3\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-core:1.3\" level=\"project\" />\n"
    },
    {
        "commit_hash": "bc99e75c2fa4b56325910e445283d1b24cb2618d",
        "previous_commit_hash": "a4bdd6f054c3e3a119c0b8df3d8b5fde5ca5f61d",
        "diff_stats": {
            "additions": 6,
            "deletions": 0
        },
        "diff_content": "@@ -22,6 +22,12 @@\n             <version>11.0.2</version>\n         </dependency>\n \n+        <dependency>\n+            <groupId>commons-lang</groupId>\n+            <artifactId>commons-lang</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+\n     </dependencies>\n \n     <build>\n"
    },
    {
        "commit_hash": "bc99e75c2fa4b56325910e445283d1b24cb2618d",
        "previous_commit_hash": "a4bdd6f054c3e3a119c0b8df3d8b5fde5ca5f61d",
        "diff_stats": {
            "additions": 217,
            "deletions": 193
        },
        "diff_content": "@@ -4,331 +4,355 @@\n \n package net.orfjackal.retrolambda.test;\n \n-import org.junit.Test;\n+import org.apache.commons.lang.SystemUtils;\n+import org.junit.*;\n+import org.junit.rules.ExpectedException;\n \n-import java.util.Comparator;\n+import java.util.*;\n \n import static org.hamcrest.MatcherAssert.assertThat;\n-import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.*;\n+import static org.junit.Assume.assumeThat;\n \n+@SuppressWarnings({\"Convert2Lambda\", \"Anonymous2MethodRef\"})\n public class DefaultMethodsTest {\n \n-    /**\n-     * JDK 8 adds a bridge method to an interface when it overrides a method\n-     * from the parent interface and refines its return type. This uses Java 8's\n-     * default methods feature, which won't work on Java 7 and below, so we have\n-     * to remove it for it - this makes the bytecode same as what JDK 7 produces.\n-     */\n+    @Rule\n+    public final ExpectedException thrown = ExpectedException.none();\n+\n+    @Test\n+    public void default_method_inherited_from_interface() {\n+        DefaultMethods obj = new DefaultMethods() {\n+        };\n+        assertThat(obj.foo(), is(\"original\"));\n+    }\n+\n     @Test\n-    public void will_remove_bridge_methods_from_interfaces() {\n-        class Foo implements Child {\n+    public void default_method_overridden_in_class() {\n+        DefaultMethods obj = new DefaultMethods() {\n             @Override\n             public String foo() {\n-                return \"foo\";\n+                return \"overridden\";\n             }\n+        };\n+        assertThat(obj.foo(), is(\"overridden\"));\n+    }\n+\n+    private interface DefaultMethods {\n+        default String foo() {\n+            return \"original\";\n         }\n-        assertThat(\"direct call\", new Foo().foo(), is(\"foo\"));\n-        assertThat(\"bridged call\", ((Parent) new Foo()).foo(), is((Object) \"foo\"));\n     }\n \n-    public interface Parent {\n-        Object foo();\n+\n+    @Test\n+    public void default_method_overridden_in_child_interface() {\n+        OverrideChild child = new OverrideChild() {\n+        };\n+        assertThat(child.foo(), is(\"overridden\"));\n     }\n \n-    public interface Child extends Parent {\n-        String foo(); // refined return type\n+    private interface OverrideParent {\n+        default String foo() {\n+            return \"original\";\n+        }\n+    }\n+\n+    private interface OverrideChild extends OverrideParent {\n+        @Override\n+        default String foo() {\n+            return \"overridden\";\n+        }\n     }\n \n \n     @Test\n-    public void will_return_right_string() {\n-        boolean sameStrings = new Child2() {\n+    public void default_method_type_refined_in_child_interface() {\n+        RefineChild child = new RefineChild() {\n+            @Override\n+            public String foo() {\n+                return \"refined\";\n+            }\n+        };\n+        assertThat(\"direct call\", child.foo(), is(\"refined\"));\n+        assertThat(\"bridged call\", ((RefineParent) child).foo(), is((Object) \"refined\"));\n+    }\n+\n+    private interface RefineParent {\n+        default Object foo() {\n+            return \"original\";\n+        }\n+    }\n \n-        }.method().equals(\"Child2\");\n-        assertThat(\"they are equal\", sameStrings);\n+    private interface RefineChild extends RefineParent {\n+        @Override\n+        String foo();\n     }\n \n-    public interface Parent2 {\n-        default Object method() {\n-            return \"Parent\";\n+\n+    @Test\n+    public void default_method_overridden_and_refined_in_child_interface() {\n+        OverrideRefineChild child = new OverrideRefineChild() {\n+        };\n+        assertThat(child.foo(), is(\"overridden and refined\"));\n+    }\n+\n+    private interface OverrideRefineParent {\n+        default Object foo() {\n+            return \"original\";\n         }\n     }\n \n-    public interface Child2 extends Parent2 {\n+    private interface OverrideRefineChild extends OverrideRefineParent {\n         @Override\n-        default String method() {\n-            return \"Child2\";\n+        default String foo() {\n+            return \"overridden and refined\";\n         }\n     }\n \n \n     @Test\n-    public void primitives_run() {\n+    public void default_methods_of_primitive_type() {\n         Primitives p = new Primitives() {\n         };\n-        assertThat(p.aBoolean(), is(true));\n-        assertThat(p.anInt(), is(1));\n-        assertThat(p.aShort(), is((short) 2));\n-        assertThat(p.aLong(), is(1L << 50));\n-        assertThat(p.aFloat(), is(0f));\n-        assertThat(p.aDouble(), is(0.0));\n-        p.aVoid(); // would crash\n-    }\n-\n-    public interface Primitives {\n-        default int anInt() {\n-            return 1;\n+        assertThat(\"boolean\", p.getBoolean(), is(true));\n+        assertThat(\"byte\", p.getByte(), is((byte) 2));\n+        assertThat(\"short\", p.getShort(), is((short) 3));\n+        assertThat(\"int\", p.getInt(), is(4));\n+        assertThat(\"long\", p.getLong(), is(5L));\n+        assertThat(\"float\", p.getFloat(), is(6.0f));\n+        assertThat(\"double\", p.getDouble(), is(7.0));\n+        assertThat(\"char\", p.getChar(), is('a'));\n+    }\n+\n+    private interface Primitives {\n+        default boolean getBoolean() {\n+            return true;\n         }\n \n-        default short aShort() {\n+        default byte getByte() {\n             return 2;\n         }\n \n-        default long aLong() {\n-            return 1L << 50;\n+        default short getShort() {\n+            return 3;\n+        }\n+\n+        default int getInt() {\n+            return 4;\n         }\n \n-        default boolean aBoolean() {\n-            return true;\n+        default long getLong() {\n+            return 5L;\n         }\n \n-        default float aFloat() {\n-            return 0f;\n+        default float getFloat() {\n+            return 6.0f;\n         }\n \n-        default double aDouble() {\n-            return 0.0;\n+        default double getDouble() {\n+            return 7.0;\n         }\n \n-        default void aVoid() {\n+        default char getChar() {\n+            return 'a';\n         }\n     }\n \n \n     @Test\n-    public void anonymous_instances() {\n-        Chaining c1 = new Chaining() {\n-\n-        };\n-        Chaining c2 = new Chaining() {\n-\n+    public void default_methods_of_void_type() {\n+        modifiedByVoidMethod = 1;\n+        Voids v = new Voids() {\n         };\n-        assertThat(\"Strings equals\", c1.join(c2).equals(\"InterfaceInterface\"));\n-        Chaining anon = new Chaining() {\n-            @Override\n-            public String myString() {\n-                return \"Anon\";\n-            }\n-        };\n-        assertThat(\"Anonymous override equals\", c1.join(anon).equals(\"InterfaceAnon\"));\n+        v.run();\n+        assertThat(modifiedByVoidMethod, is(2));\n     }\n \n-    public interface Chaining {\n-        default String myString() {\n-            return \"Interface\";\n-        }\n+    private static int modifiedByVoidMethod;\n \n-        default String join(Chaining other) {\n-            return myString() + other.myString();\n+    private interface Voids {\n+        default void run() {\n+            modifiedByVoidMethod++;\n         }\n     }\n \n \n     @Test\n-    public void test_override_primitive() {\n-        DeepChild d1 = new DeepChild() {\n+    public void default_methods_with_primitive_arguments() {\n+        PrimitiveArgs p = new PrimitiveArgs() {\n+        };\n+        assertThat(p.sum(true, (byte) 2, (short) 3, 4, 5, 6, 7, (char) 8), is(36));\n+    }\n+\n+    private interface PrimitiveArgs {\n+        default int sum(boolean bool, byte b, short s, int i, long l, float f, double d, char c) {\n+            return (int) ((bool ? 1 : 0) + b + s + i + l + f + d + c);\n+        }\n+    }\n+\n \n+    @Test\n+    public void default_methods_calling_super() {\n+        SuperCallChild child = new SuperCallChild() {\n         };\n-        assertThat(\"override works\", d1.level() == 2);\n-        DeepChild d2 = new DeepChild() {\n+        assertThat(child.callSuper(), is(11));\n+    }\n+\n+    @Test\n+    public void default_methods_called_with_super() {\n+        class C implements SuperCallChild {\n             @Override\n-            public int level() {\n-                return 1 + DeepChild.super.level();\n+            public int callSuper() {\n+                return 100 + SuperCallChild.super.callSuper();\n             }\n-        };\n-        assertThat(\"super call interface works\", d2.level() == 3);\n+\n+            public int siblingCallingSuper() {\n+                return 1000 + SuperCallChild.super.callSuper();\n+            }\n+        }\n+        assertThat(new C().callSuper(), is(111));\n+        assertThat(new C().siblingCallingSuper(), is(1011));\n     }\n \n-    public interface DeepParent {\n-        default int level() {\n+    private interface SuperCallParent {\n+        default int callSuper() {\n             return 1;\n         }\n     }\n \n-    public interface DeepChild extends DeepParent {\n+    private interface SuperCallChild extends SuperCallParent {\n         @Override\n-        default int level() {\n-            return DeepParent.super.level() + 1;\n+        default int callSuper() {\n+            return 10 + SuperCallParent.super.callSuper();\n         }\n     }\n \n \n     @Test\n-    public void will_handle_override_proprly() {\n+    public void inheriting_unrelated_default_methods() {\n         class C implements Conflict1, Conflict2 {\n-            public String confl() {\n-                return Conflict1.super.confl() + Conflict2.super.confl();\n+            @Override\n+            public String conflict() {\n+                return Conflict1.super.conflict() + Conflict2.super.conflict();\n             }\n         }\n-        assertThat(\"Handles method conflict\", new C().confl().equals(\"12\"));\n+        assertThat(new C().conflict(), is(\"ab\"));\n     }\n \n-    interface Conflict1 {\n-        default String confl() {\n-            return \"1\";\n+    private interface Conflict1 {\n+        default String conflict() {\n+            return \"a\";\n         }\n     }\n \n-    interface Conflict2 {\n-        default String confl() {\n-            return \"2\";\n+    private interface Conflict2 {\n+        default String conflict() {\n+            return \"b\";\n         }\n     }\n \n \n     @Test\n-    public void will_handle_long_paramlist() {\n-        DeepParent2 dp = new DeepParent2() {\n+    public void default_methods_calling_other_interface_methods() {\n+        CallOtherMethods obj = new CallOtherMethods() {\n             @Override\n-            public int anInt() {\n+            public int foo() {\n                 return 2;\n             }\n         };\n-        assertThat(\"Long call parameter list works\", dp.method(dp, dp, dp) == 8);\n+        assertThat(obj.callsFoo(), is(12));\n     }\n \n-    public interface DeepParent2 {\n-        int anInt();\n+    private interface CallOtherMethods {\n+        int foo();\n \n-        default int method(DeepParent2 p1, DeepParent2 p2, DeepParent2 p3) {\n-            return p1.anInt() + p2.anInt() + p3.anInt() + anInt();\n+        default int callsFoo() {\n+            return foo() + 10;\n         }\n     }\n \n \n     @Test\n-    public void will_handle_lambda() {\n-        DeepParent2 dp = () -> 2;\n-        assertThat(\"Long call parameter list with lambda works\", dp.method(dp, dp, dp) == 8);\n-    }\n-\n-\n-    @Test\n-    public void handles_bridge_methods() {\n-        StringBridge sb = new StringBridge() {\n-        };\n-        assertThat(\"returns true\", sb.compare());\n-        BridgeTest<String> sb2 = sb;\n-        assertThat(\"still returns true\", sb2.max(\"A\", \"B\", String.CASE_INSENSITIVE_ORDER).equals(\"B\"));\n-    }\n-\n-    interface BridgeTest<T> {\n-        default T max(T t1, T t2, Comparator<? super T> comparator) {\n-            return comparator.compare(t1, t2) > 0 ? t1 : t2;\n-        }\n-    }\n-\n-    interface StringBridge extends BridgeTest<String> {\n-        default boolean compare() {\n-            return max(\"A\", \"B\", String.CASE_INSENSITIVE_ORDER).equals(\"B\");\n-        }\n+    public void lambdas_with_default_methods() {\n+        CallOtherMethods lambda = () -> 2;\n+        assertThat(lambda.foo(), is(2));\n+        assertThat(lambda.callsFoo(), is(12));\n     }\n \n \n+    /**\n+     * Based on the example in <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html#jls-9.4.1\">JLS \u00a79.4.1</a>\n+     * (Interfaces - Inheritance and Overriding)\n+     */\n     @Test\n-    public void right_method_chosen() {\n-        assertThat(new Middle3aParent() {\n+    public void inheriting_same_default_methods_through_many_parent_interfaces() {\n+        assertThat(new InheritsOriginal() {\n+        }.foo(), is(\"original\"));\n \n-        }.anInt(), is(2));\n+        assertThat(new InheritsOverridden() {\n+        }.foo(), is(\"overridden\"));\n \n-        assertThat(new Middle3bParent() {\n+        assertThat(new InheritsOverriddenAndOriginal() {\n+        }.foo(), is(\"overridden\"));\n \n-        }.anInt(), is(2));\n+        assertThat(new InheritsOriginalAndOverridden() {\n+        }.foo(), is(\"overridden\"));\n     }\n \n-    public interface MiddleParent {\n-        default int anInt() {\n-            return 1;\n+    private interface SuperOriginal {\n+        default String foo() {\n+            return \"original\";\n         }\n     }\n \n-    public interface Middle2Parent extends MiddleParent {\n+    private interface SuperOverridden extends SuperOriginal {\n         @Override\n-        default int anInt() {\n-            return 2;\n+        default String foo() {\n+            return \"overridden\";\n         }\n     }\n \n-    public interface Middle3aParent extends MiddleParent, Middle2Parent {\n-    }\n-\n-    public interface Middle3bParent extends Middle2Parent, MiddleParent {\n+    private interface InheritsOriginal extends SuperOriginal {\n     }\n \n-\n-    @Test\n-    public void yet_another_deep_hiearchy_test_with_bridges() {\n-        assertThat(new SubSub2() {\n-\n-        }.anInt(), is(2));\n-\n-        assertThat(new SubSub() {\n-\n-        }.anInt(), is(3));\n-        SubSub sub = new SubSub() {\n-\n-        };\n-        assertThat(sub.anInt(), is(3));\n-        Top<?> top = sub;\n-        assertThat(\"is instanceof string\", top.anObject() instanceof String);\n+    private interface InheritsOverridden extends SuperOverridden {\n     }\n \n-    public interface Top<T> {\n-        T anObject();\n-\n-        default int anInt() {\n-            return 1;\n-        }\n+    private interface InheritsOverriddenAndOriginal extends SuperOverridden, InheritsOriginal {\n     }\n \n-    public interface SubTop<T extends CharSequence> extends Top<T> {\n-        default int anInt() {\n-            return Top.super.anInt() + 1;\n-        }\n+    private interface InheritsOriginalAndOverridden extends InheritsOriginal, SuperOverridden {\n     }\n \n-    public interface SubSub extends SubTop<String> {\n-        default int anInt() {\n-            return SubTop.super.anInt() + 1;\n-        }\n \n-        default String anObject() {\n-            return \"0\";\n-        }\n-    }\n+    @Test\n+    public void default_methods_of_library_interfaces_are_ignored_silently() {\n+        Iterable<String> it = new Iterable<String>() {\n+            @Override\n+            public Iterator<String> iterator() {\n+                return Collections.emptyIterator();\n+            }\n+        };\n \n-    public interface SubSub2 extends SubTop<String> {\n-        default String anObject() {\n-            return \"1\";\n-        }\n+        assertThat(it.iterator(), is(Collections.<String>emptyIterator()));\n     }\n \n-\n     @Test\n-    public void call_static_methods_from_default() {\n-        DefaultToStatic i = new DefaultToStatic() {\n-        };\n-        assertThat(i.ifMeth(), is(3));\n-        assertThat(DefaultToStatic.staticMeth(), is(3));\n-    }\n+    public void trying_to_use_default_methods_of_library_interfaces_causes_NoSuchMethodError() {\n+        assumeThat(SystemUtils.JAVA_VERSION_FLOAT, is(lessThan(1.8f)));\n \n-    public interface DefaultToStatic {\n-        default int ifMeth() {\n-            return staticMeth();\n+        class C implements Iterable<String> {\n+            @Override\n+            public Iterator<String> iterator() {\n+                return Collections.emptyIterator();\n+            }\n         }\n \n-        static int staticMeth() {\n-            return 3;\n-        }\n+        thrown.expect(NoSuchMethodError.class);\n+        thrown.expectMessage(\"spliterator\");\n+        // Called directly on the class (invokevirtual) instead of the interface (invokeinterface),\n+        // to make sure that no method was inserted to the class (in which case this call would not fail)\n+        new C().spliterator();\n     }\n }\n"
    },
    {
        "commit_hash": "bc99e75c2fa4b56325910e445283d1b24cb2618d",
        "previous_commit_hash": "a4bdd6f054c3e3a119c0b8df3d8b5fde5ca5f61d",
        "diff_stats": {
            "additions": 40,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,40 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.test;\n+\n+import org.junit.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+\n+public class InterfaceBridgeMethodsTest {\n+\n+    /**\n+     * JDK 8 adds a bridge method to an interface when it overrides a method\n+     * from the parent interface and refines its return type. This uses Java 8's\n+     * default methods feature, which won't work on Java 7 and below, so we have\n+     * to remove it for it - this makes the bytecode same as what JDK 7 produces.\n+     */\n+    @Test\n+    public void will_remove_bridge_methods_from_interfaces() {\n+        BridgeChild child = new BridgeChild() {\n+            @Override\n+            public String foo() {\n+                return \"foo\";\n+            }\n+        };\n+        assertThat(\"direct call\", child.foo(), is(\"foo\"));\n+        assertThat(\"bridged call\", ((BridgeParent) child).foo(), is((Object) \"foo\"));\n+    }\n+\n+    public interface BridgeParent {\n+        Object foo();\n+    }\n+\n+    public interface BridgeChild extends BridgeParent {\n+        @Override\n+        String foo(); // refined return type\n+    }\n+}\n"
    },
    {
        "commit_hash": "bc99e75c2fa4b56325910e445283d1b24cb2618d",
        "previous_commit_hash": "a4bdd6f054c3e3a119c0b8df3d8b5fde5ca5f61d",
        "diff_stats": {
            "additions": 53,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,53 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.test;\n+\n+import org.junit.Test;\n+\n+import java.util.concurrent.Callable;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+\n+public class InterfaceStaticMethodsTest {\n+\n+    @Test\n+    public void static_methods_on_interfaces() {\n+        assertThat(Interface.staticMethod(), is(42));\n+    }\n+\n+    @Test\n+    public void static_methods_on_interfaces_taking_arguments() {\n+        assertThat(Interface.staticMethodWithArgs(\"a\", 1, 2L), is(\"a12\"));\n+    }\n+\n+    @Test\n+    public void calling_static_methods_on_interfaces_from_default_methods() {\n+        Interface obj = new Interface() {\n+        };\n+        assertThat(obj.callStaticMethod(), is(42));\n+    }\n+\n+    @Test\n+    public void calling_static_methods_on_interfaces_from_lambdas() throws Exception {\n+        Callable<Integer> c = Interface::staticMethod;\n+        assertThat(c.call(), is(42));\n+    }\n+\n+    private interface Interface {\n+        default int callStaticMethod() {\n+            return staticMethod();\n+        }\n+\n+        static int staticMethod() {\n+            return 42;\n+        }\n+\n+        // arguments of just a couple of different types because we're lazy\n+        static String staticMethodWithArgs(String s, int a, long b) {\n+            return s + a + b;\n+        }\n+    }\n+}\n"
    },
    {
        "commit_hash": "bc99e75c2fa4b56325910e445283d1b24cb2618d",
        "previous_commit_hash": "a4bdd6f054c3e3a119c0b8df3d8b5fde5ca5f61d",
        "diff_stats": {
            "additions": 6,
            "deletions": 0
        },
        "diff_content": "@@ -121,6 +121,12 @@\n                 <version>17.0</version>\n             </dependency>\n \n+            <dependency>\n+                <groupId>commons-lang</groupId>\n+                <artifactId>commons-lang</artifactId>\n+                <version>2.6</version>\n+            </dependency>\n+\n         </dependencies>\n     </dependencyManagement>\n \n"
    },
    {
        "commit_hash": "6cb79086e4691e060a54b82da6c912bd00c937c1",
        "previous_commit_hash": "bc99e75c2fa4b56325910e445283d1b24cb2618d",
        "diff_stats": {
            "additions": 23,
            "deletions": 8
        },
        "diff_content": "@@ -28,14 +28,22 @@ public class DefaultMethodsTest {\n     }\n \n     @Test\n-    public void default_method_overridden_in_class() {\n-        DefaultMethods obj = new DefaultMethods() {\n-            @Override\n-            public String foo() {\n-                return \"overridden\";\n-            }\n-        };\n-        assertThat(obj.foo(), is(\"overridden\"));\n+    public void default_method_overridden_in_current_class() {\n+        assertThat(new DefaultMethodOverridingClass().foo(), is(\"overridden\"));\n+    }\n+\n+    @Test\n+    public void default_method_overridden_in_parent_class() {\n+        class C extends DefaultMethodOverridingClass {\n+        }\n+        assertThat(new C().foo(), is(\"overridden\"));\n+    }\n+\n+    @Test\n+    public void default_method_overridden_in_parent_class_and_implements_interface_explicitly() {\n+        class C extends DefaultMethodOverridingClass implements DefaultMethods {\n+        }\n+        assertThat(new C().foo(), is(\"overridden\"));\n     }\n \n     private interface DefaultMethods {\n@@ -44,6 +52,13 @@ public class DefaultMethodsTest {\n         }\n     }\n \n+    private class DefaultMethodOverridingClass implements DefaultMethods {\n+        @Override\n+        public String foo() {\n+            return \"overridden\";\n+        }\n+    }\n+\n \n     @Test\n     public void default_method_overridden_in_child_interface() {\n"
    },
    {
        "commit_hash": "1b6e665fff399db1300a8a93c832c8d8f9e62cbb",
        "previous_commit_hash": "6cb79086e4691e060a54b82da6c912bd00c937c1",
        "diff_stats": {
            "additions": 113,
            "deletions": 46
        },
        "diff_content": "@@ -14,12 +14,15 @@ import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.*;\n import static org.junit.Assume.assumeThat;\n \n-@SuppressWarnings({\"Convert2Lambda\", \"Anonymous2MethodRef\"})\n+@SuppressWarnings({\"Convert2Lambda\", \"Anonymous2MethodRef\", \"RedundantCast\"})\n public class DefaultMethodsTest {\n \n     @Rule\n     public final ExpectedException thrown = ExpectedException.none();\n \n+\n+    // Inheriting & Overriding\n+\n     @Test\n     public void default_method_inherited_from_interface() {\n         DefaultMethods obj = new DefaultMethods() {\n@@ -81,6 +84,53 @@ public class DefaultMethodsTest {\n     }\n \n \n+    /**\n+     * Based on the example in <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html#jls-9.4.1\">JLS \u00a79.4.1</a>\n+     * (Interfaces - Inheritance and Overriding)\n+     */\n+    @Test\n+    public void inheriting_same_default_methods_through_many_parent_interfaces() {\n+        assertThat(new InheritsOriginal() {\n+        }.foo(), is(\"original\"));\n+\n+        assertThat(new InheritsOverridden() {\n+        }.foo(), is(\"overridden\"));\n+\n+        assertThat(new InheritsOverriddenAndOriginal() {\n+        }.foo(), is(\"overridden\"));\n+\n+        assertThat(new InheritsOriginalAndOverridden() {\n+        }.foo(), is(\"overridden\"));\n+    }\n+\n+    private interface SuperOriginal {\n+        default String foo() {\n+            return \"original\";\n+        }\n+    }\n+\n+    private interface SuperOverridden extends SuperOriginal {\n+        @Override\n+        default String foo() {\n+            return \"overridden\";\n+        }\n+    }\n+\n+    private interface InheritsOriginal extends SuperOriginal {\n+    }\n+\n+    private interface InheritsOverridden extends SuperOverridden {\n+    }\n+\n+    private interface InheritsOverriddenAndOriginal extends SuperOverridden, InheritsOriginal {\n+    }\n+\n+    private interface InheritsOriginalAndOverridden extends InheritsOriginal, SuperOverridden {\n+    }\n+\n+\n+    // Bridge Methods\n+\n     @Test\n     public void default_method_type_refined_in_child_interface() {\n         RefineChild child = new RefineChild() {\n@@ -93,6 +143,19 @@ public class DefaultMethodsTest {\n         assertThat(\"bridged call\", ((RefineParent) child).foo(), is((Object) \"refined\"));\n     }\n \n+    @Test\n+    public void default_method_type_refined_in_implementing_class() {\n+        class C implements RefineParent {\n+            @Override\n+            public String foo() {\n+                return \"refined\";\n+            }\n+        }\n+        C obj = new C();\n+        assertThat(\"direct call\", obj.foo(), is(\"refined\"));\n+        assertThat(\"bridged call\", ((RefineParent) obj).foo(), is((Object) \"refined\"));\n+    }\n+\n     private interface RefineParent {\n         default Object foo() {\n             return \"original\";\n@@ -106,10 +169,46 @@ public class DefaultMethodsTest {\n \n \n     @Test\n-    public void default_method_overridden_and_refined_in_child_interface() {\n+    public void default_method_argument_type_refined_in_child_interface() {\n+        RefineArgChild child = new RefineArgChild() {\n+        };\n+        assertThat(\"direct call\", child.foo(\"42\"), is(\"refined 42\"));\n+        assertThat(\"bridged call\", ((RefineArgParent<String>) child).foo(\"42\"), is((Object) \"refined 42\"));\n+    }\n+\n+    @Test\n+    public void default_method_argument_type_refined_in_implementing_class() {\n+        class C implements RefineArgParent<String> {\n+            @Override\n+            public String foo(String arg) {\n+                return \"refined \" + arg;\n+            }\n+        }\n+        C obj = new C();\n+        assertThat(\"direct call\", obj.foo(\"42\"), is(\"refined 42\"));\n+        assertThat(\"bridged call\", ((RefineArgParent<String>) obj).foo(\"42\"), is((Object) \"refined 42\"));\n+    }\n+\n+    private interface RefineArgParent<T> {\n+        default String foo(T arg) {\n+            return \"original \" + arg;\n+        }\n+    }\n+\n+    private interface RefineArgChild extends RefineArgParent<String> {\n+        @Override\n+        default String foo(String arg) {\n+            return \"refined \" + arg;\n+        }\n+    }\n+\n+\n+    @Test\n+    public void default_method_type_refined_and_overridden_in_child_interface() {\n         OverrideRefineChild child = new OverrideRefineChild() {\n         };\n-        assertThat(child.foo(), is(\"overridden and refined\"));\n+        assertThat(\"direct call\", child.foo(), is(\"overridden and refined\"));\n+        assertThat(\"bridged call\", ((OverrideRefineParent) child).foo(), is((Object) \"overridden and refined\"));\n     }\n \n     private interface OverrideRefineParent {\n@@ -126,6 +225,8 @@ public class DefaultMethodsTest {\n     }\n \n \n+    // Primitive Types & Void\n+\n     @Test\n     public void default_methods_of_primitive_type() {\n         Primitives p = new Primitives() {\n@@ -207,6 +308,8 @@ public class DefaultMethodsTest {\n     }\n \n \n+    // Calling Super\n+\n     @Test\n     public void default_methods_calling_super() {\n         SuperCallChild child = new SuperCallChild() {\n@@ -268,6 +371,8 @@ public class DefaultMethodsTest {\n     }\n \n \n+    // Misc\n+\n     @Test\n     public void default_methods_calling_other_interface_methods() {\n         CallOtherMethods obj = new CallOtherMethods() {\n@@ -288,6 +393,9 @@ public class DefaultMethodsTest {\n     }\n \n \n+    /**\n+     * Backporting default methods should not interact badly with backporting lambdas.\n+     */\n     @Test\n     public void lambdas_with_default_methods() {\n         CallOtherMethods lambda = () -> 2;\n@@ -297,50 +405,9 @@ public class DefaultMethodsTest {\n \n \n     /**\n-     * Based on the example in <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html#jls-9.4.1\">JLS \u00a79.4.1</a>\n-     * (Interfaces - Inheritance and Overriding)\n+     * We're unable to backport default methods if we cannot modify the interface,\n+     * e.g. if it's part of the standard library or a third-party library.\n      */\n-    @Test\n-    public void inheriting_same_default_methods_through_many_parent_interfaces() {\n-        assertThat(new InheritsOriginal() {\n-        }.foo(), is(\"original\"));\n-\n-        assertThat(new InheritsOverridden() {\n-        }.foo(), is(\"overridden\"));\n-\n-        assertThat(new InheritsOverriddenAndOriginal() {\n-        }.foo(), is(\"overridden\"));\n-\n-        assertThat(new InheritsOriginalAndOverridden() {\n-        }.foo(), is(\"overridden\"));\n-    }\n-\n-    private interface SuperOriginal {\n-        default String foo() {\n-            return \"original\";\n-        }\n-    }\n-\n-    private interface SuperOverridden extends SuperOriginal {\n-        @Override\n-        default String foo() {\n-            return \"overridden\";\n-        }\n-    }\n-\n-    private interface InheritsOriginal extends SuperOriginal {\n-    }\n-\n-    private interface InheritsOverridden extends SuperOverridden {\n-    }\n-\n-    private interface InheritsOverriddenAndOriginal extends SuperOverridden, InheritsOriginal {\n-    }\n-\n-    private interface InheritsOriginalAndOverridden extends InheritsOriginal, SuperOverridden {\n-    }\n-\n-\n     @Test\n     public void default_methods_of_library_interfaces_are_ignored_silently() {\n         Iterable<String> it = new Iterable<String>() {\n"
    },
    {
        "commit_hash": "d3656b80685758cc0b9e6e4f8678973150d60ec1",
        "previous_commit_hash": "1b6e665fff399db1300a8a93c832c8d8f9e62cbb",
        "diff_stats": {
            "additions": 7,
            "deletions": 0
        },
        "diff_content": "@@ -11,6 +11,7 @@ import java.util.concurrent.Callable;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.is;\n \n+@SuppressWarnings(\"Convert2MethodRef\")\n public class InterfaceStaticMethodsTest {\n \n     @Test\n@@ -32,6 +33,12 @@ public class InterfaceStaticMethodsTest {\n \n     @Test\n     public void calling_static_methods_on_interfaces_from_lambdas() throws Exception {\n+        Callable<Integer> c = () -> Interface.staticMethod();\n+        assertThat(c.call(), is(42));\n+    }\n+\n+    @Test\n+    public void calling_static_methods_on_interfaces_from_method_references() throws Exception {\n         Callable<Integer> c = Interface::staticMethod;\n         assertThat(c.call(), is(42));\n     }\n"
    },
    {
        "commit_hash": "b8211a1c4f5a2e5d26318ecb0dd863b13c8648b7",
        "previous_commit_hash": "d3656b80685758cc0b9e6e4f8678973150d60ec1",
        "diff_stats": {
            "additions": 22,
            "deletions": 0
        },
        "diff_content": "@@ -85,6 +85,28 @@\n     </build>\n \n     <profiles>\n+        <profile>\n+            <id>no-default-methods</id>\n+            <activation>\n+                <property>\n+                    <name>!env.DEFAULT_METHODS</name>\n+                </property>\n+            </activation>\n+            <build>\n+                <plugins>\n+                    <plugin>\n+                        <artifactId>maven-compiler-plugin</artifactId>\n+                        <configuration>\n+                            <testExcludes>\n+                                <pattern>**/DefaultMethodsTest.java</pattern>\n+                                <pattern>**/InterfaceStaticMethodsTest.java</pattern>\n+                            </testExcludes>\n+                        </configuration>\n+                    </plugin>\n+                </plugins>\n+            </build>\n+        </profile>\n+\n         <profile>\n             <id>eclipse</id>\n             <build>\n"
    },
    {
        "commit_hash": "b8211a1c4f5a2e5d26318ecb0dd863b13c8648b7",
        "previous_commit_hash": "d3656b80685758cc0b9e6e4f8678973150d60ec1",
        "diff_stats": {
            "additions": 18,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,18 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda;\n+\n+public class FeatureToggles {\n+\n+    public static final int DEFAULT_METHODS = parseInt(System.getenv(\"DEFAULT_METHODS\"), 0);\n+\n+    private static int parseInt(String value, int defaultValue) {\n+        try {\n+            return Integer.parseInt(value);\n+        } catch (NumberFormatException e) {\n+            return defaultValue;\n+        }\n+    }\n+}\n"
    },
    {
        "commit_hash": "b8211a1c4f5a2e5d26318ecb0dd863b13c8648b7",
        "previous_commit_hash": "d3656b80685758cc0b9e6e4f8678973150d60ec1",
        "diff_stats": {
            "additions": 11,
            "deletions": 6
        },
        "diff_content": "@@ -7,8 +7,6 @@ package net.orfjackal.retrolambda;\n import net.orfjackal.retrolambda.defaultmethods.ClassModifier;\n import org.objectweb.asm.*;\n \n-import java.util.Arrays;\n-\n import static org.objectweb.asm.Opcodes.*;\n \n public class LambdaClassBackporter {\n@@ -18,8 +16,15 @@ public class LambdaClassBackporter {\n \n     public static byte[] transform(byte[] bytecode, int targetVersion) {\n         ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n-\t\tClassModifier stage2 = new ClassModifier(targetVersion, writer);\n-        new ClassReader(bytecode).accept(new LambdaClassVisitor(stage2, targetVersion), 0);\n+        if (FeatureToggles.DEFAULT_METHODS == 0) {\n+            LambdaClassVisitor stage1 = new LambdaClassVisitor(writer, targetVersion);\n+            new ClassReader(bytecode).accept(stage1, 0);\n+        }\n+        if (FeatureToggles.DEFAULT_METHODS == 1) {\n+            ClassModifier stage2 = new ClassModifier(targetVersion, writer);\n+            LambdaClassVisitor stage1 = new LambdaClassVisitor(stage2, targetVersion);\n+            new ClassReader(bytecode).accept(stage1, 0);\n+        }\n         return writer.toByteArray();\n     }\n \n@@ -31,8 +36,8 @@ public class LambdaClassBackporter {\n         private Handle bridgeMethod;\n         private LambdaFactoryMethod factoryMethod;\n \n-        public LambdaClassVisitor(ClassVisitor cw, int targetVersion) {\n-            super(ASM5, cw);\n+        public LambdaClassVisitor(ClassVisitor cv, int targetVersion) {\n+            super(ASM5, cv);\n             this.targetVersion = targetVersion;\n         }\n \n"
    },
    {
        "commit_hash": "b8211a1c4f5a2e5d26318ecb0dd863b13c8648b7",
        "previous_commit_hash": "d3656b80685758cc0b9e6e4f8678973150d60ec1",
        "diff_stats": {
            "additions": 31,
            "deletions": 10
        },
        "diff_content": "@@ -4,9 +4,7 @@\n \n package net.orfjackal.retrolambda;\n \n-import net.orfjackal.retrolambda.defaultmethods.ClassModifier;\n-import net.orfjackal.retrolambda.defaultmethods.Helpers;\n-import net.orfjackal.retrolambda.defaultmethods.InterfaceModifier;\n+import net.orfjackal.retrolambda.defaultmethods.*;\n import org.objectweb.asm.*;\n \n import java.lang.reflect.Field;\n@@ -19,12 +17,18 @@ public class LambdaUsageBackporter {\n \n     public static byte[] transform(byte[] bytecode, int targetVersion) {\n         resetLambdaClassSequenceNumber();\n-        ClassWriter stage2 = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n-\t\tClassModifier stage3 = new ClassModifier(targetVersion, stage2);\n-\t\tInterfaceModifier stage4 = new InterfaceModifier(stage3, targetVersion);\n-        InvokeDynamicInsnConverter stage1 = new InvokeDynamicInsnConverter(stage4, targetVersion);\n-        new ClassReader(bytecode).accept(stage1, 0);\n-        return stage2.toByteArray();\n+        ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n+        if (FeatureToggles.DEFAULT_METHODS == 0) {\n+            InvokeDynamicInsnConverter stage1 = new InvokeDynamicInsnConverter(writer, targetVersion);\n+            new ClassReader(bytecode).accept(stage1, 0);\n+        }\n+        if (FeatureToggles.DEFAULT_METHODS == 1) {\n+            ClassModifier stage3 = new ClassModifier(targetVersion, writer);\n+            InterfaceModifier stage2 = new InterfaceModifier(stage3, targetVersion);\n+            InvokeDynamicInsnConverter stage1 = new InvokeDynamicInsnConverter(stage2, targetVersion);\n+            new ClassReader(bytecode).accept(stage1, 0);\n+        }\n+        return writer.toByteArray();\n     }\n \n     private static void resetLambdaClassSequenceNumber() {\n@@ -68,6 +72,23 @@ public class LambdaUsageBackporter {\n             if (isBridgeMethodOnInterface(access)) {\n                 return null; // remove the bridge method; Java 7 didn't use them\n             }\n+            if (FeatureToggles.DEFAULT_METHODS == 0\n+                    && isNonAbstractMethodOnInterface(access)\n+                    && !isClassInitializerMethod(name, desc, access)) {\n+                // In case we have missed a case of Java 8 producing non-abstract methods\n+                // on interfaces, we have this warning here to get a bug report sooner.\n+                // Not allowed by Java 7:\n+                // - default methods\n+                // - static methods\n+                // - bridge methods\n+                // Allowed by Java 7:\n+                // - class initializer methods (for initializing constants)\n+                System.out.println(\"WARNING: Method '\" + name + \"' of interface '\" + className + \"' is non-abstract! \" +\n+                        \"This will probably fail to run on Java 7 and below. \" +\n+                        \"If you get this warning _without_ using Java 8's default methods, \" +\n+                        \"please report a bug at https://github.com/orfjackal/retrolambda/issues \" +\n+                        \"together with an SSCCE (http://www.sscce.org/)\");\n+            }\n             MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n             return new InvokeDynamicInsnConvertingMethodVisitor(mv, this);\n         }\n@@ -154,5 +175,5 @@ public class LambdaUsageBackporter {\n                     invoker, invokedName, invokedType, bsm, bsmArgs);\n             super.visitMethodInsn(INVOKESTATIC, factory.getOwner(), factory.getName(), factory.getDesc(), false);\n         }\n-\t}\n+    }\n }\n"
    },
    {
        "commit_hash": "d37b134855d4262795e383e020a1910397933abf",
        "previous_commit_hash": "70b2bbbe4dcd4a0d5261b781b0833312e8041818",
        "diff_stats": {
            "additions": 37,
            "deletions": 2
        },
        "diff_content": "@@ -4,16 +4,24 @@\n \n package net.orfjackal.retrolambda.test;\n \n-import org.junit.Test;\n+import org.apache.commons.lang.SystemUtils;\n+import org.junit.*;\n+import org.junit.rules.ExpectedException;\n \n+import java.util.Comparator;\n import java.util.concurrent.Callable;\n+import java.util.stream.Stream;\n \n import static org.hamcrest.MatcherAssert.assertThat;\n-import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.*;\n+import static org.junit.Assume.assumeThat;\n \n @SuppressWarnings(\"Convert2MethodRef\")\n public class InterfaceStaticMethodsTest {\n \n+    @Rule\n+    public final ExpectedException thrown = ExpectedException.none();\n+\n     @Test\n     public void static_methods_on_interfaces() {\n         assertThat(Interface.staticMethod(), is(42));\n@@ -57,4 +65,31 @@ public class InterfaceStaticMethodsTest {\n             return s + a + b;\n         }\n     }\n+\n+    /**\n+     * Calling a {@code InterfaceMethodref} constant pool entry with {@code invokestatic}\n+     * is not allowed in Java 7 bytecode. It'll fail at class loading time with\n+     * \"VerifyError: Illegal type at constant pool entry\"\n+     */\n+    @Test\n+    public void calling_static_methods_of_library_interfaces__new_interface() {\n+        assumeThat(SystemUtils.JAVA_VERSION_FLOAT, is(lessThan(1.8f)));\n+\n+        thrown.expect(NoClassDefFoundError.class);\n+        thrown.expectMessage(\"java.util.stream.Stream\");\n+        // We don't want this call to prevent loading this whole test class,\n+        // it should only fail when this line is executed\n+        Stream.of(1, 2, 3);\n+    }\n+\n+    @Test\n+    public void calling_static_methods_of_library_interfaces__new_method_on_old_interface() {\n+        assumeThat(SystemUtils.JAVA_VERSION_FLOAT, is(lessThan(1.8f)));\n+\n+        thrown.expect(NoSuchMethodError.class);\n+        thrown.expectMessage(\"naturalOrder\");\n+        // We don't want this call to prevent loading this whole test class,\n+        // it should only fail when this line is executed\n+        Comparator.naturalOrder();\n+    }\n }\n"
    },
    {
        "commit_hash": "d37b134855d4262795e383e020a1910397933abf",
        "previous_commit_hash": "70b2bbbe4dcd4a0d5261b781b0833312e8041818",
        "diff_stats": {
            "additions": 10,
            "deletions": 1
        },
        "diff_content": "@@ -167,7 +167,7 @@ public class LambdaUsageBackporter {\n         }\n \n         private void backportLambda(String invokedName, Type invokedType, Handle bsm, Object[] bsmArgs) {\n-            Class<?> invoker = Helpers.loadClass(context.className);\n+            Class<?> invoker = loadClass(context.className);\n             Handle implMethod = (Handle) bsmArgs[1];\n             Handle bridgeMethod = context.getLambdaBridgeMethod(implMethod);\n \n@@ -175,5 +175,14 @@ public class LambdaUsageBackporter {\n                     invoker, invokedName, invokedType, bsm, bsmArgs);\n             super.visitMethodInsn(INVOKESTATIC, factory.getOwner(), factory.getName(), factory.getDesc(), false);\n         }\n+\n+        private static Class<?> loadClass(String className) {\n+            try {\n+                ClassLoader cl = Thread.currentThread().getContextClassLoader();\n+                return cl.loadClass(className.replace('/', '.'));\n+            } catch (ClassNotFoundException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n     }\n }\n"
    },
    {
        "commit_hash": "c7d6226d2e728922129f932f4474b45364c243cf",
        "previous_commit_hash": "d37b134855d4262795e383e020a1910397933abf",
        "diff_stats": {
            "additions": 2,
            "deletions": 1
        },
        "diff_content": "@@ -35,7 +35,8 @@ public class LambdaClassDumper implements AutoCloseable {\n             Path p = new VirtualPath(\"\");\n             dumperField.set(null, newProxyClassesDumper(p));\n         } catch (Exception e) {\n-            throw new RuntimeException(\"Cannot initialize dumper\", e);\n+            throw new IllegalStateException(\"Cannot initialize dumper; unexpected JDK implementation. \" +\n+                    \"Please run Retrolambda using the Java agent (enable forking in the Maven plugin).\", e);\n         }\n     }\n \n"
    },
    {
        "commit_hash": "86565f93c874f676e43d555f7703a3133096e2f8",
        "previous_commit_hash": "c7d6226d2e728922129f932f4474b45364c243cf",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -87,6 +87,7 @@\n \n     <profiles>\n         <profile>\n+            <!-- TODO: default methods; remove this profile -->\n             <id>no-default-methods</id>\n             <activation>\n                 <property>\n"
    },
    {
        "commit_hash": "86565f93c874f676e43d555f7703a3133096e2f8",
        "previous_commit_hash": "c7d6226d2e728922129f932f4474b45364c243cf",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -83,6 +83,7 @@\n                     </execution>\n                 </executions>\n                 <configuration>\n+                    <!-- TODO: default methods; enable minimizing -->\n                     <!-- <minimizeJar>true</minimizeJar>  --> <!-- http://jira.codehaus.org/browse/MSHADE-174 -->\n                     <relocations>\n                         <relocation>\n"
    },
    {
        "commit_hash": "86565f93c874f676e43d555f7703a3133096e2f8",
        "previous_commit_hash": "c7d6226d2e728922129f932f4474b45364c243cf",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -6,6 +6,7 @@ package net.orfjackal.retrolambda;\n \n public class FeatureToggles {\n \n+    // TODO: default methods; remove this toggle and all other related TODOs\n     public static final int DEFAULT_METHODS = parseInt(System.getenv(\"DEFAULT_METHODS\"), 0);\n \n     private static int parseInt(String value, int defaultValue) {\n"
    },
    {
        "commit_hash": "7ccbe2281dae7277fbab955cdeb14220307192ea",
        "previous_commit_hash": "86565f93c874f676e43d555f7703a3133096e2f8",
        "diff_stats": {
            "additions": 3,
            "deletions": 4
        },
        "diff_content": "@@ -16,14 +16,13 @@ public class LambdaClassBackporter {\n \n     public static byte[] transform(byte[] bytecode, int targetVersion) {\n         ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n-        if (FeatureToggles.DEFAULT_METHODS == 0) {\n-            LambdaClassVisitor stage1 = new LambdaClassVisitor(writer, targetVersion);\n-            new ClassReader(bytecode).accept(stage1, 0);\n-        }\n         if (FeatureToggles.DEFAULT_METHODS == 1) {\n             ClassModifier stage2 = new ClassModifier(targetVersion, writer);\n             LambdaClassVisitor stage1 = new LambdaClassVisitor(stage2, targetVersion);\n             new ClassReader(bytecode).accept(stage1, 0);\n+        } else {\n+            LambdaClassVisitor stage1 = new LambdaClassVisitor(writer, targetVersion);\n+            new ClassReader(bytecode).accept(stage1, 0);\n         }\n         return writer.toByteArray();\n     }\n"
    },
    {
        "commit_hash": "7ccbe2281dae7277fbab955cdeb14220307192ea",
        "previous_commit_hash": "86565f93c874f676e43d555f7703a3133096e2f8",
        "diff_stats": {
            "additions": 3,
            "deletions": 4
        },
        "diff_content": "@@ -18,15 +18,14 @@ public class LambdaUsageBackporter {\n     public static byte[] transform(byte[] bytecode, int targetVersion) {\n         resetLambdaClassSequenceNumber();\n         ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n-        if (FeatureToggles.DEFAULT_METHODS == 0) {\n-            InvokeDynamicInsnConverter stage1 = new InvokeDynamicInsnConverter(writer, targetVersion);\n-            new ClassReader(bytecode).accept(stage1, 0);\n-        }\n         if (FeatureToggles.DEFAULT_METHODS == 1) {\n             ClassModifier stage3 = new ClassModifier(targetVersion, writer);\n             InterfaceModifier stage2 = new InterfaceModifier(stage3, targetVersion);\n             InvokeDynamicInsnConverter stage1 = new InvokeDynamicInsnConverter(stage2, targetVersion);\n             new ClassReader(bytecode).accept(stage1, 0);\n+        } else {\n+            InvokeDynamicInsnConverter stage1 = new InvokeDynamicInsnConverter(writer, targetVersion);\n+            new ClassReader(bytecode).accept(stage1, 0);\n         }\n         return writer.toByteArray();\n     }\n"
    },
    {
        "commit_hash": "f6f4aeec00b9a7a12bb0bb5b05496e934d8595fd",
        "previous_commit_hash": "7ccbe2281dae7277fbab955cdeb14220307192ea",
        "diff_stats": {
            "additions": 6,
            "deletions": 0
        },
        "diff_content": "@@ -20,6 +20,12 @@\n             <artifactId>asm-debug-all</artifactId>\n         </dependency>\n \n+        <dependency>\n+            <groupId>com.google.guava</groupId>\n+            <artifactId>guava</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+\n     </dependencies>\n \n     <build>\n"
    },
    {
        "commit_hash": "f6f4aeec00b9a7a12bb0bb5b05496e934d8595fd",
        "previous_commit_hash": "7ccbe2281dae7277fbab955cdeb14220307192ea",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -11,6 +11,7 @@\n     <orderEntry type=\"inheritedJdk\" />\n     <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n     <orderEntry type=\"library\" name=\"Maven: org.ow2.asm:asm-debug-all:5.0.2\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: com.google.guava:guava:17.0\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.11\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-library:1.3\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-core:1.3\" level=\"project\" />\n"
    },
    {
        "commit_hash": "f6f4aeec00b9a7a12bb0bb5b05496e934d8595fd",
        "previous_commit_hash": "7ccbe2281dae7277fbab955cdeb14220307192ea",
        "diff_stats": {
            "additions": 37,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,37 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda;\n+\n+import org.objectweb.asm.*;\n+\n+import java.util.*;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+public class ClassHierarchyAnalyzer {\n+\n+    private final Map<Type, List<Type>> interfacesByImplementer = new HashMap<>();\n+\n+    public void analyze(byte[] bytecode) {\n+        ClassReader cr = new ClassReader(bytecode);\n+        Type implementer = classNameToType(cr.getClassName());\n+        List<Type> interfaces = classNamesToTypes(cr.getInterfaces());\n+        interfacesByImplementer.put(implementer, interfaces);\n+    }\n+\n+    public List<Type> getInterfaces(Type type) {\n+        return interfacesByImplementer.get(type);\n+    }\n+\n+    private static List<Type> classNamesToTypes(String[] interfaces) {\n+        return Arrays.asList(interfaces).stream() // TODO: use Stream.of() once it's supported\n+                .map(ClassHierarchyAnalyzer::classNameToType)\n+                .collect(toList());\n+    }\n+\n+    private static Type classNameToType(String className) {\n+        return Type.getType(\"L\" + className + \";\");\n+    }\n+}\n"
    },
    {
        "commit_hash": "f6f4aeec00b9a7a12bb0bb5b05496e934d8595fd",
        "previous_commit_hash": "7ccbe2281dae7277fbab955cdeb14220307192ea",
        "diff_stats": {
            "additions": 72,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,72 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda;\n+\n+import com.google.common.io.ByteStreams;\n+import org.junit.Test;\n+import org.objectweb.asm.Type;\n+\n+import java.io.*;\n+import java.util.List;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.stream.Collectors.toList;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.*;\n+\n+public class ClassHierarchyAnalyzerTest {\n+\n+    private final ClassHierarchyAnalyzer analyzer = new ClassHierarchyAnalyzer();\n+\n+    @Test\n+    public void no_parent_interfaces() {\n+        analyze(Interface.class);\n+\n+        assertThat(getInterfaces(Interface.class), is(empty()));\n+    }\n+\n+    @Test\n+    public void immediate_interfaces_implemented_by_a_class() {\n+        analyze(InterfaceImplementer.class);\n+\n+        assertThat(getInterfaces(InterfaceImplementer.class), is(asList((Class<?>) Interface.class)));\n+    }\n+\n+    private interface Interface {\n+    }\n+\n+    private class InterfaceImplementer implements Interface {\n+    }\n+\n+\n+    // helpers\n+\n+    private void analyze(Class<?> clazz) {\n+        byte[] bytecode = readBytecode(clazz);\n+        analyzer.analyze(bytecode);\n+    }\n+\n+    private static byte[] readBytecode(Class<?> clazz) {\n+        try (InputStream in = clazz.getResourceAsStream(\"/\" + Type.getType(clazz).getInternalName() + \".class\")) {\n+            return ByteStreams.toByteArray(in);\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private List<Class<?>> getInterfaces(Class<?> clazz) {\n+        return analyzer.getInterfaces(Type.getType(clazz)).stream()\n+                .map(ClassHierarchyAnalyzerTest::toClass)\n+                .collect(toList());\n+    }\n+\n+    private static Class<?> toClass(Type type) {\n+        try {\n+            return Class.forName(type.getClassName());\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+}\n"
    },
    {
        "commit_hash": "75464cc274c7bd0b08aba69a568dae862205047f",
        "previous_commit_hash": "f6f4aeec00b9a7a12bb0bb5b05496e934d8595fd",
        "diff_stats": {
            "additions": 2,
            "deletions": 1
        },
        "diff_content": "@@ -7,6 +7,7 @@ package net.orfjackal.retrolambda;\n import org.objectweb.asm.*;\n \n import java.util.*;\n+import java.util.stream.Stream;\n \n import static java.util.stream.Collectors.toList;\n \n@@ -26,7 +27,7 @@ public class ClassHierarchyAnalyzer {\n     }\n \n     private static List<Type> classNamesToTypes(String[] interfaces) {\n-        return Arrays.asList(interfaces).stream() // TODO: use Stream.of() once it's supported\n+        return Stream.of(interfaces)\n                 .map(ClassHierarchyAnalyzer::classNameToType)\n                 .collect(toList());\n     }\n"
    },
    {
        "commit_hash": "75464cc274c7bd0b08aba69a568dae862205047f",
        "previous_commit_hash": "f6f4aeec00b9a7a12bb0bb5b05496e934d8595fd",
        "diff_stats": {
            "additions": 38,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,38 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda;\n+\n+import org.objectweb.asm.*;\n+\n+import static org.objectweb.asm.Opcodes.*;\n+\n+public class InvokeStaticInterfaceMethodConverter extends ClassVisitor {\n+\n+    public InvokeStaticInterfaceMethodConverter(ClassVisitor next) {\n+        super(ASM5, next);\n+    }\n+\n+    @Override\n+    public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+        return new MyMethodVisitor(super.visitMethod(access, name, desc, signature, exceptions));\n+    }\n+\n+\n+    private static class MyMethodVisitor extends MethodVisitor {\n+\n+        public MyMethodVisitor(MethodVisitor next) {\n+            super(Opcodes.ASM5, next);\n+        }\n+\n+        @Override\n+        public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\n+            if (opcode == INVOKESTATIC && itf) {\n+                // pre-Java8 bytecode is not allowed to do invokestatic calls on interface method references\n+                itf = false;\n+            }\n+            super.visitMethodInsn(opcode, owner, name, desc, itf);\n+        }\n+    }\n+}\n"
    },
    {
        "commit_hash": "75464cc274c7bd0b08aba69a568dae862205047f",
        "previous_commit_hash": "f6f4aeec00b9a7a12bb0bb5b05496e934d8595fd",
        "diff_stats": {
            "additions": 2,
            "deletions": 1
        },
        "diff_content": "@@ -24,7 +24,8 @@ public class LambdaUsageBackporter {\n             InvokeDynamicInsnConverter stage1 = new InvokeDynamicInsnConverter(stage2, targetVersion);\n             new ClassReader(bytecode).accept(stage1, 0);\n         } else {\n-            InvokeDynamicInsnConverter stage1 = new InvokeDynamicInsnConverter(writer, targetVersion);\n+            InvokeStaticInterfaceMethodConverter stage2 = new InvokeStaticInterfaceMethodConverter(writer);\n+            InvokeDynamicInsnConverter stage1 = new InvokeDynamicInsnConverter(stage2, targetVersion);\n             new ClassReader(bytecode).accept(stage1, 0);\n         }\n         return writer.toByteArray();\n"
    },
    {
        "commit_hash": "8da77d2862c69f4908f1edcdfd5e520dead5c1c6",
        "previous_commit_hash": "75464cc274c7bd0b08aba69a568dae862205047f",
        "diff_stats": {
            "additions": 5,
            "deletions": 5
        },
        "diff_content": "@@ -16,14 +16,14 @@ public class LambdaClassBackporter {\n \n     public static byte[] transform(byte[] bytecode, int targetVersion) {\n         ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n+        ClassVisitor next = writer;\n         if (FeatureToggles.DEFAULT_METHODS == 1) {\n-            ClassModifier stage2 = new ClassModifier(targetVersion, writer);\n-            LambdaClassVisitor stage1 = new LambdaClassVisitor(stage2, targetVersion);\n-            new ClassReader(bytecode).accept(stage1, 0);\n+            next = new ClassModifier(targetVersion, next);\n+            next = new LambdaClassVisitor(next, targetVersion);\n         } else {\n-            LambdaClassVisitor stage1 = new LambdaClassVisitor(writer, targetVersion);\n-            new ClassReader(bytecode).accept(stage1, 0);\n+            next = new LambdaClassVisitor(next, targetVersion);\n         }\n+        new ClassReader(bytecode).accept(next, 0);\n         return writer.toByteArray();\n     }\n \n"
    },
    {
        "commit_hash": "8da77d2862c69f4908f1edcdfd5e520dead5c1c6",
        "previous_commit_hash": "75464cc274c7bd0b08aba69a568dae862205047f",
        "diff_stats": {
            "additions": 7,
            "deletions": 7
        },
        "diff_content": "@@ -18,16 +18,16 @@ public class LambdaUsageBackporter {\n     public static byte[] transform(byte[] bytecode, int targetVersion) {\n         resetLambdaClassSequenceNumber();\n         ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n+        ClassVisitor next = writer;\n         if (FeatureToggles.DEFAULT_METHODS == 1) {\n-            ClassModifier stage3 = new ClassModifier(targetVersion, writer);\n-            InterfaceModifier stage2 = new InterfaceModifier(stage3, targetVersion);\n-            InvokeDynamicInsnConverter stage1 = new InvokeDynamicInsnConverter(stage2, targetVersion);\n-            new ClassReader(bytecode).accept(stage1, 0);\n+            next = new ClassModifier(targetVersion, next);\n+            next = new InterfaceModifier(next, targetVersion);\n+            next = new InvokeDynamicInsnConverter(next, targetVersion);\n         } else {\n-            InvokeStaticInterfaceMethodConverter stage2 = new InvokeStaticInterfaceMethodConverter(writer);\n-            InvokeDynamicInsnConverter stage1 = new InvokeDynamicInsnConverter(stage2, targetVersion);\n-            new ClassReader(bytecode).accept(stage1, 0);\n+            next = new InvokeStaticInterfaceMethodConverter(next);\n+            next = new InvokeDynamicInsnConverter(next, targetVersion);\n         }\n+        new ClassReader(bytecode).accept(next, 0);\n         return writer.toByteArray();\n     }\n \n"
    },
    {
        "commit_hash": "f63f5d892388f4b753305195e8a123c82e0dad90",
        "previous_commit_hash": "8da77d2862c69f4908f1edcdfd5e520dead5c1c6",
        "diff_stats": {
            "additions": 4,
            "deletions": 0
        },
        "diff_content": "@@ -23,6 +23,10 @@ public class LambdaUsageBackporter {\n             next = new ClassModifier(targetVersion, next);\n             next = new InterfaceModifier(next, targetVersion);\n             next = new InvokeDynamicInsnConverter(next, targetVersion);\n+        } else if (FeatureToggles.DEFAULT_METHODS == 2) {\n+            next = new RemoveDefaultMethods(next);\n+            next = new InvokeStaticInterfaceMethodConverter(next);\n+            next = new InvokeDynamicInsnConverter(next, targetVersion);\n         } else {\n             next = new InvokeStaticInterfaceMethodConverter(next);\n             next = new InvokeDynamicInsnConverter(next, targetVersion);\n"
    },
    {
        "commit_hash": "f63f5d892388f4b753305195e8a123c82e0dad90",
        "previous_commit_hash": "8da77d2862c69f4908f1edcdfd5e520dead5c1c6",
        "diff_stats": {
            "additions": 33,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,33 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda;\n+\n+import org.objectweb.asm.*;\n+\n+import static org.objectweb.asm.Opcodes.*;\n+\n+public class RemoveDefaultMethods extends ClassVisitor {\n+\n+    private boolean isInterface;\n+\n+    public RemoveDefaultMethods(ClassVisitor next) {\n+        super(ASM5, next);\n+    }\n+\n+    @Override\n+    public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n+        isInterface = Flags.hasFlag(access, ACC_INTERFACE);\n+        super.visit(version, access, name, signature, superName, interfaces);\n+    }\n+\n+    @Override\n+    public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+        if (isInterface && !Flags.hasFlag(access, ACC_ABSTRACT)) {\n+            return null;\n+        } else {\n+            return super.visitMethod(access, name, desc, signature, exceptions);\n+        }\n+    }\n+}\n"
    },
    {
        "commit_hash": "23cfe1b9dca6a28a2e31bf66726d237f8f5eae20",
        "previous_commit_hash": "f63f5d892388f4b753305195e8a123c82e0dad90",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -76,7 +76,7 @@ public class InterfaceStaticMethodsTest {\n         assumeThat(SystemUtils.JAVA_VERSION_FLOAT, is(lessThan(1.8f)));\n \n         thrown.expect(NoClassDefFoundError.class);\n-        thrown.expectMessage(\"java.util.stream.Stream\");\n+        thrown.expectMessage(\"java/util/stream/Stream\");\n         // We don't want this call to prevent loading this whole test class,\n         // it should only fail when this line is executed\n         Stream.of(1, 2, 3);\n@@ -86,8 +86,8 @@ public class InterfaceStaticMethodsTest {\n     public void calling_static_methods_of_library_interfaces__new_method_on_old_interface() {\n         assumeThat(SystemUtils.JAVA_VERSION_FLOAT, is(lessThan(1.8f)));\n \n-        thrown.expect(NoSuchMethodError.class);\n-        thrown.expectMessage(\"naturalOrder\");\n+        thrown.expect(IncompatibleClassChangeError.class);\n+        thrown.expectMessage(\"Found interface java.util.Comparator, but class was expected\");\n         // We don't want this call to prevent loading this whole test class,\n         // it should only fail when this line is executed\n         Comparator.naturalOrder();\n"
    },
    {
        "commit_hash": "9420a75aa4dcbef5755b22eb08ad425e76afbe05",
        "previous_commit_hash": "23cfe1b9dca6a28a2e31bf66726d237f8f5eae20",
        "diff_stats": {
            "additions": 21,
            "deletions": 3
        },
        "diff_content": "@@ -10,19 +10,37 @@ import java.util.*;\n import java.util.stream.Stream;\n \n import static java.util.stream.Collectors.toList;\n+import static org.objectweb.asm.Opcodes.ACC_INTERFACE;\n \n public class ClassHierarchyAnalyzer {\n \n+    private final List<Type> interfaces = new ArrayList<>();\n+    private final List<Type> classes = new ArrayList<>();\n     private final Map<Type, List<Type>> interfacesByImplementer = new HashMap<>();\n \n     public void analyze(byte[] bytecode) {\n         ClassReader cr = new ClassReader(bytecode);\n-        Type implementer = classNameToType(cr.getClassName());\n+        Type clazz = classNameToType(cr.getClassName());\n+\n+        if (Flags.hasFlag(cr.getAccess(), ACC_INTERFACE)) {\n+            interfaces.add(clazz);\n+        } else {\n+            classes.add(clazz);\n+        }\n+\n         List<Type> interfaces = classNamesToTypes(cr.getInterfaces());\n-        interfacesByImplementer.put(implementer, interfaces);\n+        interfacesByImplementer.put(clazz, interfaces);\n+    }\n+\n+    public List<Type> getInterfaces() {\n+        return interfaces;\n+    }\n+\n+    public List<Type> getClasses() {\n+        return classes;\n     }\n \n-    public List<Type> getInterfaces(Type type) {\n+    public List<Type> getInterfacesOf(Type type) {\n         return interfacesByImplementer.get(type);\n     }\n \n"
    },
    {
        "commit_hash": "9420a75aa4dcbef5755b22eb08ad425e76afbe05",
        "previous_commit_hash": "23cfe1b9dca6a28a2e31bf66726d237f8f5eae20",
        "diff_stats": {
            "additions": 39,
            "deletions": 11
        },
        "diff_content": "@@ -20,18 +20,27 @@ public class ClassHierarchyAnalyzerTest {\n \n     private final ClassHierarchyAnalyzer analyzer = new ClassHierarchyAnalyzer();\n \n+    @Test\n+    public void separates_interfaces_from_classes() {\n+        analyze(Interface.class);\n+        analyze(InterfaceImplementer.class);\n+\n+        assertThat(getInterfaces(), is(classList(Interface.class)));\n+        assertThat(getClasses(), is(classList(InterfaceImplementer.class)));\n+    }\n+\n     @Test\n     public void no_parent_interfaces() {\n         analyze(Interface.class);\n \n-        assertThat(getInterfaces(Interface.class), is(empty()));\n+        assertThat(getInterfacesOf(Interface.class), is(empty()));\n     }\n \n     @Test\n     public void immediate_interfaces_implemented_by_a_class() {\n         analyze(InterfaceImplementer.class);\n \n-        assertThat(getInterfaces(InterfaceImplementer.class), is(asList((Class<?>) Interface.class)));\n+        assertThat(getInterfacesOf(InterfaceImplementer.class), is(classList(Interface.class)));\n     }\n \n     private interface Interface {\n@@ -41,27 +50,38 @@ public class ClassHierarchyAnalyzerTest {\n     }\n \n \n-    // helpers\n+    // API wrappers\n \n     private void analyze(Class<?> clazz) {\n         byte[] bytecode = readBytecode(clazz);\n         analyzer.analyze(bytecode);\n     }\n \n-    private static byte[] readBytecode(Class<?> clazz) {\n-        try (InputStream in = clazz.getResourceAsStream(\"/\" + Type.getType(clazz).getInternalName() + \".class\")) {\n-            return ByteStreams.toByteArray(in);\n-        } catch (IOException e) {\n-            throw new RuntimeException(e);\n-        }\n+    private List<Class<?>> getInterfaces() {\n+        return toClassList(analyzer.getInterfaces());\n+    }\n+\n+    private List<Class<?>> getClasses() {\n+        return toClassList(analyzer.getClasses());\n     }\n \n-    private List<Class<?>> getInterfaces(Class<?> clazz) {\n-        return analyzer.getInterfaces(Type.getType(clazz)).stream()\n+    private List<Class<?>> getInterfacesOf(Class<?> clazz) {\n+        return toClassList(analyzer.getInterfacesOf(Type.getType(clazz)));\n+    }\n+\n+\n+    // other helpers\n+\n+    private static List<Class<?>> toClassList(List<Type> types) {\n+        return types.stream()\n                 .map(ClassHierarchyAnalyzerTest::toClass)\n                 .collect(toList());\n     }\n \n+    private static List<Class<?>> classList(Class<?>... aClass) {\n+        return asList(aClass);\n+    }\n+\n     private static Class<?> toClass(Type type) {\n         try {\n             return Class.forName(type.getClassName());\n@@ -69,4 +89,12 @@ public class ClassHierarchyAnalyzerTest {\n             throw new RuntimeException(e);\n         }\n     }\n+\n+    private static byte[] readBytecode(Class<?> clazz) {\n+        try (InputStream in = clazz.getResourceAsStream(\"/\" + Type.getType(clazz).getInternalName() + \".class\")) {\n+            return ByteStreams.toByteArray(in);\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n }\n"
    },
    {
        "commit_hash": "81f78657193f1ce288c6310309d7d7650f29f074",
        "previous_commit_hash": "9420a75aa4dcbef5755b22eb08ad425e76afbe05",
        "diff_stats": {
            "additions": 5,
            "deletions": 10
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -10,12 +10,10 @@ import java.nio.file.attribute.BasicFileAttributes;\n \n public abstract class BytecodeTransformingFileVisitor extends SimpleFileVisitor<Path> {\n \n-    private final Path inputDir;\n-    private final Path outputDir;\n+    private final ClassSaver saver;\n \n-    public BytecodeTransformingFileVisitor(Path inputDir, Path outputDir) {\n-        this.inputDir = inputDir;\n-        this.outputDir = outputDir;\n+    public BytecodeTransformingFileVisitor(ClassSaver saver) {\n+        this.saver = saver;\n     }\n \n     @Override\n@@ -23,10 +21,7 @@ public abstract class BytecodeTransformingFileVisitor extends SimpleFileVisitor<\n         if (isJavaClass(inputFile)) {\n             byte[] originalBytes = Files.readAllBytes(inputFile);\n             byte[] transformedBytes = transform(originalBytes);\n-\n-            Path outputFile = outputDir.resolve(inputDir.relativize(inputFile));\n-            Files.createDirectories(outputFile.getParent());\n-            Files.write(outputFile, transformedBytes);\n+            saver.save(transformedBytes);\n         }\n         return FileVisitResult.CONTINUE;\n     }\n"
    },
    {
        "commit_hash": "81f78657193f1ce288c6310309d7d7650f29f074",
        "previous_commit_hash": "9420a75aa4dcbef5755b22eb08ad425e76afbe05",
        "diff_stats": {
            "additions": 26,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,26 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda;\n+\n+import org.objectweb.asm.ClassReader;\n+\n+import java.io.IOException;\n+import java.nio.file.*;\n+\n+public class ClassSaver {\n+\n+    private final Path outputDir;\n+\n+    public ClassSaver(Path outputDir) {\n+        this.outputDir = outputDir;\n+    }\n+\n+    public void save(byte[] bytecode) throws IOException {\n+        ClassReader cr = new ClassReader(bytecode);\n+        Path outputFile = outputDir.resolve(cr.getClassName() + \".class\");\n+        Files.createDirectories(outputFile.getParent());\n+        Files.write(outputFile, bytecode);\n+    }\n+}\n"
    },
    {
        "commit_hash": "81f78657193f1ce288c6310309d7d7650f29f074",
        "previous_commit_hash": "9420a75aa4dcbef5755b22eb08ad425e76afbe05",
        "diff_stats": {
            "additions": 2,
            "deletions": 1
        },
        "diff_content": "@@ -36,7 +36,8 @@ public class Retrolambda {\n             if (!PreMain.isAgentLoaded()) {\n                 dumper.install();\n             }\n-            visitFiles(inputDir, includedFiles, new BytecodeTransformingFileVisitor(inputDir, outputDir) {\n+            ClassSaver saver = new ClassSaver(outputDir);\n+            visitFiles(inputDir, includedFiles, new BytecodeTransformingFileVisitor(saver) {\n                 @Override\n                 protected byte[] transform(byte[] bytecode) {\n                     return LambdaUsageBackporter.transform(bytecode, bytecodeVersion);\n"
    },
    {
        "commit_hash": "bc599ff321fda7148c2362f2c5746bd52dca3501",
        "previous_commit_hash": "81f78657193f1ce288c6310309d7d7650f29f074",
        "diff_stats": {
            "additions": 3,
            "deletions": 11
        },
        "diff_content": "@@ -8,25 +8,17 @@ import java.io.IOException;\n import java.nio.file.*;\n import java.nio.file.attribute.BasicFileAttributes;\n \n-public abstract class BytecodeTransformingFileVisitor extends SimpleFileVisitor<Path> {\n-\n-    private final ClassSaver saver;\n-\n-    public BytecodeTransformingFileVisitor(ClassSaver saver) {\n-        this.saver = saver;\n-    }\n+public abstract class BytecodeFileVisitor extends SimpleFileVisitor<Path> {\n \n     @Override\n     public FileVisitResult visitFile(Path inputFile, BasicFileAttributes attrs) throws IOException {\n         if (isJavaClass(inputFile)) {\n-            byte[] originalBytes = Files.readAllBytes(inputFile);\n-            byte[] transformedBytes = transform(originalBytes);\n-            saver.save(transformedBytes);\n+            visit(Files.readAllBytes(inputFile));\n         }\n         return FileVisitResult.CONTINUE;\n     }\n \n-    protected abstract byte[] transform(byte[] bytecode);\n+    protected abstract void visit(byte[] bytecode);\n \n     private static boolean isJavaClass(Path file) {\n         return file.getFileName().toString().endsWith(\".class\");\n"
    },
    {
        "commit_hash": "bc599ff321fda7148c2362f2c5746bd52dca3501",
        "previous_commit_hash": "81f78657193f1ce288c6310309d7d7650f29f074",
        "diff_stats": {
            "additions": 6,
            "deletions": 6
        },
        "diff_content": "@@ -14,8 +14,8 @@ import static org.objectweb.asm.Opcodes.ACC_INTERFACE;\n \n public class ClassHierarchyAnalyzer {\n \n-    private final List<Type> interfaces = new ArrayList<>();\n-    private final List<Type> classes = new ArrayList<>();\n+    private final List<ClassReader> interfaces = new ArrayList<>();\n+    private final List<ClassReader> classes = new ArrayList<>();\n     private final Map<Type, List<Type>> interfacesByImplementer = new HashMap<>();\n \n     public void analyze(byte[] bytecode) {\n@@ -23,20 +23,20 @@ public class ClassHierarchyAnalyzer {\n         Type clazz = classNameToType(cr.getClassName());\n \n         if (Flags.hasFlag(cr.getAccess(), ACC_INTERFACE)) {\n-            interfaces.add(clazz);\n+            interfaces.add(cr);\n         } else {\n-            classes.add(clazz);\n+            classes.add(cr);\n         }\n \n         List<Type> interfaces = classNamesToTypes(cr.getInterfaces());\n         interfacesByImplementer.put(clazz, interfaces);\n     }\n \n-    public List<Type> getInterfaces() {\n+    public List<ClassReader> getInterfaces() {\n         return interfaces;\n     }\n \n-    public List<Type> getClasses() {\n+    public List<ClassReader> getClasses() {\n         return classes;\n     }\n \n"
    },
    {
        "commit_hash": "bc599ff321fda7148c2362f2c5746bd52dca3501",
        "previous_commit_hash": "81f78657193f1ce288c6310309d7d7650f29f074",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -15,7 +15,7 @@ import static org.objectweb.asm.Opcodes.*;\n \n public class LambdaUsageBackporter {\n \n-    public static byte[] transform(byte[] bytecode, int targetVersion) {\n+    public static byte[] transform(ClassReader reader, int targetVersion) {\n         resetLambdaClassSequenceNumber();\n         ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n         ClassVisitor next = writer;\n@@ -31,7 +31,7 @@ public class LambdaUsageBackporter {\n             next = new InvokeStaticInterfaceMethodConverter(next);\n             next = new InvokeDynamicInsnConverter(next, targetVersion);\n         }\n-        new ClassReader(bytecode).accept(next, 0);\n+        reader.accept(next, 0);\n         return writer.toByteArray();\n     }\n \n"
    },
    {
        "commit_hash": "bc599ff321fda7148c2362f2c5746bd52dca3501",
        "previous_commit_hash": "81f78657193f1ce288c6310309d7d7650f29f074",
        "diff_stats": {
            "additions": 15,
            "deletions": 4
        },
        "diff_content": "@@ -4,6 +4,8 @@\n \n package net.orfjackal.retrolambda;\n \n+import org.objectweb.asm.ClassReader;\n+\n import java.io.IOException;\n import java.net.*;\n import java.nio.file.*;\n@@ -36,13 +38,22 @@ public class Retrolambda {\n             if (!PreMain.isAgentLoaded()) {\n                 dumper.install();\n             }\n-            ClassSaver saver = new ClassSaver(outputDir);\n-            visitFiles(inputDir, includedFiles, new BytecodeTransformingFileVisitor(saver) {\n+\n+            ClassHierarchyAnalyzer analyzer = new ClassHierarchyAnalyzer();\n+            visitFiles(inputDir, includedFiles, new BytecodeFileVisitor() {\n                 @Override\n-                protected byte[] transform(byte[] bytecode) {\n-                    return LambdaUsageBackporter.transform(bytecode, bytecodeVersion);\n+                protected void visit(byte[] bytecode) {\n+                    analyzer.analyze(bytecode);\n                 }\n             });\n+\n+            ClassSaver saver = new ClassSaver(outputDir);\n+            for (ClassReader reader : analyzer.getInterfaces()) {\n+                saver.save(LambdaUsageBackporter.transform(reader, bytecodeVersion));\n+            }\n+            for (ClassReader reader : analyzer.getClasses()) {\n+                saver.save(LambdaUsageBackporter.transform(reader, bytecodeVersion));\n+            }\n         }\n     }\n \n"
    },
    {
        "commit_hash": "bc599ff321fda7148c2362f2c5746bd52dca3501",
        "previous_commit_hash": "81f78657193f1ce288c6310309d7d7650f29f074",
        "diff_stats": {
            "additions": 19,
            "deletions": 5
        },
        "diff_content": "@@ -6,7 +6,7 @@ package net.orfjackal.retrolambda;\n \n import com.google.common.io.ByteStreams;\n import org.junit.Test;\n-import org.objectweb.asm.Type;\n+import org.objectweb.asm.*;\n \n import java.io.*;\n import java.util.List;\n@@ -58,21 +58,27 @@ public class ClassHierarchyAnalyzerTest {\n     }\n \n     private List<Class<?>> getInterfaces() {\n-        return toClassList(analyzer.getInterfaces());\n+        return readersToClasses(analyzer.getInterfaces());\n     }\n \n     private List<Class<?>> getClasses() {\n-        return toClassList(analyzer.getClasses());\n+        return readersToClasses(analyzer.getClasses());\n     }\n \n     private List<Class<?>> getInterfacesOf(Class<?> clazz) {\n-        return toClassList(analyzer.getInterfacesOf(Type.getType(clazz)));\n+        return typesToClasses(analyzer.getInterfacesOf(Type.getType(clazz)));\n     }\n \n \n     // other helpers\n \n-    private static List<Class<?>> toClassList(List<Type> types) {\n+    private static List<Class<?>> readersToClasses(List<ClassReader> readers) {\n+        return readers.stream()\n+                .map(ClassHierarchyAnalyzerTest::toClass)\n+                .collect(toList());\n+    }\n+\n+    private static List<Class<?>> typesToClasses(List<Type> types) {\n         return types.stream()\n                 .map(ClassHierarchyAnalyzerTest::toClass)\n                 .collect(toList());\n@@ -82,6 +88,14 @@ public class ClassHierarchyAnalyzerTest {\n         return asList(aClass);\n     }\n \n+    private static Class<?> toClass(ClassReader reader) {\n+        try {\n+            return Class.forName(reader.getClassName().replace('/', '.'));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n     private static Class<?> toClass(Type type) {\n         try {\n             return Class.forName(type.getClassName());\n"
    },
    {
        "commit_hash": "e7122935077bc8bf99d00fe92d2defd65be4c3ba",
        "previous_commit_hash": "bc599ff321fda7148c2362f2c5746bd52dca3501",
        "diff_stats": {
            "additions": 12,
            "deletions": 18
        },
        "diff_content": "@@ -19,25 +19,22 @@ public class LambdaClassBackporter {\n         ClassVisitor next = writer;\n         if (FeatureToggles.DEFAULT_METHODS == 1) {\n             next = new ClassModifier(targetVersion, next);\n-            next = new LambdaClassVisitor(next, targetVersion);\n-        } else {\n-            next = new LambdaClassVisitor(next, targetVersion);\n         }\n+        next = new LambdaClassVisitor(next);\n+        next = new LowerBytecodeVersion(next, targetVersion);\n         new ClassReader(bytecode).accept(next, 0);\n         return writer.toByteArray();\n     }\n \n     private static class LambdaClassVisitor extends ClassVisitor {\n-        private final int targetVersion;\n         private String lambdaClass;\n         private Type constructor;\n         private Handle implMethod;\n         private Handle bridgeMethod;\n         private LambdaFactoryMethod factoryMethod;\n \n-        public LambdaClassVisitor(ClassVisitor cv, int targetVersion) {\n-            super(ASM5, cv);\n-            this.targetVersion = targetVersion;\n+        public LambdaClassVisitor(ClassVisitor next) {\n+            super(ASM5, next);\n         }\n \n         @Override\n@@ -48,9 +45,6 @@ public class LambdaClassBackporter {\n             bridgeMethod = LambdaReifier.getLambdaBridgeMethod();\n             factoryMethod = LambdaReifier.getLambdaFactoryMethod();\n \n-            if (version > targetVersion) {\n-                version = targetVersion;\n-            }\n             if (superName.equals(LambdaNaming.MAGIC_LAMBDA_IMPL)) {\n                 superName = JAVA_LANG_OBJECT;\n             }\n@@ -62,10 +56,10 @@ public class LambdaClassBackporter {\n             if (name.equals(\"<init>\")) {\n                 constructor = Type.getMethodType(desc);\n             }\n-            MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n-            mv = new MagicLambdaRemovingMethodVisitor(mv);\n-            mv = new PrivateMethodInvocationFixingMethodVisitor(mv, this);\n-            return mv;\n+            MethodVisitor next = super.visitMethod(access, name, desc, signature, exceptions);\n+            next = new MagicLambdaRemovingMethodVisitor(next);\n+            next = new PrivateMethodInvocationFixingMethodVisitor(next, this);\n+            return next;\n         }\n \n         @Override\n@@ -129,8 +123,8 @@ public class LambdaClassBackporter {\n \n     private static class MagicLambdaRemovingMethodVisitor extends MethodVisitor {\n \n-        public MagicLambdaRemovingMethodVisitor(MethodVisitor mv) {\n-            super(ASM5, mv);\n+        public MagicLambdaRemovingMethodVisitor(MethodVisitor next) {\n+            super(ASM5, next);\n         }\n \n         @Override\n@@ -150,8 +144,8 @@ public class LambdaClassBackporter {\n         private final Handle implMethod;\n         private final Handle bridgeMethod;\n \n-        public PrivateMethodInvocationFixingMethodVisitor(MethodVisitor mv, LambdaClassVisitor context) {\n-            super(ASM5, mv);\n+        public PrivateMethodInvocationFixingMethodVisitor(MethodVisitor next, LambdaClassVisitor context) {\n+            super(ASM5, next);\n             this.implMethod = context.implMethod;\n             this.bridgeMethod = context.bridgeMethod;\n         }\n"
    },
    {
        "commit_hash": "e7122935077bc8bf99d00fe92d2defd65be4c3ba",
        "previous_commit_hash": "bc599ff321fda7148c2362f2c5746bd52dca3501",
        "diff_stats": {
            "additions": 5,
            "deletions": 11
        },
        "diff_content": "@@ -22,15 +22,14 @@ public class LambdaUsageBackporter {\n         if (FeatureToggles.DEFAULT_METHODS == 1) {\n             next = new ClassModifier(targetVersion, next);\n             next = new InterfaceModifier(next, targetVersion);\n-            next = new InvokeDynamicInsnConverter(next, targetVersion);\n         } else if (FeatureToggles.DEFAULT_METHODS == 2) {\n             next = new RemoveDefaultMethods(next);\n             next = new InvokeStaticInterfaceMethodConverter(next);\n-            next = new InvokeDynamicInsnConverter(next, targetVersion);\n         } else {\n             next = new InvokeStaticInterfaceMethodConverter(next);\n-            next = new InvokeDynamicInsnConverter(next, targetVersion);\n         }\n+        next = new InvokeDynamicInsnConverter(next);\n+        next = new LowerBytecodeVersion(next, targetVersion);\n         reader.accept(next, 0);\n         return writer.toByteArray();\n     }\n@@ -51,21 +50,16 @@ public class LambdaUsageBackporter {\n \n \n     private static class InvokeDynamicInsnConverter extends ClassVisitor {\n-        private final int targetVersion;\n         private int classAccess;\n         String className;\n         private final Map<Handle, Handle> lambdaBridgesToImplMethods = new LinkedHashMap<>();\n \n-        public InvokeDynamicInsnConverter(ClassVisitor next, int targetVersion) {\n+        public InvokeDynamicInsnConverter(ClassVisitor next) {\n             super(ASM5, next);\n-            this.targetVersion = targetVersion;\n         }\n \n         @Override\n         public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n-            if (version > targetVersion) {\n-                version = targetVersion;\n-            }\n             super.visit(version, access, name, signature, superName, interfaces);\n             this.classAccess = access;\n             this.className = name;\n@@ -156,8 +150,8 @@ public class LambdaUsageBackporter {\n     private static class InvokeDynamicInsnConvertingMethodVisitor extends MethodVisitor {\n         private final InvokeDynamicInsnConverter context;\n \n-        public InvokeDynamicInsnConvertingMethodVisitor(MethodVisitor mv, InvokeDynamicInsnConverter context) {\n-            super(ASM5, mv);\n+        public InvokeDynamicInsnConvertingMethodVisitor(MethodVisitor next, InvokeDynamicInsnConverter context) {\n+            super(ASM5, next);\n             this.context = context;\n         }\n \n"
    },
    {
        "commit_hash": "e7122935077bc8bf99d00fe92d2defd65be4c3ba",
        "previous_commit_hash": "bc599ff321fda7148c2362f2c5746bd52dca3501",
        "diff_stats": {
            "additions": 27,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,27 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda;\n+\n+import org.objectweb.asm.ClassVisitor;\n+\n+import static org.objectweb.asm.Opcodes.ASM5;\n+\n+public class LowerBytecodeVersion extends ClassVisitor {\n+\n+    private final int targetVersion;\n+\n+    public LowerBytecodeVersion(ClassVisitor next, int targetVersion) {\n+        super(ASM5, next);\n+        this.targetVersion = targetVersion;\n+    }\n+\n+    @Override\n+    public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n+        if (version > targetVersion) {\n+            version = targetVersion;\n+        }\n+        super.visit(version, access, name, signature, superName, interfaces);\n+    }\n+}\n"
    },
    {
        "commit_hash": "93e0667b926618104b139d0f0d0a5e049be41893",
        "previous_commit_hash": "e7122935077bc8bf99d00fe92d2defd65be4c3ba",
        "diff_stats": {
            "additions": 51,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,51 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda;\n+\n+import org.objectweb.asm.*;\n+\n+import static org.objectweb.asm.Opcodes.ASM5;\n+\n+public class ApplyMethodRelocations extends ClassVisitor {\n+\n+    public ApplyMethodRelocations(ClassVisitor next) {\n+        super(ASM5, next);\n+    }\n+\n+    @Override\n+    public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n+        super.visit(version, access, name, signature, superName, interfaces);\n+    }\n+\n+    @Override\n+    public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+        return new ApplyRenamesMethodVisitor(super.visitMethod(access, name, desc, signature, exceptions));\n+    }\n+\n+    private static class ApplyRenamesMethodVisitor extends MethodVisitor {\n+\n+        public ApplyRenamesMethodVisitor(MethodVisitor next) {\n+            super(Opcodes.ASM5, next);\n+        }\n+\n+        @Override\n+        public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\n+            // TODO: \"make it right\"\n+            if (owner.equals(\"net/orfjackal/retrolambda/test/InterfaceStaticMethodsTest$Interface\")\n+                    && name.equals(\"staticMethod\")\n+                    && desc.equals(\"()I\")) {\n+                owner += \"$\";\n+                itf = false;\n+            }\n+            if (owner.equals(\"net/orfjackal/retrolambda/test/InterfaceStaticMethodsTest$Interface\")\n+                    && name.equals(\"staticMethodWithArgs\")\n+                    && desc.equals(\"(Ljava/lang/String;IJ)Ljava/lang/String;\")) {\n+                owner += \"$\";\n+                itf = false;\n+            }\n+            super.visitMethodInsn(opcode, owner, name, desc, itf);\n+        }\n+    }\n+}\n"
    },
    {
        "commit_hash": "93e0667b926618104b139d0f0d0a5e049be41893",
        "previous_commit_hash": "e7122935077bc8bf99d00fe92d2defd65be4c3ba",
        "diff_stats": {
            "additions": 3,
            "deletions": 0
        },
        "diff_content": "@@ -18,6 +18,9 @@ public class ClassSaver {\n     }\n \n     public void save(byte[] bytecode) throws IOException {\n+        if (bytecode == null) {\n+            return;\n+        }\n         ClassReader cr = new ClassReader(bytecode);\n         Path outputFile = outputDir.resolve(cr.getClassName() + \".class\");\n         Files.createDirectories(outputFile.getParent());\n"
    },
    {
        "commit_hash": "93e0667b926618104b139d0f0d0a5e049be41893",
        "previous_commit_hash": "e7122935077bc8bf99d00fe92d2defd65be4c3ba",
        "diff_stats": {
            "additions": 28,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,28 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda;\n+\n+import org.objectweb.asm.ClassVisitor;\n+\n+import static org.objectweb.asm.Opcodes.*;\n+\n+public class ExtractInterfaceCompanionClass extends ClassVisitor {\n+\n+    public ExtractInterfaceCompanionClass(ClassVisitor next) {\n+        super(ASM5, next);\n+    }\n+\n+    @Override\n+    public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n+        // TODO: \"make it right\"\n+        if (name.equals(\"net/orfjackal/retrolambda/test/InterfaceStaticMethodsTest$Interface\")) {\n+            name += \"$\";\n+            access &= ~ACC_INTERFACE;\n+            access &= ~ACC_ABSTRACT;\n+        }\n+        // TODO: remove abstract methods\n+        super.visit(version, access, name, signature, superName, interfaces);\n+    }\n+}\n"
    },
    {
        "commit_hash": "93e0667b926618104b139d0f0d0a5e049be41893",
        "previous_commit_hash": "e7122935077bc8bf99d00fe92d2defd65be4c3ba",
        "diff_stats": {
            "additions": 29,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,29 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda;\n+\n+import org.objectweb.asm.*;\n+\n+public class InterfaceCompanionBackporter {\n+\n+    public static byte[] transform(ClassReader reader, int targetVersion) {\n+        if (FeatureToggles.DEFAULT_METHODS == 2\n+                && isInterface(reader)) {\n+            ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n+            ClassVisitor next = writer;\n+            next = new ApplyMethodRelocations(next);\n+            next = new ExtractInterfaceCompanionClass(next);\n+            next = new LowerBytecodeVersion(next, targetVersion);\n+            reader.accept(next, 0);\n+            return writer.toByteArray();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    private static boolean isInterface(ClassReader reader) {\n+        return Flags.hasFlag(reader.getAccess(), Opcodes.ACC_INTERFACE);\n+    }\n+}\n"
    },
    {
        "commit_hash": "93e0667b926618104b139d0f0d0a5e049be41893",
        "previous_commit_hash": "e7122935077bc8bf99d00fe92d2defd65be4c3ba",
        "diff_stats": {
            "additions": 2,
            "deletions": 0
        },
        "diff_content": "@@ -19,6 +19,8 @@ public class LambdaClassBackporter {\n         ClassVisitor next = writer;\n         if (FeatureToggles.DEFAULT_METHODS == 1) {\n             next = new ClassModifier(targetVersion, next);\n+        } else if (FeatureToggles.DEFAULT_METHODS == 2) {\n+            next = new ApplyMethodRelocations(next);\n         }\n         next = new LambdaClassVisitor(next);\n         next = new LowerBytecodeVersion(next, targetVersion);\n"
    },
    {
        "commit_hash": "93e0667b926618104b139d0f0d0a5e049be41893",
        "previous_commit_hash": "e7122935077bc8bf99d00fe92d2defd65be4c3ba",
        "diff_stats": {
            "additions": 5,
            "deletions": 10
        },
        "diff_content": "@@ -4,15 +4,13 @@\n \n package net.orfjackal.retrolambda;\n \n-import java.nio.file.*;\n-\n public class LambdaClassSaver {\n \n-    private final Path outputDir;\n+    private final ClassSaver saver;\n     private final int bytecodeVersion;\n \n-    public LambdaClassSaver(Path outputDir, int bytecodeVersion) {\n-        this.outputDir = outputDir;\n+    public LambdaClassSaver(ClassSaver saver, int bytecodeVersion) {\n+        this.saver = saver;\n         this.bytecodeVersion = bytecodeVersion;\n     }\n \n@@ -22,13 +20,10 @@ public class LambdaClassSaver {\n         }\n     }\n \n-    private void reifyLambdaClass(String className, byte[] originalBytecode) {\n+    private void reifyLambdaClass(String className, byte[] bytecode) {\n         try {\n             System.out.println(\"Saving lambda class: \" + className);\n-            byte[] backportedBytecode = LambdaClassBackporter.transform(originalBytecode, bytecodeVersion);\n-            Path savePath = outputDir.resolve(className + \".class\");\n-            Files.createDirectories(savePath.getParent());\n-            Files.write(savePath, backportedBytecode);\n+            saver.save(LambdaClassBackporter.transform(bytecode, bytecodeVersion));\n \n         } catch (Throwable t) {\n             // print to stdout to keep in sync with other log output\n"
    },
    {
        "commit_hash": "93e0667b926618104b139d0f0d0a5e049be41893",
        "previous_commit_hash": "e7122935077bc8bf99d00fe92d2defd65be4c3ba",
        "diff_stats": {
            "additions": 3,
            "deletions": 2
        },
        "diff_content": "@@ -23,8 +23,9 @@ public class LambdaUsageBackporter {\n             next = new ClassModifier(targetVersion, next);\n             next = new InterfaceModifier(next, targetVersion);\n         } else if (FeatureToggles.DEFAULT_METHODS == 2) {\n-            next = new RemoveDefaultMethods(next);\n-            next = new InvokeStaticInterfaceMethodConverter(next);\n+            next = new RemoveDefaultMethods(next); // TODO: only needed for interfaces - skip else?\n+            next = new InvokeStaticInterfaceMethodConverter(next); // TODO: is this still needed after static methods are moved to companion class?\n+            next = new ApplyMethodRelocations(next);\n         } else {\n             next = new InvokeStaticInterfaceMethodConverter(next);\n         }\n"
    },
    {
        "commit_hash": "93e0667b926618104b139d0f0d0a5e049be41893",
        "previous_commit_hash": "e7122935077bc8bf99d00fe92d2defd65be4c3ba",
        "diff_stats": {
            "additions": 2,
            "deletions": 1
        },
        "diff_content": "@@ -15,7 +15,8 @@ public class PreMain {\n         Config config = new Config(System.getProperties());\n         int bytecodeVersion = config.getBytecodeVersion();\n         Path outputDir = config.getOutputDir();\n-        inst.addTransformer(new LambdaSavingClassFileTransformer(new LambdaClassSaver(outputDir, bytecodeVersion)));\n+        ClassSaver saver = new ClassSaver(outputDir);\n+        inst.addTransformer(new LambdaSavingClassFileTransformer(new LambdaClassSaver(saver, bytecodeVersion)));\n         agentLoaded = true;\n     }\n \n"
    },
    {
        "commit_hash": "93e0667b926618104b139d0f0d0a5e049be41893",
        "previous_commit_hash": "e7122935077bc8bf99d00fe92d2defd65be4c3ba",
        "diff_stats": {
            "additions": 12,
            "deletions": 4
        },
        "diff_content": "@@ -34,7 +34,8 @@ public class Retrolambda {\n \n         Thread.currentThread().setContextClassLoader(new NonDelegatingClassLoader(asUrls(classpath)));\n \n-        try (LambdaClassDumper dumper = new LambdaClassDumper(new LambdaClassSaver(outputDir, bytecodeVersion))) {\n+        ClassSaver saver = new ClassSaver(outputDir);\n+        try (LambdaClassDumper dumper = new LambdaClassDumper(new LambdaClassSaver(saver, bytecodeVersion))) {\n             if (!PreMain.isAgentLoaded()) {\n                 dumper.install();\n             }\n@@ -47,12 +48,19 @@ public class Retrolambda {\n                 }\n             });\n \n-            ClassSaver saver = new ClassSaver(outputDir);\n+            List<byte[]> transformed = new ArrayList<>();\n             for (ClassReader reader : analyzer.getInterfaces()) {\n-                saver.save(LambdaUsageBackporter.transform(reader, bytecodeVersion));\n+                transformed.add(InterfaceCompanionBackporter.transform(reader, bytecodeVersion));\n+                transformed.add(LambdaUsageBackporter.transform(reader, bytecodeVersion));\n             }\n             for (ClassReader reader : analyzer.getClasses()) {\n-                saver.save(LambdaUsageBackporter.transform(reader, bytecodeVersion));\n+                transformed.add(LambdaUsageBackporter.transform(reader, bytecodeVersion));\n+            }\n+\n+            // We need to load some of the classes (for calling the lambda metafactory)\n+            // so we need to take care not to modify any bytecode before loading them.\n+            for (byte[] bytecode : transformed) {\n+                saver.save(bytecode);\n             }\n         }\n     }\n"
    },
    {
        "commit_hash": "eeb888628090a53cb5196224e216f9413b4f8721",
        "previous_commit_hash": "93e0667b926618104b139d0f0d0a5e049be41893",
        "diff_stats": {
            "additions": 0,
            "deletions": 55
        },
        "diff_content": "@@ -36,61 +36,6 @@\n     <option name=\"LAST_EDITED_MODULE_NAME\" />\n     <option name=\"LAST_EDITED_TAB_NAME\" />\n   </component>\n-  <component name=\"ProjectInspectionProfilesVisibleTreeState\">\n-    <entry key=\"Project Default\">\n-      <profile-state>\n-        <expanded-state>\n-          <State>\n-            <id />\n-          </State>\n-          <State>\n-            <id>Code style issuesJavaScript</id>\n-          </State>\n-          <State>\n-            <id>Data flow issues</id>\n-          </State>\n-          <State>\n-            <id>J2ME issues</id>\n-          </State>\n-          <State>\n-            <id>JBoss Seam issues</id>\n-          </State>\n-          <State>\n-            <id>JRuby</id>\n-          </State>\n-          <State>\n-            <id>JUnit issues</id>\n-          </State>\n-          <State>\n-            <id>Java EE issues</id>\n-          </State>\n-          <State>\n-            <id>JavaScript</id>\n-          </State>\n-          <State>\n-            <id>Naming conventions</id>\n-          </State>\n-          <State>\n-            <id>Probable bugs</id>\n-          </State>\n-          <State>\n-            <id>Scala: General</id>\n-          </State>\n-          <State>\n-            <id>Threading issues</id>\n-          </State>\n-          <State>\n-            <id>XPath</id>\n-          </State>\n-        </expanded-state>\n-        <selected-state>\n-          <State>\n-            <id>Abstraction issues</id>\n-          </State>\n-        </selected-state>\n-      </profile-state>\n-    </entry>\n-  </component>\n   <component name=\"ProjectRootManager\" version=\"2\" languageLevel=\"JDK_1_8\" assert-keyword=\"true\" jdk-15=\"true\" project-jdk-name=\"1.8\" project-jdk-type=\"JavaSDK\">\n     <output url=\"file://$PROJECT_DIR$/classes\" />\n   </component>\n"
    },
    {
        "commit_hash": "c8d6a300e51715f4a9d7073b5d7e7e1eb25803d0",
        "previous_commit_hash": "eeb888628090a53cb5196224e216f9413b4f8721",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -10,6 +10,7 @@\n       <w>metafactory</w>\n       <w>premain</w>\n       <w>reifier</w>\n+      <w>relocations</w>\n       <w>retrolambda</w>\n     </words>\n   </dictionary>\n"
    },
    {
        "commit_hash": "c8d6a300e51715f4a9d7073b5d7e7e1eb25803d0",
        "previous_commit_hash": "eeb888628090a53cb5196224e216f9413b4f8721",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -19,6 +19,7 @@\n     <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n     <orderEntry type=\"module\" module-name=\"retrolambda\" />\n     <orderEntry type=\"library\" name=\"Maven: org.ow2.asm:asm-debug-all:5.0.2\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: com.google.guava:guava:17.0\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-plugin-api:2.0\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"PROVIDED\" name=\"Maven: org.apache.maven.plugin-tools:maven-plugin-annotations:3.2\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-artifact:3.0\" level=\"project\" />\n@@ -43,7 +44,6 @@\n     <orderEntry type=\"library\" name=\"Maven: org.codehaus.plexus:plexus-classworlds:2.2.3\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.sonatype.sisu:sisu-inject-bean:1.4.2\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.sonatype.sisu:sisu-guice:noaop:2.1.7\" level=\"project\" />\n-    <orderEntry type=\"library\" name=\"Maven: com.google.guava:guava:17.0\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.11\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-library:1.3\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-core:1.3\" level=\"project\" />\n"
    },
    {
        "commit_hash": "c8d6a300e51715f4a9d7073b5d7e7e1eb25803d0",
        "previous_commit_hash": "eeb888628090a53cb5196224e216f9413b4f8721",
        "diff_stats": {
            "additions": 11,
            "deletions": 1
        },
        "diff_content": "@@ -23,7 +23,6 @@\n         <dependency>\n             <groupId>com.google.guava</groupId>\n             <artifactId>guava</artifactId>\n-            <scope>test</scope>\n         </dependency>\n \n     </dependencies>\n@@ -96,6 +95,10 @@\n                             <pattern>org.objectweb.asm</pattern>\n                             <shadedPattern>net.orfjackal.retrolambda.asm</shadedPattern>\n                         </relocation>\n+                        <relocation>\n+                            <pattern>com.google</pattern>\n+                            <shadedPattern>net.orfjackal.retrolambda.google</shadedPattern>\n+                        </relocation>\n                     </relocations>\n                     <filters>\n                         <filter>\n@@ -103,6 +106,13 @@\n                             <excludes>\n                                 <exclude>**/*.html</exclude>\n                                 <exclude>**/*.dtd</exclude>\n+                                <exclude>META-INF/**</exclude>\n+                            </excludes>\n+                        </filter>\n+                        <filter>\n+                            <artifact>com.google.guava:guava</artifact>\n+                            <excludes>\n+                                <exclude>META-INF/**</exclude>\n                             </excludes>\n                         </filter>\n                     </filters>\n"
    },
    {
        "commit_hash": "c8d6a300e51715f4a9d7073b5d7e7e1eb25803d0",
        "previous_commit_hash": "eeb888628090a53cb5196224e216f9413b4f8721",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n     <orderEntry type=\"inheritedJdk\" />\n     <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n     <orderEntry type=\"library\" name=\"Maven: org.ow2.asm:asm-debug-all:5.0.2\" level=\"project\" />\n-    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: com.google.guava:guava:17.0\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: com.google.guava:guava:17.0\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.11\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-library:1.3\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-core:1.3\" level=\"project\" />\n"
    },
    {
        "commit_hash": "c8d6a300e51715f4a9d7073b5d7e7e1eb25803d0",
        "previous_commit_hash": "eeb888628090a53cb5196224e216f9413b4f8721",
        "diff_stats": {
            "additions": 9,
            "deletions": 16
        },
        "diff_content": "@@ -4,14 +4,19 @@\n \n package net.orfjackal.retrolambda;\n \n+import com.google.common.base.Preconditions;\n import org.objectweb.asm.*;\n \n import static org.objectweb.asm.Opcodes.ASM5;\n \n public class ApplyMethodRelocations extends ClassVisitor {\n \n-    public ApplyMethodRelocations(ClassVisitor next) {\n+    private final MethodRelocations methodRelocations;\n+\n+    public ApplyMethodRelocations(ClassVisitor next, MethodRelocations methodRelocations) {\n         super(ASM5, next);\n+        this.methodRelocations = methodRelocations;\n+        Preconditions.checkNotNull(methodRelocations);\n     }\n \n     @Override\n@@ -24,7 +29,7 @@ public class ApplyMethodRelocations extends ClassVisitor {\n         return new ApplyRenamesMethodVisitor(super.visitMethod(access, name, desc, signature, exceptions));\n     }\n \n-    private static class ApplyRenamesMethodVisitor extends MethodVisitor {\n+    private class ApplyRenamesMethodVisitor extends MethodVisitor {\n \n         public ApplyRenamesMethodVisitor(MethodVisitor next) {\n             super(Opcodes.ASM5, next);\n@@ -32,20 +37,8 @@ public class ApplyMethodRelocations extends ClassVisitor {\n \n         @Override\n         public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\n-            // TODO: \"make it right\"\n-            if (owner.equals(\"net/orfjackal/retrolambda/test/InterfaceStaticMethodsTest$Interface\")\n-                    && name.equals(\"staticMethod\")\n-                    && desc.equals(\"()I\")) {\n-                owner += \"$\";\n-                itf = false;\n-            }\n-            if (owner.equals(\"net/orfjackal/retrolambda/test/InterfaceStaticMethodsTest$Interface\")\n-                    && name.equals(\"staticMethodWithArgs\")\n-                    && desc.equals(\"(Ljava/lang/String;IJ)Ljava/lang/String;\")) {\n-                owner += \"$\";\n-                itf = false;\n-            }\n-            super.visitMethodInsn(opcode, owner, name, desc, itf);\n+            MethodRef ref = methodRelocations.getMethodLocation(new MethodRef(owner, name, desc));\n+            super.visitMethodInsn(opcode, ref.owner, ref.name, ref.desc, itf);\n         }\n     }\n }\n"
    },
    {
        "commit_hash": "c8d6a300e51715f4a9d7073b5d7e7e1eb25803d0",
        "previous_commit_hash": "eeb888628090a53cb5196224e216f9413b4f8721",
        "diff_stats": {
            "additions": 35,
            "deletions": 2
        },
        "diff_content": "@@ -10,13 +10,14 @@ import java.util.*;\n import java.util.stream.Stream;\n \n import static java.util.stream.Collectors.toList;\n-import static org.objectweb.asm.Opcodes.ACC_INTERFACE;\n+import static org.objectweb.asm.Opcodes.*;\n \n-public class ClassHierarchyAnalyzer {\n+public class ClassHierarchyAnalyzer implements MethodRelocations {\n \n     private final List<ClassReader> interfaces = new ArrayList<>();\n     private final List<ClassReader> classes = new ArrayList<>();\n     private final Map<Type, List<Type>> interfacesByImplementer = new HashMap<>();\n+    private final Map<MethodRef, MethodRef> relocatedMethods = new HashMap<>();\n \n     public void analyze(byte[] bytecode) {\n         ClassReader cr = new ClassReader(bytecode);\n@@ -30,6 +31,33 @@ public class ClassHierarchyAnalyzer {\n \n         List<Type> interfaces = classNamesToTypes(cr.getInterfaces());\n         interfacesByImplementer.put(clazz, interfaces);\n+\n+        if (Flags.hasFlag(cr.getAccess(), ACC_INTERFACE)) {\n+            discoverRelocatedMethods(cr);\n+        }\n+    }\n+\n+    private void discoverRelocatedMethods(ClassReader cr) {\n+        cr.accept(new ClassVisitor(ASM5) {\n+            private String owner;\n+            private String companion;\n+\n+            @Override\n+            public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n+                this.owner = name;\n+                this.companion = name + \"$\";\n+            }\n+\n+            @Override\n+            public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+                if (Flags.hasFlag(access, ACC_STATIC)) {\n+                    relocatedMethods.put(\n+                            new MethodRef(owner, name, desc),\n+                            new MethodRef(companion, name, desc));\n+                }\n+                return null;\n+            }\n+        }, ClassReader.SKIP_CODE);\n     }\n \n     public List<ClassReader> getInterfaces() {\n@@ -44,6 +72,11 @@ public class ClassHierarchyAnalyzer {\n         return interfacesByImplementer.get(type);\n     }\n \n+    @Override\n+    public MethodRef getMethodLocation(MethodRef original) {\n+        return relocatedMethods.getOrDefault(original, original);\n+    }\n+\n     private static List<Type> classNamesToTypes(String[] interfaces) {\n         return Stream.of(interfaces)\n                 .map(ClassHierarchyAnalyzer::classNameToType)\n"
    },
    {
        "commit_hash": "c8d6a300e51715f4a9d7073b5d7e7e1eb25803d0",
        "previous_commit_hash": "eeb888628090a53cb5196224e216f9413b4f8721",
        "diff_stats": {
            "additions": 3,
            "deletions": 2
        },
        "diff_content": "@@ -8,13 +8,14 @@ import org.objectweb.asm.*;\n \n public class InterfaceCompanionBackporter {\n \n-    public static byte[] transform(ClassReader reader, int targetVersion) {\n+    public static byte[] transform(ClassReader reader, int targetVersion, MethodRelocations methodRelocations) {\n         if (FeatureToggles.DEFAULT_METHODS == 2\n                 && isInterface(reader)) {\n             ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n             ClassVisitor next = writer;\n-            next = new ApplyMethodRelocations(next);\n+            next = new ApplyMethodRelocations(next, methodRelocations);\n             next = new ExtractInterfaceCompanionClass(next);\n+            next = new InvokeStaticInterfaceMethodConverter(next);\n             next = new LowerBytecodeVersion(next, targetVersion);\n             reader.accept(next, 0);\n             return writer.toByteArray();\n"
    },
    {
        "commit_hash": "c8d6a300e51715f4a9d7073b5d7e7e1eb25803d0",
        "previous_commit_hash": "eeb888628090a53cb5196224e216f9413b4f8721",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -14,13 +14,13 @@ public class LambdaClassBackporter {\n     private static final String SINGLETON_FIELD_NAME = \"instance\";\n     private static final String JAVA_LANG_OBJECT = \"java/lang/Object\";\n \n-    public static byte[] transform(byte[] bytecode, int targetVersion) {\n+    public static byte[] transform(byte[] bytecode, int targetVersion, MethodRelocations methodRelocations) {\n         ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n         ClassVisitor next = writer;\n         if (FeatureToggles.DEFAULT_METHODS == 1) {\n             next = new ClassModifier(targetVersion, next);\n         } else if (FeatureToggles.DEFAULT_METHODS == 2) {\n-            next = new ApplyMethodRelocations(next);\n+            next = new ApplyMethodRelocations(next, methodRelocations);\n         }\n         next = new LambdaClassVisitor(next);\n         next = new LowerBytecodeVersion(next, targetVersion);\n"
    },
    {
        "commit_hash": "c8d6a300e51715f4a9d7073b5d7e7e1eb25803d0",
        "previous_commit_hash": "eeb888628090a53cb5196224e216f9413b4f8721",
        "diff_stats": {
            "additions": 8,
            "deletions": 2
        },
        "diff_content": "@@ -8,10 +8,16 @@ public class LambdaClassSaver {\n \n     private final ClassSaver saver;\n     private final int bytecodeVersion;\n+    private MethodRelocations methodRelocations;\n \n-    public LambdaClassSaver(ClassSaver saver, int bytecodeVersion) {\n+    public LambdaClassSaver(ClassSaver saver, int bytecodeVersion, MethodRelocations methodRelocations) {\n         this.saver = saver;\n         this.bytecodeVersion = bytecodeVersion;\n+        this.methodRelocations = methodRelocations;\n+    }\n+\n+    public void setMethodRelocations(MethodRelocations methodRelocations) {\n+        this.methodRelocations = methodRelocations;\n     }\n \n     public void saveIfLambda(String className, byte[] bytecode) {\n@@ -23,7 +29,7 @@ public class LambdaClassSaver {\n     private void reifyLambdaClass(String className, byte[] bytecode) {\n         try {\n             System.out.println(\"Saving lambda class: \" + className);\n-            saver.save(LambdaClassBackporter.transform(bytecode, bytecodeVersion));\n+            saver.save(LambdaClassBackporter.transform(bytecode, bytecodeVersion, methodRelocations));\n \n         } catch (Throwable t) {\n             // print to stdout to keep in sync with other log output\n"
    },
    {
        "commit_hash": "c8d6a300e51715f4a9d7073b5d7e7e1eb25803d0",
        "previous_commit_hash": "eeb888628090a53cb5196224e216f9413b4f8721",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -15,7 +15,7 @@ import static org.objectweb.asm.Opcodes.*;\n \n public class LambdaUsageBackporter {\n \n-    public static byte[] transform(ClassReader reader, int targetVersion) {\n+    public static byte[] transform(ClassReader reader, int targetVersion, MethodRelocations methodRelocations) {\n         resetLambdaClassSequenceNumber();\n         ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n         ClassVisitor next = writer;\n@@ -24,8 +24,8 @@ public class LambdaUsageBackporter {\n             next = new InterfaceModifier(next, targetVersion);\n         } else if (FeatureToggles.DEFAULT_METHODS == 2) {\n             next = new RemoveDefaultMethods(next); // TODO: only needed for interfaces - skip else?\n-            next = new InvokeStaticInterfaceMethodConverter(next); // TODO: is this still needed after static methods are moved to companion class?\n-            next = new ApplyMethodRelocations(next);\n+            next = new ApplyMethodRelocations(next, methodRelocations);\n+            next = new InvokeStaticInterfaceMethodConverter(next);\n         } else {\n             next = new InvokeStaticInterfaceMethodConverter(next);\n         }\n"
    },
    {
        "commit_hash": "c8d6a300e51715f4a9d7073b5d7e7e1eb25803d0",
        "previous_commit_hash": "eeb888628090a53cb5196224e216f9413b4f8721",
        "diff_stats": {
            "additions": 50,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,50 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda;\n+\n+import com.google.common.base.Objects;\n+import org.objectweb.asm.Type;\n+\n+public final class MethodRef {\n+\n+    public final String owner;\n+    public final String name;\n+    public final String desc;\n+\n+    public MethodRef(Class<?> owner, String name, String desc) {\n+        this(Type.getInternalName(owner), name, desc);\n+    }\n+\n+    public MethodRef(String owner, String name, String desc) {\n+        this.owner = owner;\n+        this.name = name;\n+        this.desc = desc;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (!(obj instanceof MethodRef)) {\n+            return false;\n+        }\n+        MethodRef that = (MethodRef) obj;\n+        return this.owner.equals(that.owner)\n+                && this.name.equals(that.name)\n+                && this.desc.equals(that.desc);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hashCode(owner, name, desc);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return Objects.toStringHelper(this)\n+                .addValue(owner)\n+                .addValue(name)\n+                .addValue(desc)\n+                .toString();\n+    }\n+}\n"
    },
    {
        "commit_hash": "c8d6a300e51715f4a9d7073b5d7e7e1eb25803d0",
        "previous_commit_hash": "eeb888628090a53cb5196224e216f9413b4f8721",
        "diff_stats": {
            "additions": 10,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,10 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda;\n+\n+public interface MethodRelocations {\n+\n+    MethodRef getMethodLocation(MethodRef original);\n+}\n"
    },
    {
        "commit_hash": "c8d6a300e51715f4a9d7073b5d7e7e1eb25803d0",
        "previous_commit_hash": "eeb888628090a53cb5196224e216f9413b4f8721",
        "diff_stats": {
            "additions": 7,
            "deletions": 1
        },
        "diff_content": "@@ -10,17 +10,23 @@ import java.nio.file.Path;\n public class PreMain {\n \n     private static boolean agentLoaded = false;\n+    private static LambdaClassSaver lambdaClassSaver;\n \n     public static void premain(String agentArgs, Instrumentation inst) {\n         Config config = new Config(System.getProperties());\n         int bytecodeVersion = config.getBytecodeVersion();\n         Path outputDir = config.getOutputDir();\n         ClassSaver saver = new ClassSaver(outputDir);\n-        inst.addTransformer(new LambdaSavingClassFileTransformer(new LambdaClassSaver(saver, bytecodeVersion)));\n+        lambdaClassSaver = new LambdaClassSaver(saver, bytecodeVersion, null); // MethodRelocations will be set by main\n+        inst.addTransformer(new LambdaSavingClassFileTransformer(lambdaClassSaver));\n         agentLoaded = true;\n     }\n \n     public static boolean isAgentLoaded() {\n         return agentLoaded;\n     }\n+\n+    public static void setMethodRelocations(MethodRelocations methodRelocations) {\n+        lambdaClassSaver.setMethodRelocations(methodRelocations);\n+    }\n }\n"
    },
    {
        "commit_hash": "c8d6a300e51715f4a9d7073b5d7e7e1eb25803d0",
        "previous_commit_hash": "eeb888628090a53cb5196224e216f9413b4f8721",
        "diff_stats": {
            "additions": 8,
            "deletions": 6
        },
        "diff_content": "@@ -34,13 +34,15 @@ public class Retrolambda {\n \n         Thread.currentThread().setContextClassLoader(new NonDelegatingClassLoader(asUrls(classpath)));\n \n+        ClassHierarchyAnalyzer analyzer = new ClassHierarchyAnalyzer();\n         ClassSaver saver = new ClassSaver(outputDir);\n-        try (LambdaClassDumper dumper = new LambdaClassDumper(new LambdaClassSaver(saver, bytecodeVersion))) {\n-            if (!PreMain.isAgentLoaded()) {\n+        try (LambdaClassDumper dumper = new LambdaClassDumper(new LambdaClassSaver(saver, bytecodeVersion, analyzer))) {\n+            if (PreMain.isAgentLoaded()) {\n+                PreMain.setMethodRelocations(analyzer);\n+            } else {\n                 dumper.install();\n             }\n \n-            ClassHierarchyAnalyzer analyzer = new ClassHierarchyAnalyzer();\n             visitFiles(inputDir, includedFiles, new BytecodeFileVisitor() {\n                 @Override\n                 protected void visit(byte[] bytecode) {\n@@ -50,11 +52,11 @@ public class Retrolambda {\n \n             List<byte[]> transformed = new ArrayList<>();\n             for (ClassReader reader : analyzer.getInterfaces()) {\n-                transformed.add(InterfaceCompanionBackporter.transform(reader, bytecodeVersion));\n-                transformed.add(LambdaUsageBackporter.transform(reader, bytecodeVersion));\n+                transformed.add(InterfaceCompanionBackporter.transform(reader, bytecodeVersion, analyzer));\n+                transformed.add(LambdaUsageBackporter.transform(reader, bytecodeVersion, analyzer));\n             }\n             for (ClassReader reader : analyzer.getClasses()) {\n-                transformed.add(LambdaUsageBackporter.transform(reader, bytecodeVersion));\n+                transformed.add(LambdaUsageBackporter.transform(reader, bytecodeVersion, analyzer));\n             }\n \n             // We need to load some of the classes (for calling the lambda metafactory)\n"
    },
    {
        "commit_hash": "c8d6a300e51715f4a9d7073b5d7e7e1eb25803d0",
        "previous_commit_hash": "eeb888628090a53cb5196224e216f9413b4f8721",
        "diff_stats": {
            "additions": 55,
            "deletions": 0
        },
        "diff_content": "@@ -16,6 +16,7 @@ import static java.util.stream.Collectors.toList;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.*;\n \n+@SuppressWarnings(\"UnusedDeclaration\")\n public class ClassHierarchyAnalyzerTest {\n \n     private final ClassHierarchyAnalyzer analyzer = new ClassHierarchyAnalyzer();\n@@ -50,6 +51,60 @@ public class ClassHierarchyAnalyzerTest {\n     }\n \n \n+    @Test\n+    public void abstract_methods_on_interfaces_are_not_relocated() {\n+        analyze(InterfaceMethodTypes.class);\n+\n+        MethodRef source = new MethodRef(InterfaceMethodTypes.class, \"abstractMethod\", \"()V\");\n+        MethodRef target = analyzer.getMethodLocation(source);\n+\n+        assertThat(target, is(source));\n+    }\n+\n+    @Test\n+    public void static_methods_on_interfaces_are_relocated_to_companion_classes() {\n+        analyze(InterfaceMethodTypes.class);\n+\n+        MethodRef source = new MethodRef(InterfaceMethodTypes.class, \"staticMethod\", \"()V\");\n+        MethodRef target = analyzer.getMethodLocation(source);\n+\n+        assertThat(target, is(new MethodRef(InterfaceMethodTypes$.class, \"staticMethod\", \"()V\")));\n+    }\n+\n+    @Test\n+    public void static_methods_on_classes_are_not_relocated() {\n+        analyze(ClassMethodTypes.class);\n+\n+        MethodRef source = new MethodRef(ClassMethodTypes.class, \"staticMethod\", \"()V\");\n+        MethodRef target = analyzer.getMethodLocation(source);\n+\n+        assertThat(target, is(source));\n+    }\n+\n+    private interface InterfaceMethodTypes {\n+        void abstractMethod();\n+\n+        default void defaultMethod() {\n+        }\n+\n+        static void staticMethod() {\n+        }\n+    }\n+\n+    private interface InterfaceMethodTypes$ {\n+    }\n+\n+    private static abstract class ClassMethodTypes {\n+        public abstract void abstractMethod();\n+\n+        public void instanceMethod() {\n+        }\n+\n+        public static void staticMethod() {\n+        }\n+    }\n+\n+\n     // API wrappers\n \n     private void analyze(Class<?> clazz) {\n"
    },
    {
        "commit_hash": "81c37127510c96c779a532b83b9590b6f87bd4dc",
        "previous_commit_hash": "c8d6a300e51715f4a9d7073b5d7e7e1eb25803d0",
        "diff_stats": {
            "additions": 7,
            "deletions": 0
        },
        "diff_content": "@@ -18,6 +18,7 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n     private final List<ClassReader> classes = new ArrayList<>();\n     private final Map<Type, List<Type>> interfacesByImplementer = new HashMap<>();\n     private final Map<MethodRef, MethodRef> relocatedMethods = new HashMap<>();\n+    private final Map<String, String> companionClasses = new HashMap<>();\n \n     public void analyze(byte[] bytecode) {\n         ClassReader cr = new ClassReader(bytecode);\n@@ -54,6 +55,7 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n                     relocatedMethods.put(\n                             new MethodRef(owner, name, desc),\n                             new MethodRef(companion, name, desc));\n+                    companionClasses.put(owner, companion);\n                 }\n                 return null;\n             }\n@@ -77,6 +79,11 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n         return relocatedMethods.getOrDefault(original, original);\n     }\n \n+    @Override\n+    public String getCompanionClass(String className) {\n+        return companionClasses.get(className);\n+    }\n+\n     private static List<Type> classNamesToTypes(String[] interfaces) {\n         return Stream.of(interfaces)\n                 .map(ClassHierarchyAnalyzer::classNameToType)\n"
    },
    {
        "commit_hash": "81c37127510c96c779a532b83b9590b6f87bd4dc",
        "previous_commit_hash": "c8d6a300e51715f4a9d7073b5d7e7e1eb25803d0",
        "diff_stats": {
            "additions": 9,
            "deletions": 8
        },
        "diff_content": "@@ -10,19 +10,20 @@ import static org.objectweb.asm.Opcodes.*;\n \n public class ExtractInterfaceCompanionClass extends ClassVisitor {\n \n-    public ExtractInterfaceCompanionClass(ClassVisitor next) {\n+    private final String companion;\n+\n+    public ExtractInterfaceCompanionClass(ClassVisitor next, String companion) {\n         super(ASM5, next);\n+        this.companion = companion;\n     }\n \n     @Override\n     public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n-        // TODO: \"make it right\"\n-        if (name.equals(\"net/orfjackal/retrolambda/test/InterfaceStaticMethodsTest$Interface\")) {\n-            name += \"$\";\n-            access &= ~ACC_INTERFACE;\n-            access &= ~ACC_ABSTRACT;\n-        }\n-        // TODO: remove abstract methods\n+        name = companion;\n+        access &= ~ACC_INTERFACE;\n+        access &= ~ACC_ABSTRACT;\n         super.visit(version, access, name, signature, superName, interfaces);\n     }\n+\n+    // TODO: remove abstract methods\n }\n"
    },
    {
        "commit_hash": "81c37127510c96c779a532b83b9590b6f87bd4dc",
        "previous_commit_hash": "c8d6a300e51715f4a9d7073b5d7e7e1eb25803d0",
        "diff_stats": {
            "additions": 4,
            "deletions": 2
        },
        "diff_content": "@@ -9,12 +9,14 @@ import org.objectweb.asm.*;\n public class InterfaceCompanionBackporter {\n \n     public static byte[] transform(ClassReader reader, int targetVersion, MethodRelocations methodRelocations) {\n+        String companion;\n         if (FeatureToggles.DEFAULT_METHODS == 2\n-                && isInterface(reader)) {\n+                && isInterface(reader)\n+                && (companion = methodRelocations.getCompanionClass(reader.getClassName())) != null) {\n             ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n             ClassVisitor next = writer;\n             next = new ApplyMethodRelocations(next, methodRelocations);\n-            next = new ExtractInterfaceCompanionClass(next);\n+            next = new ExtractInterfaceCompanionClass(next, companion);\n             next = new InvokeStaticInterfaceMethodConverter(next);\n             next = new LowerBytecodeVersion(next, targetVersion);\n             reader.accept(next, 0);\n"
    },
    {
        "commit_hash": "81c37127510c96c779a532b83b9590b6f87bd4dc",
        "previous_commit_hash": "c8d6a300e51715f4a9d7073b5d7e7e1eb25803d0",
        "diff_stats": {
            "additions": 2,
            "deletions": 0
        },
        "diff_content": "@@ -7,4 +7,6 @@ package net.orfjackal.retrolambda;\n public interface MethodRelocations {\n \n     MethodRef getMethodLocation(MethodRef original);\n+\n+    String getCompanionClass(String className);\n }\n"
    },
    {
        "commit_hash": "81c37127510c96c779a532b83b9590b6f87bd4dc",
        "previous_commit_hash": "c8d6a300e51715f4a9d7073b5d7e7e1eb25803d0",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -53,10 +53,10 @@ public class Retrolambda {\n             List<byte[]> transformed = new ArrayList<>();\n             for (ClassReader reader : analyzer.getInterfaces()) {\n                 transformed.add(InterfaceCompanionBackporter.transform(reader, bytecodeVersion, analyzer));\n-                transformed.add(LambdaUsageBackporter.transform(reader, bytecodeVersion, analyzer));\n+                transformed.add(LambdaUsageBackporter.transform(reader, bytecodeVersion, analyzer)); // TODO: extract InterfaceBackporter\n             }\n             for (ClassReader reader : analyzer.getClasses()) {\n-                transformed.add(LambdaUsageBackporter.transform(reader, bytecodeVersion, analyzer));\n+                transformed.add(LambdaUsageBackporter.transform(reader, bytecodeVersion, analyzer)); // TODO: extract ClassBackporter\n             }\n \n             // We need to load some of the classes (for calling the lambda metafactory)\n"
    },
    {
        "commit_hash": "81c37127510c96c779a532b83b9590b6f87bd4dc",
        "previous_commit_hash": "c8d6a300e51715f4a9d7073b5d7e7e1eb25803d0",
        "diff_stats": {
            "additions": 12,
            "deletions": 0
        },
        "diff_content": "@@ -105,6 +105,18 @@ public class ClassHierarchyAnalyzerTest {\n     }\n \n \n+    @Test\n+    public void companion_class_is_needed_when_methods_are_moved_there() {\n+        analyze(Interface.class);\n+        analyze(InterfaceMethodTypes.class);\n+        analyze(ClassMethodTypes.class);\n+\n+        assertThat(\"Interface\", analyzer.getCompanionClass(Type.getInternalName(Interface.class)), is(nullValue()));\n+        assertThat(\"InterfaceMethodTypes\", analyzer.getCompanionClass(Type.getInternalName(InterfaceMethodTypes.class)), is(Type.getInternalName(InterfaceMethodTypes$.class)));\n+        assertThat(\"ClassMethodTypes\", analyzer.getCompanionClass(Type.getInternalName(ClassMethodTypes.class)), is(nullValue()));\n+    }\n+\n+\n     // API wrappers\n \n     private void analyze(Class<?> clazz) {\n"
    },
    {
        "commit_hash": "979fb8bb7c7b4189d725c42898f460cabc068a69",
        "previous_commit_hash": "81c37127510c96c779a532b83b9590b6f87bd4dc",
        "diff_stats": {
            "additions": 5,
            "deletions": 0
        },
        "diff_content": "@@ -149,6 +149,11 @@ package-private.\n Version History\n ---------------\n \n+### Upcoming\n+\n+- Backports static methods on interfaces\n+  ([Issue #31](https://github.com/orfjackal/retrolambda/issues/31))\n+\n ### Retrolambda 1.6.1 (2014-08-25)\n \n - Fixed a crash when trying backport classes which are nominally the same\n"
    },
    {
        "commit_hash": "831594a2bde4af9426c0fddfb25f93dc370a142f",
        "previous_commit_hash": "23cfe1b9dca6a28a2e31bf66726d237f8f5eae20",
        "diff_stats": {
            "additions": 121,
            "deletions": 157
        },
        "diff_content": "@@ -12,167 +12,131 @@ import org.objectweb.asm.Type;\n import java.lang.reflect.Method;\n import java.lang.reflect.Modifier;\n import java.util.*;\n-import java.util.stream.Stream;\n+import java.util.stream.*;\n \n /**\n  * Created by arneball on 2014-08-12.\n  */\n public class ClassModifier extends ClassVisitor implements Opcodes {\n-\tprivate final int bytecodeVersion;\n-\tprivate String[] interfaces;\n-\n-\tprivate Set<VisitedMethod> visitedMethods = new HashSet<>();\n-\tprivate Set<MethodContainer> defaultMethods = new HashSet<>();\n-\n-\tpublic ClassModifier(int bytecodeVersion, ClassVisitor cv) {\n-\t\tsuper(ASM5, cv);\n-\t\tthis.bytecodeVersion = bytecodeVersion;\n-\t}\n-\n-\t@Override\n-\tpublic void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n-\t\tboolean isClass = (access & ACC_INTERFACE) == 0;\n-\t\tif(isClass) {\n-\t\t\tdefaultMethods = getMethodsToImplement(interfaces, signature);\n-\t\t}\n-\t\tthis.interfaces = interfaces;\n-\t\tSystem.out.println(\"Class is \" + name + \", non abstract \" + isClass + \", Interfaces are \" + Arrays.toString(interfaces) + \"\" +\n-\t\t\t\t\", default methods are \" + defaultMethods);\n-\t\tsuper.visit(bytecodeVersion, access, name, signature, superName, interfaces);\n-\t}\n-\n-\tprivate static Set<MethodContainer> getMethodsToImplement(String[] interfaces, String sig) {\n-\t\tSet<MethodContainer> tmp = new HashSet<>();\n-\t\tfor(String iff : interfaces) {\n-\t\t\ttmp.addAll(getMethodsToImplement(iff, sig));\n-\t\t}\n-\t\treturn tmp;\n-\t}\n-\n-\tprivate static Set<MethodContainer> getMethodsToImplement(String interfac, String sig) {\n-\t\tClass<?> ifClass = Helpers.loadClass(interfac);\n-\t\tMethod[] tmp = ifClass.getMethods();\n-\t\tSystem.out.println(\"Interface: \" + interfac + \", methods: \" + Arrays.toString(tmp));\n-\t\tSet<MethodContainer> toReturn = new HashSet<>();\n-\t\tfor(Method m : tmp) {\n-\t\t\tif(!Modifier.isAbstract(m.getModifiers())) {\n-\t\t\t\tSystem.out.println(\"NEED TO CREATE PROXY TO \" + interfac + sig + \"\\n\" + m.getDeclaringClass());\n-\t\t\t\tMethodContainer e = new MethodContainer(m.getName(), Type.getMethodDescriptor(m), m.getDeclaringClass().getName().replace(\".\", \"/\"), sig, getExceptions(m));\n-\t\t\t\ttoReturn.add(e);\n-\t\t\t}\n-\t\t}\n-\t\treturn toReturn;\n-\t}\n-\n-\tprivate static String[] getExceptions(Method m) {\n-\t\tClass<?>[] exceptionTypes = m.getExceptionTypes();\n-\t\tString[] tmp = new String[exceptionTypes.length];\n-\t\tfor(int i = 0; i < exceptionTypes.length; i++) {\n-\t\t\ttmp[i] = exceptionTypes[i].getName().replace(\".\", \"/\");\n-\t\t}\n-\t\treturn tmp;\n-\t}\n-\n-\t@Override\n-\tpublic MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n-\t\tvisitedMethods.add(new VisitedMethod(name, desc));\n-\t\treturn new InterfaceToHelperRewriter(super.visitMethod(access, name, desc, signature, exceptions));\n-\t}\n-\n-\t@Override\n-\tpublic void visitEnd() {\n-\t\tfor(MethodContainer m : defaultMethods) {\n-\t\t\tif(visitedMethods.contains(new VisitedMethod(m.methodName, m.methodDesc))) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\t\t\tSystem.out.println(\"VISITEND, CREATING PROXY \" + m);\n-\t\t\tMethodVisitor tmp = super.visitMethod(ACC_PUBLIC, m.methodName, m.methodDesc, m.signature, m.exceptions);\n-\t\t\ttmp.visitVarInsn(ALOAD, 0);\n-\t\t\tint i = 1;\n-\t\t\tfor(Type arg : Type.getArgumentTypes(m.methodDesc)) {\n-\t\t\t\ttmp.visitVarInsn(getVarIns(arg), i++);\n-\t\t\t}\n-\t\t\tString rightInterace = findRightInterace(m, interfaces);\n-\t\t\tSystem.out.println(\"It thinks that the right interface is \" + rightInterace);\n-\t\t\tString mDesc = Helpers.addParam(m.methodDesc, rightInterace);\n-\t\t\ttmp.visitMethodInsn(INVOKESTATIC, rightInterace + \"$helper\", m.methodName, mDesc, false);\n-\t\t\ttmp.visitInsn(getReturnIns(Type.getReturnType(m.methodDesc)));\n-\t\t\ttmp.visitMaxs(0, 0);\n-\t\t\ttmp.visitEnd();\n-\t\t}\n-\t\tsuper.visitEnd();\n-\t}\n-\n-\tpublic static final Comparator<Method> COMPARATOR = (o1, o2) -> {\n-\t\tboolean o1iso2 = o1.getDeclaringClass().isAssignableFrom(o2.getDeclaringClass());\n-\t\tboolean o2iso1 = o2.getDeclaringClass().isAssignableFrom(o1.getDeclaringClass());\n-\t\tif(o1iso2 && o2iso1) {\n-\t\t\treturn 0;\n-\t\t} else if(o2iso1)\n-\t\t\treturn -1;\n-\t\telse return 1;\n-\t};\n-\n-\tpublic static String findRightInterace(MethodContainer methodContainer, String[] interfaces) {\n-\t\tSystem.out.println(\"Find right interfaces for \" + methodContainer + \" \" + Arrays.toString(interfaces));\n-\t\treturn Stream.of(interfaces)\n-\t\t\t\t.map(Helpers::loadClass)\n-\t\t\t\t.flatMap(i -> flattenInterfaces(i).stream())\n-\t\t\t\t.flatMap(i -> Stream.of(i.getMethods()))\n-\t\t\t\t.filter(Method::isDefault)\n-\t\t\t\t.filter(m -> Type.getMethodDescriptor(m).equals(methodContainer.methodDesc))\n-\t\t\t\t.min(COMPARATOR)\n-\t\t\t\t.map(Method::getDeclaringClass)\n-\t\t\t\t.map(Class::getName)\n-\t\t\t\t.map(s -> s.replace(\".\", \"/\"))\n-\t\t\t\t.orElseThrow(NullPointerException::new);\n-\t}\n-\n-\tprivate static List<Class<?>> flattenInterfaces(Class<?> iff) {\n-\t\tList<Class<?>> tmp = new ArrayList<>();\n-\t\tif(iff != null){\n-\t\t\ttmp.add(iff);\n-\t\t\tfor(Class<?> stream : iff.getInterfaces()) {\n-\t\t\t\ttmp.addAll(flattenInterfaces(stream));\n-\t\t\t}\n-\t\t}\n-\t\treturn tmp;\n-\t}\n-\n-\tstatic int getReturnIns(Type arg) {\n-\t\tif(arg == Type.INT_TYPE || arg == Type.BOOLEAN_TYPE || arg == Type.SHORT_TYPE) {\n-\t\t\treturn IRETURN;\n-\t\t}\n-\t\telse if(arg == Type.LONG_TYPE) {\n-\t\t\treturn LRETURN;\n-\t\t}\n-\t\telse if(arg == Type.DOUBLE_TYPE) {\n-\t\t\treturn DRETURN;\n-\t\t}\n-\t\telse if(arg == Type.FLOAT_TYPE) {\n-\t\t\treturn FRETURN;\n-\t\t}\n-\t\telse if(arg == Type.VOID_TYPE) {\n-\t\t\treturn RETURN;\n-\t\t}\n-\t\telse {\n-\t\t\treturn ARETURN;\n-\t\t}\n-\t}\n-\n-\tstatic int getVarIns(Type arg) {\n-\t\tif(arg == Type.INT_TYPE || arg == Type.BOOLEAN_TYPE || arg == Type.SHORT_TYPE) {\n-\t\t\treturn ILOAD;\n-\t\t}\n-\t\telse if(arg == Type.DOUBLE_TYPE) {\n-\t\t\treturn DLOAD;\n-\t\t}\n-\t\telse if(arg == Type.FLOAT_TYPE) {\n-\t\t\treturn FLOAD;\n-\t\t}\n-\t\telse {\n-\t\t\treturn ALOAD;\n-\t\t}\n-\t}\n+    private final int bytecodeVersion;\n+    private String[] interfaces;\n+\n+    private Set<VisitedMethod> visitedMethods = new HashSet<>();\n+    private Set<MethodContainer> defaultMethods = new HashSet<>();\n+\n+    public ClassModifier(int bytecodeVersion, ClassVisitor cv) {\n+        super(ASM5, cv);\n+        this.bytecodeVersion = bytecodeVersion;\n+    }\n+\n+    @Override\n+    public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n+        boolean isClass = (access & ACC_INTERFACE) == 0;\n+        if (isClass) {\n+            defaultMethods = getMethodsToImplement(interfaces, signature);\n+        }\n+        this.interfaces = interfaces;\n+        System.out.println(\"Class is \" + name + \", non abstract \" + isClass + \", Interfaces are \" + Arrays.toString(interfaces) + \"\" +\n+                \", default methods are \" + defaultMethods);\n+        super.visit(bytecodeVersion, access, name, signature, superName, interfaces);\n+    }\n+\n+    private static Set<MethodContainer> getMethodsToImplement(String[] interfaces, String sig) {\n+        return Stream.of(interfaces)\n+                .flatMap(iff -> getMethodsToImplement(iff, sig).stream())\n+                .collect(Collectors.toSet());\n+    }\n+\n+    private static Set<MethodContainer> getMethodsToImplement(String interfac, String sig) {\n+        Class<?> ifClass = Helpers.loadClass(interfac);\n+        Method[] tmp = ifClass.getMethods();\n+        System.out.println(\"Interface: \" + interfac + \", methods: \" + Arrays.toString(tmp));\n+        return Stream.of(tmp)\n+                .filter(m -> !Modifier.isAbstract(m.getModifiers()))\n+                .filter(Helpers::declaringClassBelongsToInputFiles)\n+                .map(m -> createMethodContainer(m, interfac, sig))\n+                .collect(Collectors.toSet());\n+    }\n+\n+    private static MethodContainer createMethodContainer(Method m, String interfac, String sig) {\n+        System.out.println(\"NEED TO CREATE PROXY TO \" + interfac + sig + \"\\n\" + m.getDeclaringClass());\n+        String methodDescriptor = Type.getMethodDescriptor(m);\n+        String internalName = Type.getInternalName(m.getDeclaringClass());\n+        return new MethodContainer(m.getName(), methodDescriptor, internalName, sig, getExceptions(m));\n+    }\n+\n+    private static String[] getExceptions(Method m) {\n+        return Stream.of(m.getExceptionTypes())\n+                .map(Type::getInternalName)\n+                .toArray(String[]::new);\n+    }\n+\n+    @Override\n+    public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+        visitedMethods.add(new VisitedMethod(name, desc));\n+        return new InterfaceToHelperRewriter(super.visitMethod(access, name, desc, signature, exceptions));\n+    }\n+\n+    @Override\n+    public void visitEnd() {\n+        for (MethodContainer m : defaultMethods) {\n+            if (visitedMethods.contains(new VisitedMethod(m.methodName, m.methodDesc))) {\n+                continue;\n+            }\n+            System.out.println(\"VISITEND, CREATING PROXY \" + m);\n+            MethodVisitor tmp = super.visitMethod(ACC_PUBLIC, m.methodName, m.methodDesc, m.signature, m.exceptions);\n+            tmp.visitVarInsn(ALOAD, 0);\n+            int i = 1;\n+            for (Type arg : Type.getArgumentTypes(m.methodDesc)) {\n+                tmp.visitVarInsn(arg.getOpcode(ILOAD), i++);\n+            }\n+            String rightInterface = findRightInterace(m, interfaces);\n+            System.out.println(\"It thinks that the right interface is \" + rightInterface);\n+            String mDesc = Helpers.addParam(m.methodDesc, rightInterface);\n+            tmp.visitMethodInsn(INVOKESTATIC, rightInterface + \"$helper\", m.methodName, mDesc, false);\n+            tmp.visitInsn(Type.getReturnType(m.methodDesc).getOpcode(IRETURN));\n+            tmp.visitMaxs(0, 0);\n+            tmp.visitEnd();\n+        }\n+        super.visitEnd();\n+    }\n+\n+    public static final Comparator<Method> COMPARATOR = (o1, o2) -> {\n+        boolean o1iso2 = o1.getDeclaringClass().isAssignableFrom(o2.getDeclaringClass());\n+        boolean o2iso1 = o2.getDeclaringClass().isAssignableFrom(o1.getDeclaringClass());\n+        if (o1iso2 && o2iso1) {\n+            return 0;\n+        } else if (o2iso1) {\n+            return -1;\n+        } else {\n+            return 1;\n+        }\n+    };\n+\n+    public static String findRightInterace(MethodContainer methodContainer, String[] interfaces) {\n+        System.out.println(\"Find right interfaces for \" + methodContainer + \" \" + Arrays.toString(interfaces));\n+        return Stream.of(interfaces)\n+                .map(Helpers::loadClass)\n+                .flatMap(i -> flattenInterfaces(i).stream())\n+                .flatMap(i -> Stream.of(i.getMethods()))\n+                .filter(Method::isDefault)\n+                .filter(m -> Type.getMethodDescriptor(m).equals(methodContainer.methodDesc))\n+                .min(COMPARATOR)\n+                .map(Method::getDeclaringClass)\n+                .map(Class::getName)\n+                .map(s -> s.replace(\".\", \"/\"))\n+                .orElseThrow(NullPointerException::new);\n+    }\n+\n+    private static List<Class<?>> flattenInterfaces(Class<?> iff) {\n+        List<Class<?>> tmp = new ArrayList<>();\n+        if (iff != null) {\n+            tmp.add(iff);\n+            for (Class<?> stream : iff.getInterfaces()) {\n+                tmp.addAll(flattenInterfaces(stream));\n+            }\n+        }\n+        return tmp;\n+    }\n \n }\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "831594a2bde4af9426c0fddfb25f93dc370a142f",
        "previous_commit_hash": "23cfe1b9dca6a28a2e31bf66726d237f8f5eae20",
        "diff_stats": {
            "additions": 85,
            "deletions": 34
        },
        "diff_content": "@@ -4,48 +4,99 @@\n \n package net.orfjackal.retrolambda.defaultmethods;\n \n+import net.orfjackal.retrolambda.Config;\n import org.objectweb.asm.Type;\n \n+import java.io.File;\n import java.lang.reflect.Method;\n+import java.net.*;\n+import java.nio.file.Path;\n+import java.util.List;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n-import java.util.stream.Stream;\n+import java.util.stream.*;\n+\n import static org.objectweb.asm.Type.*;\n+\n /**\n  * Created by arneball on 2014-08-12.\n  */\n public class Helpers {\n-\tprivate static final Pattern pattern = Pattern.compile(\"\\\\((.*)\\\\)(.*)\");\n-\n-\tpublic static String addParam(String desc, String className) {\n-\t\tMatcher m = pattern.matcher(desc);\n-\t\tm.find();\n-\t\tString rest = m.group(1);\n-\t\tString returntype = m.group(2);\n-\t\treturn String.format(\"(L%s;%s)%s\", className, rest, returntype);\n-\t}\n-\n-\tpublic static String changeReturnType(String desc, String returnType) {\n-\t\tMatcher m = pattern.matcher(desc);\n-\t\tm.find();\n-\t\tString rest = m.group(1);\n-\t\treturn String.format(\"(%s)L%s;\", rest, returnType);\n-\t}\n-\n-\tpublic static Class<?> loadClass(String className) {\n-\t\ttry {\n-\t\t\tClassLoader cl = Thread.currentThread().getContextClassLoader();\n-\t\t\treturn cl.loadClass(className.replace('/', '.'));\n-\t\t} catch (ClassNotFoundException e) {\n-\t\t\tthrow new RuntimeException(e);\n-\t\t}\n-\t}\n-\n-\tpublic static boolean isPrimitive(Type containerReturnType) {\n-\t\treturn Stream.of(BYTE_TYPE, SHORT_TYPE, INT_TYPE, LONG_TYPE, FLOAT_TYPE, DOUBLE_TYPE, VOID_TYPE, BOOLEAN_TYPE)\n-\t\t\t\t.filter(containerReturnType::equals)\n-\t\t\t\t.findAny()\n-\t\t\t\t.isPresent();\n-\n-\t}\n+    private static final Pattern pattern = Pattern.compile(\"\\\\((.*)\\\\)(.*)\");\n+\n+    public static String addParam(String desc, String className) {\n+        Matcher m = pattern.matcher(desc);\n+        m.find();\n+        String rest = m.group(1);\n+        String returntype = m.group(2);\n+        return String.format(\"(L%s;%s)%s\", className, rest, returntype);\n+    }\n+\n+    public static String changeReturnType(String desc, String returnType) {\n+        Matcher m = pattern.matcher(desc);\n+        m.find();\n+        String rest = m.group(1);\n+        return String.format(\"(%s)L%s;\", rest, returnType);\n+    }\n+\n+    public static Class<?> loadClass(String className) {\n+        try {\n+            ClassLoader cl = Thread.currentThread().getContextClassLoader();\n+            return cl.loadClass(className.replace('/', '.'));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+\n+    public static boolean isPrimitive(Type containerReturnType) {\n+        return Stream.of(BYTE_TYPE, SHORT_TYPE, INT_TYPE, LONG_TYPE, FLOAT_TYPE, DOUBLE_TYPE, VOID_TYPE, BOOLEAN_TYPE)\n+                .filter(containerReturnType::equals)\n+                .findAny()\n+                .isPresent();\n+\n+    }\n+\n+    public static boolean interfaceBelongsToUs(String iff) {\n+        return InputFilesClassLoader.INSTANCE.isOurGuy(iff.replace(\"/\", \".\"));\n+    }\n+\n+    public static boolean declaringClassBelongsToInputFiles(Method method) {\n+        boolean ourGuy = InputFilesClassLoader.INSTANCE.isOurGuy(method.getDeclaringClass().getName());\n+        System.out.println(\"Method: \" + method + \", declaring class: \" + method.getDeclaringClass() + \", our guy: \" + ourGuy);\n+        return ourGuy;\n+    }\n+\n+    private static class InputFilesClassLoader extends URLClassLoader {\n+        private static final InputFilesClassLoader INSTANCE = create();\n+        private InputFilesClassLoader(URL inputFiles) {\n+            super(new URL[]{ inputFiles });\n+        }\n+\n+        private static InputFilesClassLoader create() {\n+            Config config = new Config(System.getProperties());\n+            System.out.println(\"INCLUDED FILES \" + config.getInputDir());\n+            try {\n+                URL inputFiles = config.getInputDir().toUri().toURL();\n+                return new InputFilesClassLoader(inputFiles);\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        public boolean isOurGuy(String cname) {\n+            try {\n+                findSystemClass(cname);\n+                return false;\n+            } catch (ClassNotFoundException e) {\n+                try {\n+                    findClass(cname);\n+                    return true;\n+                } catch (ClassNotFoundException e1) {\n+                    return false;\n+                }\n+            }\n+        }\n+    }\n }\n"
    },
    {
        "commit_hash": "831594a2bde4af9426c0fddfb25f93dc370a142f",
        "previous_commit_hash": "23cfe1b9dca6a28a2e31bf66726d237f8f5eae20",
        "diff_stats": {
            "additions": 156,
            "deletions": 154
        },
        "diff_content": "@@ -20,158 +20,160 @@ import java.util.stream.Stream;\n /**\n  * Created by arneball on 2014-08-12.\n  */\n-public class InterfaceModifier  extends ClassVisitor implements Opcodes{\n-\tprivate final int targetByteCode;\n-\tprivate String className;\n-\tprivate boolean isInterface;\n-\tprivate ClassWriter helperClassVisitor;\n-\tprivate String[] interfaces;\n-\tprivate List<MethodContainer> methodContainers = new ArrayList<>();\n-\n-\tpublic InterfaceModifier(ClassVisitor classWriter, int targetBytodeCode) {\n-\t\tsuper(ASM5, classWriter);\n-\t\tthis.targetByteCode = targetBytodeCode;\n-\t}\n-\n-\t@Override\n-\tpublic void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n-\t\tisInterface = (access & ACC_INTERFACE) != 0;\n-\t\tclassName = name;\n-\t\tthis.interfaces = interfaces;\n-\t\t// force load this class, if not, we are overwriting the interface and succeeding loads will see the purely abstract onoe\n-\t\tHelpers.loadClass(name);\n-\t\tSystem.out.println(\"Visiting interface \" + name);\n-\t\tsuper.visit(version, access, name, signature, superName, interfaces);\n-\t}\n-\n-\t@Override\n-\tpublic MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n-\t\tboolean isConcrete = (access & ACC_ABSTRACT) == 0;\n-\t\tboolean isStatic = (access & ACC_STATIC) != 0;\n-\t\tif(isConcrete && isInterface && !isStatic) {\n-\t\t\tsuper.visitMethod(access | ACC_ABSTRACT, name, desc, signature, exceptions);\n-\t\t\tMethodVisitor tmp = getHelperClassVisitor().visitMethod(\n-\t\t\t\t\taccess | ACC_STATIC,\n-\t\t\t\t\tname,\n-\t\t\t\t\tHelpers.addParam(desc, className),\n-\t\t\t\t\tsignature,\n-\t\t\t\t\texceptions);\n-\t\t\tmethodContainers.add(new MethodContainer(name, desc, null, signature, exceptions));\n-\t\t\treturn new InterfaceToHelperRewriter(new BodyMover(tmp));\n-\t\t} else if(isStatic && isInterface) {\n-\t\t\treturn getHelperClassVisitor().visitMethod(access, name + \"$static\", desc, signature, exceptions);\n-\t\t} else {\n-\t\t\treturn super.visitMethod(access, name, desc, signature, exceptions);\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void visitEnd() {\n-\t\tPath newPath = new Config(System.getProperties()).getOutputDir();\n-\t\tArrayList<Method> allMethods = Stream.of(interfaces)\n-\t\t\t\t.map(Helpers::loadClass)\n-\t\t\t\t.flatMap(c -> Stream.of(c.getMethods()))\n-\t\t\t\t.collect(Collectors.toCollection(ArrayList::new));\n-\t\tmethodContainers.stream().forEach(m -> {\n-\t\t\tallMethods.stream()\n-\t\t\t\t\t.filter(meth -> bridgeNeeded(meth, m))\n-\t\t\t\t\t.forEach(meth -> createBridge(meth, m));\n-\t\t});\n-\t\tgetHelperClassVisitor().visitEnd();\n-\t\tsuper.visitEnd();\n-\t\ttry {\n-\t\t\tFiles.createDirectories(newPath.getParent());\n-\t\t\tFiles.write(newPath.resolve(helperClassName() + \".class\"), getHelperClassVisitor().toByteArray());\n-\t\t} catch (IOException e) {\n-\t\t\te.printStackTrace();\n-\t\t}\n-\t}\n-\n-\tprivate void createBridge(Method meth, MethodContainer m) {\n-\t\tint access = ACC_PUBLIC | ACC_STATIC | ACC_BRIDGE;\n-\t\tString desc = Helpers.addParam(m.methodDesc, className);\n-\t\tString returnType = Type.getReturnType(meth).getInternalName();\n-\t\tdesc = Helpers.changeReturnType(desc, returnType);\n-\t\tMethodVisitor tmp = getHelperClassVisitor().visitMethod(access, m.methodName, desc, m.signature, m.exceptions);\n-\t\ttmp.visitVarInsn(ALOAD, 0);\n-\t\tint i = 1;\n-\t\tfor(Type arg : Type.getArgumentTypes(m.methodDesc)) {\n-\t\t\ttmp.visitVarInsn(ClassModifier.getVarIns(arg), i++);\n-\t\t}\n-\t\tString mDesc = Helpers.addParam(m.methodDesc, className);\n-\t\ttmp.visitMethodInsn(INVOKESTATIC, className + \"$helper\", m.methodName, mDesc, false);\n-\t\ttmp.visitInsn(ARETURN);\n-\t\ttmp.visitMaxs(0, 0);\n-\t\ttmp.visitEnd();\n-\t}\n-\n-\tprivate static boolean bridgeNeeded(Method method, MethodContainer methodContainer) {\n-\t\tType[] methodArgumentns = Type.getArgumentTypes(method);\n-\t\tType[] containerArguments = Type.getArgumentTypes(methodContainer.methodDesc);\n-\t\tboolean argsEquals = Arrays.equals(methodArgumentns, containerArguments);\n-\t\tboolean nameEquals = method.getName().equals(methodContainer.methodName);\n-\t\tlog(\"\" + method + \" should be equal to \" + methodContainer);\n-\t\tlog(\"Args equal = \" + argsEquals + \", nameEquals = \" + nameEquals);\n-\t\tif(!argsEquals || !nameEquals) {\n-\t\t\treturn false;\n-\t\t}\n-\t\tType containerReturnType = Type.getReturnType(methodContainer.methodDesc);\n-\t\tType methodReturnType = Type.getReturnType(method);\n-\t\tboolean containerRetPrimite = Helpers.isPrimitive(containerReturnType);\n-\t\tboolean methodRetPrimitive = Helpers.isPrimitive(methodReturnType);\n-\t\tlog(\"Container ret primitive = \" + containerRetPrimite + \", methodRetPrimitive = \" + methodRetPrimitive);\n-\t\tif(containerRetPrimite || methodRetPrimitive) {\n-\t\t\tlog(\"Either one primitive, no bridge needed\");\n-\t\t\treturn false;\n-\t\t}\n-\n-\t\tClass<?> returnType = method.getReturnType();\n-\t\tlog(\"returnType = \" + returnType + \", isPrimitive = \" + returnType.isPrimitive());\n-\t\treturn returnType.isAssignableFrom(Helpers.loadClass(containerReturnType.getClassName()));\n-\t}\n-\n-\tprivate static void log(String s) {\n-\t\tSystem.out.println(\"interfaceModifier ======= \" + s);\n-\t}\n-\n-\tprivate ClassWriter getHelperClassVisitor() {\n-\t\treturn helperClassVisitor == null ? helperClassVisitor = mkHelperClassVisitor() : helperClassVisitor;\n-\t}\n-\n-\tprivate ClassWriter mkHelperClassVisitor() {\n-\t\tClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n-\t\tcw.visit(targetByteCode,\n-\t\t\t\tACC_PUBLIC + ACC_SUPER,\n-\t\t\t\thelperClassName(),\n-\t\t\t\tnull,\n-\t\t\t\t\"java/lang/Object\",\n-\t\t\t\tnull);\n-\t\tMethodVisitor mv = cw.visitMethod(ACC_PRIVATE, \"<init>\", \"()V\", null, null);\n-\t\tmv.visitVarInsn(ALOAD, 0);\n-\t\tmv.visitMethodInsn(INVOKESPECIAL, \"java/lang/Object\", \"<init>\", \"()V\", false);\n-\t\tmv.visitInsn(RETURN);\n-\t\tmv.visitMaxs(0, 0);\n-\t\tmv.visitEnd();\n-    \treturn cw;\n-\t}\n-\n-\tprivate String helperClassName() {\n-\t\treturn className + \"$helper\";\n-\t}\n-\n-\tprivate static class BodyMover extends MethodVisitor{\n-\t\tBodyMover(MethodVisitor newMethod) {\n-\t\t\tsuper(ASM5, newMethod);\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\n-\t\t\tif(opcode == INVOKESPECIAL && itf) {\n-\t\t\t\tsuper.visitMethodInsn(INVOKESTATIC, owner + \"$helper\", name, Helpers.addParam(desc, owner), false);\n-\t\t\t} else {\n-\t\t\t\tsuper.visitMethodInsn(opcode, owner, name, desc, itf);\n-\t\t\t}\n-\t\t}\n-\n-\t}\n+public class InterfaceModifier extends ClassVisitor implements Opcodes {\n+    private final int targetByteCode;\n+    private String className;\n+    private boolean isInterface;\n+    private ClassWriter helperClassVisitor;\n+    private String[] interfaces;\n+    private List<MethodContainer> methodContainers = new ArrayList<>();\n+\n+    public InterfaceModifier(ClassVisitor classWriter, int targetBytodeCode) {\n+        super(ASM5, classWriter);\n+        this.targetByteCode = targetBytodeCode;\n+    }\n+\n+    @Override\n+    public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n+        isInterface = (access & ACC_INTERFACE) != 0;\n+        className = name;\n+        this.interfaces = Stream.of(interfaces)\n+                .filter(Helpers::interfaceBelongsToUs)\n+                .toArray(String[]::new);\n+        // force load this class, if not, we are overwriting the interface and succeeding loads will see the purely abstract onoe\n+        Helpers.loadClass(name);\n+        System.out.println(\"Visiting interface \" + name);\n+        super.visit(version, access, name, signature, superName, interfaces);\n+    }\n+\n+    @Override\n+    public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+        boolean isConcrete = (access & ACC_ABSTRACT) == 0;\n+        boolean isStatic = (access & ACC_STATIC) != 0;\n+        if (isConcrete && isInterface && !isStatic) {\n+            super.visitMethod(access | ACC_ABSTRACT, name, desc, signature, exceptions);\n+            MethodVisitor tmp = getHelperClassVisitor().visitMethod(\n+                    access | ACC_STATIC,\n+                    name,\n+                    Helpers.addParam(desc, className),\n+                    signature,\n+                    exceptions);\n+            methodContainers.add(new MethodContainer(name, desc, null, signature, exceptions));\n+            return new InterfaceToHelperRewriter(new BodyMover(tmp));\n+        } else if (isStatic && isInterface) {\n+            return getHelperClassVisitor().visitMethod(access, name + \"$static\", desc, signature, exceptions);\n+        } else {\n+            return super.visitMethod(access, name, desc, signature, exceptions);\n+        }\n+    }\n+\n+    @Override\n+    public void visitEnd() {\n+        Path newPath = new Config(System.getProperties()).getOutputDir();\n+        ArrayList<Method> allMethods = Stream.of(interfaces)\n+                .map(Helpers::loadClass)\n+                .flatMap(c -> Stream.of(c.getMethods()))\n+                .collect(Collectors.toCollection(ArrayList::new));\n+        methodContainers.stream().forEach(m -> {\n+            allMethods.stream()\n+                    .filter(meth -> bridgeNeeded(meth, m))\n+                    .forEach(meth -> createBridge(meth, m));\n+        });\n+        getHelperClassVisitor().visitEnd();\n+        super.visitEnd();\n+        try {\n+            Files.createDirectories(newPath.getParent());\n+            Files.write(newPath.resolve(helperClassName() + \".class\"), getHelperClassVisitor().toByteArray());\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    private void createBridge(Method meth, MethodContainer m) {\n+        int access = ACC_PUBLIC | ACC_STATIC | ACC_BRIDGE;\n+        String desc = Helpers.addParam(m.methodDesc, className);\n+        String returnType = Type.getReturnType(meth).getInternalName();\n+        desc = Helpers.changeReturnType(desc, returnType);\n+        MethodVisitor tmp = getHelperClassVisitor().visitMethod(access, m.methodName, desc, m.signature, m.exceptions);\n+        tmp.visitVarInsn(ALOAD, 0);\n+        int i = 1;\n+        for (Type arg : Type.getArgumentTypes(m.methodDesc)) {\n+            tmp.visitVarInsn(arg.getOpcode(ILOAD), i++);\n+        }\n+        String mDesc = Helpers.addParam(m.methodDesc, className);\n+        tmp.visitMethodInsn(INVOKESTATIC, className + \"$helper\", m.methodName, mDesc, false);\n+        tmp.visitInsn(ARETURN);\n+        tmp.visitMaxs(0, 0);\n+        tmp.visitEnd();\n+    }\n+\n+    private static boolean bridgeNeeded(Method method, MethodContainer methodContainer) {\n+        Type[] methodArgumentns = Type.getArgumentTypes(method);\n+        Type[] containerArguments = Type.getArgumentTypes(methodContainer.methodDesc);\n+        boolean argsEquals = Arrays.equals(methodArgumentns, containerArguments);\n+        boolean nameEquals = method.getName().equals(methodContainer.methodName);\n+        log(\"\" + method + \" should be equal to \" + methodContainer);\n+        log(\"Args equal = \" + argsEquals + \", nameEquals = \" + nameEquals);\n+        if (!argsEquals || !nameEquals) {\n+            return false;\n+        }\n+        Type containerReturnType = Type.getReturnType(methodContainer.methodDesc);\n+        Type methodReturnType = Type.getReturnType(method);\n+        boolean containerRetPrimite = Helpers.isPrimitive(containerReturnType);\n+        boolean methodRetPrimitive = Helpers.isPrimitive(methodReturnType);\n+        log(\"Container ret primitive = \" + containerRetPrimite + \", methodRetPrimitive = \" + methodRetPrimitive);\n+        if (containerRetPrimite || methodRetPrimitive) {\n+            log(\"Either one primitive, no bridge needed\");\n+            return false;\n+        }\n+\n+        Class<?> returnType = method.getReturnType();\n+        log(\"returnType = \" + returnType + \", isPrimitive = \" + returnType.isPrimitive());\n+        return returnType.isAssignableFrom(Helpers.loadClass(containerReturnType.getClassName()));\n+    }\n+\n+    private static void log(String s) {\n+        System.out.println(\"interfaceModifier ======= \" + s);\n+    }\n+\n+    private ClassWriter getHelperClassVisitor() {\n+        return helperClassVisitor == null ? helperClassVisitor = mkHelperClassVisitor() : helperClassVisitor;\n+    }\n+\n+    private ClassWriter mkHelperClassVisitor() {\n+        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n+        cw.visit(targetByteCode,\n+                ACC_PUBLIC + ACC_SUPER,\n+                helperClassName(),\n+                null,\n+                \"java/lang/Object\",\n+                null);\n+        MethodVisitor mv = cw.visitMethod(ACC_PRIVATE, \"<init>\", \"()V\", null, null);\n+        mv.visitVarInsn(ALOAD, 0);\n+        mv.visitMethodInsn(INVOKESPECIAL, \"java/lang/Object\", \"<init>\", \"()V\", false);\n+        mv.visitInsn(RETURN);\n+        mv.visitMaxs(0, 0);\n+        mv.visitEnd();\n+        return cw;\n+    }\n+\n+    private String helperClassName() {\n+        return className + \"$helper\";\n+    }\n+\n+    private static class BodyMover extends MethodVisitor {\n+        BodyMover(MethodVisitor newMethod) {\n+            super(ASM5, newMethod);\n+        }\n+\n+        @Override\n+        public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\n+            if (opcode == INVOKESPECIAL && itf) {\n+                super.visitMethodInsn(INVOKESTATIC, owner + \"$helper\", name, Helpers.addParam(desc, owner), false);\n+            } else {\n+                super.visitMethodInsn(opcode, owner, name, desc, itf);\n+            }\n+        }\n+\n+    }\n }\n"
    },
    {
        "commit_hash": "831594a2bde4af9426c0fddfb25f93dc370a142f",
        "previous_commit_hash": "23cfe1b9dca6a28a2e31bf66726d237f8f5eae20",
        "diff_stats": {
            "additions": 18,
            "deletions": 15
        },
        "diff_content": "@@ -8,21 +8,24 @@ import org.objectweb.asm.MethodVisitor;\n import org.objectweb.asm.Opcodes;\n \n /**\n-* Created by arneball on 2014-08-24.\n-*/\n+ * Created by arneball on 2014-08-24.\n+ */\n class InterfaceToHelperRewriter extends MethodVisitor implements Opcodes {\n-\tpublic InterfaceToHelperRewriter(MethodVisitor mv) {\n-\t\tsuper(ASM5, mv);\n-\t}\n+    public InterfaceToHelperRewriter(MethodVisitor mv) {\n+        super(ASM5, mv);\n+    }\n \n-\t@Override\n-\tpublic void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\n-\t\tif(opcode == INVOKESPECIAL && itf){\n-\t\t\tsuper.visitMethodInsn(INVOKESTATIC, owner + \"$helper\", name, Helpers.addParam(desc, owner), false);\n-\t\t} else if(opcode == INVOKESTATIC && itf) {\n-\t\t\tsuper.visitMethodInsn(INVOKESTATIC, owner + \"$helper\", name + \"$static\", desc, false);\n-\t\t} else {\n-\t\t\tsuper.visitMethodInsn(opcode, owner, name, desc, itf);\n-\t\t}\n-\t}\n+    @Override\n+    public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\n+        boolean belongsToUs = Helpers.interfaceBelongsToUs(owner);\n+        String newOwner = belongsToUs ? owner + \"$helper\" : owner;\n+        if (opcode == INVOKESPECIAL && itf) {\n+            super.visitMethodInsn(INVOKESTATIC, newOwner, name, Helpers.addParam(desc, owner), false);\n+        } else if (opcode == INVOKESTATIC && itf) {\n+            String newName = belongsToUs ? name + \"$static\" : name;\n+            super.visitMethodInsn(INVOKESTATIC, newOwner, newName, desc, false);\n+        } else {\n+            super.visitMethodInsn(opcode, owner, name, desc, itf);\n+        }\n+    }\n }\n"
    },
    {
        "commit_hash": "831594a2bde4af9426c0fddfb25f93dc370a142f",
        "previous_commit_hash": "23cfe1b9dca6a28a2e31bf66726d237f8f5eae20",
        "diff_stats": {
            "additions": 59,
            "deletions": 47
        },
        "diff_content": "@@ -7,52 +7,64 @@ package net.orfjackal.retrolambda.defaultmethods;\n import java.util.Arrays;\n \n /**\n-* Created by arneball on 2014-08-23.\n-*/\n+ * Created by arneball on 2014-08-23.\n+ */\n class MethodContainer {\n-\tpublic final String methodName, methodDesc, interfce, signature;\n-\tpublic final String[] exceptions;\n-\n-\t@Override\n-\tpublic String toString() {\n-\t\treturn \"MethodContainer{\" +\n-\t\t\t\t\"methodName='\" + methodName + '\\'' +\n-\t\t\t\t\", methodDesc='\" + methodDesc + '\\'' +\n-\t\t\t\t\", interfce='\" + interfce + '\\'' +\n-\t\t\t\t\", signature='\" + signature + '\\'' +\n-\t\t\t\t\", exceptions=\" + Arrays.toString(exceptions) +\n-\t\t\t\t'}';\n-\t}\n-\n-\tMethodContainer(String methodName, String methodDesc, String interfce, String signature, String[] exceptions) {\n-\t\tthis.methodName = methodName;\n-\t\tthis.methodDesc = methodDesc;\n-\t\tthis.interfce = interfce;\n-\t\tthis.signature = signature;\n-\t\tthis.exceptions = exceptions;\n-\t}\n-\n-\t@Override\n-\tpublic boolean equals(Object o) {\n-\t\tif (this == o) return true;\n-\t\tif (o == null || getClass() != o.getClass()) return false;\n-\n-\t\tMethodContainer that = (MethodContainer) o;\n-\n-\t\tif (!Arrays.equals(exceptions, that.exceptions)) return false;\n-\t\tif (methodDesc != null ? !methodDesc.equals(that.methodDesc) : that.methodDesc != null) return false;\n-\t\tif (methodName != null ? !methodName.equals(that.methodName) : that.methodName != null) return false;\n-\t\tif (signature != null ? !signature.equals(that.signature) : that.signature != null) return false;\n-\n-\t\treturn true;\n-\t}\n-\n-\t@Override\n-\tpublic int hashCode() {\n-\t\tint result = methodName != null ? methodName.hashCode() : 0;\n-\t\tresult = 31 * result + (methodDesc != null ? methodDesc.hashCode() : 0);\n-\t\tresult = 31 * result + (signature != null ? signature.hashCode() : 0);\n-\t\tresult = 31 * result + (exceptions != null ? Arrays.hashCode(exceptions) : 0);\n-\t\treturn result;\n-\t}\n+    public final String methodName, methodDesc, interfce, signature;\n+    public final String[] exceptions;\n+\n+    @Override\n+    public String toString() {\n+        return \"MethodContainer{\" +\n+                \"methodName='\" + methodName + '\\'' +\n+                \", methodDesc='\" + methodDesc + '\\'' +\n+                \", interfce='\" + interfce + '\\'' +\n+                \", signature='\" + signature + '\\'' +\n+                \", exceptions=\" + Arrays.toString(exceptions) +\n+                '}';\n+    }\n+\n+    MethodContainer(String methodName, String methodDesc, String interfce, String signature, String[] exceptions) {\n+        this.methodName = methodName;\n+        this.methodDesc = methodDesc;\n+        this.interfce = interfce;\n+        this.signature = signature;\n+        this.exceptions = exceptions;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+\n+        MethodContainer that = (MethodContainer) o;\n+\n+        if (!Arrays.equals(exceptions, that.exceptions)) {\n+            return false;\n+        }\n+        if (methodDesc != null ? !methodDesc.equals(that.methodDesc) : that.methodDesc != null) {\n+            return false;\n+        }\n+        if (methodName != null ? !methodName.equals(that.methodName) : that.methodName != null) {\n+            return false;\n+        }\n+        if (signature != null ? !signature.equals(that.signature) : that.signature != null) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int result = methodName != null ? methodName.hashCode() : 0;\n+        result = 31 * result + (methodDesc != null ? methodDesc.hashCode() : 0);\n+        result = 31 * result + (signature != null ? signature.hashCode() : 0);\n+        result = 31 * result + (exceptions != null ? Arrays.hashCode(exceptions) : 0);\n+        return result;\n+    }\n }\n"
    },
    {
        "commit_hash": "831594a2bde4af9426c0fddfb25f93dc370a142f",
        "previous_commit_hash": "23cfe1b9dca6a28a2e31bf66726d237f8f5eae20",
        "diff_stats": {
            "additions": 36,
            "deletions": 28
        },
        "diff_content": "@@ -5,33 +5,41 @@\n package net.orfjackal.retrolambda.defaultmethods;\n \n /**\n-* Created by arneball on 2014-08-23.\n-*/\n+ * Created by arneball on 2014-08-23.\n+ */\n class VisitedMethod {\n-\tpublic final String name, desc;\n-\n-\tVisitedMethod(String name, String desc) {\n-\t\tthis.name = name;\n-\t\tthis.desc = desc;\n-\t}\n-\n-\t@Override\n-\tpublic boolean equals(Object o) {\n-\t\tif (this == o) return true;\n-\t\tif (o == null || getClass() != o.getClass()) return false;\n-\n-\t\tVisitedMethod that = (VisitedMethod) o;\n-\n-\t\tif (!desc.equals(that.desc)) return false;\n-\t\tif (!name.equals(that.name)) return false;\n-\n-\t\treturn true;\n-\t}\n-\n-\t@Override\n-\tpublic int hashCode() {\n-\t\tint result = name.hashCode();\n-\t\tresult = 31 * result + desc.hashCode();\n-\t\treturn result;\n-\t}\n+    public final String name, desc;\n+\n+    VisitedMethod(String name, String desc) {\n+        this.name = name;\n+        this.desc = desc;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+\n+        VisitedMethod that = (VisitedMethod) o;\n+\n+        if (!desc.equals(that.desc)) {\n+            return false;\n+        }\n+        if (!name.equals(that.name)) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int result = name.hashCode();\n+        result = 31 * result + desc.hashCode();\n+        return result;\n+    }\n }\n"
    },
    {
        "commit_hash": "7c6ff0895a033586b85abc114f798b561a209707",
        "previous_commit_hash": "97a6cba507a0cb758fac9b64cd48ff0e6b91b154",
        "diff_stats": {
            "additions": 5,
            "deletions": 0
        },
        "diff_content": "@@ -4,6 +4,7 @@\n \n package net.orfjackal.retrolambda;\n \n+import net.orfjackal.retrolambda.defaultmethods.Helpers;\n import org.objectweb.asm.ClassReader;\n \n import java.io.IOException;\n@@ -32,6 +33,10 @@ public class Retrolambda {\n             return;\n         }\n \n+        if (FeatureToggles.DEFAULT_METHODS == 1) {\n+            Helpers.config = config;\n+        }\n+\n         Thread.currentThread().setContextClassLoader(new NonDelegatingClassLoader(asUrls(classpath)));\n \n         ClassHierarchyAnalyzer analyzer = new ClassHierarchyAnalyzer();\n"
    },
    {
        "commit_hash": "7c6ff0895a033586b85abc114f798b561a209707",
        "previous_commit_hash": "97a6cba507a0cb758fac9b64cd48ff0e6b91b154",
        "diff_stats": {
            "additions": 6,
            "deletions": 8
        },
        "diff_content": "@@ -7,14 +7,10 @@ package net.orfjackal.retrolambda.defaultmethods;\n import net.orfjackal.retrolambda.Config;\n import org.objectweb.asm.Type;\n \n-import java.io.File;\n import java.lang.reflect.Method;\n import java.net.*;\n-import java.nio.file.Path;\n-import java.util.List;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-import java.util.stream.*;\n+import java.util.regex.*;\n+import java.util.stream.Stream;\n \n import static org.objectweb.asm.Type.*;\n \n@@ -23,6 +19,7 @@ import static org.objectweb.asm.Type.*;\n  */\n public class Helpers {\n     private static final Pattern pattern = Pattern.compile(\"\\\\((.*)\\\\)(.*)\");\n+    public static Config config; // XXX: hack for passing in the Config from main\n \n     public static String addParam(String desc, String className) {\n         Matcher m = pattern.matcher(desc);\n@@ -69,12 +66,13 @@ public class Helpers {\n \n     private static class InputFilesClassLoader extends URLClassLoader {\n         private static final InputFilesClassLoader INSTANCE = create();\n+\n         private InputFilesClassLoader(URL inputFiles) {\n-            super(new URL[]{ inputFiles });\n+            super(new URL[]{inputFiles});\n         }\n \n         private static InputFilesClassLoader create() {\n-            Config config = new Config(System.getProperties());\n+            Config config = Helpers.config;\n             System.out.println(\"INCLUDED FILES \" + config.getInputDir());\n             try {\n                 URL inputFiles = config.getInputDir().toUri().toURL();\n"
    },
    {
        "commit_hash": "7c6ff0895a033586b85abc114f798b561a209707",
        "previous_commit_hash": "97a6cba507a0cb758fac9b64cd48ff0e6b91b154",
        "diff_stats": {
            "additions": 4,
            "deletions": 9
        },
        "diff_content": "@@ -4,18 +4,13 @@\n \n package net.orfjackal.retrolambda.defaultmethods;\n \n-import net.orfjackal.retrolambda.Config;\n import org.objectweb.asm.*;\n \n import java.io.IOException;\n import java.lang.reflect.Method;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n+import java.nio.file.*;\n+import java.util.*;\n+import java.util.stream.*;\n \n /**\n  * Created by arneball on 2014-08-12.\n@@ -69,7 +64,7 @@ public class InterfaceModifier extends ClassVisitor implements Opcodes {\n \n     @Override\n     public void visitEnd() {\n-        Path newPath = new Config(System.getProperties()).getOutputDir();\n+        Path newPath = Helpers.config.getOutputDir();\n         ArrayList<Method> allMethods = Stream.of(interfaces)\n                 .map(Helpers::loadClass)\n                 .flatMap(c -> Stream.of(c.getMethods()))\n"
    },
    {
        "commit_hash": "43998c73f877d7434d1f81206298848a258c1d43",
        "previous_commit_hash": "7c6ff0895a033586b85abc114f798b561a209707",
        "diff_stats": {
            "additions": 1,
            "deletions": 7
        },
        "diff_content": "@@ -124,7 +124,7 @@ You will need Java 8 for compiling and also for generating Javadocs.\n Known Limitations\n -----------------\n \n-Does not backport the use of Java 8 APIs.\n+Does not backport Java 8 APIs.\n \n Does not backport Java 8 language features other than lambda expressions.\n \n@@ -139,12 +139,6 @@ May break if a future JDK 8 build stops generating a new class for each\n that `java.lang.invoke.LambdaMetafactory` generates dynamically, so\n optimizations to that mechanism may break Retrolambda.\n \n-Does not implement JDK 8's safety measure of using `invokespecial` to call\n-lambda implementation methods that are private instance methods (such as\n-when the lambda accesses an instance variable, or the lambda is a method\n-reference to a private instance method), but instead makes those methods\n-package-private.\n-\n \n Version History\n ---------------\n"
    },
    {
        "commit_hash": "5654c5de8187d2d44030f783993d01061fc80f02",
        "previous_commit_hash": "43998c73f877d7434d1f81206298848a258c1d43",
        "diff_stats": {
            "additions": 0,
            "deletions": 19
        },
        "diff_content": "@@ -39,25 +39,6 @@\n   <component name=\"ProjectRootManager\" version=\"2\" languageLevel=\"JDK_1_8\" assert-keyword=\"true\" jdk-15=\"true\" project-jdk-name=\"1.8\" project-jdk-type=\"JavaSDK\">\n     <output url=\"file://$PROJECT_DIR$/classes\" />\n   </component>\n-  <component name=\"SvnConfiguration\" maxAnnotateRevisions=\"500\" myUseAcceleration=\"nothing\" myAutoUpdateAfterCommit=\"false\" cleanupOnStartRun=\"false\">\n-    <option name=\"USER\" value=\"\" />\n-    <option name=\"PASSWORD\" value=\"\" />\n-    <option name=\"mySSHConnectionTimeout\" value=\"30000\" />\n-    <option name=\"mySSHReadTimeout\" value=\"30000\" />\n-    <option name=\"LAST_MERGED_REVISION\" />\n-    <option name=\"MERGE_DRY_RUN\" value=\"false\" />\n-    <option name=\"MERGE_DIFF_USE_ANCESTRY\" value=\"true\" />\n-    <option name=\"UPDATE_LOCK_ON_DEMAND\" value=\"false\" />\n-    <option name=\"IGNORE_SPACES_IN_MERGE\" value=\"false\" />\n-    <option name=\"DETECT_NESTED_COPIES\" value=\"true\" />\n-    <option name=\"CHECK_NESTED_FOR_QUICK_MERGE\" value=\"false\" />\n-    <option name=\"IGNORE_SPACES_IN_ANNOTATE\" value=\"true\" />\n-    <option name=\"SHOW_MERGE_SOURCES_IN_ANNOTATE\" value=\"true\" />\n-    <option name=\"FORCE_UPDATE\" value=\"false\" />\n-    <option name=\"IGNORE_EXTERNALS\" value=\"false\" />\n-    <configuration useDefault=\"true\">C:\\Users\\ORFJackal\\AppData\\Roaming\\Subversion</configuration>\n-    <myIsUseDefaultProxy>false</myIsUseDefaultProxy>\n-  </component>\n   <component name=\"VssConfiguration\">\n     <option name=\"CLIENT_PATH\" value=\"\" />\n     <option name=\"SRCSAFEINI_PATH\" value=\"\" />\n"
    },
    {
        "commit_hash": "d81252e9595b7e5dd5a51af370a1cbd5b8fa1980",
        "previous_commit_hash": "5654c5de8187d2d44030f783993d01061fc80f02",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -24,6 +24,7 @@\n         <option name=\"WHILE_BRACE_FORCE\" value=\"3\" />\n         <option name=\"FOR_BRACE_FORCE\" value=\"3\" />\n         <option name=\"FIELD_ANNOTATION_WRAP\" value=\"0\" />\n+        <ClojureCodeStyleSettings />\n         <XML>\n           <option name=\"XML_LEGACY_SETTINGS_IMPORTED\" value=\"true\" />\n         </XML>\n"
    },
    {
        "commit_hash": "d81252e9595b7e5dd5a51af370a1cbd5b8fa1980",
        "previous_commit_hash": "5654c5de8187d2d44030f783993d01061fc80f02",
        "diff_stats": {
            "additions": 62,
            "deletions": 2
        },
        "diff_content": "@@ -5,16 +5,18 @@\n package net.orfjackal.retrolambda.test;\n \n import org.apache.commons.lang.SystemUtils;\n+import org.hamcrest.*;\n import org.junit.*;\n import org.junit.rules.ExpectedException;\n \n+import java.lang.annotation.*;\n import java.util.*;\n \n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.*;\n import static org.junit.Assume.assumeThat;\n \n-@SuppressWarnings({\"Convert2Lambda\", \"Anonymous2MethodRef\", \"RedundantCast\"})\n+@SuppressWarnings({\"Convert2Lambda\", \"Anonymous2MethodRef\", \"RedundantCast\", \"UnusedDeclaration\"})\n public class DefaultMethodsTest {\n \n     @Rule\n@@ -392,7 +394,6 @@ public class DefaultMethodsTest {\n         }\n     }\n \n-\n     /**\n      * Backporting default methods should not interact badly with backporting lambdas.\n      */\n@@ -437,4 +438,63 @@ public class DefaultMethodsTest {\n         // to make sure that no method was inserted to the class (in which case this call would not fail)\n         new C().spliterator();\n     }\n+\n+    /**\n+     * A naive method for removing method bodies would easily also remove their annotations,\n+     * because in ASM method annotations are expressed as calls on the MethodVisitor.\n+     */\n+    @Test\n+    @SuppressWarnings(\"unchecked\")\n+    public void keeps_annotations_on_interface_methods() throws Exception {\n+        assertThat(\"interface\", AnnotatedInterface.class.getAnnotations(),\n+                arrayContaining(someAnnotation(1)));\n+\n+        assertThat(\"abstract method\", AnnotatedInterface.class.getMethod(\"annotatedAbstractMethod\").getAnnotations(),\n+                arrayContaining(someAnnotation(2)));\n+\n+        assertThat(\"default method\", AnnotatedInterface.class.getMethod(\"annotatedDefaultMethod\").getAnnotations(),\n+                arrayContaining(someAnnotation(3)));\n+\n+        assumeThat(SystemUtils.JAVA_VERSION_FLOAT, is(lessThan(1.8f)));\n+        assertThat(\"static method\", companionOf(AnnotatedInterface.class).getMethod(\"annotatedStaticMethod\").getAnnotations(),\n+                arrayContaining(someAnnotation(4)));\n+    }\n+\n+    @SomeAnnotation(1)\n+    private interface AnnotatedInterface {\n+\n+        @SomeAnnotation(2)\n+        void annotatedAbstractMethod();\n+\n+        @SomeAnnotation(3)\n+        default void annotatedDefaultMethod() {\n+        }\n+\n+        @SomeAnnotation(4)\n+        public static void annotatedStaticMethod() {\n+        }\n+    }\n+\n+    @Retention(value = RetentionPolicy.RUNTIME)\n+    private @interface SomeAnnotation {\n+        int value();\n+    }\n+\n+    private static Matcher<Annotation> someAnnotation(int value) {\n+        return new TypeSafeMatcher<Annotation>() {\n+            @Override\n+            protected boolean matchesSafely(Annotation item) {\n+                return item instanceof SomeAnnotation && ((SomeAnnotation) item).value() == value;\n+            }\n+\n+            @Override\n+            public void describeTo(Description description) {\n+                description.appendText(\"@SomeAnnotation(\" + value + \")\");\n+            }\n+        };\n+    }\n+\n+    private static Class<?> companionOf(Class<?> itf) throws ClassNotFoundException {\n+        return Class.forName(itf.getName() + \"$\");\n+    }\n }\n"
    },
    {
        "commit_hash": "d81252e9595b7e5dd5a51af370a1cbd5b8fa1980",
        "previous_commit_hash": "5654c5de8187d2d44030f783993d01061fc80f02",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -23,7 +23,7 @@ public class LambdaUsageBackporter {\n             next = new ClassModifier(targetVersion, next);\n             next = new InterfaceModifier(next, targetVersion);\n         } else if (FeatureToggles.DEFAULT_METHODS == 2) {\n-            next = new RemoveDefaultMethods(next); // TODO: only needed for interfaces - skip else?\n+            next = new RemoveDefaultMethodBodies(next); // TODO: only needed for interfaces - skip else?\n             next = new ApplyMethodRelocations(next, methodRelocations);\n             next = new InvokeStaticInterfaceMethodConverter(next);\n         } else {\n"
    },
    {
        "commit_hash": "d81252e9595b7e5dd5a51af370a1cbd5b8fa1980",
        "previous_commit_hash": "5654c5de8187d2d44030f783993d01061fc80f02",
        "diff_stats": {
            "additions": 16,
            "deletions": 3
        },
        "diff_content": "@@ -8,11 +8,11 @@ import org.objectweb.asm.*;\n \n import static org.objectweb.asm.Opcodes.*;\n \n-public class RemoveDefaultMethods extends ClassVisitor {\n+public class RemoveDefaultMethodBodies extends ClassVisitor {\n \n     private boolean isInterface;\n \n-    public RemoveDefaultMethods(ClassVisitor next) {\n+    public RemoveDefaultMethodBodies(ClassVisitor next) {\n         super(ASM5, next);\n     }\n \n@@ -24,10 +24,23 @@ public class RemoveDefaultMethods extends ClassVisitor {\n \n     @Override\n     public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n-        if (isInterface && !Flags.hasFlag(access, ACC_ABSTRACT)) {\n+        if (isInterface && isDefaultMethod(access)) {\n+            MethodVisitor next = super.visitMethod(access | ACC_ABSTRACT, name, desc, signature, exceptions);\n+            // TODO: annotations\n+            return null;\n+        } else if (isInterface && isStaticMethod(access)) {\n             return null;\n         } else {\n             return super.visitMethod(access, name, desc, signature, exceptions);\n         }\n     }\n+\n+    private static boolean isDefaultMethod(int access) {\n+        return !Flags.hasFlag(access, ACC_ABSTRACT)\n+                && !Flags.hasFlag(access, ACC_STATIC);\n+    }\n+\n+    private static boolean isStaticMethod(int access) {\n+        return Flags.hasFlag(access, ACC_STATIC);\n+    }\n }\n"
    },
    {
        "commit_hash": "cf561c518dc37a961c90437a472a97b6a09e8bd0",
        "previous_commit_hash": "d81252e9595b7e5dd5a51af370a1cbd5b8fa1980",
        "diff_stats": {
            "additions": 20,
            "deletions": 3
        },
        "diff_content": "@@ -5,6 +5,7 @@\n package net.orfjackal.retrolambda;\n \n import org.objectweb.asm.*;\n+import org.objectweb.asm.tree.MethodNode;\n \n import static org.objectweb.asm.Opcodes.*;\n \n@@ -26,10 +27,9 @@ public class RemoveDefaultMethodBodies extends ClassVisitor {\n     public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n         if (isInterface && isDefaultMethod(access)) {\n             MethodVisitor next = super.visitMethod(access | ACC_ABSTRACT, name, desc, signature, exceptions);\n-            // TODO: annotations\n-            return null;\n+            return new RemoveMethodBody(next, access, name, desc, signature, exceptions);\n         } else if (isInterface && isStaticMethod(access)) {\n-            return null;\n+            return null; // TODO: move to another class for more cohesion\n         } else {\n             return super.visitMethod(access, name, desc, signature, exceptions);\n         }\n@@ -43,4 +43,21 @@ public class RemoveDefaultMethodBodies extends ClassVisitor {\n     private static boolean isStaticMethod(int access) {\n         return Flags.hasFlag(access, ACC_STATIC);\n     }\n+\n+\n+    private static class RemoveMethodBody extends MethodNode {\n+        private final MethodVisitor next;\n+\n+        private RemoveMethodBody(MethodVisitor next, int access, String name, String desc, String signature, String[] exceptions) {\n+            super(ASM5, access, name, desc, signature, exceptions);\n+            this.next = next;\n+        }\n+\n+        @Override\n+        public void visitEnd() {\n+            super.visitEnd();\n+            instructions.clear();\n+            super.accept(next);\n+        }\n+    }\n }\n"
    },
    {
        "commit_hash": "d0a7fc9cfc4a92fbcd844de20bee25d86cbf586e",
        "previous_commit_hash": "cf561c518dc37a961c90437a472a97b6a09e8bd0",
        "diff_stats": {
            "additions": 8,
            "deletions": 1
        },
        "diff_content": "@@ -23,7 +23,10 @@ public class LambdaUsageBackporter {\n             next = new ClassModifier(targetVersion, next);\n             next = new InterfaceModifier(next, targetVersion);\n         } else if (FeatureToggles.DEFAULT_METHODS == 2) {\n-            next = new RemoveDefaultMethodBodies(next); // TODO: only needed for interfaces - skip else?\n+            if (isInterface(reader)) {\n+                next = new RemoveStaticMethods(next);\n+                next = new RemoveDefaultMethodBodies(next);\n+            }\n             next = new ApplyMethodRelocations(next, methodRelocations);\n             next = new InvokeStaticInterfaceMethodConverter(next);\n         } else {\n@@ -49,6 +52,10 @@ public class LambdaUsageBackporter {\n         }\n     }\n \n+    private static boolean isInterface(ClassReader reader) {\n+        return Flags.hasFlag(reader.getAccess(), ACC_INTERFACE);\n+    }\n+\n \n     private static class InvokeDynamicInsnConverter extends ClassVisitor {\n         private int classAccess;\n"
    },
    {
        "commit_hash": "d0a7fc9cfc4a92fbcd844de20bee25d86cbf586e",
        "previous_commit_hash": "cf561c518dc37a961c90437a472a97b6a09e8bd0",
        "diff_stats": {
            "additions": 1,
            "deletions": 16
        },
        "diff_content": "@@ -11,25 +11,15 @@ import static org.objectweb.asm.Opcodes.*;\n \n public class RemoveDefaultMethodBodies extends ClassVisitor {\n \n-    private boolean isInterface;\n-\n     public RemoveDefaultMethodBodies(ClassVisitor next) {\n         super(ASM5, next);\n     }\n \n-    @Override\n-    public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n-        isInterface = Flags.hasFlag(access, ACC_INTERFACE);\n-        super.visit(version, access, name, signature, superName, interfaces);\n-    }\n-\n     @Override\n     public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n-        if (isInterface && isDefaultMethod(access)) {\n+        if (isDefaultMethod(access)) {\n             MethodVisitor next = super.visitMethod(access | ACC_ABSTRACT, name, desc, signature, exceptions);\n             return new RemoveMethodBody(next, access, name, desc, signature, exceptions);\n-        } else if (isInterface && isStaticMethod(access)) {\n-            return null; // TODO: move to another class for more cohesion\n         } else {\n             return super.visitMethod(access, name, desc, signature, exceptions);\n         }\n@@ -40,11 +30,6 @@ public class RemoveDefaultMethodBodies extends ClassVisitor {\n                 && !Flags.hasFlag(access, ACC_STATIC);\n     }\n \n-    private static boolean isStaticMethod(int access) {\n-        return Flags.hasFlag(access, ACC_STATIC);\n-    }\n-\n-\n     private static class RemoveMethodBody extends MethodNode {\n         private final MethodVisitor next;\n \n"
    },
    {
        "commit_hash": "d0a7fc9cfc4a92fbcd844de20bee25d86cbf586e",
        "previous_commit_hash": "cf561c518dc37a961c90437a472a97b6a09e8bd0",
        "diff_stats": {
            "additions": 29,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,29 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda;\n+\n+import org.objectweb.asm.*;\n+\n+import static org.objectweb.asm.Opcodes.*;\n+\n+public class RemoveStaticMethods extends ClassVisitor {\n+\n+    public RemoveStaticMethods(ClassVisitor next) {\n+        super(ASM5, next);\n+    }\n+\n+    @Override\n+    public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+        if (isStaticMethod(access)) {\n+            return null;\n+        } else {\n+            return super.visitMethod(access, name, desc, signature, exceptions);\n+        }\n+    }\n+\n+    private static boolean isStaticMethod(int access) {\n+        return Flags.hasFlag(access, ACC_STATIC);\n+    }\n+}\n"
    },
    {
        "commit_hash": "637f71e17199ecb5b26941b13395c1fffb657156",
        "previous_commit_hash": "d0a7fc9cfc4a92fbcd844de20bee25d86cbf586e",
        "diff_stats": {
            "additions": 12,
            "deletions": 0
        },
        "diff_content": "@@ -51,6 +51,8 @@ public class ClassHierarchyAnalyzerTest {\n     }\n \n \n+    // Method relocations\n+\n     @Test\n     public void abstract_methods_on_interfaces_are_not_relocated() {\n         analyze(InterfaceMethodTypes.class);\n@@ -61,6 +63,16 @@ public class ClassHierarchyAnalyzerTest {\n         assertThat(target, is(source));\n     }\n \n+    @Test\n+    public void default_methods_on_interfaces_are_not_relocated() {\n+        analyze(InterfaceMethodTypes.class);\n+\n+        MethodRef source = new MethodRef(InterfaceMethodTypes.class, \"defaultMethod\", \"()V\");\n+        MethodRef target = analyzer.getMethodLocation(source);\n+\n+        assertThat(target, is(source));\n+    }\n+\n     @Test\n     public void static_methods_on_interfaces_are_relocated_to_companion_classes() {\n         analyze(InterfaceMethodTypes.class);\n"
    },
    {
        "commit_hash": "feabde79d74e700b03b978ffd2c1db2538260e8b",
        "previous_commit_hash": "637f71e17199ecb5b26941b13395c1fffb657156",
        "diff_stats": {
            "additions": 163,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,163 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda;\n+\n+import org.objectweb.asm.*;\n+\n+import java.lang.reflect.Field;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.objectweb.asm.Opcodes.*;\n+\n+public class BackportLambdaInvocations extends ClassVisitor {\n+\n+    private int classAccess;\n+    private String className;\n+    private final Map<Handle, Handle> lambdaBridgesToImplMethods = new LinkedHashMap<>();\n+\n+    public BackportLambdaInvocations(ClassVisitor next) {\n+        super(ASM5, next);\n+    }\n+\n+    @Override\n+    public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n+        resetLambdaClassSequenceNumber();\n+        this.classAccess = access;\n+        this.className = name;\n+        super.visit(version, access, name, signature, superName, interfaces);\n+    }\n+\n+    private static void resetLambdaClassSequenceNumber() {\n+        try {\n+            Field counterField = Class.forName(\"java.lang.invoke.InnerClassLambdaMetafactory\").getDeclaredField(\"counter\");\n+            counterField.setAccessible(true);\n+            AtomicInteger counter = (AtomicInteger) counterField.get(null);\n+            counter.set(0);\n+        } catch (Throwable t) {\n+            // print to stdout to keep in sync with other log output\n+            System.out.println(\"WARNING: Failed to start class numbering from one. Don't worry, it's cosmetic, \" +\n+                    \"but please file a bug report and tell on which JDK version this happened.\");\n+            t.printStackTrace(System.out);\n+        }\n+    }\n+\n+    @Override\n+    public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+        // TODO: move stuff to an interface transformer\n+        if (isBridgeMethodOnInterface(access)) {\n+            return null; // remove the bridge method; Java 7 didn't use them\n+        }\n+        if (FeatureToggles.DEFAULT_METHODS == 0\n+                && isNonAbstractMethodOnInterface(access)\n+                && !isClassInitializerMethod(name, desc, access)) {\n+            // In case we have missed a case of Java 8 producing non-abstract methods\n+            // on interfaces, we have this warning here to get a bug report sooner.\n+            // Not allowed by Java 7:\n+            // - default methods\n+            // - static methods\n+            // - bridge methods\n+            // Allowed by Java 7:\n+            // - class initializer methods (for initializing constants)\n+            System.out.println(\"WARNING: Method '\" + name + \"' of interface '\" + className + \"' is non-abstract! \" +\n+                    \"This will probably fail to run on Java 7 and below. \" +\n+                    \"If you get this warning _without_ using Java 8's default methods, \" +\n+                    \"please report a bug at https://github.com/orfjackal/retrolambda/issues \" +\n+                    \"together with an SSCCE (http://www.sscce.org/)\");\n+        }\n+        return new InvokeDynamicInsnConverter(super.visitMethod(access, name, desc, signature, exceptions));\n+    }\n+\n+    private boolean isBridgeMethodOnInterface(int methodAccess) {\n+        return Flags.hasFlag(classAccess, ACC_INTERFACE) &&\n+                Flags.hasFlag(methodAccess, ACC_BRIDGE);\n+    }\n+\n+    private boolean isNonAbstractMethodOnInterface(int methodAccess) {\n+        return Flags.hasFlag(classAccess, ACC_INTERFACE) &&\n+                !Flags.hasFlag(methodAccess, ACC_ABSTRACT);\n+    }\n+\n+    private static boolean isClassInitializerMethod(String name, String desc, int methodAccess) {\n+        return name.equals(\"<clinit>\") &&\n+                desc.equals(\"()V\") &&\n+                Flags.hasFlag(methodAccess, ACC_STATIC);\n+    }\n+\n+    Handle getLambdaBridgeMethod(Handle implMethod) {\n+        if (!implMethod.getOwner().equals(className)) {\n+            return implMethod;\n+        }\n+        // TODO: do not generate a bridge method if the impl method is not private (probably not implementable with a single pass)\n+        String name = \"access$lambda$\" + lambdaBridgesToImplMethods.size();\n+        String desc = implMethod.getTag() == H_INVOKESTATIC\n+                ? implMethod.getDesc()\n+                : Types.prependArgumentType(Type.getType(\"L\" + className + \";\"), implMethod.getDesc());\n+        Handle bridgeMethod = new Handle(H_INVOKESTATIC, className, name, desc);\n+        lambdaBridgesToImplMethods.put(bridgeMethod, implMethod);\n+        return bridgeMethod;\n+    }\n+\n+    @Override\n+    public void visitEnd() {\n+        for (Map.Entry<Handle, Handle> entry : lambdaBridgesToImplMethods.entrySet()) {\n+            Handle bridgeMethod = entry.getKey();\n+            Handle implMethod = entry.getValue();\n+            generateLambdaBridgeMethod(bridgeMethod, implMethod);\n+        }\n+        super.visitEnd();\n+    }\n+\n+    private void generateLambdaBridgeMethod(Handle bridge, Handle impl) {\n+        MethodVisitor mv = super.visitMethod(ACC_STATIC | ACC_SYNTHETIC | ACC_BRIDGE,\n+                bridge.getName(), bridge.getDesc(), null, null);\n+        mv.visitCode();\n+        int varIndex = 0;\n+        for (Type type : Type.getArgumentTypes(bridge.getDesc())) {\n+            mv.visitVarInsn(type.getOpcode(ILOAD), varIndex);\n+            varIndex += type.getSize();\n+        }\n+        mv.visitMethodInsn(Handles.getOpcode(impl), impl.getOwner(), impl.getName(), impl.getDesc(), impl.getTag() == H_INVOKEINTERFACE);\n+        mv.visitInsn(Type.getReturnType(bridge.getDesc()).getOpcode(IRETURN));\n+        mv.visitMaxs(-1, -1); // rely on ClassWriter.COMPUTE_MAXS\n+        mv.visitEnd();\n+    }\n+\n+\n+    private class InvokeDynamicInsnConverter extends MethodVisitor {\n+\n+        public InvokeDynamicInsnConverter(MethodVisitor next) {\n+            super(ASM5, next);\n+        }\n+\n+        @Override\n+        public void visitInvokeDynamicInsn(String name, String desc, Handle bsm, Object... bsmArgs) {\n+            if (bsm.getOwner().equals(LambdaNaming.LAMBDA_METAFACTORY)) {\n+                backportLambda(name, Type.getType(desc), bsm, bsmArgs);\n+            } else {\n+                super.visitInvokeDynamicInsn(name, desc, bsm, bsmArgs);\n+            }\n+        }\n+\n+        private void backportLambda(String invokedName, Type invokedType, Handle bsm, Object[] bsmArgs) {\n+            Class<?> invoker = loadClass(className);\n+            Handle implMethod = (Handle) bsmArgs[1];\n+            Handle bridgeMethod = getLambdaBridgeMethod(implMethod);\n+\n+            LambdaFactoryMethod factory = LambdaReifier.reifyLambdaClass(implMethod, bridgeMethod,\n+                    invoker, invokedName, invokedType, bsm, bsmArgs);\n+            super.visitMethodInsn(INVOKESTATIC, factory.getOwner(), factory.getName(), factory.getDesc(), false);\n+        }\n+    }\n+\n+    private static Class<?> loadClass(String className) {\n+        try {\n+            ClassLoader cl = Thread.currentThread().getContextClassLoader();\n+            return cl.loadClass(className.replace('/', '.'));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+}\n"
    },
    {
        "commit_hash": "feabde79d74e700b03b978ffd2c1db2538260e8b",
        "previous_commit_hash": "637f71e17199ecb5b26941b13395c1fffb657156",
        "diff_stats": {
            "additions": 2,
            "deletions": 157
        },
        "diff_content": "@@ -7,16 +7,11 @@ package net.orfjackal.retrolambda;\n import net.orfjackal.retrolambda.defaultmethods.*;\n import org.objectweb.asm.*;\n \n-import java.lang.reflect.Field;\n-import java.util.*;\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-import static org.objectweb.asm.Opcodes.*;\n+import static org.objectweb.asm.Opcodes.ACC_INTERFACE;\n \n public class LambdaUsageBackporter {\n \n     public static byte[] transform(ClassReader reader, int targetVersion, MethodRelocations methodRelocations) {\n-        resetLambdaClassSequenceNumber();\n         ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n         ClassVisitor next = writer;\n         if (FeatureToggles.DEFAULT_METHODS == 1) {\n@@ -32,163 +27,13 @@ public class LambdaUsageBackporter {\n         } else {\n             next = new InvokeStaticInterfaceMethodConverter(next);\n         }\n-        next = new InvokeDynamicInsnConverter(next);\n+        next = new BackportLambdaInvocations(next);\n         next = new LowerBytecodeVersion(next, targetVersion);\n         reader.accept(next, 0);\n         return writer.toByteArray();\n     }\n \n-    private static void resetLambdaClassSequenceNumber() {\n-        try {\n-            Field counterField = Class.forName(\"java.lang.invoke.InnerClassLambdaMetafactory\").getDeclaredField(\"counter\");\n-            counterField.setAccessible(true);\n-            AtomicInteger counter = (AtomicInteger) counterField.get(null);\n-            counter.set(0);\n-        } catch (Throwable t) {\n-            // print to stdout to keep in sync with other log output\n-            System.out.println(\"WARNING: Failed to start class numbering from one. Don't worry, it's cosmetic, \" +\n-                    \"but please file a bug report and tell on which JDK version this happened.\");\n-            t.printStackTrace(System.out);\n-        }\n-    }\n-\n     private static boolean isInterface(ClassReader reader) {\n         return Flags.hasFlag(reader.getAccess(), ACC_INTERFACE);\n     }\n-\n-\n-    private static class InvokeDynamicInsnConverter extends ClassVisitor {\n-        private int classAccess;\n-        String className;\n-        private final Map<Handle, Handle> lambdaBridgesToImplMethods = new LinkedHashMap<>();\n-\n-        public InvokeDynamicInsnConverter(ClassVisitor next) {\n-            super(ASM5, next);\n-        }\n-\n-        @Override\n-        public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n-            super.visit(version, access, name, signature, superName, interfaces);\n-            this.classAccess = access;\n-            this.className = name;\n-        }\n-\n-        @Override\n-        public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n-            if (isBridgeMethodOnInterface(access)) {\n-                return null; // remove the bridge method; Java 7 didn't use them\n-            }\n-            if (FeatureToggles.DEFAULT_METHODS == 0\n-                    && isNonAbstractMethodOnInterface(access)\n-                    && !isClassInitializerMethod(name, desc, access)) {\n-                // In case we have missed a case of Java 8 producing non-abstract methods\n-                // on interfaces, we have this warning here to get a bug report sooner.\n-                // Not allowed by Java 7:\n-                // - default methods\n-                // - static methods\n-                // - bridge methods\n-                // Allowed by Java 7:\n-                // - class initializer methods (for initializing constants)\n-                System.out.println(\"WARNING: Method '\" + name + \"' of interface '\" + className + \"' is non-abstract! \" +\n-                        \"This will probably fail to run on Java 7 and below. \" +\n-                        \"If you get this warning _without_ using Java 8's default methods, \" +\n-                        \"please report a bug at https://github.com/orfjackal/retrolambda/issues \" +\n-                        \"together with an SSCCE (http://www.sscce.org/)\");\n-            }\n-            MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n-            return new InvokeDynamicInsnConvertingMethodVisitor(mv, this);\n-        }\n-\n-        private boolean isBridgeMethodOnInterface(int methodAccess) {\n-            return Flags.hasFlag(classAccess, ACC_INTERFACE) &&\n-                    Flags.hasFlag(methodAccess, ACC_BRIDGE);\n-        }\n-\n-        private boolean isNonAbstractMethodOnInterface(int methodAccess) {\n-            return Flags.hasFlag(classAccess, ACC_INTERFACE) &&\n-                    !Flags.hasFlag(methodAccess, ACC_ABSTRACT);\n-        }\n-\n-        private static boolean isClassInitializerMethod(String name, String desc, int methodAccess) {\n-            return name.equals(\"<clinit>\") &&\n-                    desc.equals(\"()V\") &&\n-                    Flags.hasFlag(methodAccess, ACC_STATIC);\n-        }\n-\n-        Handle getLambdaBridgeMethod(Handle implMethod) {\n-            if (!implMethod.getOwner().equals(className)) {\n-                return implMethod;\n-            }\n-            // TODO: do not generate a bridge method if the impl method is not private (probably not implementable with a single pass)\n-            String name = \"access$lambda$\" + lambdaBridgesToImplMethods.size();\n-            String desc = implMethod.getTag() == H_INVOKESTATIC\n-                    ? implMethod.getDesc()\n-                    : Types.prependArgumentType(Type.getType(\"L\" + className + \";\"), implMethod.getDesc());\n-            Handle bridgeMethod = new Handle(H_INVOKESTATIC, className, name, desc);\n-            lambdaBridgesToImplMethods.put(bridgeMethod, implMethod);\n-            return bridgeMethod;\n-        }\n-\n-        @Override\n-        public void visitEnd() {\n-            for (Map.Entry<Handle, Handle> entry : lambdaBridgesToImplMethods.entrySet()) {\n-                Handle bridgeMethod = entry.getKey();\n-                Handle implMethod = entry.getValue();\n-                generateLambdaBridgeMethod(bridgeMethod, implMethod);\n-            }\n-            super.visitEnd();\n-        }\n-\n-        private void generateLambdaBridgeMethod(Handle bridge, Handle impl) {\n-            MethodVisitor mv = super.visitMethod(ACC_STATIC | ACC_SYNTHETIC | ACC_BRIDGE,\n-                    bridge.getName(), bridge.getDesc(), null, null);\n-            mv.visitCode();\n-            int varIndex = 0;\n-            for (Type type : Type.getArgumentTypes(bridge.getDesc())) {\n-                mv.visitVarInsn(type.getOpcode(ILOAD), varIndex);\n-                varIndex += type.getSize();\n-            }\n-            mv.visitMethodInsn(Handles.getOpcode(impl), impl.getOwner(), impl.getName(), impl.getDesc(), impl.getTag() == H_INVOKEINTERFACE);\n-            mv.visitInsn(Type.getReturnType(bridge.getDesc()).getOpcode(IRETURN));\n-            mv.visitMaxs(-1, -1); // rely on ClassWriter.COMPUTE_MAXS\n-            mv.visitEnd();\n-        }\n-    }\n-\n-    private static class InvokeDynamicInsnConvertingMethodVisitor extends MethodVisitor {\n-        private final InvokeDynamicInsnConverter context;\n-\n-        public InvokeDynamicInsnConvertingMethodVisitor(MethodVisitor next, InvokeDynamicInsnConverter context) {\n-            super(ASM5, next);\n-            this.context = context;\n-        }\n-\n-        @Override\n-        public void visitInvokeDynamicInsn(String name, String desc, Handle bsm, Object... bsmArgs) {\n-            if (bsm.getOwner().equals(LambdaNaming.LAMBDA_METAFACTORY)) {\n-                backportLambda(name, Type.getType(desc), bsm, bsmArgs);\n-            } else {\n-                super.visitInvokeDynamicInsn(name, desc, bsm, bsmArgs);\n-            }\n-        }\n-\n-        private void backportLambda(String invokedName, Type invokedType, Handle bsm, Object[] bsmArgs) {\n-            Class<?> invoker = loadClass(context.className);\n-            Handle implMethod = (Handle) bsmArgs[1];\n-            Handle bridgeMethod = context.getLambdaBridgeMethod(implMethod);\n-\n-            LambdaFactoryMethod factory = LambdaReifier.reifyLambdaClass(implMethod, bridgeMethod,\n-                    invoker, invokedName, invokedType, bsm, bsmArgs);\n-            super.visitMethodInsn(INVOKESTATIC, factory.getOwner(), factory.getName(), factory.getDesc(), false);\n-        }\n-\n-        private static Class<?> loadClass(String className) {\n-            try {\n-                ClassLoader cl = Thread.currentThread().getContextClassLoader();\n-                return cl.loadClass(className.replace('/', '.'));\n-            } catch (ClassNotFoundException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-    }\n }\n"
    },
    {
        "commit_hash": "a1681b9bf9a6dd380e2d04b1a067f7f6c5d9813e",
        "previous_commit_hash": "feabde79d74e700b03b978ffd2c1db2538260e8b",
        "diff_stats": {
            "additions": 154,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,154 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda;\n+\n+import org.objectweb.asm.*;\n+\n+import static org.objectweb.asm.Opcodes.*;\n+\n+public class BackportLambdaClass extends ClassVisitor {\n+\n+    private static final String SINGLETON_FIELD_NAME = \"instance\";\n+    private static final String JAVA_LANG_OBJECT = \"java/lang/Object\";\n+\n+    private String lambdaClass;\n+    private Type constructor;\n+    private Handle implMethod;\n+    private Handle bridgeMethod;\n+    private LambdaFactoryMethod factoryMethod;\n+\n+    public BackportLambdaClass(ClassVisitor next) {\n+        super(ASM5, next);\n+    }\n+\n+    @Override\n+    public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n+        lambdaClass = name;\n+        LambdaReifier.setLambdaClass(lambdaClass);\n+        implMethod = LambdaReifier.getLambdaImplMethod();\n+        bridgeMethod = LambdaReifier.getLambdaBridgeMethod();\n+        factoryMethod = LambdaReifier.getLambdaFactoryMethod();\n+\n+        if (superName.equals(LambdaNaming.MAGIC_LAMBDA_IMPL)) {\n+            superName = JAVA_LANG_OBJECT;\n+        }\n+        super.visit(version, access, name, signature, superName, interfaces);\n+    }\n+\n+    @Override\n+    public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+        if (name.equals(\"<init>\")) {\n+            constructor = Type.getMethodType(desc);\n+        }\n+        MethodVisitor next = super.visitMethod(access, name, desc, signature, exceptions);\n+        next = new RemoveMagicLambdaConstructorCall(next);\n+        next = new BridgePrivateMethodInvocations(next);\n+        return next;\n+    }\n+\n+    @Override\n+    public void visitEnd() {\n+        if (isStateless()) {\n+            makeSingleton();\n+        }\n+        generateFactoryMethod();\n+        super.visitEnd();\n+    }\n+\n+    private void makeSingleton() {\n+        FieldVisitor fv = super.visitField(ACC_PRIVATE | ACC_STATIC | ACC_FINAL,\n+                SINGLETON_FIELD_NAME, singletonFieldDesc(), null, null);\n+        fv.visitEnd();\n+\n+        MethodVisitor mv = super.visitMethod(ACC_STATIC, \"<clinit>\", \"()V\", null, null);\n+        mv.visitCode();\n+        mv.visitTypeInsn(NEW, lambdaClass);\n+        mv.visitInsn(DUP);\n+        mv.visitMethodInsn(INVOKESPECIAL, lambdaClass, \"<init>\", \"()V\", false);\n+        mv.visitFieldInsn(PUTSTATIC, lambdaClass, SINGLETON_FIELD_NAME, singletonFieldDesc());\n+        mv.visitInsn(RETURN);\n+        mv.visitMaxs(-1, -1); // rely on ClassWriter.COMPUTE_MAXS\n+        mv.visitEnd();\n+    }\n+\n+    private void generateFactoryMethod() {\n+        MethodVisitor mv = cv.visitMethod(ACC_PUBLIC | ACC_STATIC,\n+                factoryMethod.getName(), factoryMethod.getDesc(), null, null);\n+        mv.visitCode();\n+\n+        if (isStateless()) {\n+            mv.visitFieldInsn(GETSTATIC, lambdaClass, SINGLETON_FIELD_NAME, singletonFieldDesc());\n+            mv.visitInsn(ARETURN);\n+\n+        } else {\n+            mv.visitTypeInsn(NEW, lambdaClass);\n+            mv.visitInsn(DUP);\n+            int varIndex = 0;\n+            for (Type type : constructor.getArgumentTypes()) {\n+                mv.visitVarInsn(type.getOpcode(ILOAD), varIndex);\n+                varIndex += type.getSize();\n+            }\n+            mv.visitMethodInsn(INVOKESPECIAL, lambdaClass, \"<init>\", constructor.getDescriptor(), false);\n+            mv.visitInsn(ARETURN);\n+        }\n+\n+        mv.visitMaxs(-1, -1); // rely on ClassWriter.COMPUTE_MAXS\n+        mv.visitEnd();\n+    }\n+\n+    private String singletonFieldDesc() {\n+        return \"L\" + lambdaClass + \";\";\n+    }\n+\n+    private boolean isStateless() {\n+        return constructor.getArgumentTypes().length == 0;\n+    }\n+\n+\n+    private static class RemoveMagicLambdaConstructorCall extends MethodVisitor {\n+\n+        public RemoveMagicLambdaConstructorCall(MethodVisitor next) {\n+            super(ASM5, next);\n+        }\n+\n+        @Override\n+        public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\n+            if (opcode == INVOKESPECIAL\n+                    && owner.equals(LambdaNaming.MAGIC_LAMBDA_IMPL)\n+                    && name.equals(\"<init>\")\n+                    && desc.equals(\"()V\")) {\n+                owner = JAVA_LANG_OBJECT;\n+            }\n+            super.visitMethodInsn(opcode, owner, name, desc, itf);\n+        }\n+    }\n+\n+    private class BridgePrivateMethodInvocations extends MethodVisitor {\n+\n+        public BridgePrivateMethodInvocations(MethodVisitor next) {\n+            super(ASM5, next);\n+        }\n+\n+        @Override\n+        public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\n+            // Java 8's lambda classes get away with calling private virtual methods\n+            // by using invokespecial because the JVM relaxes the bytecode validation\n+            // of the lambda classes it generates. We must however call them through\n+            // a non-private bridge method which we have generated.\n+            if (owner.equals(implMethod.getOwner())\n+                    && name.equals(implMethod.getName())\n+                    && desc.equals(implMethod.getDesc())) {\n+                super.visitMethodInsn(\n+                        Handles.getOpcode(bridgeMethod),\n+                        bridgeMethod.getOwner(),\n+                        bridgeMethod.getName(),\n+                        bridgeMethod.getDesc(),\n+                        bridgeMethod.getTag() == H_INVOKEINTERFACE);\n+            } else {\n+                super.visitMethodInsn(opcode, owner, name, desc, itf);\n+            }\n+        }\n+    }\n+}\n"
    },
    {
        "commit_hash": "a1681b9bf9a6dd380e2d04b1a067f7f6c5d9813e",
        "previous_commit_hash": "feabde79d74e700b03b978ffd2c1db2538260e8b",
        "diff_stats": {
            "additions": 1,
            "deletions": 151
        },
        "diff_content": "@@ -7,13 +7,8 @@ package net.orfjackal.retrolambda;\n import net.orfjackal.retrolambda.defaultmethods.ClassModifier;\n import org.objectweb.asm.*;\n \n-import static org.objectweb.asm.Opcodes.*;\n-\n public class LambdaClassBackporter {\n \n-    private static final String SINGLETON_FIELD_NAME = \"instance\";\n-    private static final String JAVA_LANG_OBJECT = \"java/lang/Object\";\n-\n     public static byte[] transform(byte[] bytecode, int targetVersion, MethodRelocations methodRelocations) {\n         ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n         ClassVisitor next = writer;\n@@ -22,154 +17,9 @@ public class LambdaClassBackporter {\n         } else if (FeatureToggles.DEFAULT_METHODS == 2) {\n             next = new ApplyMethodRelocations(next, methodRelocations);\n         }\n-        next = new LambdaClassVisitor(next);\n+        next = new BackportLambdaClass(next);\n         next = new LowerBytecodeVersion(next, targetVersion);\n         new ClassReader(bytecode).accept(next, 0);\n         return writer.toByteArray();\n     }\n-\n-    private static class LambdaClassVisitor extends ClassVisitor {\n-        private String lambdaClass;\n-        private Type constructor;\n-        private Handle implMethod;\n-        private Handle bridgeMethod;\n-        private LambdaFactoryMethod factoryMethod;\n-\n-        public LambdaClassVisitor(ClassVisitor next) {\n-            super(ASM5, next);\n-        }\n-\n-        @Override\n-        public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n-            lambdaClass = name;\n-            LambdaReifier.setLambdaClass(lambdaClass);\n-            implMethod = LambdaReifier.getLambdaImplMethod();\n-            bridgeMethod = LambdaReifier.getLambdaBridgeMethod();\n-            factoryMethod = LambdaReifier.getLambdaFactoryMethod();\n-\n-            if (superName.equals(LambdaNaming.MAGIC_LAMBDA_IMPL)) {\n-                superName = JAVA_LANG_OBJECT;\n-            }\n-            super.visit(version, access, name, signature, superName, interfaces);\n-        }\n-\n-        @Override\n-        public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n-            if (name.equals(\"<init>\")) {\n-                constructor = Type.getMethodType(desc);\n-            }\n-            MethodVisitor next = super.visitMethod(access, name, desc, signature, exceptions);\n-            next = new MagicLambdaRemovingMethodVisitor(next);\n-            next = new PrivateMethodInvocationFixingMethodVisitor(next, this);\n-            return next;\n-        }\n-\n-        @Override\n-        public void visitEnd() {\n-            if (isStateless()) {\n-                makeSingleton();\n-            }\n-            generateFactoryMethod();\n-            super.visitEnd();\n-        }\n-\n-        private void makeSingleton() {\n-            FieldVisitor fv = super.visitField(ACC_PRIVATE | ACC_STATIC | ACC_FINAL,\n-                    SINGLETON_FIELD_NAME, singletonFieldDesc(), null, null);\n-            fv.visitEnd();\n-\n-            MethodVisitor mv = super.visitMethod(ACC_STATIC, \"<clinit>\", \"()V\", null, null);\n-            mv.visitCode();\n-            mv.visitTypeInsn(NEW, lambdaClass);\n-            mv.visitInsn(DUP);\n-            mv.visitMethodInsn(INVOKESPECIAL, lambdaClass, \"<init>\", \"()V\", false);\n-            mv.visitFieldInsn(PUTSTATIC, lambdaClass, SINGLETON_FIELD_NAME, singletonFieldDesc());\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(-1, -1); // rely on ClassWriter.COMPUTE_MAXS\n-            mv.visitEnd();\n-        }\n-\n-        private void generateFactoryMethod() {\n-            MethodVisitor mv = cv.visitMethod(ACC_PUBLIC | ACC_STATIC,\n-                    factoryMethod.getName(), factoryMethod.getDesc(), null, null);\n-            mv.visitCode();\n-\n-            if (isStateless()) {\n-                mv.visitFieldInsn(GETSTATIC, lambdaClass, SINGLETON_FIELD_NAME, singletonFieldDesc());\n-                mv.visitInsn(ARETURN);\n-\n-            } else {\n-                mv.visitTypeInsn(NEW, lambdaClass);\n-                mv.visitInsn(DUP);\n-                int varIndex = 0;\n-                for (Type type : constructor.getArgumentTypes()) {\n-                    mv.visitVarInsn(type.getOpcode(ILOAD), varIndex);\n-                    varIndex += type.getSize();\n-                }\n-                mv.visitMethodInsn(INVOKESPECIAL, lambdaClass, \"<init>\", constructor.getDescriptor(), false);\n-                mv.visitInsn(ARETURN);\n-            }\n-\n-            mv.visitMaxs(-1, -1); // rely on ClassWriter.COMPUTE_MAXS\n-            mv.visitEnd();\n-        }\n-\n-        private String singletonFieldDesc() {\n-            return \"L\" + lambdaClass + \";\";\n-        }\n-\n-        private boolean isStateless() {\n-            return constructor.getArgumentTypes().length == 0;\n-        }\n-    }\n-\n-    private static class MagicLambdaRemovingMethodVisitor extends MethodVisitor {\n-\n-        public MagicLambdaRemovingMethodVisitor(MethodVisitor next) {\n-            super(ASM5, next);\n-        }\n-\n-        @Override\n-        public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\n-            if (opcode == INVOKESPECIAL\n-                    && owner.equals(LambdaNaming.MAGIC_LAMBDA_IMPL)\n-                    && name.equals(\"<init>\")\n-                    && desc.equals(\"()V\")) {\n-                owner = JAVA_LANG_OBJECT;\n-            }\n-            super.visitMethodInsn(opcode, owner, name, desc, itf);\n-        }\n-    }\n-\n-    private static class PrivateMethodInvocationFixingMethodVisitor extends MethodVisitor {\n-\n-        private final Handle implMethod;\n-        private final Handle bridgeMethod;\n-\n-        public PrivateMethodInvocationFixingMethodVisitor(MethodVisitor next, LambdaClassVisitor context) {\n-            super(ASM5, next);\n-            this.implMethod = context.implMethod;\n-            this.bridgeMethod = context.bridgeMethod;\n-        }\n-\n-        @Override\n-        public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\n-            // Java 8's lambda classes get away with calling private virtual methods\n-            // by using invokespecial because the JVM relaxes the bytecode validation\n-            // of the lambda classes it generates. We must however call them through\n-            // a non-private bridge method which we have generated.\n-            if (owner.equals(implMethod.getOwner())\n-                    && name.equals(implMethod.getName())\n-                    && desc.equals(implMethod.getDesc())) {\n-                super.visitMethodInsn(\n-                        Handles.getOpcode(bridgeMethod),\n-                        bridgeMethod.getOwner(),\n-                        bridgeMethod.getName(),\n-                        bridgeMethod.getDesc(),\n-                        bridgeMethod.getTag() == H_INVOKEINTERFACE);\n-            } else {\n-                super.visitMethodInsn(opcode, owner, name, desc, itf);\n-            }\n-        }\n-    }\n }\n"
    },
    {
        "commit_hash": "7aec89a28410bf3f981069eb3d89fad4354000a0",
        "previous_commit_hash": "a1681b9bf9a6dd380e2d04b1a067f7f6c5d9813e",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -8,9 +8,9 @@ import org.objectweb.asm.*;\n \n import static org.objectweb.asm.Opcodes.*;\n \n-public class InvokeStaticInterfaceMethodConverter extends ClassVisitor {\n+public class FixInvokeStaticOnInterfaceMethod extends ClassVisitor {\n \n-    public InvokeStaticInterfaceMethodConverter(ClassVisitor next) {\n+    public FixInvokeStaticOnInterfaceMethod(ClassVisitor next) {\n         super(ASM5, next);\n     }\n \n"
    },
    {
        "commit_hash": "7aec89a28410bf3f981069eb3d89fad4354000a0",
        "previous_commit_hash": "a1681b9bf9a6dd380e2d04b1a067f7f6c5d9813e",
        "diff_stats": {
            "additions": 0,
            "deletions": 32
        },
        "diff_content": "@@ -1,32 +0,0 @@\n-// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n-// This software is released under the Apache License 2.0.\n-// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n-\n-package net.orfjackal.retrolambda;\n-\n-import org.objectweb.asm.*;\n-\n-public class InterfaceCompanionBackporter {\n-\n-    public static byte[] transform(ClassReader reader, int targetVersion, MethodRelocations methodRelocations) {\n-        String companion;\n-        if (FeatureToggles.DEFAULT_METHODS == 2\n-                && isInterface(reader)\n-                && (companion = methodRelocations.getCompanionClass(reader.getClassName())) != null) {\n-            ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n-            ClassVisitor next = writer;\n-            next = new ApplyMethodRelocations(next, methodRelocations);\n-            next = new ExtractInterfaceCompanionClass(next, companion);\n-            next = new InvokeStaticInterfaceMethodConverter(next);\n-            next = new LowerBytecodeVersion(next, targetVersion);\n-            reader.accept(next, 0);\n-            return writer.toByteArray();\n-        } else {\n-            return null;\n-        }\n-    }\n-\n-    private static boolean isInterface(ClassReader reader) {\n-        return Flags.hasFlag(reader.getAccess(), Opcodes.ACC_INTERFACE);\n-    }\n-}\n"
    },
    {
        "commit_hash": "7aec89a28410bf3f981069eb3d89fad4354000a0",
        "previous_commit_hash": "a1681b9bf9a6dd380e2d04b1a067f7f6c5d9813e",
        "diff_stats": {
            "additions": 0,
            "deletions": 25
        },
        "diff_content": "@@ -1,25 +0,0 @@\n-// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n-// This software is released under the Apache License 2.0.\n-// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n-\n-package net.orfjackal.retrolambda;\n-\n-import net.orfjackal.retrolambda.defaultmethods.ClassModifier;\n-import org.objectweb.asm.*;\n-\n-public class LambdaClassBackporter {\n-\n-    public static byte[] transform(byte[] bytecode, int targetVersion, MethodRelocations methodRelocations) {\n-        ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n-        ClassVisitor next = writer;\n-        if (FeatureToggles.DEFAULT_METHODS == 1) {\n-            next = new ClassModifier(targetVersion, next);\n-        } else if (FeatureToggles.DEFAULT_METHODS == 2) {\n-            next = new ApplyMethodRelocations(next, methodRelocations);\n-        }\n-        next = new BackportLambdaClass(next);\n-        next = new LowerBytecodeVersion(next, targetVersion);\n-        new ClassReader(bytecode).accept(next, 0);\n-        return writer.toByteArray();\n-    }\n-}\n"
    },
    {
        "commit_hash": "7aec89a28410bf3f981069eb3d89fad4354000a0",
        "previous_commit_hash": "a1681b9bf9a6dd380e2d04b1a067f7f6c5d9813e",
        "diff_stats": {
            "additions": 6,
            "deletions": 10
        },
        "diff_content": "@@ -4,20 +4,16 @@\n \n package net.orfjackal.retrolambda;\n \n+import org.objectweb.asm.ClassReader;\n+\n public class LambdaClassSaver {\n \n     private final ClassSaver saver;\n-    private final int bytecodeVersion;\n-    private MethodRelocations methodRelocations;\n+    private final Transformers transformers;\n \n-    public LambdaClassSaver(ClassSaver saver, int bytecodeVersion, MethodRelocations methodRelocations) {\n+    public LambdaClassSaver(ClassSaver saver, Transformers transformers) {\n         this.saver = saver;\n-        this.bytecodeVersion = bytecodeVersion;\n-        this.methodRelocations = methodRelocations;\n-    }\n-\n-    public void setMethodRelocations(MethodRelocations methodRelocations) {\n-        this.methodRelocations = methodRelocations;\n+        this.transformers = transformers;\n     }\n \n     public void saveIfLambda(String className, byte[] bytecode) {\n@@ -29,7 +25,7 @@ public class LambdaClassSaver {\n     private void reifyLambdaClass(String className, byte[] bytecode) {\n         try {\n             System.out.println(\"Saving lambda class: \" + className);\n-            saver.save(LambdaClassBackporter.transform(bytecode, bytecodeVersion, methodRelocations));\n+            saver.save(transformers.backportLambdaClass(new ClassReader(bytecode)));\n \n         } catch (Throwable t) {\n             // print to stdout to keep in sync with other log output\n"
    },
    {
        "commit_hash": "7aec89a28410bf3f981069eb3d89fad4354000a0",
        "previous_commit_hash": "a1681b9bf9a6dd380e2d04b1a067f7f6c5d9813e",
        "diff_stats": {
            "additions": 6,
            "deletions": 4
        },
        "diff_content": "@@ -9,11 +9,11 @@ import org.objectweb.asm.ClassReader;\n import java.lang.instrument.*;\n import java.security.ProtectionDomain;\n \n-public class LambdaSavingClassFileTransformer implements ClassFileTransformer {\n+public class LambdaClassSaverAgent implements ClassFileTransformer {\n \n-    private final LambdaClassSaver lambdaClassSaver;\n+    private LambdaClassSaver lambdaClassSaver;\n \n-    public LambdaSavingClassFileTransformer(LambdaClassSaver lambdaClassSaver) {\n+    public void setLambdaClassSaver(LambdaClassSaver lambdaClassSaver) {\n         this.lambdaClassSaver = lambdaClassSaver;\n     }\n \n@@ -24,7 +24,9 @@ public class LambdaSavingClassFileTransformer implements ClassFileTransformer {\n             // but we can read it from the bytecode where the name still exists.\n             className = new ClassReader(classfileBuffer).getClassName();\n         }\n-        lambdaClassSaver.saveIfLambda(className, classfileBuffer);\n+        if (lambdaClassSaver != null) {\n+            lambdaClassSaver.saveIfLambda(className, classfileBuffer);\n+        }\n         return null;\n     }\n }\n"
    },
    {
        "commit_hash": "7aec89a28410bf3f981069eb3d89fad4354000a0",
        "previous_commit_hash": "a1681b9bf9a6dd380e2d04b1a067f7f6c5d9813e",
        "diff_stats": {
            "additions": 0,
            "deletions": 39
        },
        "diff_content": "@@ -1,39 +0,0 @@\n-// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n-// This software is released under the Apache License 2.0.\n-// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n-\n-package net.orfjackal.retrolambda;\n-\n-import net.orfjackal.retrolambda.defaultmethods.*;\n-import org.objectweb.asm.*;\n-\n-import static org.objectweb.asm.Opcodes.ACC_INTERFACE;\n-\n-public class LambdaUsageBackporter {\n-\n-    public static byte[] transform(ClassReader reader, int targetVersion, MethodRelocations methodRelocations) {\n-        ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n-        ClassVisitor next = writer;\n-        if (FeatureToggles.DEFAULT_METHODS == 1) {\n-            next = new ClassModifier(targetVersion, next);\n-            next = new InterfaceModifier(next, targetVersion);\n-        } else if (FeatureToggles.DEFAULT_METHODS == 2) {\n-            if (isInterface(reader)) {\n-                next = new RemoveStaticMethods(next);\n-                next = new RemoveDefaultMethodBodies(next);\n-            }\n-            next = new ApplyMethodRelocations(next, methodRelocations);\n-            next = new InvokeStaticInterfaceMethodConverter(next);\n-        } else {\n-            next = new InvokeStaticInterfaceMethodConverter(next);\n-        }\n-        next = new BackportLambdaInvocations(next);\n-        next = new LowerBytecodeVersion(next, targetVersion);\n-        reader.accept(next, 0);\n-        return writer.toByteArray();\n-    }\n-\n-    private static boolean isInterface(ClassReader reader) {\n-        return Flags.hasFlag(reader.getAccess(), ACC_INTERFACE);\n-    }\n-}\n"
    },
    {
        "commit_hash": "7aec89a28410bf3f981069eb3d89fad4354000a0",
        "previous_commit_hash": "a1681b9bf9a6dd380e2d04b1a067f7f6c5d9813e",
        "diff_stats": {
            "additions": 4,
            "deletions": 10
        },
        "diff_content": "@@ -5,20 +5,14 @@\n package net.orfjackal.retrolambda;\n \n import java.lang.instrument.Instrumentation;\n-import java.nio.file.Path;\n \n public class PreMain {\n \n+    private static final LambdaClassSaverAgent agent = new LambdaClassSaverAgent();\n     private static boolean agentLoaded = false;\n-    private static LambdaClassSaver lambdaClassSaver;\n \n     public static void premain(String agentArgs, Instrumentation inst) {\n-        Config config = new Config(System.getProperties());\n-        int bytecodeVersion = config.getBytecodeVersion();\n-        Path outputDir = config.getOutputDir();\n-        ClassSaver saver = new ClassSaver(outputDir);\n-        lambdaClassSaver = new LambdaClassSaver(saver, bytecodeVersion, null); // MethodRelocations will be set by main\n-        inst.addTransformer(new LambdaSavingClassFileTransformer(lambdaClassSaver));\n+        inst.addTransformer(agent);\n         agentLoaded = true;\n     }\n \n@@ -26,7 +20,7 @@ public class PreMain {\n         return agentLoaded;\n     }\n \n-    public static void setMethodRelocations(MethodRelocations methodRelocations) {\n-        lambdaClassSaver.setMethodRelocations(methodRelocations);\n+    public static void setLambdaClassSaver(LambdaClassSaver lambdaClassSaver) {\n+        agent.setLambdaClassSaver(lambdaClassSaver);\n     }\n }\n"
    },
    {
        "commit_hash": "7aec89a28410bf3f981069eb3d89fad4354000a0",
        "previous_commit_hash": "a1681b9bf9a6dd380e2d04b1a067f7f6c5d9813e",
        "diff_stats": {
            "additions": 8,
            "deletions": 5
        },
        "diff_content": "@@ -41,9 +41,12 @@ public class Retrolambda {\n \n         ClassHierarchyAnalyzer analyzer = new ClassHierarchyAnalyzer();\n         ClassSaver saver = new ClassSaver(outputDir);\n-        try (LambdaClassDumper dumper = new LambdaClassDumper(new LambdaClassSaver(saver, bytecodeVersion, analyzer))) {\n+        Transformers transformers = new Transformers(bytecodeVersion, analyzer);\n+        LambdaClassSaver lambdaClassSaver = new LambdaClassSaver(saver, transformers);\n+\n+        try (LambdaClassDumper dumper = new LambdaClassDumper(lambdaClassSaver)) {\n             if (PreMain.isAgentLoaded()) {\n-                PreMain.setMethodRelocations(analyzer);\n+                PreMain.setLambdaClassSaver(lambdaClassSaver);\n             } else {\n                 dumper.install();\n             }\n@@ -57,11 +60,11 @@ public class Retrolambda {\n \n             List<byte[]> transformed = new ArrayList<>();\n             for (ClassReader reader : analyzer.getInterfaces()) {\n-                transformed.add(InterfaceCompanionBackporter.transform(reader, bytecodeVersion, analyzer));\n-                transformed.add(LambdaUsageBackporter.transform(reader, bytecodeVersion, analyzer)); // TODO: extract InterfaceBackporter\n+                transformed.add(transformers.extractInterfaceCompanion(reader));\n+                transformed.add(transformers.backportInterface(reader));\n             }\n             for (ClassReader reader : analyzer.getClasses()) {\n-                transformed.add(LambdaUsageBackporter.transform(reader, bytecodeVersion, analyzer)); // TODO: extract ClassBackporter\n+                transformed.add(transformers.backportClass(reader));\n             }\n \n             // We need to load some of the classes (for calling the lambda metafactory)\n"
    },
    {
        "commit_hash": "7aec89a28410bf3f981069eb3d89fad4354000a0",
        "previous_commit_hash": "a1681b9bf9a6dd380e2d04b1a067f7f6c5d9813e",
        "diff_stats": {
            "additions": 89,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,89 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda;\n+\n+import net.orfjackal.retrolambda.defaultmethods.*;\n+import org.objectweb.asm.*;\n+\n+public class Transformers {\n+\n+    private final int targetVersion;\n+    private final MethodRelocations methodRelocations;\n+\n+    public Transformers(int targetVersion, MethodRelocations methodRelocations) {\n+        this.targetVersion = targetVersion;\n+        this.methodRelocations = methodRelocations;\n+    }\n+\n+    public byte[] backportLambdaClass(ClassReader reader) {\n+        return transform(reader, (next) -> {\n+            if (FeatureToggles.DEFAULT_METHODS == 1) {\n+                next = new ClassModifier(targetVersion, next);\n+            } else if (FeatureToggles.DEFAULT_METHODS == 2) {\n+                next = new UpdateRelocatedMethodInvocations(next, methodRelocations);\n+            }\n+            next = new BackportLambdaClass(next);\n+            return next;\n+        });\n+    }\n+\n+    public byte[] backportClass(ClassReader reader) {\n+        return transform(reader, (next) -> {\n+            if (FeatureToggles.DEFAULT_METHODS == 1) {\n+                next = new ClassModifier(targetVersion, next);\n+                next = new InterfaceModifier(next, targetVersion);\n+            } else if (FeatureToggles.DEFAULT_METHODS == 2) {\n+                next = new UpdateRelocatedMethodInvocations(next, methodRelocations);\n+            }\n+            next = new BackportLambdaInvocations(next);\n+            return next;\n+        });\n+    }\n+\n+    public byte[] backportInterface(ClassReader reader) {\n+        return transform(reader, (next) -> {\n+            if (FeatureToggles.DEFAULT_METHODS == 1) {\n+                next = new ClassModifier(targetVersion, next);\n+                next = new InterfaceModifier(next, targetVersion);\n+            } else if (FeatureToggles.DEFAULT_METHODS == 2) {\n+                next = new RemoveStaticMethods(next);\n+                next = new RemoveDefaultMethodBodies(next);\n+                next = new UpdateRelocatedMethodInvocations(next, methodRelocations);\n+            }\n+            next = new BackportLambdaInvocations(next);\n+            return next;\n+        });\n+    }\n+\n+    public byte[] extractInterfaceCompanion(ClassReader reader) {\n+        String companion;\n+        if (FeatureToggles.DEFAULT_METHODS == 2\n+                && (companion = methodRelocations.getCompanionClass(reader.getClassName())) != null) {\n+            return transform(reader, (next) -> {\n+                next = new UpdateRelocatedMethodInvocations(next, methodRelocations);\n+                next = new ExtractInterfaceCompanionClass(next, companion);\n+                return next;\n+            });\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    private byte[] transform(ClassReader reader, ClassVisitorChain chain) {\n+        ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n+        ClassVisitor next = writer;\n+\n+        next = new LowerBytecodeVersion(next, targetVersion);\n+        next = new FixInvokeStaticOnInterfaceMethod(next);\n+        next = chain.wrap(next);\n+\n+        reader.accept(next, 0);\n+        return writer.toByteArray();\n+    }\n+\n+    private interface ClassVisitorChain {\n+        ClassVisitor wrap(ClassVisitor next);\n+    }\n+}\n"
    },
    {
        "commit_hash": "7aec89a28410bf3f981069eb3d89fad4354000a0",
        "previous_commit_hash": "a1681b9bf9a6dd380e2d04b1a067f7f6c5d9813e",
        "diff_stats": {
            "additions": 5,
            "deletions": 5
        },
        "diff_content": "@@ -9,11 +9,11 @@ import org.objectweb.asm.*;\n \n import static org.objectweb.asm.Opcodes.ASM5;\n \n-public class ApplyMethodRelocations extends ClassVisitor {\n+public class UpdateRelocatedMethodInvocations extends ClassVisitor {\n \n     private final MethodRelocations methodRelocations;\n \n-    public ApplyMethodRelocations(ClassVisitor next, MethodRelocations methodRelocations) {\n+    public UpdateRelocatedMethodInvocations(ClassVisitor next, MethodRelocations methodRelocations) {\n         super(ASM5, next);\n         this.methodRelocations = methodRelocations;\n         Preconditions.checkNotNull(methodRelocations);\n@@ -26,12 +26,12 @@ public class ApplyMethodRelocations extends ClassVisitor {\n \n     @Override\n     public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n-        return new ApplyRenamesMethodVisitor(super.visitMethod(access, name, desc, signature, exceptions));\n+        return new UpdateMethodCalls(super.visitMethod(access, name, desc, signature, exceptions));\n     }\n \n-    private class ApplyRenamesMethodVisitor extends MethodVisitor {\n+    private class UpdateMethodCalls extends MethodVisitor {\n \n-        public ApplyRenamesMethodVisitor(MethodVisitor next) {\n+        public UpdateMethodCalls(MethodVisitor next) {\n             super(Opcodes.ASM5, next);\n         }\n \n"
    },
    {
        "commit_hash": "ee81282019acd9e4b2a210d05d063bd8122721dc",
        "previous_commit_hash": "7aec89a28410bf3f981069eb3d89fad4354000a0",
        "diff_stats": {
            "additions": 2,
            "deletions": 0
        },
        "diff_content": "@@ -4,6 +4,8 @@\n \n package net.orfjackal.retrolambda;\n \n+import net.orfjackal.retrolambda.lambdas.*;\n+\n import java.lang.instrument.Instrumentation;\n \n public class PreMain {\n"
    },
    {
        "commit_hash": "ee81282019acd9e4b2a210d05d063bd8122721dc",
        "previous_commit_hash": "7aec89a28410bf3f981069eb3d89fad4354000a0",
        "diff_stats": {
            "additions": 3,
            "deletions": 0
        },
        "diff_content": "@@ -5,6 +5,9 @@\n package net.orfjackal.retrolambda;\n \n import net.orfjackal.retrolambda.defaultmethods.Helpers;\n+import net.orfjackal.retrolambda.files.*;\n+import net.orfjackal.retrolambda.interfaces.ClassHierarchyAnalyzer;\n+import net.orfjackal.retrolambda.lambdas.*;\n import org.objectweb.asm.ClassReader;\n \n import java.io.IOException;\n"
    },
    {
        "commit_hash": "ee81282019acd9e4b2a210d05d063bd8122721dc",
        "previous_commit_hash": "7aec89a28410bf3f981069eb3d89fad4354000a0",
        "diff_stats": {
            "additions": 2,
            "deletions": 0
        },
        "diff_content": "@@ -5,6 +5,8 @@\n package net.orfjackal.retrolambda;\n \n import net.orfjackal.retrolambda.defaultmethods.*;\n+import net.orfjackal.retrolambda.interfaces.*;\n+import net.orfjackal.retrolambda.lambdas.*;\n import org.objectweb.asm.*;\n \n public class Transformers {\n"
    },
    {
        "commit_hash": "ee81282019acd9e4b2a210d05d063bd8122721dc",
        "previous_commit_hash": "7aec89a28410bf3f981069eb3d89fad4354000a0",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -2,7 +2,7 @@\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n-package net.orfjackal.retrolambda;\n+package net.orfjackal.retrolambda.files;\n \n import java.io.IOException;\n import java.nio.file.*;\n"
    },
    {
        "commit_hash": "ee81282019acd9e4b2a210d05d063bd8122721dc",
        "previous_commit_hash": "7aec89a28410bf3f981069eb3d89fad4354000a0",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -2,7 +2,7 @@\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n-package net.orfjackal.retrolambda;\n+package net.orfjackal.retrolambda.files;\n \n import org.objectweb.asm.ClassReader;\n \n"
    },
    {
        "commit_hash": "ee81282019acd9e4b2a210d05d063bd8122721dc",
        "previous_commit_hash": "7aec89a28410bf3f981069eb3d89fad4354000a0",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -2,7 +2,7 @@\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n-package net.orfjackal.retrolambda;\n+package net.orfjackal.retrolambda.files;\n \n import java.io.IOException;\n import java.nio.file.*;\n"
    },
    {
        "commit_hash": "ee81282019acd9e4b2a210d05d063bd8122721dc",
        "previous_commit_hash": "7aec89a28410bf3f981069eb3d89fad4354000a0",
        "diff_stats": {
            "additions": 2,
            "deletions": 1
        },
        "diff_content": "@@ -2,8 +2,9 @@\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n-package net.orfjackal.retrolambda;\n+package net.orfjackal.retrolambda.interfaces;\n \n+import net.orfjackal.retrolambda.Flags;\n import org.objectweb.asm.*;\n \n import java.util.*;\n"
    },
    {
        "commit_hash": "ee81282019acd9e4b2a210d05d063bd8122721dc",
        "previous_commit_hash": "7aec89a28410bf3f981069eb3d89fad4354000a0",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -2,7 +2,7 @@\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n-package net.orfjackal.retrolambda;\n+package net.orfjackal.retrolambda.interfaces;\n \n import org.objectweb.asm.ClassVisitor;\n \n"
    },
    {
        "commit_hash": "ee81282019acd9e4b2a210d05d063bd8122721dc",
        "previous_commit_hash": "7aec89a28410bf3f981069eb3d89fad4354000a0",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -2,7 +2,7 @@\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n-package net.orfjackal.retrolambda;\n+package net.orfjackal.retrolambda.interfaces;\n \n import org.objectweb.asm.*;\n \n"
    },
    {
        "commit_hash": "ee81282019acd9e4b2a210d05d063bd8122721dc",
        "previous_commit_hash": "7aec89a28410bf3f981069eb3d89fad4354000a0",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -2,7 +2,7 @@\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n-package net.orfjackal.retrolambda;\n+package net.orfjackal.retrolambda.interfaces;\n \n import com.google.common.base.Objects;\n import org.objectweb.asm.Type;\n"
    },
    {
        "commit_hash": "ee81282019acd9e4b2a210d05d063bd8122721dc",
        "previous_commit_hash": "7aec89a28410bf3f981069eb3d89fad4354000a0",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -2,7 +2,7 @@\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n-package net.orfjackal.retrolambda;\n+package net.orfjackal.retrolambda.interfaces;\n \n public interface MethodRelocations {\n \n"
    },
    {
        "commit_hash": "ee81282019acd9e4b2a210d05d063bd8122721dc",
        "previous_commit_hash": "7aec89a28410bf3f981069eb3d89fad4354000a0",
        "diff_stats": {
            "additions": 2,
            "deletions": 1
        },
        "diff_content": "@@ -2,8 +2,9 @@\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n-package net.orfjackal.retrolambda;\n+package net.orfjackal.retrolambda.interfaces;\n \n+import net.orfjackal.retrolambda.Flags;\n import org.objectweb.asm.*;\n import org.objectweb.asm.tree.MethodNode;\n \n"
    },
    {
        "commit_hash": "ee81282019acd9e4b2a210d05d063bd8122721dc",
        "previous_commit_hash": "7aec89a28410bf3f981069eb3d89fad4354000a0",
        "diff_stats": {
            "additions": 2,
            "deletions": 1
        },
        "diff_content": "@@ -2,8 +2,9 @@\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n-package net.orfjackal.retrolambda;\n+package net.orfjackal.retrolambda.interfaces;\n \n+import net.orfjackal.retrolambda.Flags;\n import org.objectweb.asm.*;\n \n import static org.objectweb.asm.Opcodes.*;\n"
    },
    {
        "commit_hash": "ee81282019acd9e4b2a210d05d063bd8122721dc",
        "previous_commit_hash": "7aec89a28410bf3f981069eb3d89fad4354000a0",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -2,7 +2,7 @@\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n-package net.orfjackal.retrolambda;\n+package net.orfjackal.retrolambda.interfaces;\n \n import com.google.common.base.Preconditions;\n import org.objectweb.asm.*;\n"
    },
    {
        "commit_hash": "ee81282019acd9e4b2a210d05d063bd8122721dc",
        "previous_commit_hash": "7aec89a28410bf3f981069eb3d89fad4354000a0",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -2,7 +2,7 @@\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n-package net.orfjackal.retrolambda;\n+package net.orfjackal.retrolambda.lambdas;\n \n import org.objectweb.asm.*;\n \n"
    },
    {
        "commit_hash": "ee81282019acd9e4b2a210d05d063bd8122721dc",
        "previous_commit_hash": "7aec89a28410bf3f981069eb3d89fad4354000a0",
        "diff_stats": {
            "additions": 2,
            "deletions": 1
        },
        "diff_content": "@@ -2,8 +2,9 @@\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n-package net.orfjackal.retrolambda;\n+package net.orfjackal.retrolambda.lambdas;\n \n+import net.orfjackal.retrolambda.*;\n import org.objectweb.asm.*;\n \n import java.lang.reflect.Field;\n"
    },
    {
        "commit_hash": "ee81282019acd9e4b2a210d05d063bd8122721dc",
        "previous_commit_hash": "7aec89a28410bf3f981069eb3d89fad4354000a0",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -2,7 +2,7 @@\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n-package net.orfjackal.retrolambda;\n+package net.orfjackal.retrolambda.lambdas;\n \n import org.objectweb.asm.Handle;\n \n"
    },
    {
        "commit_hash": "ee81282019acd9e4b2a210d05d063bd8122721dc",
        "previous_commit_hash": "7aec89a28410bf3f981069eb3d89fad4354000a0",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -2,7 +2,7 @@\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n-package net.orfjackal.retrolambda;\n+package net.orfjackal.retrolambda.lambdas;\n \n import net.orfjackal.retrolambda.fs.*;\n \n"
    },
    {
        "commit_hash": "ee81282019acd9e4b2a210d05d063bd8122721dc",
        "previous_commit_hash": "7aec89a28410bf3f981069eb3d89fad4354000a0",
        "diff_stats": {
            "additions": 3,
            "deletions": 1
        },
        "diff_content": "@@ -2,8 +2,10 @@\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n-package net.orfjackal.retrolambda;\n+package net.orfjackal.retrolambda.lambdas;\n \n+import net.orfjackal.retrolambda.Transformers;\n+import net.orfjackal.retrolambda.files.ClassSaver;\n import org.objectweb.asm.ClassReader;\n \n public class LambdaClassSaver {\n"
    },
    {
        "commit_hash": "ee81282019acd9e4b2a210d05d063bd8122721dc",
        "previous_commit_hash": "7aec89a28410bf3f981069eb3d89fad4354000a0",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -2,7 +2,7 @@\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n-package net.orfjackal.retrolambda;\n+package net.orfjackal.retrolambda.lambdas;\n \n import org.objectweb.asm.ClassReader;\n \n"
    },
    {
        "commit_hash": "ee81282019acd9e4b2a210d05d063bd8122721dc",
        "previous_commit_hash": "7aec89a28410bf3f981069eb3d89fad4354000a0",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -2,7 +2,7 @@\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n-package net.orfjackal.retrolambda;\n+package net.orfjackal.retrolambda.lambdas;\n \n import org.objectweb.asm.Type;\n \n"
    },
    {
        "commit_hash": "ee81282019acd9e4b2a210d05d063bd8122721dc",
        "previous_commit_hash": "7aec89a28410bf3f981069eb3d89fad4354000a0",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -2,7 +2,7 @@\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n-package net.orfjackal.retrolambda;\n+package net.orfjackal.retrolambda.lambdas;\n \n import java.util.regex.Pattern;\n \n"
    },
    {
        "commit_hash": "ee81282019acd9e4b2a210d05d063bd8122721dc",
        "previous_commit_hash": "7aec89a28410bf3f981069eb3d89fad4354000a0",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -2,7 +2,7 @@\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n-package net.orfjackal.retrolambda;\n+package net.orfjackal.retrolambda.lambdas;\n \n import org.objectweb.asm.*;\n \n"
    },
    {
        "commit_hash": "ee81282019acd9e4b2a210d05d063bd8122721dc",
        "previous_commit_hash": "7aec89a28410bf3f981069eb3d89fad4354000a0",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -2,7 +2,7 @@\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n-package net.orfjackal.retrolambda;\n+package net.orfjackal.retrolambda.lambdas;\n \n import org.objectweb.asm.*;\n \n"
    },
    {
        "commit_hash": "ee81282019acd9e4b2a210d05d063bd8122721dc",
        "previous_commit_hash": "7aec89a28410bf3f981069eb3d89fad4354000a0",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -5,6 +5,7 @@\n package net.orfjackal.retrolambda;\n \n import com.google.common.io.ByteStreams;\n+import net.orfjackal.retrolambda.interfaces.*;\n import org.junit.Test;\n import org.objectweb.asm.*;\n \n"
    },
    {
        "commit_hash": "de81131de13bb062fde0cdb9a729be696c5be26f",
        "previous_commit_hash": "ee81282019acd9e4b2a210d05d063bd8122721dc",
        "diff_stats": {
            "additions": 5,
            "deletions": 0
        },
        "diff_content": "@@ -5,6 +5,11 @@ DESCRIPTION=\"$1\"\n VERSION=\"$2\"\n set -x\n \n+mvn nexus-staging:deploy-staged-repository \\\n+    --errors \\\n+    -DrepositoryDirectory=staging \\\n+    -DstagingDescription=\"$DESCRIPTION\"\n+\n mvn nexus-staging:release \\\n     --errors \\\n     -DaltStagingDirectory=staging \\\n"
    },
    {
        "commit_hash": "de81131de13bb062fde0cdb9a729be696c5be26f",
        "previous_commit_hash": "ee81282019acd9e4b2a210d05d063bd8122721dc",
        "diff_stats": {
            "additions": 0,
            "deletions": 5
        },
        "diff_content": "@@ -33,8 +33,3 @@ mvn clean deploy \\\n     --errors \\\n     -P sonatype-oss-release \\\n     -DaltDeploymentRepository=\"staging::default::file:staging\"\n-\n-mvn nexus-staging:deploy-staged-repository \\\n-    --errors \\\n-    -DrepositoryDirectory=staging \\\n-    -DstagingDescription=\"$DESCRIPTION\"\n"
    },
    {
        "commit_hash": "0059e934c53103cce66083cdc9278ead5eb5284c",
        "previous_commit_hash": "de81131de13bb062fde0cdb9a729be696c5be26f",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -12,6 +12,7 @@\n             <list>\n               <option value=\"clean\" />\n               <option value=\"verify\" />\n+              <option value=\"-e\" />\n             </list>\n           </option>\n           <option name=\"profilesMap\">\n"
    },
    {
        "commit_hash": "0059e934c53103cce66083cdc9278ead5eb5284c",
        "previous_commit_hash": "de81131de13bb062fde0cdb9a729be696c5be26f",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -22,6 +22,7 @@\n             <list>\n               <option value=\"clean\" />\n               <option value=\"verify\" />\n+              <option value=\"-e\" />\n             </list>\n           </option>\n           <option name=\"profilesMap\">\n"
    },
    {
        "commit_hash": "281ef936f969633268ff91947a44b46ee7381351",
        "previous_commit_hash": "0059e934c53103cce66083cdc9278ead5eb5284c",
        "diff_stats": {
            "additions": 20,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,20 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package java.lang;\n+\n+import net.orfjackal.retrolambda.test.ClasspathTest;\n+\n+/**\n+ * @see ClasspathTest#ignores_classes_in_explicit_classpath_that_are_under_the_java_package\n+ */\n+@SuppressWarnings(\"UnusedDeclaration\")\n+public class Math {\n+\n+    public Math() {\n+        // some lambdas to cause Retrolambda try backporting this class\n+        Runnable r = () -> {\n+        };\n+    }\n+}\n"
    },
    {
        "commit_hash": "281ef936f969633268ff91947a44b46ee7381351",
        "previous_commit_hash": "0059e934c53103cce66083cdc9278ead5eb5284c",
        "diff_stats": {
            "additions": 11,
            "deletions": 0
        },
        "diff_content": "@@ -57,4 +57,15 @@ public class ClasspathTest {\n     public void prefers_classes_in_explicit_classpath_over_classes_in_the_JRE() {\n         assertNotNull(getClass().getResource(\"/com/sun/javafx/application/LauncherImpl$$Lambda$1.class\"));\n     }\n+\n+    /**\n+     * Classes in the {@code java.*} packages can be loaded only by the bootstrap\n+     * class loader, so we must not try to load them with our custom class loader.\n+     * This situation arises when backporting Android applications, because android.jar\n+     * contains {@code java.*} classes.\n+     */\n+    @Test\n+    public void ignores_classes_in_explicit_classpath_that_are_under_the_java_package() {\n+        assertNotNull(getClass().getResource(\"/java/lang/Math.class\"));\n+    }\n }\n"
    },
    {
        "commit_hash": "281ef936f969633268ff91947a44b46ee7381351",
        "previous_commit_hash": "0059e934c53103cce66083cdc9278ead5eb5284c",
        "diff_stats": {
            "additions": 6,
            "deletions": 1
        },
        "diff_content": "@@ -23,7 +23,12 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n \n     public void analyze(byte[] bytecode) {\n         ClassReader cr = new ClassReader(bytecode);\n-        Type clazz = classNameToType(cr.getClassName());\n+        String className = cr.getClassName();\n+        if (className.startsWith(\"java/\")) {\n+            // the JVM disallows user classes in java.* packages, so don't even try backporting them\n+            return;\n+        }\n+        Type clazz = classNameToType(className);\n \n         if (Flags.hasFlag(cr.getAccess(), ACC_INTERFACE)) {\n             interfaces.add(cr);\n"
    },
    {
        "commit_hash": "f969cc292050a6b92b1bdc596b7fec136d4d036c",
        "previous_commit_hash": "281ef936f969633268ff91947a44b46ee7381351",
        "diff_stats": {
            "additions": 9,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,9 @@\n+<component name=\"libraryTable\">\n+  <library name=\"Maven: net.orfjackal.retrolambda:java-lang-dummies:1\">\n+    <CLASSES>\n+      <root url=\"jar://$PROJECT_DIR$/end-to-end-tests/src/test/lib/java-lang-dummies.jar!/\" />\n+    </CLASSES>\n+    <JAVADOC />\n+    <SOURCES />\n+  </library>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "f969cc292050a6b92b1bdc596b7fec136d4d036c",
        "previous_commit_hash": "281ef936f969633268ff91947a44b46ee7381351",
        "diff_stats": {
            "additions": 2,
            "deletions": 0
        },
        "diff_content": "@@ -147,6 +147,8 @@ Version History\n \n - Backports static methods on interfaces\n   ([Issue #31](https://github.com/orfjackal/retrolambda/issues/31))\n+- Fixed a crash when trying backport Android classes\n+  ([Issue #34](https://github.com/orfjackal/retrolambda/issues/34))\n \n ### Retrolambda 1.6.1 (2014-08-25)\n \n"
    },
    {
        "commit_hash": "f969cc292050a6b92b1bdc596b7fec136d4d036c",
        "previous_commit_hash": "281ef936f969633268ff91947a44b46ee7381351",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -13,6 +13,7 @@\n     <orderEntry type=\"library\" name=\"Maven: com.google.guava:guava:11.0.2\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: com.google.code.findbugs:jsr305:1.3.9\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: commons-lang:commons-lang:2.6\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: net.orfjackal.retrolambda:java-lang-dummies:1\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.11\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-library:1.3\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-core:1.3\" level=\"project\" />\n"
    },
    {
        "commit_hash": "f969cc292050a6b92b1bdc596b7fec136d4d036c",
        "previous_commit_hash": "281ef936f969633268ff91947a44b46ee7381351",
        "diff_stats": {
            "additions": 9,
            "deletions": 0
        },
        "diff_content": "@@ -28,6 +28,15 @@\n             <scope>test</scope>\n         </dependency>\n \n+        <!-- See net.orfjackal.retrolambda.test.ClasspathTest#ignores_classes_in_explicit_classpath_that_are_under_the_java_package -->\n+        <dependency>\n+            <groupId>net.orfjackal.retrolambda</groupId>\n+            <artifactId>java-lang-dummies</artifactId>\n+            <version>1</version>\n+            <scope>system</scope>\n+            <systemPath>${basedir}/src/test/lib/java-lang-dummies.jar</systemPath>\n+        </dependency>\n+\n     </dependencies>\n \n     <build>\n"
    },
    {
        "commit_hash": "f969cc292050a6b92b1bdc596b7fec136d4d036c",
        "previous_commit_hash": "281ef936f969633268ff91947a44b46ee7381351",
        "diff_stats": {
            "additions": 0,
            "deletions": 20
        },
        "diff_content": "@@ -1,20 +0,0 @@\n-// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n-// This software is released under the Apache License 2.0.\n-// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n-\n-package java.lang;\n-\n-import net.orfjackal.retrolambda.test.ClasspathTest;\n-\n-/**\n- * @see ClasspathTest#ignores_classes_in_explicit_classpath_that_are_under_the_java_package\n- */\n-@SuppressWarnings(\"UnusedDeclaration\")\n-public class Math {\n-\n-    public Math() {\n-        // some lambdas to cause Retrolambda try backporting this class\n-        Runnable r = () -> {\n-        };\n-    }\n-}\n"
    },
    {
        "commit_hash": "f969cc292050a6b92b1bdc596b7fec136d4d036c",
        "previous_commit_hash": "281ef936f969633268ff91947a44b46ee7381351",
        "diff_stats": {
            "additions": 10,
            "deletions": 4
        },
        "diff_content": "@@ -7,10 +7,12 @@ package net.orfjackal.retrolambda.test;\n import org.hamcrest.*;\n import org.junit.Test;\n \n-import java.util.Arrays;\n+import java.io.IOException;\n+import java.net.URL;\n+import java.util.*;\n \n import static org.hamcrest.MatcherAssert.assertThat;\n-import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.*;\n import static org.junit.Assert.assertNotNull;\n \n public class ClasspathTest {\n@@ -65,7 +67,11 @@ public class ClasspathTest {\n      * contains {@code java.*} classes.\n      */\n     @Test\n-    public void ignores_classes_in_explicit_classpath_that_are_under_the_java_package() {\n-        assertNotNull(getClass().getResource(\"/java/lang/Math.class\"));\n+    public void ignores_classes_in_explicit_classpath_that_are_under_the_java_package() throws IOException {\n+        // We have a JAR on the classpath that contains dummy version of java.lang.Object,\n+        // the same way as android.jar, which causes Retrolambda to try loading that class\n+        // because the classes to be backported extend it implicitly.\n+        List<URL> resources = Collections.list(getClass().getClassLoader().getResources(\"java/lang/Object.class\"));\n+        assertThat(resources, (Matcher) hasItem(hasToString(containsString(\"java-lang-dummies.jar\"))));\n     }\n }\n"
    },
    {
        "commit_hash": "f969cc292050a6b92b1bdc596b7fec136d4d036c",
        "previous_commit_hash": "281ef936f969633268ff91947a44b46ee7381351",
        "diff_stats": {
            "additions": 0,
            "deletions": 0
        },
        "diff_content": "Binary files /dev/null and b/end-to-end-tests/src/test/lib/java-lang-dummies.jar differ\n"
    },
    {
        "commit_hash": "f969cc292050a6b92b1bdc596b7fec136d4d036c",
        "previous_commit_hash": "281ef936f969633268ff91947a44b46ee7381351",
        "diff_stats": {
            "additions": 3,
            "deletions": 0
        },
        "diff_content": "@@ -14,6 +14,9 @@ public class NonDelegatingClassLoader extends URLClassLoader {\n \n     @Override\n     public Class<?> loadClass(String name) throws ClassNotFoundException {\n+        if (name.startsWith(\"java.\")) { // the java.* classes can only be loaded by the bootstrap class loader\n+            return super.loadClass(name);\n+        }\n         Class<?> c = findLoadedClass(name);\n         if (c != null) {\n             return c;\n"
    },
    {
        "commit_hash": "f969cc292050a6b92b1bdc596b7fec136d4d036c",
        "previous_commit_hash": "281ef936f969633268ff91947a44b46ee7381351",
        "diff_stats": {
            "additions": 1,
            "deletions": 6
        },
        "diff_content": "@@ -23,12 +23,7 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n \n     public void analyze(byte[] bytecode) {\n         ClassReader cr = new ClassReader(bytecode);\n-        String className = cr.getClassName();\n-        if (className.startsWith(\"java/\")) {\n-            // the JVM disallows user classes in java.* packages, so don't even try backporting them\n-            return;\n-        }\n-        Type clazz = classNameToType(className);\n+        Type clazz = classNameToType(cr.getClassName());\n \n         if (Flags.hasFlag(cr.getAccess(), ACC_INTERFACE)) {\n             interfaces.add(cr);\n"
    },
    {
        "commit_hash": "1e0ddae9a64347229e0127c74d561dd3252d23d4",
        "previous_commit_hash": "f969cc292050a6b92b1bdc596b7fec136d4d036c",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>1.6.2-SNAPSHOT</version>\n+    <version>1.6.3-SNAPSHOT</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n@@ -370,7 +370,7 @@\n                 <plugin>\n                     <groupId>org.sonatype.plugins</groupId>\n                     <artifactId>nexus-staging-maven-plugin</artifactId>\n-                    <version>1.5.1</version>\n+                    <version>1.6.4</version>\n                     <configuration>\n                         <nexusUrl>https://oss.sonatype.org/</nexusUrl>\n                         <serverId>ossrh-releases-net.orfjackal</serverId>\n"
    },
    {
        "commit_hash": "fdd4185874c4163164100a46f2e438b8d89a562c",
        "previous_commit_hash": "1e0ddae9a64347229e0127c74d561dd3252d23d4",
        "diff_stats": {
            "additions": 4,
            "deletions": 1
        },
        "diff_content": "@@ -85,7 +85,7 @@ To run Retrolambda using Maven, add the following to your pom.xml:\n <plugin>\n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>retrolambda-maven-plugin</artifactId>\n-    <version>1.6.1</version>\n+    <version>1.6.2</version>\n     <executions>\n         <execution>\n             <goals>\n@@ -147,6 +147,9 @@ Version History\n \n - Backports static methods on interfaces\n   ([Issue #31](https://github.com/orfjackal/retrolambda/issues/31))\n+\n+### Retrolambda 1.6.2 (2014-10-03)\n+\n - Fixed a crash when trying backport Android classes\n   ([Issue #34](https://github.com/orfjackal/retrolambda/issues/34))\n \n"
    },
    {
        "commit_hash": "fdd4185874c4163164100a46f2e438b8d89a562c",
        "previous_commit_hash": "1e0ddae9a64347229e0127c74d561dd3252d23d4",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.6.2-SNAPSHOT</version>\n+        <version>1.6.2</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "fdd4185874c4163164100a46f2e438b8d89a562c",
        "previous_commit_hash": "1e0ddae9a64347229e0127c74d561dd3252d23d4",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>1.6.3-SNAPSHOT</version>\n+    <version>1.6.2</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "fdd4185874c4163164100a46f2e438b8d89a562c",
        "previous_commit_hash": "1e0ddae9a64347229e0127c74d561dd3252d23d4",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.6.2-SNAPSHOT</version>\n+        <version>1.6.2</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "fdd4185874c4163164100a46f2e438b8d89a562c",
        "previous_commit_hash": "1e0ddae9a64347229e0127c74d561dd3252d23d4",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.6.2-SNAPSHOT</version>\n+        <version>1.6.2</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "fdd4185874c4163164100a46f2e438b8d89a562c",
        "previous_commit_hash": "1e0ddae9a64347229e0127c74d561dd3252d23d4",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.6.2-SNAPSHOT</version>\n+        <version>1.6.2</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "94104faa276eaafde41c57a6bf4f962bf214a0b5",
        "previous_commit_hash": "fdd4185874c4163164100a46f2e438b8d89a562c",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.6.2</version>\n+        <version>1.6.3-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "94104faa276eaafde41c57a6bf4f962bf214a0b5",
        "previous_commit_hash": "fdd4185874c4163164100a46f2e438b8d89a562c",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>1.6.2</version>\n+    <version>1.6.3-SNAPSHOT</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "94104faa276eaafde41c57a6bf4f962bf214a0b5",
        "previous_commit_hash": "fdd4185874c4163164100a46f2e438b8d89a562c",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.6.2</version>\n+        <version>1.6.3-SNAPSHOT</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "94104faa276eaafde41c57a6bf4f962bf214a0b5",
        "previous_commit_hash": "fdd4185874c4163164100a46f2e438b8d89a562c",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.6.2</version>\n+        <version>1.6.3-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "94104faa276eaafde41c57a6bf4f962bf214a0b5",
        "previous_commit_hash": "fdd4185874c4163164100a46f2e438b8d89a562c",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.6.2</version>\n+        <version>1.6.3-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "2277cc1e45bd49fedebadde2e7cbec12c68c202f",
        "previous_commit_hash": "94104faa276eaafde41c57a6bf4f962bf214a0b5",
        "diff_stats": {
            "additions": 3,
            "deletions": 0
        },
        "diff_content": "@@ -10,9 +10,12 @@ mvn nexus-staging:deploy-staged-repository \\\n     -DrepositoryDirectory=staging \\\n     -DstagingDescription=\"$DESCRIPTION\"\n \n+REPOSITORY_ID=`sed -n -r 's/stagingRepository\\.id=(\\w+)/\\1/p' staging/*.properties`\n+\n mvn nexus-staging:release \\\n     --errors \\\n     -DaltStagingDirectory=staging \\\n+    -DstagingRepositoryId=\"$REPOSITORY_ID\" \\\n     -DstagingDescription=\"$DESCRIPTION\"\n \n git push origin HEAD\n"
    },
    {
        "commit_hash": "d136f083ed7c121e7e4abddb4dfdd7c538780960",
        "previous_commit_hash": "2277cc1e45bd49fedebadde2e7cbec12c68c202f",
        "diff_stats": {
            "additions": 2,
            "deletions": 6
        },
        "diff_content": "@@ -128,12 +128,6 @@ Does not backport Java 8 APIs.\n \n Does not backport Java 8 language features other than lambda expressions.\n \n-Does not support serializable lambda expressions. Implementing support for\n-them would technically be possible, but it would require projects to have a\n-runtime dependency on a library which would contain a backported copy of\n-the `java.lang.invoke.SerializedLambda` class. If you really need it, make\n-a feature request. ;-)\n-\n May break if a future JDK 8 build stops generating a new class for each\n `invokedynamic` call. Retrolambda works so that it captures the bytecode\n that `java.lang.invoke.LambdaMetafactory` generates dynamically, so\n@@ -147,6 +141,8 @@ Version History\n \n - Backports static methods on interfaces\n   ([Issue #31](https://github.com/orfjackal/retrolambda/issues/31))\n+- Support for serializable lambdas\n+  ([Issue #35](https://github.com/orfjackal/retrolambda/issues/35))\n \n ### Retrolambda 1.6.2 (2014-10-03)\n \n"
    },
    {
        "commit_hash": "d136f083ed7c121e7e4abddb4dfdd7c538780960",
        "previous_commit_hash": "2277cc1e45bd49fedebadde2e7cbec12c68c202f",
        "diff_stats": {
            "additions": 64,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,64 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.test;\n+\n+import org.junit.Test;\n+\n+import java.io.*;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+\n+public class SerializableLambdaTest {\n+\n+    @Test\n+    public void serializable_interface() throws Exception {\n+        SerializableFoo original = (i) -> i + 10;\n+\n+        SerializableFoo serialized = roundTripSerialize(original);\n+\n+        assertThat(serialized.foo(4), is(14));\n+    }\n+\n+    @Test\n+    public void cast_expression_with_serializable_additional_bound() throws Exception {\n+        Foo original = (Foo & Serializable) (i) -> i + 20;\n+\n+        Foo serialized = roundTripSerialize(original);\n+\n+        assertThat(serialized.foo(4), is(24));\n+    }\n+\n+    @Test\n+    public void captured_local_variables() throws Exception {\n+        int var = 30;\n+        SerializableFoo original = (i) -> i + var;\n+\n+        SerializableFoo serialized = roundTripSerialize(original);\n+\n+        assertThat(serialized.foo(4), is(34));\n+    }\n+\n+\n+    // guinea pigs & helpers\n+\n+    public interface Foo {\n+        int foo(int i);\n+    }\n+\n+    public interface SerializableFoo extends Foo, Serializable {\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static <T> T roundTripSerialize(T original) throws Exception {\n+        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+        try (ObjectOutputStream out = new ObjectOutputStream(buffer)) {\n+            out.writeObject(original);\n+        }\n+        try (ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()))) {\n+            return (T) in.readObject();\n+        }\n+    }\n+}\n"
    },
    {
        "commit_hash": "d136f083ed7c121e7e4abddb4dfdd7c538780960",
        "previous_commit_hash": "2277cc1e45bd49fedebadde2e7cbec12c68c202f",
        "diff_stats": {
            "additions": 3,
            "deletions": 0
        },
        "diff_content": "@@ -42,6 +42,9 @@ public class BackportLambdaClass extends ClassVisitor {\n         if (name.equals(\"<init>\")) {\n             constructor = Type.getMethodType(desc);\n         }\n+        if (LambdaNaming.isSerializationHook(access, name, desc)) {\n+            return null; // remove serialization hooks; we serialize lambda instances as-is\n+        }\n         MethodVisitor next = super.visitMethod(access, name, desc, signature, exceptions);\n         next = new RemoveMagicLambdaConstructorCall(next);\n         next = new BridgePrivateMethodInvocations(next);\n"
    },
    {
        "commit_hash": "d136f083ed7c121e7e4abddb4dfdd7c538780960",
        "previous_commit_hash": "2277cc1e45bd49fedebadde2e7cbec12c68c202f",
        "diff_stats": {
            "additions": 3,
            "deletions": 0
        },
        "diff_content": "@@ -51,6 +51,9 @@ public class BackportLambdaInvocations extends ClassVisitor {\n         if (isBridgeMethodOnInterface(access)) {\n             return null; // remove the bridge method; Java 7 didn't use them\n         }\n+        if (LambdaNaming.isDeserializationHook(access, name, desc)) {\n+            return null; // remove serialization hooks; we serialize lambda instances as-is\n+        }\n         if (FeatureToggles.DEFAULT_METHODS == 0\n                 && isNonAbstractMethodOnInterface(access)\n                 && !isClassInitializerMethod(name, desc, access)) {\n"
    },
    {
        "commit_hash": "d136f083ed7c121e7e4abddb4dfdd7c538780960",
        "previous_commit_hash": "2277cc1e45bd49fedebadde2e7cbec12c68c202f",
        "diff_stats": {
            "additions": 16,
            "deletions": 0
        },
        "diff_content": "@@ -4,8 +4,12 @@\n \n package net.orfjackal.retrolambda.lambdas;\n \n+import net.orfjackal.retrolambda.Flags;\n+\n import java.util.regex.Pattern;\n \n+import static org.objectweb.asm.Opcodes.*;\n+\n public class LambdaNaming {\n \n     public static final String LAMBDA_METAFACTORY = \"java/lang/invoke/LambdaMetafactory\";\n@@ -15,4 +19,16 @@ public class LambdaNaming {\n      * Java 8 produces at runtime classes named {@code EnclosingClass$$Lambda$1}\n      */\n     public static final Pattern LAMBDA_CLASS = Pattern.compile(\"^.+\\\\$\\\\$Lambda\\\\$\\\\d+$\");\n+\n+    public static boolean isSerializationHook(int access, String name, String desc) {\n+        return name.equals(\"writeReplace\")\n+                && desc.equals(\"()Ljava/lang/Object;\")\n+                && Flags.hasFlag(access, ACC_PRIVATE);\n+    }\n+\n+    public static boolean isDeserializationHook(int access, String name, String desc) {\n+        return name.equals(\"$deserializeLambda$\")\n+                && desc.equals(\"(Ljava/lang/invoke/SerializedLambda;)Ljava/lang/Object;\")\n+                && Flags.hasFlag(access, ACC_PRIVATE | ACC_STATIC | ACC_SYNTHETIC);\n+    }\n }\n"
    },
    {
        "commit_hash": "aaa13668a1089811bf2897e6ce12fc24f88c8701",
        "previous_commit_hash": "d136f083ed7c121e7e4abddb4dfdd7c538780960",
        "diff_stats": {
            "additions": 4,
            "deletions": 4
        },
        "diff_content": "@@ -1,13 +1,13 @@\n <component name=\"libraryTable\">\n-  <library name=\"Maven: com.google.guava:guava:17.0\">\n+  <library name=\"Maven: com.google.guava:guava:18.0\">\n     <CLASSES>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/com/google/guava/guava/17.0/guava-17.0.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/com/google/guava/guava/18.0/guava-18.0.jar!/\" />\n     </CLASSES>\n     <JAVADOC>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/com/google/guava/guava/17.0/guava-17.0-javadoc.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/com/google/guava/guava/18.0/guava-18.0-javadoc.jar!/\" />\n     </JAVADOC>\n     <SOURCES>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/com/google/guava/guava/17.0/guava-17.0-sources.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/com/google/guava/guava/18.0/guava-18.0-sources.jar!/\" />\n     </SOURCES>\n   </library>\n </component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "aaa13668a1089811bf2897e6ce12fc24f88c8701",
        "previous_commit_hash": "d136f083ed7c121e7e4abddb4dfdd7c538780960",
        "diff_stats": {
            "additions": 0,
            "deletions": 13
        },
        "diff_content": "@@ -1,13 +0,0 @@\n-<component name=\"libraryTable\">\n-  <library name=\"Maven: junit:junit:4.11\">\n-    <CLASSES>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/junit/junit/4.11/junit-4.11.jar!/\" />\n-    </CLASSES>\n-    <JAVADOC>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/junit/junit/4.11/junit-4.11-javadoc.jar!/\" />\n-    </JAVADOC>\n-    <SOURCES>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/junit/junit/4.11/junit-4.11-sources.jar!/\" />\n-    </SOURCES>\n-  </library>\n-</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "aaa13668a1089811bf2897e6ce12fc24f88c8701",
        "previous_commit_hash": "d136f083ed7c121e7e4abddb4dfdd7c538780960",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,13 @@\n+<component name=\"libraryTable\">\n+  <library name=\"Maven: junit:junit:4.12-beta-2\">\n+    <CLASSES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/junit/junit/4.12-beta-2/junit-4.12-beta-2.jar!/\" />\n+    </CLASSES>\n+    <JAVADOC>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/junit/junit/4.12-beta-2/junit-4.12-beta-2-javadoc.jar!/\" />\n+    </JAVADOC>\n+    <SOURCES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/junit/junit/4.12-beta-2/junit-4.12-beta-2-sources.jar!/\" />\n+    </SOURCES>\n+  </library>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "aaa13668a1089811bf2897e6ce12fc24f88c8701",
        "previous_commit_hash": "d136f083ed7c121e7e4abddb4dfdd7c538780960",
        "diff_stats": {
            "additions": 4,
            "deletions": 4
        },
        "diff_content": "@@ -1,13 +1,13 @@\n <component name=\"libraryTable\">\n-  <library name=\"Maven: org.mockito:mockito-core:1.9.5\">\n+  <library name=\"Maven: org.mockito:mockito-core:1.10.8\">\n     <CLASSES>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/mockito/mockito-core/1.9.5/mockito-core-1.9.5.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/mockito/mockito-core/1.10.8/mockito-core-1.10.8.jar!/\" />\n     </CLASSES>\n     <JAVADOC>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/mockito/mockito-core/1.9.5/mockito-core-1.9.5-javadoc.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/mockito/mockito-core/1.10.8/mockito-core-1.10.8-javadoc.jar!/\" />\n     </JAVADOC>\n     <SOURCES>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/mockito/mockito-core/1.9.5/mockito-core-1.9.5-sources.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/mockito/mockito-core/1.10.8/mockito-core-1.10.8-sources.jar!/\" />\n     </SOURCES>\n   </library>\n </component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "aaa13668a1089811bf2897e6ce12fc24f88c8701",
        "previous_commit_hash": "d136f083ed7c121e7e4abddb4dfdd7c538780960",
        "diff_stats": {
            "additions": 4,
            "deletions": 4
        },
        "diff_content": "@@ -1,13 +1,13 @@\n <component name=\"libraryTable\">\n-  <library name=\"Maven: org.objenesis:objenesis:1.0\">\n+  <library name=\"Maven: org.objenesis:objenesis:2.1\">\n     <CLASSES>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/objenesis/objenesis/1.0/objenesis-1.0.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/objenesis/objenesis/2.1/objenesis-2.1.jar!/\" />\n     </CLASSES>\n     <JAVADOC>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/objenesis/objenesis/1.0/objenesis-1.0-javadoc.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/objenesis/objenesis/2.1/objenesis-2.1-javadoc.jar!/\" />\n     </JAVADOC>\n     <SOURCES>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/objenesis/objenesis/1.0/objenesis-1.0-sources.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/objenesis/objenesis/2.1/objenesis-2.1-sources.jar!/\" />\n     </SOURCES>\n   </library>\n </component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "aaa13668a1089811bf2897e6ce12fc24f88c8701",
        "previous_commit_hash": "d136f083ed7c121e7e4abddb4dfdd7c538780960",
        "diff_stats": {
            "additions": 4,
            "deletions": 4
        },
        "diff_content": "@@ -1,13 +1,13 @@\n <component name=\"libraryTable\">\n-  <library name=\"Maven: org.ow2.asm:asm-debug-all:5.0.2\">\n+  <library name=\"Maven: org.ow2.asm:asm-debug-all:5.0.3\">\n     <CLASSES>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm-debug-all/5.0.2/asm-debug-all-5.0.2.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm-debug-all/5.0.3/asm-debug-all-5.0.3.jar!/\" />\n     </CLASSES>\n     <JAVADOC>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm-debug-all/5.0.2/asm-debug-all-5.0.2-javadoc.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm-debug-all/5.0.3/asm-debug-all-5.0.3-javadoc.jar!/\" />\n     </JAVADOC>\n     <SOURCES>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm-debug-all/5.0.2/asm-debug-all-5.0.2-sources.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm-debug-all/5.0.3/asm-debug-all-5.0.3-sources.jar!/\" />\n     </SOURCES>\n   </library>\n </component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "aaa13668a1089811bf2897e6ce12fc24f88c8701",
        "previous_commit_hash": "d136f083ed7c121e7e4abddb4dfdd7c538780960",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -14,11 +14,11 @@\n     <orderEntry type=\"library\" name=\"Maven: com.google.code.findbugs:jsr305:1.3.9\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: commons-lang:commons-lang:2.6\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: net.orfjackal.retrolambda:java-lang-dummies:1\" level=\"project\" />\n-    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.11\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.12-beta-2\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-library:1.3\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-core:1.3\" level=\"project\" />\n-    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.mockito:mockito-core:1.9.5\" level=\"project\" />\n-    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.objenesis:objenesis:1.0\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.mockito:mockito-core:1.10.8\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.objenesis:objenesis:2.1\" level=\"project\" />\n   </component>\n </module>\n \n"
    },
    {
        "commit_hash": "aaa13668a1089811bf2897e6ce12fc24f88c8701",
        "previous_commit_hash": "d136f083ed7c121e7e4abddb4dfdd7c538780960",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -9,11 +9,11 @@\n     </content>\n     <orderEntry type=\"inheritedJdk\" />\n     <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n-    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.11\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.12-beta-2\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-library:1.3\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-core:1.3\" level=\"project\" />\n-    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.mockito:mockito-core:1.9.5\" level=\"project\" />\n-    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.objenesis:objenesis:1.0\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.mockito:mockito-core:1.10.8\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.objenesis:objenesis:2.1\" level=\"project\" />\n   </component>\n </module>\n \n"
    },
    {
        "commit_hash": "aaa13668a1089811bf2897e6ce12fc24f88c8701",
        "previous_commit_hash": "d136f083ed7c121e7e4abddb4dfdd7c538780960",
        "diff_stats": {
            "additions": 5,
            "deletions": 5
        },
        "diff_content": "@@ -84,7 +84,7 @@\n             <dependency>\n                 <groupId>org.ow2.asm</groupId>\n                 <artifactId>asm-debug-all</artifactId>\n-                <version>5.0.2</version>\n+                <version>5.0.3</version>\n             </dependency>\n \n             <!-- Testing -->\n@@ -92,7 +92,7 @@\n             <dependency>\n                 <groupId>junit</groupId>\n                 <artifactId>junit</artifactId>\n-                <version>4.11</version>\n+                <version>4.12-beta-2</version>\n                 <exclusions>\n                     <!-- Avoid diverging hamcrest-library and hamcrest-core versions -->\n                     <exclusion>\n@@ -111,7 +111,7 @@\n             <dependency>\n                 <groupId>org.mockito</groupId>\n                 <artifactId>mockito-core</artifactId>\n-                <version>1.9.5</version>\n+                <version>1.10.8</version>\n             </dependency>\n \n             <!-- Utils -->\n@@ -119,7 +119,7 @@\n             <dependency>\n                 <groupId>com.google.guava</groupId>\n                 <artifactId>guava</artifactId>\n-                <version>17.0</version>\n+                <version>18.0</version>\n             </dependency>\n \n             <dependency>\n@@ -370,7 +370,7 @@\n                 <plugin>\n                     <groupId>org.sonatype.plugins</groupId>\n                     <artifactId>nexus-staging-maven-plugin</artifactId>\n-                    <version>1.6.4</version>\n+                    <version>1.6.5</version>\n                     <configuration>\n                         <nexusUrl>https://oss.sonatype.org/</nexusUrl>\n                         <serverId>ossrh-releases-net.orfjackal</serverId>\n"
    },
    {
        "commit_hash": "aaa13668a1089811bf2897e6ce12fc24f88c8701",
        "previous_commit_hash": "d136f083ed7c121e7e4abddb4dfdd7c538780960",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -9,11 +9,11 @@\n     </content>\n     <orderEntry type=\"inheritedJdk\" />\n     <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n-    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.11\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.12-beta-2\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-library:1.3\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-core:1.3\" level=\"project\" />\n-    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.mockito:mockito-core:1.9.5\" level=\"project\" />\n-    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.objenesis:objenesis:1.0\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.mockito:mockito-core:1.10.8\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.objenesis:objenesis:2.1\" level=\"project\" />\n   </component>\n </module>\n \n"
    },
    {
        "commit_hash": "aaa13668a1089811bf2897e6ce12fc24f88c8701",
        "previous_commit_hash": "d136f083ed7c121e7e4abddb4dfdd7c538780960",
        "diff_stats": {
            "additions": 5,
            "deletions": 5
        },
        "diff_content": "@@ -18,8 +18,8 @@\n     <orderEntry type=\"inheritedJdk\" />\n     <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n     <orderEntry type=\"module\" module-name=\"retrolambda\" />\n-    <orderEntry type=\"library\" name=\"Maven: org.ow2.asm:asm-debug-all:5.0.2\" level=\"project\" />\n-    <orderEntry type=\"library\" name=\"Maven: com.google.guava:guava:17.0\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.ow2.asm:asm-debug-all:5.0.3\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: com.google.guava:guava:18.0\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-plugin-api:2.0\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"PROVIDED\" name=\"Maven: org.apache.maven.plugin-tools:maven-plugin-annotations:3.2\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-artifact:3.0\" level=\"project\" />\n@@ -44,11 +44,11 @@\n     <orderEntry type=\"library\" name=\"Maven: org.codehaus.plexus:plexus-classworlds:2.2.3\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.sonatype.sisu:sisu-inject-bean:1.4.2\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.sonatype.sisu:sisu-guice:noaop:2.1.7\" level=\"project\" />\n-    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.11\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.12-beta-2\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-library:1.3\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-core:1.3\" level=\"project\" />\n-    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.mockito:mockito-core:1.9.5\" level=\"project\" />\n-    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.objenesis:objenesis:1.0\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.mockito:mockito-core:1.10.8\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.objenesis:objenesis:2.1\" level=\"project\" />\n   </component>\n </module>\n \n"
    },
    {
        "commit_hash": "aaa13668a1089811bf2897e6ce12fc24f88c8701",
        "previous_commit_hash": "d136f083ed7c121e7e4abddb4dfdd7c538780960",
        "diff_stats": {
            "additions": 5,
            "deletions": 5
        },
        "diff_content": "@@ -10,13 +10,13 @@\n     </content>\n     <orderEntry type=\"inheritedJdk\" />\n     <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n-    <orderEntry type=\"library\" name=\"Maven: org.ow2.asm:asm-debug-all:5.0.2\" level=\"project\" />\n-    <orderEntry type=\"library\" name=\"Maven: com.google.guava:guava:17.0\" level=\"project\" />\n-    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.11\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.ow2.asm:asm-debug-all:5.0.3\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: com.google.guava:guava:18.0\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.12-beta-2\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-library:1.3\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-core:1.3\" level=\"project\" />\n-    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.mockito:mockito-core:1.9.5\" level=\"project\" />\n-    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.objenesis:objenesis:1.0\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.mockito:mockito-core:1.10.8\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.objenesis:objenesis:2.1\" level=\"project\" />\n   </component>\n </module>\n \n"
    },
    {
        "commit_hash": "98468853e6a2a80e544a6553326ef366d22a766f",
        "previous_commit_hash": "aaa13668a1089811bf2897e6ce12fc24f88c8701",
        "diff_stats": {
            "additions": 2,
            "deletions": 4
        },
        "diff_content": "@@ -10,12 +10,10 @@ mvn nexus-staging:deploy-staged-repository \\\n     -DrepositoryDirectory=staging \\\n     -DstagingDescription=\"$DESCRIPTION\"\n \n-REPOSITORY_ID=`sed -n -r 's/stagingRepository\\.id=(\\w+)/\\1/p' staging/*.properties`\n-\n+# assumes 'staging/*.properties' under altStagingDirectory\n mvn nexus-staging:release \\\n     --errors \\\n-    -DaltStagingDirectory=staging \\\n-    -DstagingRepositoryId=\"$REPOSITORY_ID\" \\\n+    -DaltStagingDirectory=. \\\n     -DstagingDescription=\"$DESCRIPTION\"\n \n git push origin HEAD\n"
    },
    {
        "commit_hash": "2c2001b5ec1856be887b2357008cf6d2637763df",
        "previous_commit_hash": "98468853e6a2a80e544a6553326ef366d22a766f",
        "diff_stats": {
            "additions": 4,
            "deletions": 1
        },
        "diff_content": "@@ -85,7 +85,7 @@ To run Retrolambda using Maven, add the following to your pom.xml:\n <plugin>\n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>retrolambda-maven-plugin</artifactId>\n-    <version>1.6.2</version>\n+    <version>1.7.0</version>\n     <executions>\n         <execution>\n             <goals>\n@@ -141,6 +141,9 @@ Version History\n \n - Backports static methods on interfaces\n   ([Issue #31](https://github.com/orfjackal/retrolambda/issues/31))\n+\n+### Retrolambda 1.7.0 (2014-10-21)\n+\n - Support for serializable lambdas\n   ([Issue #35](https://github.com/orfjackal/retrolambda/issues/35))\n \n"
    },
    {
        "commit_hash": "2c2001b5ec1856be887b2357008cf6d2637763df",
        "previous_commit_hash": "98468853e6a2a80e544a6553326ef366d22a766f",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.6.3-SNAPSHOT</version>\n+        <version>1.7.0</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "2c2001b5ec1856be887b2357008cf6d2637763df",
        "previous_commit_hash": "98468853e6a2a80e544a6553326ef366d22a766f",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>1.6.3-SNAPSHOT</version>\n+    <version>1.7.0</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "2c2001b5ec1856be887b2357008cf6d2637763df",
        "previous_commit_hash": "98468853e6a2a80e544a6553326ef366d22a766f",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.6.3-SNAPSHOT</version>\n+        <version>1.7.0</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "2c2001b5ec1856be887b2357008cf6d2637763df",
        "previous_commit_hash": "98468853e6a2a80e544a6553326ef366d22a766f",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.6.3-SNAPSHOT</version>\n+        <version>1.7.0</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "2c2001b5ec1856be887b2357008cf6d2637763df",
        "previous_commit_hash": "98468853e6a2a80e544a6553326ef366d22a766f",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.6.3-SNAPSHOT</version>\n+        <version>1.7.0</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "bbd9cdec8fbc8a402c8750c2b1ee08c7a3d13d8b",
        "previous_commit_hash": "2c2001b5ec1856be887b2357008cf6d2637763df",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.7.0</version>\n+        <version>1.7.1-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "bbd9cdec8fbc8a402c8750c2b1ee08c7a3d13d8b",
        "previous_commit_hash": "2c2001b5ec1856be887b2357008cf6d2637763df",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>1.7.0</version>\n+    <version>1.7.1-SNAPSHOT</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "bbd9cdec8fbc8a402c8750c2b1ee08c7a3d13d8b",
        "previous_commit_hash": "2c2001b5ec1856be887b2357008cf6d2637763df",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.7.0</version>\n+        <version>1.7.1-SNAPSHOT</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "bbd9cdec8fbc8a402c8750c2b1ee08c7a3d13d8b",
        "previous_commit_hash": "2c2001b5ec1856be887b2357008cf6d2637763df",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.7.0</version>\n+        <version>1.7.1-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "bbd9cdec8fbc8a402c8750c2b1ee08c7a3d13d8b",
        "previous_commit_hash": "2c2001b5ec1856be887b2357008cf6d2637763df",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.7.0</version>\n+        <version>1.7.1-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "cf7214bb80e06f4231a38d00644f53a0d726ae4d",
        "previous_commit_hash": "bbd9cdec8fbc8a402c8750c2b1ee08c7a3d13d8b",
        "diff_stats": {
            "additions": 5,
            "deletions": 5
        },
        "diff_content": "@@ -4,10 +4,10 @@ Retrolambda: Use Lambdas on Java 7\n \n Just as there was [Retroweaver](http://retroweaver.sourceforge.net/) et al.\n for running Java 5 code with generics on Java 1.4, **Retrolambda** lets you\n-run Java 8 code with lambda expressions on Java 7 or lower. It does this by\n-transforming your Java 8 compiled bytecode so that it can run on a Java 7\n-runtime. After the transformation they are just a bunch of normal .class\n-files, without adding any runtime dependencies.\n+run Java 8 code with lambda expressions and method references on Java 7 or\n+lower. It does this by transforming your Java 8 compiled bytecode so that\n+it can run on a Java 7 runtime. After the transformation they are just a\n+bunch of normal .class files, without adding any runtime dependencies.\n \n Adventurous developers may use Retrolambda to backport lambda expressions\n even to Java 6 or Java 5. And if you reach Java 5, there are [other\n@@ -247,5 +247,5 @@ Version History\n \n ### Retrolambda 1.0.0 (2013-07-23)\n \n-- Backports lambda expressions and method handles to Java 7 and older\n+- Backports lambda expressions and method references to Java 7 and older\n - Tested to work with JDK 8 Early Access Build b99 (2013-07-19)\n"
    },
    {
        "commit_hash": "97fc3a53587486024bced5ea12370c3824e0c33c",
        "previous_commit_hash": "cf7214bb80e06f4231a38d00644f53a0d726ae4d",
        "diff_stats": {
            "additions": 2,
            "deletions": 0
        },
        "diff_content": "@@ -141,6 +141,8 @@ Version History\n \n - Backports static methods on interfaces\n   ([Issue #31](https://github.com/orfjackal/retrolambda/issues/31))\n+  - *Experimental! Can be enabled with the enviroment variable\n+    DEFAULT_METHODS=2*\n \n ### Retrolambda 1.7.0 (2014-10-21)\n \n"
    },
    {
        "commit_hash": "cb5b8c282101f3439d167ce13a015b34c4796b09",
        "previous_commit_hash": "97fc3a53587486024bced5ea12370c3824e0c33c",
        "diff_stats": {
            "additions": 2,
            "deletions": 0
        },
        "diff_content": "@@ -2,6 +2,8 @@\n Retrolambda: Use Lambdas on Java 7\n ==================================\n \n+[![Retrolambda presentation video](resources/presentation-preview.png)](https://www.youtube.com/watch?v=DUdhfPh9V_s)\n+\n Just as there was [Retroweaver](http://retroweaver.sourceforge.net/) et al.\n for running Java 5 code with generics on Java 1.4, **Retrolambda** lets you\n run Java 8 code with lambda expressions and method references on Java 7 or\n"
    },
    {
        "commit_hash": "cb5b8c282101f3439d167ce13a015b34c4796b09",
        "previous_commit_hash": "97fc3a53587486024bced5ea12370c3824e0c33c",
        "diff_stats": {
            "additions": 0,
            "deletions": 0
        },
        "diff_content": "Binary files /dev/null and b/resources/presentation-preview.png differ\n"
    },
    {
        "commit_hash": "c80e12922af180db7d9d608b8a4c47c497486cd8",
        "previous_commit_hash": "cb5b8c282101f3439d167ce13a015b34c4796b09",
        "diff_stats": {
            "additions": 45,
            "deletions": 36
        },
        "diff_content": "@@ -23,7 +23,42 @@ article about how to do it](http://zserge.com/blog/android-lambda.html).\n User Guide\n ----------\n \n-### Getting Started\n+Retrolambda can be run as a [Maven plugin](#maven-plugin),\n+[Gradle plugin](#gradle-plugin) or\n+[command line application](#command-line-application). Also have a look at\n+[some tips for using Retrolambda effectively](#tips).\n+\n+\n+### Maven Plugin\n+\n+To run Retrolambda using Maven, add the following to your pom.xml:\n+\n+```xml\n+<plugin>\n+    <groupId>net.orfjackal.retrolambda</groupId>\n+    <artifactId>retrolambda-maven-plugin</artifactId>\n+    <version>1.7.0</version>\n+    <executions>\n+        <execution>\n+            <goals>\n+                <goal>process-main</goal>\n+                <goal>process-test</goal>\n+            </goals>\n+        </execution>\n+    </executions>\n+</plugin>\n+```\n+\n+See the [plugin documentation](http://orfjackal.github.io/retrolambda/retrolambda-maven-plugin/plugin-info.html)\n+for all possible parameters. There is also a usage example in [end-to-end-tests/pom.xml](https://github.com/orfjackal/retrolambda/blob/master/end-to-end-tests/pom.xml)\n+\n+\n+### Gradle Plugin\n+\n+[Gradle Retrolamba Plugin](https://github.com/evant/gradle-retrolambda) is developed by Evan Tatarka. See its site for usage instructions.\n+\n+\n+### Command Line Application\n \n [Download](https://oss.sonatype.org/content/groups/public/net/orfjackal/retrolambda/retrolambda/)\n the latest `retrolambda.jar` from Maven Central.\n@@ -34,9 +69,7 @@ Run Retrolambda, using Java 8, on the class files produced by JDK 8. Run\n `java -jar retrolambda.jar` without any additional options to see the\n instructions (for your convenience they are also shown below).\n \n-Your class files should now run on Java 7. Be sure to run comprehensive tests\n-on Java 7, in case the code accidentally uses Java 8 APIs or language features\n-that Retrolambda doesn't backport.\n+Your class files should now run on Java 7 or older.\n \n ```\n Usage: java -Dretrolambda.inputDir=? -Dretrolambda.classpath=? [-javaagent:retrolambda.jar] -jar retrolambda.jar\n@@ -79,41 +112,16 @@ stopping to work between Java releases.\n ```\n \n \n-### Maven Plugin\n-\n-To run Retrolambda using Maven, add the following to your pom.xml:\n-\n-```xml\n-<plugin>\n-    <groupId>net.orfjackal.retrolambda</groupId>\n-    <artifactId>retrolambda-maven-plugin</artifactId>\n-    <version>1.7.0</version>\n-    <executions>\n-        <execution>\n-            <goals>\n-                <goal>process-main</goal>\n-                <goal>process-test</goal>\n-            </goals>\n-        </execution>\n-    </executions>\n-</plugin>\n-```\n-\n-See the [plugin documentation](http://orfjackal.github.io/retrolambda/retrolambda-maven-plugin/plugin-info.html)\n-for all possible parameters. There is also a usage example in [end-to-end-tests/pom.xml](https://github.com/orfjackal/retrolambda/blob/master/end-to-end-tests/pom.xml)\n-\n-\n-### Gradle Plugin\n-\n-[Gradle Retrolamba Plugin](https://github.com/evant/gradle-retrolambda) is developed by Evan Tatarka. See its site for usage instructions.\n-\n-\n ### Tips\n \n+Be sure to run comprehensive tests on your target JVM version (e.g. Java\n+7), in case the code accidentally uses Java 8 APIs or language features\n+that Retrolambda doesn't backport.\n+\n During development, inside an IDE, it's the easiest to use Java 8, without\n-Retrolamba, to compile and run tests. But in your continuous integration build\n-you should run tests using the target Java version. For example, you can\n-configure Maven Surefire Plugin to run tests\n+Retrolamba, to compile and run tests. But in your continuous integration\n+and release builds you should run all tests using the target Java version.\n+For example, you can configure Maven Surefire Plugin to run tests\n [using a different JVM](http://maven.apache.org/surefire/maven-surefire-plugin/test-mojo.html#jvm).\n \n I recommend setting up environment variables JAVA8_HOME, JAVA7_HOME etc. and\n@@ -121,6 +129,7 @@ referring to those variables in the build configuration, instead of relying on\n what happens to be the default Java version in JAVA_HOME.\n \n You will need Java 8 for compiling and also for generating Javadocs.\n+JDK 7's Javadoc tool will fail for some valid Java 8 code.\n \n \n Known Limitations\n"
    },
    {
        "commit_hash": "869ff20185d9a0bb70ead008db7f1d844f97f00b",
        "previous_commit_hash": "c80e12922af180db7d9d608b8a4c47c497486cd8",
        "diff_stats": {
            "additions": 1,
            "deletions": 3
        },
        "diff_content": "@@ -45,7 +45,6 @@\n         </codeStyleSettings>\n         <codeStyleSettings language=\"Groovy\">\n           <option name=\"IF_BRACE_FORCE\" value=\"3\" />\n-          <option name=\"DOWHILE_BRACE_FORCE\" value=\"3\" />\n           <option name=\"WHILE_BRACE_FORCE\" value=\"3\" />\n           <option name=\"FOR_BRACE_FORCE\" value=\"3\" />\n           <option name=\"FIELD_ANNOTATION_WRAP\" value=\"0\" />\n@@ -103,5 +102,4 @@\n     </option>\n     <option name=\"USE_PER_PROJECT_SETTINGS\" value=\"true\" />\n   </component>\n-</project>\n-\n+</project>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "869ff20185d9a0bb70ead008db7f1d844f97f00b",
        "previous_commit_hash": "c80e12922af180db7d9d608b8a4c47c497486cd8",
        "diff_stats": {
            "additions": 5,
            "deletions": 2
        },
        "diff_content": "@@ -22,8 +22,11 @@\n       </profile>\n     </annotationProcessing>\n     <bytecodeTargetLevel target=\"1.8\">\n+      <module name=\"end-to-end-tests\" target=\"1.8\" />\n+      <module name=\"parent\" target=\"1.8\" />\n+      <module name=\"project\" target=\"1.8\" />\n+      <module name=\"retrolambda\" target=\"1.8\" />\n       <module name=\"retrolambda-maven-plugin\" target=\"1.6\" />\n     </bytecodeTargetLevel>\n   </component>\n-</project>\n-\n+</project>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "869ff20185d9a0bb70ead008db7f1d844f97f00b",
        "previous_commit_hash": "c80e12922af180db7d9d608b8a4c47c497486cd8",
        "diff_stats": {
            "additions": 0,
            "deletions": 1
        },
        "diff_content": "@@ -1,6 +1,5 @@\n <component name=\"CopyrightManager\">\n   <settings default=\"Apache 2.0\">\n-    <module2copyright />\n     <LanguageOptions name=\"CSS\">\n       <option name=\"fileTypeOverride\" value=\"1\" />\n     </LanguageOptions>\n"
    },
    {
        "commit_hash": "869ff20185d9a0bb70ead008db7f1d844f97f00b",
        "previous_commit_hash": "c80e12922af180db7d9d608b8a4c47c497486cd8",
        "diff_stats": {
            "additions": 1,
            "deletions": 6
        },
        "diff_content": "@@ -1,7 +1,2 @@\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n-<project version=\"4\">\n-  <component name=\"GradleSettings\">\n-    <option name=\"gradleHome\" value=\"C:/Program Files/gradle\" />\n-  </component>\n-</project>\n-\n+<project version=\"4\" />\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "869ff20185d9a0bb70ead008db7f1d844f97f00b",
        "previous_commit_hash": "c80e12922af180db7d9d608b8a4c47c497486cd8",
        "diff_stats": {
            "additions": 0,
            "deletions": 3
        },
        "diff_content": "@@ -42,9 +42,6 @@\n     <inspection_tool class=\"LongLiteralsEndingWithLowercaseL\" enabled=\"true\" level=\"WARNING\" enabled_by_default=\"true\" />\n     <inspection_tool class=\"MethodMayBeSynchronized\" enabled=\"true\" level=\"WARNING\" enabled_by_default=\"true\" />\n     <inspection_tool class=\"NonSerializableWithSerialVersionUIDField\" enabled=\"true\" level=\"WARNING\" enabled_by_default=\"true\" />\n-    <inspection_tool class=\"PointlessArithmeticExpression\" enabled=\"true\" level=\"WARNING\" enabled_by_default=\"true\">\n-      <option name=\"m_ignoreExpressionsContainingConstants\" value=\"true\" />\n-    </inspection_tool>\n     <inspection_tool class=\"RawUseOfParameterizedType\" enabled=\"true\" level=\"WARNING\" enabled_by_default=\"true\" />\n     <inspection_tool class=\"RedundantSuppression\" enabled=\"true\" level=\"WARNING\" enabled_by_default=\"true\" />\n     <inspection_tool class=\"RedundantThrowsDeclaration\" enabled=\"true\" level=\"WARNING\" enabled_by_default=\"true\" />\n"
    },
    {
        "commit_hash": "869ff20185d9a0bb70ead008db7f1d844f97f00b",
        "previous_commit_hash": "c80e12922af180db7d9d608b8a4c47c497486cd8",
        "diff_stats": {
            "additions": 4,
            "deletions": 0
        },
        "diff_content": "@@ -4,10 +4,14 @@\n       <option name=\"myGeneralSettings\" />\n       <option name=\"myRunnerSettings\">\n         <MavenRunnerSettings>\n+          <option name=\"environmentProperties\">\n+            <map />\n+          </option>\n           <option name=\"jreName\" value=\"1.6\" />\n           <option name=\"mavenProperties\">\n             <map />\n           </option>\n+          <option name=\"passParentEnv\" value=\"true\" />\n           <option name=\"runMavenInBackground\" value=\"true\" />\n           <option name=\"skipTests\" value=\"false\" />\n           <option name=\"vmOptions\" value=\"\" />\n"
    },
    {
        "commit_hash": "869ff20185d9a0bb70ead008db7f1d844f97f00b",
        "previous_commit_hash": "c80e12922af180db7d9d608b8a4c47c497486cd8",
        "diff_stats": {
            "additions": 11,
            "deletions": 4
        },
        "diff_content": "@@ -1,6 +1,6 @@\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <module org.jetbrains.idea.maven.project.MavenProjectsManager.isMavenModule=\"true\" type=\"JAVA_MODULE\" version=\"4\">\n-  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"false\">\n+  <component name=\"NewModuleRootManager\" LANGUAGE_LEVEL=\"JDK_1_8\" inherit-compiler-output=\"false\">\n     <output url=\"file://$MODULE_DIR$/target/classes\" />\n     <output-test url=\"file://$MODULE_DIR$/target/test-classes\" />\n     <content url=\"file://$MODULE_DIR$\">\n@@ -13,12 +13,19 @@\n     <orderEntry type=\"library\" name=\"Maven: com.google.guava:guava:11.0.2\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: com.google.code.findbugs:jsr305:1.3.9\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: commons-lang:commons-lang:2.6\" level=\"project\" />\n-    <orderEntry type=\"library\" name=\"Maven: net.orfjackal.retrolambda:java-lang-dummies:1\" level=\"project\" />\n+    <orderEntry type=\"module-library\">\n+      <library name=\"Maven: net.orfjackal.retrolambda:java-lang-dummies:1\">\n+        <CLASSES>\n+          <root url=\"jar://$MODULE_DIR$/src/test/lib/java-lang-dummies.jar!/\" />\n+        </CLASSES>\n+        <JAVADOC />\n+        <SOURCES />\n+      </library>\n+    </orderEntry>\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.12-beta-2\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-library:1.3\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-core:1.3\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.mockito:mockito-core:1.10.8\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.objenesis:objenesis:2.1\" level=\"project\" />\n   </component>\n-</module>\n-\n+</module>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "869ff20185d9a0bb70ead008db7f1d844f97f00b",
        "previous_commit_hash": "c80e12922af180db7d9d608b8a4c47c497486cd8",
        "diff_stats": {
            "additions": 2,
            "deletions": 4
        },
        "diff_content": "@@ -1,9 +1,8 @@\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <module org.jetbrains.idea.maven.project.MavenProjectsManager.isMavenModule=\"true\" type=\"JAVA_MODULE\" version=\"4\">\n-  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"false\">\n+  <component name=\"NewModuleRootManager\" LANGUAGE_LEVEL=\"JDK_1_8\" inherit-compiler-output=\"false\">\n     <output url=\"file://$MODULE_DIR$/target/classes\" />\n     <output-test url=\"file://$MODULE_DIR$/target/test-classes\" />\n-    <exclude-output />\n     <content url=\"file://$MODULE_DIR$\">\n       <excludeFolder url=\"file://$MODULE_DIR$/target\" />\n     </content>\n@@ -15,5 +14,4 @@\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.mockito:mockito-core:1.10.8\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.objenesis:objenesis:2.1\" level=\"project\" />\n   </component>\n-</module>\n-\n+</module>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "869ff20185d9a0bb70ead008db7f1d844f97f00b",
        "previous_commit_hash": "c80e12922af180db7d9d608b8a4c47c497486cd8",
        "diff_stats": {
            "additions": 2,
            "deletions": 4
        },
        "diff_content": "@@ -1,9 +1,8 @@\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <module org.jetbrains.idea.maven.project.MavenProjectsManager.isMavenModule=\"true\" type=\"JAVA_MODULE\" version=\"4\">\n-  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"false\">\n+  <component name=\"NewModuleRootManager\" LANGUAGE_LEVEL=\"JDK_1_8\" inherit-compiler-output=\"false\">\n     <output url=\"file://$MODULE_DIR$/target/classes\" />\n     <output-test url=\"file://$MODULE_DIR$/target/test-classes\" />\n-    <exclude-output />\n     <content url=\"file://$MODULE_DIR$\">\n       <excludeFolder url=\"file://$MODULE_DIR$/target\" />\n     </content>\n@@ -15,5 +14,4 @@\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.mockito:mockito-core:1.10.8\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.objenesis:objenesis:2.1\" level=\"project\" />\n   </component>\n-</module>\n-\n+</module>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "869ff20185d9a0bb70ead008db7f1d844f97f00b",
        "previous_commit_hash": "c80e12922af180db7d9d608b8a4c47c497486cd8",
        "diff_stats": {
            "additions": 11,
            "deletions": 12
        },
        "diff_content": "@@ -4,7 +4,7 @@\n     <output url=\"file://$MODULE_DIR$/target/classes\" />\n     <output-test url=\"file://$MODULE_DIR$/target/test-classes\" />\n     <content url=\"file://$MODULE_DIR$\">\n-      <sourceFolder url=\"file://$MODULE_DIR$/target/generated-sources/plugin\" isTestSource=\"false\" />\n+      <sourceFolder url=\"file://$MODULE_DIR$/target/generated-sources/plugin\" isTestSource=\"false\" generated=\"true\" />\n       <sourceFolder url=\"file://$MODULE_DIR$/src/main/resources\" isTestSource=\"false\" />\n       <sourceFolder url=\"file://$MODULE_DIR$/src/main/java\" isTestSource=\"false\" />\n       <sourceFolder url=\"file://$MODULE_DIR$/src/test/java\" isTestSource=\"true\" />\n@@ -19,36 +19,35 @@\n     <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n     <orderEntry type=\"module\" module-name=\"retrolambda\" />\n     <orderEntry type=\"library\" name=\"Maven: org.ow2.asm:asm-debug-all:5.0.3\" level=\"project\" />\n-    <orderEntry type=\"library\" name=\"Maven: com.google.guava:guava:18.0\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-plugin-api:2.0\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"PROVIDED\" name=\"Maven: org.apache.maven.plugin-tools:maven-plugin-annotations:3.2\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-artifact:3.0\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.codehaus.plexus:plexus-utils:3.0.17\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.twdata.maven:mojo-executor:2.2.0\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-core:3.0\" level=\"project\" />\n-    <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-model:3.0\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-settings:3.0\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-settings-builder:3.0\" level=\"project\" />\n-    <orderEntry type=\"library\" name=\"Maven: org.codehaus.plexus:plexus-interpolation:1.14\" level=\"project\" />\n-    <orderEntry type=\"library\" name=\"Maven: org.codehaus.plexus:plexus-component-annotations:1.5.5\" level=\"project\" />\n-    <orderEntry type=\"library\" name=\"Maven: org.sonatype.plexus:plexus-sec-dispatcher:1.3\" level=\"project\" />\n-    <orderEntry type=\"library\" name=\"Maven: org.sonatype.plexus:plexus-cipher:1.4\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-repository-metadata:3.0\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-model-builder:3.0\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"RUNTIME\" name=\"Maven: org.apache.maven:maven-aether-provider:3.0\" level=\"project\" />\n-    <orderEntry type=\"library\" name=\"Maven: org.sonatype.aether:aether-api:1.7\" level=\"project\" />\n-    <orderEntry type=\"library\" name=\"Maven: org.sonatype.aether:aether-util:1.7\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.sonatype.aether:aether-impl:1.7\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.sonatype.aether:aether-spi:1.7\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.sonatype.aether:aether-api:1.7\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.sonatype.aether:aether-util:1.7\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.sonatype.sisu:sisu-inject-plexus:1.4.2\" level=\"project\" />\n-    <orderEntry type=\"library\" name=\"Maven: org.codehaus.plexus:plexus-classworlds:2.2.3\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.sonatype.sisu:sisu-inject-bean:1.4.2\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.sonatype.sisu:sisu-guice:noaop:2.1.7\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.codehaus.plexus:plexus-interpolation:1.14\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.codehaus.plexus:plexus-classworlds:2.2.3\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.codehaus.plexus:plexus-component-annotations:1.5.5\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.sonatype.plexus:plexus-sec-dispatcher:1.3\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.sonatype.plexus:plexus-cipher:1.4\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-model:3.0\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: com.google.guava:guava:18.0\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.12-beta-2\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-library:1.3\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-core:1.3\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.mockito:mockito-core:1.10.8\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.objenesis:objenesis:2.1\" level=\"project\" />\n   </component>\n-</module>\n-\n+</module>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "869ff20185d9a0bb70ead008db7f1d844f97f00b",
        "previous_commit_hash": "c80e12922af180db7d9d608b8a4c47c497486cd8",
        "diff_stats": {
            "additions": 2,
            "deletions": 3
        },
        "diff_content": "@@ -1,6 +1,6 @@\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <module org.jetbrains.idea.maven.project.MavenProjectsManager.isMavenModule=\"true\" type=\"JAVA_MODULE\" version=\"4\">\n-  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"false\">\n+  <component name=\"NewModuleRootManager\" LANGUAGE_LEVEL=\"JDK_1_8\" inherit-compiler-output=\"false\">\n     <output url=\"file://$MODULE_DIR$/target/classes\" />\n     <output-test url=\"file://$MODULE_DIR$/target/test-classes\" />\n     <content url=\"file://$MODULE_DIR$\">\n@@ -18,5 +18,4 @@\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.mockito:mockito-core:1.10.8\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.objenesis:objenesis:2.1\" level=\"project\" />\n   </component>\n-</module>\n-\n+</module>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "4a125e8e7c144f3ab31d20a880f993e778ac3b70",
        "previous_commit_hash": "869ff20185d9a0bb70ead008db7f1d844f97f00b",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -76,7 +76,7 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n     }\n \n     @Override\n-    public MethodRef getMethodLocation(MethodRef original) {\n+    public MethodRef getMethodCallTarget(MethodRef original) {\n         return relocatedMethods.getOrDefault(original, original);\n     }\n \n"
    },
    {
        "commit_hash": "4a125e8e7c144f3ab31d20a880f993e778ac3b70",
        "previous_commit_hash": "869ff20185d9a0bb70ead008db7f1d844f97f00b",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@ package net.orfjackal.retrolambda.interfaces;\n \n public interface MethodRelocations {\n \n-    MethodRef getMethodLocation(MethodRef original);\n+    MethodRef getMethodCallTarget(MethodRef original);\n \n     String getCompanionClass(String className);\n }\n"
    },
    {
        "commit_hash": "4a125e8e7c144f3ab31d20a880f993e778ac3b70",
        "previous_commit_hash": "869ff20185d9a0bb70ead008db7f1d844f97f00b",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -37,7 +37,7 @@ public class UpdateRelocatedMethodInvocations extends ClassVisitor {\n \n         @Override\n         public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\n-            MethodRef ref = methodRelocations.getMethodLocation(new MethodRef(owner, name, desc));\n+            MethodRef ref = methodRelocations.getMethodCallTarget(new MethodRef(owner, name, desc));\n             super.visitMethodInsn(opcode, ref.owner, ref.name, ref.desc, itf);\n         }\n     }\n"
    },
    {
        "commit_hash": "4a125e8e7c144f3ab31d20a880f993e778ac3b70",
        "previous_commit_hash": "869ff20185d9a0bb70ead008db7f1d844f97f00b",
        "diff_stats": {
            "additions": 4,
            "deletions": 4
        },
        "diff_content": "@@ -59,7 +59,7 @@ public class ClassHierarchyAnalyzerTest {\n         analyze(InterfaceMethodTypes.class);\n \n         MethodRef source = new MethodRef(InterfaceMethodTypes.class, \"abstractMethod\", \"()V\");\n-        MethodRef target = analyzer.getMethodLocation(source);\n+        MethodRef target = analyzer.getMethodCallTarget(source);\n \n         assertThat(target, is(source));\n     }\n@@ -69,7 +69,7 @@ public class ClassHierarchyAnalyzerTest {\n         analyze(InterfaceMethodTypes.class);\n \n         MethodRef source = new MethodRef(InterfaceMethodTypes.class, \"defaultMethod\", \"()V\");\n-        MethodRef target = analyzer.getMethodLocation(source);\n+        MethodRef target = analyzer.getMethodCallTarget(source);\n \n         assertThat(target, is(source));\n     }\n@@ -79,7 +79,7 @@ public class ClassHierarchyAnalyzerTest {\n         analyze(InterfaceMethodTypes.class);\n \n         MethodRef source = new MethodRef(InterfaceMethodTypes.class, \"staticMethod\", \"()V\");\n-        MethodRef target = analyzer.getMethodLocation(source);\n+        MethodRef target = analyzer.getMethodCallTarget(source);\n \n         assertThat(target, is(new MethodRef(InterfaceMethodTypes$.class, \"staticMethod\", \"()V\")));\n     }\n@@ -89,7 +89,7 @@ public class ClassHierarchyAnalyzerTest {\n         analyze(ClassMethodTypes.class);\n \n         MethodRef source = new MethodRef(ClassMethodTypes.class, \"staticMethod\", \"()V\");\n-        MethodRef target = analyzer.getMethodLocation(source);\n+        MethodRef target = analyzer.getMethodCallTarget(source);\n \n         assertThat(target, is(source));\n     }\n"
    },
    {
        "commit_hash": "6aa8427a6ee55682cc146fd79a957c7c30e5919e",
        "previous_commit_hash": "4a125e8e7c144f3ab31d20a880f993e778ac3b70",
        "diff_stats": {
            "additions": 50,
            "deletions": 7
        },
        "diff_content": "@@ -15,10 +15,13 @@ import static org.objectweb.asm.Opcodes.*;\n \n public class ClassHierarchyAnalyzer implements MethodRelocations {\n \n+    private static final MethodRef ABSTRACT_METHOD = new MethodRef(\"\", \"\", \"\");\n+\n     private final List<ClassReader> interfaces = new ArrayList<>();\n     private final List<ClassReader> classes = new ArrayList<>();\n-    private final Map<Type, List<Type>> interfacesByImplementer = new HashMap<>();\n+    private final Map<Type, List<Type>> interfacesByImplementer = new HashMap<>(); // TODO: could use just String instead of Type\n     private final Map<MethodRef, MethodRef> relocatedMethods = new HashMap<>();\n+    private final Map<MethodRef, MethodRef> methodDefaultImpls = new HashMap<>();\n     private final Map<String, String> companionClasses = new HashMap<>();\n \n     public void analyze(byte[] bytecode) {\n@@ -35,11 +38,11 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n         interfacesByImplementer.put(clazz, interfaces);\n \n         if (Flags.hasFlag(cr.getAccess(), ACC_INTERFACE)) {\n-            discoverRelocatedMethods(cr);\n+            analyzeInterface(cr);\n         }\n     }\n \n-    private void discoverRelocatedMethods(ClassReader cr) {\n+    private void analyzeInterface(ClassReader cr) {\n         cr.accept(new ClassVisitor(ASM5) {\n             private String owner;\n             private String companion;\n@@ -52,14 +55,34 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n \n             @Override\n             public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n-                if (Flags.hasFlag(access, ACC_STATIC)) {\n-                    relocatedMethods.put(\n-                            new MethodRef(owner, name, desc),\n-                            new MethodRef(companion, name, desc));\n+                MethodRef method = new MethodRef(owner, name, desc);\n+\n+                if (isAbstractMethod(access)) {\n+                    methodDefaultImpls.put(method, ABSTRACT_METHOD);\n+\n+                } else if (isDefaultMethod(access)) {\n+                    methodDefaultImpls.put(method, new MethodRef(companion, name, desc));\n+                    companionClasses.put(owner, companion);\n+\n+                } else if (isStaticMethod(access)) {\n+                    relocatedMethods.put(method, new MethodRef(companion, name, desc));\n                     companionClasses.put(owner, companion);\n                 }\n                 return null;\n             }\n+\n+            private boolean isAbstractMethod(int access) {\n+                return Flags.hasFlag(access, ACC_ABSTRACT);\n+            }\n+\n+            private boolean isStaticMethod(int access) {\n+                return Flags.hasFlag(access, ACC_STATIC);\n+            }\n+\n+            private boolean isDefaultMethod(int access) {\n+                return !isAbstractMethod(access)\n+                        && !isStaticMethod(access);\n+            }\n         }, ClassReader.SKIP_CODE);\n     }\n \n@@ -80,6 +103,26 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n         return relocatedMethods.getOrDefault(original, original);\n     }\n \n+    @Override\n+    public MethodRef getMethodDefaultImplementation(MethodRef interfaceMethod) {\n+        MethodRef impl = methodDefaultImpls.get(interfaceMethod);\n+        if (impl == ABSTRACT_METHOD) {\n+            return null;\n+        }\n+        if (impl != null) {\n+            return impl;\n+        }\n+\n+        // check if a default implementation is inherited from parents\n+        for (Type parentInterface : interfacesByImplementer.getOrDefault(Type.getObjectType(interfaceMethod.owner), Collections.emptyList())) {\n+            impl = getMethodDefaultImplementation(interfaceMethod.withOwner(parentInterface.getInternalName()));\n+            if (impl != null) {\n+                return impl;\n+            }\n+        }\n+        return null;\n+    }\n+\n     @Override\n     public String getCompanionClass(String className) {\n         return companionClasses.get(className);\n"
    },
    {
        "commit_hash": "6aa8427a6ee55682cc146fd79a957c7c30e5919e",
        "previous_commit_hash": "4a125e8e7c144f3ab31d20a880f993e778ac3b70",
        "diff_stats": {
            "additions": 4,
            "deletions": 0
        },
        "diff_content": "@@ -23,6 +23,10 @@ public final class MethodRef {\n         this.desc = desc;\n     }\n \n+    public MethodRef withOwner(String newOwner) {\n+        return new MethodRef(newOwner, name, desc);\n+    }\n+\n     @Override\n     public boolean equals(Object obj) {\n         if (!(obj instanceof MethodRef)) {\n"
    },
    {
        "commit_hash": "6aa8427a6ee55682cc146fd79a957c7c30e5919e",
        "previous_commit_hash": "4a125e8e7c144f3ab31d20a880f993e778ac3b70",
        "diff_stats": {
            "additions": 2,
            "deletions": 0
        },
        "diff_content": "@@ -8,5 +8,7 @@ public interface MethodRelocations {\n \n     MethodRef getMethodCallTarget(MethodRef original);\n \n+    MethodRef getMethodDefaultImplementation(MethodRef interfaceMethod);\n+\n     String getCompanionClass(String className);\n }\n"
    },
    {
        "commit_hash": "6aa8427a6ee55682cc146fd79a957c7c30e5919e",
        "previous_commit_hash": "4a125e8e7c144f3ab31d20a880f993e778ac3b70",
        "diff_stats": {
            "additions": 104,
            "deletions": 9
        },
        "diff_content": "@@ -10,7 +10,7 @@ import org.junit.Test;\n import org.objectweb.asm.*;\n \n import java.io.*;\n-import java.util.List;\n+import java.util.*;\n \n import static java.util.Arrays.asList;\n import static java.util.stream.Collectors.toList;\n@@ -24,8 +24,8 @@ public class ClassHierarchyAnalyzerTest {\n \n     @Test\n     public void separates_interfaces_from_classes() {\n-        analyze(Interface.class);\n-        analyze(InterfaceImplementer.class);\n+        analyze(Interface.class,\n+                InterfaceImplementer.class);\n \n         assertThat(getInterfaces(), is(classList(Interface.class)));\n         assertThat(getClasses(), is(classList(InterfaceImplementer.class)));\n@@ -46,9 +46,13 @@ public class ClassHierarchyAnalyzerTest {\n     }\n \n     private interface Interface {\n+        void abstractMethod();\n     }\n \n     private class InterfaceImplementer implements Interface {\n+        @Override\n+        public void abstractMethod() {\n+        }\n     }\n \n \n@@ -118,23 +122,114 @@ public class ClassHierarchyAnalyzerTest {\n     }\n \n \n+    // Default method implementations\n+\n+    @Test\n+    public void abstract_methods_have_no_implementation() {\n+        analyze(HasDefaultMethods.class);\n+\n+        MethodRef method = new MethodRef(HasDefaultMethods.class, \"abstractMethod\", \"()V\");\n+        MethodRef impl = analyzer.getMethodDefaultImplementation(method);\n+\n+        assertThat(impl, is(nullValue()));\n+    }\n+\n+    @Test\n+    public void default_method_implementation_is_moved_to_companion_class() {\n+        analyze(HasDefaultMethods.class);\n+\n+        MethodRef method = new MethodRef(HasDefaultMethods.class, \"defaultMethod\", \"()V\");\n+        MethodRef impl = analyzer.getMethodDefaultImplementation(method);\n+\n+        assertThat(impl, is(new MethodRef(HasDefaultMethods$.class, \"defaultMethod\", \"()V\")));\n+    }\n+\n+    @Test\n+    public void default_method_implementations_are_inherited_from_parent_interface() {\n+        analyze(HasDefaultMethods.class,\n+                DoesNotOverrideDefaultMethods.class);\n+\n+        MethodRef method = new MethodRef(DoesNotOverrideDefaultMethods.class, \"defaultMethod\", \"()V\");\n+        MethodRef impl = analyzer.getMethodDefaultImplementation(method);\n+\n+        assertThat(impl, is(new MethodRef(HasDefaultMethods$.class, \"defaultMethod\", \"()V\")));\n+    }\n+\n+    @Test\n+    public void overridden_default_method_implementation_is_moved_to_companion_class() {\n+        analyze(HasDefaultMethods.class,\n+                OverridesDefaultMethods.class);\n+\n+        MethodRef method = new MethodRef(OverridesDefaultMethods.class, \"defaultMethod\", \"()V\");\n+        MethodRef impl = analyzer.getMethodDefaultImplementation(method);\n+\n+        assertThat(impl, is(new MethodRef(OverridesDefaultMethods$.class, \"defaultMethod\", \"()V\")));\n+    }\n+\n+    @Test\n+    public void abstracted_default_method_implementations_are_again_abstract() {\n+        analyze(HasDefaultMethods.class,\n+                AbstractsDefaultMethods.class);\n+\n+        MethodRef method = new MethodRef(AbstractsDefaultMethods.class, \"defaultMethod\", \"()V\");\n+        MethodRef impl = analyzer.getMethodDefaultImplementation(method);\n+\n+        assertThat(impl, is(nullValue()));\n+    }\n+\n+    private interface HasDefaultMethods {\n+        void abstractMethod();\n+\n+        default void defaultMethod() {\n+        }\n+    }\n+\n+    private interface HasDefaultMethods$ {\n+    }\n+\n+    private interface DoesNotOverrideDefaultMethods extends HasDefaultMethods {\n+    }\n+\n+    private interface OverridesDefaultMethods extends HasDefaultMethods {\n+        @Override\n+        default void defaultMethod() {\n+        }\n+    }\n+\n+    private interface OverridesDefaultMethods$ {\n+    }\n+\n+    private interface AbstractsDefaultMethods extends HasDefaultMethods {\n+        @Override\n+        void defaultMethod();\n+    }\n+\n+\n+    // Companion class\n+\n     @Test\n     public void companion_class_is_needed_when_methods_are_moved_there() {\n-        analyze(Interface.class);\n-        analyze(InterfaceMethodTypes.class);\n-        analyze(ClassMethodTypes.class);\n+        analyze(Interface.class,\n+                InterfaceMethodTypes.class,\n+                HasDefaultMethods.class,\n+                ClassMethodTypes.class);\n \n         assertThat(\"Interface\", analyzer.getCompanionClass(Type.getInternalName(Interface.class)), is(nullValue()));\n         assertThat(\"InterfaceMethodTypes\", analyzer.getCompanionClass(Type.getInternalName(InterfaceMethodTypes.class)), is(Type.getInternalName(InterfaceMethodTypes$.class)));\n+        assertThat(\"HasDefaultMethods\", analyzer.getCompanionClass(Type.getInternalName(HasDefaultMethods.class)), is(Type.getInternalName(HasDefaultMethods$.class)));\n         assertThat(\"ClassMethodTypes\", analyzer.getCompanionClass(Type.getInternalName(ClassMethodTypes.class)), is(nullValue()));\n     }\n \n \n     // API wrappers\n \n-    private void analyze(Class<?> clazz) {\n-        byte[] bytecode = readBytecode(clazz);\n-        analyzer.analyze(bytecode);\n+    private void analyze(Class<?>... classes) {\n+        List<Class<?>> inAnyOrder = new ArrayList<>(Arrays.asList(classes));\n+        Collections.shuffle(inAnyOrder);\n+        for (Class<?> clazz : inAnyOrder) {\n+            byte[] bytecode = readBytecode(clazz);\n+            analyzer.analyze(bytecode);\n+        }\n     }\n \n     private List<Class<?>> getInterfaces() {\n"
    },
    {
        "commit_hash": "28e6be7581496dbc20804ad4e6749b4261195a8d",
        "previous_commit_hash": "6aa8427a6ee55682cc146fd79a957c7c30e5919e",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -18,6 +18,7 @@ public class InterfaceBridgeMethodsTest {\n      * to remove it for it - this makes the bytecode same as what JDK 7 produces.\n      */\n     @Test\n+    @SuppressWarnings(\"Convert2Lambda\")\n     public void will_remove_bridge_methods_from_interfaces() {\n         BridgeChild child = new BridgeChild() {\n             @Override\n"
    },
    {
        "commit_hash": "28e6be7581496dbc20804ad4e6749b4261195a8d",
        "previous_commit_hash": "6aa8427a6ee55682cc146fd79a957c7c30e5919e",
        "diff_stats": {
            "additions": 11,
            "deletions": 11
        },
        "diff_content": "@@ -16,7 +16,7 @@ public class BackportLambdaClass extends ClassVisitor {\n     private String lambdaClass;\n     private Type constructor;\n     private Handle implMethod;\n-    private Handle bridgeMethod;\n+    private Handle accessMethod;\n     private LambdaFactoryMethod factoryMethod;\n \n     public BackportLambdaClass(ClassVisitor next) {\n@@ -28,7 +28,7 @@ public class BackportLambdaClass extends ClassVisitor {\n         lambdaClass = name;\n         LambdaReifier.setLambdaClass(lambdaClass);\n         implMethod = LambdaReifier.getLambdaImplMethod();\n-        bridgeMethod = LambdaReifier.getLambdaBridgeMethod();\n+        accessMethod = LambdaReifier.getLambdaAccessMethod();\n         factoryMethod = LambdaReifier.getLambdaFactoryMethod();\n \n         if (superName.equals(LambdaNaming.MAGIC_LAMBDA_IMPL)) {\n@@ -47,7 +47,7 @@ public class BackportLambdaClass extends ClassVisitor {\n         }\n         MethodVisitor next = super.visitMethod(access, name, desc, signature, exceptions);\n         next = new RemoveMagicLambdaConstructorCall(next);\n-        next = new BridgePrivateMethodInvocations(next);\n+        next = new CallPrivateImplMethodsViaAccessMethods(next);\n         return next;\n     }\n \n@@ -128,9 +128,9 @@ public class BackportLambdaClass extends ClassVisitor {\n         }\n     }\n \n-    private class BridgePrivateMethodInvocations extends MethodVisitor {\n+    private class CallPrivateImplMethodsViaAccessMethods extends MethodVisitor {\n \n-        public BridgePrivateMethodInvocations(MethodVisitor next) {\n+        public CallPrivateImplMethodsViaAccessMethods(MethodVisitor next) {\n             super(ASM5, next);\n         }\n \n@@ -139,16 +139,16 @@ public class BackportLambdaClass extends ClassVisitor {\n             // Java 8's lambda classes get away with calling private virtual methods\n             // by using invokespecial because the JVM relaxes the bytecode validation\n             // of the lambda classes it generates. We must however call them through\n-            // a non-private bridge method which we have generated.\n+            // a non-private access method which we have generated.\n             if (owner.equals(implMethod.getOwner())\n                     && name.equals(implMethod.getName())\n                     && desc.equals(implMethod.getDesc())) {\n                 super.visitMethodInsn(\n-                        Handles.getOpcode(bridgeMethod),\n-                        bridgeMethod.getOwner(),\n-                        bridgeMethod.getName(),\n-                        bridgeMethod.getDesc(),\n-                        bridgeMethod.getTag() == H_INVOKEINTERFACE);\n+                        Handles.getOpcode(accessMethod),\n+                        accessMethod.getOwner(),\n+                        accessMethod.getName(),\n+                        accessMethod.getDesc(),\n+                        accessMethod.getTag() == H_INVOKEINTERFACE);\n             } else {\n                 super.visitMethodInsn(opcode, owner, name, desc, itf);\n             }\n"
    },
    {
        "commit_hash": "28e6be7581496dbc20804ad4e6749b4261195a8d",
        "previous_commit_hash": "6aa8427a6ee55682cc146fd79a957c7c30e5919e",
        "diff_stats": {
            "additions": 17,
            "deletions": 17
        },
        "diff_content": "@@ -17,7 +17,7 @@ public class BackportLambdaInvocations extends ClassVisitor {\n \n     private int classAccess;\n     private String className;\n-    private final Map<Handle, Handle> lambdaBridgesToImplMethods = new LinkedHashMap<>();\n+    private final Map<Handle, Handle> lambdaAccessToImplMethods = new LinkedHashMap<>();\n \n     public BackportLambdaInvocations(ClassVisitor next) {\n         super(ASM5, next);\n@@ -90,41 +90,41 @@ public class BackportLambdaInvocations extends ClassVisitor {\n                 Flags.hasFlag(methodAccess, ACC_STATIC);\n     }\n \n-    Handle getLambdaBridgeMethod(Handle implMethod) {\n+    Handle getLambdaAccessMethod(Handle implMethod) {\n         if (!implMethod.getOwner().equals(className)) {\n             return implMethod;\n         }\n-        // TODO: do not generate a bridge method if the impl method is not private (probably not implementable with a single pass)\n-        String name = \"access$lambda$\" + lambdaBridgesToImplMethods.size();\n+        // TODO: do not generate an access method if the impl method is not private (probably not implementable with a single pass)\n+        String name = \"access$lambda$\" + lambdaAccessToImplMethods.size();\n         String desc = implMethod.getTag() == H_INVOKESTATIC\n                 ? implMethod.getDesc()\n                 : Types.prependArgumentType(Type.getType(\"L\" + className + \";\"), implMethod.getDesc());\n-        Handle bridgeMethod = new Handle(H_INVOKESTATIC, className, name, desc);\n-        lambdaBridgesToImplMethods.put(bridgeMethod, implMethod);\n-        return bridgeMethod;\n+        Handle accessMethod = new Handle(H_INVOKESTATIC, className, name, desc);\n+        lambdaAccessToImplMethods.put(accessMethod, implMethod);\n+        return accessMethod;\n     }\n \n     @Override\n     public void visitEnd() {\n-        for (Map.Entry<Handle, Handle> entry : lambdaBridgesToImplMethods.entrySet()) {\n-            Handle bridgeMethod = entry.getKey();\n+        for (Map.Entry<Handle, Handle> entry : lambdaAccessToImplMethods.entrySet()) {\n+            Handle accessMethod = entry.getKey();\n             Handle implMethod = entry.getValue();\n-            generateLambdaBridgeMethod(bridgeMethod, implMethod);\n+            generateLambdaAccessMethod(accessMethod, implMethod);\n         }\n         super.visitEnd();\n     }\n \n-    private void generateLambdaBridgeMethod(Handle bridge, Handle impl) {\n-        MethodVisitor mv = super.visitMethod(ACC_STATIC | ACC_SYNTHETIC | ACC_BRIDGE,\n-                bridge.getName(), bridge.getDesc(), null, null);\n+    private void generateLambdaAccessMethod(Handle access, Handle impl) {\n+        MethodVisitor mv = super.visitMethod(ACC_STATIC | ACC_SYNTHETIC,\n+                access.getName(), access.getDesc(), null, null);\n         mv.visitCode();\n         int varIndex = 0;\n-        for (Type type : Type.getArgumentTypes(bridge.getDesc())) {\n+        for (Type type : Type.getArgumentTypes(access.getDesc())) {\n             mv.visitVarInsn(type.getOpcode(ILOAD), varIndex);\n             varIndex += type.getSize();\n         }\n         mv.visitMethodInsn(Handles.getOpcode(impl), impl.getOwner(), impl.getName(), impl.getDesc(), impl.getTag() == H_INVOKEINTERFACE);\n-        mv.visitInsn(Type.getReturnType(bridge.getDesc()).getOpcode(IRETURN));\n+        mv.visitInsn(Type.getReturnType(access.getDesc()).getOpcode(IRETURN));\n         mv.visitMaxs(-1, -1); // rely on ClassWriter.COMPUTE_MAXS\n         mv.visitEnd();\n     }\n@@ -148,9 +148,9 @@ public class BackportLambdaInvocations extends ClassVisitor {\n         private void backportLambda(String invokedName, Type invokedType, Handle bsm, Object[] bsmArgs) {\n             Class<?> invoker = loadClass(className);\n             Handle implMethod = (Handle) bsmArgs[1];\n-            Handle bridgeMethod = getLambdaBridgeMethod(implMethod);\n+            Handle accessMethod = getLambdaAccessMethod(implMethod);\n \n-            LambdaFactoryMethod factory = LambdaReifier.reifyLambdaClass(implMethod, bridgeMethod,\n+            LambdaFactoryMethod factory = LambdaReifier.reifyLambdaClass(implMethod, accessMethod,\n                     invoker, invokedName, invokedType, bsm, bsmArgs);\n             super.visitMethodInsn(INVOKESTATIC, factory.getOwner(), factory.getName(), factory.getDesc(), false);\n         }\n"
    },
    {
        "commit_hash": "28e6be7581496dbc20804ad4e6749b4261195a8d",
        "previous_commit_hash": "6aa8427a6ee55682cc146fd79a957c7c30e5919e",
        "diff_stats": {
            "additions": 8,
            "deletions": 8
        },
        "diff_content": "@@ -18,16 +18,16 @@ public class LambdaReifier {\n     // We expect only one class being processed at a time, so it should\n     // be an error if these collections contain more than one element.\n     private static final BlockingDeque<Handle> currentLambdaImplMethod = new LinkedBlockingDeque<>(1);\n-    private static final BlockingDeque<Handle> currentLambdaBridgeMethod = new LinkedBlockingDeque<>(1);\n+    private static final BlockingDeque<Handle> currentLambdaAccessMethod = new LinkedBlockingDeque<>(1);\n     private static final BlockingDeque<Class<?>> currentInvoker = new LinkedBlockingDeque<>(1);\n     private static final BlockingDeque<Type> currentInvokedType = new LinkedBlockingDeque<>(1);\n     private static final BlockingDeque<String> currentLambdaClass = new LinkedBlockingDeque<>(1);\n \n-    public static LambdaFactoryMethod reifyLambdaClass(Handle lambdaImplMethod, Handle lambdaBridgeMethod,\n+    public static LambdaFactoryMethod reifyLambdaClass(Handle lambdaImplMethod, Handle lambdaAccessMethod,\n                                                        Class<?> invoker, String invokedName, Type invokedType, Handle bsm, Object[] bsmArgs) {\n         try {\n             setLambdaImplMethod(lambdaImplMethod);\n-            setLambdaBridgeMethod(lambdaBridgeMethod);\n+            setLambdaAccessMethod(lambdaAccessMethod);\n             setInvoker(invoker);\n             setInvokedType(invokedType);\n \n@@ -49,8 +49,8 @@ public class LambdaReifier {\n         currentLambdaImplMethod.push(lambdaImplMethod);\n     }\n \n-    private static void setLambdaBridgeMethod(Handle lambdaBridgeMethod) {\n-        currentLambdaBridgeMethod.push(lambdaBridgeMethod);\n+    private static void setLambdaAccessMethod(Handle lambdaAccessMethod) {\n+        currentLambdaAccessMethod.push(lambdaAccessMethod);\n     }\n \n     private static void setInvoker(Class<?> lambdaInvoker) {\n@@ -76,8 +76,8 @@ public class LambdaReifier {\n         return currentLambdaImplMethod.getFirst();\n     }\n \n-    public static Handle getLambdaBridgeMethod() {\n-        return currentLambdaBridgeMethod.getFirst();\n+    public static Handle getLambdaAccessMethod() {\n+        return currentLambdaAccessMethod.getFirst();\n     }\n \n     public static LambdaFactoryMethod getLambdaFactoryMethod() {\n@@ -88,7 +88,7 @@ public class LambdaReifier {\n \n     private static void resetGlobals() {\n         currentLambdaImplMethod.clear();\n-        currentLambdaBridgeMethod.clear();\n+        currentLambdaAccessMethod.clear();\n         currentInvoker.clear();\n         currentInvokedType.clear();\n         currentLambdaClass.clear();\n"
    },
    {
        "commit_hash": "b4a6a1bee13f2d18797bc1d09165d0594bd3d9d6",
        "previous_commit_hash": "28e6be7581496dbc20804ad4e6749b4261195a8d",
        "diff_stats": {
            "additions": 12,
            "deletions": 0
        },
        "diff_content": "@@ -20,6 +20,7 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n     private final List<ClassReader> interfaces = new ArrayList<>();\n     private final List<ClassReader> classes = new ArrayList<>();\n     private final Map<Type, List<Type>> interfacesByImplementer = new HashMap<>(); // TODO: could use just String instead of Type\n+    private final Map<String, List<MethodRef>> methodsByInterface = new HashMap<>();\n     private final Map<MethodRef, MethodRef> relocatedMethods = new HashMap<>();\n     private final Map<MethodRef, MethodRef> methodDefaultImpls = new HashMap<>();\n     private final Map<String, String> companionClasses = new HashMap<>();\n@@ -59,10 +60,12 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n \n                 if (isAbstractMethod(access)) {\n                     methodDefaultImpls.put(method, ABSTRACT_METHOD);\n+                    saveInterfaceMethod(method);\n \n                 } else if (isDefaultMethod(access)) {\n                     methodDefaultImpls.put(method, new MethodRef(companion, name, desc));\n                     companionClasses.put(owner, companion);\n+                    saveInterfaceMethod(method);\n \n                 } else if (isStaticMethod(access)) {\n                     relocatedMethods.put(method, new MethodRef(companion, name, desc));\n@@ -71,6 +74,10 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n                 return null;\n             }\n \n+            private void saveInterfaceMethod(MethodRef method) {\n+                methodsByInterface.computeIfAbsent(method.owner, key -> new ArrayList<>()).add(method);\n+            }\n+\n             private boolean isAbstractMethod(int access) {\n                 return Flags.hasFlag(access, ACC_ABSTRACT);\n             }\n@@ -123,6 +130,11 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n         return null;\n     }\n \n+    @Override\n+    public List<MethodRef> getInterfaceMethods(String interfaceName) {\n+        return methodsByInterface.getOrDefault(interfaceName, Collections.emptyList());\n+    }\n+\n     @Override\n     public String getCompanionClass(String className) {\n         return companionClasses.get(className);\n"
    },
    {
        "commit_hash": "b4a6a1bee13f2d18797bc1d09165d0594bd3d9d6",
        "previous_commit_hash": "28e6be7581496dbc20804ad4e6749b4261195a8d",
        "diff_stats": {
            "additions": 4,
            "deletions": 0
        },
        "diff_content": "@@ -4,11 +4,15 @@\n \n package net.orfjackal.retrolambda.interfaces;\n \n+import java.util.List;\n+\n public interface MethodRelocations {\n \n     MethodRef getMethodCallTarget(MethodRef original);\n \n     MethodRef getMethodDefaultImplementation(MethodRef interfaceMethod);\n \n+    List<MethodRef> getInterfaceMethods(String interfaceName);\n+\n     String getCompanionClass(String className);\n }\n"
    },
    {
        "commit_hash": "b4a6a1bee13f2d18797bc1d09165d0594bd3d9d6",
        "previous_commit_hash": "28e6be7581496dbc20804ad4e6749b4261195a8d",
        "diff_stats": {
            "additions": 20,
            "deletions": 9
        },
        "diff_content": "@@ -23,32 +23,43 @@ public class ClassHierarchyAnalyzerTest {\n     private final ClassHierarchyAnalyzer analyzer = new ClassHierarchyAnalyzer();\n \n     @Test\n-    public void separates_interfaces_from_classes() {\n+    public void finds_interfaces_and_classes_separately() {\n         analyze(Interface.class,\n                 InterfaceImplementer.class);\n \n-        assertThat(getInterfaces(), is(classList(Interface.class)));\n-        assertThat(getClasses(), is(classList(InterfaceImplementer.class)));\n+        assertThat(\"interfaces\", getInterfaces(), is(classList(Interface.class)));\n+        assertThat(\"classes\", getClasses(), is(classList(InterfaceImplementer.class)));\n     }\n \n     @Test\n-    public void no_parent_interfaces() {\n-        analyze(Interface.class);\n+    public void finds_implemented_interfaces() {\n+        analyze(Interface.class,\n+                ChildInterface.class,\n+                InterfaceImplementer.class);\n \n-        assertThat(getInterfacesOf(Interface.class), is(empty()));\n+        assertThat(\"Interface\", getInterfacesOf(Interface.class), is(empty()));\n+        assertThat(\"ChildInterface\", getInterfacesOf(ChildInterface.class), is(Arrays.asList(Interface.class)));\n+        assertThat(\"InterfaceImplementer\", getInterfacesOf(InterfaceImplementer.class), is(classList(Interface.class)));\n     }\n \n     @Test\n-    public void immediate_interfaces_implemented_by_a_class() {\n-        analyze(InterfaceImplementer.class);\n+    public void finds_interface_methods() {\n+        analyze(InterfaceMethodTypes.class);\n+\n+        assertThat(analyzer.getInterfaceMethods(Type.getType(InterfaceMethodTypes.class).getInternalName()),\n+                containsInAnyOrder(\n+                        new MethodRef(InterfaceMethodTypes.class, \"abstractMethod\", \"()V\"),\n+                        new MethodRef(InterfaceMethodTypes.class, \"defaultMethod\", \"()V\")));\n \n-        assertThat(getInterfacesOf(InterfaceImplementer.class), is(classList(Interface.class)));\n     }\n \n     private interface Interface {\n         void abstractMethod();\n     }\n \n+    private interface ChildInterface extends Interface {\n+    }\n+\n     private class InterfaceImplementer implements Interface {\n         @Override\n         public void abstractMethod() {\n"
    },
    {
        "commit_hash": "e9cdf9a1bf34c1f1ae960a0f8fac1708cd87ebc9",
        "previous_commit_hash": "b4a6a1bee13f2d18797bc1d09165d0594bd3d9d6",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -38,6 +38,7 @@ public class Transformers {\n                 next = new InterfaceModifier(next, targetVersion);\n             } else if (FeatureToggles.DEFAULT_METHODS == 2) {\n                 next = new UpdateRelocatedMethodInvocations(next, methodRelocations);\n+                next = new AddMethodDefaultImplementations(next, methodRelocations);\n             }\n             next = new BackportLambdaInvocations(next);\n             return next;\n"
    },
    {
        "commit_hash": "e9cdf9a1bf34c1f1ae960a0f8fac1708cd87ebc9",
        "previous_commit_hash": "b4a6a1bee13f2d18797bc1d09165d0594bd3d9d6",
        "diff_stats": {
            "additions": 69,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,69 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.interfaces;\n+\n+import org.objectweb.asm.*;\n+\n+import java.util.*;\n+\n+import static org.objectweb.asm.Opcodes.*;\n+\n+public class AddMethodDefaultImplementations extends ClassVisitor {\n+\n+    private final MethodRelocations methodRelocations;\n+    private String className;\n+    private String[] interfaces;\n+    private final Set<MethodRef> methods = new HashSet<>();\n+\n+    public AddMethodDefaultImplementations(ClassVisitor next, MethodRelocations methodRelocations) {\n+        super(ASM5, next);\n+        this.methodRelocations = methodRelocations;\n+    }\n+\n+    @Override\n+    public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n+        this.className = name;\n+        this.interfaces = interfaces;\n+        super.visit(version, access, name, signature, superName, interfaces);\n+    }\n+\n+    @Override\n+    public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+        methods.add(new MethodRef(className, name, desc));\n+        return super.visitMethod(access, name, desc, signature, exceptions);\n+    }\n+\n+    @Override\n+    public void visitEnd() {\n+        for (String anInterface : interfaces) {\n+            for (MethodRef interfaceMethod : methodRelocations.getInterfaceMethods(anInterface)) {\n+                if (!methods.contains(interfaceMethod.withOwner(className))) {\n+                    generateDefaultImplementation(interfaceMethod);\n+                }\n+            }\n+        }\n+        super.visitEnd();\n+    }\n+\n+    private void generateDefaultImplementation(MethodRef interfaceMethod) {\n+        MethodRef impl = methodRelocations.getMethodDefaultImplementation(interfaceMethod);\n+\n+        // TODO: duplicates net.orfjackal.retrolambda.lambdas.BackportLambdaInvocations.generateLambdaAccessMethod()\n+        // - replace MethodRef with Handle\n+\n+        MethodVisitor mv = super.visitMethod(ACC_PUBLIC | ACC_SYNTHETIC,\n+                interfaceMethod.name, interfaceMethod.desc, null, null);\n+        mv.visitCode();\n+        int varIndex = 0;\n+        for (Type type : Type.getArgumentTypes(impl.desc)) {\n+            mv.visitVarInsn(type.getOpcode(ILOAD), varIndex);\n+            varIndex += type.getSize();\n+        }\n+        mv.visitMethodInsn(INVOKESTATIC, impl.owner, impl.name, impl.desc, false);\n+        mv.visitInsn(Type.getReturnType(interfaceMethod.desc).getOpcode(IRETURN));\n+        mv.visitMaxs(-1, -1); // rely on ClassWriter.COMPUTE_MAXS\n+        mv.visitEnd();\n+    }\n+}\n"
    },
    {
        "commit_hash": "e9cdf9a1bf34c1f1ae960a0f8fac1708cd87ebc9",
        "previous_commit_hash": "b4a6a1bee13f2d18797bc1d09165d0594bd3d9d6",
        "diff_stats": {
            "additions": 8,
            "deletions": 2
        },
        "diff_content": "@@ -4,7 +4,7 @@\n \n package net.orfjackal.retrolambda.interfaces;\n \n-import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.*;\n \n import static org.objectweb.asm.Opcodes.*;\n \n@@ -25,5 +25,11 @@ public class ExtractInterfaceCompanionClass extends ClassVisitor {\n         super.visit(version, access, name, signature, superName, interfaces);\n     }\n \n-    // TODO: remove abstract methods\n+    @Override\n+    public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+        // TODO: remove abstract methods\n+\n+        access |= ACC_STATIC;\n+        return super.visitMethod(access, name, desc, signature, exceptions);\n+    }\n }\n"
    },
    {
        "commit_hash": "e9cdf9a1bf34c1f1ae960a0f8fac1708cd87ebc9",
        "previous_commit_hash": "b4a6a1bee13f2d18797bc1d09165d0594bd3d9d6",
        "diff_stats": {
            "additions": 0,
            "deletions": 7
        },
        "diff_content": "@@ -4,7 +4,6 @@\n \n package net.orfjackal.retrolambda.interfaces;\n \n-import com.google.common.base.Preconditions;\n import org.objectweb.asm.*;\n \n import static org.objectweb.asm.Opcodes.ASM5;\n@@ -16,12 +15,6 @@ public class UpdateRelocatedMethodInvocations extends ClassVisitor {\n     public UpdateRelocatedMethodInvocations(ClassVisitor next, MethodRelocations methodRelocations) {\n         super(ASM5, next);\n         this.methodRelocations = methodRelocations;\n-        Preconditions.checkNotNull(methodRelocations);\n-    }\n-\n-    @Override\n-    public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n-        super.visit(version, access, name, signature, superName, interfaces);\n     }\n \n     @Override\n"
    },
    {
        "commit_hash": "f6d918533f73c066722d2bf435fa436d561684f5",
        "previous_commit_hash": "e9cdf9a1bf34c1f1ae960a0f8fac1708cd87ebc9",
        "diff_stats": {
            "additions": 2,
            "deletions": 16
        },
        "diff_content": "@@ -4,6 +4,7 @@\n \n package net.orfjackal.retrolambda.interfaces;\n \n+import net.orfjackal.retrolambda.util.Bytecode;\n import org.objectweb.asm.*;\n \n import java.util.*;\n@@ -49,21 +50,6 @@ public class AddMethodDefaultImplementations extends ClassVisitor {\n \n     private void generateDefaultImplementation(MethodRef interfaceMethod) {\n         MethodRef impl = methodRelocations.getMethodDefaultImplementation(interfaceMethod);\n-\n-        // TODO: duplicates net.orfjackal.retrolambda.lambdas.BackportLambdaInvocations.generateLambdaAccessMethod()\n-        // - replace MethodRef with Handle\n-\n-        MethodVisitor mv = super.visitMethod(ACC_PUBLIC | ACC_SYNTHETIC,\n-                interfaceMethod.name, interfaceMethod.desc, null, null);\n-        mv.visitCode();\n-        int varIndex = 0;\n-        for (Type type : Type.getArgumentTypes(impl.desc)) {\n-            mv.visitVarInsn(type.getOpcode(ILOAD), varIndex);\n-            varIndex += type.getSize();\n-        }\n-        mv.visitMethodInsn(INVOKESTATIC, impl.owner, impl.name, impl.desc, false);\n-        mv.visitInsn(Type.getReturnType(interfaceMethod.desc).getOpcode(IRETURN));\n-        mv.visitMaxs(-1, -1); // rely on ClassWriter.COMPUTE_MAXS\n-        mv.visitEnd();\n+        Bytecode.generateDelegateMethod(cv, ACC_PUBLIC | ACC_SYNTHETIC, interfaceMethod.toHandle(H_INVOKEVIRTUAL), impl.toHandle(H_INVOKESTATIC));\n     }\n }\n"
    },
    {
        "commit_hash": "f6d918533f73c066722d2bf435fa436d561684f5",
        "previous_commit_hash": "e9cdf9a1bf34c1f1ae960a0f8fac1708cd87ebc9",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -4,7 +4,7 @@\n \n package net.orfjackal.retrolambda.interfaces;\n \n-import net.orfjackal.retrolambda.Flags;\n+import net.orfjackal.retrolambda.util.Flags;\n import org.objectweb.asm.*;\n \n import java.util.*;\n"
    },
    {
        "commit_hash": "f6d918533f73c066722d2bf435fa436d561684f5",
        "previous_commit_hash": "e9cdf9a1bf34c1f1ae960a0f8fac1708cd87ebc9",
        "diff_stats": {
            "additions": 12,
            "deletions": 4
        },
        "diff_content": "@@ -4,11 +4,15 @@\n \n package net.orfjackal.retrolambda.interfaces;\n \n-import com.google.common.base.Objects;\n-import org.objectweb.asm.Type;\n+import com.google.common.base.MoreObjects;\n+import org.objectweb.asm.*;\n+\n+import java.util.Objects;\n \n public final class MethodRef {\n \n+    // TODO: replace MethodRef with ASM's Handle\n+\n     public final String owner;\n     public final String name;\n     public final String desc;\n@@ -27,6 +31,10 @@ public final class MethodRef {\n         return new MethodRef(newOwner, name, desc);\n     }\n \n+    public Handle toHandle(int tag) {\n+        return new Handle(tag, owner, name, desc);\n+    }\n+\n     @Override\n     public boolean equals(Object obj) {\n         if (!(obj instanceof MethodRef)) {\n@@ -40,12 +48,12 @@ public final class MethodRef {\n \n     @Override\n     public int hashCode() {\n-        return Objects.hashCode(owner, name, desc);\n+        return Objects.hash(owner, name, desc);\n     }\n \n     @Override\n     public String toString() {\n-        return Objects.toStringHelper(this)\n+        return MoreObjects.toStringHelper(this)\n                 .addValue(owner)\n                 .addValue(name)\n                 .addValue(desc)\n"
    },
    {
        "commit_hash": "f6d918533f73c066722d2bf435fa436d561684f5",
        "previous_commit_hash": "e9cdf9a1bf34c1f1ae960a0f8fac1708cd87ebc9",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -4,7 +4,7 @@\n \n package net.orfjackal.retrolambda.interfaces;\n \n-import net.orfjackal.retrolambda.Flags;\n+import net.orfjackal.retrolambda.util.Flags;\n import org.objectweb.asm.*;\n import org.objectweb.asm.tree.MethodNode;\n \n"
    },
    {
        "commit_hash": "f6d918533f73c066722d2bf435fa436d561684f5",
        "previous_commit_hash": "e9cdf9a1bf34c1f1ae960a0f8fac1708cd87ebc9",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -4,7 +4,7 @@\n \n package net.orfjackal.retrolambda.interfaces;\n \n-import net.orfjackal.retrolambda.Flags;\n+import net.orfjackal.retrolambda.util.Flags;\n import org.objectweb.asm.*;\n \n import static org.objectweb.asm.Opcodes.*;\n"
    },
    {
        "commit_hash": "f6d918533f73c066722d2bf435fa436d561684f5",
        "previous_commit_hash": "e9cdf9a1bf34c1f1ae960a0f8fac1708cd87ebc9",
        "diff_stats": {
            "additions": 3,
            "deletions": 17
        },
        "diff_content": "@@ -4,7 +4,8 @@\n \n package net.orfjackal.retrolambda.lambdas;\n \n-import net.orfjackal.retrolambda.*;\n+import net.orfjackal.retrolambda.FeatureToggles;\n+import net.orfjackal.retrolambda.util.*;\n import org.objectweb.asm.*;\n \n import java.lang.reflect.Field;\n@@ -109,26 +110,11 @@ public class BackportLambdaInvocations extends ClassVisitor {\n         for (Map.Entry<Handle, Handle> entry : lambdaAccessToImplMethods.entrySet()) {\n             Handle accessMethod = entry.getKey();\n             Handle implMethod = entry.getValue();\n-            generateLambdaAccessMethod(accessMethod, implMethod);\n+            Bytecode.generateDelegateMethod(cv, ACC_STATIC | ACC_SYNTHETIC, accessMethod, implMethod);\n         }\n         super.visitEnd();\n     }\n \n-    private void generateLambdaAccessMethod(Handle access, Handle impl) {\n-        MethodVisitor mv = super.visitMethod(ACC_STATIC | ACC_SYNTHETIC,\n-                access.getName(), access.getDesc(), null, null);\n-        mv.visitCode();\n-        int varIndex = 0;\n-        for (Type type : Type.getArgumentTypes(access.getDesc())) {\n-            mv.visitVarInsn(type.getOpcode(ILOAD), varIndex);\n-            varIndex += type.getSize();\n-        }\n-        mv.visitMethodInsn(Handles.getOpcode(impl), impl.getOwner(), impl.getName(), impl.getDesc(), impl.getTag() == H_INVOKEINTERFACE);\n-        mv.visitInsn(Type.getReturnType(access.getDesc()).getOpcode(IRETURN));\n-        mv.visitMaxs(-1, -1); // rely on ClassWriter.COMPUTE_MAXS\n-        mv.visitEnd();\n-    }\n-\n \n     private class InvokeDynamicInsnConverter extends MethodVisitor {\n \n"
    },
    {
        "commit_hash": "f6d918533f73c066722d2bf435fa436d561684f5",
        "previous_commit_hash": "e9cdf9a1bf34c1f1ae960a0f8fac1708cd87ebc9",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -4,7 +4,7 @@\n \n package net.orfjackal.retrolambda.lambdas;\n \n-import net.orfjackal.retrolambda.Flags;\n+import net.orfjackal.retrolambda.util.Flags;\n \n import java.util.regex.Pattern;\n \n"
    },
    {
        "commit_hash": "f6d918533f73c066722d2bf435fa436d561684f5",
        "previous_commit_hash": "e9cdf9a1bf34c1f1ae960a0f8fac1708cd87ebc9",
        "diff_stats": {
            "additions": 27,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,27 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.util;\n+\n+import net.orfjackal.retrolambda.lambdas.Handles;\n+import org.objectweb.asm.*;\n+\n+import static org.objectweb.asm.Opcodes.*;\n+\n+public class Bytecode {\n+\n+    public static void generateDelegateMethod(ClassVisitor cv, int access, Handle method, Handle target) {\n+        MethodVisitor mv = cv.visitMethod(access, method.getName(), method.getDesc(), null, null);\n+        mv.visitCode();\n+        int varIndex = 0;\n+        for (Type type : Type.getArgumentTypes(method.getDesc())) {\n+            mv.visitVarInsn(type.getOpcode(ILOAD), varIndex);\n+            varIndex += type.getSize();\n+        }\n+        mv.visitMethodInsn(Handles.getOpcode(target), target.getOwner(), target.getName(), target.getDesc(), target.getTag() == H_INVOKEINTERFACE);\n+        mv.visitInsn(Type.getReturnType(method.getDesc()).getOpcode(IRETURN));\n+        mv.visitMaxs(-1, -1); // rely on ClassWriter.COMPUTE_MAXS\n+        mv.visitEnd();\n+    }\n+}\n"
    },
    {
        "commit_hash": "f6d918533f73c066722d2bf435fa436d561684f5",
        "previous_commit_hash": "e9cdf9a1bf34c1f1ae960a0f8fac1708cd87ebc9",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -2,7 +2,7 @@\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n-package net.orfjackal.retrolambda;\n+package net.orfjackal.retrolambda.util;\n \n public class Flags {\n \n"
    },
    {
        "commit_hash": "de9ad6815f0bb46d36d60835388e613037631003",
        "previous_commit_hash": "f6d918533f73c066722d2bf435fa436d561684f5",
        "diff_stats": {
            "additions": 9,
            "deletions": 2
        },
        "diff_content": "@@ -102,7 +102,7 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n     }\n \n     public List<Type> getInterfacesOf(Type type) {\n-        return interfacesByImplementer.get(type);\n+        return interfacesByImplementer.getOrDefault(type, Collections.emptyList());\n     }\n \n     @Override\n@@ -132,7 +132,14 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n \n     @Override\n     public List<MethodRef> getInterfaceMethods(String interfaceName) {\n-        return methodsByInterface.getOrDefault(interfaceName, Collections.emptyList());\n+        Set<MethodRef> results = new LinkedHashSet<>();\n+        results.addAll(methodsByInterface.getOrDefault(interfaceName, Collections.emptyList()));\n+        for (Type parent : getInterfacesOf(Type.getObjectType(interfaceName))) {\n+            for (MethodRef parentMethod : getInterfaceMethods(parent.getInternalName())) {\n+                results.add(parentMethod.withOwner(interfaceName));\n+            }\n+        }\n+        return new ArrayList<>(results);\n     }\n \n     @Override\n"
    },
    {
        "commit_hash": "de9ad6815f0bb46d36d60835388e613037631003",
        "previous_commit_hash": "f6d918533f73c066722d2bf435fa436d561684f5",
        "diff_stats": {
            "additions": 21,
            "deletions": 3
        },
        "diff_content": "@@ -46,11 +46,25 @@ public class ClassHierarchyAnalyzerTest {\n     public void finds_interface_methods() {\n         analyze(InterfaceMethodTypes.class);\n \n-        assertThat(analyzer.getInterfaceMethods(Type.getType(InterfaceMethodTypes.class).getInternalName()),\n+        assertThat(analyzer.getInterfaceMethods(getInternalName(InterfaceMethodTypes.class)),\n                 containsInAnyOrder(\n                         new MethodRef(InterfaceMethodTypes.class, \"abstractMethod\", \"()V\"),\n-                        new MethodRef(InterfaceMethodTypes.class, \"defaultMethod\", \"()V\")));\n+                        new MethodRef(InterfaceMethodTypes.class, \"defaultMethod\", \"()V\"))); // all but staticMethod\n+    }\n+\n+    @Test\n+    public void finds_inherited_interface_methods() {\n+        analyze(ChildInterface.class,\n+                Interface.class);\n \n+        assertThat(analyzer.getInterfaceMethods(getInternalName(ChildInterface.class)),\n+                containsInAnyOrder(\n+                        new MethodRef(ChildInterface.class, \"abstractMethod\", \"()V\")));\n+    }\n+\n+    @Test\n+    public void does_not_find_interface_methods_of_not_analyzed_interfaces() {\n+        assertThat(analyzer.getInterfaceMethods(getInternalName(Interface.class)), is(empty()));\n     }\n \n     private interface Interface {\n@@ -291,10 +305,14 @@ public class ClassHierarchyAnalyzerTest {\n     }\n \n     private static byte[] readBytecode(Class<?> clazz) {\n-        try (InputStream in = clazz.getResourceAsStream(\"/\" + Type.getType(clazz).getInternalName() + \".class\")) {\n+        try (InputStream in = clazz.getResourceAsStream(\"/\" + getInternalName(clazz) + \".class\")) {\n             return ByteStreams.toByteArray(in);\n         } catch (IOException e) {\n             throw new RuntimeException(e);\n         }\n     }\n+\n+    private static String getInternalName(Class<?> clazz) {\n+        return Type.getType(clazz).getInternalName();\n+    }\n }\n"
    },
    {
        "commit_hash": "29dbe422f4c3429741454ca12650f7e584f0c22e",
        "previous_commit_hash": "de9ad6815f0bb46d36d60835388e613037631003",
        "diff_stats": {
            "additions": 4,
            "deletions": 2
        },
        "diff_content": "@@ -4,6 +4,7 @@\n \n package net.orfjackal.retrolambda.interfaces;\n \n+import net.orfjackal.retrolambda.util.Flags;\n import org.objectweb.asm.*;\n \n import static org.objectweb.asm.Opcodes.*;\n@@ -27,8 +28,9 @@ public class ExtractInterfaceCompanionClass extends ClassVisitor {\n \n     @Override\n     public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n-        // TODO: remove abstract methods\n-\n+        if (Flags.hasFlag(access, ACC_ABSTRACT)) {\n+            return null;\n+        }\n         access |= ACC_STATIC;\n         return super.visitMethod(access, name, desc, signature, exceptions);\n     }\n"
    },
    {
        "commit_hash": "73dfdbb233c184d5da4fca91de2ddc70cf3f1d29",
        "previous_commit_hash": "29dbe422f4c3429741454ca12650f7e584f0c22e",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -25,6 +25,7 @@ public class Transformers {\n                 next = new ClassModifier(targetVersion, next);\n             } else if (FeatureToggles.DEFAULT_METHODS == 2) {\n                 next = new UpdateRelocatedMethodInvocations(next, methodRelocations);\n+                next = new AddMethodDefaultImplementations(next, methodRelocations);\n             }\n             next = new BackportLambdaClass(next);\n             return next;\n"
    },
    {
        "commit_hash": "baf8c1cb739f8d5179330b96c8a08a4ee73399ad",
        "previous_commit_hash": "73dfdbb233c184d5da4fca91de2ddc70cf3f1d29",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n             <list>\n               <option value=\"clean\" />\n               <option value=\"verify\" />\n-              <option value=\"-e\" />\n+              <option value=\"-Dmaven.test.redirectTestOutputToFile=false\" />\n             </list>\n           </option>\n           <option name=\"profilesMap\">\n"
    },
    {
        "commit_hash": "baf8c1cb739f8d5179330b96c8a08a4ee73399ad",
        "previous_commit_hash": "73dfdbb233c184d5da4fca91de2ddc70cf3f1d29",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -26,7 +26,7 @@\n             <list>\n               <option value=\"clean\" />\n               <option value=\"verify\" />\n-              <option value=\"-e\" />\n+              <option value=\"-Dmaven.test.redirectTestOutputToFile=false\" />\n             </list>\n           </option>\n           <option name=\"profilesMap\">\n"
    },
    {
        "commit_hash": "baf8c1cb739f8d5179330b96c8a08a4ee73399ad",
        "previous_commit_hash": "73dfdbb233c184d5da4fca91de2ddc70cf3f1d29",
        "diff_stats": {
            "additions": 3,
            "deletions": 0
        },
        "diff_content": "@@ -154,6 +154,9 @@ Version History\n   ([Issue #31](https://github.com/orfjackal/retrolambda/issues/31))\n   - *Experimental! Can be enabled with the enviroment variable\n     DEFAULT_METHODS=2*\n+- Backports try-with-resources statements to Java 6 and older by removing\n+  calls to `Throwable.addSuppressed`\n+  ([Issue #38](https://github.com/orfjackal/retrolambda/issues/38))\n \n ### Retrolambda 1.7.0 (2014-10-21)\n \n"
    },
    {
        "commit_hash": "baf8c1cb739f8d5179330b96c8a08a4ee73399ad",
        "previous_commit_hash": "73dfdbb233c184d5da4fca91de2ddc70cf3f1d29",
        "diff_stats": {
            "additions": 49,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,49 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.test;\n+\n+import org.apache.commons.lang.SystemUtils;\n+import org.junit.Test;\n+\n+import java.io.Closeable;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.*;\n+\n+public class TryWithResourcesTest {\n+\n+    @Test\n+    public void suppressed_exceptions() {\n+        try {\n+            try (ThrowSecondaryExceptionOnClose c = new ThrowSecondaryExceptionOnClose()) {\n+                throw new PrimaryException();\n+            }\n+\n+        } catch (Exception e) {\n+            assertThat(\"thrown\", e, is(instanceOf(PrimaryException.class)));\n+            assertThat(\"cause\", e.getCause(), is(nullValue()));\n+\n+            // On Java 6 and lower we will swallow the suppressed exception, because the API does not exist,\n+            // but on Java 7 we want to keep the original behavior.\n+            if (SystemUtils.isJavaVersionAtLeast(1.7f)) {\n+                assertThat(\"suppressed\", e.getSuppressed(), arrayContaining(instanceOf(SecondaryException.class)));\n+            }\n+        }\n+    }\n+\n+\n+    private static class PrimaryException extends RuntimeException {\n+    }\n+\n+    private static class SecondaryException extends RuntimeException {\n+    }\n+\n+    private static class ThrowSecondaryExceptionOnClose implements Closeable {\n+        @Override\n+        public void close() {\n+            throw new SecondaryException();\n+        }\n+    }\n+}\n"
    },
    {
        "commit_hash": "baf8c1cb739f8d5179330b96c8a08a4ee73399ad",
        "previous_commit_hash": "73dfdbb233c184d5da4fca91de2ddc70cf3f1d29",
        "diff_stats": {
            "additions": 5,
            "deletions": 1
        },
        "diff_content": "@@ -7,6 +7,7 @@ package net.orfjackal.retrolambda;\n import net.orfjackal.retrolambda.defaultmethods.*;\n import net.orfjackal.retrolambda.interfaces.*;\n import net.orfjackal.retrolambda.lambdas.*;\n+import net.orfjackal.retrolambda.trywithresources.SwallowSuppressedExceptions;\n import org.objectweb.asm.*;\n \n public class Transformers {\n@@ -80,7 +81,10 @@ public class Transformers {\n         ClassVisitor next = writer;\n \n         next = new LowerBytecodeVersion(next, targetVersion);\n-        next = new FixInvokeStaticOnInterfaceMethod(next);\n+        if (targetVersion < Opcodes.V1_7) {\n+            next = new SwallowSuppressedExceptions(next);\n+        }\n+        next = new FixInvokeStaticOnInterfaceMethod(next); // TODO: remove me?\n         next = chain.wrap(next);\n \n         reader.accept(next, 0);\n"
    },
    {
        "commit_hash": "baf8c1cb739f8d5179330b96c8a08a4ee73399ad",
        "previous_commit_hash": "73dfdbb233c184d5da4fca91de2ddc70cf3f1d29",
        "diff_stats": {
            "additions": 35,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,35 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.trywithresources;\n+\n+import org.objectweb.asm.*;\n+\n+import static org.objectweb.asm.Opcodes.ASM5;\n+\n+public class SwallowSuppressedExceptions extends ClassVisitor {\n+\n+    public SwallowSuppressedExceptions(ClassVisitor next) {\n+        super(ASM5, next);\n+    }\n+\n+    @Override\n+    public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+        MethodVisitor next = super.visitMethod(access, name, desc, signature, exceptions);\n+        return new MethodVisitor(ASM5, next) {\n+            @Override\n+            public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\n+                if (opcode == Opcodes.INVOKEVIRTUAL\n+                        && owner.equals(\"java/lang/Throwable\")\n+                        && name.equals(\"addSuppressed\")\n+                        && desc.equals(\"(Ljava/lang/Throwable;)V\")) {\n+                    super.visitInsn(Opcodes.POP); // the suppressed exception\n+                    super.visitInsn(Opcodes.POP); // the original exception\n+                } else {\n+                    super.visitMethodInsn(opcode, owner, name, desc, itf);\n+                }\n+            }\n+        };\n+    }\n+}\n"
    },
    {
        "commit_hash": "4142ede396f4e4385c57afcee7c33a7f4e1c9da7",
        "previous_commit_hash": "baf8c1cb739f8d5179330b96c8a08a4ee73399ad",
        "diff_stats": {
            "additions": 4,
            "deletions": 1
        },
        "diff_content": "@@ -37,7 +37,7 @@ To run Retrolambda using Maven, add the following to your pom.xml:\n <plugin>\n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>retrolambda-maven-plugin</artifactId>\n-    <version>1.7.0</version>\n+    <version>1.8.0</version>\n     <executions>\n         <execution>\n             <goals>\n@@ -154,6 +154,9 @@ Version History\n   ([Issue #31](https://github.com/orfjackal/retrolambda/issues/31))\n   - *Experimental! Can be enabled with the enviroment variable\n     DEFAULT_METHODS=2*\n+\n+### Retrolambda 1.8.0 (2014-11-16)\n+\n - Backports try-with-resources statements to Java 6 and older by removing\n   calls to `Throwable.addSuppressed`\n   ([Issue #38](https://github.com/orfjackal/retrolambda/issues/38))\n"
    },
    {
        "commit_hash": "4142ede396f4e4385c57afcee7c33a7f4e1c9da7",
        "previous_commit_hash": "baf8c1cb739f8d5179330b96c8a08a4ee73399ad",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.7.1-SNAPSHOT</version>\n+        <version>1.8.0</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "4142ede396f4e4385c57afcee7c33a7f4e1c9da7",
        "previous_commit_hash": "baf8c1cb739f8d5179330b96c8a08a4ee73399ad",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>1.7.1-SNAPSHOT</version>\n+    <version>1.8.0</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "4142ede396f4e4385c57afcee7c33a7f4e1c9da7",
        "previous_commit_hash": "baf8c1cb739f8d5179330b96c8a08a4ee73399ad",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.7.1-SNAPSHOT</version>\n+        <version>1.8.0</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "4142ede396f4e4385c57afcee7c33a7f4e1c9da7",
        "previous_commit_hash": "baf8c1cb739f8d5179330b96c8a08a4ee73399ad",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.7.1-SNAPSHOT</version>\n+        <version>1.8.0</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "4142ede396f4e4385c57afcee7c33a7f4e1c9da7",
        "previous_commit_hash": "baf8c1cb739f8d5179330b96c8a08a4ee73399ad",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.7.1-SNAPSHOT</version>\n+        <version>1.8.0</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "4c26a35578aeb3046c152734ad0e2b6127e5ef10",
        "previous_commit_hash": "4142ede396f4e4385c57afcee7c33a7f4e1c9da7",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.8.0</version>\n+        <version>1.8.1-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "4c26a35578aeb3046c152734ad0e2b6127e5ef10",
        "previous_commit_hash": "4142ede396f4e4385c57afcee7c33a7f4e1c9da7",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>1.8.0</version>\n+    <version>1.8.1-SNAPSHOT</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "4c26a35578aeb3046c152734ad0e2b6127e5ef10",
        "previous_commit_hash": "4142ede396f4e4385c57afcee7c33a7f4e1c9da7",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.8.0</version>\n+        <version>1.8.1-SNAPSHOT</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "4c26a35578aeb3046c152734ad0e2b6127e5ef10",
        "previous_commit_hash": "4142ede396f4e4385c57afcee7c33a7f4e1c9da7",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.8.0</version>\n+        <version>1.8.1-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "4c26a35578aeb3046c152734ad0e2b6127e5ef10",
        "previous_commit_hash": "4142ede396f4e4385c57afcee7c33a7f4e1c9da7",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.8.0</version>\n+        <version>1.8.1-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "6d6b419b366769a217214657ab1133477f8a6934",
        "previous_commit_hash": "4c26a35578aeb3046c152734ad0e2b6127e5ef10",
        "diff_stats": {
            "additions": 2,
            "deletions": 1
        },
        "diff_content": "@@ -4,7 +4,7 @@\n \n package net.orfjackal.retrolambda.interfaces;\n \n-import net.orfjackal.retrolambda.util.Flags;\n+import net.orfjackal.retrolambda.util.*;\n import org.objectweb.asm.*;\n \n import java.util.*;\n@@ -63,6 +63,7 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n                     saveInterfaceMethod(method);\n \n                 } else if (isDefaultMethod(access)) {\n+                    desc = Bytecode.prependArgumentType(desc, Type.getObjectType(owner));\n                     methodDefaultImpls.put(method, new MethodRef(companion, name, desc));\n                     companionClasses.put(owner, companion);\n                     saveInterfaceMethod(method);\n"
    },
    {
        "commit_hash": "6d6b419b366769a217214657ab1133477f8a6934",
        "previous_commit_hash": "4c26a35578aeb3046c152734ad0e2b6127e5ef10",
        "diff_stats": {
            "additions": 10,
            "deletions": 2
        },
        "diff_content": "@@ -4,7 +4,7 @@\n \n package net.orfjackal.retrolambda.interfaces;\n \n-import net.orfjackal.retrolambda.util.Flags;\n+import net.orfjackal.retrolambda.util.*;\n import org.objectweb.asm.*;\n \n import static org.objectweb.asm.Opcodes.*;\n@@ -12,6 +12,7 @@ import static org.objectweb.asm.Opcodes.*;\n public class ExtractInterfaceCompanionClass extends ClassVisitor {\n \n     private final String companion;\n+    private String interfaceName;\n \n     public ExtractInterfaceCompanionClass(ClassVisitor next, String companion) {\n         super(ASM5, next);\n@@ -20,6 +21,7 @@ public class ExtractInterfaceCompanionClass extends ClassVisitor {\n \n     @Override\n     public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n+        interfaceName = name;\n         name = companion;\n         access &= ~ACC_INTERFACE;\n         access &= ~ACC_ABSTRACT;\n@@ -29,9 +31,15 @@ public class ExtractInterfaceCompanionClass extends ClassVisitor {\n     @Override\n     public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n         if (Flags.hasFlag(access, ACC_ABSTRACT)) {\n+            // do not copy abstract methods to the companion class\n             return null;\n         }\n-        access |= ACC_STATIC;\n+        if (!Flags.hasFlag(access, ACC_STATIC)) {\n+            // default method; make static and take 'this' as the first argument\n+            access |= ACC_STATIC;\n+            // TODO: this adding of the first argument is duplicated in ClassHierarchyAnalyzer\n+            desc = Bytecode.prependArgumentType(desc, Type.getObjectType(interfaceName));\n+        }\n         return super.visitMethod(access, name, desc, signature, exceptions);\n     }\n }\n"
    },
    {
        "commit_hash": "6d6b419b366769a217214657ab1133477f8a6934",
        "previous_commit_hash": "4c26a35578aeb3046c152734ad0e2b6127e5ef10",
        "diff_stats": {
            "additions": 23,
            "deletions": 3
        },
        "diff_content": "@@ -14,14 +14,34 @@ public class Bytecode {\n     public static void generateDelegateMethod(ClassVisitor cv, int access, Handle method, Handle target) {\n         MethodVisitor mv = cv.visitMethod(access, method.getName(), method.getDesc(), null, null);\n         mv.visitCode();\n+\n+        // we assume one of the methods to be static and the other virtual, i.e. it has an implicit 'this' argument\n+        Type[] args = longest(\n+                Type.getArgumentTypes(method.getDesc()),\n+                Type.getArgumentTypes(target.getDesc()));\n         int varIndex = 0;\n-        for (Type type : Type.getArgumentTypes(method.getDesc())) {\n-            mv.visitVarInsn(type.getOpcode(ILOAD), varIndex);\n-            varIndex += type.getSize();\n+        for (Type arg : args) {\n+            mv.visitVarInsn(arg.getOpcode(ILOAD), varIndex);\n+            varIndex += arg.getSize();\n         }\n         mv.visitMethodInsn(Handles.getOpcode(target), target.getOwner(), target.getName(), target.getDesc(), target.getTag() == H_INVOKEINTERFACE);\n         mv.visitInsn(Type.getReturnType(method.getDesc()).getOpcode(IRETURN));\n         mv.visitMaxs(-1, -1); // rely on ClassWriter.COMPUTE_MAXS\n         mv.visitEnd();\n     }\n+\n+    private static Type[] longest(Type[] t1, Type[] t2) {\n+        return t1.length > t2.length ? t1 : t2;\n+    }\n+\n+    public static String prependArgumentType(String desc, Type type) {\n+        Type returnType = Type.getReturnType(desc);\n+        Type[] args = Type.getArgumentTypes(desc);\n+\n+        Type[] newArgs = new Type[args.length + 1];\n+        newArgs[0] = type;\n+        System.arraycopy(args, 0, newArgs, 1, args.length);\n+\n+        return Type.getMethodDescriptor(returnType, newArgs);\n+    }\n }\n"
    },
    {
        "commit_hash": "6d6b419b366769a217214657ab1133477f8a6934",
        "previous_commit_hash": "4c26a35578aeb3046c152734ad0e2b6127e5ef10",
        "diff_stats": {
            "additions": 24,
            "deletions": 16
        },
        "diff_content": "@@ -11,6 +11,7 @@ import org.objectweb.asm.*;\n \n import java.io.*;\n import java.util.*;\n+import java.util.stream.Stream;\n \n import static java.util.Arrays.asList;\n import static java.util.stream.Collectors.toList;\n@@ -48,8 +49,8 @@ public class ClassHierarchyAnalyzerTest {\n \n         assertThat(analyzer.getInterfaceMethods(getInternalName(InterfaceMethodTypes.class)),\n                 containsInAnyOrder(\n-                        new MethodRef(InterfaceMethodTypes.class, \"abstractMethod\", \"()V\"),\n-                        new MethodRef(InterfaceMethodTypes.class, \"defaultMethod\", \"()V\"))); // all but staticMethod\n+                        new MethodRef(InterfaceMethodTypes.class, \"abstractMethod\", voidMethod()),\n+                        new MethodRef(InterfaceMethodTypes.class, \"defaultMethod\", voidMethod()))); // all but staticMethod\n     }\n \n     @Test\n@@ -59,7 +60,7 @@ public class ClassHierarchyAnalyzerTest {\n \n         assertThat(analyzer.getInterfaceMethods(getInternalName(ChildInterface.class)),\n                 containsInAnyOrder(\n-                        new MethodRef(ChildInterface.class, \"abstractMethod\", \"()V\")));\n+                        new MethodRef(ChildInterface.class, \"abstractMethod\", voidMethod())));\n     }\n \n     @Test\n@@ -87,7 +88,7 @@ public class ClassHierarchyAnalyzerTest {\n     public void abstract_methods_on_interfaces_are_not_relocated() {\n         analyze(InterfaceMethodTypes.class);\n \n-        MethodRef source = new MethodRef(InterfaceMethodTypes.class, \"abstractMethod\", \"()V\");\n+        MethodRef source = new MethodRef(InterfaceMethodTypes.class, \"abstractMethod\", voidMethod());\n         MethodRef target = analyzer.getMethodCallTarget(source);\n \n         assertThat(target, is(source));\n@@ -97,7 +98,7 @@ public class ClassHierarchyAnalyzerTest {\n     public void default_methods_on_interfaces_are_not_relocated() {\n         analyze(InterfaceMethodTypes.class);\n \n-        MethodRef source = new MethodRef(InterfaceMethodTypes.class, \"defaultMethod\", \"()V\");\n+        MethodRef source = new MethodRef(InterfaceMethodTypes.class, \"defaultMethod\", voidMethod());\n         MethodRef target = analyzer.getMethodCallTarget(source);\n \n         assertThat(target, is(source));\n@@ -107,17 +108,17 @@ public class ClassHierarchyAnalyzerTest {\n     public void static_methods_on_interfaces_are_relocated_to_companion_classes() {\n         analyze(InterfaceMethodTypes.class);\n \n-        MethodRef source = new MethodRef(InterfaceMethodTypes.class, \"staticMethod\", \"()V\");\n+        MethodRef source = new MethodRef(InterfaceMethodTypes.class, \"staticMethod\", voidMethod());\n         MethodRef target = analyzer.getMethodCallTarget(source);\n \n-        assertThat(target, is(new MethodRef(InterfaceMethodTypes$.class, \"staticMethod\", \"()V\")));\n+        assertThat(target, is(new MethodRef(InterfaceMethodTypes$.class, \"staticMethod\", voidMethod())));\n     }\n \n     @Test\n     public void static_methods_on_classes_are_not_relocated() {\n         analyze(ClassMethodTypes.class);\n \n-        MethodRef source = new MethodRef(ClassMethodTypes.class, \"staticMethod\", \"()V\");\n+        MethodRef source = new MethodRef(ClassMethodTypes.class, \"staticMethod\", voidMethod());\n         MethodRef target = analyzer.getMethodCallTarget(source);\n \n         assertThat(target, is(source));\n@@ -153,7 +154,7 @@ public class ClassHierarchyAnalyzerTest {\n     public void abstract_methods_have_no_implementation() {\n         analyze(HasDefaultMethods.class);\n \n-        MethodRef method = new MethodRef(HasDefaultMethods.class, \"abstractMethod\", \"()V\");\n+        MethodRef method = new MethodRef(HasDefaultMethods.class, \"abstractMethod\", voidMethod());\n         MethodRef impl = analyzer.getMethodDefaultImplementation(method);\n \n         assertThat(impl, is(nullValue()));\n@@ -163,10 +164,10 @@ public class ClassHierarchyAnalyzerTest {\n     public void default_method_implementation_is_moved_to_companion_class() {\n         analyze(HasDefaultMethods.class);\n \n-        MethodRef method = new MethodRef(HasDefaultMethods.class, \"defaultMethod\", \"()V\");\n+        MethodRef method = new MethodRef(HasDefaultMethods.class, \"defaultMethod\", voidMethod());\n         MethodRef impl = analyzer.getMethodDefaultImplementation(method);\n \n-        assertThat(impl, is(new MethodRef(HasDefaultMethods$.class, \"defaultMethod\", \"()V\")));\n+        assertThat(impl, is(new MethodRef(HasDefaultMethods$.class, \"defaultMethod\", voidMethod(HasDefaultMethods.class))));\n     }\n \n     @Test\n@@ -174,10 +175,10 @@ public class ClassHierarchyAnalyzerTest {\n         analyze(HasDefaultMethods.class,\n                 DoesNotOverrideDefaultMethods.class);\n \n-        MethodRef method = new MethodRef(DoesNotOverrideDefaultMethods.class, \"defaultMethod\", \"()V\");\n+        MethodRef method = new MethodRef(DoesNotOverrideDefaultMethods.class, \"defaultMethod\", voidMethod());\n         MethodRef impl = analyzer.getMethodDefaultImplementation(method);\n \n-        assertThat(impl, is(new MethodRef(HasDefaultMethods$.class, \"defaultMethod\", \"()V\")));\n+        assertThat(impl, is(new MethodRef(HasDefaultMethods$.class, \"defaultMethod\", voidMethod(HasDefaultMethods.class))));\n     }\n \n     @Test\n@@ -185,10 +186,10 @@ public class ClassHierarchyAnalyzerTest {\n         analyze(HasDefaultMethods.class,\n                 OverridesDefaultMethods.class);\n \n-        MethodRef method = new MethodRef(OverridesDefaultMethods.class, \"defaultMethod\", \"()V\");\n+        MethodRef method = new MethodRef(OverridesDefaultMethods.class, \"defaultMethod\", voidMethod());\n         MethodRef impl = analyzer.getMethodDefaultImplementation(method);\n \n-        assertThat(impl, is(new MethodRef(OverridesDefaultMethods$.class, \"defaultMethod\", \"()V\")));\n+        assertThat(impl, is(new MethodRef(OverridesDefaultMethods$.class, \"defaultMethod\", voidMethod(OverridesDefaultMethods.class))));\n     }\n \n     @Test\n@@ -196,7 +197,7 @@ public class ClassHierarchyAnalyzerTest {\n         analyze(HasDefaultMethods.class,\n                 AbstractsDefaultMethods.class);\n \n-        MethodRef method = new MethodRef(AbstractsDefaultMethods.class, \"defaultMethod\", \"()V\");\n+        MethodRef method = new MethodRef(AbstractsDefaultMethods.class, \"defaultMethod\", voidMethod());\n         MethodRef impl = analyzer.getMethodDefaultImplementation(method);\n \n         assertThat(impl, is(nullValue()));\n@@ -272,6 +273,13 @@ public class ClassHierarchyAnalyzerTest {\n \n     // other helpers\n \n+    private static String voidMethod(Class<?>... argumentTypes) {\n+        return Type.getMethodDescriptor(Type.VOID_TYPE,\n+                Stream.of(argumentTypes)\n+                        .map(Type::getType)\n+                        .toArray(Type[]::new));\n+    }\n+\n     private static List<Class<?>> readersToClasses(List<ClassReader> readers) {\n         return readers.stream()\n                 .map(ClassHierarchyAnalyzerTest::toClass)\n"
    },
    {
        "commit_hash": "89f1070f165aeb7407b9832bcf453639f1e72c25",
        "previous_commit_hash": "6d6b419b366769a217214657ab1133477f8a6934",
        "diff_stats": {
            "additions": 14,
            "deletions": 2
        },
        "diff_content": "@@ -30,8 +30,20 @@ public class UpdateRelocatedMethodInvocations extends ClassVisitor {\n \n         @Override\n         public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\n-            MethodRef ref = methodRelocations.getMethodCallTarget(new MethodRef(owner, name, desc));\n-            super.visitMethodInsn(opcode, ref.owner, ref.name, ref.desc, itf);\n+            MethodRef method = new MethodRef(owner, name, desc);\n+\n+            // change Interface.super.defaultMethod() calls to static calls on the companion class\n+            // TODO: move this inside getMethodCallTarget (also opcode, so must first change MethodRef to Handle)\n+            if (opcode == Opcodes.INVOKESPECIAL) {\n+                MethodRef impl = methodRelocations.getMethodDefaultImplementation(method);\n+                if (impl != null) {\n+                    opcode = Opcodes.INVOKESTATIC;\n+                    method = impl;\n+                }\n+            }\n+\n+            method = methodRelocations.getMethodCallTarget(method);\n+            super.visitMethodInsn(opcode, method.owner, method.name, method.desc, itf);\n         }\n     }\n }\n"
    },
    {
        "commit_hash": "61a0a2838ae86edd1c9ad84cb48999fe859024c9",
        "previous_commit_hash": "89f1070f165aeb7407b9832bcf453639f1e72c25",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -84,7 +84,7 @@ public class Transformers {\n         if (targetVersion < Opcodes.V1_7) {\n             next = new SwallowSuppressedExceptions(next);\n         }\n-        next = new FixInvokeStaticOnInterfaceMethod(next); // TODO: remove me?\n+        next = new FixInvokeStaticOnInterfaceMethod(next);\n         next = chain.wrap(next);\n \n         reader.accept(next, 0);\n"
    },
    {
        "commit_hash": "cab293c7cece11e00cce5e258b8cc713cf209477",
        "previous_commit_hash": "61a0a2838ae86edd1c9ad84cb48999fe859024c9",
        "diff_stats": {
            "additions": 10,
            "deletions": 3
        },
        "diff_content": "@@ -15,6 +15,7 @@ import java.util.*;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.*;\n import static org.junit.Assume.assumeThat;\n+import static org.mockito.Mockito.mock;\n \n @SuppressWarnings({\"Convert2Lambda\", \"Anonymous2MethodRef\", \"RedundantCast\", \"UnusedDeclaration\"})\n public class DefaultMethodsTest {\n@@ -410,15 +411,21 @@ public class DefaultMethodsTest {\n      * e.g. if it's part of the standard library or a third-party library.\n      */\n     @Test\n-    public void default_methods_of_library_interfaces_are_ignored_silently() {\n+    public void default_methods_of_library_interfaces_are_ignored_silently() throws Exception {\n+        @SuppressWarnings(\"unchecked\") Iterator<String> dummy = mock(Iterator.class);\n+\n+        // the Iterable interface has default methods in Java 8, but that\n+        // should not prevent us from using it in previous Java versions\n         Iterable<String> it = new Iterable<String>() {\n             @Override\n             public Iterator<String> iterator() {\n-                return Collections.emptyIterator();\n+                return dummy;\n             }\n         };\n \n-        assertThat(it.iterator(), is(Collections.<String>emptyIterator()));\n+        assertThat(\"interface should work as usual\", it.iterator(), is(dummy));\n+        assertThat(\"should not copy default methods from library interfaces\",\n+                it.getClass().getDeclaredMethods(), arrayWithSize(1));\n     }\n \n     @Test\n"
    },
    {
        "commit_hash": "017455fcdb92b15f60d52050e16d1681a9ad18d8",
        "previous_commit_hash": "cab293c7cece11e00cce5e258b8cc713cf209477",
        "diff_stats": {
            "additions": 4,
            "deletions": 1
        },
        "diff_content": "@@ -87,7 +87,10 @@ public class InterfaceStaticMethodsTest {\n         assumeThat(SystemUtils.JAVA_VERSION_FLOAT, is(lessThan(1.8f)));\n \n         thrown.expect(IncompatibleClassChangeError.class);\n-        thrown.expectMessage(\"Found interface java.util.Comparator, but class was expected\");\n+        thrown.expectMessage(SystemUtils.isJavaVersionAtLeast(1.6f)\n+                ? equalTo(\"Found interface java.util.Comparator, but class was expected\")\n+                : nullValue(String.class)); // on Java 5 there is no message\n+\n         // We don't want this call to prevent loading this whole test class,\n         // it should only fail when this line is executed\n         Comparator.naturalOrder();\n"
    },
    {
        "commit_hash": "3251e51a0ae58330e30dbdd2218c7f101ba08b34",
        "previous_commit_hash": "017455fcdb92b15f60d52050e16d1681a9ad18d8",
        "diff_stats": {
            "additions": 17,
            "deletions": 0
        },
        "diff_content": "@@ -10,6 +10,7 @@ run Java 8 code with lambda expressions and method references on Java 7 or\n lower. It does this by transforming your Java 8 compiled bytecode so that\n it can run on a Java 7 runtime. After the transformation they are just a\n bunch of normal .class files, without adding any runtime dependencies.\n+[Read more details](#backported-language-features).\n \n Adventurous developers may use Retrolambda to backport lambda expressions\n even to Java 6 or Java 5. And if you reach Java 5, there are [other\n@@ -132,6 +133,22 @@ You will need Java 8 for compiling and also for generating Javadocs.\n JDK 7's Javadoc tool will fail for some valid Java 8 code.\n \n \n+Backported Language Features\n+----------------------------\n+\n+**Lambda expressions** are backported by converting them to anonymous inner\n+classes. This includes the optimization of using a singleton instance for\n+stateless lambda expressions to avoid repeated object allocation.\n+\n+**Method references** are basically just syntax sugar for lambda\n+expressions and they are backported in the same way.\n+\n+**Try-with-resources statements** are backported by removing calls to\n+`Throwable.addSuppressed` if the target bytecode version is below Java 7.\n+If you would like the suppressed exceptions to be logged instead of\n+swallowed, please create a feature request and we'll make it configurable.\n+\n+\n Known Limitations\n -----------------\n \n"
    },
    {
        "commit_hash": "4d6b456d956aca5e0caf57d6fc88bcd32f43216d",
        "previous_commit_hash": "3251e51a0ae58330e30dbdd2218c7f101ba08b34",
        "diff_stats": {
            "additions": 6,
            "deletions": 4
        },
        "diff_content": "@@ -9,7 +9,7 @@ for running Java 5 code with generics on Java 1.4, **Retrolambda** lets you\n run Java 8 code with lambda expressions and method references on Java 7 or\n lower. It does this by transforming your Java 8 compiled bytecode so that\n it can run on a Java 7 runtime. After the transformation they are just a\n-bunch of normal .class files, without adding any runtime dependencies.\n+bunch of normal .class files, without any additional runtime dependencies.\n [Read more details](#backported-language-features).\n \n Adventurous developers may use Retrolambda to backport lambda expressions\n@@ -17,8 +17,10 @@ even to Java 6 or Java 5. And if you reach Java 5, there are [other\n backporting tools](http://en.wikipedia.org/wiki/Java_backporting_tools)\n that may let you go down to Java 1.4.\n \n-Android developers may also use Retrolambda. Serge Zaitsev has written [an\n-article about how to do it](http://zserge.com/blog/android-lambda.html).\n+Android developers may also use Retrolambda to take advantage of the Java 8\n+features on Android. Serge Zaitsev has written [an article about\n+it](http://zserge.com/blog/android-lambda.html) and there is a [Gradle\n+plugin](#gradle-plugin) which makes it easy.\n \n \n User Guide\n@@ -185,7 +187,7 @@ Version History\n \n ### Retrolambda 1.6.2 (2014-10-03)\n \n-- Fixed a crash when trying backport Android classes\n+- Fixed a crash when trying to backport Android classes\n   ([Issue #34](https://github.com/orfjackal/retrolambda/issues/34))\n \n ### Retrolambda 1.6.1 (2014-08-25)\n"
    },
    {
        "commit_hash": "9b2b605490a7dc2ed032ca5697e236ee5e86b36d",
        "previous_commit_hash": "4d6b456d956aca5e0caf57d6fc88bcd32f43216d",
        "diff_stats": {
            "additions": 12,
            "deletions": 1
        },
        "diff_content": "@@ -7,13 +7,24 @@ package net.orfjackal.retrolambda.test;\n import org.apache.commons.lang.SystemUtils;\n import org.junit.Test;\n \n-import java.io.Closeable;\n+import java.io.*;\n \n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.*;\n+import static org.mockito.Mockito.*;\n \n public class TryWithResourcesTest {\n \n+    @Test\n+    public void calls_close() throws IOException {\n+        Closeable closeable = mock(Closeable.class);\n+\n+        try (Closeable c = closeable) {\n+        }\n+\n+        verify(closeable).close();\n+    }\n+\n     @Test\n     public void suppressed_exceptions() {\n         try {\n"
    },
    {
        "commit_hash": "a3fb072f57f590c797e625be0bd370ed46d46d70",
        "previous_commit_hash": "9b2b605490a7dc2ed032ca5697e236ee5e86b36d",
        "diff_stats": {
            "additions": 10,
            "deletions": 8
        },
        "diff_content": "@@ -27,20 +27,22 @@ public class TryWithResourcesTest {\n \n     @Test\n     public void suppressed_exceptions() {\n+        Exception thrown;\n         try {\n             try (ThrowSecondaryExceptionOnClose c = new ThrowSecondaryExceptionOnClose()) {\n                 throw new PrimaryException();\n             }\n-\n         } catch (Exception e) {\n-            assertThat(\"thrown\", e, is(instanceOf(PrimaryException.class)));\n-            assertThat(\"cause\", e.getCause(), is(nullValue()));\n+            thrown = e;\n+        }\n \n-            // On Java 6 and lower we will swallow the suppressed exception, because the API does not exist,\n-            // but on Java 7 we want to keep the original behavior.\n-            if (SystemUtils.isJavaVersionAtLeast(1.7f)) {\n-                assertThat(\"suppressed\", e.getSuppressed(), arrayContaining(instanceOf(SecondaryException.class)));\n-            }\n+        assertThat(\"thrown\", thrown, is(instanceOf(PrimaryException.class)));\n+        assertThat(\"cause\", thrown.getCause(), is(nullValue()));\n+\n+        // On Java 6 and lower we will swallow the suppressed exception, because the API does not exist,\n+        // but on Java 7 we want to keep the original behavior.\n+        if (SystemUtils.isJavaVersionAtLeast(1.7f)) {\n+            assertThat(\"suppressed\", thrown.getSuppressed(), arrayContaining(instanceOf(SecondaryException.class)));\n         }\n     }\n \n"
    },
    {
        "commit_hash": "c09c671446ca0d8476e706c3fab1173d5b10b062",
        "previous_commit_hash": "a3fb072f57f590c797e625be0bd370ed46d46d70",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -169,7 +169,7 @@ Version History\n \n ### Upcoming\n \n-- Backports static methods on interfaces\n+- Backports default methods and static methods on interfaces\n   ([Issue #31](https://github.com/orfjackal/retrolambda/issues/31))\n   - *Experimental! Can be enabled with the enviroment variable\n     DEFAULT_METHODS=2*\n"
    },
    {
        "commit_hash": "a51e2ca2bd5e01ee0732466ef60783613b71518f",
        "previous_commit_hash": "c09c671446ca0d8476e706c3fab1173d5b10b062",
        "diff_stats": {
            "additions": 7,
            "deletions": 0
        },
        "diff_content": "@@ -86,6 +86,13 @@\n             <option name=\"TAB_SIZE\" value=\"8\" />\n           </indentOptions>\n         </codeStyleSettings>\n+        <codeStyleSettings language=\"TypeScript\">\n+          <option name=\"IF_BRACE_FORCE\" value=\"3\" />\n+          <option name=\"DOWHILE_BRACE_FORCE\" value=\"3\" />\n+          <option name=\"WHILE_BRACE_FORCE\" value=\"3\" />\n+          <option name=\"FOR_BRACE_FORCE\" value=\"3\" />\n+          <option name=\"PARENT_SETTINGS_INSTALLED\" value=\"true\" />\n+        </codeStyleSettings>\n         <codeStyleSettings language=\"XML\">\n           <indentOptions>\n             <option name=\"TAB_SIZE\" value=\"8\" />\n"
    },
    {
        "commit_hash": "a143fc9b4ae21b2eea3fceb5472cd1c7545eafc4",
        "previous_commit_hash": "a51e2ca2bd5e01ee0732466ef60783613b71518f",
        "diff_stats": {
            "additions": 10,
            "deletions": 1
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -85,6 +85,15 @@ public class LambdaTest extends SuperClass {\n         assertThat(lambda.call(), is(36));\n     }\n \n+    @Test\n+    public void lambda_in_the_constant_initializer_of_an_interface() throws Exception {\n+        assertThat(LambdaConstant.LAMBDA.call(), is(\"foo\"));\n+    }\n+\n+    public interface LambdaConstant {\n+        Callable<String> LAMBDA = () -> \"foo\";\n+    }\n+\n     @Test\n     public void method_references_to_virtual_methods() throws Exception {\n         String foo = \"foo\";\n"
    },
    {
        "commit_hash": "3413871775e0b14a443337da7384d4f57f14e907",
        "previous_commit_hash": "a143fc9b4ae21b2eea3fceb5472cd1c7545eafc4",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -81,7 +81,7 @@ Retrolambda is a backporting tool for classes which use lambda expressions\n and have been compiled with Java 8, to run on Java 7 (maybe even Java 5).\n See https://github.com/orfjackal/retrolambda\n \n-Copyright (c) 2013-2014  Esko Luontola <www.orfjackal.net>\n+Copyright (c) 2013-2015  Esko Luontola <www.orfjackal.net>\n This software is released under the Apache License 2.0.\n The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n"
    },
    {
        "commit_hash": "3413871775e0b14a443337da7384d4f57f14e907",
        "previous_commit_hash": "a143fc9b4ae21b2eea3fceb5472cd1c7545eafc4",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -154,7 +154,7 @@ public class Config {\n                 \"and have been compiled with Java 8, to run on Java 7 (maybe even Java 5).\\n\" +\n                 \"See https://github.com/orfjackal/retrolambda\\n\" +\n                 \"\\n\" +\n-                \"Copyright (c) 2013-2014  Esko Luontola <www.orfjackal.net>\\n\" +\n+                \"Copyright (c) 2013-2015  Esko Luontola <www.orfjackal.net>\\n\" +\n                 \"This software is released under the Apache License 2.0.\\n\" +\n                 \"The license text is at http://www.apache.org/licenses/LICENSE-2.0\\n\" +\n                 \"\\n\" +\n"
    },
    {
        "commit_hash": "e3c8647b91d71d5825f28695253e1e3e60628d1c",
        "previous_commit_hash": "3413871775e0b14a443337da7384d4f57f14e907",
        "diff_stats": {
            "additions": 2,
            "deletions": 0
        },
        "diff_content": "@@ -173,6 +173,8 @@ Version History\n   ([Issue #31](https://github.com/orfjackal/retrolambda/issues/31))\n   - *Experimental! Can be enabled with the enviroment variable\n     DEFAULT_METHODS=2*\n+- Backports lambda expressions in an interface's constant initializer\n+  ([Issue #42](https://github.com/orfjackal/retrolambda/issues/42))\n \n ### Retrolambda 1.8.0 (2014-11-16)\n \n"
    },
    {
        "commit_hash": "e3c8647b91d71d5825f28695253e1e3e60628d1c",
        "previous_commit_hash": "3413871775e0b14a443337da7384d4f57f14e907",
        "diff_stats": {
            "additions": 14,
            "deletions": 10
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -27,6 +27,9 @@ public class Transformers {\n             } else if (FeatureToggles.DEFAULT_METHODS == 2) {\n                 next = new UpdateRelocatedMethodInvocations(next, methodRelocations);\n                 next = new AddMethodDefaultImplementations(next, methodRelocations);\n+            } else {\n+                // needed for lambdas in an interface's constant initializer\n+                next = new UpdateRelocatedMethodInvocations(next, methodRelocations);\n             }\n             next = new BackportLambdaClass(next);\n             return next;\n@@ -56,6 +59,9 @@ public class Transformers {\n                 next = new RemoveStaticMethods(next);\n                 next = new RemoveDefaultMethodBodies(next);\n                 next = new UpdateRelocatedMethodInvocations(next, methodRelocations);\n+            } else {\n+                // needed for lambdas in an interface's constant initializer\n+                next = new RemoveStaticMethods(next);\n             }\n             next = new BackportLambdaInvocations(next);\n             return next;\n@@ -63,17 +69,15 @@ public class Transformers {\n     }\n \n     public byte[] extractInterfaceCompanion(ClassReader reader) {\n-        String companion;\n-        if (FeatureToggles.DEFAULT_METHODS == 2\n-                && (companion = methodRelocations.getCompanionClass(reader.getClassName())) != null) {\n-            return transform(reader, (next) -> {\n-                next = new UpdateRelocatedMethodInvocations(next, methodRelocations);\n-                next = new ExtractInterfaceCompanionClass(next, companion);\n-                return next;\n-            });\n-        } else {\n+        String companion = methodRelocations.getCompanionClass(reader.getClassName());\n+        if (companion == null) {\n             return null;\n         }\n+        return transform(reader, (next) -> {\n+            next = new UpdateRelocatedMethodInvocations(next, methodRelocations);\n+            next = new ExtractInterfaceCompanionClass(next, companion);\n+            return next;\n+        });\n     }\n \n     private byte[] transform(ClassReader reader, ClassVisitorChain chain) {\n"
    },
    {
        "commit_hash": "e3c8647b91d71d5825f28695253e1e3e60628d1c",
        "previous_commit_hash": "3413871775e0b14a443337da7384d4f57f14e907",
        "diff_stats": {
            "additions": 20,
            "deletions": 1
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -34,6 +34,19 @@ public class ExtractInterfaceCompanionClass extends ClassVisitor {\n             // do not copy abstract methods to the companion class\n             return null;\n         }\n+        if (Flags.isClassInitializer(name, desc, access)) {\n+            // we won't copy constant fields from the interface, so a class initializer won't be needed\n+            return null;\n+        }\n+        if (Flags.hasFlag(access, ACC_STATIC)\n+                && Flags.hasFlag(access, ACC_PRIVATE)) {\n+            // XXX: Possibly a lambda impl method, which is private. It is the easiest for us to make it visible,\n+            // which should be quite safe because static methods are not inherited (and anyways nothing inherits\n+            // the companion class). The clean solution would be to generate an access method for it, but due to\n+            // the location in code which generates those access methods, it would require complex code changes to\n+            // pass around the information from one transformation to another.\n+            access &= ~ACC_PRIVATE;\n+        }\n         if (!Flags.hasFlag(access, ACC_STATIC)) {\n             // default method; make static and take 'this' as the first argument\n             access |= ACC_STATIC;\n@@ -42,4 +55,10 @@ public class ExtractInterfaceCompanionClass extends ClassVisitor {\n         }\n         return super.visitMethod(access, name, desc, signature, exceptions);\n     }\n+\n+    @Override\n+    public FieldVisitor visitField(int access, String name, String desc, String signature, Object value) {\n+        // an interface can only contain constant fields; they don't need to be copied\n+        return null;\n+    }\n }\n"
    },
    {
        "commit_hash": "e3c8647b91d71d5825f28695253e1e3e60628d1c",
        "previous_commit_hash": "3413871775e0b14a443337da7384d4f57f14e907",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -17,7 +17,7 @@ public class RemoveStaticMethods extends ClassVisitor {\n \n     @Override\n     public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n-        if (isStaticMethod(access)) {\n+        if (isStaticMethod(access) && !Flags.isClassInitializer(name, desc, access)) {\n             return null;\n         } else {\n             return super.visitMethod(access, name, desc, signature, exceptions);\n"
    },
    {
        "commit_hash": "e3c8647b91d71d5825f28695253e1e3e60628d1c",
        "previous_commit_hash": "3413871775e0b14a443337da7384d4f57f14e907",
        "diff_stats": {
            "additions": 6,
            "deletions": 8
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -57,7 +57,7 @@ public class BackportLambdaInvocations extends ClassVisitor {\n         }\n         if (FeatureToggles.DEFAULT_METHODS == 0\n                 && isNonAbstractMethodOnInterface(access)\n-                && !isClassInitializerMethod(name, desc, access)) {\n+                && !Flags.isClassInitializer(name, desc, access)) {\n             // In case we have missed a case of Java 8 producing non-abstract methods\n             // on interfaces, we have this warning here to get a bug report sooner.\n             // Not allowed by Java 7:\n@@ -85,16 +85,14 @@ public class BackportLambdaInvocations extends ClassVisitor {\n                 !Flags.hasFlag(methodAccess, ACC_ABSTRACT);\n     }\n \n-    private static boolean isClassInitializerMethod(String name, String desc, int methodAccess) {\n-        return name.equals(\"<clinit>\") &&\n-                desc.equals(\"()V\") &&\n-                Flags.hasFlag(methodAccess, ACC_STATIC);\n-    }\n-\n     Handle getLambdaAccessMethod(Handle implMethod) {\n         if (!implMethod.getOwner().equals(className)) {\n             return implMethod;\n         }\n+        if (Flags.hasFlag(classAccess, ACC_INTERFACE)) {\n+            // the method will be relocated to a companion class\n+            return implMethod;\n+        }\n         // TODO: do not generate an access method if the impl method is not private (probably not implementable with a single pass)\n         String name = \"access$lambda$\" + lambdaAccessToImplMethods.size();\n         String desc = implMethod.getTag() == H_INVOKESTATIC\n"
    },
    {
        "commit_hash": "e3c8647b91d71d5825f28695253e1e3e60628d1c",
        "previous_commit_hash": "3413871775e0b14a443337da7384d4f57f14e907",
        "diff_stats": {
            "additions": 9,
            "deletions": 1
        },
        "diff_content": "@@ -1,12 +1,20 @@\n-// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n package net.orfjackal.retrolambda.util;\n \n+import static org.objectweb.asm.Opcodes.ACC_STATIC;\n+\n public class Flags {\n \n     public static boolean hasFlag(int subject, int flag) {\n         return (subject & flag) == flag;\n     }\n+\n+    public static boolean isClassInitializer(String name, String desc, int methodAccess) {\n+        return name.equals(\"<clinit>\") &&\n+                desc.equals(\"()V\") &&\n+                hasFlag(methodAccess, ACC_STATIC);\n+    }\n }\n"
    },
    {
        "commit_hash": "0c25984ac4940119f3de6bdd4075fd8600a34b55",
        "previous_commit_hash": "e3c8647b91d71d5825f28695253e1e3e60628d1c",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -171,7 +171,7 @@ Version History\n \n - Backports default methods and static methods on interfaces\n   ([Issue #31](https://github.com/orfjackal/retrolambda/issues/31))\n-  - *Experimental! Can be enabled with the enviroment variable\n+  - *Experimental! Can be enabled with the environment variable\n     DEFAULT_METHODS=2*\n - Backports lambda expressions in an interface's constant initializer\n   ([Issue #42](https://github.com/orfjackal/retrolambda/issues/42))\n"
    },
    {
        "commit_hash": "0c25984ac4940119f3de6bdd4075fd8600a34b55",
        "previous_commit_hash": "e3c8647b91d71d5825f28695253e1e3e60628d1c",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -62,6 +62,7 @@ public class Transformers {\n             } else {\n                 // needed for lambdas in an interface's constant initializer\n                 next = new RemoveStaticMethods(next);\n+                next = new WarnAboutDefaultAndStaticMethods(next);\n             }\n             next = new BackportLambdaInvocations(next);\n             return next;\n"
    },
    {
        "commit_hash": "0c25984ac4940119f3de6bdd4075fd8600a34b55",
        "previous_commit_hash": "e3c8647b91d71d5825f28695253e1e3e60628d1c",
        "diff_stats": {
            "additions": 55,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,55 @@\n+// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.interfaces;\n+\n+import net.orfjackal.retrolambda.util.Flags;\n+import org.objectweb.asm.*;\n+\n+import static org.objectweb.asm.Opcodes.*;\n+\n+public class WarnAboutDefaultAndStaticMethods extends ClassVisitor {\n+\n+    private String interfaceName;\n+\n+    public WarnAboutDefaultAndStaticMethods(ClassVisitor next) {\n+        super(Opcodes.ASM5, next);\n+    }\n+\n+    @Override\n+    public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n+        if (!Flags.hasFlag(access, ACC_INTERFACE)) {\n+            throw new IllegalArgumentException(name + \" is not an interface\");\n+        }\n+        interfaceName = name;\n+        super.visit(version, access, name, signature, superName, interfaces);\n+    }\n+\n+    @Override\n+    public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+        // Not allowed by Java 7 in interfaces:\n+        // - default methods\n+        // - static methods\n+        // - bridge methods\n+        // Allowed by Java 7:\n+        // - class initializer methods (for initializing constants)\n+        if (Flags.hasFlag(access, ACC_STATIC)) {\n+            if (!Flags.isClassInitializer(name, desc, access) &&\n+                    !name.startsWith(\"lambda$\")) {\n+                printWarning(\"a static method\", name);\n+            }\n+        } else {\n+            if (!Flags.hasFlag(access, ACC_ABSTRACT)) {\n+                printWarning(\"a default method\", name);\n+            }\n+        }\n+        return super.visitMethod(access, name, desc, signature, exceptions);\n+    }\n+\n+    private void printWarning(String methodKind, String methodName) {\n+        System.out.println(\"WARNING: The interface \" + interfaceName + \" has \" + methodKind + \" \\\"\" + methodName + \"\\\" \" +\n+                \"but the experimental support for them is not enabled \" +\n+                \"(set the environment variable DEFAULT_METHODS=2)\");\n+    }\n+}\n"
    },
    {
        "commit_hash": "0c25984ac4940119f3de6bdd4075fd8600a34b55",
        "previous_commit_hash": "e3c8647b91d71d5825f28695253e1e3e60628d1c",
        "diff_stats": {
            "additions": 0,
            "deletions": 23
        },
        "diff_content": "@@ -4,7 +4,6 @@\n \n package net.orfjackal.retrolambda.lambdas;\n \n-import net.orfjackal.retrolambda.FeatureToggles;\n import net.orfjackal.retrolambda.util.*;\n import org.objectweb.asm.*;\n \n@@ -55,23 +54,6 @@ public class BackportLambdaInvocations extends ClassVisitor {\n         if (LambdaNaming.isDeserializationHook(access, name, desc)) {\n             return null; // remove serialization hooks; we serialize lambda instances as-is\n         }\n-        if (FeatureToggles.DEFAULT_METHODS == 0\n-                && isNonAbstractMethodOnInterface(access)\n-                && !Flags.isClassInitializer(name, desc, access)) {\n-            // In case we have missed a case of Java 8 producing non-abstract methods\n-            // on interfaces, we have this warning here to get a bug report sooner.\n-            // Not allowed by Java 7:\n-            // - default methods\n-            // - static methods\n-            // - bridge methods\n-            // Allowed by Java 7:\n-            // - class initializer methods (for initializing constants)\n-            System.out.println(\"WARNING: Method '\" + name + \"' of interface '\" + className + \"' is non-abstract! \" +\n-                    \"This will probably fail to run on Java 7 and below. \" +\n-                    \"If you get this warning _without_ using Java 8's default methods, \" +\n-                    \"please report a bug at https://github.com/orfjackal/retrolambda/issues \" +\n-                    \"together with an SSCCE (http://www.sscce.org/)\");\n-        }\n         return new InvokeDynamicInsnConverter(super.visitMethod(access, name, desc, signature, exceptions));\n     }\n \n@@ -80,11 +62,6 @@ public class BackportLambdaInvocations extends ClassVisitor {\n                 Flags.hasFlag(methodAccess, ACC_BRIDGE);\n     }\n \n-    private boolean isNonAbstractMethodOnInterface(int methodAccess) {\n-        return Flags.hasFlag(classAccess, ACC_INTERFACE) &&\n-                !Flags.hasFlag(methodAccess, ACC_ABSTRACT);\n-    }\n-\n     Handle getLambdaAccessMethod(Handle implMethod) {\n         if (!implMethod.getOwner().equals(className)) {\n             return implMethod;\n"
    },
    {
        "commit_hash": "3cf474b8f906a69bad563ce85a7c42c7b2e5eee6",
        "previous_commit_hash": "0c25984ac4940119f3de6bdd4075fd8600a34b55",
        "diff_stats": {
            "additions": 3,
            "deletions": 4
        },
        "diff_content": "@@ -28,8 +28,7 @@ public class Transformers {\n                 next = new UpdateRelocatedMethodInvocations(next, methodRelocations);\n                 next = new AddMethodDefaultImplementations(next, methodRelocations);\n             } else {\n-                // needed for lambdas in an interface's constant initializer\n-                next = new UpdateRelocatedMethodInvocations(next, methodRelocations);\n+                next = new UpdateRelocatedMethodInvocations(next, methodRelocations); // needed for lambdas in an interface's constant initializer\n             }\n             next = new BackportLambdaClass(next);\n             return next;\n@@ -60,10 +59,10 @@ public class Transformers {\n                 next = new RemoveDefaultMethodBodies(next);\n                 next = new UpdateRelocatedMethodInvocations(next, methodRelocations);\n             } else {\n-                // needed for lambdas in an interface's constant initializer\n-                next = new RemoveStaticMethods(next);\n+                next = new RemoveStaticMethods(next); // needed for lambdas in an interface's constant initializer\n                 next = new WarnAboutDefaultAndStaticMethods(next);\n             }\n+            next = new RemoveBridgeMethods(next);\n             next = new BackportLambdaInvocations(next);\n             return next;\n         });\n"
    },
    {
        "commit_hash": "3cf474b8f906a69bad563ce85a7c42c7b2e5eee6",
        "previous_commit_hash": "0c25984ac4940119f3de6bdd4075fd8600a34b55",
        "diff_stats": {
            "additions": 25,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,25 @@\n+// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.interfaces;\n+\n+import net.orfjackal.retrolambda.util.Flags;\n+import org.objectweb.asm.*;\n+\n+import static org.objectweb.asm.Opcodes.*;\n+\n+public class RemoveBridgeMethods extends ClassVisitor {\n+\n+    public RemoveBridgeMethods(ClassVisitor next) {\n+        super(ASM5, next);\n+    }\n+\n+    @Override\n+    public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+        if (Flags.hasFlag(access, ACC_BRIDGE)) {\n+            return null; // remove the bridge method; Java 7 didn't use them\n+        }\n+        return super.visitMethod(access, name, desc, signature, exceptions);\n+    }\n+}\n"
    },
    {
        "commit_hash": "3cf474b8f906a69bad563ce85a7c42c7b2e5eee6",
        "previous_commit_hash": "0c25984ac4940119f3de6bdd4075fd8600a34b55",
        "diff_stats": {
            "additions": 0,
            "deletions": 9
        },
        "diff_content": "@@ -47,21 +47,12 @@ public class BackportLambdaInvocations extends ClassVisitor {\n \n     @Override\n     public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n-        // TODO: move stuff to an interface transformer\n-        if (isBridgeMethodOnInterface(access)) {\n-            return null; // remove the bridge method; Java 7 didn't use them\n-        }\n         if (LambdaNaming.isDeserializationHook(access, name, desc)) {\n             return null; // remove serialization hooks; we serialize lambda instances as-is\n         }\n         return new InvokeDynamicInsnConverter(super.visitMethod(access, name, desc, signature, exceptions));\n     }\n \n-    private boolean isBridgeMethodOnInterface(int methodAccess) {\n-        return Flags.hasFlag(classAccess, ACC_INTERFACE) &&\n-                Flags.hasFlag(methodAccess, ACC_BRIDGE);\n-    }\n-\n     Handle getLambdaAccessMethod(Handle implMethod) {\n         if (!implMethod.getOwner().equals(className)) {\n             return implMethod;\n"
    },
    {
        "commit_hash": "51abb79d3b502c7cab745b91cfa728326182b1fc",
        "previous_commit_hash": "3cf474b8f906a69bad563ce85a7c42c7b2e5eee6",
        "diff_stats": {
            "additions": 4,
            "deletions": 1
        },
        "diff_content": "@@ -40,7 +40,7 @@ To run Retrolambda using Maven, add the following to your pom.xml:\n <plugin>\n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>retrolambda-maven-plugin</artifactId>\n-    <version>1.8.0</version>\n+    <version>1.8.1</version>\n     <executions>\n         <execution>\n             <goals>\n@@ -173,6 +173,9 @@ Version History\n   ([Issue #31](https://github.com/orfjackal/retrolambda/issues/31))\n   - *Experimental! Can be enabled with the environment variable\n     DEFAULT_METHODS=2*\n+\n+### Retrolambda 1.8.1 (2015-01-06)\n+\n - Backports lambda expressions in an interface's constant initializer\n   ([Issue #42](https://github.com/orfjackal/retrolambda/issues/42))\n \n"
    },
    {
        "commit_hash": "51abb79d3b502c7cab745b91cfa728326182b1fc",
        "previous_commit_hash": "3cf474b8f906a69bad563ce85a7c42c7b2e5eee6",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.8.1-SNAPSHOT</version>\n+        <version>1.8.1</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "51abb79d3b502c7cab745b91cfa728326182b1fc",
        "previous_commit_hash": "3cf474b8f906a69bad563ce85a7c42c7b2e5eee6",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>1.8.1-SNAPSHOT</version>\n+    <version>1.8.1</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "51abb79d3b502c7cab745b91cfa728326182b1fc",
        "previous_commit_hash": "3cf474b8f906a69bad563ce85a7c42c7b2e5eee6",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.8.1-SNAPSHOT</version>\n+        <version>1.8.1</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "51abb79d3b502c7cab745b91cfa728326182b1fc",
        "previous_commit_hash": "3cf474b8f906a69bad563ce85a7c42c7b2e5eee6",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.8.1-SNAPSHOT</version>\n+        <version>1.8.1</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "51abb79d3b502c7cab745b91cfa728326182b1fc",
        "previous_commit_hash": "3cf474b8f906a69bad563ce85a7c42c7b2e5eee6",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.8.1-SNAPSHOT</version>\n+        <version>1.8.1</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "d0287aa3235da1987df0431b1c6b8ebac82d151f",
        "previous_commit_hash": "51abb79d3b502c7cab745b91cfa728326182b1fc",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.8.1</version>\n+        <version>1.8.2-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "d0287aa3235da1987df0431b1c6b8ebac82d151f",
        "previous_commit_hash": "51abb79d3b502c7cab745b91cfa728326182b1fc",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>1.8.1</version>\n+    <version>1.8.2-SNAPSHOT</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "d0287aa3235da1987df0431b1c6b8ebac82d151f",
        "previous_commit_hash": "51abb79d3b502c7cab745b91cfa728326182b1fc",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.8.1</version>\n+        <version>1.8.2-SNAPSHOT</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "d0287aa3235da1987df0431b1c6b8ebac82d151f",
        "previous_commit_hash": "51abb79d3b502c7cab745b91cfa728326182b1fc",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.8.1</version>\n+        <version>1.8.2-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "d0287aa3235da1987df0431b1c6b8ebac82d151f",
        "previous_commit_hash": "51abb79d3b502c7cab745b91cfa728326182b1fc",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.8.1</version>\n+        <version>1.8.2-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "c90ca7cc116fe456d3397f6ae36dd85bc9964f67",
        "previous_commit_hash": "d0287aa3235da1987df0431b1c6b8ebac82d151f",
        "diff_stats": {
            "additions": 1,
            "deletions": 2
        },
        "diff_content": "@@ -88,8 +88,7 @@\n                     </execution>\n                 </executions>\n                 <configuration>\n-                    <!-- TODO: default methods; enable minimizing -->\n-                    <!-- <minimizeJar>true</minimizeJar>  --> <!-- http://jira.codehaus.org/browse/MSHADE-174 -->\n+                    <minimizeJar>true</minimizeJar>\n                     <relocations>\n                         <relocation>\n                             <pattern>org.objectweb.asm</pattern>\n"
    },
    {
        "commit_hash": "c90ca7cc116fe456d3397f6ae36dd85bc9964f67",
        "previous_commit_hash": "d0287aa3235da1987df0431b1c6b8ebac82d151f",
        "diff_stats": {
            "additions": 1,
            "deletions": 6
        },
        "diff_content": "@@ -1,10 +1,9 @@\n-// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n package net.orfjackal.retrolambda;\n \n-import net.orfjackal.retrolambda.defaultmethods.Helpers;\n import net.orfjackal.retrolambda.files.*;\n import net.orfjackal.retrolambda.interfaces.ClassHierarchyAnalyzer;\n import net.orfjackal.retrolambda.lambdas.*;\n@@ -36,10 +35,6 @@ public class Retrolambda {\n             return;\n         }\n \n-        if (FeatureToggles.DEFAULT_METHODS == 1) {\n-            Helpers.config = config;\n-        }\n-\n         Thread.currentThread().setContextClassLoader(new NonDelegatingClassLoader(asUrls(classpath)));\n \n         ClassHierarchyAnalyzer analyzer = new ClassHierarchyAnalyzer();\n"
    },
    {
        "commit_hash": "c90ca7cc116fe456d3397f6ae36dd85bc9964f67",
        "previous_commit_hash": "d0287aa3235da1987df0431b1c6b8ebac82d151f",
        "diff_stats": {
            "additions": 3,
            "deletions": 12
        },
        "diff_content": "@@ -4,7 +4,6 @@\n \n package net.orfjackal.retrolambda;\n \n-import net.orfjackal.retrolambda.defaultmethods.*;\n import net.orfjackal.retrolambda.interfaces.*;\n import net.orfjackal.retrolambda.lambdas.*;\n import net.orfjackal.retrolambda.trywithresources.SwallowSuppressedExceptions;\n@@ -22,9 +21,7 @@ public class Transformers {\n \n     public byte[] backportLambdaClass(ClassReader reader) {\n         return transform(reader, (next) -> {\n-            if (FeatureToggles.DEFAULT_METHODS == 1) {\n-                next = new ClassModifier(targetVersion, next);\n-            } else if (FeatureToggles.DEFAULT_METHODS == 2) {\n+            if (FeatureToggles.DEFAULT_METHODS == 2) {\n                 next = new UpdateRelocatedMethodInvocations(next, methodRelocations);\n                 next = new AddMethodDefaultImplementations(next, methodRelocations);\n             } else {\n@@ -37,10 +34,7 @@ public class Transformers {\n \n     public byte[] backportClass(ClassReader reader) {\n         return transform(reader, (next) -> {\n-            if (FeatureToggles.DEFAULT_METHODS == 1) {\n-                next = new ClassModifier(targetVersion, next);\n-                next = new InterfaceModifier(next, targetVersion);\n-            } else if (FeatureToggles.DEFAULT_METHODS == 2) {\n+            if (FeatureToggles.DEFAULT_METHODS == 2) {\n                 next = new UpdateRelocatedMethodInvocations(next, methodRelocations);\n                 next = new AddMethodDefaultImplementations(next, methodRelocations);\n             }\n@@ -51,10 +45,7 @@ public class Transformers {\n \n     public byte[] backportInterface(ClassReader reader) {\n         return transform(reader, (next) -> {\n-            if (FeatureToggles.DEFAULT_METHODS == 1) {\n-                next = new ClassModifier(targetVersion, next);\n-                next = new InterfaceModifier(next, targetVersion);\n-            } else if (FeatureToggles.DEFAULT_METHODS == 2) {\n+            if (FeatureToggles.DEFAULT_METHODS == 2) {\n                 next = new RemoveStaticMethods(next);\n                 next = new RemoveDefaultMethodBodies(next);\n                 next = new UpdateRelocatedMethodInvocations(next, methodRelocations);\n"
    },
    {
        "commit_hash": "c90ca7cc116fe456d3397f6ae36dd85bc9964f67",
        "previous_commit_hash": "d0287aa3235da1987df0431b1c6b8ebac82d151f",
        "diff_stats": {
            "additions": 0,
            "deletions": 142
        },
        "diff_content": "@@ -1,142 +0,0 @@\n-// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n-// This software is released under the Apache License 2.0.\n-// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n-\n-package net.orfjackal.retrolambda.defaultmethods;\n-\n-import org.objectweb.asm.ClassVisitor;\n-import org.objectweb.asm.MethodVisitor;\n-import org.objectweb.asm.Opcodes;\n-import org.objectweb.asm.Type;\n-\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-import java.util.*;\n-import java.util.stream.*;\n-\n-/**\n- * Created by arneball on 2014-08-12.\n- */\n-public class ClassModifier extends ClassVisitor implements Opcodes {\n-    private final int bytecodeVersion;\n-    private String[] interfaces;\n-\n-    private Set<VisitedMethod> visitedMethods = new HashSet<>();\n-    private Set<MethodContainer> defaultMethods = new HashSet<>();\n-\n-    public ClassModifier(int bytecodeVersion, ClassVisitor cv) {\n-        super(ASM5, cv);\n-        this.bytecodeVersion = bytecodeVersion;\n-    }\n-\n-    @Override\n-    public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n-        boolean isClass = (access & ACC_INTERFACE) == 0;\n-        if (isClass) {\n-            defaultMethods = getMethodsToImplement(interfaces, signature);\n-        }\n-        this.interfaces = interfaces;\n-        System.out.println(\"Class is \" + name + \", non abstract \" + isClass + \", Interfaces are \" + Arrays.toString(interfaces) + \"\" +\n-                \", default methods are \" + defaultMethods);\n-        super.visit(bytecodeVersion, access, name, signature, superName, interfaces);\n-    }\n-\n-    private static Set<MethodContainer> getMethodsToImplement(String[] interfaces, String sig) {\n-        return Stream.of(interfaces)\n-                .flatMap(iff -> getMethodsToImplement(iff, sig).stream())\n-                .collect(Collectors.toSet());\n-    }\n-\n-    private static Set<MethodContainer> getMethodsToImplement(String interfac, String sig) {\n-        Class<?> ifClass = Helpers.loadClass(interfac);\n-        Method[] tmp = ifClass.getMethods();\n-        System.out.println(\"Interface: \" + interfac + \", methods: \" + Arrays.toString(tmp));\n-        return Stream.of(tmp)\n-                .filter(m -> !Modifier.isAbstract(m.getModifiers()))\n-                .filter(Helpers::declaringClassBelongsToInputFiles)\n-                .map(m -> createMethodContainer(m, interfac, sig))\n-                .collect(Collectors.toSet());\n-    }\n-\n-    private static MethodContainer createMethodContainer(Method m, String interfac, String sig) {\n-        System.out.println(\"NEED TO CREATE PROXY TO \" + interfac + sig + \"\\n\" + m.getDeclaringClass());\n-        String methodDescriptor = Type.getMethodDescriptor(m);\n-        String internalName = Type.getInternalName(m.getDeclaringClass());\n-        return new MethodContainer(m.getName(), methodDescriptor, internalName, sig, getExceptions(m));\n-    }\n-\n-    private static String[] getExceptions(Method m) {\n-        return Stream.of(m.getExceptionTypes())\n-                .map(Type::getInternalName)\n-                .toArray(String[]::new);\n-    }\n-\n-    @Override\n-    public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n-        visitedMethods.add(new VisitedMethod(name, desc));\n-        return new InterfaceToHelperRewriter(super.visitMethod(access, name, desc, signature, exceptions));\n-    }\n-\n-    @Override\n-    public void visitEnd() {\n-        for (MethodContainer m : defaultMethods) {\n-            if (visitedMethods.contains(new VisitedMethod(m.methodName, m.methodDesc))) {\n-                continue;\n-            }\n-            System.out.println(\"VISITEND, CREATING PROXY \" + m);\n-            MethodVisitor tmp = super.visitMethod(ACC_PUBLIC, m.methodName, m.methodDesc, m.signature, m.exceptions);\n-            tmp.visitVarInsn(ALOAD, 0);\n-            int i = 1;\n-            for (Type arg : Type.getArgumentTypes(m.methodDesc)) {\n-                tmp.visitVarInsn(arg.getOpcode(ILOAD), i++);\n-            }\n-            String rightInterface = findRightInterace(m, interfaces);\n-            System.out.println(\"It thinks that the right interface is \" + rightInterface);\n-            String mDesc = Helpers.addParam(m.methodDesc, rightInterface);\n-            tmp.visitMethodInsn(INVOKESTATIC, rightInterface + \"$helper\", m.methodName, mDesc, false);\n-            tmp.visitInsn(Type.getReturnType(m.methodDesc).getOpcode(IRETURN));\n-            tmp.visitMaxs(0, 0);\n-            tmp.visitEnd();\n-        }\n-        super.visitEnd();\n-    }\n-\n-    public static final Comparator<Method> COMPARATOR = (o1, o2) -> {\n-        boolean o1iso2 = o1.getDeclaringClass().isAssignableFrom(o2.getDeclaringClass());\n-        boolean o2iso1 = o2.getDeclaringClass().isAssignableFrom(o1.getDeclaringClass());\n-        if (o1iso2 && o2iso1) {\n-            return 0;\n-        } else if (o2iso1) {\n-            return -1;\n-        } else {\n-            return 1;\n-        }\n-    };\n-\n-    public static String findRightInterace(MethodContainer methodContainer, String[] interfaces) {\n-        System.out.println(\"Find right interfaces for \" + methodContainer + \" \" + Arrays.toString(interfaces));\n-        return Stream.of(interfaces)\n-                .map(Helpers::loadClass)\n-                .flatMap(i -> flattenInterfaces(i).stream())\n-                .flatMap(i -> Stream.of(i.getMethods()))\n-                .filter(Method::isDefault)\n-                .filter(m -> Type.getMethodDescriptor(m).equals(methodContainer.methodDesc))\n-                .min(COMPARATOR)\n-                .map(Method::getDeclaringClass)\n-                .map(Class::getName)\n-                .map(s -> s.replace(\".\", \"/\"))\n-                .orElseThrow(NullPointerException::new);\n-    }\n-\n-    private static List<Class<?>> flattenInterfaces(Class<?> iff) {\n-        List<Class<?>> tmp = new ArrayList<>();\n-        if (iff != null) {\n-            tmp.add(iff);\n-            for (Class<?> stream : iff.getInterfaces()) {\n-                tmp.addAll(flattenInterfaces(stream));\n-            }\n-        }\n-        return tmp;\n-    }\n-\n-}\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "c90ca7cc116fe456d3397f6ae36dd85bc9964f67",
        "previous_commit_hash": "d0287aa3235da1987df0431b1c6b8ebac82d151f",
        "diff_stats": {
            "additions": 0,
            "deletions": 100
        },
        "diff_content": "@@ -1,100 +0,0 @@\n-// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n-// This software is released under the Apache License 2.0.\n-// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n-\n-package net.orfjackal.retrolambda.defaultmethods;\n-\n-import net.orfjackal.retrolambda.Config;\n-import org.objectweb.asm.Type;\n-\n-import java.lang.reflect.Method;\n-import java.net.*;\n-import java.util.regex.*;\n-import java.util.stream.Stream;\n-\n-import static org.objectweb.asm.Type.*;\n-\n-/**\n- * Created by arneball on 2014-08-12.\n- */\n-public class Helpers {\n-    private static final Pattern pattern = Pattern.compile(\"\\\\((.*)\\\\)(.*)\");\n-    public static Config config; // XXX: hack for passing in the Config from main\n-\n-    public static String addParam(String desc, String className) {\n-        Matcher m = pattern.matcher(desc);\n-        m.find();\n-        String rest = m.group(1);\n-        String returntype = m.group(2);\n-        return String.format(\"(L%s;%s)%s\", className, rest, returntype);\n-    }\n-\n-    public static String changeReturnType(String desc, String returnType) {\n-        Matcher m = pattern.matcher(desc);\n-        m.find();\n-        String rest = m.group(1);\n-        return String.format(\"(%s)L%s;\", rest, returnType);\n-    }\n-\n-    public static Class<?> loadClass(String className) {\n-        try {\n-            ClassLoader cl = Thread.currentThread().getContextClassLoader();\n-            return cl.loadClass(className.replace('/', '.'));\n-        } catch (ClassNotFoundException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-\n-    public static boolean isPrimitive(Type containerReturnType) {\n-        return Stream.of(BYTE_TYPE, SHORT_TYPE, INT_TYPE, LONG_TYPE, FLOAT_TYPE, DOUBLE_TYPE, VOID_TYPE, BOOLEAN_TYPE)\n-                .filter(containerReturnType::equals)\n-                .findAny()\n-                .isPresent();\n-\n-    }\n-\n-    public static boolean interfaceBelongsToUs(String iff) {\n-        return InputFilesClassLoader.INSTANCE.isOurGuy(iff.replace(\"/\", \".\"));\n-    }\n-\n-    public static boolean declaringClassBelongsToInputFiles(Method method) {\n-        boolean ourGuy = InputFilesClassLoader.INSTANCE.isOurGuy(method.getDeclaringClass().getName());\n-        System.out.println(\"Method: \" + method + \", declaring class: \" + method.getDeclaringClass() + \", our guy: \" + ourGuy);\n-        return ourGuy;\n-    }\n-\n-    private static class InputFilesClassLoader extends URLClassLoader {\n-        private static final InputFilesClassLoader INSTANCE = create();\n-\n-        private InputFilesClassLoader(URL inputFiles) {\n-            super(new URL[]{inputFiles});\n-        }\n-\n-        private static InputFilesClassLoader create() {\n-            Config config = Helpers.config;\n-            System.out.println(\"INCLUDED FILES \" + config.getInputDir());\n-            try {\n-                URL inputFiles = config.getInputDir().toUri().toURL();\n-                return new InputFilesClassLoader(inputFiles);\n-            } catch (Exception e) {\n-                e.printStackTrace();\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-        public boolean isOurGuy(String cname) {\n-            try {\n-                findSystemClass(cname);\n-                return false;\n-            } catch (ClassNotFoundException e) {\n-                try {\n-                    findClass(cname);\n-                    return true;\n-                } catch (ClassNotFoundException e1) {\n-                    return false;\n-                }\n-            }\n-        }\n-    }\n-}\n"
    },
    {
        "commit_hash": "c90ca7cc116fe456d3397f6ae36dd85bc9964f67",
        "previous_commit_hash": "d0287aa3235da1987df0431b1c6b8ebac82d151f",
        "diff_stats": {
            "additions": 0,
            "deletions": 174
        },
        "diff_content": "@@ -1,174 +0,0 @@\n-// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n-// This software is released under the Apache License 2.0.\n-// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n-\n-package net.orfjackal.retrolambda.defaultmethods;\n-\n-import org.objectweb.asm.*;\n-\n-import java.io.IOException;\n-import java.lang.reflect.Method;\n-import java.nio.file.*;\n-import java.util.*;\n-import java.util.stream.*;\n-\n-/**\n- * Created by arneball on 2014-08-12.\n- */\n-public class InterfaceModifier extends ClassVisitor implements Opcodes {\n-    private final int targetByteCode;\n-    private String className;\n-    private boolean isInterface;\n-    private ClassWriter helperClassVisitor;\n-    private String[] interfaces;\n-    private List<MethodContainer> methodContainers = new ArrayList<>();\n-\n-    public InterfaceModifier(ClassVisitor classWriter, int targetBytodeCode) {\n-        super(ASM5, classWriter);\n-        this.targetByteCode = targetBytodeCode;\n-    }\n-\n-    @Override\n-    public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n-        isInterface = (access & ACC_INTERFACE) != 0;\n-        className = name;\n-        this.interfaces = Stream.of(interfaces)\n-                .filter(Helpers::interfaceBelongsToUs)\n-                .toArray(String[]::new);\n-        // force load this class, if not, we are overwriting the interface and succeeding loads will see the purely abstract onoe\n-        Helpers.loadClass(name);\n-        System.out.println(\"Visiting interface \" + name);\n-        super.visit(version, access, name, signature, superName, interfaces);\n-    }\n-\n-    @Override\n-    public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n-        boolean isConcrete = (access & ACC_ABSTRACT) == 0;\n-        boolean isStatic = (access & ACC_STATIC) != 0;\n-        if (isConcrete && isInterface && !isStatic) {\n-            super.visitMethod(access | ACC_ABSTRACT, name, desc, signature, exceptions);\n-            MethodVisitor tmp = getHelperClassVisitor().visitMethod(\n-                    access | ACC_STATIC,\n-                    name,\n-                    Helpers.addParam(desc, className),\n-                    signature,\n-                    exceptions);\n-            methodContainers.add(new MethodContainer(name, desc, null, signature, exceptions));\n-            return new InterfaceToHelperRewriter(new BodyMover(tmp));\n-        } else if (isStatic && isInterface) {\n-            return getHelperClassVisitor().visitMethod(access, name + \"$static\", desc, signature, exceptions);\n-        } else {\n-            return super.visitMethod(access, name, desc, signature, exceptions);\n-        }\n-    }\n-\n-    @Override\n-    public void visitEnd() {\n-        Path newPath = Helpers.config.getOutputDir();\n-        ArrayList<Method> allMethods = Stream.of(interfaces)\n-                .map(Helpers::loadClass)\n-                .flatMap(c -> Stream.of(c.getMethods()))\n-                .collect(Collectors.toCollection(ArrayList::new));\n-        methodContainers.stream().forEach(m -> {\n-            allMethods.stream()\n-                    .filter(meth -> bridgeNeeded(meth, m))\n-                    .forEach(meth -> createBridge(meth, m));\n-        });\n-        getHelperClassVisitor().visitEnd();\n-        super.visitEnd();\n-        try {\n-            Files.createDirectories(newPath.getParent());\n-            Files.write(newPath.resolve(helperClassName() + \".class\"), getHelperClassVisitor().toByteArray());\n-        } catch (IOException e) {\n-            e.printStackTrace();\n-        }\n-    }\n-\n-    private void createBridge(Method meth, MethodContainer m) {\n-        int access = ACC_PUBLIC | ACC_STATIC | ACC_BRIDGE;\n-        String desc = Helpers.addParam(m.methodDesc, className);\n-        String returnType = Type.getReturnType(meth).getInternalName();\n-        desc = Helpers.changeReturnType(desc, returnType);\n-        MethodVisitor tmp = getHelperClassVisitor().visitMethod(access, m.methodName, desc, m.signature, m.exceptions);\n-        tmp.visitVarInsn(ALOAD, 0);\n-        int i = 1;\n-        for (Type arg : Type.getArgumentTypes(m.methodDesc)) {\n-            tmp.visitVarInsn(arg.getOpcode(ILOAD), i++);\n-        }\n-        String mDesc = Helpers.addParam(m.methodDesc, className);\n-        tmp.visitMethodInsn(INVOKESTATIC, className + \"$helper\", m.methodName, mDesc, false);\n-        tmp.visitInsn(ARETURN);\n-        tmp.visitMaxs(0, 0);\n-        tmp.visitEnd();\n-    }\n-\n-    private static boolean bridgeNeeded(Method method, MethodContainer methodContainer) {\n-        Type[] methodArgumentns = Type.getArgumentTypes(method);\n-        Type[] containerArguments = Type.getArgumentTypes(methodContainer.methodDesc);\n-        boolean argsEquals = Arrays.equals(methodArgumentns, containerArguments);\n-        boolean nameEquals = method.getName().equals(methodContainer.methodName);\n-        log(\"\" + method + \" should be equal to \" + methodContainer);\n-        log(\"Args equal = \" + argsEquals + \", nameEquals = \" + nameEquals);\n-        if (!argsEquals || !nameEquals) {\n-            return false;\n-        }\n-        Type containerReturnType = Type.getReturnType(methodContainer.methodDesc);\n-        Type methodReturnType = Type.getReturnType(method);\n-        boolean containerRetPrimite = Helpers.isPrimitive(containerReturnType);\n-        boolean methodRetPrimitive = Helpers.isPrimitive(methodReturnType);\n-        log(\"Container ret primitive = \" + containerRetPrimite + \", methodRetPrimitive = \" + methodRetPrimitive);\n-        if (containerRetPrimite || methodRetPrimitive) {\n-            log(\"Either one primitive, no bridge needed\");\n-            return false;\n-        }\n-\n-        Class<?> returnType = method.getReturnType();\n-        log(\"returnType = \" + returnType + \", isPrimitive = \" + returnType.isPrimitive());\n-        return returnType.isAssignableFrom(Helpers.loadClass(containerReturnType.getClassName()));\n-    }\n-\n-    private static void log(String s) {\n-        System.out.println(\"interfaceModifier ======= \" + s);\n-    }\n-\n-    private ClassWriter getHelperClassVisitor() {\n-        return helperClassVisitor == null ? helperClassVisitor = mkHelperClassVisitor() : helperClassVisitor;\n-    }\n-\n-    private ClassWriter mkHelperClassVisitor() {\n-        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n-        cw.visit(targetByteCode,\n-                ACC_PUBLIC + ACC_SUPER,\n-                helperClassName(),\n-                null,\n-                \"java/lang/Object\",\n-                null);\n-        MethodVisitor mv = cw.visitMethod(ACC_PRIVATE, \"<init>\", \"()V\", null, null);\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitMethodInsn(INVOKESPECIAL, \"java/lang/Object\", \"<init>\", \"()V\", false);\n-        mv.visitInsn(RETURN);\n-        mv.visitMaxs(0, 0);\n-        mv.visitEnd();\n-        return cw;\n-    }\n-\n-    private String helperClassName() {\n-        return className + \"$helper\";\n-    }\n-\n-    private static class BodyMover extends MethodVisitor {\n-        BodyMover(MethodVisitor newMethod) {\n-            super(ASM5, newMethod);\n-        }\n-\n-        @Override\n-        public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\n-            if (opcode == INVOKESPECIAL && itf) {\n-                super.visitMethodInsn(INVOKESTATIC, owner + \"$helper\", name, Helpers.addParam(desc, owner), false);\n-            } else {\n-                super.visitMethodInsn(opcode, owner, name, desc, itf);\n-            }\n-        }\n-\n-    }\n-}\n"
    },
    {
        "commit_hash": "c90ca7cc116fe456d3397f6ae36dd85bc9964f67",
        "previous_commit_hash": "d0287aa3235da1987df0431b1c6b8ebac82d151f",
        "diff_stats": {
            "additions": 0,
            "deletions": 31
        },
        "diff_content": "@@ -1,31 +0,0 @@\n-// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n-// This software is released under the Apache License 2.0.\n-// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n-\n-package net.orfjackal.retrolambda.defaultmethods;\n-\n-import org.objectweb.asm.MethodVisitor;\n-import org.objectweb.asm.Opcodes;\n-\n-/**\n- * Created by arneball on 2014-08-24.\n- */\n-class InterfaceToHelperRewriter extends MethodVisitor implements Opcodes {\n-    public InterfaceToHelperRewriter(MethodVisitor mv) {\n-        super(ASM5, mv);\n-    }\n-\n-    @Override\n-    public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\n-        boolean belongsToUs = Helpers.interfaceBelongsToUs(owner);\n-        String newOwner = belongsToUs ? owner + \"$helper\" : owner;\n-        if (opcode == INVOKESPECIAL && itf) {\n-            super.visitMethodInsn(INVOKESTATIC, newOwner, name, Helpers.addParam(desc, owner), false);\n-        } else if (opcode == INVOKESTATIC && itf) {\n-            String newName = belongsToUs ? name + \"$static\" : name;\n-            super.visitMethodInsn(INVOKESTATIC, newOwner, newName, desc, false);\n-        } else {\n-            super.visitMethodInsn(opcode, owner, name, desc, itf);\n-        }\n-    }\n-}\n"
    },
    {
        "commit_hash": "c90ca7cc116fe456d3397f6ae36dd85bc9964f67",
        "previous_commit_hash": "d0287aa3235da1987df0431b1c6b8ebac82d151f",
        "diff_stats": {
            "additions": 0,
            "deletions": 70
        },
        "diff_content": "@@ -1,70 +0,0 @@\n-// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n-// This software is released under the Apache License 2.0.\n-// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n-\n-package net.orfjackal.retrolambda.defaultmethods;\n-\n-import java.util.Arrays;\n-\n-/**\n- * Created by arneball on 2014-08-23.\n- */\n-class MethodContainer {\n-    public final String methodName, methodDesc, interfce, signature;\n-    public final String[] exceptions;\n-\n-    @Override\n-    public String toString() {\n-        return \"MethodContainer{\" +\n-                \"methodName='\" + methodName + '\\'' +\n-                \", methodDesc='\" + methodDesc + '\\'' +\n-                \", interfce='\" + interfce + '\\'' +\n-                \", signature='\" + signature + '\\'' +\n-                \", exceptions=\" + Arrays.toString(exceptions) +\n-                '}';\n-    }\n-\n-    MethodContainer(String methodName, String methodDesc, String interfce, String signature, String[] exceptions) {\n-        this.methodName = methodName;\n-        this.methodDesc = methodDesc;\n-        this.interfce = interfce;\n-        this.signature = signature;\n-        this.exceptions = exceptions;\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-            return false;\n-        }\n-\n-        MethodContainer that = (MethodContainer) o;\n-\n-        if (!Arrays.equals(exceptions, that.exceptions)) {\n-            return false;\n-        }\n-        if (methodDesc != null ? !methodDesc.equals(that.methodDesc) : that.methodDesc != null) {\n-            return false;\n-        }\n-        if (methodName != null ? !methodName.equals(that.methodName) : that.methodName != null) {\n-            return false;\n-        }\n-        if (signature != null ? !signature.equals(that.signature) : that.signature != null) {\n-            return false;\n-        }\n-\n-        return true;\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        int result = methodName != null ? methodName.hashCode() : 0;\n-        result = 31 * result + (methodDesc != null ? methodDesc.hashCode() : 0);\n-        result = 31 * result + (signature != null ? signature.hashCode() : 0);\n-        result = 31 * result + (exceptions != null ? Arrays.hashCode(exceptions) : 0);\n-        return result;\n-    }\n-}\n"
    },
    {
        "commit_hash": "c90ca7cc116fe456d3397f6ae36dd85bc9964f67",
        "previous_commit_hash": "d0287aa3235da1987df0431b1c6b8ebac82d151f",
        "diff_stats": {
            "additions": 0,
            "deletions": 45
        },
        "diff_content": "@@ -1,45 +0,0 @@\n-// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n-// This software is released under the Apache License 2.0.\n-// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n-\n-package net.orfjackal.retrolambda.defaultmethods;\n-\n-/**\n- * Created by arneball on 2014-08-23.\n- */\n-class VisitedMethod {\n-    public final String name, desc;\n-\n-    VisitedMethod(String name, String desc) {\n-        this.name = name;\n-        this.desc = desc;\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-            return false;\n-        }\n-\n-        VisitedMethod that = (VisitedMethod) o;\n-\n-        if (!desc.equals(that.desc)) {\n-            return false;\n-        }\n-        if (!name.equals(that.name)) {\n-            return false;\n-        }\n-\n-        return true;\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        int result = name.hashCode();\n-        result = 31 * result + desc.hashCode();\n-        return result;\n-    }\n-}\n"
    },
    {
        "commit_hash": "5519d0cd3bbe17beda848dd28cc9c214e867674a",
        "previous_commit_hash": "c90ca7cc116fe456d3397f6ae36dd85bc9964f67",
        "diff_stats": {
            "additions": 8,
            "deletions": 1
        },
        "diff_content": "@@ -40,7 +40,14 @@ public class AddMethodDefaultImplementations extends ClassVisitor {\n     public void visitEnd() {\n         for (String anInterface : interfaces) {\n             for (MethodRef interfaceMethod : methodRelocations.getInterfaceMethods(anInterface)) {\n-                if (!methods.contains(interfaceMethod.withOwner(className))) {\n+                boolean hasOverride = false;\n+                for (MethodRef superMethod : methodRelocations.getSuperclassMethods(className)) {\n+                    if (superMethod.equals(interfaceMethod.withOwner(superMethod.owner))) {\n+                        hasOverride = true;\n+                        break;\n+                    }\n+                }\n+                if (!hasOverride && !methods.contains(interfaceMethod.withOwner(className))) {\n                     generateDefaultImplementation(interfaceMethod);\n                 }\n             }\n"
    },
    {
        "commit_hash": "5519d0cd3bbe17beda848dd28cc9c214e867674a",
        "previous_commit_hash": "c90ca7cc116fe456d3397f6ae36dd85bc9964f67",
        "diff_stats": {
            "additions": 53,
            "deletions": 14
        },
        "diff_content": "@@ -19,8 +19,10 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n \n     private final List<ClassReader> interfaces = new ArrayList<>();\n     private final List<ClassReader> classes = new ArrayList<>();\n+    private final Map<String, String> superclasses = new HashMap<>();\n     private final Map<Type, List<Type>> interfacesByImplementer = new HashMap<>(); // TODO: could use just String instead of Type\n     private final Map<String, List<MethodRef>> methodsByInterface = new HashMap<>();\n+    private final Map<String, List<MethodRef>> methodsByClass = new HashMap<>();\n     private final Map<MethodRef, MethodRef> relocatedMethods = new HashMap<>();\n     private final Map<MethodRef, MethodRef> methodDefaultImpls = new HashMap<>();\n     private final Map<String, String> companionClasses = new HashMap<>();\n@@ -37,12 +39,35 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n \n         List<Type> interfaces = classNamesToTypes(cr.getInterfaces());\n         interfacesByImplementer.put(clazz, interfaces);\n+        superclasses.put(cr.getClassName(), cr.getSuperName());\n \n         if (Flags.hasFlag(cr.getAccess(), ACC_INTERFACE)) {\n             analyzeInterface(cr);\n+        } else {\n+            analyzeClass(cr);\n         }\n     }\n \n+    private void analyzeClass(ClassReader cr) {\n+        cr.accept(new ClassVisitor(ASM5) {\n+            private String owner;\n+\n+            @Override\n+            public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n+                this.owner = name;\n+            }\n+\n+            @Override\n+            public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+                MethodRef method = new MethodRef(owner, name, desc);\n+                methodsByClass.computeIfAbsent(method.owner, key -> new ArrayList<>()).add(method);\n+\n+                return null;\n+            }\n+\n+        }, ClassReader.SKIP_CODE);\n+    }\n+\n     private void analyzeInterface(ClassReader cr) {\n         cr.accept(new ClassVisitor(ASM5) {\n             private String owner;\n@@ -113,21 +138,26 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n \n     @Override\n     public MethodRef getMethodDefaultImplementation(MethodRef interfaceMethod) {\n-        MethodRef impl = methodDefaultImpls.get(interfaceMethod);\n-        if (impl == ABSTRACT_METHOD) {\n-            return null;\n-        }\n-        if (impl != null) {\n-            return impl;\n-        }\n-\n-        // check if a default implementation is inherited from parents\n-        for (Type parentInterface : interfacesByImplementer.getOrDefault(Type.getObjectType(interfaceMethod.owner), Collections.emptyList())) {\n-            impl = getMethodDefaultImplementation(interfaceMethod.withOwner(parentInterface.getInternalName()));\n-            if (impl != null) {\n-                return impl;\n+        MethodRef impl;\n+        List<Type> currentInterfaces = new ArrayList<>();\n+        List<Type> parentInterfaces = new ArrayList<>();\n+        currentInterfaces.add(Type.getObjectType(interfaceMethod.owner));\n+\n+        do {\n+            for (Type anInterface : currentInterfaces) {\n+                impl = methodDefaultImpls.get(interfaceMethod.withOwner(anInterface.getInternalName()));\n+                if (impl == ABSTRACT_METHOD) {\n+                    return null;\n+                }\n+                if (impl != null) {\n+                    return impl;\n+                }\n+                parentInterfaces.addAll(interfacesByImplementer.getOrDefault(anInterface, Collections.emptyList()));\n             }\n-        }\n+            currentInterfaces = parentInterfaces;\n+            parentInterfaces = new ArrayList<>();\n+        } while (!currentInterfaces.isEmpty());\n+\n         return null;\n     }\n \n@@ -143,6 +173,15 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n         return new ArrayList<>(results);\n     }\n \n+    public List<MethodRef> getSuperclassMethods(String className) {\n+        Set<MethodRef> results = new LinkedHashSet<>();\n+        while (superclasses.containsKey(className)) {\n+            className = superclasses.get(className);\n+            results.addAll(methodsByClass.getOrDefault(className, Collections.emptyList()));\n+        }\n+        return new ArrayList<>(results);\n+    }\n+\n     @Override\n     public String getCompanionClass(String className) {\n         return companionClasses.get(className);\n"
    },
    {
        "commit_hash": "5519d0cd3bbe17beda848dd28cc9c214e867674a",
        "previous_commit_hash": "c90ca7cc116fe456d3397f6ae36dd85bc9964f67",
        "diff_stats": {
            "additions": 2,
            "deletions": 0
        },
        "diff_content": "@@ -14,5 +14,7 @@ public interface MethodRelocations {\n \n     List<MethodRef> getInterfaceMethods(String interfaceName);\n \n+    List<MethodRef> getSuperclassMethods(String className);\n+\n     String getCompanionClass(String className);\n }\n"
    },
    {
        "commit_hash": "f31f7bc278e211170a7c7db94652bb501b7a0b1c",
        "previous_commit_hash": "382b5504d44ca93462605077d7a0b4a387c95f5e",
        "diff_stats": {
            "additions": 21,
            "deletions": 0
        },
        "diff_content": "@@ -132,6 +132,27 @@ public class DefaultMethodsTest {\n     }\n \n \n+    @Test\n+    public void implements_original_and_overridden_default_method() {\n+        assertThat(new AB().foo(), is(\"overridden\"));\n+    }\n+\n+    private interface A {\n+        default String foo() {\n+            return \"original\";\n+        }\n+    }\n+\n+    private interface B extends A {\n+        default String foo() {\n+            return \"overridden\";\n+        }\n+    }\n+\n+    private class AB implements A, B {\n+    }\n+\n+\n     // Bridge Methods\n \n     @Test\n"
    },
    {
        "commit_hash": "3556a2bf64e53be1727991ae60e84311ee5d2832",
        "previous_commit_hash": "f31f7bc278e211170a7c7db94652bb501b7a0b1c",
        "diff_stats": {
            "additions": 5,
            "deletions": 1
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -135,6 +135,7 @@ public class DefaultMethodsTest {\n     @Test\n     public void implements_original_and_overridden_default_method() {\n         assertThat(new AB().foo(), is(\"overridden\"));\n+        assertThat(new BA().foo(), is(\"overridden\"));\n     }\n \n     private interface A {\n@@ -152,6 +153,9 @@ public class DefaultMethodsTest {\n     private class AB implements A, B {\n     }\n \n+    private class BA implements B, A {\n+    }\n+\n \n     // Bridge Methods\n \n"
    },
    {
        "commit_hash": "118f68e9400ff7821228dc81400039db1cdefe85",
        "previous_commit_hash": "3556a2bf64e53be1727991ae60e84311ee5d2832",
        "diff_stats": {
            "additions": 6,
            "deletions": 7
        },
        "diff_content": "@@ -5,9 +5,8 @@\n package net.orfjackal.retrolambda;\n \n import net.orfjackal.retrolambda.files.*;\n-import net.orfjackal.retrolambda.interfaces.ClassHierarchyAnalyzer;\n+import net.orfjackal.retrolambda.interfaces.*;\n import net.orfjackal.retrolambda.lambdas.*;\n-import org.objectweb.asm.ClassReader;\n \n import java.io.IOException;\n import java.net.*;\n@@ -57,12 +56,12 @@ public class Retrolambda {\n             });\n \n             List<byte[]> transformed = new ArrayList<>();\n-            for (ClassReader reader : analyzer.getInterfaces()) {\n-                transformed.add(transformers.extractInterfaceCompanion(reader));\n-                transformed.add(transformers.backportInterface(reader));\n+            for (ClassInfo c : analyzer.getInterfaces()) {\n+                transformed.add(transformers.extractInterfaceCompanion(c.reader));\n+                transformed.add(transformers.backportInterface(c.reader));\n             }\n-            for (ClassReader reader : analyzer.getClasses()) {\n-                transformed.add(transformers.backportClass(reader));\n+            for (ClassInfo c : analyzer.getClasses()) {\n+                transformed.add(transformers.backportClass(c.reader));\n             }\n \n             // We need to load some of the classes (for calling the lambda metafactory)\n"
    },
    {
        "commit_hash": "118f68e9400ff7821228dc81400039db1cdefe85",
        "previous_commit_hash": "3556a2bf64e53be1727991ae60e84311ee5d2832",
        "diff_stats": {
            "additions": 26,
            "deletions": 20
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -17,11 +17,12 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n \n     private static final MethodRef ABSTRACT_METHOD = new MethodRef(\"\", \"\", \"\");\n \n-    private final List<ClassReader> interfaces = new ArrayList<>();\n-    private final List<ClassReader> classes = new ArrayList<>();\n+    private final Map<Type, ClassInfo> classes = new HashMap<>();\n+    @Deprecated\n     private final Map<String, String> superclasses = new HashMap<>();\n-    private final Map<Type, List<Type>> interfacesByImplementer = new HashMap<>(); // TODO: could use just String instead of Type\n+    @Deprecated\n     private final Map<String, List<MethodRef>> methodsByInterface = new HashMap<>();\n+    @Deprecated\n     private final Map<String, List<MethodRef>> methodsByClass = new HashMap<>();\n     private final Map<MethodRef, MethodRef> relocatedMethods = new HashMap<>();\n     private final Map<MethodRef, MethodRef> methodDefaultImpls = new HashMap<>();\n@@ -29,16 +30,10 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n \n     public void analyze(byte[] bytecode) {\n         ClassReader cr = new ClassReader(bytecode);\n-        Type clazz = classNameToType(cr.getClassName());\n \n-        if (Flags.hasFlag(cr.getAccess(), ACC_INTERFACE)) {\n-            interfaces.add(cr);\n-        } else {\n-            classes.add(cr);\n-        }\n+        ClassInfo c = new ClassInfo(cr);\n+        classes.put(c.type, c);\n \n-        List<Type> interfaces = classNamesToTypes(cr.getInterfaces());\n-        interfacesByImplementer.put(clazz, interfaces);\n         superclasses.put(cr.getClassName(), cr.getSuperName());\n \n         if (Flags.hasFlag(cr.getAccess(), ACC_INTERFACE)) {\n@@ -119,16 +114,27 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n         }, ClassReader.SKIP_CODE);\n     }\n \n-    public List<ClassReader> getInterfaces() {\n-        return interfaces;\n+    public List<ClassInfo> getInterfaces() {\n+        return classes.values()\n+                .stream()\n+                .filter(ClassInfo::isInterface)\n+                .collect(toList());\n     }\n \n-    public List<ClassReader> getClasses() {\n-        return classes;\n+    public List<ClassInfo> getClasses() {\n+        return classes.values()\n+                .stream()\n+                .filter(ClassInfo::isClass)\n+                .collect(toList());\n     }\n \n     public List<Type> getInterfacesOf(Type type) {\n-        return interfacesByImplementer.getOrDefault(type, Collections.emptyList());\n+        ClassInfo c = classes.get(type);\n+        if (c == null) {\n+            // non-analyzed class, probably from a class library\n+            return Collections.emptyList();\n+        }\n+        return c.interfaces;\n     }\n \n     @Override\n@@ -152,7 +158,7 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n                 if (impl != null) {\n                     return impl;\n                 }\n-                parentInterfaces.addAll(interfacesByImplementer.getOrDefault(anInterface, Collections.emptyList()));\n+                parentInterfaces.addAll(getInterfacesOf(anInterface));\n             }\n             currentInterfaces = parentInterfaces;\n             parentInterfaces = new ArrayList<>();\n@@ -187,13 +193,13 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n         return companionClasses.get(className);\n     }\n \n-    private static List<Type> classNamesToTypes(String[] interfaces) {\n+    static List<Type> classNamesToTypes(String[] interfaces) {\n         return Stream.of(interfaces)\n                 .map(ClassHierarchyAnalyzer::classNameToType)\n                 .collect(toList());\n     }\n \n-    private static Type classNameToType(String className) {\n+    static Type classNameToType(String className) {\n         return Type.getType(\"L\" + className + \";\");\n     }\n }\n"
    },
    {
        "commit_hash": "118f68e9400ff7821228dc81400039db1cdefe85",
        "previous_commit_hash": "3556a2bf64e53be1727991ae60e84311ee5d2832",
        "diff_stats": {
            "additions": 38,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,38 @@\n+// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.interfaces;\n+\n+import net.orfjackal.retrolambda.util.Flags;\n+import org.objectweb.asm.*;\n+\n+import java.util.List;\n+\n+import static net.orfjackal.retrolambda.interfaces.ClassHierarchyAnalyzer.*;\n+import static org.objectweb.asm.Opcodes.ACC_INTERFACE;\n+\n+public class ClassInfo {\n+\n+    public final ClassReader reader;\n+    private final int access;\n+    public final Type type;\n+    public final Type superclass;\n+    public final List<Type> interfaces;\n+\n+    public ClassInfo(ClassReader cr) {\n+        this.reader = cr;\n+        this.access = cr.getAccess();\n+        this.type = classNameToType(cr.getClassName());\n+        this.superclass = classNameToType(cr.getSuperName());\n+        this.interfaces = classNamesToTypes(cr.getInterfaces());\n+    }\n+\n+    public boolean isClass() {\n+        return !isInterface();\n+    }\n+\n+    public boolean isInterface() {\n+        return Flags.hasFlag(access, ACC_INTERFACE);\n+    }\n+}\n"
    },
    {
        "commit_hash": "118f68e9400ff7821228dc81400039db1cdefe85",
        "previous_commit_hash": "3556a2bf64e53be1727991ae60e84311ee5d2832",
        "diff_stats": {
            "additions": 5,
            "deletions": 1
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -26,6 +26,10 @@ public final class MethodRef {\n         this.name = name;\n         this.desc = desc;\n     }\n+    \n+    public MethodSignature getSignature() {\n+        return new MethodSignature(name, desc);\n+    }\n \n     public MethodRef withOwner(String newOwner) {\n         return new MethodRef(newOwner, name, desc);\n"
    },
    {
        "commit_hash": "118f68e9400ff7821228dc81400039db1cdefe85",
        "previous_commit_hash": "3556a2bf64e53be1727991ae60e84311ee5d2832",
        "diff_stats": {
            "additions": 43,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,43 @@\n+// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.interfaces;\n+\n+import com.google.common.base.MoreObjects;\n+\n+import java.util.Objects;\n+\n+public class MethodSignature {\n+\n+    public final String name;\n+    public final String desc;\n+\n+    public MethodSignature(String desc, String name) {\n+        this.name = name;\n+        this.desc = desc;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (!(obj instanceof MethodSignature)) {\n+            return false;\n+        }\n+        MethodSignature that = (MethodSignature) obj;\n+        return this.name.equals(that.name)\n+                && this.desc.equals(that.desc);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(name, desc);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return MoreObjects.toStringHelper(this)\n+                .addValue(name)\n+                .addValue(desc)\n+                .toString();\n+    }\n+}\n"
    },
    {
        "commit_hash": "118f68e9400ff7821228dc81400039db1cdefe85",
        "previous_commit_hash": "3556a2bf64e53be1727991ae60e84311ee5d2832",
        "diff_stats": {
            "additions": 8,
            "deletions": 8
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -7,7 +7,7 @@ package net.orfjackal.retrolambda;\n import com.google.common.io.ByteStreams;\n import net.orfjackal.retrolambda.interfaces.*;\n import org.junit.Test;\n-import org.objectweb.asm.*;\n+import org.objectweb.asm.Type;\n \n import java.io.*;\n import java.util.*;\n@@ -259,11 +259,11 @@ public class ClassHierarchyAnalyzerTest {\n     }\n \n     private List<Class<?>> getInterfaces() {\n-        return readersToClasses(analyzer.getInterfaces());\n+        return infosToClasses(analyzer.getInterfaces());\n     }\n \n     private List<Class<?>> getClasses() {\n-        return readersToClasses(analyzer.getClasses());\n+        return infosToClasses(analyzer.getClasses());\n     }\n \n     private List<Class<?>> getInterfacesOf(Class<?> clazz) {\n@@ -280,8 +280,8 @@ public class ClassHierarchyAnalyzerTest {\n                         .toArray(Type[]::new));\n     }\n \n-    private static List<Class<?>> readersToClasses(List<ClassReader> readers) {\n-        return readers.stream()\n+    private static List<Class<?>> infosToClasses(List<ClassInfo> classes) {\n+        return classes.stream()\n                 .map(ClassHierarchyAnalyzerTest::toClass)\n                 .collect(toList());\n     }\n@@ -296,9 +296,9 @@ public class ClassHierarchyAnalyzerTest {\n         return asList(aClass);\n     }\n \n-    private static Class<?> toClass(ClassReader reader) {\n+    private static Class<?> toClass(ClassInfo c) {\n         try {\n-            return Class.forName(reader.getClassName().replace('/', '.'));\n+            return Class.forName(c.type.getClassName().replace('/', '.'));\n         } catch (ClassNotFoundException e) {\n             throw new RuntimeException(e);\n         }\n"
    },
    {
        "commit_hash": "43fea2407daa888d5a228f446d4579c4dcbaa728",
        "previous_commit_hash": "118f68e9400ff7821228dc81400039db1cdefe85",
        "diff_stats": {
            "additions": 4,
            "deletions": 3
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -9,6 +9,7 @@ import org.objectweb.asm.*;\n \n import java.util.*;\n \n+import static net.orfjackal.retrolambda.interfaces.ClassHierarchyAnalyzer.classNameToType;\n import static org.objectweb.asm.Opcodes.*;\n \n public class AddMethodDefaultImplementations extends ClassVisitor {\n@@ -39,9 +40,9 @@ public class AddMethodDefaultImplementations extends ClassVisitor {\n     @Override\n     public void visitEnd() {\n         for (String anInterface : interfaces) {\n-            for (MethodRef interfaceMethod : methodRelocations.getInterfaceMethods(anInterface)) {\n+            for (MethodRef interfaceMethod : methodRelocations.getInterfaceMethods(classNameToType(anInterface))) {\n                 boolean hasOverride = false;\n-                for (MethodRef superMethod : methodRelocations.getSuperclassMethods(className)) {\n+                for (MethodRef superMethod : methodRelocations.getSuperclassMethods(classNameToType(className))) {\n                     if (superMethod.equals(interfaceMethod.withOwner(superMethod.owner))) {\n                         hasOverride = true;\n                         break;\n"
    },
    {
        "commit_hash": "43fea2407daa888d5a228f446d4579c4dcbaa728",
        "previous_commit_hash": "118f68e9400ff7821228dc81400039db1cdefe85",
        "diff_stats": {
            "additions": 11,
            "deletions": 11
        },
        "diff_content": "@@ -19,11 +19,11 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n \n     private final Map<Type, ClassInfo> classes = new HashMap<>();\n     @Deprecated\n-    private final Map<String, String> superclasses = new HashMap<>();\n+    private final Map<Type, Type> superclasses = new HashMap<>();\n     @Deprecated\n-    private final Map<String, List<MethodRef>> methodsByInterface = new HashMap<>();\n+    private final Map<Type, List<MethodRef>> methodsByInterface = new HashMap<>();\n     @Deprecated\n-    private final Map<String, List<MethodRef>> methodsByClass = new HashMap<>();\n+    private final Map<Type, List<MethodRef>> methodsByClass = new HashMap<>();\n     private final Map<MethodRef, MethodRef> relocatedMethods = new HashMap<>();\n     private final Map<MethodRef, MethodRef> methodDefaultImpls = new HashMap<>();\n     private final Map<String, String> companionClasses = new HashMap<>();\n@@ -34,7 +34,7 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n         ClassInfo c = new ClassInfo(cr);\n         classes.put(c.type, c);\n \n-        superclasses.put(cr.getClassName(), cr.getSuperName());\n+        superclasses.put(c.type, classNameToType(cr.getSuperName()));\n \n         if (Flags.hasFlag(cr.getAccess(), ACC_INTERFACE)) {\n             analyzeInterface(cr);\n@@ -55,7 +55,7 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n             @Override\n             public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n                 MethodRef method = new MethodRef(owner, name, desc);\n-                methodsByClass.computeIfAbsent(method.owner, key -> new ArrayList<>()).add(method);\n+                methodsByClass.computeIfAbsent(classNameToType(method.owner), key -> new ArrayList<>()).add(method);\n \n                 return null;\n             }\n@@ -96,7 +96,7 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n             }\n \n             private void saveInterfaceMethod(MethodRef method) {\n-                methodsByInterface.computeIfAbsent(method.owner, key -> new ArrayList<>()).add(method);\n+                methodsByInterface.computeIfAbsent(classNameToType(method.owner), key -> new ArrayList<>()).add(method);\n             }\n \n             private boolean isAbstractMethod(int access) {\n@@ -168,18 +168,18 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n     }\n \n     @Override\n-    public List<MethodRef> getInterfaceMethods(String interfaceName) {\n+    public List<MethodRef> getInterfaceMethods(Type interfaceName) {\n         Set<MethodRef> results = new LinkedHashSet<>();\n         results.addAll(methodsByInterface.getOrDefault(interfaceName, Collections.emptyList()));\n-        for (Type parent : getInterfacesOf(Type.getObjectType(interfaceName))) {\n-            for (MethodRef parentMethod : getInterfaceMethods(parent.getInternalName())) {\n-                results.add(parentMethod.withOwner(interfaceName));\n+        for (Type parent : getInterfacesOf(interfaceName)) {\n+            for (MethodRef parentMethod : getInterfaceMethods(parent)) {\n+                results.add(parentMethod.withOwner(interfaceName.getInternalName()));\n             }\n         }\n         return new ArrayList<>(results);\n     }\n \n-    public List<MethodRef> getSuperclassMethods(String className) {\n+    public List<MethodRef> getSuperclassMethods(Type className) {\n         Set<MethodRef> results = new LinkedHashSet<>();\n         while (superclasses.containsKey(className)) {\n             className = superclasses.get(className);\n"
    },
    {
        "commit_hash": "43fea2407daa888d5a228f446d4579c4dcbaa728",
        "previous_commit_hash": "118f68e9400ff7821228dc81400039db1cdefe85",
        "diff_stats": {
            "additions": 5,
            "deletions": 3
        },
        "diff_content": "@@ -1,9 +1,11 @@\n-// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n package net.orfjackal.retrolambda.interfaces;\n \n+import org.objectweb.asm.Type;\n+\n import java.util.List;\n \n public interface MethodRelocations {\n@@ -12,9 +14,9 @@ public interface MethodRelocations {\n \n     MethodRef getMethodDefaultImplementation(MethodRef interfaceMethod);\n \n-    List<MethodRef> getInterfaceMethods(String interfaceName);\n+    List<MethodRef> getInterfaceMethods(Type interfaceName);\n \n-    List<MethodRef> getSuperclassMethods(String className);\n+    List<MethodRef> getSuperclassMethods(Type className);\n \n     String getCompanionClass(String className);\n }\n"
    },
    {
        "commit_hash": "43fea2407daa888d5a228f446d4579c4dcbaa728",
        "previous_commit_hash": "118f68e9400ff7821228dc81400039db1cdefe85",
        "diff_stats": {
            "additions": 4,
            "deletions": 8
        },
        "diff_content": "@@ -47,7 +47,7 @@ public class ClassHierarchyAnalyzerTest {\n     public void finds_interface_methods() {\n         analyze(InterfaceMethodTypes.class);\n \n-        assertThat(analyzer.getInterfaceMethods(getInternalName(InterfaceMethodTypes.class)),\n+        assertThat(analyzer.getInterfaceMethods(Type.getType(InterfaceMethodTypes.class)),\n                 containsInAnyOrder(\n                         new MethodRef(InterfaceMethodTypes.class, \"abstractMethod\", voidMethod()),\n                         new MethodRef(InterfaceMethodTypes.class, \"defaultMethod\", voidMethod()))); // all but staticMethod\n@@ -58,14 +58,14 @@ public class ClassHierarchyAnalyzerTest {\n         analyze(ChildInterface.class,\n                 Interface.class);\n \n-        assertThat(analyzer.getInterfaceMethods(getInternalName(ChildInterface.class)),\n+        assertThat(analyzer.getInterfaceMethods(Type.getType(ChildInterface.class)),\n                 containsInAnyOrder(\n                         new MethodRef(ChildInterface.class, \"abstractMethod\", voidMethod())));\n     }\n \n     @Test\n     public void does_not_find_interface_methods_of_not_analyzed_interfaces() {\n-        assertThat(analyzer.getInterfaceMethods(getInternalName(Interface.class)), is(empty()));\n+        assertThat(analyzer.getInterfaceMethods(Type.getType(Interface.class)), is(empty()));\n     }\n \n     private interface Interface {\n@@ -313,14 +313,10 @@ public class ClassHierarchyAnalyzerTest {\n     }\n \n     private static byte[] readBytecode(Class<?> clazz) {\n-        try (InputStream in = clazz.getResourceAsStream(\"/\" + getInternalName(clazz) + \".class\")) {\n+        try (InputStream in = clazz.getResourceAsStream(\"/\" + Type.getType(clazz).getInternalName() + \".class\")) {\n             return ByteStreams.toByteArray(in);\n         } catch (IOException e) {\n             throw new RuntimeException(e);\n         }\n     }\n-\n-    private static String getInternalName(Class<?> clazz) {\n-        return Type.getType(clazz).getInternalName();\n-    }\n }\n"
    },
    {
        "commit_hash": "82f9e8b8ca8b0044900118addc57f974976c3e32",
        "previous_commit_hash": "43fea2407daa888d5a228f446d4579c4dcbaa728",
        "diff_stats": {
            "additions": 9,
            "deletions": 12
        },
        "diff_content": "@@ -19,8 +19,6 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n \n     private final Map<Type, ClassInfo> classes = new HashMap<>();\n     @Deprecated\n-    private final Map<Type, Type> superclasses = new HashMap<>();\n-    @Deprecated\n     private final Map<Type, List<MethodRef>> methodsByInterface = new HashMap<>();\n     @Deprecated\n     private final Map<Type, List<MethodRef>> methodsByClass = new HashMap<>();\n@@ -34,8 +32,6 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n         ClassInfo c = new ClassInfo(cr);\n         classes.put(c.type, c);\n \n-        superclasses.put(c.type, classNameToType(cr.getSuperName()));\n-\n         if (Flags.hasFlag(cr.getAccess(), ACC_INTERFACE)) {\n             analyzeInterface(cr);\n         } else {\n@@ -168,22 +164,23 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n     }\n \n     @Override\n-    public List<MethodRef> getInterfaceMethods(Type interfaceName) {\n+    public List<MethodRef> getInterfaceMethods(Type type) {\n         Set<MethodRef> results = new LinkedHashSet<>();\n-        results.addAll(methodsByInterface.getOrDefault(interfaceName, Collections.emptyList()));\n-        for (Type parent : getInterfacesOf(interfaceName)) {\n+        results.addAll(methodsByInterface.getOrDefault(type, Collections.emptyList()));\n+        for (Type parent : getInterfacesOf(type)) {\n             for (MethodRef parentMethod : getInterfaceMethods(parent)) {\n-                results.add(parentMethod.withOwner(interfaceName.getInternalName()));\n+                results.add(parentMethod.withOwner(type.getInternalName()));\n             }\n         }\n         return new ArrayList<>(results);\n     }\n \n-    public List<MethodRef> getSuperclassMethods(Type className) {\n+    public List<MethodRef> getSuperclassMethods(Type type) {\n         Set<MethodRef> results = new LinkedHashSet<>();\n-        while (superclasses.containsKey(className)) {\n-            className = superclasses.get(className);\n-            results.addAll(methodsByClass.getOrDefault(className, Collections.emptyList()));\n+        while (classes.containsKey(type)) {\n+            ClassInfo c = classes.get(type);\n+            type = c.superclass;\n+            results.addAll(methodsByClass.getOrDefault(type, Collections.emptyList()));\n         }\n         return new ArrayList<>(results);\n     }\n"
    },
    {
        "commit_hash": "5dd5f6d015b3e3b3d1ba97212eac716edd59bf87",
        "previous_commit_hash": "82f9e8b8ca8b0044900118addc57f974976c3e32",
        "diff_stats": {
            "additions": 8,
            "deletions": 19
        },
        "diff_content": "@@ -19,8 +19,6 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n \n     private final Map<Type, ClassInfo> classes = new HashMap<>();\n     @Deprecated\n-    private final Map<Type, List<MethodRef>> methodsByInterface = new HashMap<>();\n-    @Deprecated\n     private final Map<Type, List<MethodRef>> methodsByClass = new HashMap<>();\n     private final Map<MethodRef, MethodRef> relocatedMethods = new HashMap<>();\n     private final Map<MethodRef, MethodRef> methodDefaultImpls = new HashMap<>();\n@@ -33,13 +31,13 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n         classes.put(c.type, c);\n \n         if (Flags.hasFlag(cr.getAccess(), ACC_INTERFACE)) {\n-            analyzeInterface(cr);\n+            analyzeInterface(c, cr);\n         } else {\n-            analyzeClass(cr);\n+            analyzeClass(c, cr);\n         }\n     }\n \n-    private void analyzeClass(ClassReader cr) {\n+    private void analyzeClass(ClassInfo c, ClassReader cr) {\n         cr.accept(new ClassVisitor(ASM5) {\n             private String owner;\n \n@@ -59,7 +57,7 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n         }, ClassReader.SKIP_CODE);\n     }\n \n-    private void analyzeInterface(ClassReader cr) {\n+    private void analyzeInterface(ClassInfo c, ClassReader cr) {\n         cr.accept(new ClassVisitor(ASM5) {\n             private String owner;\n             private String companion;\n@@ -76,13 +74,13 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n \n                 if (isAbstractMethod(access)) {\n                     methodDefaultImpls.put(method, ABSTRACT_METHOD);\n-                    saveInterfaceMethod(method);\n+                    c.methods.add(method);\n \n                 } else if (isDefaultMethod(access)) {\n                     desc = Bytecode.prependArgumentType(desc, Type.getObjectType(owner));\n                     methodDefaultImpls.put(method, new MethodRef(companion, name, desc));\n                     companionClasses.put(owner, companion);\n-                    saveInterfaceMethod(method);\n+                    c.methods.add(method);\n \n                 } else if (isStaticMethod(access)) {\n                     relocatedMethods.put(method, new MethodRef(companion, name, desc));\n@@ -91,10 +89,6 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n                 return null;\n             }\n \n-            private void saveInterfaceMethod(MethodRef method) {\n-                methodsByInterface.computeIfAbsent(classNameToType(method.owner), key -> new ArrayList<>()).add(method);\n-            }\n-\n             private boolean isAbstractMethod(int access) {\n                 return Flags.hasFlag(access, ACC_ABSTRACT);\n             }\n@@ -125,12 +119,7 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n     }\n \n     public List<Type> getInterfacesOf(Type type) {\n-        ClassInfo c = classes.get(type);\n-        if (c == null) {\n-            // non-analyzed class, probably from a class library\n-            return Collections.emptyList();\n-        }\n-        return c.interfaces;\n+        return classes.getOrDefault(type, new ClassInfo()).interfaces;\n     }\n \n     @Override\n@@ -166,7 +155,7 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n     @Override\n     public List<MethodRef> getInterfaceMethods(Type type) {\n         Set<MethodRef> results = new LinkedHashSet<>();\n-        results.addAll(methodsByInterface.getOrDefault(type, Collections.emptyList()));\n+        results.addAll(classes.getOrDefault(type, new ClassInfo()).methods);\n         for (Type parent : getInterfacesOf(type)) {\n             for (MethodRef parentMethod : getInterfaceMethods(parent)) {\n                 results.add(parentMethod.withOwner(type.getInternalName()));\n"
    },
    {
        "commit_hash": "5dd5f6d015b3e3b3d1ba97212eac716edd59bf87",
        "previous_commit_hash": "82f9e8b8ca8b0044900118addc57f974976c3e32",
        "diff_stats": {
            "additions": 10,
            "deletions": 1
        },
        "diff_content": "@@ -7,7 +7,7 @@ package net.orfjackal.retrolambda.interfaces;\n import net.orfjackal.retrolambda.util.Flags;\n import org.objectweb.asm.*;\n \n-import java.util.List;\n+import java.util.*;\n \n import static net.orfjackal.retrolambda.interfaces.ClassHierarchyAnalyzer.*;\n import static org.objectweb.asm.Opcodes.ACC_INTERFACE;\n@@ -19,6 +19,15 @@ public class ClassInfo {\n     public final Type type;\n     public final Type superclass;\n     public final List<Type> interfaces;\n+    public final List<MethodRef> methods = new ArrayList<>();\n+\n+    public ClassInfo() {\n+        this.reader = null;\n+        this.access = 0;\n+        this.type = null;\n+        this.superclass = null;\n+        this.interfaces = new ArrayList<>();\n+    }\n \n     public ClassInfo(ClassReader cr) {\n         this.reader = cr;\n"
    },
    {
        "commit_hash": "3b22b4b5eae5f84ee0931d96093803acee530000",
        "previous_commit_hash": "5dd5f6d015b3e3b3d1ba97212eac716edd59bf87",
        "diff_stats": {
            "additions": 12,
            "deletions": 6
        },
        "diff_content": "@@ -18,8 +18,6 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n     private static final MethodRef ABSTRACT_METHOD = new MethodRef(\"\", \"\", \"\");\n \n     private final Map<Type, ClassInfo> classes = new HashMap<>();\n-    @Deprecated\n-    private final Map<Type, List<MethodRef>> methodsByClass = new HashMap<>();\n     private final Map<MethodRef, MethodRef> relocatedMethods = new HashMap<>();\n     private final Map<MethodRef, MethodRef> methodDefaultImpls = new HashMap<>();\n     private final Map<String, String> companionClasses = new HashMap<>();\n@@ -49,8 +47,12 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n             @Override\n             public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n                 MethodRef method = new MethodRef(owner, name, desc);\n-                methodsByClass.computeIfAbsent(classNameToType(method.owner), key -> new ArrayList<>()).add(method);\n+                // FIXME: skip static methods\n+                c.methods.add(method);\n \n+                // XXX: backporting Retrolambda fails if we remove this; it tries backporting a lambda while backporting a lambda\n+                Runnable r = () -> {\n+                };\n                 return null;\n             }\n \n@@ -118,8 +120,12 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n                 .collect(toList());\n     }\n \n+    private ClassInfo getClass(Type type) {\n+        return classes.getOrDefault(type, new ClassInfo());\n+    }\n+\n     public List<Type> getInterfacesOf(Type type) {\n-        return classes.getOrDefault(type, new ClassInfo()).interfaces;\n+        return getClass(type).interfaces;\n     }\n \n     @Override\n@@ -155,7 +161,7 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n     @Override\n     public List<MethodRef> getInterfaceMethods(Type type) {\n         Set<MethodRef> results = new LinkedHashSet<>();\n-        results.addAll(classes.getOrDefault(type, new ClassInfo()).methods);\n+        results.addAll(getClass(type).methods);\n         for (Type parent : getInterfacesOf(type)) {\n             for (MethodRef parentMethod : getInterfaceMethods(parent)) {\n                 results.add(parentMethod.withOwner(type.getInternalName()));\n@@ -169,7 +175,7 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n         while (classes.containsKey(type)) {\n             ClassInfo c = classes.get(type);\n             type = c.superclass;\n-            results.addAll(methodsByClass.getOrDefault(type, Collections.emptyList()));\n+            results.addAll(getClass(type).methods);\n         }\n         return new ArrayList<>(results);\n     }\n"
    },
    {
        "commit_hash": "a49ab23f07eaf81aaa2cf2b6a2a61449a4b6c1b5",
        "previous_commit_hash": "3b22b4b5eae5f84ee0931d96093803acee530000",
        "diff_stats": {
            "additions": 4,
            "deletions": 0
        },
        "diff_content": "@@ -41,6 +41,10 @@\n     <inspection_tool class=\"ListIndexOfReplaceableByContains\" enabled=\"true\" level=\"WARNING\" enabled_by_default=\"true\" />\n     <inspection_tool class=\"LongLiteralsEndingWithLowercaseL\" enabled=\"true\" level=\"WARNING\" enabled_by_default=\"true\" />\n     <inspection_tool class=\"MethodMayBeSynchronized\" enabled=\"true\" level=\"WARNING\" enabled_by_default=\"true\" />\n+    <inspection_tool class=\"MissingOverrideAnnotation\" enabled=\"true\" level=\"WARNING\" enabled_by_default=\"true\">\n+      <option name=\"ignoreObjectMethods\" value=\"false\" />\n+      <option name=\"ignoreAnonymousClassMethods\" value=\"false\" />\n+    </inspection_tool>\n     <inspection_tool class=\"NonSerializableWithSerialVersionUIDField\" enabled=\"true\" level=\"WARNING\" enabled_by_default=\"true\" />\n     <inspection_tool class=\"RawUseOfParameterizedType\" enabled=\"true\" level=\"WARNING\" enabled_by_default=\"true\" />\n     <inspection_tool class=\"RedundantSuppression\" enabled=\"true\" level=\"WARNING\" enabled_by_default=\"true\" />\n"
    },
    {
        "commit_hash": "a49ab23f07eaf81aaa2cf2b6a2a61449a4b6c1b5",
        "previous_commit_hash": "3b22b4b5eae5f84ee0931d96093803acee530000",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -145,6 +145,7 @@ public class DefaultMethodsTest {\n     }\n \n     private interface B extends A {\n+        @Override\n         default String foo() {\n             return \"overridden\";\n         }\n"
    },
    {
        "commit_hash": "a49ab23f07eaf81aaa2cf2b6a2a61449a4b6c1b5",
        "previous_commit_hash": "3b22b4b5eae5f84ee0931d96093803acee530000",
        "diff_stats": {
            "additions": 5,
            "deletions": 1
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -19,14 +19,17 @@ public class FilteringFileVisitor implements FileVisitor<Path> {\n         this.target = target;\n     }\n \n+    @Override\n     public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {\n         return target.postVisitDirectory(dir, exc);\n     }\n \n+    @Override\n     public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {\n         return target.preVisitDirectory(dir, attrs);\n     }\n \n+    @Override\n     public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n         if (fileFilter.contains(file)) {\n             return target.visitFile(file, attrs);\n@@ -35,6 +38,7 @@ public class FilteringFileVisitor implements FileVisitor<Path> {\n         }\n     }\n \n+    @Override\n     public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {\n         return target.visitFileFailed(file, exc);\n     }\n"
    },
    {
        "commit_hash": "a49ab23f07eaf81aaa2cf2b6a2a61449a4b6c1b5",
        "previous_commit_hash": "3b22b4b5eae5f84ee0931d96093803acee530000",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -170,6 +170,7 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n         return new ArrayList<>(results);\n     }\n \n+    @Override\n     public List<MethodRef> getSuperclassMethods(Type type) {\n         Set<MethodRef> results = new LinkedHashSet<>();\n         while (classes.containsKey(type)) {\n"
    },
    {
        "commit_hash": "da3792bb5c7f0349eadc522749be9ece849a7173",
        "previous_commit_hash": "a49ab23f07eaf81aaa2cf2b6a2a61449a4b6c1b5",
        "diff_stats": {
            "additions": 20,
            "deletions": 10
        },
        "diff_content": "@@ -17,7 +17,7 @@ public class AddMethodDefaultImplementations extends ClassVisitor {\n     private final MethodRelocations methodRelocations;\n     private String className;\n     private String[] interfaces;\n-    private final Set<MethodRef> methods = new HashSet<>();\n+    private final Set<MethodSignature> methods = new HashSet<>();\n \n     public AddMethodDefaultImplementations(ClassVisitor next, MethodRelocations methodRelocations) {\n         super(ASM5, next);\n@@ -33,7 +33,7 @@ public class AddMethodDefaultImplementations extends ClassVisitor {\n \n     @Override\n     public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n-        methods.add(new MethodRef(className, name, desc));\n+        methods.add(new MethodSignature(name, desc));\n         return super.visitMethod(access, name, desc, signature, exceptions);\n     }\n \n@@ -41,14 +41,7 @@ public class AddMethodDefaultImplementations extends ClassVisitor {\n     public void visitEnd() {\n         for (String anInterface : interfaces) {\n             for (MethodRef interfaceMethod : methodRelocations.getInterfaceMethods(classNameToType(anInterface))) {\n-                boolean hasOverride = false;\n-                for (MethodRef superMethod : methodRelocations.getSuperclassMethods(classNameToType(className))) {\n-                    if (superMethod.equals(interfaceMethod.withOwner(superMethod.owner))) {\n-                        hasOverride = true;\n-                        break;\n-                    }\n-                }\n-                if (!hasOverride && !methods.contains(interfaceMethod.withOwner(className))) {\n+                if (!overrides(interfaceMethod.getSignature())) {\n                     generateDefaultImplementation(interfaceMethod);\n                 }\n             }\n@@ -56,6 +49,23 @@ public class AddMethodDefaultImplementations extends ClassVisitor {\n         super.visitEnd();\n     }\n \n+    private boolean overrides(MethodSignature method) {\n+        return thisOverrides(method) || superclassOverrides(method);\n+    }\n+\n+    private boolean thisOverrides(MethodSignature method) {\n+        return methods.contains(method);\n+    }\n+\n+    private boolean superclassOverrides(MethodSignature method) {\n+        for (MethodSignature superMethod : methodRelocations.getSuperclassMethods(classNameToType(className))) {\n+            if (superMethod.equals(method)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n     private void generateDefaultImplementation(MethodRef interfaceMethod) {\n         MethodRef impl = methodRelocations.getMethodDefaultImplementation(interfaceMethod);\n         Bytecode.generateDelegateMethod(cv, ACC_PUBLIC | ACC_SYNTHETIC, interfaceMethod.toHandle(H_INVOKEVIRTUAL), impl.toHandle(H_INVOKESTATIC));\n"
    },
    {
        "commit_hash": "da3792bb5c7f0349eadc522749be9ece849a7173",
        "previous_commit_hash": "a49ab23f07eaf81aaa2cf2b6a2a61449a4b6c1b5",
        "diff_stats": {
            "additions": 4,
            "deletions": 2
        },
        "diff_content": "@@ -171,14 +171,16 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n     }\n \n     @Override\n-    public List<MethodRef> getSuperclassMethods(Type type) {\n+    public List<MethodSignature> getSuperclassMethods(Type type) {\n         Set<MethodRef> results = new LinkedHashSet<>();\n         while (classes.containsKey(type)) {\n             ClassInfo c = classes.get(type);\n             type = c.superclass;\n             results.addAll(getClass(type).methods);\n         }\n-        return new ArrayList<>(results);\n+        return results.stream()\n+                .map(MethodRef::getSignature)\n+                .collect(toList());\n     }\n \n     @Override\n"
    },
    {
        "commit_hash": "da3792bb5c7f0349eadc522749be9ece849a7173",
        "previous_commit_hash": "a49ab23f07eaf81aaa2cf2b6a2a61449a4b6c1b5",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -16,7 +16,7 @@ public interface MethodRelocations {\n \n     List<MethodRef> getInterfaceMethods(Type interfaceName);\n \n-    List<MethodRef> getSuperclassMethods(Type className);\n+    List<MethodSignature> getSuperclassMethods(Type className);\n \n     String getCompanionClass(String className);\n }\n"
    },
    {
        "commit_hash": "1ffcd829c92c058814b2121abe8acd9467774de8",
        "previous_commit_hash": "da3792bb5c7f0349eadc522749be9ece849a7173",
        "diff_stats": {
            "additions": 5,
            "deletions": 3
        },
        "diff_content": "@@ -9,6 +9,8 @@ import net.orfjackal.retrolambda.lambdas.*;\n import net.orfjackal.retrolambda.trywithresources.SwallowSuppressedExceptions;\n import org.objectweb.asm.*;\n \n+import java.util.Optional;\n+\n public class Transformers {\n \n     private final int targetVersion;\n@@ -60,13 +62,13 @@ public class Transformers {\n     }\n \n     public byte[] extractInterfaceCompanion(ClassReader reader) {\n-        String companion = methodRelocations.getCompanionClass(reader.getClassName());\n-        if (companion == null) {\n+        Optional<Type> companion = methodRelocations.getCompanionClass(Type.getObjectType(reader.getClassName()));\n+        if (!companion.isPresent()) {\n             return null;\n         }\n         return transform(reader, (next) -> {\n             next = new UpdateRelocatedMethodInvocations(next, methodRelocations);\n-            next = new ExtractInterfaceCompanionClass(next, companion);\n+            next = new ExtractInterfaceCompanionClass(next, companion.get());\n             return next;\n         });\n     }\n"
    },
    {
        "commit_hash": "1ffcd829c92c058814b2121abe8acd9467774de8",
        "previous_commit_hash": "da3792bb5c7f0349eadc522749be9ece849a7173",
        "diff_stats": {
            "additions": 7,
            "deletions": 8
        },
        "diff_content": "@@ -20,7 +20,6 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n     private final Map<Type, ClassInfo> classes = new HashMap<>();\n     private final Map<MethodRef, MethodRef> relocatedMethods = new HashMap<>();\n     private final Map<MethodRef, MethodRef> methodDefaultImpls = new HashMap<>();\n-    private final Map<String, String> companionClasses = new HashMap<>();\n \n     public void analyze(byte[] bytecode) {\n         ClassReader cr = new ClassReader(bytecode);\n@@ -48,7 +47,7 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n             public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n                 MethodRef method = new MethodRef(owner, name, desc);\n                 // FIXME: skip static methods\n-                c.methods.add(method);\n+                c.addMethod(method);\n \n                 // XXX: backporting Retrolambda fails if we remove this; it tries backporting a lambda while backporting a lambda\n                 Runnable r = () -> {\n@@ -76,17 +75,17 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n \n                 if (isAbstractMethod(access)) {\n                     methodDefaultImpls.put(method, ABSTRACT_METHOD);\n-                    c.methods.add(method);\n+                    c.addMethod(method);\n \n                 } else if (isDefaultMethod(access)) {\n                     desc = Bytecode.prependArgumentType(desc, Type.getObjectType(owner));\n                     methodDefaultImpls.put(method, new MethodRef(companion, name, desc));\n-                    companionClasses.put(owner, companion);\n-                    c.methods.add(method);\n+                    c.enableCompanionClass();\n+                    c.addMethod(method);\n \n                 } else if (isStaticMethod(access)) {\n                     relocatedMethods.put(method, new MethodRef(companion, name, desc));\n-                    companionClasses.put(owner, companion);\n+                    c.enableCompanionClass();\n                 }\n                 return null;\n             }\n@@ -184,8 +183,8 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n     }\n \n     @Override\n-    public String getCompanionClass(String className) {\n-        return companionClasses.get(className);\n+    public Optional<Type> getCompanionClass(Type type) {\n+        return getClass(type).getCompanionClass();\n     }\n \n     static List<Type> classNamesToTypes(String[] interfaces) {\n"
    },
    {
        "commit_hash": "1ffcd829c92c058814b2121abe8acd9467774de8",
        "previous_commit_hash": "da3792bb5c7f0349eadc522749be9ece849a7173",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -20,6 +20,7 @@ public class ClassInfo {\n     public final Type superclass;\n     public final List<Type> interfaces;\n     public final List<MethodRef> methods = new ArrayList<>();\n+    private Type companion;\n \n     public ClassInfo() {\n         this.reader = null;\n@@ -37,6 +38,18 @@ public class ClassInfo {\n         this.interfaces = classNamesToTypes(cr.getInterfaces());\n     }\n \n+    public void addMethod(MethodRef method) {\n+        methods.add(method);\n+    }\n+\n+    public void enableCompanionClass() {\n+        this.companion = Type.getObjectType(type.getInternalName() + \"$\");\n+    }\n+\n+    public Optional<Type> getCompanionClass() {\n+        return Optional.ofNullable(companion);\n+    }\n+\n     public boolean isClass() {\n         return !isInterface();\n     }\n"
    },
    {
        "commit_hash": "1ffcd829c92c058814b2121abe8acd9467774de8",
        "previous_commit_hash": "da3792bb5c7f0349eadc522749be9ece849a7173",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -11,10 +11,10 @@ import static org.objectweb.asm.Opcodes.*;\n \n public class ExtractInterfaceCompanionClass extends ClassVisitor {\n \n-    private final String companion;\n+    private final Type companion;\n     private String interfaceName;\n \n-    public ExtractInterfaceCompanionClass(ClassVisitor next, String companion) {\n+    public ExtractInterfaceCompanionClass(ClassVisitor next, Type companion) {\n         super(ASM5, next);\n         this.companion = companion;\n     }\n@@ -22,7 +22,7 @@ public class ExtractInterfaceCompanionClass extends ClassVisitor {\n     @Override\n     public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n         interfaceName = name;\n-        name = companion;\n+        name = companion.getInternalName();\n         access &= ~ACC_INTERFACE;\n         access &= ~ACC_ABSTRACT;\n         super.visit(version, access, name, signature, superName, interfaces);\n"
    },
    {
        "commit_hash": "1ffcd829c92c058814b2121abe8acd9467774de8",
        "previous_commit_hash": "da3792bb5c7f0349eadc522749be9ece849a7173",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -6,7 +6,7 @@ package net.orfjackal.retrolambda.interfaces;\n \n import org.objectweb.asm.Type;\n \n-import java.util.List;\n+import java.util.*;\n \n public interface MethodRelocations {\n \n@@ -18,5 +18,5 @@ public interface MethodRelocations {\n \n     List<MethodSignature> getSuperclassMethods(Type className);\n \n-    String getCompanionClass(String className);\n+    Optional<Type> getCompanionClass(Type type);\n }\n"
    },
    {
        "commit_hash": "1ffcd829c92c058814b2121abe8acd9467774de8",
        "previous_commit_hash": "da3792bb5c7f0349eadc522749be9ece849a7173",
        "diff_stats": {
            "additions": 5,
            "deletions": 5
        },
        "diff_content": "@@ -240,10 +240,10 @@ public class ClassHierarchyAnalyzerTest {\n                 HasDefaultMethods.class,\n                 ClassMethodTypes.class);\n \n-        assertThat(\"Interface\", analyzer.getCompanionClass(Type.getInternalName(Interface.class)), is(nullValue()));\n-        assertThat(\"InterfaceMethodTypes\", analyzer.getCompanionClass(Type.getInternalName(InterfaceMethodTypes.class)), is(Type.getInternalName(InterfaceMethodTypes$.class)));\n-        assertThat(\"HasDefaultMethods\", analyzer.getCompanionClass(Type.getInternalName(HasDefaultMethods.class)), is(Type.getInternalName(HasDefaultMethods$.class)));\n-        assertThat(\"ClassMethodTypes\", analyzer.getCompanionClass(Type.getInternalName(ClassMethodTypes.class)), is(nullValue()));\n+        assertThat(\"Interface\", analyzer.getCompanionClass(Type.getType(Interface.class)), is(Optional.empty()));\n+        assertThat(\"InterfaceMethodTypes\", analyzer.getCompanionClass(Type.getType(InterfaceMethodTypes.class)), is(Optional.of(Type.getType(InterfaceMethodTypes$.class))));\n+        assertThat(\"HasDefaultMethods\", analyzer.getCompanionClass(Type.getType(HasDefaultMethods.class)), is(Optional.of(Type.getType(HasDefaultMethods$.class))));\n+        assertThat(\"ClassMethodTypes\", analyzer.getCompanionClass(Type.getType(ClassMethodTypes.class)), is(Optional.empty()));\n     }\n \n \n@@ -298,7 +298,7 @@ public class ClassHierarchyAnalyzerTest {\n \n     private static Class<?> toClass(ClassInfo c) {\n         try {\n-            return Class.forName(c.type.getClassName().replace('/', '.'));\n+            return Class.forName(c.type.getClassName());\n         } catch (ClassNotFoundException e) {\n             throw new RuntimeException(e);\n         }\n"
    },
    {
        "commit_hash": "942e33cb76557e57c0bc062a66af7e6e78df2629",
        "previous_commit_hash": "1ffcd829c92c058814b2121abe8acd9467774de8",
        "diff_stats": {
            "additions": 2,
            "deletions": 3
        },
        "diff_content": "@@ -9,7 +9,6 @@ import org.objectweb.asm.*;\n \n import java.util.*;\n \n-import static net.orfjackal.retrolambda.interfaces.ClassHierarchyAnalyzer.classNameToType;\n import static org.objectweb.asm.Opcodes.*;\n \n public class AddMethodDefaultImplementations extends ClassVisitor {\n@@ -40,7 +39,7 @@ public class AddMethodDefaultImplementations extends ClassVisitor {\n     @Override\n     public void visitEnd() {\n         for (String anInterface : interfaces) {\n-            for (MethodRef interfaceMethod : methodRelocations.getInterfaceMethods(classNameToType(anInterface))) {\n+            for (MethodRef interfaceMethod : methodRelocations.getInterfaceMethods(Type.getObjectType(anInterface))) {\n                 if (!overrides(interfaceMethod.getSignature())) {\n                     generateDefaultImplementation(interfaceMethod);\n                 }\n@@ -58,7 +57,7 @@ public class AddMethodDefaultImplementations extends ClassVisitor {\n     }\n \n     private boolean superclassOverrides(MethodSignature method) {\n-        for (MethodSignature superMethod : methodRelocations.getSuperclassMethods(classNameToType(className))) {\n+        for (MethodSignature superMethod : methodRelocations.getSuperclassMethods(Type.getObjectType(className))) {\n             if (superMethod.equals(method)) {\n                 return true;\n             }\n"
    },
    {
        "commit_hash": "942e33cb76557e57c0bc062a66af7e6e78df2629",
        "previous_commit_hash": "1ffcd829c92c058814b2121abe8acd9467774de8",
        "diff_stats": {
            "additions": 2,
            "deletions": 13
        },
        "diff_content": "@@ -8,7 +8,6 @@ import net.orfjackal.retrolambda.util.*;\n import org.objectweb.asm.*;\n \n import java.util.*;\n-import java.util.stream.Stream;\n \n import static java.util.stream.Collectors.toList;\n import static org.objectweb.asm.Opcodes.*;\n@@ -160,7 +159,7 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n     @Override\n     public List<MethodRef> getInterfaceMethods(Type type) {\n         Set<MethodRef> results = new LinkedHashSet<>();\n-        results.addAll(getClass(type).methods);\n+        results.addAll(getClass(type).getMethods());\n         for (Type parent : getInterfacesOf(type)) {\n             for (MethodRef parentMethod : getInterfaceMethods(parent)) {\n                 results.add(parentMethod.withOwner(type.getInternalName()));\n@@ -175,7 +174,7 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n         while (classes.containsKey(type)) {\n             ClassInfo c = classes.get(type);\n             type = c.superclass;\n-            results.addAll(getClass(type).methods);\n+            results.addAll(getClass(type).getMethods());\n         }\n         return results.stream()\n                 .map(MethodRef::getSignature)\n@@ -186,14 +185,4 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n     public Optional<Type> getCompanionClass(Type type) {\n         return getClass(type).getCompanionClass();\n     }\n-\n-    static List<Type> classNamesToTypes(String[] interfaces) {\n-        return Stream.of(interfaces)\n-                .map(ClassHierarchyAnalyzer::classNameToType)\n-                .collect(toList());\n-    }\n-\n-    static Type classNameToType(String className) {\n-        return Type.getType(\"L\" + className + \";\");\n-    }\n }\n"
    },
    {
        "commit_hash": "942e33cb76557e57c0bc062a66af7e6e78df2629",
        "previous_commit_hash": "1ffcd829c92c058814b2121abe8acd9467774de8",
        "diff_stats": {
            "additions": 16,
            "deletions": 11
        },
        "diff_content": "@@ -8,8 +8,9 @@ import net.orfjackal.retrolambda.util.Flags;\n import org.objectweb.asm.*;\n \n import java.util.*;\n+import java.util.stream.Stream;\n \n-import static net.orfjackal.retrolambda.interfaces.ClassHierarchyAnalyzer.*;\n+import static java.util.stream.Collectors.toList;\n import static org.objectweb.asm.Opcodes.ACC_INTERFACE;\n \n public class ClassInfo {\n@@ -19,35 +20,39 @@ public class ClassInfo {\n     public final Type type;\n     public final Type superclass;\n     public final List<Type> interfaces;\n-    public final List<MethodRef> methods = new ArrayList<>();\n-    private Type companion;\n+    private final List<MethodRef> methods = new ArrayList<>();\n+    private Optional<Type> companionClass = Optional.empty();\n \n     public ClassInfo() {\n         this.reader = null;\n         this.access = 0;\n         this.type = null;\n         this.superclass = null;\n-        this.interfaces = new ArrayList<>();\n+        this.interfaces = Collections.emptyList();\n     }\n \n     public ClassInfo(ClassReader cr) {\n         this.reader = cr;\n         this.access = cr.getAccess();\n-        this.type = classNameToType(cr.getClassName());\n-        this.superclass = classNameToType(cr.getSuperName());\n-        this.interfaces = classNamesToTypes(cr.getInterfaces());\n+        this.type = Type.getObjectType(cr.getClassName());\n+        this.superclass = Type.getObjectType(cr.getSuperName());\n+        this.interfaces = Stream.of(cr.getInterfaces()).map(Type::getObjectType).collect(toList());\n+    }\n+\n+    public List<MethodRef> getMethods() {\n+        return methods;\n     }\n \n     public void addMethod(MethodRef method) {\n         methods.add(method);\n     }\n \n-    public void enableCompanionClass() {\n-        this.companion = Type.getObjectType(type.getInternalName() + \"$\");\n+    public Optional<Type> getCompanionClass() {\n+        return companionClass;\n     }\n \n-    public Optional<Type> getCompanionClass() {\n-        return Optional.ofNullable(companion);\n+    public void enableCompanionClass() {\n+        this.companionClass = Optional.of(Type.getObjectType(type.getInternalName() + \"$\"));\n     }\n \n     public boolean isClass() {\n"
    },
    {
        "commit_hash": "942e33cb76557e57c0bc062a66af7e6e78df2629",
        "previous_commit_hash": "1ffcd829c92c058814b2121abe8acd9467774de8",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -39,7 +39,7 @@ public class ClassHierarchyAnalyzerTest {\n                 InterfaceImplementer.class);\n \n         assertThat(\"Interface\", getInterfacesOf(Interface.class), is(empty()));\n-        assertThat(\"ChildInterface\", getInterfacesOf(ChildInterface.class), is(Arrays.asList(Interface.class)));\n+        assertThat(\"ChildInterface\", getInterfacesOf(ChildInterface.class), is(classList(Interface.class)));\n         assertThat(\"InterfaceImplementer\", getInterfacesOf(InterfaceImplementer.class), is(classList(Interface.class)));\n     }\n \n"
    },
    {
        "commit_hash": "281aa17f7e8a0b14d332fc903f9a0d67a0b6fd52",
        "previous_commit_hash": "942e33cb76557e57c0bc062a66af7e6e78df2629",
        "diff_stats": {
            "additions": 27,
            "deletions": 8
        },
        "diff_content": "@@ -44,9 +44,10 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n \n             @Override\n             public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n-                MethodRef method = new MethodRef(owner, name, desc);\n-                // FIXME: skip static methods\n-                c.addMethod(method);\n+                if (name.equals(\"<init>\") || Flags.hasFlag(access, ACC_STATIC)) {\n+                    return null;\n+                }\n+                c.addMethod(new MethodRef(owner, name, desc), new MethodKind.Concrete());\n \n                 // XXX: backporting Retrolambda fails if we remove this; it tries backporting a lambda while backporting a lambda\n                 Runnable r = () -> {\n@@ -74,13 +75,14 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n \n                 if (isAbstractMethod(access)) {\n                     methodDefaultImpls.put(method, ABSTRACT_METHOD);\n-                    c.addMethod(method);\n+                    c.addMethod(method, new MethodKind.Abstract());\n \n                 } else if (isDefaultMethod(access)) {\n                     desc = Bytecode.prependArgumentType(desc, Type.getObjectType(owner));\n-                    methodDefaultImpls.put(method, new MethodRef(companion, name, desc));\n+                    MethodRef defaultImpl = new MethodRef(companion, name, desc);\n+                    methodDefaultImpls.put(method, defaultImpl);\n                     c.enableCompanionClass();\n-                    c.addMethod(method);\n+                    c.addMethod(method, new MethodKind.Default(defaultImpl));\n \n                 } else if (isStaticMethod(access)) {\n                     relocatedMethods.put(method, new MethodRef(companion, name, desc));\n@@ -159,7 +161,7 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n     @Override\n     public List<MethodRef> getInterfaceMethods(Type type) {\n         Set<MethodRef> results = new LinkedHashSet<>();\n-        results.addAll(getClass(type).getMethods());\n+        results.addAll(getClass(type).getMethodRefs());\n         for (Type parent : getInterfacesOf(type)) {\n             for (MethodRef parentMethod : getInterfaceMethods(parent)) {\n                 results.add(parentMethod.withOwner(type.getInternalName()));\n@@ -174,7 +176,7 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n         while (classes.containsKey(type)) {\n             ClassInfo c = classes.get(type);\n             type = c.superclass;\n-            results.addAll(getClass(type).getMethods());\n+            results.addAll(getClass(type).getMethodRefs());\n         }\n         return results.stream()\n                 .map(MethodRef::getSignature)\n@@ -185,4 +187,21 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n     public Optional<Type> getCompanionClass(Type type) {\n         return getClass(type).getCompanionClass();\n     }\n+\n+    public Collection<MethodInfo> getMethods(Type type) {\n+        ClassInfo c = getClass(type);\n+        Map<MethodSignature, MethodInfo> methods = new HashMap<>();\n+\n+        for (Type iface : c.interfaces) {\n+            for (MethodInfo m : getMethods(iface)) {\n+                methods.put(m.signature, m);\n+            }\n+        }\n+\n+        // the current class' methods override methods from interfaces\n+        for (MethodInfo m : c.getMethods()) {\n+            methods.put(m.signature, m);\n+        }\n+        return methods.values();\n+    }\n }\n"
    },
    {
        "commit_hash": "281aa17f7e8a0b14d332fc903f9a0d67a0b6fd52",
        "previous_commit_hash": "942e33cb76557e57c0bc062a66af7e6e78df2629",
        "diff_stats": {
            "additions": 11,
            "deletions": 5
        },
        "diff_content": "@@ -20,7 +20,8 @@ public class ClassInfo {\n     public final Type type;\n     public final Type superclass;\n     public final List<Type> interfaces;\n-    private final List<MethodRef> methods = new ArrayList<>();\n+    private final List<MethodInfo> methods = new ArrayList<>();\n+    private final List<MethodRef> methodRefs = new ArrayList<>();\n     private Optional<Type> companionClass = Optional.empty();\n \n     public ClassInfo() {\n@@ -39,12 +40,17 @@ public class ClassInfo {\n         this.interfaces = Stream.of(cr.getInterfaces()).map(Type::getObjectType).collect(toList());\n     }\n \n-    public List<MethodRef> getMethods() {\n-        return methods;\n+    public List<MethodInfo> getMethods() {\n+        return Collections.unmodifiableList(methods);\n     }\n \n-    public void addMethod(MethodRef method) {\n-        methods.add(method);\n+    public List<MethodRef> getMethodRefs() {\n+        return Collections.unmodifiableList(methodRefs);\n+    }\n+\n+    public void addMethod(MethodRef method, MethodKind kind) {\n+        methods.add(new MethodInfo(method.getSignature(), kind));\n+        methodRefs.add(method);\n     }\n \n     public Optional<Type> getCompanionClass() {\n"
    },
    {
        "commit_hash": "281aa17f7e8a0b14d332fc903f9a0d67a0b6fd52",
        "previous_commit_hash": "942e33cb76557e57c0bc062a66af7e6e78df2629",
        "diff_stats": {
            "additions": 47,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,47 @@\n+// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.interfaces;\n+\n+import com.google.common.base.MoreObjects;\n+\n+import java.util.Objects;\n+\n+public class MethodInfo {\n+\n+    public final MethodSignature signature;\n+    public final MethodKind kind;\n+\n+    public MethodInfo(String name, String desc, MethodKind kind) {\n+        this(new MethodSignature(name, desc), kind);\n+    }\n+\n+    public MethodInfo(MethodSignature signature, MethodKind kind) {\n+        this.signature = signature;\n+        this.kind = kind;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (!(obj instanceof MethodInfo)) {\n+            return false;\n+        }\n+        MethodInfo that = (MethodInfo) obj;\n+        return this.signature.equals(that.signature)\n+                && this.kind.equals(that.kind);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(signature, kind);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return MoreObjects.toStringHelper(this)\n+                .addValue(signature)\n+                .addValue(kind)\n+                .toString();\n+    }\n+}\n"
    },
    {
        "commit_hash": "281aa17f7e8a0b14d332fc903f9a0d67a0b6fd52",
        "previous_commit_hash": "942e33cb76557e57c0bc062a66af7e6e78df2629",
        "diff_stats": {
            "additions": 72,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,72 @@\n+// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.interfaces;\n+\n+import com.google.common.base.MoreObjects;\n+\n+import java.util.Objects;\n+\n+public abstract class MethodKind {\n+\n+    private MethodKind() {\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (!(obj instanceof MethodKind)) {\n+            return false;\n+        }\n+        MethodKind that = (MethodKind) obj;\n+        return this.getClass() == that.getClass();\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(getClass());\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return MoreObjects.toStringHelper(this)\n+                .toString();\n+    }\n+\n+\n+    public static class Abstract extends MethodKind {\n+    }\n+\n+    public static class Concrete extends MethodKind {\n+    }\n+\n+    public static class Default extends MethodKind {\n+\n+        public final MethodRef defaultImpl;\n+\n+        public Default(MethodRef defaultImpl) {\n+            this.defaultImpl = defaultImpl;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (!(obj instanceof Default)) {\n+                return false;\n+            }\n+            Default that = (Default) obj;\n+            return this.defaultImpl.equals(that.defaultImpl);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(defaultImpl);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return MoreObjects.toStringHelper(this)\n+                    .addValue(defaultImpl)\n+                    .toString();\n+        }\n+    }\n+}\n"
    },
    {
        "commit_hash": "281aa17f7e8a0b14d332fc903f9a0d67a0b6fd52",
        "previous_commit_hash": "942e33cb76557e57c0bc062a66af7e6e78df2629",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -13,7 +13,7 @@ public class MethodSignature {\n     public final String name;\n     public final String desc;\n \n-    public MethodSignature(String desc, String name) {\n+    public MethodSignature(String name, String desc) {\n         this.name = name;\n         this.desc = desc;\n     }\n"
    },
    {
        "commit_hash": "281aa17f7e8a0b14d332fc903f9a0d67a0b6fd52",
        "previous_commit_hash": "942e33cb76557e57c0bc062a66af7e6e78df2629",
        "diff_stats": {
            "additions": 77,
            "deletions": 0
        },
        "diff_content": "@@ -82,6 +82,83 @@ public class ClassHierarchyAnalyzerTest {\n     }\n \n \n+    // Method inheritance\n+\n+    @Test\n+    public void abstract_interface_method_inherited_and_implemented() {\n+        analyze(Interface.class,\n+                ChildInterface.class,\n+                InterfaceImplementer.class);\n+\n+        assertThat(\"original\", analyzer.getMethods(Type.getType(Interface.class)),\n+                containsInAnyOrder(new MethodInfo(\"abstractMethod\", \"()V\", new MethodKind.Abstract())));\n+\n+        assertThat(\"inherits unchanged\", analyzer.getMethods(Type.getType(ChildInterface.class)),\n+                containsInAnyOrder(new MethodInfo(\"abstractMethod\", \"()V\", new MethodKind.Abstract())));\n+\n+        assertThat(\"implements\", analyzer.getMethods(Type.getType(InterfaceImplementer.class)),\n+                containsInAnyOrder(new MethodInfo(\"abstractMethod\", \"()V\", new MethodKind.Concrete())));\n+    }\n+\n+    @Test\n+    public void interface_method_types() {\n+        analyze(InterfaceMethodTypes.class);\n+\n+        assertThat(analyzer.getMethods(Type.getType(InterfaceMethodTypes.class)),\n+                containsInAnyOrder(\n+                        new MethodInfo(\"abstractMethod\", \"()V\", new MethodKind.Abstract()),\n+                        new MethodInfo(\"defaultMethod\", \"()V\", new MethodKind.Default(\n+                                new MethodRef(InterfaceMethodTypes$.class, \"defaultMethod\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$InterfaceMethodTypes;)V\")))));\n+    }\n+\n+    @Test\n+    public void class_method_types() {\n+        analyze(ClassMethodTypes.class);\n+\n+        // TODO: make a difference between abstract and concrete instance methods?\n+        // An abstract instance method will probably take precedence over a default method,\n+        // so our algorithm might require abstract instance methods to be considered same as concrete.\n+        assertThat(analyzer.getMethods(Type.getType(ClassMethodTypes.class)),\n+                containsInAnyOrder(\n+                        new MethodInfo(\"abstractMethod\", \"()V\", new MethodKind.Concrete()),\n+                        new MethodInfo(\"instanceMethod\", \"()V\", new MethodKind.Concrete())));\n+    }\n+\n+    @Test\n+    public void default_method_overridden_and_abstracted() {\n+        analyze(HasDefaultMethods.class,\n+                DoesNotOverrideDefaultMethods.class,\n+                OverridesDefaultMethods.class,\n+                AbstractsDefaultMethods.class);\n+\n+        assertThat(\"original\", analyzer.getMethods(Type.getType(HasDefaultMethods.class)),\n+                containsInAnyOrder(\n+                        new MethodInfo(\"abstractMethod\", \"()V\", new MethodKind.Abstract()),\n+                        new MethodInfo(\"defaultMethod\", \"()V\", new MethodKind.Default(\n+                                new MethodRef(HasDefaultMethods$.class, \"defaultMethod\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$HasDefaultMethods;)V\")))));\n+\n+        assertThat(\"inherits unchanged\", analyzer.getMethods(Type.getType(DoesNotOverrideDefaultMethods.class)),\n+                containsInAnyOrder(\n+                        new MethodInfo(\"abstractMethod\", \"()V\", new MethodKind.Abstract()),\n+                        new MethodInfo(\"defaultMethod\", \"()V\", new MethodKind.Default(\n+                                new MethodRef(HasDefaultMethods$.class, \"defaultMethod\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$HasDefaultMethods;)V\")))));\n+\n+        assertThat(\"changes default impl\", analyzer.getMethods(Type.getType(OverridesDefaultMethods.class)),\n+                containsInAnyOrder(\n+                        new MethodInfo(\"abstractMethod\", \"()V\", new MethodKind.Abstract()),\n+                        new MethodInfo(\"defaultMethod\", \"()V\", new MethodKind.Default(\n+                                new MethodRef(OverridesDefaultMethods$.class, \"defaultMethod\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$OverridesDefaultMethods;)V\")))));\n+\n+        assertThat(\"makes abstract\", analyzer.getMethods(Type.getType(AbstractsDefaultMethods.class)),\n+                containsInAnyOrder(\n+                        new MethodInfo(\"abstractMethod\", \"()V\", new MethodKind.Abstract()),\n+                        new MethodInfo(\"defaultMethod\", \"()V\", new MethodKind.Abstract())));\n+    }\n+\n+    // TODO: superclasses\n+    // TODO: edge cases from e2e tests\n+\n+\n     // Method relocations\n \n     @Test\n"
    },
    {
        "commit_hash": "9c4b7f54c9651b43ba59bde14ca3c7a06fd454cc",
        "previous_commit_hash": "281aa17f7e8a0b14d332fc903f9a0d67a0b6fd52",
        "diff_stats": {
            "additions": 9,
            "deletions": 2
        },
        "diff_content": "@@ -192,13 +192,20 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n         ClassInfo c = getClass(type);\n         Map<MethodSignature, MethodInfo> methods = new HashMap<>();\n \n+        // in reverse priority order:\n+        // - default methods\n         for (Type iface : c.interfaces) {\n             for (MethodInfo m : getMethods(iface)) {\n                 methods.put(m.signature, m);\n             }\n         }\n-\n-        // the current class' methods override methods from interfaces\n+        // - superclass methods\n+        if (c.superclass != null) {\n+            for (MethodInfo m : getMethods(c.superclass)) {\n+                methods.put(m.signature, m);\n+            }\n+        }\n+        // - own methods\n         for (MethodInfo m : c.getMethods()) {\n             methods.put(m.signature, m);\n         }\n"
    },
    {
        "commit_hash": "9c4b7f54c9651b43ba59bde14ca3c7a06fd454cc",
        "previous_commit_hash": "281aa17f7e8a0b14d332fc903f9a0d67a0b6fd52",
        "diff_stats": {
            "additions": 77,
            "deletions": 1
        },
        "diff_content": "@@ -155,7 +155,83 @@ public class ClassHierarchyAnalyzerTest {\n                         new MethodInfo(\"defaultMethod\", \"()V\", new MethodKind.Abstract())));\n     }\n \n-    // TODO: superclasses\n+    @Test\n+    public void superclass_inheritance() {\n+        analyze(BaseClass.class,\n+                ChildClass.class);\n+\n+        assertThat(\"original\", analyzer.getMethods(Type.getType(BaseClass.class)),\n+                containsInAnyOrder(\n+                        new MethodInfo(\"baseMethod\", \"()V\", new MethodKind.Concrete())));\n+\n+        assertThat(\"inherits unchanged\", analyzer.getMethods(Type.getType(ChildClass.class)),\n+                containsInAnyOrder(\n+                        new MethodInfo(\"baseMethod\", \"()V\", new MethodKind.Concrete())));\n+    }\n+\n+    private class BaseClass {\n+        void baseMethod() {\n+        }\n+    }\n+\n+    private class ChildClass extends BaseClass {\n+    }\n+\n+    @Test\n+    public void overriding_default_methods() {\n+        analyze(DefaultMethods.class,\n+                InheritsDefault.class,\n+                OverridesDefault.class,\n+                InheritsOverridesDefault.class,\n+                InheritsOverridesDefaultAndDirectlyImplements.class);\n+\n+        assertThat(\"original\", analyzer.getMethods(Type.getType(DefaultMethods.class)),\n+                containsInAnyOrder(\n+                        new MethodInfo(\"foo\", \"()V\", new MethodKind.Default(\n+                                new MethodRef(DefaultMethods$.class, \"foo\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$DefaultMethods;)V\")))));\n+\n+        assertThat(\"inherits unchanged\", analyzer.getMethods(Type.getType(InheritsDefault.class)),\n+                containsInAnyOrder(\n+                        new MethodInfo(\"foo\", \"()V\", new MethodKind.Default(\n+                                new MethodRef(DefaultMethods$.class, \"foo\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$DefaultMethods;)V\")))));\n+\n+        assertThat(\"overrides\", analyzer.getMethods(Type.getType(OverridesDefault.class)),\n+                containsInAnyOrder(\n+                        new MethodInfo(\"foo\", \"()V\", new MethodKind.Concrete())));\n+\n+        assertThat(\"inherits overridden\", analyzer.getMethods(Type.getType(InheritsOverridesDefault.class)),\n+                containsInAnyOrder(\n+                        new MethodInfo(\"foo\", \"()V\", new MethodKind.Concrete())));\n+\n+        assertThat(\"inherits overridden\", analyzer.getMethods(Type.getType(InheritsOverridesDefaultAndDirectlyImplements.class)),\n+                containsInAnyOrder(\n+                        new MethodInfo(\"foo\", \"()V\", new MethodKind.Concrete())));\n+    }\n+\n+    private interface DefaultMethods {\n+        default void foo() {\n+        }\n+    }\n+\n+    private interface DefaultMethods$ {\n+    }\n+\n+    private class InheritsDefault implements DefaultMethods {\n+    }\n+\n+    private class OverridesDefault implements DefaultMethods {\n+        @Override\n+        public void foo() {\n+        }\n+    }\n+\n+    class InheritsOverridesDefault extends OverridesDefault {\n+    }\n+\n+    class InheritsOverridesDefaultAndDirectlyImplements extends OverridesDefault implements DefaultMethods {\n+    }\n+\n+\n     // TODO: edge cases from e2e tests\n \n \n"
    },
    {
        "commit_hash": "1ede67d75ef18a43d6408f0f32002f7f7a5dd368",
        "previous_commit_hash": "9c4b7f54c9651b43ba59bde14ca3c7a06fd454cc",
        "diff_stats": {
            "additions": 103,
            "deletions": 96
        },
        "diff_content": "@@ -24,7 +24,7 @@ public class ClassHierarchyAnalyzerTest {\n     private final ClassHierarchyAnalyzer analyzer = new ClassHierarchyAnalyzer();\n \n     @Test\n-    public void finds_interfaces_and_classes_separately() {\n+    public void lists_interfaces_and_classes_separately() {\n         analyze(Interface.class,\n                 InterfaceImplementer.class);\n \n@@ -32,40 +32,23 @@ public class ClassHierarchyAnalyzerTest {\n         assertThat(\"classes\", getClasses(), is(classList(InterfaceImplementer.class)));\n     }\n \n+\n+    // Method inheritance\n+\n     @Test\n-    public void finds_implemented_interfaces() {\n+    public void abstract_interface_method_inherited_and_implemented() {\n         analyze(Interface.class,\n                 ChildInterface.class,\n                 InterfaceImplementer.class);\n \n-        assertThat(\"Interface\", getInterfacesOf(Interface.class), is(empty()));\n-        assertThat(\"ChildInterface\", getInterfacesOf(ChildInterface.class), is(classList(Interface.class)));\n-        assertThat(\"InterfaceImplementer\", getInterfacesOf(InterfaceImplementer.class), is(classList(Interface.class)));\n-    }\n-\n-    @Test\n-    public void finds_interface_methods() {\n-        analyze(InterfaceMethodTypes.class);\n-\n-        assertThat(analyzer.getInterfaceMethods(Type.getType(InterfaceMethodTypes.class)),\n-                containsInAnyOrder(\n-                        new MethodRef(InterfaceMethodTypes.class, \"abstractMethod\", voidMethod()),\n-                        new MethodRef(InterfaceMethodTypes.class, \"defaultMethod\", voidMethod()))); // all but staticMethod\n-    }\n-\n-    @Test\n-    public void finds_inherited_interface_methods() {\n-        analyze(ChildInterface.class,\n-                Interface.class);\n+        assertThat(\"original\", analyzer.getMethods(Type.getType(Interface.class)),\n+                containsInAnyOrder(new MethodInfo(\"abstractMethod\", \"()V\", new MethodKind.Abstract())));\n \n-        assertThat(analyzer.getInterfaceMethods(Type.getType(ChildInterface.class)),\n-                containsInAnyOrder(\n-                        new MethodRef(ChildInterface.class, \"abstractMethod\", voidMethod())));\n-    }\n+        assertThat(\"inherits unchanged\", analyzer.getMethods(Type.getType(ChildInterface.class)),\n+                containsInAnyOrder(new MethodInfo(\"abstractMethod\", \"()V\", new MethodKind.Abstract())));\n \n-    @Test\n-    public void does_not_find_interface_methods_of_not_analyzed_interfaces() {\n-        assertThat(analyzer.getInterfaceMethods(Type.getType(Interface.class)), is(empty()));\n+        assertThat(\"implements\", analyzer.getMethods(Type.getType(InterfaceImplementer.class)),\n+                containsInAnyOrder(new MethodInfo(\"abstractMethod\", \"()V\", new MethodKind.Concrete())));\n     }\n \n     private interface Interface {\n@@ -82,24 +65,6 @@ public class ClassHierarchyAnalyzerTest {\n     }\n \n \n-    // Method inheritance\n-\n-    @Test\n-    public void abstract_interface_method_inherited_and_implemented() {\n-        analyze(Interface.class,\n-                ChildInterface.class,\n-                InterfaceImplementer.class);\n-\n-        assertThat(\"original\", analyzer.getMethods(Type.getType(Interface.class)),\n-                containsInAnyOrder(new MethodInfo(\"abstractMethod\", \"()V\", new MethodKind.Abstract())));\n-\n-        assertThat(\"inherits unchanged\", analyzer.getMethods(Type.getType(ChildInterface.class)),\n-                containsInAnyOrder(new MethodInfo(\"abstractMethod\", \"()V\", new MethodKind.Abstract())));\n-\n-        assertThat(\"implements\", analyzer.getMethods(Type.getType(InterfaceImplementer.class)),\n-                containsInAnyOrder(new MethodInfo(\"abstractMethod\", \"()V\", new MethodKind.Concrete())));\n-    }\n-\n     @Test\n     public void interface_method_types() {\n         analyze(InterfaceMethodTypes.class);\n@@ -124,6 +89,30 @@ public class ClassHierarchyAnalyzerTest {\n                         new MethodInfo(\"instanceMethod\", \"()V\", new MethodKind.Concrete())));\n     }\n \n+    private interface InterfaceMethodTypes {\n+        void abstractMethod();\n+\n+        default void defaultMethod() {\n+        }\n+\n+        static void staticMethod() {\n+        }\n+    }\n+\n+    private interface InterfaceMethodTypes$ {\n+    }\n+\n+    private static abstract class ClassMethodTypes {\n+        public abstract void abstractMethod();\n+\n+        public void instanceMethod() {\n+        }\n+\n+        public static void staticMethod() {\n+        }\n+    }\n+\n+\n     @Test\n     public void default_method_overridden_and_abstracted() {\n         analyze(HasDefaultMethods.class,\n@@ -155,6 +144,34 @@ public class ClassHierarchyAnalyzerTest {\n                         new MethodInfo(\"defaultMethod\", \"()V\", new MethodKind.Abstract())));\n     }\n \n+    private interface HasDefaultMethods {\n+        void abstractMethod();\n+\n+        default void defaultMethod() {\n+        }\n+    }\n+\n+    private interface HasDefaultMethods$ {\n+    }\n+\n+    private interface DoesNotOverrideDefaultMethods extends HasDefaultMethods {\n+    }\n+\n+    private interface OverridesDefaultMethods extends HasDefaultMethods {\n+        @Override\n+        default void defaultMethod() {\n+        }\n+    }\n+\n+    private interface OverridesDefaultMethods$ {\n+    }\n+\n+    private interface AbstractsDefaultMethods extends HasDefaultMethods {\n+        @Override\n+        void defaultMethod();\n+    }\n+\n+\n     @Test\n     public void superclass_inheritance() {\n         analyze(BaseClass.class,\n@@ -177,6 +194,7 @@ public class ClassHierarchyAnalyzerTest {\n     private class ChildClass extends BaseClass {\n     }\n \n+\n     @Test\n     public void overriding_default_methods() {\n         analyze(DefaultMethods.class,\n@@ -235,6 +253,45 @@ public class ClassHierarchyAnalyzerTest {\n     // TODO: edge cases from e2e tests\n \n \n+    // Older tests\n+\n+    @Test\n+    public void finds_implemented_interfaces() {\n+        analyze(Interface.class,\n+                ChildInterface.class,\n+                InterfaceImplementer.class);\n+\n+        assertThat(\"Interface\", getInterfacesOf(Interface.class), is(empty()));\n+        assertThat(\"ChildInterface\", getInterfacesOf(ChildInterface.class), is(classList(Interface.class)));\n+        assertThat(\"InterfaceImplementer\", getInterfacesOf(InterfaceImplementer.class), is(classList(Interface.class)));\n+    }\n+\n+    @Test\n+    public void finds_interface_methods() {\n+        analyze(InterfaceMethodTypes.class);\n+\n+        assertThat(analyzer.getInterfaceMethods(Type.getType(InterfaceMethodTypes.class)),\n+                containsInAnyOrder(\n+                        new MethodRef(InterfaceMethodTypes.class, \"abstractMethod\", voidMethod()),\n+                        new MethodRef(InterfaceMethodTypes.class, \"defaultMethod\", voidMethod()))); // all but staticMethod\n+    }\n+\n+    @Test\n+    public void finds_inherited_interface_methods() {\n+        analyze(ChildInterface.class,\n+                Interface.class);\n+\n+        assertThat(analyzer.getInterfaceMethods(Type.getType(ChildInterface.class)),\n+                containsInAnyOrder(\n+                        new MethodRef(ChildInterface.class, \"abstractMethod\", voidMethod())));\n+    }\n+\n+    @Test\n+    public void does_not_find_interface_methods_of_not_analyzed_interfaces() {\n+        assertThat(analyzer.getInterfaceMethods(Type.getType(Interface.class)), is(empty()));\n+    }\n+\n+\n     // Method relocations\n \n     @Test\n@@ -277,29 +334,6 @@ public class ClassHierarchyAnalyzerTest {\n         assertThat(target, is(source));\n     }\n \n-    private interface InterfaceMethodTypes {\n-        void abstractMethod();\n-\n-        default void defaultMethod() {\n-        }\n-\n-        static void staticMethod() {\n-        }\n-    }\n-\n-    private interface InterfaceMethodTypes$ {\n-    }\n-\n-    private static abstract class ClassMethodTypes {\n-        public abstract void abstractMethod();\n-\n-        public void instanceMethod() {\n-        }\n-\n-        public static void staticMethod() {\n-        }\n-    }\n-\n \n     // Default method implementations\n \n@@ -356,33 +390,6 @@ public class ClassHierarchyAnalyzerTest {\n         assertThat(impl, is(nullValue()));\n     }\n \n-    private interface HasDefaultMethods {\n-        void abstractMethod();\n-\n-        default void defaultMethod() {\n-        }\n-    }\n-\n-    private interface HasDefaultMethods$ {\n-    }\n-\n-    private interface DoesNotOverrideDefaultMethods extends HasDefaultMethods {\n-    }\n-\n-    private interface OverridesDefaultMethods extends HasDefaultMethods {\n-        @Override\n-        default void defaultMethod() {\n-        }\n-    }\n-\n-    private interface OverridesDefaultMethods$ {\n-    }\n-\n-    private interface AbstractsDefaultMethods extends HasDefaultMethods {\n-        @Override\n-        void defaultMethod();\n-    }\n-\n \n     // Companion class\n \n"
    },
    {
        "commit_hash": "654f1072fc6b9ef5653a91ab82c94f6fb1ee44eb",
        "previous_commit_hash": "1ede67d75ef18a43d6408f0f32002f7f7a5dd368",
        "diff_stats": {
            "additions": 18,
            "deletions": 1
        },
        "diff_content": "@@ -196,7 +196,9 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n         // - default methods\n         for (Type iface : c.interfaces) {\n             for (MethodInfo m : getMethods(iface)) {\n-                methods.put(m.signature, m);\n+                if (!isAlreadyInherited(m, methods)) {\n+                    methods.put(m.signature, m);\n+                }\n             }\n         }\n         // - superclass methods\n@@ -211,4 +213,19 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n         }\n         return methods.values();\n     }\n+\n+    private boolean isAlreadyInherited(MethodInfo subject, Map<MethodSignature, MethodInfo> existingMethods) {\n+        MethodInfo existing = existingMethods.get(subject.signature);\n+        return existing != null && getAllInterfaces(existing.owner).contains(subject.owner);\n+    }\n+\n+    private Set<Type> getAllInterfaces(Type interfaceType) {\n+        assert getClass(interfaceType).isInterface() : \"not interface: \" + interfaceType;\n+        HashSet<Type> results = new HashSet<>();\n+        results.add(interfaceType);\n+        for (Type parentInterface : getClass(interfaceType).interfaces) {\n+            results.addAll(getAllInterfaces(parentInterface));\n+        }\n+        return results;\n+    }\n }\n"
    },
    {
        "commit_hash": "654f1072fc6b9ef5653a91ab82c94f6fb1ee44eb",
        "previous_commit_hash": "1ede67d75ef18a43d6408f0f32002f7f7a5dd368",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -49,7 +49,7 @@ public class ClassInfo {\n     }\n \n     public void addMethod(MethodRef method, MethodKind kind) {\n-        methods.add(new MethodInfo(method.getSignature(), kind));\n+        methods.add(new MethodInfo(method.getSignature(), Type.getObjectType(method.owner), kind));\n         methodRefs.add(method);\n     }\n \n"
    },
    {
        "commit_hash": "654f1072fc6b9ef5653a91ab82c94f6fb1ee44eb",
        "previous_commit_hash": "1ede67d75ef18a43d6408f0f32002f7f7a5dd368",
        "diff_stats": {
            "additions": 9,
            "deletions": 4
        },
        "diff_content": "@@ -5,20 +5,23 @@\n package net.orfjackal.retrolambda.interfaces;\n \n import com.google.common.base.MoreObjects;\n+import org.objectweb.asm.Type;\n \n import java.util.Objects;\n \n public class MethodInfo {\n \n     public final MethodSignature signature;\n+    public final Type owner;\n     public final MethodKind kind;\n \n-    public MethodInfo(String name, String desc, MethodKind kind) {\n-        this(new MethodSignature(name, desc), kind);\n+    public MethodInfo(String name, String desc, Class<?> owner, MethodKind kind) {\n+        this(new MethodSignature(name, desc), Type.getType(owner), kind);\n     }\n \n-    public MethodInfo(MethodSignature signature, MethodKind kind) {\n+    public MethodInfo(MethodSignature signature, Type owner, MethodKind kind) {\n         this.signature = signature;\n+        this.owner = owner;\n         this.kind = kind;\n     }\n \n@@ -29,18 +32,20 @@ public class MethodInfo {\n         }\n         MethodInfo that = (MethodInfo) obj;\n         return this.signature.equals(that.signature)\n+                && this.owner.equals(that.owner)\n                 && this.kind.equals(that.kind);\n     }\n \n     @Override\n     public int hashCode() {\n-        return Objects.hash(signature, kind);\n+        return Objects.hash(signature, owner, kind);\n     }\n \n     @Override\n     public String toString() {\n         return MoreObjects.toStringHelper(this)\n                 .addValue(signature)\n+                .addValue(owner)\n                 .addValue(kind)\n                 .toString();\n     }\n"
    },
    {
        "commit_hash": "654f1072fc6b9ef5653a91ab82c94f6fb1ee44eb",
        "previous_commit_hash": "1ede67d75ef18a43d6408f0f32002f7f7a5dd368",
        "diff_stats": {
            "additions": 76,
            "deletions": 22
        },
        "diff_content": "@@ -42,13 +42,13 @@ public class ClassHierarchyAnalyzerTest {\n                 InterfaceImplementer.class);\n \n         assertThat(\"original\", analyzer.getMethods(Type.getType(Interface.class)),\n-                containsInAnyOrder(new MethodInfo(\"abstractMethod\", \"()V\", new MethodKind.Abstract())));\n+                containsInAnyOrder(new MethodInfo(\"abstractMethod\", \"()V\", Interface.class, new MethodKind.Abstract())));\n \n         assertThat(\"inherits unchanged\", analyzer.getMethods(Type.getType(ChildInterface.class)),\n-                containsInAnyOrder(new MethodInfo(\"abstractMethod\", \"()V\", new MethodKind.Abstract())));\n+                containsInAnyOrder(new MethodInfo(\"abstractMethod\", \"()V\", Interface.class, new MethodKind.Abstract())));\n \n         assertThat(\"implements\", analyzer.getMethods(Type.getType(InterfaceImplementer.class)),\n-                containsInAnyOrder(new MethodInfo(\"abstractMethod\", \"()V\", new MethodKind.Concrete())));\n+                containsInAnyOrder(new MethodInfo(\"abstractMethod\", \"()V\", InterfaceImplementer.class, new MethodKind.Concrete())));\n     }\n \n     private interface Interface {\n@@ -71,8 +71,8 @@ public class ClassHierarchyAnalyzerTest {\n \n         assertThat(analyzer.getMethods(Type.getType(InterfaceMethodTypes.class)),\n                 containsInAnyOrder(\n-                        new MethodInfo(\"abstractMethod\", \"()V\", new MethodKind.Abstract()),\n-                        new MethodInfo(\"defaultMethod\", \"()V\", new MethodKind.Default(\n+                        new MethodInfo(\"abstractMethod\", \"()V\", InterfaceMethodTypes.class, new MethodKind.Abstract()),\n+                        new MethodInfo(\"defaultMethod\", \"()V\", InterfaceMethodTypes.class, new MethodKind.Default(\n                                 new MethodRef(InterfaceMethodTypes$.class, \"defaultMethod\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$InterfaceMethodTypes;)V\")))));\n     }\n \n@@ -85,8 +85,8 @@ public class ClassHierarchyAnalyzerTest {\n         // so our algorithm might require abstract instance methods to be considered same as concrete.\n         assertThat(analyzer.getMethods(Type.getType(ClassMethodTypes.class)),\n                 containsInAnyOrder(\n-                        new MethodInfo(\"abstractMethod\", \"()V\", new MethodKind.Concrete()),\n-                        new MethodInfo(\"instanceMethod\", \"()V\", new MethodKind.Concrete())));\n+                        new MethodInfo(\"abstractMethod\", \"()V\", ClassMethodTypes.class, new MethodKind.Concrete()),\n+                        new MethodInfo(\"instanceMethod\", \"()V\", ClassMethodTypes.class, new MethodKind.Concrete())));\n     }\n \n     private interface InterfaceMethodTypes {\n@@ -122,26 +122,26 @@ public class ClassHierarchyAnalyzerTest {\n \n         assertThat(\"original\", analyzer.getMethods(Type.getType(HasDefaultMethods.class)),\n                 containsInAnyOrder(\n-                        new MethodInfo(\"abstractMethod\", \"()V\", new MethodKind.Abstract()),\n-                        new MethodInfo(\"defaultMethod\", \"()V\", new MethodKind.Default(\n+                        new MethodInfo(\"abstractMethod\", \"()V\", HasDefaultMethods.class, new MethodKind.Abstract()),\n+                        new MethodInfo(\"defaultMethod\", \"()V\", HasDefaultMethods.class, new MethodKind.Default(\n                                 new MethodRef(HasDefaultMethods$.class, \"defaultMethod\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$HasDefaultMethods;)V\")))));\n \n         assertThat(\"inherits unchanged\", analyzer.getMethods(Type.getType(DoesNotOverrideDefaultMethods.class)),\n                 containsInAnyOrder(\n-                        new MethodInfo(\"abstractMethod\", \"()V\", new MethodKind.Abstract()),\n-                        new MethodInfo(\"defaultMethod\", \"()V\", new MethodKind.Default(\n+                        new MethodInfo(\"abstractMethod\", \"()V\", HasDefaultMethods.class, new MethodKind.Abstract()),\n+                        new MethodInfo(\"defaultMethod\", \"()V\", HasDefaultMethods.class, new MethodKind.Default(\n                                 new MethodRef(HasDefaultMethods$.class, \"defaultMethod\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$HasDefaultMethods;)V\")))));\n \n         assertThat(\"changes default impl\", analyzer.getMethods(Type.getType(OverridesDefaultMethods.class)),\n                 containsInAnyOrder(\n-                        new MethodInfo(\"abstractMethod\", \"()V\", new MethodKind.Abstract()),\n-                        new MethodInfo(\"defaultMethod\", \"()V\", new MethodKind.Default(\n+                        new MethodInfo(\"abstractMethod\", \"()V\", HasDefaultMethods.class, new MethodKind.Abstract()),\n+                        new MethodInfo(\"defaultMethod\", \"()V\", OverridesDefaultMethods.class, new MethodKind.Default(\n                                 new MethodRef(OverridesDefaultMethods$.class, \"defaultMethod\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$OverridesDefaultMethods;)V\")))));\n \n         assertThat(\"makes abstract\", analyzer.getMethods(Type.getType(AbstractsDefaultMethods.class)),\n                 containsInAnyOrder(\n-                        new MethodInfo(\"abstractMethod\", \"()V\", new MethodKind.Abstract()),\n-                        new MethodInfo(\"defaultMethod\", \"()V\", new MethodKind.Abstract())));\n+                        new MethodInfo(\"abstractMethod\", \"()V\", HasDefaultMethods.class, new MethodKind.Abstract()),\n+                        new MethodInfo(\"defaultMethod\", \"()V\", AbstractsDefaultMethods.class, new MethodKind.Abstract())));\n     }\n \n     private interface HasDefaultMethods {\n@@ -179,11 +179,11 @@ public class ClassHierarchyAnalyzerTest {\n \n         assertThat(\"original\", analyzer.getMethods(Type.getType(BaseClass.class)),\n                 containsInAnyOrder(\n-                        new MethodInfo(\"baseMethod\", \"()V\", new MethodKind.Concrete())));\n+                        new MethodInfo(\"baseMethod\", \"()V\", BaseClass.class, new MethodKind.Concrete())));\n \n         assertThat(\"inherits unchanged\", analyzer.getMethods(Type.getType(ChildClass.class)),\n                 containsInAnyOrder(\n-                        new MethodInfo(\"baseMethod\", \"()V\", new MethodKind.Concrete())));\n+                        new MethodInfo(\"baseMethod\", \"()V\", BaseClass.class, new MethodKind.Concrete())));\n     }\n \n     private class BaseClass {\n@@ -205,25 +205,25 @@ public class ClassHierarchyAnalyzerTest {\n \n         assertThat(\"original\", analyzer.getMethods(Type.getType(DefaultMethods.class)),\n                 containsInAnyOrder(\n-                        new MethodInfo(\"foo\", \"()V\", new MethodKind.Default(\n+                        new MethodInfo(\"foo\", \"()V\", DefaultMethods.class, new MethodKind.Default(\n                                 new MethodRef(DefaultMethods$.class, \"foo\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$DefaultMethods;)V\")))));\n \n         assertThat(\"inherits unchanged\", analyzer.getMethods(Type.getType(InheritsDefault.class)),\n                 containsInAnyOrder(\n-                        new MethodInfo(\"foo\", \"()V\", new MethodKind.Default(\n+                        new MethodInfo(\"foo\", \"()V\", DefaultMethods.class, new MethodKind.Default(\n                                 new MethodRef(DefaultMethods$.class, \"foo\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$DefaultMethods;)V\")))));\n \n         assertThat(\"overrides\", analyzer.getMethods(Type.getType(OverridesDefault.class)),\n                 containsInAnyOrder(\n-                        new MethodInfo(\"foo\", \"()V\", new MethodKind.Concrete())));\n+                        new MethodInfo(\"foo\", \"()V\", OverridesDefault.class, new MethodKind.Concrete())));\n \n         assertThat(\"inherits overridden\", analyzer.getMethods(Type.getType(InheritsOverridesDefault.class)),\n                 containsInAnyOrder(\n-                        new MethodInfo(\"foo\", \"()V\", new MethodKind.Concrete())));\n+                        new MethodInfo(\"foo\", \"()V\", OverridesDefault.class, new MethodKind.Concrete())));\n \n         assertThat(\"inherits overridden\", analyzer.getMethods(Type.getType(InheritsOverridesDefaultAndDirectlyImplements.class)),\n                 containsInAnyOrder(\n-                        new MethodInfo(\"foo\", \"()V\", new MethodKind.Concrete())));\n+                        new MethodInfo(\"foo\", \"()V\", OverridesDefault.class, new MethodKind.Concrete())));\n     }\n \n     private interface DefaultMethods {\n@@ -250,6 +250,60 @@ public class ClassHierarchyAnalyzerTest {\n     }\n \n \n+    @Test\n+    public void inheriting_same_default_methods_through_many_parent_interfaces() {\n+        analyze(SuperOriginal.class,\n+                SuperOverridden.class,\n+                InheritsOriginal.class,\n+                InheritsOverridden.class,\n+                InheritsOverriddenAndOriginal.class,\n+                InheritsOriginalAndOverridden.class);\n+\n+        MethodInfo original = new MethodInfo(\"foo\", \"()V\", SuperOriginal.class, new MethodKind.Default(\n+                new MethodRef(SuperOriginal$.class, \"foo\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$SuperOriginal;)V\")));\n+        MethodInfo overridden = new MethodInfo(\"foo\", \"()V\", SuperOverridden.class, new MethodKind.Default(\n+                new MethodRef(SuperOverridden$.class, \"foo\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$SuperOverridden;)V\")));\n+\n+        assertThat(\"inherits original\", analyzer.getMethods(Type.getType(InheritsOriginal.class)),\n+                containsInAnyOrder(original));\n+        assertThat(\"inherits overridden\", analyzer.getMethods(Type.getType(InheritsOverridden.class)),\n+                containsInAnyOrder(overridden));\n+        assertThat(\"inherits overridden and original\", analyzer.getMethods(Type.getType(InheritsOverriddenAndOriginal.class)),\n+                containsInAnyOrder(overridden));\n+        assertThat(\"inherits original and overridden\", analyzer.getMethods(Type.getType(InheritsOriginalAndOverridden.class)),\n+                containsInAnyOrder(overridden));\n+    }\n+\n+    private interface SuperOriginal {\n+        default void foo() {\n+        }\n+    }\n+\n+    private interface SuperOriginal$ {\n+    }\n+\n+    private interface SuperOverridden extends SuperOriginal {\n+        @Override\n+        default void foo() {\n+        }\n+    }\n+\n+    private interface SuperOverridden$ {\n+    }\n+\n+    private interface InheritsOriginal extends SuperOriginal {\n+    }\n+\n+    private interface InheritsOverridden extends SuperOverridden {\n+    }\n+\n+    private interface InheritsOverriddenAndOriginal extends SuperOverridden, InheritsOriginal {\n+    }\n+\n+    private interface InheritsOriginalAndOverridden extends InheritsOriginal, SuperOverridden {\n+    }\n+\n+\n     // TODO: edge cases from e2e tests\n \n \n"
    },
    {
        "commit_hash": "e742b72f4138a154e7c443e6e9e8243b8e098880",
        "previous_commit_hash": "654f1072fc6b9ef5653a91ab82c94f6fb1ee44eb",
        "diff_stats": {
            "additions": 6,
            "deletions": 6
        },
        "diff_content": "@@ -134,27 +134,27 @@ public class DefaultMethodsTest {\n \n     @Test\n     public void implements_original_and_overridden_default_method() {\n-        assertThat(new AB().foo(), is(\"overridden\"));\n-        assertThat(new BA().foo(), is(\"overridden\"));\n+        assertThat(new ImplementsOriginalAndOverriddenDefault().foo(), is(\"overridden\"));\n+        assertThat(new ImplementsOverriddenAndOriginalDefault().foo(), is(\"overridden\"));\n     }\n \n-    private interface A {\n+    private interface OriginalDefault {\n         default String foo() {\n             return \"original\";\n         }\n     }\n \n-    private interface B extends A {\n+    private interface OverriddenDefault extends OriginalDefault {\n         @Override\n         default String foo() {\n             return \"overridden\";\n         }\n     }\n \n-    private class AB implements A, B {\n+    private class ImplementsOriginalAndOverriddenDefault implements OriginalDefault, OverriddenDefault {\n     }\n \n-    private class BA implements B, A {\n+    private class ImplementsOverriddenAndOriginalDefault implements OverriddenDefault, OriginalDefault {\n     }\n \n \n"
    },
    {
        "commit_hash": "e742b72f4138a154e7c443e6e9e8243b8e098880",
        "previous_commit_hash": "654f1072fc6b9ef5653a91ab82c94f6fb1ee44eb",
        "diff_stats": {
            "additions": 38,
            "deletions": 1
        },
        "diff_content": "@@ -304,7 +304,44 @@ public class ClassHierarchyAnalyzerTest {\n     }\n \n \n-    // TODO: edge cases from e2e tests\n+    @Test\n+    public void implements_original_and_overridden_default_method() {\n+        analyze(OriginalDefault.class,\n+                OverriddenDefault.class,\n+                ImplementsOriginalAndOverriddenDefault.class,\n+                ImplementsOverriddenAndOriginalDefault.class);\n+\n+        MethodInfo overridden = new MethodInfo(\"foo\", \"()V\", OverriddenDefault.class, new MethodKind.Default(\n+                new MethodRef(OverriddenDefault$.class, \"foo\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$OverriddenDefault;)V\")));\n+\n+        assertThat(\"implements original and overridden\", analyzer.getMethods(Type.getType(ImplementsOriginalAndOverriddenDefault.class)),\n+                containsInAnyOrder(overridden));\n+        assertThat(\"implements overridden and original\", analyzer.getMethods(Type.getType(ImplementsOverriddenAndOriginalDefault.class)),\n+                containsInAnyOrder(overridden));\n+    }\n+\n+    private interface OriginalDefault {\n+        default void foo() {\n+        }\n+    }\n+\n+    private interface OriginalDefault$ {\n+    }\n+\n+    private interface OverriddenDefault extends OriginalDefault {\n+        @Override\n+        default void foo() {\n+        }\n+    }\n+\n+    private interface OverriddenDefault$ {\n+    }\n+\n+    private class ImplementsOriginalAndOverriddenDefault implements OriginalDefault, OverriddenDefault {\n+    }\n+\n+    private class ImplementsOverriddenAndOriginalDefault implements OverriddenDefault, OriginalDefault {\n+    }\n \n \n     // Older tests\n"
    },
    {
        "commit_hash": "d327e9e6c718d70281259b7c52fdce81ca98f528",
        "previous_commit_hash": "e742b72f4138a154e7c443e6e9e8243b8e098880",
        "diff_stats": {
            "additions": 9,
            "deletions": 2
        },
        "diff_content": "@@ -55,12 +55,19 @@ public class Retrolambda {\n                 }\n             });\n \n+            // Because Transformers.backportLambdaClass() analyzes the lambda class,\n+            // adding it to the analyzer's list of classes, we must take care to\n+            // use the list of classes before that happened, or else we might accidentally\n+            // overwrite the lambda class.\n+            List<ClassInfo> interfaces = analyzer.getInterfaces();\n+            List<ClassInfo> classes = analyzer.getClasses();\n+\n             List<byte[]> transformed = new ArrayList<>();\n-            for (ClassInfo c : analyzer.getInterfaces()) {\n+            for (ClassInfo c : interfaces) {\n                 transformed.add(transformers.extractInterfaceCompanion(c.reader));\n                 transformed.add(transformers.backportInterface(c.reader));\n             }\n-            for (ClassInfo c : analyzer.getClasses()) {\n+            for (ClassInfo c : classes) {\n                 transformed.add(transformers.backportClass(c.reader));\n             }\n \n"
    },
    {
        "commit_hash": "d327e9e6c718d70281259b7c52fdce81ca98f528",
        "previous_commit_hash": "e742b72f4138a154e7c443e6e9e8243b8e098880",
        "diff_stats": {
            "additions": 4,
            "deletions": 0
        },
        "diff_content": "@@ -24,6 +24,10 @@ public class Transformers {\n     public byte[] backportLambdaClass(ClassReader reader) {\n         return transform(reader, (next) -> {\n             if (FeatureToggles.DEFAULT_METHODS == 2) {\n+                // Lambda classes are generated dynamically, so they were not\n+                // part of the original analytics and must be analyzed now,\n+                // in case they implement interfaces with default methods.\n+                methodRelocations.analyze(reader);\n                 next = new UpdateRelocatedMethodInvocations(next, methodRelocations);\n                 next = new AddMethodDefaultImplementations(next, methodRelocations);\n             } else {\n"
    },
    {
        "commit_hash": "d327e9e6c718d70281259b7c52fdce81ca98f528",
        "previous_commit_hash": "e742b72f4138a154e7c443e6e9e8243b8e098880",
        "diff_stats": {
            "additions": 4,
            "deletions": 39
        },
        "diff_content": "@@ -7,16 +7,12 @@ package net.orfjackal.retrolambda.interfaces;\n import net.orfjackal.retrolambda.util.Bytecode;\n import org.objectweb.asm.*;\n \n-import java.util.*;\n-\n import static org.objectweb.asm.Opcodes.*;\n \n public class AddMethodDefaultImplementations extends ClassVisitor {\n \n     private final MethodRelocations methodRelocations;\n     private String className;\n-    private String[] interfaces;\n-    private final Set<MethodSignature> methods = new HashSet<>();\n \n     public AddMethodDefaultImplementations(ClassVisitor next, MethodRelocations methodRelocations) {\n         super(ASM5, next);\n@@ -26,47 +22,16 @@ public class AddMethodDefaultImplementations extends ClassVisitor {\n     @Override\n     public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n         this.className = name;\n-        this.interfaces = interfaces;\n         super.visit(version, access, name, signature, superName, interfaces);\n     }\n \n-    @Override\n-    public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n-        methods.add(new MethodSignature(name, desc));\n-        return super.visitMethod(access, name, desc, signature, exceptions);\n-    }\n-\n     @Override\n     public void visitEnd() {\n-        for (String anInterface : interfaces) {\n-            for (MethodRef interfaceMethod : methodRelocations.getInterfaceMethods(Type.getObjectType(anInterface))) {\n-                if (!overrides(interfaceMethod.getSignature())) {\n-                    generateDefaultImplementation(interfaceMethod);\n-                }\n-            }\n+        for (MethodInfo method : methodRelocations.getDefaultMethods(Type.getObjectType(className))) {\n+            MethodRef interfaceMethod = method.toMethodRef();\n+            MethodRef defaultImpl = ((MethodKind.Default) method.kind).defaultImpl;\n+            Bytecode.generateDelegateMethod(cv, ACC_PUBLIC | ACC_SYNTHETIC, interfaceMethod.toHandle(H_INVOKEVIRTUAL), defaultImpl.toHandle(H_INVOKESTATIC));\n         }\n         super.visitEnd();\n     }\n-\n-    private boolean overrides(MethodSignature method) {\n-        return thisOverrides(method) || superclassOverrides(method);\n-    }\n-\n-    private boolean thisOverrides(MethodSignature method) {\n-        return methods.contains(method);\n-    }\n-\n-    private boolean superclassOverrides(MethodSignature method) {\n-        for (MethodSignature superMethod : methodRelocations.getSuperclassMethods(Type.getObjectType(className))) {\n-            if (superMethod.equals(method)) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    private void generateDefaultImplementation(MethodRef interfaceMethod) {\n-        MethodRef impl = methodRelocations.getMethodDefaultImplementation(interfaceMethod);\n-        Bytecode.generateDelegateMethod(cv, ACC_PUBLIC | ACC_SYNTHETIC, interfaceMethod.toHandle(H_INVOKEVIRTUAL), impl.toHandle(H_INVOKESTATIC));\n-    }\n }\n"
    },
    {
        "commit_hash": "d327e9e6c718d70281259b7c52fdce81ca98f528",
        "previous_commit_hash": "e742b72f4138a154e7c443e6e9e8243b8e098880",
        "diff_stats": {
            "additions": 12,
            "deletions": 1
        },
        "diff_content": "@@ -20,9 +20,13 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n     private final Map<MethodRef, MethodRef> relocatedMethods = new HashMap<>();\n     private final Map<MethodRef, MethodRef> methodDefaultImpls = new HashMap<>();\n \n+    @Override\n     public void analyze(byte[] bytecode) {\n-        ClassReader cr = new ClassReader(bytecode);\n+        analyze(new ClassReader(bytecode));\n+    }\n \n+    @Override\n+    public void analyze(ClassReader cr) {\n         ClassInfo c = new ClassInfo(cr);\n         classes.put(c.type, c);\n \n@@ -188,6 +192,13 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n         return getClass(type).getCompanionClass();\n     }\n \n+    @Override\n+    public List<MethodInfo> getDefaultMethods(Type type) {\n+        return getMethods(type).stream()\n+                .filter(m -> m.kind instanceof MethodKind.Default)\n+                .collect(toList());\n+    }\n+\n     public Collection<MethodInfo> getMethods(Type type) {\n         ClassInfo c = getClass(type);\n         Map<MethodSignature, MethodInfo> methods = new HashMap<>();\n"
    },
    {
        "commit_hash": "d327e9e6c718d70281259b7c52fdce81ca98f528",
        "previous_commit_hash": "e742b72f4138a154e7c443e6e9e8243b8e098880",
        "diff_stats": {
            "additions": 4,
            "deletions": 0
        },
        "diff_content": "@@ -25,6 +25,10 @@ public class MethodInfo {\n         this.kind = kind;\n     }\n \n+    public MethodRef toMethodRef() {\n+        return new MethodRef(owner.getInternalName(), signature.name, signature.desc);\n+    }\n+\n     @Override\n     public boolean equals(Object obj) {\n         if (!(obj instanceof MethodInfo)) {\n"
    },
    {
        "commit_hash": "d327e9e6c718d70281259b7c52fdce81ca98f528",
        "previous_commit_hash": "e742b72f4138a154e7c443e6e9e8243b8e098880",
        "diff_stats": {
            "additions": 7,
            "deletions": 1
        },
        "diff_content": "@@ -4,12 +4,16 @@\n \n package net.orfjackal.retrolambda.interfaces;\n \n-import org.objectweb.asm.Type;\n+import org.objectweb.asm.*;\n \n import java.util.*;\n \n public interface MethodRelocations {\n \n+    void analyze(byte[] bytecode);\n+\n+    void analyze(ClassReader reader);\n+\n     MethodRef getMethodCallTarget(MethodRef original);\n \n     MethodRef getMethodDefaultImplementation(MethodRef interfaceMethod);\n@@ -19,4 +23,6 @@ public interface MethodRelocations {\n     List<MethodSignature> getSuperclassMethods(Type className);\n \n     Optional<Type> getCompanionClass(Type type);\n+\n+    List<MethodInfo> getDefaultMethods(Type className);\n }\n"
    },
    {
        "commit_hash": "726cf6f7a8d877547c883dcbb082d4fabe14fb33",
        "previous_commit_hash": "d327e9e6c718d70281259b7c52fdce81ca98f528",
        "diff_stats": {
            "additions": 4,
            "deletions": 3
        },
        "diff_content": "@@ -1,7 +1,9 @@\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <project version=\"4\">\n   <component name=\"EntryPointsManager\">\n-    <entry_points version=\"2.0\" />\n+    <entry_points version=\"2.0\">\n+      <entry_point TYPE=\"method\" FQNAME=\"net.orfjackal.retrolambda.PreMain void premain(java.lang.String agentArgs, java.lang.instrument.Instrumentation inst)\" />\n+    </entry_points>\n     <list size=\"3\">\n       <item index=\"0\" class=\"java.lang.String\" itemvalue=\"org.apache.maven.plugins.annotations.Component\" />\n       <item index=\"1\" class=\"java.lang.String\" itemvalue=\"org.apache.maven.plugins.annotations.Mojo\" />\n@@ -73,5 +75,4 @@\n       <option name=\"VERSION\" />\n     </GetOptions>\n   </component>\n-</project>\n-\n+</project>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "726cf6f7a8d877547c883dcbb082d4fabe14fb33",
        "previous_commit_hash": "d327e9e6c718d70281259b7c52fdce81ca98f528",
        "diff_stats": {
            "additions": 12,
            "deletions": 12
        },
        "diff_content": "@@ -14,11 +14,11 @@ import java.util.Optional;\n public class Transformers {\n \n     private final int targetVersion;\n-    private final MethodRelocations methodRelocations;\n+    private final ClassHierarchyAnalyzer analyzer;\n \n-    public Transformers(int targetVersion, MethodRelocations methodRelocations) {\n+    public Transformers(int targetVersion, ClassHierarchyAnalyzer analyzer) {\n         this.targetVersion = targetVersion;\n-        this.methodRelocations = methodRelocations;\n+        this.analyzer = analyzer;\n     }\n \n     public byte[] backportLambdaClass(ClassReader reader) {\n@@ -27,11 +27,11 @@ public class Transformers {\n                 // Lambda classes are generated dynamically, so they were not\n                 // part of the original analytics and must be analyzed now,\n                 // in case they implement interfaces with default methods.\n-                methodRelocations.analyze(reader);\n-                next = new UpdateRelocatedMethodInvocations(next, methodRelocations);\n-                next = new AddMethodDefaultImplementations(next, methodRelocations);\n+                analyzer.analyze(reader);\n+                next = new UpdateRelocatedMethodInvocations(next, analyzer);\n+                next = new AddMethodDefaultImplementations(next, analyzer);\n             } else {\n-                next = new UpdateRelocatedMethodInvocations(next, methodRelocations); // needed for lambdas in an interface's constant initializer\n+                next = new UpdateRelocatedMethodInvocations(next, analyzer); // needed for lambdas in an interface's constant initializer\n             }\n             next = new BackportLambdaClass(next);\n             return next;\n@@ -41,8 +41,8 @@ public class Transformers {\n     public byte[] backportClass(ClassReader reader) {\n         return transform(reader, (next) -> {\n             if (FeatureToggles.DEFAULT_METHODS == 2) {\n-                next = new UpdateRelocatedMethodInvocations(next, methodRelocations);\n-                next = new AddMethodDefaultImplementations(next, methodRelocations);\n+                next = new UpdateRelocatedMethodInvocations(next, analyzer);\n+                next = new AddMethodDefaultImplementations(next, analyzer);\n             }\n             next = new BackportLambdaInvocations(next);\n             return next;\n@@ -54,7 +54,7 @@ public class Transformers {\n             if (FeatureToggles.DEFAULT_METHODS == 2) {\n                 next = new RemoveStaticMethods(next);\n                 next = new RemoveDefaultMethodBodies(next);\n-                next = new UpdateRelocatedMethodInvocations(next, methodRelocations);\n+                next = new UpdateRelocatedMethodInvocations(next, analyzer);\n             } else {\n                 next = new RemoveStaticMethods(next); // needed for lambdas in an interface's constant initializer\n                 next = new WarnAboutDefaultAndStaticMethods(next);\n@@ -66,12 +66,12 @@ public class Transformers {\n     }\n \n     public byte[] extractInterfaceCompanion(ClassReader reader) {\n-        Optional<Type> companion = methodRelocations.getCompanionClass(Type.getObjectType(reader.getClassName()));\n+        Optional<Type> companion = analyzer.getCompanionClass(Type.getObjectType(reader.getClassName()));\n         if (!companion.isPresent()) {\n             return null;\n         }\n         return transform(reader, (next) -> {\n-            next = new UpdateRelocatedMethodInvocations(next, methodRelocations);\n+            next = new UpdateRelocatedMethodInvocations(next, analyzer);\n             next = new ExtractInterfaceCompanionClass(next, companion.get());\n             return next;\n         });\n"
    },
    {
        "commit_hash": "726cf6f7a8d877547c883dcbb082d4fabe14fb33",
        "previous_commit_hash": "d327e9e6c718d70281259b7c52fdce81ca98f528",
        "diff_stats": {
            "additions": 8,
            "deletions": 7
        },
        "diff_content": "@@ -11,12 +11,12 @@ import static org.objectweb.asm.Opcodes.*;\n \n public class AddMethodDefaultImplementations extends ClassVisitor {\n \n-    private final MethodRelocations methodRelocations;\n+    private final ClassHierarchyAnalyzer analyzer;\n     private String className;\n \n-    public AddMethodDefaultImplementations(ClassVisitor next, MethodRelocations methodRelocations) {\n+    public AddMethodDefaultImplementations(ClassVisitor next, ClassHierarchyAnalyzer analyzer) {\n         super(ASM5, next);\n-        this.methodRelocations = methodRelocations;\n+        this.analyzer = analyzer;\n     }\n \n     @Override\n@@ -27,10 +27,11 @@ public class AddMethodDefaultImplementations extends ClassVisitor {\n \n     @Override\n     public void visitEnd() {\n-        for (MethodInfo method : methodRelocations.getDefaultMethods(Type.getObjectType(className))) {\n-            MethodRef interfaceMethod = method.toMethodRef();\n-            MethodRef defaultImpl = ((MethodKind.Default) method.kind).defaultImpl;\n-            Bytecode.generateDelegateMethod(cv, ACC_PUBLIC | ACC_SYNTHETIC, interfaceMethod.toHandle(H_INVOKEVIRTUAL), defaultImpl.toHandle(H_INVOKESTATIC));\n+        for (MethodInfo method : analyzer.getDefaultMethods(Type.getObjectType(className))) {\n+            Bytecode.generateDelegateMethod(cv,\n+                    ACC_PUBLIC | ACC_SYNTHETIC,\n+                    method.toMethodRef().toHandle(H_INVOKEVIRTUAL),\n+                    method.getDefaultMethodImpl().toHandle(H_INVOKESTATIC));\n         }\n         super.visitEnd();\n     }\n"
    },
    {
        "commit_hash": "726cf6f7a8d877547c883dcbb082d4fabe14fb33",
        "previous_commit_hash": "d327e9e6c718d70281259b7c52fdce81ca98f528",
        "diff_stats": {
            "additions": 9,
            "deletions": 64
        },
        "diff_content": "@@ -12,20 +12,15 @@ import java.util.*;\n import static java.util.stream.Collectors.toList;\n import static org.objectweb.asm.Opcodes.*;\n \n-public class ClassHierarchyAnalyzer implements MethodRelocations {\n-\n-    private static final MethodRef ABSTRACT_METHOD = new MethodRef(\"\", \"\", \"\");\n+public class ClassHierarchyAnalyzer {\n \n     private final Map<Type, ClassInfo> classes = new HashMap<>();\n     private final Map<MethodRef, MethodRef> relocatedMethods = new HashMap<>();\n-    private final Map<MethodRef, MethodRef> methodDefaultImpls = new HashMap<>();\n \n-    @Override\n     public void analyze(byte[] bytecode) {\n         analyze(new ClassReader(bytecode));\n     }\n \n-    @Override\n     public void analyze(ClassReader cr) {\n         ClassInfo c = new ClassInfo(cr);\n         classes.put(c.type, c);\n@@ -78,13 +73,10 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n                 MethodRef method = new MethodRef(owner, name, desc);\n \n                 if (isAbstractMethod(access)) {\n-                    methodDefaultImpls.put(method, ABSTRACT_METHOD);\n                     c.addMethod(method, new MethodKind.Abstract());\n \n                 } else if (isDefaultMethod(access)) {\n-                    desc = Bytecode.prependArgumentType(desc, Type.getObjectType(owner));\n-                    MethodRef defaultImpl = new MethodRef(companion, name, desc);\n-                    methodDefaultImpls.put(method, defaultImpl);\n+                    MethodRef defaultImpl = new MethodRef(companion, name, Bytecode.prependArgumentType(desc, Type.getObjectType(owner)));\n                     c.enableCompanionClass();\n                     c.addMethod(method, new MethodKind.Default(defaultImpl));\n \n@@ -128,71 +120,24 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n         return classes.getOrDefault(type, new ClassInfo());\n     }\n \n-    public List<Type> getInterfacesOf(Type type) {\n-        return getClass(type).interfaces;\n-    }\n-\n-    @Override\n     public MethodRef getMethodCallTarget(MethodRef original) {\n         return relocatedMethods.getOrDefault(original, original);\n     }\n \n-    @Override\n     public MethodRef getMethodDefaultImplementation(MethodRef interfaceMethod) {\n-        MethodRef impl;\n-        List<Type> currentInterfaces = new ArrayList<>();\n-        List<Type> parentInterfaces = new ArrayList<>();\n-        currentInterfaces.add(Type.getObjectType(interfaceMethod.owner));\n-\n-        do {\n-            for (Type anInterface : currentInterfaces) {\n-                impl = methodDefaultImpls.get(interfaceMethod.withOwner(anInterface.getInternalName()));\n-                if (impl == ABSTRACT_METHOD) {\n-                    return null;\n-                }\n-                if (impl != null) {\n-                    return impl;\n-                }\n-                parentInterfaces.addAll(getInterfacesOf(anInterface));\n-            }\n-            currentInterfaces = parentInterfaces;\n-            parentInterfaces = new ArrayList<>();\n-        } while (!currentInterfaces.isEmpty());\n-\n-        return null;\n-    }\n-\n-    @Override\n-    public List<MethodRef> getInterfaceMethods(Type type) {\n-        Set<MethodRef> results = new LinkedHashSet<>();\n-        results.addAll(getClass(type).getMethodRefs());\n-        for (Type parent : getInterfacesOf(type)) {\n-            for (MethodRef parentMethod : getInterfaceMethods(parent)) {\n-                results.add(parentMethod.withOwner(type.getInternalName()));\n+        MethodSignature signature = interfaceMethod.getSignature();\n+        for (MethodInfo method : getDefaultMethods(Type.getObjectType(interfaceMethod.owner))) {\n+            if (method.signature.equals(signature)) {\n+                return method.getDefaultMethodImpl();\n             }\n         }\n-        return new ArrayList<>(results);\n-    }\n-\n-    @Override\n-    public List<MethodSignature> getSuperclassMethods(Type type) {\n-        Set<MethodRef> results = new LinkedHashSet<>();\n-        while (classes.containsKey(type)) {\n-            ClassInfo c = classes.get(type);\n-            type = c.superclass;\n-            results.addAll(getClass(type).getMethodRefs());\n-        }\n-        return results.stream()\n-                .map(MethodRef::getSignature)\n-                .collect(toList());\n+        return null;\n     }\n \n-    @Override\n     public Optional<Type> getCompanionClass(Type type) {\n         return getClass(type).getCompanionClass();\n     }\n \n-    @Override\n     public List<MethodInfo> getDefaultMethods(Type type) {\n         return getMethods(type).stream()\n                 .filter(m -> m.kind instanceof MethodKind.Default)\n@@ -205,7 +150,7 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n \n         // in reverse priority order:\n         // - default methods\n-        for (Type iface : c.interfaces) {\n+        for (Type iface : c.getInterfaces()) {\n             for (MethodInfo m : getMethods(iface)) {\n                 if (!isAlreadyInherited(m, methods)) {\n                     methods.put(m.signature, m);\n@@ -234,7 +179,7 @@ public class ClassHierarchyAnalyzer implements MethodRelocations {\n         assert getClass(interfaceType).isInterface() : \"not interface: \" + interfaceType;\n         HashSet<Type> results = new HashSet<>();\n         results.add(interfaceType);\n-        for (Type parentInterface : getClass(interfaceType).interfaces) {\n+        for (Type parentInterface : getClass(interfaceType).getInterfaces()) {\n             results.addAll(getAllInterfaces(parentInterface));\n         }\n         return results;\n"
    },
    {
        "commit_hash": "726cf6f7a8d877547c883dcbb082d4fabe14fb33",
        "previous_commit_hash": "d327e9e6c718d70281259b7c52fdce81ca98f528",
        "diff_stats": {
            "additions": 8,
            "deletions": 11
        },
        "diff_content": "@@ -8,9 +8,7 @@ import net.orfjackal.retrolambda.util.Flags;\n import org.objectweb.asm.*;\n \n import java.util.*;\n-import java.util.stream.Stream;\n \n-import static java.util.stream.Collectors.toList;\n import static org.objectweb.asm.Opcodes.ACC_INTERFACE;\n \n public class ClassInfo {\n@@ -19,9 +17,8 @@ public class ClassInfo {\n     private final int access;\n     public final Type type;\n     public final Type superclass;\n-    public final List<Type> interfaces;\n+    private final List<Type> interfaces = new ArrayList<>();\n     private final List<MethodInfo> methods = new ArrayList<>();\n-    private final List<MethodRef> methodRefs = new ArrayList<>();\n     private Optional<Type> companionClass = Optional.empty();\n \n     public ClassInfo() {\n@@ -29,7 +26,6 @@ public class ClassInfo {\n         this.access = 0;\n         this.type = null;\n         this.superclass = null;\n-        this.interfaces = Collections.emptyList();\n     }\n \n     public ClassInfo(ClassReader cr) {\n@@ -37,20 +33,21 @@ public class ClassInfo {\n         this.access = cr.getAccess();\n         this.type = Type.getObjectType(cr.getClassName());\n         this.superclass = Type.getObjectType(cr.getSuperName());\n-        this.interfaces = Stream.of(cr.getInterfaces()).map(Type::getObjectType).collect(toList());\n+        for (String iface : cr.getInterfaces()) {\n+            this.interfaces.add(Type.getObjectType(iface));\n+        }\n     }\n \n-    public List<MethodInfo> getMethods() {\n-        return Collections.unmodifiableList(methods);\n+    public List<Type> getInterfaces() {\n+        return Collections.unmodifiableList(interfaces);\n     }\n \n-    public List<MethodRef> getMethodRefs() {\n-        return Collections.unmodifiableList(methodRefs);\n+    public List<MethodInfo> getMethods() {\n+        return Collections.unmodifiableList(methods);\n     }\n \n     public void addMethod(MethodRef method, MethodKind kind) {\n         methods.add(new MethodInfo(method.getSignature(), Type.getObjectType(method.owner), kind));\n-        methodRefs.add(method);\n     }\n \n     public Optional<Type> getCompanionClass() {\n"
    },
    {
        "commit_hash": "726cf6f7a8d877547c883dcbb082d4fabe14fb33",
        "previous_commit_hash": "d327e9e6c718d70281259b7c52fdce81ca98f528",
        "diff_stats": {
            "additions": 4,
            "deletions": 0
        },
        "diff_content": "@@ -25,6 +25,10 @@ public class MethodInfo {\n         this.kind = kind;\n     }\n \n+    public MethodRef getDefaultMethodImpl() {\n+        return ((MethodKind.Default) kind).defaultImpl;\n+    }\n+\n     public MethodRef toMethodRef() {\n         return new MethodRef(owner.getInternalName(), signature.name, signature.desc);\n     }\n"
    },
    {
        "commit_hash": "726cf6f7a8d877547c883dcbb082d4fabe14fb33",
        "previous_commit_hash": "d327e9e6c718d70281259b7c52fdce81ca98f528",
        "diff_stats": {
            "additions": 2,
            "deletions": 6
        },
        "diff_content": "@@ -11,7 +11,7 @@ import java.util.Objects;\n \n public final class MethodRef {\n \n-    // TODO: replace MethodRef with ASM's Handle\n+    // TODO: replace MethodRef with ASM's Handle, or merge with MethodInfo?\n \n     public final String owner;\n     public final String name;\n@@ -26,15 +26,11 @@ public final class MethodRef {\n         this.name = name;\n         this.desc = desc;\n     }\n-    \n+\n     public MethodSignature getSignature() {\n         return new MethodSignature(name, desc);\n     }\n \n-    public MethodRef withOwner(String newOwner) {\n-        return new MethodRef(newOwner, name, desc);\n-    }\n-\n     public Handle toHandle(int tag) {\n         return new Handle(tag, owner, name, desc);\n     }\n"
    },
    {
        "commit_hash": "726cf6f7a8d877547c883dcbb082d4fabe14fb33",
        "previous_commit_hash": "d327e9e6c718d70281259b7c52fdce81ca98f528",
        "diff_stats": {
            "additions": 0,
            "deletions": 28
        },
        "diff_content": "@@ -1,28 +0,0 @@\n-// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n-// This software is released under the Apache License 2.0.\n-// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n-\n-package net.orfjackal.retrolambda.interfaces;\n-\n-import org.objectweb.asm.*;\n-\n-import java.util.*;\n-\n-public interface MethodRelocations {\n-\n-    void analyze(byte[] bytecode);\n-\n-    void analyze(ClassReader reader);\n-\n-    MethodRef getMethodCallTarget(MethodRef original);\n-\n-    MethodRef getMethodDefaultImplementation(MethodRef interfaceMethod);\n-\n-    List<MethodRef> getInterfaceMethods(Type interfaceName);\n-\n-    List<MethodSignature> getSuperclassMethods(Type className);\n-\n-    Optional<Type> getCompanionClass(Type type);\n-\n-    List<MethodInfo> getDefaultMethods(Type className);\n-}\n"
    },
    {
        "commit_hash": "726cf6f7a8d877547c883dcbb082d4fabe14fb33",
        "previous_commit_hash": "d327e9e6c718d70281259b7c52fdce81ca98f528",
        "diff_stats": {
            "additions": 6,
            "deletions": 6
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -10,11 +10,11 @@ import static org.objectweb.asm.Opcodes.ASM5;\n \n public class UpdateRelocatedMethodInvocations extends ClassVisitor {\n \n-    private final MethodRelocations methodRelocations;\n+    private final ClassHierarchyAnalyzer analyzer;\n \n-    public UpdateRelocatedMethodInvocations(ClassVisitor next, MethodRelocations methodRelocations) {\n+    public UpdateRelocatedMethodInvocations(ClassVisitor next, ClassHierarchyAnalyzer analyzer) {\n         super(ASM5, next);\n-        this.methodRelocations = methodRelocations;\n+        this.analyzer = analyzer;\n     }\n \n     @Override\n@@ -35,14 +35,14 @@ public class UpdateRelocatedMethodInvocations extends ClassVisitor {\n             // change Interface.super.defaultMethod() calls to static calls on the companion class\n             // TODO: move this inside getMethodCallTarget (also opcode, so must first change MethodRef to Handle)\n             if (opcode == Opcodes.INVOKESPECIAL) {\n-                MethodRef impl = methodRelocations.getMethodDefaultImplementation(method);\n+                MethodRef impl = analyzer.getMethodDefaultImplementation(method);\n                 if (impl != null) {\n                     opcode = Opcodes.INVOKESTATIC;\n                     method = impl;\n                 }\n             }\n \n-            method = methodRelocations.getMethodCallTarget(method);\n+            method = analyzer.getMethodCallTarget(method);\n             super.visitMethodInsn(opcode, method.owner, method.name, method.desc, itf);\n         }\n     }\n"
    },
    {
        "commit_hash": "726cf6f7a8d877547c883dcbb082d4fabe14fb33",
        "previous_commit_hash": "d327e9e6c718d70281259b7c52fdce81ca98f528",
        "diff_stats": {
            "additions": 0,
            "deletions": 43
        },
        "diff_content": "@@ -344,45 +344,6 @@ public class ClassHierarchyAnalyzerTest {\n     }\n \n \n-    // Older tests\n-\n-    @Test\n-    public void finds_implemented_interfaces() {\n-        analyze(Interface.class,\n-                ChildInterface.class,\n-                InterfaceImplementer.class);\n-\n-        assertThat(\"Interface\", getInterfacesOf(Interface.class), is(empty()));\n-        assertThat(\"ChildInterface\", getInterfacesOf(ChildInterface.class), is(classList(Interface.class)));\n-        assertThat(\"InterfaceImplementer\", getInterfacesOf(InterfaceImplementer.class), is(classList(Interface.class)));\n-    }\n-\n-    @Test\n-    public void finds_interface_methods() {\n-        analyze(InterfaceMethodTypes.class);\n-\n-        assertThat(analyzer.getInterfaceMethods(Type.getType(InterfaceMethodTypes.class)),\n-                containsInAnyOrder(\n-                        new MethodRef(InterfaceMethodTypes.class, \"abstractMethod\", voidMethod()),\n-                        new MethodRef(InterfaceMethodTypes.class, \"defaultMethod\", voidMethod()))); // all but staticMethod\n-    }\n-\n-    @Test\n-    public void finds_inherited_interface_methods() {\n-        analyze(ChildInterface.class,\n-                Interface.class);\n-\n-        assertThat(analyzer.getInterfaceMethods(Type.getType(ChildInterface.class)),\n-                containsInAnyOrder(\n-                        new MethodRef(ChildInterface.class, \"abstractMethod\", voidMethod())));\n-    }\n-\n-    @Test\n-    public void does_not_find_interface_methods_of_not_analyzed_interfaces() {\n-        assertThat(analyzer.getInterfaceMethods(Type.getType(Interface.class)), is(empty()));\n-    }\n-\n-\n     // Method relocations\n \n     @Test\n@@ -517,10 +478,6 @@ public class ClassHierarchyAnalyzerTest {\n         return infosToClasses(analyzer.getClasses());\n     }\n \n-    private List<Class<?>> getInterfacesOf(Class<?> clazz) {\n-        return typesToClasses(analyzer.getInterfacesOf(Type.getType(clazz)));\n-    }\n-\n \n     // other helpers\n \n"
    },
    {
        "commit_hash": "5555bc9621635b01b84276ab4d2711d39bf8729c",
        "previous_commit_hash": "726cf6f7a8d877547c883dcbb082d4fabe14fb33",
        "diff_stats": {
            "additions": 17,
            "deletions": 13
        },
        "diff_content": "@@ -43,10 +43,10 @@ public class ClassHierarchyAnalyzer {\n \n             @Override\n             public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n-                if (name.equals(\"<init>\") || Flags.hasFlag(access, ACC_STATIC)) {\n+                if (isConstructor(name) || isStaticMethod(access)) {\n                     return null;\n                 }\n-                c.addMethod(new MethodRef(owner, name, desc), new MethodKind.Concrete());\n+                c.addMethod(new MethodRef(owner, name, desc), new MethodKind.Implemented());\n \n                 // XXX: backporting Retrolambda fails if we remove this; it tries backporting a lambda while backporting a lambda\n                 Runnable r = () -> {\n@@ -86,20 +86,24 @@ public class ClassHierarchyAnalyzer {\n                 }\n                 return null;\n             }\n+        }, ClassReader.SKIP_CODE);\n+    }\n \n-            private boolean isAbstractMethod(int access) {\n-                return Flags.hasFlag(access, ACC_ABSTRACT);\n-            }\n+    private static boolean isConstructor(String name) {\n+        return name.equals(\"<init>\");\n+    }\n \n-            private boolean isStaticMethod(int access) {\n-                return Flags.hasFlag(access, ACC_STATIC);\n-            }\n+    private static boolean isAbstractMethod(int access) {\n+        return Flags.hasFlag(access, ACC_ABSTRACT);\n+    }\n \n-            private boolean isDefaultMethod(int access) {\n-                return !isAbstractMethod(access)\n-                        && !isStaticMethod(access);\n-            }\n-        }, ClassReader.SKIP_CODE);\n+    private static boolean isStaticMethod(int access) {\n+        return Flags.hasFlag(access, ACC_STATIC);\n+    }\n+\n+    private static boolean isDefaultMethod(int access) {\n+        return !isAbstractMethod(access)\n+                && !isStaticMethod(access);\n     }\n \n     public List<ClassInfo> getInterfaces() {\n"
    },
    {
        "commit_hash": "5555bc9621635b01b84276ab4d2711d39bf8729c",
        "previous_commit_hash": "726cf6f7a8d877547c883dcbb082d4fabe14fb33",
        "diff_stats": {
            "additions": 12,
            "deletions": 2
        },
        "diff_content": "@@ -34,12 +34,22 @@ public abstract class MethodKind {\n     }\n \n \n-    public static class Abstract extends MethodKind {\n+    /**\n+     * Instance method on a class, regardless of whether it's abstract or non-abstract,\n+     * because it will anyways take precedence over inherited interface methods.\n+     */\n+    public static class Implemented extends MethodKind {\n     }\n \n-    public static class Concrete extends MethodKind {\n+    /**\n+     * Abstract method on an interface.\n+     */\n+    public static class Abstract extends MethodKind {\n     }\n \n+    /**\n+     * Default method on an interface.\n+     */\n     public static class Default extends MethodKind {\n \n         public final MethodRef defaultImpl;\n"
    },
    {
        "commit_hash": "5555bc9621635b01b84276ab4d2711d39bf8729c",
        "previous_commit_hash": "726cf6f7a8d877547c883dcbb082d4fabe14fb33",
        "diff_stats": {
            "additions": 10,
            "deletions": 11
        },
        "diff_content": "@@ -48,7 +48,7 @@ public class ClassHierarchyAnalyzerTest {\n                 containsInAnyOrder(new MethodInfo(\"abstractMethod\", \"()V\", Interface.class, new MethodKind.Abstract())));\n \n         assertThat(\"implements\", analyzer.getMethods(Type.getType(InterfaceImplementer.class)),\n-                containsInAnyOrder(new MethodInfo(\"abstractMethod\", \"()V\", InterfaceImplementer.class, new MethodKind.Concrete())));\n+                containsInAnyOrder(new MethodInfo(\"abstractMethod\", \"()V\", InterfaceImplementer.class, new MethodKind.Implemented())));\n     }\n \n     private interface Interface {\n@@ -80,13 +80,12 @@ public class ClassHierarchyAnalyzerTest {\n     public void class_method_types() {\n         analyze(ClassMethodTypes.class);\n \n-        // TODO: make a difference between abstract and concrete instance methods?\n-        // An abstract instance method will probably take precedence over a default method,\n-        // so our algorithm might require abstract instance methods to be considered same as concrete.\n+        // An abstract instance method takes precedence over a default method,\n+        // so we handle abstract instance methods the same way as concrete instance methods.\n         assertThat(analyzer.getMethods(Type.getType(ClassMethodTypes.class)),\n                 containsInAnyOrder(\n-                        new MethodInfo(\"abstractMethod\", \"()V\", ClassMethodTypes.class, new MethodKind.Concrete()),\n-                        new MethodInfo(\"instanceMethod\", \"()V\", ClassMethodTypes.class, new MethodKind.Concrete())));\n+                        new MethodInfo(\"abstractMethod\", \"()V\", ClassMethodTypes.class, new MethodKind.Implemented()),\n+                        new MethodInfo(\"instanceMethod\", \"()V\", ClassMethodTypes.class, new MethodKind.Implemented())));\n     }\n \n     private interface InterfaceMethodTypes {\n@@ -179,11 +178,11 @@ public class ClassHierarchyAnalyzerTest {\n \n         assertThat(\"original\", analyzer.getMethods(Type.getType(BaseClass.class)),\n                 containsInAnyOrder(\n-                        new MethodInfo(\"baseMethod\", \"()V\", BaseClass.class, new MethodKind.Concrete())));\n+                        new MethodInfo(\"baseMethod\", \"()V\", BaseClass.class, new MethodKind.Implemented())));\n \n         assertThat(\"inherits unchanged\", analyzer.getMethods(Type.getType(ChildClass.class)),\n                 containsInAnyOrder(\n-                        new MethodInfo(\"baseMethod\", \"()V\", BaseClass.class, new MethodKind.Concrete())));\n+                        new MethodInfo(\"baseMethod\", \"()V\", BaseClass.class, new MethodKind.Implemented())));\n     }\n \n     private class BaseClass {\n@@ -215,15 +214,15 @@ public class ClassHierarchyAnalyzerTest {\n \n         assertThat(\"overrides\", analyzer.getMethods(Type.getType(OverridesDefault.class)),\n                 containsInAnyOrder(\n-                        new MethodInfo(\"foo\", \"()V\", OverridesDefault.class, new MethodKind.Concrete())));\n+                        new MethodInfo(\"foo\", \"()V\", OverridesDefault.class, new MethodKind.Implemented())));\n \n         assertThat(\"inherits overridden\", analyzer.getMethods(Type.getType(InheritsOverridesDefault.class)),\n                 containsInAnyOrder(\n-                        new MethodInfo(\"foo\", \"()V\", OverridesDefault.class, new MethodKind.Concrete())));\n+                        new MethodInfo(\"foo\", \"()V\", OverridesDefault.class, new MethodKind.Implemented())));\n \n         assertThat(\"inherits overridden\", analyzer.getMethods(Type.getType(InheritsOverridesDefaultAndDirectlyImplements.class)),\n                 containsInAnyOrder(\n-                        new MethodInfo(\"foo\", \"()V\", OverridesDefault.class, new MethodKind.Concrete())));\n+                        new MethodInfo(\"foo\", \"()V\", OverridesDefault.class, new MethodKind.Implemented())));\n     }\n \n     private interface DefaultMethods {\n"
    },
    {
        "commit_hash": "2bc0b461b44ed6206f2d30c16042b5d5a28f5074",
        "previous_commit_hash": "5555bc9621635b01b84276ab4d2711d39bf8729c",
        "diff_stats": {
            "additions": 8,
            "deletions": 0
        },
        "diff_content": "@@ -134,8 +134,10 @@ public class DefaultMethodsTest {\n \n     @Test\n     public void implements_original_and_overridden_default_method() {\n+        assertThat(new ImplementsOriginal().foo(), is(\"original\"));\n         assertThat(new ImplementsOriginalAndOverriddenDefault().foo(), is(\"overridden\"));\n         assertThat(new ImplementsOverriddenAndOriginalDefault().foo(), is(\"overridden\"));\n+        assertThat(new ExtendsImplementsOriginalAndImplementsOverriddenDefault().foo(), is(\"overridden\"));\n     }\n \n     private interface OriginalDefault {\n@@ -151,12 +153,18 @@ public class DefaultMethodsTest {\n         }\n     }\n \n+    private class ImplementsOriginal implements OriginalDefault {\n+    }\n+\n     private class ImplementsOriginalAndOverriddenDefault implements OriginalDefault, OverriddenDefault {\n     }\n \n     private class ImplementsOverriddenAndOriginalDefault implements OverriddenDefault, OriginalDefault {\n     }\n \n+    private class ExtendsImplementsOriginalAndImplementsOverriddenDefault extends ImplementsOriginal implements OverriddenDefault {\n+    }\n+\n \n     // Bridge Methods\n \n"
    },
    {
        "commit_hash": "2bc0b461b44ed6206f2d30c16042b5d5a28f5074",
        "previous_commit_hash": "5555bc9621635b01b84276ab4d2711d39bf8729c",
        "diff_stats": {
            "additions": 3,
            "deletions": 1
        },
        "diff_content": "@@ -164,7 +164,9 @@ public class ClassHierarchyAnalyzer {\n         // - superclass methods\n         if (c.superclass != null) {\n             for (MethodInfo m : getMethods(c.superclass)) {\n-                methods.put(m.signature, m);\n+                if (!isAlreadyInherited(m, methods)) {\n+                    methods.put(m.signature, m);\n+                }\n             }\n         }\n         // - own methods\n"
    },
    {
        "commit_hash": "2bc0b461b44ed6206f2d30c16042b5d5a28f5074",
        "previous_commit_hash": "5555bc9621635b01b84276ab4d2711d39bf8729c",
        "diff_stats": {
            "additions": 15,
            "deletions": 1
        },
        "diff_content": "@@ -307,16 +307,24 @@ public class ClassHierarchyAnalyzerTest {\n     public void implements_original_and_overridden_default_method() {\n         analyze(OriginalDefault.class,\n                 OverriddenDefault.class,\n+                ImplementsOriginal.class,\n                 ImplementsOriginalAndOverriddenDefault.class,\n-                ImplementsOverriddenAndOriginalDefault.class);\n+                ImplementsOverriddenAndOriginalDefault.class,\n+                ExtendsImplementsOriginalAndImplementsOverriddenDefault.class);\n \n+        MethodInfo original = new MethodInfo(\"foo\", \"()V\", OriginalDefault.class, new MethodKind.Default(\n+                new MethodRef(OriginalDefault$.class, \"foo\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$OriginalDefault;)V\")));\n         MethodInfo overridden = new MethodInfo(\"foo\", \"()V\", OverriddenDefault.class, new MethodKind.Default(\n                 new MethodRef(OverriddenDefault$.class, \"foo\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$OverriddenDefault;)V\")));\n \n+        assertThat(\"implements original\", analyzer.getMethods(Type.getType(ImplementsOriginal.class)),\n+                containsInAnyOrder(original));\n         assertThat(\"implements original and overridden\", analyzer.getMethods(Type.getType(ImplementsOriginalAndOverriddenDefault.class)),\n                 containsInAnyOrder(overridden));\n         assertThat(\"implements overridden and original\", analyzer.getMethods(Type.getType(ImplementsOverriddenAndOriginalDefault.class)),\n                 containsInAnyOrder(overridden));\n+        assertThat(\"extends implementor of original and implements overridden\", analyzer.getMethods(Type.getType(ExtendsImplementsOriginalAndImplementsOverriddenDefault.class)),\n+                containsInAnyOrder(overridden));\n     }\n \n     private interface OriginalDefault {\n@@ -336,12 +344,18 @@ public class ClassHierarchyAnalyzerTest {\n     private interface OverriddenDefault$ {\n     }\n \n+    private class ImplementsOriginal implements OriginalDefault {\n+    }\n+\n     private class ImplementsOriginalAndOverriddenDefault implements OriginalDefault, OverriddenDefault {\n     }\n \n     private class ImplementsOverriddenAndOriginalDefault implements OverriddenDefault, OriginalDefault {\n     }\n \n+    private class ExtendsImplementsOriginalAndImplementsOverriddenDefault extends ImplementsOriginal implements OverriddenDefault {\n+    }\n+\n \n     // Method relocations\n \n"
    },
    {
        "commit_hash": "9cafcca09c71ae3f0a2ae4ffddd4ea3868bba52f",
        "previous_commit_hash": "2bc0b461b44ed6206f2d30c16042b5d5a28f5074",
        "diff_stats": {
            "additions": 19,
            "deletions": 19
        },
        "diff_content": "@@ -257,72 +257,72 @@\n \n                 <plugin>\n                     <artifactId>maven-toolchains-plugin</artifactId>\n-                    <version>1.0</version>\n+                    <version>1.1</version>\n                 </plugin>\n \n                 <plugin>\n                     <artifactId>maven-clean-plugin</artifactId>\n-                    <version>2.5</version>\n+                    <version>2.6.1</version>\n                 </plugin>\n \n                 <plugin>\n                     <artifactId>maven-compiler-plugin</artifactId>\n-                    <version>3.1</version>\n+                    <version>3.3</version>\n                 </plugin>\n \n                 <plugin>\n                     <artifactId>maven-resources-plugin</artifactId>\n-                    <version>2.6</version>\n+                    <version>2.7</version>\n                 </plugin>\n \n                 <plugin>\n                     <artifactId>maven-jar-plugin</artifactId>\n-                    <version>2.4</version>\n+                    <version>2.6</version>\n                 </plugin>\n \n                 <plugin>\n                     <artifactId>maven-javadoc-plugin</artifactId>\n-                    <version>2.9.1</version>\n+                    <version>2.10.2</version>\n                 </plugin>\n \n                 <plugin>\n                     <artifactId>maven-install-plugin</artifactId>\n-                    <version>2.5.1</version>\n+                    <version>2.5.2</version>\n                 </plugin>\n \n                 <plugin>\n                     <artifactId>maven-deploy-plugin</artifactId>\n-                    <version>2.8.1</version>\n+                    <version>2.8.2</version>\n                 </plugin>\n \n                 <plugin>\n                     <artifactId>maven-plugin-plugin</artifactId>\n-                    <version>3.2</version>\n+                    <version>3.4</version>\n                 </plugin>\n \n                 <plugin>\n                     <artifactId>maven-site-plugin</artifactId>\n-                    <version>3.3</version>\n+                    <version>3.4</version>\n                 </plugin>\n \n                 <plugin>\n                     <artifactId>maven-project-info-reports-plugin</artifactId>\n-                    <version>2.7</version>\n+                    <version>2.8</version>\n                 </plugin>\n \n                 <plugin>\n                     <artifactId>maven-source-plugin</artifactId>\n-                    <version>2.2.1</version>\n+                    <version>2.4</version>\n                 </plugin>\n \n                 <plugin>\n                     <artifactId>maven-release-plugin</artifactId>\n-                    <version>2.5</version>\n+                    <version>2.5.1</version>\n                 </plugin>\n \n                 <plugin>\n                     <artifactId>maven-enforcer-plugin</artifactId>\n-                    <version>1.3.1</version>\n+                    <version>1.4</version>\n                 </plugin>\n \n                 <plugin>\n@@ -338,27 +338,27 @@\n \n                 <plugin>\n                     <artifactId>maven-surefire-plugin</artifactId>\n-                    <version>2.16</version>\n+                    <version>2.18.1</version>\n                 </plugin>\n \n                 <plugin>\n                     <artifactId>maven-failsafe-plugin</artifactId>\n-                    <version>2.17</version>\n+                    <version>2.18.1</version>\n                 </plugin>\n \n                 <plugin>\n                     <artifactId>maven-invoker-plugin</artifactId>\n-                    <version>1.8</version>\n+                    <version>1.9</version>\n                 </plugin>\n \n                 <plugin>\n                     <artifactId>maven-dependency-plugin</artifactId>\n-                    <version>2.8</version>\n+                    <version>2.10</version>\n                 </plugin>\n \n                 <plugin>\n                     <artifactId>maven-antrun-plugin</artifactId>\n-                    <version>1.7</version>\n+                    <version>1.8</version>\n                 </plugin>\n \n                 <plugin>\n"
    },
    {
        "commit_hash": "e011d457ed782f22ecda288e2c17fe5b67be10b6",
        "previous_commit_hash": "9cafcca09c71ae3f0a2ae4ffddd4ea3868bba52f",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -64,6 +64,7 @@\n                                     <arg value=\"-Dretrolambda.bytecodeVersion=50\"/>\n                                     <arg value=\"-Dretrolambda.inputDir=${project.build.outputDirectory}\"/>\n                                     <arg value=\"-Dretrolambda.classpath=${compile_classpath}\"/>\n+                                    <arg value=\"-Dretrolambda.includedFiles=${project.build.outputDirectory}/net/orfjackal/retrolambda/Main.class${path.separator}${project.build.outputDirectory}/net/orfjackal/retrolambda/Config.class${path.separator}${project.build.outputDirectory}/net/orfjackal/retrolambda/Retrolambda.class\"/>\n                                     <arg value=\"-cp\"/>\n                                     <arg value=\"${project.build.outputDirectory}\"/>\n                                     <arg value=\"-cp\"/>\n"
    },
    {
        "commit_hash": "e011d457ed782f22ecda288e2c17fe5b67be10b6",
        "previous_commit_hash": "9cafcca09c71ae3f0a2ae4ffddd4ea3868bba52f",
        "diff_stats": {
            "additions": 0,
            "deletions": 4
        },
        "diff_content": "@@ -47,10 +47,6 @@ public class ClassHierarchyAnalyzer {\n                     return null;\n                 }\n                 c.addMethod(new MethodRef(owner, name, desc), new MethodKind.Implemented());\n-\n-                // XXX: backporting Retrolambda fails if we remove this; it tries backporting a lambda while backporting a lambda\n-                Runnable r = () -> {\n-                };\n                 return null;\n             }\n \n"
    },
    {
        "commit_hash": "04c1e286e5ab74d4aee97bcb082757c5fd4142d6",
        "previous_commit_hash": "e011d457ed782f22ecda288e2c17fe5b67be10b6",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,13 @@\n+<component name=\"libraryTable\">\n+  <library name=\"Maven: junit:junit:4.12\">\n+    <CLASSES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/junit/junit/4.12/junit-4.12.jar!/\" />\n+    </CLASSES>\n+    <JAVADOC>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/junit/junit/4.12/junit-4.12-javadoc.jar!/\" />\n+    </JAVADOC>\n+    <SOURCES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/junit/junit/4.12/junit-4.12-sources.jar!/\" />\n+    </SOURCES>\n+  </library>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "04c1e286e5ab74d4aee97bcb082757c5fd4142d6",
        "previous_commit_hash": "e011d457ed782f22ecda288e2c17fe5b67be10b6",
        "diff_stats": {
            "additions": 0,
            "deletions": 13
        },
        "diff_content": "@@ -1,13 +0,0 @@\n-<component name=\"libraryTable\">\n-  <library name=\"Maven: junit:junit:4.12-beta-2\">\n-    <CLASSES>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/junit/junit/4.12-beta-2/junit-4.12-beta-2.jar!/\" />\n-    </CLASSES>\n-    <JAVADOC>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/junit/junit/4.12-beta-2/junit-4.12-beta-2-javadoc.jar!/\" />\n-    </JAVADOC>\n-    <SOURCES>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/junit/junit/4.12-beta-2/junit-4.12-beta-2-sources.jar!/\" />\n-    </SOURCES>\n-  </library>\n-</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "04c1e286e5ab74d4aee97bcb082757c5fd4142d6",
        "previous_commit_hash": "e011d457ed782f22ecda288e2c17fe5b67be10b6",
        "diff_stats": {
            "additions": 4,
            "deletions": 4
        },
        "diff_content": "@@ -1,13 +1,13 @@\n <component name=\"libraryTable\">\n-  <library name=\"Maven: org.apache.maven.plugin-tools:maven-plugin-annotations:3.2\">\n+  <library name=\"Maven: org.apache.maven.plugin-tools:maven-plugin-annotations:3.4\">\n     <CLASSES>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/maven/plugin-tools/maven-plugin-annotations/3.2/maven-plugin-annotations-3.2.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/maven/plugin-tools/maven-plugin-annotations/3.4/maven-plugin-annotations-3.4.jar!/\" />\n     </CLASSES>\n     <JAVADOC>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/maven/plugin-tools/maven-plugin-annotations/3.2/maven-plugin-annotations-3.2-javadoc.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/maven/plugin-tools/maven-plugin-annotations/3.4/maven-plugin-annotations-3.4-javadoc.jar!/\" />\n     </JAVADOC>\n     <SOURCES>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/maven/plugin-tools/maven-plugin-annotations/3.2/maven-plugin-annotations-3.2-sources.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/maven/plugin-tools/maven-plugin-annotations/3.4/maven-plugin-annotations-3.4-sources.jar!/\" />\n     </SOURCES>\n   </library>\n </component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "04c1e286e5ab74d4aee97bcb082757c5fd4142d6",
        "previous_commit_hash": "e011d457ed782f22ecda288e2c17fe5b67be10b6",
        "diff_stats": {
            "additions": 4,
            "deletions": 4
        },
        "diff_content": "@@ -1,13 +1,13 @@\n <component name=\"libraryTable\">\n-  <library name=\"Maven: org.codehaus.plexus:plexus-utils:3.0.17\">\n+  <library name=\"Maven: org.codehaus.plexus:plexus-utils:3.0.21\">\n     <CLASSES>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/codehaus/plexus/plexus-utils/3.0.17/plexus-utils-3.0.17.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/codehaus/plexus/plexus-utils/3.0.21/plexus-utils-3.0.21.jar!/\" />\n     </CLASSES>\n     <JAVADOC>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/codehaus/plexus/plexus-utils/3.0.17/plexus-utils-3.0.17-javadoc.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/codehaus/plexus/plexus-utils/3.0.21/plexus-utils-3.0.21-javadoc.jar!/\" />\n     </JAVADOC>\n     <SOURCES>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/codehaus/plexus/plexus-utils/3.0.17/plexus-utils-3.0.17-sources.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/codehaus/plexus/plexus-utils/3.0.21/plexus-utils-3.0.21-sources.jar!/\" />\n     </SOURCES>\n   </library>\n </component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "04c1e286e5ab74d4aee97bcb082757c5fd4142d6",
        "previous_commit_hash": "e011d457ed782f22ecda288e2c17fe5b67be10b6",
        "diff_stats": {
            "additions": 4,
            "deletions": 4
        },
        "diff_content": "@@ -1,13 +1,13 @@\n <component name=\"libraryTable\">\n-  <library name=\"Maven: org.mockito:mockito-core:1.10.8\">\n+  <library name=\"Maven: org.mockito:mockito-core:1.10.19\">\n     <CLASSES>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/mockito/mockito-core/1.10.8/mockito-core-1.10.8.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/mockito/mockito-core/1.10.19/mockito-core-1.10.19.jar!/\" />\n     </CLASSES>\n     <JAVADOC>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/mockito/mockito-core/1.10.8/mockito-core-1.10.8-javadoc.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/mockito/mockito-core/1.10.19/mockito-core-1.10.19-javadoc.jar!/\" />\n     </JAVADOC>\n     <SOURCES>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/mockito/mockito-core/1.10.8/mockito-core-1.10.8-sources.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/mockito/mockito-core/1.10.19/mockito-core-1.10.19-sources.jar!/\" />\n     </SOURCES>\n   </library>\n </component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "04c1e286e5ab74d4aee97bcb082757c5fd4142d6",
        "previous_commit_hash": "e011d457ed782f22ecda288e2c17fe5b67be10b6",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -22,10 +22,10 @@\n         <SOURCES />\n       </library>\n     </orderEntry>\n-    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.12-beta-2\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.12\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-library:1.3\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-core:1.3\" level=\"project\" />\n-    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.mockito:mockito-core:1.10.8\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.mockito:mockito-core:1.10.19\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.objenesis:objenesis:2.1\" level=\"project\" />\n   </component>\n </module>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "04c1e286e5ab74d4aee97bcb082757c5fd4142d6",
        "previous_commit_hash": "e011d457ed782f22ecda288e2c17fe5b67be10b6",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -8,10 +8,10 @@\n     </content>\n     <orderEntry type=\"inheritedJdk\" />\n     <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n-    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.12-beta-2\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.12\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-library:1.3\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-core:1.3\" level=\"project\" />\n-    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.mockito:mockito-core:1.10.8\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.mockito:mockito-core:1.10.19\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.objenesis:objenesis:2.1\" level=\"project\" />\n   </component>\n </module>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "04c1e286e5ab74d4aee97bcb082757c5fd4142d6",
        "previous_commit_hash": "e011d457ed782f22ecda288e2c17fe5b67be10b6",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -92,7 +92,7 @@\n             <dependency>\n                 <groupId>junit</groupId>\n                 <artifactId>junit</artifactId>\n-                <version>4.12-beta-2</version>\n+                <version>4.12</version>\n                 <exclusions>\n                     <!-- Avoid diverging hamcrest-library and hamcrest-core versions -->\n                     <exclusion>\n@@ -111,7 +111,7 @@\n             <dependency>\n                 <groupId>org.mockito</groupId>\n                 <artifactId>mockito-core</artifactId>\n-                <version>1.10.8</version>\n+                <version>1.10.19</version>\n             </dependency>\n \n             <!-- Utils -->\n"
    },
    {
        "commit_hash": "04c1e286e5ab74d4aee97bcb082757c5fd4142d6",
        "previous_commit_hash": "e011d457ed782f22ecda288e2c17fe5b67be10b6",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -8,10 +8,10 @@\n     </content>\n     <orderEntry type=\"inheritedJdk\" />\n     <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n-    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.12-beta-2\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.12\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-library:1.3\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-core:1.3\" level=\"project\" />\n-    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.mockito:mockito-core:1.10.8\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.mockito:mockito-core:1.10.19\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.objenesis:objenesis:2.1\" level=\"project\" />\n   </component>\n </module>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "04c1e286e5ab74d4aee97bcb082757c5fd4142d6",
        "previous_commit_hash": "e011d457ed782f22ecda288e2c17fe5b67be10b6",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -28,14 +28,14 @@\n         <dependency>\n             <groupId>org.apache.maven.plugin-tools</groupId>\n             <artifactId>maven-plugin-annotations</artifactId>\n-            <version>3.2</version>\n+            <version>3.4</version>\n             <scope>provided</scope>\n         </dependency>\n \n         <dependency>\n             <groupId>org.codehaus.plexus</groupId>\n             <artifactId>plexus-utils</artifactId>\n-            <version>3.0.17</version>\n+            <version>3.0.21</version>\n         </dependency>\n \n         <dependency>\n"
    },
    {
        "commit_hash": "04c1e286e5ab74d4aee97bcb082757c5fd4142d6",
        "previous_commit_hash": "e011d457ed782f22ecda288e2c17fe5b67be10b6",
        "diff_stats": {
            "additions": 4,
            "deletions": 4
        },
        "diff_content": "@@ -20,9 +20,9 @@\n     <orderEntry type=\"module\" module-name=\"retrolambda\" />\n     <orderEntry type=\"library\" name=\"Maven: org.ow2.asm:asm-debug-all:5.0.3\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-plugin-api:2.0\" level=\"project\" />\n-    <orderEntry type=\"library\" scope=\"PROVIDED\" name=\"Maven: org.apache.maven.plugin-tools:maven-plugin-annotations:3.2\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"PROVIDED\" name=\"Maven: org.apache.maven.plugin-tools:maven-plugin-annotations:3.4\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-artifact:3.0\" level=\"project\" />\n-    <orderEntry type=\"library\" name=\"Maven: org.codehaus.plexus:plexus-utils:3.0.17\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.codehaus.plexus:plexus-utils:3.0.21\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.twdata.maven:mojo-executor:2.2.0\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-core:3.0\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-settings:3.0\" level=\"project\" />\n@@ -44,10 +44,10 @@\n     <orderEntry type=\"library\" name=\"Maven: org.sonatype.plexus:plexus-cipher:1.4\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-model:3.0\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: com.google.guava:guava:18.0\" level=\"project\" />\n-    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.12-beta-2\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.12\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-library:1.3\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-core:1.3\" level=\"project\" />\n-    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.mockito:mockito-core:1.10.8\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.mockito:mockito-core:1.10.19\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.objenesis:objenesis:2.1\" level=\"project\" />\n   </component>\n </module>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "04c1e286e5ab74d4aee97bcb082757c5fd4142d6",
        "previous_commit_hash": "e011d457ed782f22ecda288e2c17fe5b67be10b6",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -12,10 +12,10 @@\n     <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n     <orderEntry type=\"library\" name=\"Maven: org.ow2.asm:asm-debug-all:5.0.3\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: com.google.guava:guava:18.0\" level=\"project\" />\n-    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.12-beta-2\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.12\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-library:1.3\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-core:1.3\" level=\"project\" />\n-    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.mockito:mockito-core:1.10.8\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.mockito:mockito-core:1.10.19\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.objenesis:objenesis:2.1\" level=\"project\" />\n   </component>\n </module>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "cfdfc2c64698f541b437c08e2892e0398a3923b3",
        "previous_commit_hash": "04c1e286e5ab74d4aee97bcb082757c5fd4142d6",
        "diff_stats": {
            "additions": 5,
            "deletions": 5
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -31,13 +31,13 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n     @Component\n     ToolchainManager toolchainManager;\n \n-    @Component\n-    private MavenSession session;\n-\n     @Component\n     private BuildPluginManager pluginManager;\n \n-    @Component\n+    @Parameter(defaultValue = \"${session}\", readonly = true)\n+    private MavenSession session;\n+\n+    @Parameter(defaultValue = \"${project}\", readonly = true)\n     protected MavenProject project;\n \n     /**\n"
    },
    {
        "commit_hash": "ed90c63b92610fe9c523d18af2ded8f1c3e2df37",
        "previous_commit_hash": "cfdfc2c64698f541b437c08e2892e0398a3923b3",
        "diff_stats": {
            "additions": 6,
            "deletions": 0
        },
        "diff_content": "@@ -100,6 +100,12 @@ Optional system properties:\n       offset 7 at http://en.wikipedia.org/wiki/Java_class_file#General_layout\n       Default value is 51 (i.e. Java 7)\n \n+  retrolambda.defaultMethods\n+      Whether to backport default and static methods on interfaces.\n+      LIMITATIONS: All backported interfaces and all classes which implement\n+      them must be backported together with one execution of Retrolambda.\n+      Disabled by default. Enable by setting to \"true\"\n+\n   retrolambda.outputDir\n       Output directory into where the generated class files are written.\n       Defaults to same as retrolambda.inputDir\n"
    },
    {
        "commit_hash": "ed90c63b92610fe9c523d18af2ded8f1c3e2df37",
        "previous_commit_hash": "cfdfc2c64698f541b437c08e2892e0398a3923b3",
        "diff_stats": {
            "additions": 17,
            "deletions": 0
        },
        "diff_content": "@@ -15,6 +15,7 @@ public class Config {\n \n     private static final String PREFIX = \"retrolambda.\";\n     public static final String BYTECODE_VERSION = PREFIX + \"bytecodeVersion\";\n+    public static final String DEFAULT_METHODS = PREFIX + \"defaultMethods\";\n     public static final String INPUT_DIR = PREFIX + \"inputDir\";\n     public static final String OUTPUT_DIR = PREFIX + \"outputDir\";\n     public static final String CLASSPATH = PREFIX + \"classpath\";\n@@ -74,6 +75,22 @@ public class Config {\n     }\n \n \n+    // default methods\n+\n+    static {\n+        optionalParameterHelp(DEFAULT_METHODS,\n+                \"Whether to backport default and static methods on interfaces.\",\n+                \"LIMITATIONS: All backported interfaces and all classes which implement\",\n+                \"them must be backported together with one execution of Retrolambda.\",\n+                \"Disabled by default. Enable by setting to \\\"true\\\"\");\n+\n+    }\n+\n+    public boolean isDefaultMethodsEnabled() {\n+        return Boolean.parseBoolean(p.getProperty(DEFAULT_METHODS, \"false\"));\n+    }\n+\n+\n     // input dir\n \n     static {\n"
    },
    {
        "commit_hash": "ed90c63b92610fe9c523d18af2ded8f1c3e2df37",
        "previous_commit_hash": "cfdfc2c64698f541b437c08e2892e0398a3923b3",
        "diff_stats": {
            "additions": 9,
            "deletions": 1
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -35,6 +35,14 @@ public class ConfigTest {\n         assertThat(\"human printable format\", config().getJavaVersion(), is(\"Java 6\"));\n     }\n \n+    @Test\n+    public void default_methods() {\n+        assertThat(\"defaults to disabled\", config().isDefaultMethodsEnabled(), is(false));\n+\n+        systemProperties.setProperty(Config.DEFAULT_METHODS, \"true\");\n+        assertThat(\"can override the default\", config().isDefaultMethodsEnabled(), is(true));\n+    }\n+\n     @Test\n     public void input_directory_is_required() {\n         thrown.expect(IllegalArgumentException.class);\n"
    },
    {
        "commit_hash": "17587dfe476f6af69dd49e6f3367ad42bbb8ecfa",
        "previous_commit_hash": "ed90c63b92610fe9c523d18af2ded8f1c3e2df37",
        "diff_stats": {
            "additions": 28,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,28 @@\n+#!/bin/bash\n+set -eux\n+\n+# Test the forking mechanism\n+\n+mvn clean verify \\\n+    --errors \\\n+    -P fork\n+\n+# The Maven plugin's minimum requirement is Java 6,\n+# but then the plugin must force forking the process\n+\n+JAVA_HOME=\"$JAVA6_HOME\" mvn clean verify \\\n+    --errors \\\n+    -P java6\n+\n+# Run end-to-end tests against all supported Java versions\n+\n+mvn clean verify \\\n+    --errors \\\n+    -P java6\n+\n+mvn clean verify \\\n+    --errors \\\n+    -P java5\n+\n+mvn clean deploy \\\n+    --errors\n"
    },
    {
        "commit_hash": "17587dfe476f6af69dd49e6f3367ad42bbb8ecfa",
        "previous_commit_hash": "ed90c63b92610fe9c523d18af2ded8f1c3e2df37",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -62,10 +62,10 @@ git add -u\n git commit -m \"Release $RELEASE_VERSION\"\n git tag -s -m \"$APP_NAME $RELEASE_VERSION\" \"v$RELEASE_VERSION\"\n \n-$SCRIPTS/stage.sh \"$APP_NAME $RELEASE_VERSION\"\n+${SCRIPTS}/stage.sh \"$APP_NAME $RELEASE_VERSION\"\n \n set-project-version \"$NEXT_VERSION\"\n git add -u\n git commit -m \"Prepare for next development iteration\"\n \n-$SCRIPTS/publish.sh \"$APP_NAME $RELEASE_VERSION\" \"$RELEASE_VERSION\"\n+${SCRIPTS}/publish.sh \"$APP_NAME $RELEASE_VERSION\" \"$RELEASE_VERSION\"\n"
    },
    {
        "commit_hash": "17587dfe476f6af69dd49e6f3367ad42bbb8ecfa",
        "previous_commit_hash": "ed90c63b92610fe9c523d18af2ded8f1c3e2df37",
        "diff_stats": {
            "additions": 3,
            "deletions": 23
        },
        "diff_content": "@@ -1,33 +1,13 @@\n #!/bin/bash\n set -eu\n : ${1:? Usage: $0 DESCRIPTION}\n+SCRIPTS=`dirname \"$0\"`\n DESCRIPTION=\"$1\"\n set -x\n \n-rm -rfv staging\n-\n-# Test that also the forking mechanism works\n-\n-mvn clean verify \\\n-    --errors \\\n-    -P fork\n-\n-# The Maven plugin's minimum requirement is Java 6,\n-# but then the plugin must force forking the process\n-\n-JAVA_HOME=\"$JAVA6_HOME\" mvn clean verify \\\n-    --errors \\\n-    -P java6\n-\n-# Run end-to-end tests against all supported Java versions\n-\n-mvn clean verify \\\n-    --errors \\\n-    -P java6\n+${SCRIPTS}/build.sh\n \n-mvn clean verify \\\n-    --errors \\\n-    -P java5\n+rm -rfv staging\n \n mvn clean deploy \\\n     --errors \\\n"
    },
    {
        "commit_hash": "04a717ea4d52a0bcb938ad1b16b4b8b9a3279b9f",
        "previous_commit_hash": "17587dfe476f6af69dd49e6f3367ad42bbb8ecfa",
        "diff_stats": {
            "additions": 12,
            "deletions": 0
        },
        "diff_content": "@@ -66,6 +66,16 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n     @Parameter(defaultValue = \"1.7\", property = \"retrolambdaTarget\", required = true)\n     public String target;\n \n+    /**\n+     * Whether to backport default and static methods on interfaces.\n+     * LIMITATIONS: All backported interfaces and all classes which implement\n+     * them must be backported together with one execution of Retrolambda.\n+     *\n+     * @since 2.0.0\n+     */\n+    @Parameter(defaultValue = \"false\", property = \"retrolambdaDefaultMethods\", required = true)\n+    public boolean defaultMethods;\n+\n     /**\n      * Forces Retrolambda to run in a separate process. The default is not to fork,\n      * in which case Maven has to run under Java 8, or this plugin will fall back\n@@ -115,6 +125,7 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n         try {\n             Properties p = new Properties();\n             p.setProperty(Config.BYTECODE_VERSION, \"\" + targetBytecodeVersions.get(target));\n+            p.setProperty(Config.DEFAULT_METHODS, \"\" + defaultMethods);\n             p.setProperty(Config.INPUT_DIR, getInputDir().getAbsolutePath());\n             p.setProperty(Config.OUTPUT_DIR, getOutputDir().getAbsolutePath());\n             p.setProperty(Config.CLASSPATH, getClasspath());\n@@ -143,6 +154,7 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n                                         attribute(\"executable\", getJavaCommand()),\n                                         attribute(\"failonerror\", \"true\")),\n                                 element(\"arg\", attribute(\"value\", \"-Dretrolambda.bytecodeVersion=\" + targetBytecodeVersions.get(target))),\n+                                element(\"arg\", attribute(\"value\", \"-Dretrolambda.defaultMethods=\" + defaultMethods)),\n                                 element(\"arg\", attribute(\"value\", \"-Dretrolambda.inputDir=\" + getInputDir().getAbsolutePath())),\n                                 element(\"arg\", attribute(\"value\", \"-Dretrolambda.outputDir=\" + getOutputDir().getAbsolutePath())),\n                                 element(\"arg\", attribute(\"value\", \"-Dretrolambda.classpath=\" + getClasspath())),\n"
    },
    {
        "commit_hash": "2344b77885470de03b744cca6a57c6d5b3a7ab47",
        "previous_commit_hash": "04a717ea4d52a0bcb938ad1b16b4b8b9a3279b9f",
        "diff_stats": {
            "additions": 0,
            "deletions": 2
        },
        "diff_content": "@@ -177,8 +177,6 @@ Version History\n \n - Backports default methods and static methods on interfaces\n   ([Issue #31](https://github.com/orfjackal/retrolambda/issues/31))\n-  - *Experimental! Can be enabled with the environment variable\n-    DEFAULT_METHODS=2*\n \n ### Retrolambda 1.8.1 (2015-01-06)\n \n"
    },
    {
        "commit_hash": "2344b77885470de03b744cca6a57c6d5b3a7ab47",
        "previous_commit_hash": "04a717ea4d52a0bcb938ad1b16b4b8b9a3279b9f",
        "diff_stats": {
            "additions": 5,
            "deletions": 7
        },
        "diff_content": "@@ -87,6 +87,7 @@\n                 </executions>\n                 <configuration>\n                     <target>${testBytecodeTarget}</target>\n+                    <defaultMethods>${testDefaultMethods}</defaultMethods>\n                     <fork>${testFork}</fork>\n                 </configuration>\n             </plugin>\n@@ -96,13 +97,10 @@\n \n     <profiles>\n         <profile>\n-            <!-- TODO: default methods; remove this profile -->\n-            <id>no-default-methods</id>\n-            <activation>\n-                <property>\n-                    <name>!env.DEFAULT_METHODS</name>\n-                </property>\n-            </activation>\n+            <id>noDefaultMethods</id>\n+            <properties>\n+                <testDefaultMethods>false</testDefaultMethods>\n+            </properties>\n             <build>\n                 <plugins>\n                     <plugin>\n"
    },
    {
        "commit_hash": "2344b77885470de03b744cca6a57c6d5b3a7ab47",
        "previous_commit_hash": "04a717ea4d52a0bcb938ad1b16b4b8b9a3279b9f",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -46,6 +46,7 @@\n         <testJavaHome>${env.JAVA7_HOME}</testJavaHome>\n         <testBytecodeTarget>1.7</testBytecodeTarget>\n         <testFork>false</testFork>\n+        <testDefaultMethods>true</testDefaultMethods>\n     </properties>\n \n     <prerequisites>\n"
    },
    {
        "commit_hash": "2344b77885470de03b744cca6a57c6d5b3a7ab47",
        "previous_commit_hash": "04a717ea4d52a0bcb938ad1b16b4b8b9a3279b9f",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -73,6 +73,19 @@\n                 </configuration>\n             </plugin>\n \n+            <plugin>\n+                <artifactId>maven-install-plugin</artifactId>\n+                <executions>\n+                    <execution>\n+                        <id>code-completion-support-for-idea</id>\n+                        <phase>pre-integration-test</phase>\n+                        <goals>\n+                            <goal>install</goal>\n+                        </goals>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+\n             <plugin>\n                 <artifactId>maven-plugin-plugin</artifactId>\n                 <configuration>\n"
    },
    {
        "commit_hash": "2344b77885470de03b744cca6a57c6d5b3a7ab47",
        "previous_commit_hash": "04a717ea4d52a0bcb938ad1b16b4b8b9a3279b9f",
        "diff_stats": {
            "additions": 0,
            "deletions": 19
        },
        "diff_content": "@@ -1,19 +0,0 @@\n-// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n-// This software is released under the Apache License 2.0.\n-// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n-\n-package net.orfjackal.retrolambda;\n-\n-public class FeatureToggles {\n-\n-    // TODO: default methods; remove this toggle and all other related TODOs\n-    public static final int DEFAULT_METHODS = parseInt(System.getenv(\"DEFAULT_METHODS\"), 0);\n-\n-    private static int parseInt(String value, int defaultValue) {\n-        try {\n-            return Integer.parseInt(value);\n-        } catch (NumberFormatException e) {\n-            return defaultValue;\n-        }\n-    }\n-}\n"
    },
    {
        "commit_hash": "2344b77885470de03b744cca6a57c6d5b3a7ab47",
        "previous_commit_hash": "04a717ea4d52a0bcb938ad1b16b4b8b9a3279b9f",
        "diff_stats": {
            "additions": 3,
            "deletions": 1
        },
        "diff_content": "@@ -17,11 +17,13 @@ public class Retrolambda {\n \n     public static void run(Config config) throws Throwable {\n         int bytecodeVersion = config.getBytecodeVersion();\n+        boolean defaultMethodsEnabled = config.isDefaultMethodsEnabled();\n         Path inputDir = config.getInputDir();\n         Path outputDir = config.getOutputDir();\n         String classpath = config.getClasspath();\n         List<Path> includedFiles = config.getIncludedFiles();\n         System.out.println(\"Bytecode version: \" + bytecodeVersion + \" (\" + config.getJavaVersion() + \")\");\n+        System.out.println(\"Default methods:  \" + defaultMethodsEnabled);\n         System.out.println(\"Input directory:  \" + inputDir);\n         System.out.println(\"Output directory: \" + outputDir);\n         System.out.println(\"Classpath:        \" + classpath);\n@@ -38,7 +40,7 @@ public class Retrolambda {\n \n         ClassHierarchyAnalyzer analyzer = new ClassHierarchyAnalyzer();\n         ClassSaver saver = new ClassSaver(outputDir);\n-        Transformers transformers = new Transformers(bytecodeVersion, analyzer);\n+        Transformers transformers = new Transformers(bytecodeVersion, defaultMethodsEnabled, analyzer);\n         LambdaClassSaver lambdaClassSaver = new LambdaClassSaver(saver, transformers);\n \n         try (LambdaClassDumper dumper = new LambdaClassDumper(lambdaClassSaver)) {\n"
    },
    {
        "commit_hash": "2344b77885470de03b744cca6a57c6d5b3a7ab47",
        "previous_commit_hash": "04a717ea4d52a0bcb938ad1b16b4b8b9a3279b9f",
        "diff_stats": {
            "additions": 6,
            "deletions": 4
        },
        "diff_content": "@@ -14,16 +14,18 @@ import java.util.Optional;\n public class Transformers {\n \n     private final int targetVersion;\n+    private final boolean defaultMethodsEnabled;\n     private final ClassHierarchyAnalyzer analyzer;\n \n-    public Transformers(int targetVersion, ClassHierarchyAnalyzer analyzer) {\n+    public Transformers(int targetVersion, boolean defaultMethodsEnabled, ClassHierarchyAnalyzer analyzer) {\n         this.targetVersion = targetVersion;\n+        this.defaultMethodsEnabled = defaultMethodsEnabled;\n         this.analyzer = analyzer;\n     }\n \n     public byte[] backportLambdaClass(ClassReader reader) {\n         return transform(reader, (next) -> {\n-            if (FeatureToggles.DEFAULT_METHODS == 2) {\n+            if (defaultMethodsEnabled) {\n                 // Lambda classes are generated dynamically, so they were not\n                 // part of the original analytics and must be analyzed now,\n                 // in case they implement interfaces with default methods.\n@@ -40,7 +42,7 @@ public class Transformers {\n \n     public byte[] backportClass(ClassReader reader) {\n         return transform(reader, (next) -> {\n-            if (FeatureToggles.DEFAULT_METHODS == 2) {\n+            if (defaultMethodsEnabled) {\n                 next = new UpdateRelocatedMethodInvocations(next, analyzer);\n                 next = new AddMethodDefaultImplementations(next, analyzer);\n             }\n@@ -51,7 +53,7 @@ public class Transformers {\n \n     public byte[] backportInterface(ClassReader reader) {\n         return transform(reader, (next) -> {\n-            if (FeatureToggles.DEFAULT_METHODS == 2) {\n+            if (defaultMethodsEnabled) {\n                 next = new RemoveStaticMethods(next);\n                 next = new RemoveDefaultMethodBodies(next);\n                 next = new UpdateRelocatedMethodInvocations(next, analyzer);\n"
    },
    {
        "commit_hash": "2344b77885470de03b744cca6a57c6d5b3a7ab47",
        "previous_commit_hash": "04a717ea4d52a0bcb938ad1b16b4b8b9a3279b9f",
        "diff_stats": {
            "additions": 1,
            "deletions": 2
        },
        "diff_content": "@@ -49,7 +49,6 @@ public class WarnAboutDefaultAndStaticMethods extends ClassVisitor {\n \n     private void printWarning(String methodKind, String methodName) {\n         System.out.println(\"WARNING: The interface \" + interfaceName + \" has \" + methodKind + \" \\\"\" + methodName + \"\\\" \" +\n-                \"but the experimental support for them is not enabled \" +\n-                \"(set the environment variable DEFAULT_METHODS=2)\");\n+                \"but backporting default methods is not enabled\");\n     }\n }\n"
    },
    {
        "commit_hash": "2344b77885470de03b744cca6a57c6d5b3a7ab47",
        "previous_commit_hash": "04a717ea4d52a0bcb938ad1b16b4b8b9a3279b9f",
        "diff_stats": {
            "additions": 12,
            "deletions": 0
        },
        "diff_content": "@@ -6,6 +6,9 @@ set -eux\n mvn clean verify \\\n     --errors \\\n     -P fork\n+mvn clean verify \\\n+    --errors \\\n+    -P fork,noDefaultMethods\n \n # The Maven plugin's minimum requirement is Java 6,\n # but then the plugin must force forking the process\n@@ -19,10 +22,19 @@ JAVA_HOME=\"$JAVA6_HOME\" mvn clean verify \\\n mvn clean verify \\\n     --errors \\\n     -P java6\n+mvn clean verify \\\n+    --errors \\\n+    -P java6,noDefaultMethods\n \n mvn clean verify \\\n     --errors \\\n     -P java5\n+mvn clean verify \\\n+    --errors \\\n+    -P java5,noDefaultMethods\n \n mvn clean deploy \\\n     --errors\n+mvn clean deploy \\\n+    --errors \\\n+    -P noDefaultMethods\n"
    },
    {
        "commit_hash": "b0cd437be194837ca436e0b73a8a1002bcb6d1b0",
        "previous_commit_hash": "2344b77885470de03b744cca6a57c6d5b3a7ab47",
        "diff_stats": {
            "additions": 3,
            "deletions": 0
        },
        "diff_content": "@@ -58,6 +58,9 @@ public class Transformers {\n                 next = new RemoveDefaultMethodBodies(next);\n                 next = new UpdateRelocatedMethodInvocations(next, analyzer);\n             } else {\n+                // XXX: It would be better to remove only those static methods which are lambda implementation methods,\n+                // but that would either require the use of naming patterns (not guaranteed to work with every Java compiler)\n+                // or passing around information that which relocated static methods are because of lambdas.\n                 next = new RemoveStaticMethods(next); // needed for lambdas in an interface's constant initializer\n                 next = new WarnAboutDefaultAndStaticMethods(next);\n             }\n"
    },
    {
        "commit_hash": "4b9549ea6abdb053522725885b9eb59192e402d8",
        "previous_commit_hash": "b0cd437be194837ca436e0b73a8a1002bcb6d1b0",
        "diff_stats": {
            "additions": 27,
            "deletions": 8
        },
        "diff_content": "@@ -6,11 +6,15 @@ Retrolambda: Use Lambdas on Java 7\n \n Just as there was [Retroweaver](http://retroweaver.sourceforge.net/) et al.\n for running Java 5 code with generics on Java 1.4, **Retrolambda** lets you\n-run Java 8 code with lambda expressions and method references on Java 7 or\n-lower. It does this by transforming your Java 8 compiled bytecode so that\n-it can run on a Java 7 runtime. After the transformation they are just a\n-bunch of normal .class files, without any additional runtime dependencies.\n-[Read more details](#backported-language-features).\n+run Java 8 code with **lambda expressions** and **method references** on\n+Java 7 or lower. It does this by transforming your Java 8 compiled bytecode\n+so that it can run on a Java 7 runtime. After the transformation they are\n+just a bunch of normal .class files, without any additional runtime\n+dependencies. [Read more details](#backported-language-features).\n+\n+There is also [limited support](#known-limitations) for backporting\n+**default methods** and **static methods on interfaces**. This feature is\n+disabled by default.\n \n Adventurous developers may use Retrolambda to backport lambda expressions\n even to Java 6 or Java 5. And if you reach Java 5, there are [other\n@@ -101,9 +105,10 @@ Optional system properties:\n       Default value is 51 (i.e. Java 7)\n \n   retrolambda.defaultMethods\n-      Whether to backport default and static methods on interfaces.\n+      Whether to backport default methods and static methods on interfaces.\n       LIMITATIONS: All backported interfaces and all classes which implement\n-      them must be backported together with one execution of Retrolambda.\n+      them or call their static methods must be backported together,\n+      with one execution of Retrolambda.\n       Disabled by default. Enable by setting to \"true\"\n \n   retrolambda.outputDir\n@@ -156,13 +161,27 @@ expressions and they are backported in the same way.\n If you would like the suppressed exceptions to be logged instead of\n swallowed, please create a feature request and we'll make it configurable.\n \n+*Optionally also:*\n+\n+**Default methods** are backported by moving the default methods to a\n+companion class (interface name + \"$\") as static methods, and by adding the\n+necessary method implementations to all classes which implement that\n+interface.\n+\n+**Static methods on interfaces** are backported by moving the static\n+methods to a companion class (interface name + \"$\"), and by changing all\n+methods calls to call the new method location.\n+\n \n Known Limitations\n -----------------\n \n Does not backport Java 8 APIs.\n \n-Does not backport Java 8 language features other than lambda expressions.\n+Backporting default methods and static methods on interfaces requires all\n+backported interfaces and all classes which implement them or call their\n+static methods to be backported together, with one execution of\n+Retrolambda.\n \n May break if a future JDK 8 build stops generating a new class for each\n `invokedynamic` call. Retrolambda works so that it captures the bytecode\n"
    },
    {
        "commit_hash": "4b9549ea6abdb053522725885b9eb59192e402d8",
        "previous_commit_hash": "b0cd437be194837ca436e0b73a8a1002bcb6d1b0",
        "diff_stats": {
            "additions": 3,
            "deletions": 2
        },
        "diff_content": "@@ -67,9 +67,10 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n     public String target;\n \n     /**\n-     * Whether to backport default and static methods on interfaces.\n+     * Whether to backport default methods and static methods on interfaces.\n      * LIMITATIONS: All backported interfaces and all classes which implement\n-     * them must be backported together with one execution of Retrolambda.\n+     * them or call their static methods must be backported together,\n+     * with one execution of Retrolambda.\n      *\n      * @since 2.0.0\n      */\n"
    },
    {
        "commit_hash": "4b9549ea6abdb053522725885b9eb59192e402d8",
        "previous_commit_hash": "b0cd437be194837ca436e0b73a8a1002bcb6d1b0",
        "diff_stats": {
            "additions": 3,
            "deletions": 2
        },
        "diff_content": "@@ -79,9 +79,10 @@ public class Config {\n \n     static {\n         optionalParameterHelp(DEFAULT_METHODS,\n-                \"Whether to backport default and static methods on interfaces.\",\n+                \"Whether to backport default methods and static methods on interfaces.\",\n                 \"LIMITATIONS: All backported interfaces and all classes which implement\",\n-                \"them must be backported together with one execution of Retrolambda.\",\n+                \"them or call their static methods must be backported together,\",\n+                \"with one execution of Retrolambda.\",\n                 \"Disabled by default. Enable by setting to \\\"true\\\"\");\n \n     }\n"
    },
    {
        "commit_hash": "4ec7c8e304be0505f2d06bf57297f2564c99c255",
        "previous_commit_hash": "4b9549ea6abdb053522725885b9eb59192e402d8",
        "diff_stats": {
            "additions": 8,
            "deletions": 8
        },
        "diff_content": "@@ -5,10 +5,10 @@ set -eux\n \n mvn clean verify \\\n     --errors \\\n-    -P fork\n+    -P fork,noDefaultMethods\n mvn clean verify \\\n     --errors \\\n-    -P fork,noDefaultMethods\n+    -P fork\n \n # The Maven plugin's minimum requirement is Java 6,\n # but then the plugin must force forking the process\n@@ -21,20 +21,20 @@ JAVA_HOME=\"$JAVA6_HOME\" mvn clean verify \\\n \n mvn clean verify \\\n     --errors \\\n-    -P java6\n+    -P java6,noDefaultMethods\n mvn clean verify \\\n     --errors \\\n-    -P java6,noDefaultMethods\n+    -P java6\n \n mvn clean verify \\\n     --errors \\\n-    -P java5\n+    -P java5,noDefaultMethods\n mvn clean verify \\\n     --errors \\\n-    -P java5,noDefaultMethods\n+    -P java5\n \n-mvn clean deploy \\\n-    --errors\n mvn clean deploy \\\n     --errors \\\n     -P noDefaultMethods\n+mvn clean deploy \\\n+    --errors\n"
    },
    {
        "commit_hash": "8a2b3c1efa2618adf14b5dbfbacfe0dd7832cb1c",
        "previous_commit_hash": "4ec7c8e304be0505f2d06bf57297f2564c99c255",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -33,8 +33,8 @@ mvn clean verify \\\n     --errors \\\n     -P java5\n \n-mvn clean deploy \\\n+mvn clean verify \\\n     --errors \\\n     -P noDefaultMethods\n-mvn clean deploy \\\n+mvn clean verify \\\n     --errors\n"
    },
    {
        "commit_hash": "2df6174117cdc0f5d2d6ff79574be9aaeaa18beb",
        "previous_commit_hash": "8a2b3c1efa2618adf14b5dbfbacfe0dd7832cb1c",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -44,7 +44,7 @@ To run Retrolambda using Maven, add the following to your pom.xml:\n <plugin>\n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>retrolambda-maven-plugin</artifactId>\n-    <version>1.8.1</version>\n+    <version>2.0.0</version>\n     <executions>\n         <execution>\n             <goals>\n@@ -192,7 +192,7 @@ optimizations to that mechanism may break Retrolambda.\n Version History\n ---------------\n \n-### Upcoming\n+### Retrolambda 2.0.0 (2015-03-28)\n \n - Backports default methods and static methods on interfaces\n   ([Issue #31](https://github.com/orfjackal/retrolambda/issues/31))\n"
    },
    {
        "commit_hash": "2df6174117cdc0f5d2d6ff79574be9aaeaa18beb",
        "previous_commit_hash": "8a2b3c1efa2618adf14b5dbfbacfe0dd7832cb1c",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.8.2-SNAPSHOT</version>\n+        <version>2.0.0</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "2df6174117cdc0f5d2d6ff79574be9aaeaa18beb",
        "previous_commit_hash": "8a2b3c1efa2618adf14b5dbfbacfe0dd7832cb1c",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>1.8.2-SNAPSHOT</version>\n+    <version>2.0.0</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "2df6174117cdc0f5d2d6ff79574be9aaeaa18beb",
        "previous_commit_hash": "8a2b3c1efa2618adf14b5dbfbacfe0dd7832cb1c",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.8.2-SNAPSHOT</version>\n+        <version>2.0.0</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "2df6174117cdc0f5d2d6ff79574be9aaeaa18beb",
        "previous_commit_hash": "8a2b3c1efa2618adf14b5dbfbacfe0dd7832cb1c",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.8.2-SNAPSHOT</version>\n+        <version>2.0.0</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "2df6174117cdc0f5d2d6ff79574be9aaeaa18beb",
        "previous_commit_hash": "8a2b3c1efa2618adf14b5dbfbacfe0dd7832cb1c",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>1.8.2-SNAPSHOT</version>\n+        <version>2.0.0</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "f64e06ea3f99ba99700983554a4a28131245d169",
        "previous_commit_hash": "2df6174117cdc0f5d2d6ff79574be9aaeaa18beb",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.0</version>\n+        <version>2.0.1-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "f64e06ea3f99ba99700983554a4a28131245d169",
        "previous_commit_hash": "2df6174117cdc0f5d2d6ff79574be9aaeaa18beb",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>2.0.0</version>\n+    <version>2.0.1-SNAPSHOT</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "f64e06ea3f99ba99700983554a4a28131245d169",
        "previous_commit_hash": "2df6174117cdc0f5d2d6ff79574be9aaeaa18beb",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.0</version>\n+        <version>2.0.1-SNAPSHOT</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "f64e06ea3f99ba99700983554a4a28131245d169",
        "previous_commit_hash": "2df6174117cdc0f5d2d6ff79574be9aaeaa18beb",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.0</version>\n+        <version>2.0.1-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "f64e06ea3f99ba99700983554a4a28131245d169",
        "previous_commit_hash": "2df6174117cdc0f5d2d6ff79574be9aaeaa18beb",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.0</version>\n+        <version>2.0.1-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "3930c11706fada7228cd0e1b4d612df5811baab9",
        "previous_commit_hash": "f64e06ea3f99ba99700983554a4a28131245d169",
        "diff_stats": {
            "additions": 4,
            "deletions": 0
        },
        "diff_content": "@@ -18,4 +18,8 @@ To run the tests using Java 6 and Java 5, use the commands:\n     mvn clean verify -P java6\n     mvn clean verify -P java5\n \n+To run all combinations of test configurations, use the script:\n+\n+    ./scripts/build.sh\n+\n Finally copy the executable JAR from the `retrolambda/target/` directory.\n"
    },
    {
        "commit_hash": "4237a6eadf39db69389d914e6477ccba277666e3",
        "previous_commit_hash": "3930c11706fada7228cd0e1b4d612df5811baab9",
        "diff_stats": {
            "additions": 5,
            "deletions": 5
        },
        "diff_content": "@@ -16,12 +16,12 @@ There is also [limited support](#known-limitations) for backporting\n **default methods** and **static methods on interfaces**. This feature is\n disabled by default.\n \n-Adventurous developers may use Retrolambda to backport lambda expressions\n-even to Java 6 or Java 5. And if you reach Java 5, there are [other\n-backporting tools](http://en.wikipedia.org/wiki/Java_backporting_tools)\n-that may let you go down to Java 1.4.\n+Retrolambda supports backporting to Java 7, Java 6 and Java 5 runtimes. And\n+for adventurous developers there are [other backporting\n+tools](http://en.wikipedia.org/wiki/Java_backporting_tools) that may let\n+you go from Java 5 down to Java 1.4.\n \n-Android developers may also use Retrolambda to take advantage of the Java 8\n+Android developers may use Retrolambda to take advantage of the Java 8\n features on Android. Serge Zaitsev has written [an article about\n it](http://zserge.com/blog/android-lambda.html) and there is a [Gradle\n plugin](#gradle-plugin) which makes it easy.\n"
    },
    {
        "commit_hash": "4aaa3ae2cce36d702c04e012a75910e8f1d069f8",
        "previous_commit_hash": "4237a6eadf39db69389d914e6477ccba277666e3",
        "diff_stats": {
            "additions": 8,
            "deletions": 7
        },
        "diff_content": "@@ -4,13 +4,14 @@ Retrolambda: Use Lambdas on Java 7\n \n [![Retrolambda presentation video](resources/presentation-preview.png)](https://www.youtube.com/watch?v=DUdhfPh9V_s)\n \n-Just as there was [Retroweaver](http://retroweaver.sourceforge.net/) et al.\n-for running Java 5 code with generics on Java 1.4, **Retrolambda** lets you\n-run Java 8 code with **lambda expressions** and **method references** on\n-Java 7 or lower. It does this by transforming your Java 8 compiled bytecode\n-so that it can run on a Java 7 runtime. After the transformation they are\n-just a bunch of normal .class files, without any additional runtime\n-dependencies. [Read more details](#backported-language-features).\n+Just as there was *Retroweaver* et al. for running Java 5 code with\n+generics on Java 1.4, *Retrolambda* lets you run Java 8 code with **lambda\n+expressions**, **method references** and **try-with-resources statements**\n+on Java 7, 6 or 5. It does this by transforming your Java 8 compiled\n+bytecode so that it can run on an older Java runtime. After the\n+transformation they are just a bunch of normal .class files, without any\n+additional runtime dependencies.\n+[Read more details](#backported-language-features).\n \n There is also [limited support](#known-limitations) for backporting\n **default methods** and **static methods on interfaces**. This feature is\n"
    },
    {
        "commit_hash": "6f236c6fd4b880519c9d60145e13d60afb109a11",
        "previous_commit_hash": "4aaa3ae2cce36d702c04e012a75910e8f1d069f8",
        "diff_stats": {
            "additions": 10,
            "deletions": 3
        },
        "diff_content": "@@ -164,14 +164,21 @@ swallowed, please create a feature request and we'll make it configurable.\n \n *Optionally also:*\n \n-**Default methods** are backported by moving the default methods to a\n-companion class (interface name + \"$\") as static methods, and by adding the\n+**Default methods** are backported by copying the default methods to a\n+companion class (interface name + \"$\") as static methods, replacing the\n+default methods in the interface with abstract methods, and by adding the\n necessary method implementations to all classes which implement that\n interface.\n \n **Static methods on interfaces** are backported by moving the static\n methods to a companion class (interface name + \"$\"), and by changing all\n-methods calls to call the new method location.\n+methods calls to call the new method location.<sup>[1]</sup>\n+\n+<sup>[1]</sup> *The static methods are moved to a companion class even with\n+default method support disabled, because some of them may be lambda\n+implementation methods, but the method calls to static methods are not\n+updated. This may cause weird error messages if static methods on\n+interfaces are accidentally used without enabling default method support.*\n \n \n Known Limitations\n"
    },
    {
        "commit_hash": "332747e0291fb8c91eb46d38abb6f17e5ac3fcba",
        "previous_commit_hash": "6f236c6fd4b880519c9d60145e13d60afb109a11",
        "diff_stats": {
            "additions": 3,
            "deletions": 1
        },
        "diff_content": "@@ -189,7 +189,9 @@ Does not backport Java 8 APIs.\n Backporting default methods and static methods on interfaces requires all\n backported interfaces and all classes which implement them or call their\n static methods to be backported together, with one execution of\n-Retrolambda.\n+Retrolambda. In other words, you must *always do a clean build*. Also,\n+backporting default methods won't work across module or dependency\n+boundaries.\n \n May break if a future JDK 8 build stops generating a new class for each\n `invokedynamic` call. Retrolambda works so that it captures the bytecode\n"
    },
    {
        "commit_hash": "651233803be0d20fca20e71b0ec317d77c037eae",
        "previous_commit_hash": "332747e0291fb8c91eb46d38abb6f17e5ac3fcba",
        "diff_stats": {
            "additions": 0,
            "deletions": 1
        },
        "diff_content": "@@ -24,7 +24,6 @@\n         <option name=\"WHILE_BRACE_FORCE\" value=\"3\" />\n         <option name=\"FOR_BRACE_FORCE\" value=\"3\" />\n         <option name=\"FIELD_ANNOTATION_WRAP\" value=\"0\" />\n-        <ClojureCodeStyleSettings />\n         <XML>\n           <option name=\"XML_LEGACY_SETTINGS_IMPORTED\" value=\"true\" />\n         </XML>\n"
    },
    {
        "commit_hash": "651233803be0d20fca20e71b0ec317d77c037eae",
        "previous_commit_hash": "332747e0291fb8c91eb46d38abb6f17e5ac3fcba",
        "diff_stats": {
            "additions": 6,
            "deletions": 0
        },
        "diff_content": "@@ -202,6 +202,12 @@ optimizations to that mechanism may break Retrolambda.\n Version History\n ---------------\n \n+### Upcoming\n+\n+- Fixed not backporting lambda expressions in default methods and static\n+  methods on interfaces\n+  ([Issue #48](https://github.com/orfjackal/retrolambda/issues/48))\n+\n ### Retrolambda 2.0.0 (2015-03-28)\n \n - Backports default methods and static methods on interfaces\n"
    },
    {
        "commit_hash": "651233803be0d20fca20e71b0ec317d77c037eae",
        "previous_commit_hash": "332747e0291fb8c91eb46d38abb6f17e5ac3fcba",
        "diff_stats": {
            "additions": 14,
            "deletions": 0
        },
        "diff_content": "@@ -11,6 +11,7 @@ import org.junit.rules.ExpectedException;\n \n import java.lang.annotation.*;\n import java.util.*;\n+import java.util.concurrent.Callable;\n \n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.*;\n@@ -439,6 +440,19 @@ public class DefaultMethodsTest {\n         assertThat(lambda.callsFoo(), is(12));\n     }\n \n+    @Test\n+    public void default_methods_with_lambdas() throws Exception {\n+        UsesLambdas obj = new UsesLambdas() {\n+        };\n+        assertThat(obj.foo().call(), is(\"foo\"));\n+    }\n+\n+    private interface UsesLambdas {\n+        default Callable<String> foo() {\n+            return () -> \"foo\";\n+        }\n+    }\n+\n \n     /**\n      * We're unable to backport default methods if we cannot modify the interface,\n"
    },
    {
        "commit_hash": "651233803be0d20fca20e71b0ec317d77c037eae",
        "previous_commit_hash": "332747e0291fb8c91eb46d38abb6f17e5ac3fcba",
        "diff_stats": {
            "additions": 11,
            "deletions": 1
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -32,6 +32,11 @@ public class InterfaceStaticMethodsTest {\n         assertThat(Interface.staticMethodWithArgs(\"a\", 1, 2L), is(\"a12\"));\n     }\n \n+    @Test\n+    public void static_methods_on_interfaces_containing_lambdas() throws Exception {\n+        assertThat(Interface.staticMethodContainingLambdas(), is(123));\n+    }\n+\n     @Test\n     public void calling_static_methods_on_interfaces_from_default_methods() {\n         Interface obj = new Interface() {\n@@ -64,6 +69,11 @@ public class InterfaceStaticMethodsTest {\n         static String staticMethodWithArgs(String s, int a, long b) {\n             return s + a + b;\n         }\n+\n+        static int staticMethodContainingLambdas() throws Exception {\n+            Callable<Integer> lambda = () -> 123;\n+            return lambda.call();\n+        }\n     }\n \n     /**\n"
    },
    {
        "commit_hash": "651233803be0d20fca20e71b0ec317d77c037eae",
        "previous_commit_hash": "332747e0291fb8c91eb46d38abb6f17e5ac3fcba",
        "diff_stats": {
            "additions": 3,
            "deletions": 0
        },
        "diff_content": "@@ -78,6 +78,9 @@ public class Transformers {\n         return transform(reader, (next) -> {\n             next = new UpdateRelocatedMethodInvocations(next, analyzer);\n             next = new ExtractInterfaceCompanionClass(next, companion.get());\n+            // XXX: We call BackportLambdaInvocations twice on the same interface (in backportInterface and extractInterfaceCompanion)\n+            // - is this a problem, because it tries to load the lambda class twice?\n+            next = new BackportLambdaInvocations(next);\n             return next;\n         });\n     }\n"
    },
    {
        "commit_hash": "0458b48eb59da36aeaeb057257923949081799f0",
        "previous_commit_hash": "651233803be0d20fca20e71b0ec317d77c037eae",
        "diff_stats": {
            "additions": 11,
            "deletions": 0
        },
        "diff_content": "@@ -447,10 +447,21 @@ public class DefaultMethodsTest {\n         assertThat(obj.foo().call(), is(\"foo\"));\n     }\n \n+    @Test\n+    public void default_methods_with_lambdas_that_capture_this() throws Exception {\n+        UsesLambdas obj = new UsesLambdas() {\n+        };\n+        assertThat(obj.captureThis().call(), is(\"foo\"));\n+    }\n+\n     private interface UsesLambdas {\n         default Callable<String> foo() {\n             return () -> \"foo\";\n         }\n+\n+        default Callable<String> captureThis() {\n+            return () -> foo().call();\n+        }\n     }\n \n \n"
    },
    {
        "commit_hash": "0458b48eb59da36aeaeb057257923949081799f0",
        "previous_commit_hash": "651233803be0d20fca20e71b0ec317d77c037eae",
        "diff_stats": {
            "additions": 6,
            "deletions": 7
        },
        "diff_content": "@@ -38,13 +38,12 @@ public class ExtractInterfaceCompanionClass extends ClassVisitor {\n             // we won't copy constant fields from the interface, so a class initializer won't be needed\n             return null;\n         }\n-        if (Flags.hasFlag(access, ACC_STATIC)\n-                && Flags.hasFlag(access, ACC_PRIVATE)) {\n-            // XXX: Possibly a lambda impl method, which is private. It is the easiest for us to make it visible,\n-            // which should be quite safe because static methods are not inherited (and anyways nothing inherits\n-            // the companion class). The clean solution would be to generate an access method for it, but due to\n-            // the location in code which generates those access methods, it would require complex code changes to\n-            // pass around the information from one transformation to another.\n+        if (Flags.hasFlag(access, ACC_PRIVATE)) {\n+            // XXX: Possibly a lambda impl method, which is private (static or instance). It is the easiest for us\n+            // to make it visible, which should be quite safe because nothing inherits the companion class.\n+            // The clean solution would be to generate an access method for it, but due to the location in code\n+            // which generates those access methods, it would require complex code changes to pass around the\n+            // information from one transformation to another.\n             access &= ~ACC_PRIVATE;\n         }\n         if (!Flags.hasFlag(access, ACC_STATIC)) {\n"
    },
    {
        "commit_hash": "0458b48eb59da36aeaeb057257923949081799f0",
        "previous_commit_hash": "651233803be0d20fca20e71b0ec317d77c037eae",
        "diff_stats": {
            "additions": 9,
            "deletions": 1
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -18,6 +18,9 @@ public class RemoveDefaultMethodBodies extends ClassVisitor {\n \n     @Override\n     public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+        if (isPrivateInstanceMethod(access)) { // lambda impl methods which capture `this` are private instance methods\n+            return null;\n+        }\n         if (isDefaultMethod(access)) {\n             MethodVisitor next = super.visitMethod(access | ACC_ABSTRACT, name, desc, signature, exceptions);\n             return new RemoveMethodBody(next, access, name, desc, signature, exceptions);\n@@ -26,6 +29,11 @@ public class RemoveDefaultMethodBodies extends ClassVisitor {\n         }\n     }\n \n+    private static boolean isPrivateInstanceMethod(int access) {\n+        return Flags.hasFlag(access, ACC_PRIVATE)\n+                && !Flags.hasFlag(access, ACC_STATIC);\n+    }\n+\n     private static boolean isDefaultMethod(int access) {\n         return !Flags.hasFlag(access, ACC_ABSTRACT)\n                 && !Flags.hasFlag(access, ACC_STATIC);\n"
    },
    {
        "commit_hash": "9c8d9487b3e13c2bb600cb08f1c315be7b06803c",
        "previous_commit_hash": "0458b48eb59da36aeaeb057257923949081799f0",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -45,7 +45,7 @@ To run Retrolambda using Maven, add the following to your pom.xml:\n <plugin>\n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>retrolambda-maven-plugin</artifactId>\n-    <version>2.0.0</version>\n+    <version>2.0.1</version>\n     <executions>\n         <execution>\n             <goals>\n@@ -202,7 +202,7 @@ optimizations to that mechanism may break Retrolambda.\n Version History\n ---------------\n \n-### Upcoming\n+### Retrolambda 2.0.1 (2015-04-06)\n \n - Fixed not backporting lambda expressions in default methods and static\n   methods on interfaces\n"
    },
    {
        "commit_hash": "9c8d9487b3e13c2bb600cb08f1c315be7b06803c",
        "previous_commit_hash": "0458b48eb59da36aeaeb057257923949081799f0",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.1-SNAPSHOT</version>\n+        <version>2.0.1</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "9c8d9487b3e13c2bb600cb08f1c315be7b06803c",
        "previous_commit_hash": "0458b48eb59da36aeaeb057257923949081799f0",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>2.0.1-SNAPSHOT</version>\n+    <version>2.0.1</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "9c8d9487b3e13c2bb600cb08f1c315be7b06803c",
        "previous_commit_hash": "0458b48eb59da36aeaeb057257923949081799f0",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.1-SNAPSHOT</version>\n+        <version>2.0.1</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "9c8d9487b3e13c2bb600cb08f1c315be7b06803c",
        "previous_commit_hash": "0458b48eb59da36aeaeb057257923949081799f0",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.1-SNAPSHOT</version>\n+        <version>2.0.1</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "9c8d9487b3e13c2bb600cb08f1c315be7b06803c",
        "previous_commit_hash": "0458b48eb59da36aeaeb057257923949081799f0",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.1-SNAPSHOT</version>\n+        <version>2.0.1</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "e0a18a03f61c5fbc5235425a287f21c9bfc8439c",
        "previous_commit_hash": "9c8d9487b3e13c2bb600cb08f1c315be7b06803c",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.1</version>\n+        <version>2.0.2-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "e0a18a03f61c5fbc5235425a287f21c9bfc8439c",
        "previous_commit_hash": "9c8d9487b3e13c2bb600cb08f1c315be7b06803c",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>2.0.1</version>\n+    <version>2.0.2-SNAPSHOT</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "e0a18a03f61c5fbc5235425a287f21c9bfc8439c",
        "previous_commit_hash": "9c8d9487b3e13c2bb600cb08f1c315be7b06803c",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.1</version>\n+        <version>2.0.2-SNAPSHOT</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "e0a18a03f61c5fbc5235425a287f21c9bfc8439c",
        "previous_commit_hash": "9c8d9487b3e13c2bb600cb08f1c315be7b06803c",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.1</version>\n+        <version>2.0.2-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "e0a18a03f61c5fbc5235425a287f21c9bfc8439c",
        "previous_commit_hash": "9c8d9487b3e13c2bb600cb08f1c315be7b06803c",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.1</version>\n+        <version>2.0.2-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "ead4b7509ea61810a694b341d3978a55b5a12626",
        "previous_commit_hash": "e0a18a03f61c5fbc5235425a287f21c9bfc8439c",
        "diff_stats": {
            "additions": 7,
            "deletions": 0
        },
        "diff_content": "@@ -202,6 +202,13 @@ optimizations to that mechanism may break Retrolambda.\n Version History\n ---------------\n \n+### Upcoming\n+\n+- Removes generic method signatures from the default method implementation\n+  methods which are placed in the interface's companion class, to avoid\n+  them getting out of sync with their erased method descriptors\n+  ([Issue #48](https://github.com/orfjackal/retrolambda/issues/48))\n+\n ### Retrolambda 2.0.1 (2015-04-06)\n \n - Fixed not backporting lambda expressions in default methods and static\n"
    },
    {
        "commit_hash": "ead4b7509ea61810a694b341d3978a55b5a12626",
        "previous_commit_hash": "e0a18a03f61c5fbc5235425a287f21c9bfc8439c",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -51,6 +51,7 @@ public class ExtractInterfaceCompanionClass extends ClassVisitor {\n             access |= ACC_STATIC;\n             // TODO: this adding of the first argument is duplicated in ClassHierarchyAnalyzer\n             desc = Bytecode.prependArgumentType(desc, Type.getObjectType(interfaceName));\n+            signature = null; // XXX: we should prepend the argument type also to the generic signature, but removing generics is easier\n         }\n         return super.visitMethod(access, name, desc, signature, exceptions);\n     }\n"
    },
    {
        "commit_hash": "f0ad5a805c80578edda363eeb32e99ef40620e76",
        "previous_commit_hash": "ead4b7509ea61810a694b341d3978a55b5a12626",
        "diff_stats": {
            "additions": 3,
            "deletions": 0
        },
        "diff_content": "@@ -204,6 +204,9 @@ Version History\n \n ### Upcoming\n \n+- Fixed a hack which caused lambdas in interfaces to be backported twice,\n+  possibly producing broken method calls in the bytecode\n+  ([Issue #48](https://github.com/orfjackal/retrolambda/issues/48))\n - Removes generic method signatures from the default method implementation\n   methods which are placed in the interface's companion class, to avoid\n   them getting out of sync with their erased method descriptors\n"
    },
    {
        "commit_hash": "f0ad5a805c80578edda363eeb32e99ef40620e76",
        "previous_commit_hash": "ead4b7509ea61810a694b341d3978a55b5a12626",
        "diff_stats": {
            "additions": 1,
            "deletions": 2
        },
        "diff_content": "@@ -66,8 +66,7 @@ public class Retrolambda {\n \n             List<byte[]> transformed = new ArrayList<>();\n             for (ClassInfo c : interfaces) {\n-                transformed.add(transformers.extractInterfaceCompanion(c.reader));\n-                transformed.add(transformers.backportInterface(c.reader));\n+                transformed.addAll(transformers.backportInterface(c.reader));\n             }\n             for (ClassInfo c : classes) {\n                 transformed.add(transformers.backportClass(c.reader));\n"
    },
    {
        "commit_hash": "f0ad5a805c80578edda363eeb32e99ef40620e76",
        "previous_commit_hash": "ead4b7509ea61810a694b341d3978a55b5a12626",
        "diff_stats": {
            "additions": 21,
            "deletions": 10
        },
        "diff_content": "@@ -9,7 +9,7 @@ import net.orfjackal.retrolambda.lambdas.*;\n import net.orfjackal.retrolambda.trywithresources.SwallowSuppressedExceptions;\n import org.objectweb.asm.*;\n \n-import java.util.Optional;\n+import java.util.*;\n \n public class Transformers {\n \n@@ -51,7 +51,22 @@ public class Transformers {\n         });\n     }\n \n-    public byte[] backportInterface(ClassReader reader) {\n+    public List<byte[]> backportInterface(ClassReader reader) {\n+        // The lambdas must be backported only once, because bad things will happen if a lambda\n+        // is called by different class name in the interface and its companion class, and then\n+        // the wrong one of them is written to disk last.\n+        byte[] lambdasBackported = transform(reader, (next) -> {\n+            next = new BackportLambdaInvocations(next);\n+            return next;\n+        });\n+\n+        List<byte[]> results = new ArrayList<>();\n+        results.add(backportInterface2(new ClassReader(lambdasBackported)));\n+        results.addAll(extractInterfaceCompanion(new ClassReader(lambdasBackported)));\n+        return results;\n+    }\n+\n+    private byte[] backportInterface2(ClassReader reader) {\n         return transform(reader, (next) -> {\n             if (defaultMethodsEnabled) {\n                 next = new RemoveStaticMethods(next);\n@@ -65,24 +80,20 @@ public class Transformers {\n                 next = new WarnAboutDefaultAndStaticMethods(next);\n             }\n             next = new RemoveBridgeMethods(next);\n-            next = new BackportLambdaInvocations(next);\n             return next;\n         });\n     }\n \n-    public byte[] extractInterfaceCompanion(ClassReader reader) {\n+    private List<byte[]> extractInterfaceCompanion(ClassReader reader) {\n         Optional<Type> companion = analyzer.getCompanionClass(Type.getObjectType(reader.getClassName()));\n         if (!companion.isPresent()) {\n-            return null;\n+            return Collections.emptyList();\n         }\n-        return transform(reader, (next) -> {\n+        return Arrays.asList(transform(reader, (next) -> {\n             next = new UpdateRelocatedMethodInvocations(next, analyzer);\n             next = new ExtractInterfaceCompanionClass(next, companion.get());\n-            // XXX: We call BackportLambdaInvocations twice on the same interface (in backportInterface and extractInterfaceCompanion)\n-            // - is this a problem, because it tries to load the lambda class twice?\n-            next = new BackportLambdaInvocations(next);\n             return next;\n-        });\n+        }));\n     }\n \n     private byte[] transform(ClassReader reader, ClassVisitorChain chain) {\n"
    },
    {
        "commit_hash": "fe6c8e51b4d0a3241801d14397edff8a03d76e39",
        "previous_commit_hash": "f0ad5a805c80578edda363eeb32e99ef40620e76",
        "diff_stats": {
            "additions": 20,
            "deletions": 3
        },
        "diff_content": "@@ -4,6 +4,7 @@\n \n package net.orfjackal.retrolambda.test;\n \n+import net.orfjackal.retrolambda.test.anotherpackage.UsesLambdasInAnotherPackage;\n import org.apache.commons.lang.SystemUtils;\n import org.hamcrest.*;\n import org.junit.*;\n@@ -444,7 +445,7 @@ public class DefaultMethodsTest {\n     public void default_methods_with_lambdas() throws Exception {\n         UsesLambdas obj = new UsesLambdas() {\n         };\n-        assertThat(obj.foo().call(), is(\"foo\"));\n+        assertThat(obj.stateless().call(), is(\"foo\"));\n     }\n \n     @Test\n@@ -455,15 +456,31 @@ public class DefaultMethodsTest {\n     }\n \n     private interface UsesLambdas {\n-        default Callable<String> foo() {\n+        default Callable<String> stateless() {\n             return () -> \"foo\";\n         }\n \n         default Callable<String> captureThis() {\n-            return () -> foo().call();\n+            return () -> stateless().call();\n         }\n     }\n \n+    /**\n+     * Lambdas which capture this in default methods will generate the lambda implementation\n+     * method as a private <em>instance</em> method. We must avoid copying those methods to\n+     * the interface implementers as if they were default methods.\n+     */\n+    @Test\n+    public void default_methods_with_lambdas_in_another_package() throws Exception {\n+        System.out.println(\"DefaultMethodsTest.default_methods_with_lambdas_in_another_package\");\n+        UsesLambdasInAnotherPackage obj = new UsesLambdasInAnotherPackage() {\n+        };\n+        assertThat(obj.stateless().call(), is(\"foo\"));\n+        assertThat(obj.captureThis().call(), is(\"foo\"));\n+        assertThat(\"should contain only delegates to the two default methods\",\n+                obj.getClass().getDeclaredMethods(), arrayWithSize(2));\n+    }\n+\n \n     /**\n      * We're unable to backport default methods if we cannot modify the interface,\n"
    },
    {
        "commit_hash": "fe6c8e51b4d0a3241801d14397edff8a03d76e39",
        "previous_commit_hash": "f0ad5a805c80578edda363eeb32e99ef40620e76",
        "diff_stats": {
            "additions": 18,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,18 @@\n+// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.test.anotherpackage;\n+\n+import java.util.concurrent.Callable;\n+\n+public interface UsesLambdasInAnotherPackage {\n+\n+    default Callable<String> stateless() {\n+        return () -> \"foo\";\n+    }\n+\n+    default Callable<String> captureThis() {\n+        return () -> stateless().call();\n+    }\n+}\n"
    },
    {
        "commit_hash": "8ce0fff0811efbc41beda50d6ade8cf556a27d4a",
        "previous_commit_hash": "fe6c8e51b4d0a3241801d14397edff8a03d76e39",
        "diff_stats": {
            "additions": 20,
            "deletions": 1
        },
        "diff_content": "@@ -76,6 +76,10 @@ public class ClassHierarchyAnalyzer {\n                     c.enableCompanionClass();\n                     c.addMethod(method, new MethodKind.Default(defaultImpl));\n \n+                } else if (isInstanceLambdaImplMethod(access)) {\n+                    relocatedMethods.put(method, new MethodRef(companion, name, Bytecode.prependArgumentType(desc, Type.getObjectType(owner))));\n+                    c.enableCompanionClass();\n+\n                 } else if (isStaticMethod(access)) {\n                     relocatedMethods.put(method, new MethodRef(companion, name, desc));\n                     c.enableCompanionClass();\n@@ -99,7 +103,22 @@ public class ClassHierarchyAnalyzer {\n \n     private static boolean isDefaultMethod(int access) {\n         return !isAbstractMethod(access)\n-                && !isStaticMethod(access);\n+                && !isStaticMethod(access)\n+                && isPublicMethod(access);\n+    }\n+\n+    private static boolean isInstanceLambdaImplMethod(int access) {\n+        return !isAbstractMethod(access)\n+                && !isStaticMethod(access)\n+                && isPrivateMethod(access);\n+    }\n+\n+    private static boolean isPublicMethod(int access) {\n+        return Flags.hasFlag(access, ACC_PUBLIC);\n+    }\n+\n+    private static boolean isPrivateMethod(int access) {\n+        return Flags.hasFlag(access, ACC_PRIVATE);\n     }\n \n     public List<ClassInfo> getInterfaces() {\n"
    },
    {
        "commit_hash": "8ce0fff0811efbc41beda50d6ade8cf556a27d4a",
        "previous_commit_hash": "fe6c8e51b4d0a3241801d14397edff8a03d76e39",
        "diff_stats": {
            "additions": 3,
            "deletions": 0
        },
        "diff_content": "@@ -40,6 +40,9 @@ public class UpdateRelocatedMethodInvocations extends ClassVisitor {\n                     opcode = Opcodes.INVOKESTATIC;\n                     method = impl;\n                 }\n+                if (name.startsWith(\"lambda$captureThis$\")) { // FIXME: remove me\n+                    opcode = Opcodes.INVOKESTATIC;\n+                }\n             }\n \n             method = analyzer.getMethodCallTarget(method);\n"
    },
    {
        "commit_hash": "8ce0fff0811efbc41beda50d6ade8cf556a27d4a",
        "previous_commit_hash": "fe6c8e51b4d0a3241801d14397edff8a03d76e39",
        "diff_stats": {
            "additions": 33,
            "deletions": 0
        },
        "diff_content": "@@ -11,6 +11,7 @@ import org.objectweb.asm.Type;\n \n import java.io.*;\n import java.util.*;\n+import java.util.concurrent.Callable;\n import java.util.stream.Stream;\n \n import static java.util.Arrays.asList;\n@@ -357,6 +358,38 @@ public class ClassHierarchyAnalyzerTest {\n     }\n \n \n+    @Test\n+    public void default_methods_with_lambdas() {\n+        analyze(UsesLambdas.class,\n+                ImplementsUsesLambdas.class);\n+\n+        MethodInfo stateless = new MethodInfo(\"stateless\", \"()Ljava/util/concurrent/Callable;\", UsesLambdas.class, new MethodKind.Default(\n+                new MethodRef(UsesLambdas$.class, \"stateless\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$UsesLambdas;)Ljava/util/concurrent/Callable;\")));\n+        MethodInfo captureThis = new MethodInfo(\"captureThis\", \"()Ljava/util/concurrent/Callable;\", UsesLambdas.class, new MethodKind.Default(\n+                new MethodRef(UsesLambdas$.class, \"captureThis\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$UsesLambdas;)Ljava/util/concurrent/Callable;\")));\n+\n+        assertThat(\"does not copy instance lambda impl methods to implementers\",\n+                analyzer.getMethods(Type.getType(ImplementsUsesLambdas.class)),\n+                containsInAnyOrder(stateless, captureThis));\n+    }\n+\n+    private interface UsesLambdas {\n+        default Callable<String> stateless() {\n+            return () -> \"foo\";\n+        }\n+\n+        default Callable<String> captureThis() {\n+            return () -> stateless().call();\n+        }\n+    }\n+\n+    private interface UsesLambdas$ {\n+    }\n+\n+    private class ImplementsUsesLambdas implements UsesLambdas {\n+    }\n+\n+\n     // Method relocations\n \n     @Test\n"
    },
    {
        "commit_hash": "7146fa7c03b7dade4e46ec59c2fa88bff5e6684d",
        "previous_commit_hash": "8ce0fff0811efbc41beda50d6ade8cf556a27d4a",
        "diff_stats": {
            "additions": 3,
            "deletions": 0
        },
        "diff_content": "@@ -207,6 +207,9 @@ Version History\n - Fixed a hack which caused lambdas in interfaces to be backported twice,\n   possibly producing broken method calls in the bytecode\n   ([Issue #48](https://github.com/orfjackal/retrolambda/issues/48))\n+- Fixed the handling of non-static lambda implementation methods in\n+  interfaces, i.e. lambdas which capture `this`\n+  ([Issue #48](https://github.com/orfjackal/retrolambda/issues/48))\n - Removes generic method signatures from the default method implementation\n   methods which are placed in the interface's companion class, to avoid\n   them getting out of sync with their erased method descriptors\n"
    },
    {
        "commit_hash": "7146fa7c03b7dade4e46ec59c2fa88bff5e6684d",
        "previous_commit_hash": "8ce0fff0811efbc41beda50d6ade8cf556a27d4a",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -30,8 +30,8 @@ public class AddMethodDefaultImplementations extends ClassVisitor {\n         for (MethodInfo method : analyzer.getDefaultMethods(Type.getObjectType(className))) {\n             Bytecode.generateDelegateMethod(cv,\n                     ACC_PUBLIC | ACC_SYNTHETIC,\n-                    method.toMethodRef().toHandle(H_INVOKEVIRTUAL),\n-                    method.getDefaultMethodImpl().toHandle(H_INVOKESTATIC));\n+                    method.toMethodRef().toHandle(),\n+                    method.getDefaultMethodImpl().toHandle());\n         }\n         super.visitEnd();\n     }\n"
    },
    {
        "commit_hash": "7146fa7c03b7dade4e46ec59c2fa88bff5e6684d",
        "previous_commit_hash": "8ce0fff0811efbc41beda50d6ade8cf556a27d4a",
        "diff_stats": {
            "additions": 13,
            "deletions": 5
        },
        "diff_content": "@@ -4,6 +4,7 @@\n \n package net.orfjackal.retrolambda.interfaces;\n \n+import net.orfjackal.retrolambda.lambdas.Handles;\n import net.orfjackal.retrolambda.util.*;\n import org.objectweb.asm.*;\n \n@@ -46,7 +47,7 @@ public class ClassHierarchyAnalyzer {\n                 if (isConstructor(name) || isStaticMethod(access)) {\n                     return null;\n                 }\n-                c.addMethod(new MethodRef(owner, name, desc), new MethodKind.Implemented());\n+                c.addMethod(new MethodRef(H_INVOKEVIRTUAL, owner, name, desc), new MethodKind.Implemented());\n                 return null;\n             }\n \n@@ -66,22 +67,22 @@ public class ClassHierarchyAnalyzer {\n \n             @Override\n             public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n-                MethodRef method = new MethodRef(owner, name, desc);\n+                MethodRef method = new MethodRef(Handles.accessToTag(access, true), owner, name, desc);\n \n                 if (isAbstractMethod(access)) {\n                     c.addMethod(method, new MethodKind.Abstract());\n \n                 } else if (isDefaultMethod(access)) {\n-                    MethodRef defaultImpl = new MethodRef(companion, name, Bytecode.prependArgumentType(desc, Type.getObjectType(owner)));\n+                    MethodRef defaultImpl = new MethodRef(H_INVOKESTATIC, companion, name, Bytecode.prependArgumentType(desc, Type.getObjectType(owner)));\n                     c.enableCompanionClass();\n                     c.addMethod(method, new MethodKind.Default(defaultImpl));\n \n                 } else if (isInstanceLambdaImplMethod(access)) {\n-                    relocatedMethods.put(method, new MethodRef(companion, name, Bytecode.prependArgumentType(desc, Type.getObjectType(owner))));\n+                    relocatedMethods.put(method, new MethodRef(H_INVOKESTATIC, companion, name, Bytecode.prependArgumentType(desc, Type.getObjectType(owner))));\n                     c.enableCompanionClass();\n \n                 } else if (isStaticMethod(access)) {\n-                    relocatedMethods.put(method, new MethodRef(companion, name, desc));\n+                    relocatedMethods.put(method, new MethodRef(H_INVOKESTATIC, companion, name, desc));\n                     c.enableCompanionClass();\n                 }\n                 return null;\n@@ -140,6 +141,13 @@ public class ClassHierarchyAnalyzer {\n     }\n \n     public MethodRef getMethodCallTarget(MethodRef original) {\n+        if (original.tag == H_INVOKESPECIAL) {\n+            // change Interface.super.defaultMethod() calls to static calls on the companion class\n+            MethodRef impl = getMethodDefaultImplementation(original);\n+            if (impl != null) {\n+                return impl;\n+            }\n+        }\n         return relocatedMethods.getOrDefault(original, original);\n     }\n \n"
    },
    {
        "commit_hash": "7146fa7c03b7dade4e46ec59c2fa88bff5e6684d",
        "previous_commit_hash": "8ce0fff0811efbc41beda50d6ade8cf556a27d4a",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -47,7 +47,7 @@ public class ClassInfo {\n     }\n \n     public void addMethod(MethodRef method, MethodKind kind) {\n-        methods.add(new MethodInfo(method.getSignature(), Type.getObjectType(method.owner), kind));\n+        methods.add(new MethodInfo(method.tag, method.getSignature(), Type.getObjectType(method.owner), kind));\n     }\n \n     public Optional<Type> getCompanionClass() {\n"
    },
    {
        "commit_hash": "7146fa7c03b7dade4e46ec59c2fa88bff5e6684d",
        "previous_commit_hash": "8ce0fff0811efbc41beda50d6ade8cf556a27d4a",
        "diff_stats": {
            "additions": 8,
            "deletions": 4
        },
        "diff_content": "@@ -11,15 +11,17 @@ import java.util.Objects;\n \n public class MethodInfo {\n \n+    public final int tag;\n     public final MethodSignature signature;\n     public final Type owner;\n     public final MethodKind kind;\n \n-    public MethodInfo(String name, String desc, Class<?> owner, MethodKind kind) {\n-        this(new MethodSignature(name, desc), Type.getType(owner), kind);\n+    public MethodInfo(String name, String desc, Class<?> owner, MethodKind kind) { // only for tests, so we can ignore the tag\n+        this(-1, new MethodSignature(name, desc), Type.getType(owner), kind);\n     }\n \n-    public MethodInfo(MethodSignature signature, Type owner, MethodKind kind) {\n+    public MethodInfo(int tag, MethodSignature signature, Type owner, MethodKind kind) {\n+        this.tag = tag;\n         this.signature = signature;\n         this.owner = owner;\n         this.kind = kind;\n@@ -30,7 +32,7 @@ public class MethodInfo {\n     }\n \n     public MethodRef toMethodRef() {\n-        return new MethodRef(owner.getInternalName(), signature.name, signature.desc);\n+        return new MethodRef(tag, owner.getInternalName(), signature.name, signature.desc);\n     }\n \n     @Override\n@@ -38,6 +40,7 @@ public class MethodInfo {\n         if (!(obj instanceof MethodInfo)) {\n             return false;\n         }\n+        // NOTE: the tag does not not affect method equality, because e.g. super calls have different tag but same method\n         MethodInfo that = (MethodInfo) obj;\n         return this.signature.equals(that.signature)\n                 && this.owner.equals(that.owner)\n@@ -55,6 +58,7 @@ public class MethodInfo {\n                 .addValue(signature)\n                 .addValue(owner)\n                 .addValue(kind)\n+                .addValue(\"(\" + tag + \")\")\n                 .toString();\n     }\n }\n"
    },
    {
        "commit_hash": "7146fa7c03b7dade4e46ec59c2fa88bff5e6684d",
        "previous_commit_hash": "8ce0fff0811efbc41beda50d6ade8cf556a27d4a",
        "diff_stats": {
            "additions": 13,
            "deletions": 4
        },
        "diff_content": "@@ -5,6 +5,7 @@\n package net.orfjackal.retrolambda.interfaces;\n \n import com.google.common.base.MoreObjects;\n+import net.orfjackal.retrolambda.lambdas.Handles;\n import org.objectweb.asm.*;\n \n import java.util.Objects;\n@@ -13,15 +14,17 @@ public final class MethodRef {\n \n     // TODO: replace MethodRef with ASM's Handle, or merge with MethodInfo?\n \n+    public final int tag;\n     public final String owner;\n     public final String name;\n     public final String desc;\n \n-    public MethodRef(Class<?> owner, String name, String desc) {\n-        this(Type.getInternalName(owner), name, desc);\n+    public MethodRef(int tag, Class<?> owner, String name, String desc) {\n+        this(tag, Type.getInternalName(owner), name, desc);\n     }\n \n-    public MethodRef(String owner, String name, String desc) {\n+    public MethodRef(int tag, String owner, String name, String desc) {\n+        this.tag = tag;\n         this.owner = owner;\n         this.name = name;\n         this.desc = desc;\n@@ -31,7 +34,11 @@ public final class MethodRef {\n         return new MethodSignature(name, desc);\n     }\n \n-    public Handle toHandle(int tag) {\n+    public int getOpcode() {\n+        return Handles.getOpcode(toHandle());\n+    }\n+\n+    public Handle toHandle() {\n         return new Handle(tag, owner, name, desc);\n     }\n \n@@ -40,6 +47,7 @@ public final class MethodRef {\n         if (!(obj instanceof MethodRef)) {\n             return false;\n         }\n+        // NOTE: the tag does not not affect method equality, because e.g. super calls have different tag but same method\n         MethodRef that = (MethodRef) obj;\n         return this.owner.equals(that.owner)\n                 && this.name.equals(that.name)\n@@ -57,6 +65,7 @@ public final class MethodRef {\n                 .addValue(owner)\n                 .addValue(name)\n                 .addValue(desc)\n+                .addValue(\"(\" + tag + \")\")\n                 .toString();\n     }\n }\n"
    },
    {
        "commit_hash": "7146fa7c03b7dade4e46ec59c2fa88bff5e6684d",
        "previous_commit_hash": "8ce0fff0811efbc41beda50d6ade8cf556a27d4a",
        "diff_stats": {
            "additions": 3,
            "deletions": 16
        },
        "diff_content": "@@ -4,6 +4,7 @@\n \n package net.orfjackal.retrolambda.interfaces;\n \n+import net.orfjackal.retrolambda.lambdas.Handles;\n import org.objectweb.asm.*;\n \n import static org.objectweb.asm.Opcodes.ASM5;\n@@ -30,23 +31,9 @@ public class UpdateRelocatedMethodInvocations extends ClassVisitor {\n \n         @Override\n         public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\n-            MethodRef method = new MethodRef(owner, name, desc);\n-\n-            // change Interface.super.defaultMethod() calls to static calls on the companion class\n-            // TODO: move this inside getMethodCallTarget (also opcode, so must first change MethodRef to Handle)\n-            if (opcode == Opcodes.INVOKESPECIAL) {\n-                MethodRef impl = analyzer.getMethodDefaultImplementation(method);\n-                if (impl != null) {\n-                    opcode = Opcodes.INVOKESTATIC;\n-                    method = impl;\n-                }\n-                if (name.startsWith(\"lambda$captureThis$\")) { // FIXME: remove me\n-                    opcode = Opcodes.INVOKESTATIC;\n-                }\n-            }\n-\n+            MethodRef method = new MethodRef(Handles.opcodeToTag(opcode), owner, name, desc);\n             method = analyzer.getMethodCallTarget(method);\n-            super.visitMethodInsn(opcode, method.owner, method.name, method.desc, itf);\n+            super.visitMethodInsn(method.getOpcode(), method.owner, method.name, method.desc, itf);\n         }\n     }\n }\n"
    },
    {
        "commit_hash": "7146fa7c03b7dade4e46ec59c2fa88bff5e6684d",
        "previous_commit_hash": "8ce0fff0811efbc41beda50d6ade8cf556a27d4a",
        "diff_stats": {
            "additions": 31,
            "deletions": 1
        },
        "diff_content": "@@ -1,9 +1,10 @@\n-// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n package net.orfjackal.retrolambda.lambdas;\n \n+import net.orfjackal.retrolambda.util.Flags;\n import org.objectweb.asm.Handle;\n \n import static org.objectweb.asm.Opcodes.*;\n@@ -27,4 +28,33 @@ public class Handles {\n                 throw new IllegalArgumentException(\"Unsupported tag \" + tag + \" in \" + handle);\n         }\n     }\n+\n+    public static int opcodeToTag(int opcode) {\n+        switch (opcode) {\n+            case INVOKEVIRTUAL:\n+                return H_INVOKEVIRTUAL;\n+            case INVOKESTATIC:\n+                return H_INVOKESTATIC;\n+            case INVOKESPECIAL:\n+                return H_INVOKESPECIAL;\n+            case INVOKEINTERFACE:\n+                return H_INVOKEINTERFACE;\n+            default:\n+                throw new IllegalArgumentException(\"Unsupported opcode \" + opcode);\n+        }\n+    }\n+\n+    public static int accessToTag(int access, boolean itf) {\n+        if (Flags.hasFlag(access, ACC_STATIC)) {\n+            return H_INVOKESTATIC;\n+        }\n+        if (Flags.hasFlag(access, ACC_PRIVATE)) {\n+            return H_INVOKESPECIAL;\n+        }\n+        if (itf) {\n+            return H_INVOKEINTERFACE;\n+        } else {\n+            return H_INVOKEVIRTUAL;\n+        }\n+    }\n }\n"
    },
    {
        "commit_hash": "7146fa7c03b7dade4e46ec59c2fa88bff5e6684d",
        "previous_commit_hash": "8ce0fff0811efbc41beda50d6ade8cf556a27d4a",
        "diff_stats": {
            "additions": 26,
            "deletions": 25
        },
        "diff_content": "@@ -18,6 +18,7 @@ import static java.util.Arrays.asList;\n import static java.util.stream.Collectors.toList;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.*;\n+import static org.objectweb.asm.Opcodes.*;\n \n @SuppressWarnings(\"UnusedDeclaration\")\n public class ClassHierarchyAnalyzerTest {\n@@ -74,7 +75,7 @@ public class ClassHierarchyAnalyzerTest {\n                 containsInAnyOrder(\n                         new MethodInfo(\"abstractMethod\", \"()V\", InterfaceMethodTypes.class, new MethodKind.Abstract()),\n                         new MethodInfo(\"defaultMethod\", \"()V\", InterfaceMethodTypes.class, new MethodKind.Default(\n-                                new MethodRef(InterfaceMethodTypes$.class, \"defaultMethod\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$InterfaceMethodTypes;)V\")))));\n+                                new MethodRef(H_INVOKESTATIC, InterfaceMethodTypes$.class, \"defaultMethod\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$InterfaceMethodTypes;)V\")))));\n     }\n \n     @Test\n@@ -124,19 +125,19 @@ public class ClassHierarchyAnalyzerTest {\n                 containsInAnyOrder(\n                         new MethodInfo(\"abstractMethod\", \"()V\", HasDefaultMethods.class, new MethodKind.Abstract()),\n                         new MethodInfo(\"defaultMethod\", \"()V\", HasDefaultMethods.class, new MethodKind.Default(\n-                                new MethodRef(HasDefaultMethods$.class, \"defaultMethod\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$HasDefaultMethods;)V\")))));\n+                                new MethodRef(H_INVOKESTATIC, HasDefaultMethods$.class, \"defaultMethod\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$HasDefaultMethods;)V\")))));\n \n         assertThat(\"inherits unchanged\", analyzer.getMethods(Type.getType(DoesNotOverrideDefaultMethods.class)),\n                 containsInAnyOrder(\n                         new MethodInfo(\"abstractMethod\", \"()V\", HasDefaultMethods.class, new MethodKind.Abstract()),\n                         new MethodInfo(\"defaultMethod\", \"()V\", HasDefaultMethods.class, new MethodKind.Default(\n-                                new MethodRef(HasDefaultMethods$.class, \"defaultMethod\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$HasDefaultMethods;)V\")))));\n+                                new MethodRef(H_INVOKESTATIC, HasDefaultMethods$.class, \"defaultMethod\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$HasDefaultMethods;)V\")))));\n \n         assertThat(\"changes default impl\", analyzer.getMethods(Type.getType(OverridesDefaultMethods.class)),\n                 containsInAnyOrder(\n                         new MethodInfo(\"abstractMethod\", \"()V\", HasDefaultMethods.class, new MethodKind.Abstract()),\n                         new MethodInfo(\"defaultMethod\", \"()V\", OverridesDefaultMethods.class, new MethodKind.Default(\n-                                new MethodRef(OverridesDefaultMethods$.class, \"defaultMethod\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$OverridesDefaultMethods;)V\")))));\n+                                new MethodRef(H_INVOKESTATIC, OverridesDefaultMethods$.class, \"defaultMethod\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$OverridesDefaultMethods;)V\")))));\n \n         assertThat(\"makes abstract\", analyzer.getMethods(Type.getType(AbstractsDefaultMethods.class)),\n                 containsInAnyOrder(\n@@ -206,12 +207,12 @@ public class ClassHierarchyAnalyzerTest {\n         assertThat(\"original\", analyzer.getMethods(Type.getType(DefaultMethods.class)),\n                 containsInAnyOrder(\n                         new MethodInfo(\"foo\", \"()V\", DefaultMethods.class, new MethodKind.Default(\n-                                new MethodRef(DefaultMethods$.class, \"foo\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$DefaultMethods;)V\")))));\n+                                new MethodRef(H_INVOKESTATIC, DefaultMethods$.class, \"foo\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$DefaultMethods;)V\")))));\n \n         assertThat(\"inherits unchanged\", analyzer.getMethods(Type.getType(InheritsDefault.class)),\n                 containsInAnyOrder(\n                         new MethodInfo(\"foo\", \"()V\", DefaultMethods.class, new MethodKind.Default(\n-                                new MethodRef(DefaultMethods$.class, \"foo\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$DefaultMethods;)V\")))));\n+                                new MethodRef(H_INVOKESTATIC, DefaultMethods$.class, \"foo\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$DefaultMethods;)V\")))));\n \n         assertThat(\"overrides\", analyzer.getMethods(Type.getType(OverridesDefault.class)),\n                 containsInAnyOrder(\n@@ -260,9 +261,9 @@ public class ClassHierarchyAnalyzerTest {\n                 InheritsOriginalAndOverridden.class);\n \n         MethodInfo original = new MethodInfo(\"foo\", \"()V\", SuperOriginal.class, new MethodKind.Default(\n-                new MethodRef(SuperOriginal$.class, \"foo\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$SuperOriginal;)V\")));\n+                new MethodRef(H_INVOKESTATIC, SuperOriginal$.class, \"foo\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$SuperOriginal;)V\")));\n         MethodInfo overridden = new MethodInfo(\"foo\", \"()V\", SuperOverridden.class, new MethodKind.Default(\n-                new MethodRef(SuperOverridden$.class, \"foo\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$SuperOverridden;)V\")));\n+                new MethodRef(H_INVOKESTATIC, SuperOverridden$.class, \"foo\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$SuperOverridden;)V\")));\n \n         assertThat(\"inherits original\", analyzer.getMethods(Type.getType(InheritsOriginal.class)),\n                 containsInAnyOrder(original));\n@@ -314,9 +315,9 @@ public class ClassHierarchyAnalyzerTest {\n                 ExtendsImplementsOriginalAndImplementsOverriddenDefault.class);\n \n         MethodInfo original = new MethodInfo(\"foo\", \"()V\", OriginalDefault.class, new MethodKind.Default(\n-                new MethodRef(OriginalDefault$.class, \"foo\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$OriginalDefault;)V\")));\n+                new MethodRef(H_INVOKESTATIC, OriginalDefault$.class, \"foo\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$OriginalDefault;)V\")));\n         MethodInfo overridden = new MethodInfo(\"foo\", \"()V\", OverriddenDefault.class, new MethodKind.Default(\n-                new MethodRef(OverriddenDefault$.class, \"foo\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$OverriddenDefault;)V\")));\n+                new MethodRef(H_INVOKESTATIC, OverriddenDefault$.class, \"foo\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$OverriddenDefault;)V\")));\n \n         assertThat(\"implements original\", analyzer.getMethods(Type.getType(ImplementsOriginal.class)),\n                 containsInAnyOrder(original));\n@@ -364,9 +365,9 @@ public class ClassHierarchyAnalyzerTest {\n                 ImplementsUsesLambdas.class);\n \n         MethodInfo stateless = new MethodInfo(\"stateless\", \"()Ljava/util/concurrent/Callable;\", UsesLambdas.class, new MethodKind.Default(\n-                new MethodRef(UsesLambdas$.class, \"stateless\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$UsesLambdas;)Ljava/util/concurrent/Callable;\")));\n+                new MethodRef(H_INVOKESTATIC, UsesLambdas$.class, \"stateless\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$UsesLambdas;)Ljava/util/concurrent/Callable;\")));\n         MethodInfo captureThis = new MethodInfo(\"captureThis\", \"()Ljava/util/concurrent/Callable;\", UsesLambdas.class, new MethodKind.Default(\n-                new MethodRef(UsesLambdas$.class, \"captureThis\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$UsesLambdas;)Ljava/util/concurrent/Callable;\")));\n+                new MethodRef(H_INVOKESTATIC, UsesLambdas$.class, \"captureThis\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$UsesLambdas;)Ljava/util/concurrent/Callable;\")));\n \n         assertThat(\"does not copy instance lambda impl methods to implementers\",\n                 analyzer.getMethods(Type.getType(ImplementsUsesLambdas.class)),\n@@ -396,7 +397,7 @@ public class ClassHierarchyAnalyzerTest {\n     public void abstract_methods_on_interfaces_are_not_relocated() {\n         analyze(InterfaceMethodTypes.class);\n \n-        MethodRef source = new MethodRef(InterfaceMethodTypes.class, \"abstractMethod\", voidMethod());\n+        MethodRef source = new MethodRef(H_INVOKEINTERFACE, InterfaceMethodTypes.class, \"abstractMethod\", voidMethod());\n         MethodRef target = analyzer.getMethodCallTarget(source);\n \n         assertThat(target, is(source));\n@@ -406,7 +407,7 @@ public class ClassHierarchyAnalyzerTest {\n     public void default_methods_on_interfaces_are_not_relocated() {\n         analyze(InterfaceMethodTypes.class);\n \n-        MethodRef source = new MethodRef(InterfaceMethodTypes.class, \"defaultMethod\", voidMethod());\n+        MethodRef source = new MethodRef(H_INVOKEINTERFACE, InterfaceMethodTypes.class, \"defaultMethod\", voidMethod());\n         MethodRef target = analyzer.getMethodCallTarget(source);\n \n         assertThat(target, is(source));\n@@ -416,17 +417,17 @@ public class ClassHierarchyAnalyzerTest {\n     public void static_methods_on_interfaces_are_relocated_to_companion_classes() {\n         analyze(InterfaceMethodTypes.class);\n \n-        MethodRef source = new MethodRef(InterfaceMethodTypes.class, \"staticMethod\", voidMethod());\n+        MethodRef source = new MethodRef(H_INVOKESTATIC, InterfaceMethodTypes.class, \"staticMethod\", voidMethod());\n         MethodRef target = analyzer.getMethodCallTarget(source);\n \n-        assertThat(target, is(new MethodRef(InterfaceMethodTypes$.class, \"staticMethod\", voidMethod())));\n+        assertThat(target, is(new MethodRef(H_INVOKESTATIC, InterfaceMethodTypes$.class, \"staticMethod\", voidMethod())));\n     }\n \n     @Test\n     public void static_methods_on_classes_are_not_relocated() {\n         analyze(ClassMethodTypes.class);\n \n-        MethodRef source = new MethodRef(ClassMethodTypes.class, \"staticMethod\", voidMethod());\n+        MethodRef source = new MethodRef(H_INVOKESTATIC, ClassMethodTypes.class, \"staticMethod\", voidMethod());\n         MethodRef target = analyzer.getMethodCallTarget(source);\n \n         assertThat(target, is(source));\n@@ -439,7 +440,7 @@ public class ClassHierarchyAnalyzerTest {\n     public void abstract_methods_have_no_implementation() {\n         analyze(HasDefaultMethods.class);\n \n-        MethodRef method = new MethodRef(HasDefaultMethods.class, \"abstractMethod\", voidMethod());\n+        MethodRef method = new MethodRef(H_INVOKEINTERFACE, HasDefaultMethods.class, \"abstractMethod\", voidMethod());\n         MethodRef impl = analyzer.getMethodDefaultImplementation(method);\n \n         assertThat(impl, is(nullValue()));\n@@ -449,10 +450,10 @@ public class ClassHierarchyAnalyzerTest {\n     public void default_method_implementation_is_moved_to_companion_class() {\n         analyze(HasDefaultMethods.class);\n \n-        MethodRef method = new MethodRef(HasDefaultMethods.class, \"defaultMethod\", voidMethod());\n+        MethodRef method = new MethodRef(H_INVOKEINTERFACE, HasDefaultMethods.class, \"defaultMethod\", voidMethod());\n         MethodRef impl = analyzer.getMethodDefaultImplementation(method);\n \n-        assertThat(impl, is(new MethodRef(HasDefaultMethods$.class, \"defaultMethod\", voidMethod(HasDefaultMethods.class))));\n+        assertThat(impl, is(new MethodRef(H_INVOKESTATIC, HasDefaultMethods$.class, \"defaultMethod\", voidMethod(HasDefaultMethods.class))));\n     }\n \n     @Test\n@@ -460,10 +461,10 @@ public class ClassHierarchyAnalyzerTest {\n         analyze(HasDefaultMethods.class,\n                 DoesNotOverrideDefaultMethods.class);\n \n-        MethodRef method = new MethodRef(DoesNotOverrideDefaultMethods.class, \"defaultMethod\", voidMethod());\n+        MethodRef method = new MethodRef(H_INVOKEINTERFACE, DoesNotOverrideDefaultMethods.class, \"defaultMethod\", voidMethod());\n         MethodRef impl = analyzer.getMethodDefaultImplementation(method);\n \n-        assertThat(impl, is(new MethodRef(HasDefaultMethods$.class, \"defaultMethod\", voidMethod(HasDefaultMethods.class))));\n+        assertThat(impl, is(new MethodRef(H_INVOKESTATIC, HasDefaultMethods$.class, \"defaultMethod\", voidMethod(HasDefaultMethods.class))));\n     }\n \n     @Test\n@@ -471,10 +472,10 @@ public class ClassHierarchyAnalyzerTest {\n         analyze(HasDefaultMethods.class,\n                 OverridesDefaultMethods.class);\n \n-        MethodRef method = new MethodRef(OverridesDefaultMethods.class, \"defaultMethod\", voidMethod());\n+        MethodRef method = new MethodRef(H_INVOKEINTERFACE, OverridesDefaultMethods.class, \"defaultMethod\", voidMethod());\n         MethodRef impl = analyzer.getMethodDefaultImplementation(method);\n \n-        assertThat(impl, is(new MethodRef(OverridesDefaultMethods$.class, \"defaultMethod\", voidMethod(OverridesDefaultMethods.class))));\n+        assertThat(impl, is(new MethodRef(H_INVOKESTATIC, OverridesDefaultMethods$.class, \"defaultMethod\", voidMethod(OverridesDefaultMethods.class))));\n     }\n \n     @Test\n@@ -482,7 +483,7 @@ public class ClassHierarchyAnalyzerTest {\n         analyze(HasDefaultMethods.class,\n                 AbstractsDefaultMethods.class);\n \n-        MethodRef method = new MethodRef(AbstractsDefaultMethods.class, \"defaultMethod\", voidMethod());\n+        MethodRef method = new MethodRef(H_INVOKEINTERFACE, AbstractsDefaultMethods.class, \"defaultMethod\", voidMethod());\n         MethodRef impl = analyzer.getMethodDefaultImplementation(method);\n \n         assertThat(impl, is(nullValue()));\n"
    },
    {
        "commit_hash": "1952d2e1457f96478b80b7ea4cdf6d6db0a4193e",
        "previous_commit_hash": "7146fa7c03b7dade4e46ec59c2fa88bff5e6684d",
        "diff_stats": {
            "additions": 22,
            "deletions": 12
        },
        "diff_content": "@@ -8,8 +8,10 @@ import net.orfjackal.retrolambda.interfaces.*;\n import net.orfjackal.retrolambda.lambdas.*;\n import net.orfjackal.retrolambda.trywithresources.SwallowSuppressedExceptions;\n import org.objectweb.asm.*;\n+import org.objectweb.asm.tree.ClassNode;\n \n import java.util.*;\n+import java.util.function.Consumer;\n \n public class Transformers {\n \n@@ -55,19 +57,19 @@ public class Transformers {\n         // The lambdas must be backported only once, because bad things will happen if a lambda\n         // is called by different class name in the interface and its companion class, and then\n         // the wrong one of them is written to disk last.\n-        byte[] lambdasBackported = transform(reader, (next) -> {\n-            next = new BackportLambdaInvocations(next);\n-            return next;\n-        });\n+        ClassNode lambdasBackported = new ClassNode();\n+        ClassVisitor next = lambdasBackported;\n+        next = new BackportLambdaInvocations(next);\n+        reader.accept(next, 0);\n \n         List<byte[]> results = new ArrayList<>();\n-        results.add(backportInterface2(new ClassReader(lambdasBackported)));\n-        results.addAll(extractInterfaceCompanion(new ClassReader(lambdasBackported)));\n+        results.add(backportInterface2(lambdasBackported));\n+        results.addAll(extractInterfaceCompanion(lambdasBackported));\n         return results;\n     }\n \n-    private byte[] backportInterface2(ClassReader reader) {\n-        return transform(reader, (next) -> {\n+    private byte[] backportInterface2(ClassNode clazz) {\n+        return transform(clazz, (next) -> {\n             if (defaultMethodsEnabled) {\n                 next = new RemoveStaticMethods(next);\n                 next = new RemoveDefaultMethodBodies(next);\n@@ -84,19 +86,27 @@ public class Transformers {\n         });\n     }\n \n-    private List<byte[]> extractInterfaceCompanion(ClassReader reader) {\n-        Optional<Type> companion = analyzer.getCompanionClass(Type.getObjectType(reader.getClassName()));\n+    private List<byte[]> extractInterfaceCompanion(ClassNode clazz) {\n+        Optional<Type> companion = analyzer.getCompanionClass(Type.getObjectType(clazz.name));\n         if (!companion.isPresent()) {\n             return Collections.emptyList();\n         }\n-        return Arrays.asList(transform(reader, (next) -> {\n+        return Arrays.asList(transform(clazz, (next) -> {\n             next = new UpdateRelocatedMethodInvocations(next, analyzer);\n             next = new ExtractInterfaceCompanionClass(next, companion.get());\n             return next;\n         }));\n     }\n \n+    private byte[] transform(ClassNode node, ClassVisitorChain chain) {\n+        return transform(node::accept, chain);\n+    }\n+\n     private byte[] transform(ClassReader reader, ClassVisitorChain chain) {\n+        return transform(cv -> reader.accept(cv, 0), chain);\n+    }\n+\n+    private byte[] transform(Consumer<ClassVisitor> reader, ClassVisitorChain chain) {\n         ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n         ClassVisitor next = writer;\n \n@@ -107,7 +117,7 @@ public class Transformers {\n         next = new FixInvokeStaticOnInterfaceMethod(next);\n         next = chain.wrap(next);\n \n-        reader.accept(next, 0);\n+        reader.accept(next);\n         return writer.toByteArray();\n     }\n \n"
    },
    {
        "commit_hash": "152bf3b067194d422b785d206f0fe10f27810f98",
        "previous_commit_hash": "1952d2e1457f96478b80b7ea4cdf6d6db0a4193e",
        "diff_stats": {
            "additions": 6,
            "deletions": 0
        },
        "diff_content": "@@ -27,6 +27,12 @@ features on Android. Serge Zaitsev has written [an article about\n it](http://zserge.com/blog/android-lambda.html) and there is a [Gradle\n plugin](#gradle-plugin) which makes it easy.\n \n+Retrolambda does not backport the new Java 8 APIs, but there are other\n+projects that have backported some of them:\n+\n+* [streamsupport](http://sourceforge.net/projects/streamsupport/) backports the `java.util.stream` API\n+* [ThreeTen](http://www.threeten.org/) backports the `java.time` API\n+\n \n User Guide\n ----------\n"
    },
    {
        "commit_hash": "e50c6988ac39c3386159ac9aab9311eb99c9132a",
        "previous_commit_hash": "152bf3b067194d422b785d206f0fe10f27810f98",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -51,7 +51,7 @@ To run Retrolambda using Maven, add the following to your pom.xml:\n <plugin>\n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>retrolambda-maven-plugin</artifactId>\n-    <version>2.0.1</version>\n+    <version>2.0.2</version>\n     <executions>\n         <execution>\n             <goals>\n@@ -208,7 +208,7 @@ optimizations to that mechanism may break Retrolambda.\n Version History\n ---------------\n \n-### Upcoming\n+### Retrolambda 2.0.2 (2015-04-14)\n \n - Fixed a hack which caused lambdas in interfaces to be backported twice,\n   possibly producing broken method calls in the bytecode\n"
    },
    {
        "commit_hash": "e50c6988ac39c3386159ac9aab9311eb99c9132a",
        "previous_commit_hash": "152bf3b067194d422b785d206f0fe10f27810f98",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.2-SNAPSHOT</version>\n+        <version>2.0.2</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "e50c6988ac39c3386159ac9aab9311eb99c9132a",
        "previous_commit_hash": "152bf3b067194d422b785d206f0fe10f27810f98",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>2.0.2-SNAPSHOT</version>\n+    <version>2.0.2</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "e50c6988ac39c3386159ac9aab9311eb99c9132a",
        "previous_commit_hash": "152bf3b067194d422b785d206f0fe10f27810f98",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.2-SNAPSHOT</version>\n+        <version>2.0.2</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "e50c6988ac39c3386159ac9aab9311eb99c9132a",
        "previous_commit_hash": "152bf3b067194d422b785d206f0fe10f27810f98",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.2-SNAPSHOT</version>\n+        <version>2.0.2</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "e50c6988ac39c3386159ac9aab9311eb99c9132a",
        "previous_commit_hash": "152bf3b067194d422b785d206f0fe10f27810f98",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.2-SNAPSHOT</version>\n+        <version>2.0.2</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "9591f4d3c41799be41012deca28a6195947a2324",
        "previous_commit_hash": "e50c6988ac39c3386159ac9aab9311eb99c9132a",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.2</version>\n+        <version>2.0.3-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "9591f4d3c41799be41012deca28a6195947a2324",
        "previous_commit_hash": "e50c6988ac39c3386159ac9aab9311eb99c9132a",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>2.0.2</version>\n+    <version>2.0.3-SNAPSHOT</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "9591f4d3c41799be41012deca28a6195947a2324",
        "previous_commit_hash": "e50c6988ac39c3386159ac9aab9311eb99c9132a",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.2</version>\n+        <version>2.0.3-SNAPSHOT</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "9591f4d3c41799be41012deca28a6195947a2324",
        "previous_commit_hash": "e50c6988ac39c3386159ac9aab9311eb99c9132a",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.2</version>\n+        <version>2.0.3-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "9591f4d3c41799be41012deca28a6195947a2324",
        "previous_commit_hash": "e50c6988ac39c3386159ac9aab9311eb99c9132a",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.2</version>\n+        <version>2.0.3-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "f5b55934abacb90994d9092705c045e282acc069",
        "previous_commit_hash": "9591f4d3c41799be41012deca28a6195947a2324",
        "diff_stats": {
            "additions": 0,
            "deletions": 9
        },
        "diff_content": "@@ -1,9 +0,0 @@\n-<component name=\"libraryTable\">\n-  <library name=\"Maven: net.orfjackal.retrolambda:java-lang-dummies:1\">\n-    <CLASSES>\n-      <root url=\"jar://$PROJECT_DIR$/end-to-end-tests/src/test/lib/java-lang-dummies.jar!/\" />\n-    </CLASSES>\n-    <JAVADOC />\n-    <SOURCES />\n-  </library>\n-</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "f5b55934abacb90994d9092705c045e282acc069",
        "previous_commit_hash": "9591f4d3c41799be41012deca28a6195947a2324",
        "diff_stats": {
            "additions": 4,
            "deletions": 4
        },
        "diff_content": "@@ -1,13 +1,13 @@\n <component name=\"libraryTable\">\n-  <library name=\"Maven: org.ow2.asm:asm-debug-all:5.0.3\">\n+  <library name=\"Maven: org.ow2.asm:asm-debug-all:5.0.4\">\n     <CLASSES>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm-debug-all/5.0.3/asm-debug-all-5.0.3.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm-debug-all/5.0.4/asm-debug-all-5.0.4.jar!/\" />\n     </CLASSES>\n     <JAVADOC>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm-debug-all/5.0.3/asm-debug-all-5.0.3-javadoc.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm-debug-all/5.0.4/asm-debug-all-5.0.4-javadoc.jar!/\" />\n     </JAVADOC>\n     <SOURCES>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm-debug-all/5.0.3/asm-debug-all-5.0.3-sources.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm-debug-all/5.0.4/asm-debug-all-5.0.4-sources.jar!/\" />\n     </SOURCES>\n   </library>\n </component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "f5b55934abacb90994d9092705c045e282acc069",
        "previous_commit_hash": "9591f4d3c41799be41012deca28a6195947a2324",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -85,7 +85,7 @@\n             <dependency>\n                 <groupId>org.ow2.asm</groupId>\n                 <artifactId>asm-debug-all</artifactId>\n-                <version>5.0.3</version>\n+                <version>5.0.4</version>\n             </dependency>\n \n             <!-- Testing -->\n"
    },
    {
        "commit_hash": "f5b55934abacb90994d9092705c045e282acc069",
        "previous_commit_hash": "9591f4d3c41799be41012deca28a6195947a2324",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -18,7 +18,7 @@\n     <orderEntry type=\"inheritedJdk\" />\n     <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n     <orderEntry type=\"module\" module-name=\"retrolambda\" />\n-    <orderEntry type=\"library\" name=\"Maven: org.ow2.asm:asm-debug-all:5.0.3\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.ow2.asm:asm-debug-all:5.0.4\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-plugin-api:2.0\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"PROVIDED\" name=\"Maven: org.apache.maven.plugin-tools:maven-plugin-annotations:3.4\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-artifact:3.0\" level=\"project\" />\n"
    },
    {
        "commit_hash": "f5b55934abacb90994d9092705c045e282acc069",
        "previous_commit_hash": "9591f4d3c41799be41012deca28a6195947a2324",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -10,7 +10,7 @@\n     </content>\n     <orderEntry type=\"inheritedJdk\" />\n     <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n-    <orderEntry type=\"library\" name=\"Maven: org.ow2.asm:asm-debug-all:5.0.3\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.ow2.asm:asm-debug-all:5.0.4\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: com.google.guava:guava:18.0\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.12\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-library:1.3\" level=\"project\" />\n"
    },
    {
        "commit_hash": "ce253e5ca74fbd5e0a2161cb2407d8ae5f9e009d",
        "previous_commit_hash": "f5b55934abacb90994d9092705c045e282acc069",
        "diff_stats": {
            "additions": 6,
            "deletions": 0
        },
        "diff_content": "@@ -208,6 +208,12 @@ optimizations to that mechanism may break Retrolambda.\n Version History\n ---------------\n \n+### Upcoming\n+\n+- Fixed Retrolambda generating stack map frames for Java 5 bytecode,\n+  causing some bytecode tools to fail\n+  ([Issue #55](https://github.com/orfjackal/retrolambda/issues/55))\n+\n ### Retrolambda 2.0.2 (2015-04-14)\n \n - Fixed a hack which caused lambdas in interfaces to be backported twice,\n"
    },
    {
        "commit_hash": "ce253e5ca74fbd5e0a2161cb2407d8ae5f9e009d",
        "previous_commit_hash": "f5b55934abacb90994d9092705c045e282acc069",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -6,6 +6,7 @@\n     <content url=\"file://$MODULE_DIR$\">\n       <sourceFolder url=\"file://$MODULE_DIR$/src/main/java\" isTestSource=\"false\" />\n       <sourceFolder url=\"file://$MODULE_DIR$/src/test/java\" isTestSource=\"true\" />\n+      <sourceFolder url=\"file://$MODULE_DIR$/src/test/resources\" type=\"java-test-resource\" />\n       <excludeFolder url=\"file://$MODULE_DIR$/target\" />\n     </content>\n     <orderEntry type=\"inheritedJdk\" />\n"
    },
    {
        "commit_hash": "ce253e5ca74fbd5e0a2161cb2407d8ae5f9e009d",
        "previous_commit_hash": "f5b55934abacb90994d9092705c045e282acc069",
        "diff_stats": {
            "additions": 17,
            "deletions": 0
        },
        "diff_content": "@@ -40,6 +40,23 @@\n     </dependencies>\n \n     <build>\n+        <testResources>\n+            <testResource>\n+                <directory>src/test/resources</directory>\n+                <filtering>true</filtering>\n+                <includes>\n+                    <include>*.properties</include>\n+                </includes>\n+            </testResource>\n+            <testResource>\n+                <directory>src/test/resources</directory>\n+                <filtering>false</filtering>\n+                <excludes>\n+                    <exclude>*.properties</exclude>\n+                </excludes>\n+            </testResource>\n+        </testResources>\n+\n         <plugins>\n \n             <!-- Don't deploy the tests to Maven Central -->\n"
    },
    {
        "commit_hash": "ce253e5ca74fbd5e0a2161cb2407d8ae5f9e009d",
        "previous_commit_hash": "f5b55934abacb90994d9092705c045e282acc069",
        "diff_stats": {
            "additions": 47,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,47 @@\n+// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.test;\n+\n+import com.google.common.io.CharStreams;\n+import org.apache.commons.lang.SystemUtils;\n+import org.junit.Test;\n+\n+import java.io.*;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.*;\n+\n+public class Java5BytecodeTest {\n+\n+    @Test\n+    public void does_not_generate_stack_map_tables_for_Java_5() throws IOException {\n+        String javapOutput = javap(Dummy.class);\n+\n+        if (SystemUtils.isJavaVersionAtLeast(1.6f)) {\n+            assertThat(javapOutput, containsString(\"StackMap\"));\n+        } else {\n+            assertThat(javapOutput, not(containsString(\"StackMap\")));\n+        }\n+    }\n+\n+    private static String javap(Class<?> aClass) throws IOException {\n+        Process process = new ProcessBuilder()\n+                .directory(TestEnv.testClassesDir)\n+                .command(\"javap\", \"-v\", \"-p\", aClass.getName())\n+                .redirectErrorStream(true)\n+                .start();\n+        return CharStreams.toString(new InputStreamReader(process.getInputStream()));\n+    }\n+\n+\n+    public static class Dummy {\n+        public Dummy() {\n+            // cause this method to have a stack map table\n+            for (int i = 0; i < 3; i++) {\n+                System.out.println(i);\n+            }\n+        }\n+    }\n+}\n"
    },
    {
        "commit_hash": "ce253e5ca74fbd5e0a2161cb2407d8ae5f9e009d",
        "previous_commit_hash": "f5b55934abacb90994d9092705c045e282acc069",
        "diff_stats": {
            "additions": 23,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,23 @@\n+// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.test;\n+\n+import java.io.*;\n+import java.util.Properties;\n+\n+public class TestEnv {\n+\n+    public static final File testClassesDir;\n+\n+    static {\n+        Properties p = new Properties();\n+        try (InputStream in = TestEnv.class.getResourceAsStream(\"/testing.properties\")) {\n+            p.load(in);\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+        testClassesDir = new File(p.getProperty(\"testClassesDir\"));\n+    }\n+}\n"
    },
    {
        "commit_hash": "ce253e5ca74fbd5e0a2161cb2407d8ae5f9e009d",
        "previous_commit_hash": "f5b55934abacb90994d9092705c045e282acc069",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1 @@\n+testClassesDir=${project.build.testOutputDirectory}\n"
    },
    {
        "commit_hash": "ce253e5ca74fbd5e0a2161cb2407d8ae5f9e009d",
        "previous_commit_hash": "f5b55934abacb90994d9092705c045e282acc069",
        "diff_stats": {
            "additions": 24,
            "deletions": 2
        },
        "diff_content": "@@ -1,10 +1,10 @@\n-// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n package net.orfjackal.retrolambda;\n \n-import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.*;\n \n import static org.objectweb.asm.Opcodes.ASM5;\n \n@@ -24,4 +24,26 @@ public class LowerBytecodeVersion extends ClassVisitor {\n         }\n         super.visit(version, access, name, signature, superName, interfaces);\n     }\n+\n+    @Override\n+    public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+        MethodVisitor next = super.visitMethod(access, name, desc, signature, exceptions);\n+        if (targetVersion <= Opcodes.V1_5) {\n+            return new RemoveMethodFrames(next);\n+        } else {\n+            return next;\n+        }\n+    }\n+\n+    private static class RemoveMethodFrames extends MethodVisitor {\n+\n+        public RemoveMethodFrames(MethodVisitor next) {\n+            super(Opcodes.ASM5, next);\n+        }\n+\n+        @Override\n+        public void visitFrame(int type, int nLocal, Object[] local, int nStack, Object[] stack) {\n+            // remove frame\n+        }\n+    }\n }\n"
    },
    {
        "commit_hash": "d4448826ec1b37b526d980fc0ee517fc7971d658",
        "previous_commit_hash": "ce253e5ca74fbd5e0a2161cb2407d8ae5f9e009d",
        "diff_stats": {
            "additions": 0,
            "deletions": 1
        },
        "diff_content": "@@ -472,7 +472,6 @@ public class DefaultMethodsTest {\n      */\n     @Test\n     public void default_methods_with_lambdas_in_another_package() throws Exception {\n-        System.out.println(\"DefaultMethodsTest.default_methods_with_lambdas_in_another_package\");\n         UsesLambdasInAnotherPackage obj = new UsesLambdasInAnotherPackage() {\n         };\n         assertThat(obj.stateless().call(), is(\"foo\"));\n"
    },
    {
        "commit_hash": "eb89c49c3df80100bbb4234b797eaedebdc90a20",
        "previous_commit_hash": "d4448826ec1b37b526d980fc0ee517fc7971d658",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -51,7 +51,7 @@ To run Retrolambda using Maven, add the following to your pom.xml:\n <plugin>\n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>retrolambda-maven-plugin</artifactId>\n-    <version>2.0.2</version>\n+    <version>2.0.3</version>\n     <executions>\n         <execution>\n             <goals>\n@@ -208,7 +208,7 @@ optimizations to that mechanism may break Retrolambda.\n Version History\n ---------------\n \n-### Upcoming\n+### Retrolambda 2.0.3 (2015-06-07)\n \n - Fixed Retrolambda generating stack map frames for Java 5 bytecode,\n   causing some bytecode tools to fail\n"
    },
    {
        "commit_hash": "eb89c49c3df80100bbb4234b797eaedebdc90a20",
        "previous_commit_hash": "d4448826ec1b37b526d980fc0ee517fc7971d658",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.3-SNAPSHOT</version>\n+        <version>2.0.3</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "eb89c49c3df80100bbb4234b797eaedebdc90a20",
        "previous_commit_hash": "d4448826ec1b37b526d980fc0ee517fc7971d658",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>2.0.3-SNAPSHOT</version>\n+    <version>2.0.3</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "eb89c49c3df80100bbb4234b797eaedebdc90a20",
        "previous_commit_hash": "d4448826ec1b37b526d980fc0ee517fc7971d658",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.3-SNAPSHOT</version>\n+        <version>2.0.3</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "eb89c49c3df80100bbb4234b797eaedebdc90a20",
        "previous_commit_hash": "d4448826ec1b37b526d980fc0ee517fc7971d658",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.3-SNAPSHOT</version>\n+        <version>2.0.3</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "eb89c49c3df80100bbb4234b797eaedebdc90a20",
        "previous_commit_hash": "d4448826ec1b37b526d980fc0ee517fc7971d658",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.3-SNAPSHOT</version>\n+        <version>2.0.3</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "87ca4f376117b654133a36ed15bc0bd30016f51e",
        "previous_commit_hash": "eb89c49c3df80100bbb4234b797eaedebdc90a20",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.3</version>\n+        <version>2.0.4-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "87ca4f376117b654133a36ed15bc0bd30016f51e",
        "previous_commit_hash": "eb89c49c3df80100bbb4234b797eaedebdc90a20",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>2.0.3</version>\n+    <version>2.0.4-SNAPSHOT</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "87ca4f376117b654133a36ed15bc0bd30016f51e",
        "previous_commit_hash": "eb89c49c3df80100bbb4234b797eaedebdc90a20",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.3</version>\n+        <version>2.0.4-SNAPSHOT</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "87ca4f376117b654133a36ed15bc0bd30016f51e",
        "previous_commit_hash": "eb89c49c3df80100bbb4234b797eaedebdc90a20",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.3</version>\n+        <version>2.0.4-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "87ca4f376117b654133a36ed15bc0bd30016f51e",
        "previous_commit_hash": "eb89c49c3df80100bbb4234b797eaedebdc90a20",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.3</version>\n+        <version>2.0.4-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "e2156af31976e491bc2d60495d32bf95f494ef41",
        "previous_commit_hash": "87ca4f376117b654133a36ed15bc0bd30016f51e",
        "diff_stats": {
            "additions": 19,
            "deletions": 1
        },
        "diff_content": "@@ -11,14 +11,32 @@\n         <processorPath useClasspath=\"true\" />\n       </profile>\n       <profile default=\"false\" name=\"Maven default annotation processors profile\" enabled=\"true\">\n+        <sourceOutputDir name=\"target/generated-sources/annotations\" />\n+        <sourceTestOutputDir name=\"target/generated-test-sources/test-annotations\" />\n+        <outputRelativeToContentRoot value=\"true\" />\n+        <processorPath useClasspath=\"true\" />\n+        <module name=\"retrolambda-runtime (1)\" />\n+      </profile>\n+      <profile default=\"false\" name=\"Annotation profile for end-to-end-tests\" enabled=\"true\">\n         <sourceOutputDir name=\"target/generated-sources/annotations\" />\n         <sourceTestOutputDir name=\"target/generated-test-sources/test-annotations\" />\n         <outputRelativeToContentRoot value=\"true\" />\n         <processorPath useClasspath=\"true\" />\n         <module name=\"end-to-end-tests\" />\n+      </profile>\n+      <profile default=\"false\" name=\"Annotation profile for retrolambda\" enabled=\"true\">\n+        <sourceOutputDir name=\"target/generated-sources/annotations\" />\n+        <sourceTestOutputDir name=\"target/generated-test-sources/test-annotations\" />\n+        <outputRelativeToContentRoot value=\"true\" />\n+        <processorPath useClasspath=\"true\" />\n         <module name=\"retrolambda\" />\n+      </profile>\n+      <profile default=\"false\" name=\"Annotation profile for retrolambda-maven-plugin\" enabled=\"true\">\n+        <sourceOutputDir name=\"target/generated-sources/annotations\" />\n+        <sourceTestOutputDir name=\"target/generated-test-sources/test-annotations\" />\n+        <outputRelativeToContentRoot value=\"true\" />\n+        <processorPath useClasspath=\"true\" />\n         <module name=\"retrolambda-maven-plugin\" />\n-        <module name=\"retrolambda-runtime (1)\" />\n       </profile>\n     </annotationProcessing>\n     <bytecodeTargetLevel target=\"1.8\">\n"
    },
    {
        "commit_hash": "2f2e124d0f6d40d47b22c42cbecd30650a191e1c",
        "previous_commit_hash": "e2156af31976e491bc2d60495d32bf95f494ef41",
        "diff_stats": {
            "additions": 5,
            "deletions": 0
        },
        "diff_content": "@@ -208,6 +208,11 @@ optimizations to that mechanism may break Retrolambda.\n Version History\n ---------------\n \n+### Upcoming\n+\n+- Fixed a compile error when calling default methods from another module\n+  ([Issue #56](https://github.com/orfjackal/retrolambda/issues/56))\n+\n ### Retrolambda 2.0.3 (2015-06-07)\n \n - Fixed Retrolambda generating stack map frames for Java 5 bytecode,\n"
    },
    {
        "commit_hash": "2f2e124d0f6d40d47b22c42cbecd30650a191e1c",
        "previous_commit_hash": "e2156af31976e491bc2d60495d32bf95f494ef41",
        "diff_stats": {
            "additions": 17,
            "deletions": 1
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -19,4 +19,20 @@ public class InMainSources {\n     public static List<String> useLambdaOfImportedType(List<String> items) {\n         return Lists.transform(items, String::toUpperCase);\n     }\n+\n+    public interface Interface {\n+        default String defaultMethod() {\n+            return \"default\";\n+        }\n+    }\n+\n+    public static class Implementer implements Interface {\n+    }\n+\n+    public static class Overrider implements Interface {\n+        @Override\n+        public String defaultMethod() {\n+            return \"overridden\";\n+        }\n+    }\n }\n"
    },
    {
        "commit_hash": "2f2e124d0f6d40d47b22c42cbecd30650a191e1c",
        "previous_commit_hash": "e2156af31976e491bc2d60495d32bf95f494ef41",
        "diff_stats": {
            "additions": 31,
            "deletions": 1
        },
        "diff_content": "@@ -472,6 +472,8 @@ public class DefaultMethodsTest {\n      */\n     @Test\n     public void default_methods_with_lambdas_in_another_package() throws Exception {\n+        assumeThat(SystemUtils.JAVA_VERSION_FLOAT, is(lessThan(1.8f)));\n+\n         UsesLambdasInAnotherPackage obj = new UsesLambdasInAnotherPackage() {\n         };\n         assertThat(obj.stateless().call(), is(\"foo\"));\n@@ -480,6 +482,34 @@ public class DefaultMethodsTest {\n                 obj.getClass().getDeclaredMethods(), arrayWithSize(2));\n     }\n \n+    /**\n+     * Though we use {@link InMainSources}, because the Retrolambda Maven plugin\n+     * processes the main sources separately from the test sources, the effect is\n+     * the same as if they were in another module.\n+     */\n+    @Test\n+    public void calling_default_methods_from_another_module_through_interface() {\n+        InMainSources.Interface implementer = new InMainSources.Implementer();\n+        assertThat(implementer.defaultMethod(), is(\"default\"));\n+\n+        InMainSources.Interface overrider = new InMainSources.Overrider();\n+        assertThat(overrider.defaultMethod(), is(\"overridden\"));\n+    }\n+\n+    /**\n+     * Fixes issue of the generated delegate methods being marked as synthetic,\n+     * in which case the Java compiler causes \"error: cannot find symbol\"\n+     * for direct calls to those methods.\n+     */\n+    @Test\n+    public void calling_default_methods_from_another_module_through_class() {\n+        InMainSources.Implementer implementer = new InMainSources.Implementer();\n+        assertThat(implementer.defaultMethod(), is(\"default\"));\n+\n+        InMainSources.Overrider overrider = new InMainSources.Overrider();\n+        assertThat(overrider.defaultMethod(), is(\"overridden\"));\n+    }\n+\n \n     /**\n      * We're unable to backport default methods if we cannot modify the interface,\n@@ -553,7 +583,7 @@ public class DefaultMethodsTest {\n         }\n \n         @SomeAnnotation(4)\n-        public static void annotatedStaticMethod() {\n+        static void annotatedStaticMethod() {\n         }\n     }\n \n"
    },
    {
        "commit_hash": "2f2e124d0f6d40d47b22c42cbecd30650a191e1c",
        "previous_commit_hash": "e2156af31976e491bc2d60495d32bf95f494ef41",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -29,7 +29,7 @@ public class AddMethodDefaultImplementations extends ClassVisitor {\n     public void visitEnd() {\n         for (MethodInfo method : analyzer.getDefaultMethods(Type.getObjectType(className))) {\n             Bytecode.generateDelegateMethod(cv,\n-                    ACC_PUBLIC | ACC_SYNTHETIC,\n+                    ACC_PUBLIC,\n                     method.toMethodRef().toHandle(),\n                     method.getDefaultMethodImpl().toHandle());\n         }\n"
    },
    {
        "commit_hash": "a13bc98973cb8e9df14aa58fe2d19a205764d3fc",
        "previous_commit_hash": "2f2e124d0f6d40d47b22c42cbecd30650a191e1c",
        "diff_stats": {
            "additions": 2,
            "deletions": 0
        },
        "diff_content": "@@ -212,6 +212,8 @@ Version History\n \n - Fixed a compile error when calling default methods from another module\n   ([Issue #56](https://github.com/orfjackal/retrolambda/issues/56))\n+- Fixed method references to constructors of the current class\n+  ([Issue #60](https://github.com/orfjackal/retrolambda/issues/60))\n \n ### Retrolambda 2.0.3 (2015-06-07)\n \n"
    },
    {
        "commit_hash": "a13bc98973cb8e9df14aa58fe2d19a205764d3fc",
        "previous_commit_hash": "2f2e124d0f6d40d47b22c42cbecd30650a191e1c",
        "diff_stats": {
            "additions": 41,
            "deletions": 0
        },
        "diff_content": "@@ -125,6 +125,47 @@ public class LambdaTest extends SuperClass {\n         assertThat(ref.call(), is(instanceOf(ArrayList.class)));\n     }\n \n+    /**\n+     * Because the constructor is private, an access method must be generated for it\n+     * and also the NEW instruction must be done inside the access method.\n+     */\n+    @Test\n+    public void method_references_to_private_constructors() throws Exception {\n+        Callable<HasPrivateConstructor> factory = HasPrivateConstructor.factory();\n+        assertThat(factory.call(), is(instanceOf(HasPrivateConstructor.class)));\n+\n+        HasPrivateConstructorWithArgs.Factory factoryArgs = HasPrivateConstructorWithArgs.factory();\n+        assertThat(factoryArgs.create(\"args\"), is(instanceOf(HasPrivateConstructorWithArgs.class)));\n+        assertThat(factoryArgs.create(\"args\").args, is(\"args\"));\n+    }\n+\n+    public static class HasPrivateConstructor {\n+\n+        private HasPrivateConstructor() {\n+        }\n+\n+        public static Callable<HasPrivateConstructor> factory() {\n+            return HasPrivateConstructor::new;\n+        }\n+    }\n+\n+    public static class HasPrivateConstructorWithArgs {\n+        public final String args;\n+\n+        private HasPrivateConstructorWithArgs(String args) {\n+            this.args = args;\n+        }\n+\n+        public static Factory factory() {\n+            return HasPrivateConstructorWithArgs::new;\n+        }\n+\n+        public interface Factory {\n+            HasPrivateConstructorWithArgs create(String args);\n+        }\n+    }\n+\n+\n     @Test\n     public void method_references_to_overridden_inherited_methods_with_super() throws Exception {\n         Callable<String> ref = super::inheritedMethod;\n"
    },
    {
        "commit_hash": "a13bc98973cb8e9df14aa58fe2d19a205764d3fc",
        "previous_commit_hash": "2f2e124d0f6d40d47b22c42cbecd30650a191e1c",
        "diff_stats": {
            "additions": 18,
            "deletions": 1
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -149,6 +149,23 @@ public class BackportLambdaClass extends ClassVisitor {\n                         accessMethod.getName(),\n                         accessMethod.getDesc(),\n                         accessMethod.getTag() == H_INVOKEINTERFACE);\n+\n+                if (implMethod.getTag() == H_NEWINVOKESPECIAL\n+                        && accessMethod.getTag() == H_INVOKESTATIC) {\n+                    // The impl is a private constructor which is called through an access method.\n+                    // XXX: The current method already did NEW an instance, but we won't use it because\n+                    // the access method will also instantiate it, so we could remove the unused\n+                    // instance from stack using the following code, but this is not strictly necessary\n+                    // because ARETURN is allowed to leave behind a non-empty stack. We could improve\n+                    // this backporter so that it would remove the unnecessary \"NEW, DUP\" instructions,\n+                    // but that would be complicated.\n+                    if (false) {\n+                        super.visitVarInsn(ASTORE, 1);\n+                        super.visitInsn(POP);\n+                        super.visitInsn(POP);\n+                        super.visitVarInsn(ALOAD, 1);\n+                    }\n+                }\n             } else {\n                 super.visitMethodInsn(opcode, owner, name, desc, itf);\n             }\n"
    },
    {
        "commit_hash": "a13bc98973cb8e9df14aa58fe2d19a205764d3fc",
        "previous_commit_hash": "2f2e124d0f6d40d47b22c42cbecd30650a191e1c",
        "diff_stats": {
            "additions": 16,
            "deletions": 3
        },
        "diff_content": "@@ -63,14 +63,27 @@ public class BackportLambdaInvocations extends ClassVisitor {\n         }\n         // TODO: do not generate an access method if the impl method is not private (probably not implementable with a single pass)\n         String name = \"access$lambda$\" + lambdaAccessToImplMethods.size();\n-        String desc = implMethod.getTag() == H_INVOKESTATIC\n-                ? implMethod.getDesc()\n-                : Types.prependArgumentType(Type.getType(\"L\" + className + \";\"), implMethod.getDesc());\n+        String desc = getLambdaAccessMethodDesc(implMethod);\n         Handle accessMethod = new Handle(H_INVOKESTATIC, className, name, desc);\n         lambdaAccessToImplMethods.put(accessMethod, implMethod);\n         return accessMethod;\n     }\n \n+    private String getLambdaAccessMethodDesc(Handle implMethod) {\n+        if (implMethod.getTag() == H_INVOKESTATIC) {\n+            // static method call -> keep as-is\n+            return implMethod.getDesc();\n+\n+        } else if (implMethod.getTag() == H_NEWINVOKESPECIAL) {\n+            // constructor call -> change to a a factory method\n+            return Types.changeReturnType(Type.getObjectType(implMethod.getOwner()), implMethod.getDesc());\n+\n+        } else {\n+            // instance method call -> change to a static method\n+            return Types.prependArgumentType(Type.getObjectType(className), implMethod.getDesc());\n+        }\n+    }\n+\n     @Override\n     public void visitEnd() {\n         for (Map.Entry<Handle, Handle> entry : lambdaAccessToImplMethods.entrySet()) {\n"
    },
    {
        "commit_hash": "a13bc98973cb8e9df14aa58fe2d19a205764d3fc",
        "previous_commit_hash": "2f2e124d0f6d40d47b22c42cbecd30650a191e1c",
        "diff_stats": {
            "additions": 6,
            "deletions": 1
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -49,6 +49,11 @@ public class Types {\n         }\n     }\n \n+    public static String changeReturnType(Type returnType, String methodDescriptor) {\n+        Type[] argumentTypes = Type.getArgumentTypes(methodDescriptor);\n+        return Type.getMethodDescriptor(returnType, argumentTypes);\n+    }\n+\n     public static String prependArgumentType(Type argumentType, String methodDescriptor) {\n         Type returnType = Type.getReturnType(methodDescriptor);\n         Type[] argumentTypes = Type.getArgumentTypes(methodDescriptor);\n"
    },
    {
        "commit_hash": "a13bc98973cb8e9df14aa58fe2d19a205764d3fc",
        "previous_commit_hash": "2f2e124d0f6d40d47b22c42cbecd30650a191e1c",
        "diff_stats": {
            "additions": 7,
            "deletions": 1
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -15,6 +15,12 @@ public class Bytecode {\n         MethodVisitor mv = cv.visitMethod(access, method.getName(), method.getDesc(), null, null);\n         mv.visitCode();\n \n+        // if the target method is constructor, then we must NEW up the instance inside the delegate method\n+        if (target.getTag() == H_NEWINVOKESPECIAL) {\n+            mv.visitTypeInsn(NEW, target.getOwner());\n+            mv.visitInsn(DUP);\n+        }\n+\n         // we assume one of the methods to be static and the other virtual, i.e. it has an implicit 'this' argument\n         Type[] args = longest(\n                 Type.getArgumentTypes(method.getDesc()),\n"
    },
    {
        "commit_hash": "6f49e176cdd98e3e372219a5a659590fff0048a0",
        "previous_commit_hash": "a13bc98973cb8e9df14aa58fe2d19a205764d3fc",
        "diff_stats": {
            "additions": 6,
            "deletions": 6
        },
        "diff_content": "@@ -18,22 +18,22 @@\n         <module name=\"retrolambda-runtime (1)\" />\n       </profile>\n       <profile default=\"false\" name=\"Annotation profile for end-to-end-tests\" enabled=\"true\">\n-        <sourceOutputDir name=\"target/generated-sources/annotations\" />\n-        <sourceTestOutputDir name=\"target/generated-test-sources/test-annotations\" />\n+        <sourceOutputDir name=\"target\\generated-sources\\annotations\" />\n+        <sourceTestOutputDir name=\"target\\generated-test-sources\\test-annotations\" />\n         <outputRelativeToContentRoot value=\"true\" />\n         <processorPath useClasspath=\"true\" />\n         <module name=\"end-to-end-tests\" />\n       </profile>\n       <profile default=\"false\" name=\"Annotation profile for retrolambda\" enabled=\"true\">\n-        <sourceOutputDir name=\"target/generated-sources/annotations\" />\n-        <sourceTestOutputDir name=\"target/generated-test-sources/test-annotations\" />\n+        <sourceOutputDir name=\"target\\generated-sources\\annotations\" />\n+        <sourceTestOutputDir name=\"target\\generated-test-sources\\test-annotations\" />\n         <outputRelativeToContentRoot value=\"true\" />\n         <processorPath useClasspath=\"true\" />\n         <module name=\"retrolambda\" />\n       </profile>\n       <profile default=\"false\" name=\"Annotation profile for retrolambda-maven-plugin\" enabled=\"true\">\n-        <sourceOutputDir name=\"target/generated-sources/annotations\" />\n-        <sourceTestOutputDir name=\"target/generated-test-sources/test-annotations\" />\n+        <sourceOutputDir name=\"target\\generated-sources\\annotations\" />\n+        <sourceTestOutputDir name=\"target\\generated-test-sources\\test-annotations\" />\n         <outputRelativeToContentRoot value=\"true\" />\n         <processorPath useClasspath=\"true\" />\n         <module name=\"retrolambda-maven-plugin\" />\n"
    },
    {
        "commit_hash": "6f49e176cdd98e3e372219a5a659590fff0048a0",
        "previous_commit_hash": "a13bc98973cb8e9df14aa58fe2d19a205764d3fc",
        "diff_stats": {
            "additions": 3,
            "deletions": 0
        },
        "diff_content": "@@ -214,6 +214,9 @@ Version History\n   ([Issue #56](https://github.com/orfjackal/retrolambda/issues/56))\n - Fixed method references to constructors of the current class\n   ([Issue #60](https://github.com/orfjackal/retrolambda/issues/60))\n+- Removes bytecode references to `java.lang.invoke.MethodHandles.Lookup` on\n+  Java 6 and older\n+  ([Issue #61](https://github.com/orfjackal/retrolambda/issues/61))\n \n ### Retrolambda 2.0.3 (2015-06-07)\n \n"
    },
    {
        "commit_hash": "6f49e176cdd98e3e372219a5a659590fff0048a0",
        "previous_commit_hash": "a13bc98973cb8e9df14aa58fe2d19a205764d3fc",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -14,6 +14,7 @@\n     <orderEntry type=\"library\" name=\"Maven: com.google.guava:guava:11.0.2\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: com.google.code.findbugs:jsr305:1.3.9\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: commons-lang:commons-lang:2.6\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.ow2.asm:asm-debug-all:5.0.4\" level=\"project\" />\n     <orderEntry type=\"module-library\">\n       <library name=\"Maven: net.orfjackal.retrolambda:java-lang-dummies:1\">\n         <CLASSES>\n"
    },
    {
        "commit_hash": "6f49e176cdd98e3e372219a5a659590fff0048a0",
        "previous_commit_hash": "a13bc98973cb8e9df14aa58fe2d19a205764d3fc",
        "diff_stats": {
            "additions": 6,
            "deletions": 0
        },
        "diff_content": "@@ -28,6 +28,12 @@\n             <scope>test</scope>\n         </dependency>\n \n+        <dependency>\n+            <groupId>org.ow2.asm</groupId>\n+            <artifactId>asm-debug-all</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+\n         <!-- See net.orfjackal.retrolambda.test.ClasspathTest#ignores_classes_in_explicit_classpath_that_are_under_the_java_package -->\n         <dependency>\n             <groupId>net.orfjackal.retrolambda</groupId>\n"
    },
    {
        "commit_hash": "6f49e176cdd98e3e372219a5a659590fff0048a0",
        "previous_commit_hash": "a13bc98973cb8e9df14aa58fe2d19a205764d3fc",
        "diff_stats": {
            "additions": 18,
            "deletions": 0
        },
        "diff_content": "@@ -4,8 +4,12 @@\n \n package net.orfjackal.retrolambda.test;\n \n+import org.apache.commons.lang.SystemUtils;\n import org.junit.Test;\n+import org.objectweb.asm.ClassReader;\n+import org.objectweb.asm.tree.*;\n \n+import java.io.IOException;\n import java.lang.reflect.*;\n import java.util.*;\n import java.util.concurrent.Callable;\n@@ -13,6 +17,7 @@ import java.util.concurrent.Callable;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.*;\n import static org.junit.Assert.assertTrue;\n+import static org.junit.Assume.assumeThat;\n \n public class LambdaTest extends SuperClass {\n \n@@ -260,6 +265,19 @@ public class LambdaTest extends SuperClass {\n         assertThat(((Parent) child).privateMethod(), is(\"parent version\"));\n         assertThat(child.parentRef().call(), is(\"parent version\"));\n     }\n+\n+    @Test\n+    public void bytecode_will_not_contain_dangling_references_to_MethodHandles() throws IOException {\n+        assumeThat(SystemUtils.JAVA_VERSION_FLOAT, is(lessThan(1.7f)));\n+\n+        ClassReader cr = new ClassReader(getClass().getName().replace('.', '/'));\n+        ClassNode cn = new ClassNode();\n+        cr.accept(cn, ClassReader.SKIP_CODE);\n+\n+        for (InnerClassNode innerClass : cn.innerClasses) {\n+            assertThat(innerClass.name, not(startsWith(\"java/lang/invoke\")));\n+        }\n+    }\n }\n \n class SuperClass {\n"
    },
    {
        "commit_hash": "6f49e176cdd98e3e372219a5a659590fff0048a0",
        "previous_commit_hash": "a13bc98973cb8e9df14aa58fe2d19a205764d3fc",
        "diff_stats": {
            "additions": 4,
            "deletions": 2
        },
        "diff_content": "@@ -47,6 +47,8 @@\n         <testBytecodeTarget>1.7</testBytecodeTarget>\n         <testFork>false</testFork>\n         <testDefaultMethods>true</testDefaultMethods>\n+        <!-- Override the default value of this property, but allow changing it on the command line -->\n+        <maven.test.redirectTestOutputToFile>true</maven.test.redirectTestOutputToFile>\n     </properties>\n \n     <prerequisites>\n@@ -167,7 +169,7 @@\n                     <includes>\n                         <include>**/*Test.class</include>\n                     </includes>\n-                    <redirectTestOutputToFile>true</redirectTestOutputToFile>\n+                    <redirectTestOutputToFile>${maven.test.redirectTestOutputToFile}</redirectTestOutputToFile>\n                 </configuration>\n             </plugin>\n \n@@ -177,7 +179,7 @@\n                     <includes>\n                         <include>**/*Test.class</include>\n                     </includes>\n-                    <redirectTestOutputToFile>true</redirectTestOutputToFile>\n+                    <redirectTestOutputToFile>${maven.test.redirectTestOutputToFile}</redirectTestOutputToFile>\n                     <jvm>${testJavaHome}/bin/java</jvm>\n                 </configuration>\n             </plugin>\n"
    },
    {
        "commit_hash": "6f49e176cdd98e3e372219a5a659590fff0048a0",
        "previous_commit_hash": "a13bc98973cb8e9df14aa58fe2d19a205764d3fc",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -113,6 +113,7 @@ public class Transformers {\n         next = new LowerBytecodeVersion(next, targetVersion);\n         if (targetVersion < Opcodes.V1_7) {\n             next = new SwallowSuppressedExceptions(next);\n+            next = new RemoveMethodHandlesLookupReferences(next);\n         }\n         next = new FixInvokeStaticOnInterfaceMethod(next);\n         next = chain.wrap(next);\n"
    },
    {
        "commit_hash": "6f49e176cdd98e3e372219a5a659590fff0048a0",
        "previous_commit_hash": "a13bc98973cb8e9df14aa58fe2d19a205764d3fc",
        "diff_stats": {
            "additions": 27,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,27 @@\n+// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.lambdas;\n+\n+import org.objectweb.asm.*;\n+\n+import java.lang.invoke.MethodHandles;\n+\n+import static org.objectweb.asm.Opcodes.ASM5;\n+\n+public class RemoveMethodHandlesLookupReferences extends ClassVisitor {\n+\n+    private static final String METHOD_HANDLES_LOOKUP = Type.getType(MethodHandles.Lookup.class).getInternalName();\n+\n+    public RemoveMethodHandlesLookupReferences(ClassVisitor next) {\n+        super(ASM5, next);\n+    }\n+\n+    @Override\n+    public void visitInnerClass(String name, String outerName, String innerName, int access) {\n+        if (!name.equals(METHOD_HANDLES_LOOKUP)) {\n+            super.visitInnerClass(name, outerName, innerName, access);\n+        }\n+    }\n+}\n"
    },
    {
        "commit_hash": "46b0d84de9c309bca48a99e572e6611693ed5236",
        "previous_commit_hash": "6f49e176cdd98e3e372219a5a659590fff0048a0",
        "diff_stats": {
            "additions": 2,
            "deletions": 0
        },
        "diff_content": "@@ -217,6 +217,8 @@ Version History\n - Removes bytecode references to `java.lang.invoke.MethodHandles.Lookup` on\n   Java 6 and older\n   ([Issue #61](https://github.com/orfjackal/retrolambda/issues/61))\n+- Copies non-class files from input to output directory\n+  ([Issue #54](https://github.com/orfjackal/retrolambda/issues/54))\n \n ### Retrolambda 2.0.3 (2015-06-07)\n \n"
    },
    {
        "commit_hash": "46b0d84de9c309bca48a99e572e6611693ed5236",
        "previous_commit_hash": "6f49e176cdd98e3e372219a5a659590fff0048a0",
        "diff_stats": {
            "additions": 7,
            "deletions": 2
        },
        "diff_content": "@@ -52,9 +52,14 @@ public class Retrolambda {\n \n             visitFiles(inputDir, includedFiles, new BytecodeFileVisitor() {\n                 @Override\n-                protected void visit(byte[] bytecode) {\n+                protected void visitClass(byte[] bytecode) {\n                     analyzer.analyze(bytecode);\n                 }\n+\n+                @Override\n+                protected void visitResource(Path relativePath, byte[] content) throws IOException {\n+                    saver.saveResource(relativePath, content);\n+                }\n             });\n \n             // Because Transformers.backportLambdaClass() analyzes the lambda class,\n@@ -75,7 +80,7 @@ public class Retrolambda {\n             // We need to load some of the classes (for calling the lambda metafactory)\n             // so we need to take care not to modify any bytecode before loading them.\n             for (byte[] bytecode : transformed) {\n-                saver.save(bytecode);\n+                saver.saveClass(bytecode);\n             }\n         }\n     }\n"
    },
    {
        "commit_hash": "46b0d84de9c309bca48a99e572e6611693ed5236",
        "previous_commit_hash": "6f49e176cdd98e3e372219a5a659590fff0048a0",
        "diff_stats": {
            "additions": 22,
            "deletions": 5
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -10,15 +10,32 @@ import java.nio.file.attribute.BasicFileAttributes;\n \n public abstract class BytecodeFileVisitor extends SimpleFileVisitor<Path> {\n \n+    private Path baseDir;\n+\n     @Override\n-    public FileVisitResult visitFile(Path inputFile, BasicFileAttributes attrs) throws IOException {\n-        if (isJavaClass(inputFile)) {\n-            visit(Files.readAllBytes(inputFile));\n+    public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {\n+        if (baseDir == null) {\n+            baseDir = dir;\n+        }\n+        return super.preVisitDirectory(dir, attrs);\n+    }\n+\n+    @Override\n+    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n+        Path relativePath = baseDir.relativize(file);\n+        byte[] content = Files.readAllBytes(file);\n+\n+        if (isJavaClass(relativePath)) {\n+            visitClass(content);\n+        } else {\n+            visitResource(relativePath, content);\n         }\n         return FileVisitResult.CONTINUE;\n     }\n \n-    protected abstract void visit(byte[] bytecode);\n+    protected abstract void visitClass(byte[] bytecode) throws IOException;\n+\n+    protected abstract void visitResource(Path relativePath, byte[] content) throws IOException;\n \n     private static boolean isJavaClass(Path file) {\n         return file.getFileName().toString().endsWith(\".class\");\n"
    },
    {
        "commit_hash": "46b0d84de9c309bca48a99e572e6611693ed5236",
        "previous_commit_hash": "6f49e176cdd98e3e372219a5a659590fff0048a0",
        "diff_stats": {
            "additions": 9,
            "deletions": 4
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -17,13 +17,18 @@ public class ClassSaver {\n         this.outputDir = outputDir;\n     }\n \n-    public void save(byte[] bytecode) throws IOException {\n+    public void saveClass(byte[] bytecode) throws IOException {\n         if (bytecode == null) {\n             return;\n         }\n         ClassReader cr = new ClassReader(bytecode);\n-        Path outputFile = outputDir.resolve(cr.getClassName() + \".class\");\n+        Path relativePath = Paths.get(cr.getClassName() + \".class\");\n+        saveResource(relativePath, bytecode);\n+    }\n+\n+    public void saveResource(Path relativePath, byte[] content) throws IOException {\n+        Path outputFile = outputDir.resolve(relativePath);\n         Files.createDirectories(outputFile.getParent());\n-        Files.write(outputFile, bytecode);\n+        Files.write(outputFile, content);\n     }\n }\n"
    },
    {
        "commit_hash": "46b0d84de9c309bca48a99e572e6611693ed5236",
        "previous_commit_hash": "6f49e176cdd98e3e372219a5a659590fff0048a0",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -27,7 +27,7 @@ public class LambdaClassSaver {\n     private void reifyLambdaClass(String className, byte[] bytecode) {\n         try {\n             System.out.println(\"Saving lambda class: \" + className);\n-            saver.save(transformers.backportLambdaClass(new ClassReader(bytecode)));\n+            saver.saveClass(transformers.backportLambdaClass(new ClassReader(bytecode)));\n \n         } catch (Throwable t) {\n             // print to stdout to keep in sync with other log output\n"
    },
    {
        "commit_hash": "46b0d84de9c309bca48a99e572e6611693ed5236",
        "previous_commit_hash": "6f49e176cdd98e3e372219a5a659590fff0048a0",
        "diff_stats": {
            "additions": 21,
            "deletions": 1
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -14,6 +14,7 @@ import java.util.*;\n \n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.junit.Assert.assertTrue;\n \n public class RetrolambdaTest {\n \n@@ -21,6 +22,7 @@ public class RetrolambdaTest {\n     public final TemporaryFolder tempDir = new TemporaryFolder();\n \n     private Path inputDir;\n+    private Path outputDir;\n \n     private final List<Path> visitedFiles = new ArrayList<>();\n     private final FileVisitor<Path> visitor = new SimpleFileVisitor<Path>() {\n@@ -38,6 +40,7 @@ public class RetrolambdaTest {\n     @Before\n     public void setup() throws IOException {\n         inputDir = tempDir.newFolder(\"inputDir\").toPath();\n+        outputDir = tempDir.newFolder(\"outputDir\").toPath();\n         file1 = Files.createFile(inputDir.resolve(\"file1.txt\"));\n         file2 = Files.createFile(inputDir.resolve(\"file2.txt\"));\n         Path subdir = inputDir.resolve(\"subdir\");\n@@ -70,4 +73,21 @@ public class RetrolambdaTest {\n \n         assertThat(visitedFiles, containsInAnyOrder(file1));\n     }\n+\n+    @Test\n+    public void copies_resources_to_output_directory() throws Throwable {\n+        Properties p = new Properties();\n+        p.setProperty(Config.INPUT_DIR, inputDir.toString());\n+        p.setProperty(Config.OUTPUT_DIR, outputDir.toString());\n+        p.setProperty(Config.CLASSPATH, \"\");\n+\n+        Retrolambda.run(new Config(p));\n+\n+        assertIsFile(outputDir.resolve(\"file1.txt\"));\n+        assertIsFile(outputDir.resolve(\"subdir/file.txt\"));\n+    }\n+\n+    private static void assertIsFile(Path path) {\n+        assertTrue(\"Expected \" + path + \" to be a file\", Files.isRegularFile(path));\n+    }\n }\n"
    },
    {
        "commit_hash": "09715561e7d539f67c8406d962d2c8f1e90aa26b",
        "previous_commit_hash": "46b0d84de9c309bca48a99e572e6611693ed5236",
        "diff_stats": {
            "additions": 5,
            "deletions": 5
        },
        "diff_content": "@@ -39,9 +39,9 @@ public class Retrolambda {\n         Thread.currentThread().setContextClassLoader(new NonDelegatingClassLoader(asUrls(classpath)));\n \n         ClassHierarchyAnalyzer analyzer = new ClassHierarchyAnalyzer();\n-        ClassSaver saver = new ClassSaver(outputDir);\n+        OutputDirectory outputDirectory = new OutputDirectory(outputDir);\n         Transformers transformers = new Transformers(bytecodeVersion, defaultMethodsEnabled, analyzer);\n-        LambdaClassSaver lambdaClassSaver = new LambdaClassSaver(saver, transformers);\n+        LambdaClassSaver lambdaClassSaver = new LambdaClassSaver(outputDirectory, transformers);\n \n         try (LambdaClassDumper dumper = new LambdaClassDumper(lambdaClassSaver)) {\n             if (PreMain.isAgentLoaded()) {\n@@ -50,7 +50,7 @@ public class Retrolambda {\n                 dumper.install();\n             }\n \n-            visitFiles(inputDir, includedFiles, new BytecodeFileVisitor() {\n+            visitFiles(inputDir, includedFiles, new ClasspathVisitor() {\n                 @Override\n                 protected void visitClass(byte[] bytecode) {\n                     analyzer.analyze(bytecode);\n@@ -58,7 +58,7 @@ public class Retrolambda {\n \n                 @Override\n                 protected void visitResource(Path relativePath, byte[] content) throws IOException {\n-                    saver.saveResource(relativePath, content);\n+                    outputDirectory.writeFile(relativePath, content);\n                 }\n             });\n \n@@ -80,7 +80,7 @@ public class Retrolambda {\n             // We need to load some of the classes (for calling the lambda metafactory)\n             // so we need to take care not to modify any bytecode before loading them.\n             for (byte[] bytecode : transformed) {\n-                saver.saveClass(bytecode);\n+                outputDirectory.writeClass(bytecode);\n             }\n         }\n     }\n"
    },
    {
        "commit_hash": "09715561e7d539f67c8406d962d2c8f1e90aa26b",
        "previous_commit_hash": "46b0d84de9c309bca48a99e572e6611693ed5236",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -8,7 +8,7 @@ import java.io.IOException;\n import java.nio.file.*;\n import java.nio.file.attribute.BasicFileAttributes;\n \n-public abstract class BytecodeFileVisitor extends SimpleFileVisitor<Path> {\n+public abstract class ClasspathVisitor extends SimpleFileVisitor<Path> {\n \n     private Path baseDir;\n \n"
    },
    {
        "commit_hash": "09715561e7d539f67c8406d962d2c8f1e90aa26b",
        "previous_commit_hash": "46b0d84de9c309bca48a99e572e6611693ed5236",
        "diff_stats": {
            "additions": 5,
            "deletions": 5
        },
        "diff_content": "@@ -9,24 +9,24 @@ import org.objectweb.asm.ClassReader;\n import java.io.IOException;\n import java.nio.file.*;\n \n-public class ClassSaver {\n+public class OutputDirectory {\n \n     private final Path outputDir;\n \n-    public ClassSaver(Path outputDir) {\n+    public OutputDirectory(Path outputDir) {\n         this.outputDir = outputDir;\n     }\n \n-    public void saveClass(byte[] bytecode) throws IOException {\n+    public void writeClass(byte[] bytecode) throws IOException {\n         if (bytecode == null) {\n             return;\n         }\n         ClassReader cr = new ClassReader(bytecode);\n         Path relativePath = Paths.get(cr.getClassName() + \".class\");\n-        saveResource(relativePath, bytecode);\n+        writeFile(relativePath, bytecode);\n     }\n \n-    public void saveResource(Path relativePath, byte[] content) throws IOException {\n+    public void writeFile(Path relativePath, byte[] content) throws IOException {\n         Path outputFile = outputDir.resolve(relativePath);\n         Files.createDirectories(outputFile.getParent());\n         Files.write(outputFile, content);\n"
    },
    {
        "commit_hash": "09715561e7d539f67c8406d962d2c8f1e90aa26b",
        "previous_commit_hash": "46b0d84de9c309bca48a99e572e6611693ed5236",
        "diff_stats": {
            "additions": 4,
            "deletions": 4
        },
        "diff_content": "@@ -5,15 +5,15 @@\n package net.orfjackal.retrolambda.lambdas;\n \n import net.orfjackal.retrolambda.Transformers;\n-import net.orfjackal.retrolambda.files.ClassSaver;\n+import net.orfjackal.retrolambda.files.OutputDirectory;\n import org.objectweb.asm.ClassReader;\n \n public class LambdaClassSaver {\n \n-    private final ClassSaver saver;\n+    private final OutputDirectory saver;\n     private final Transformers transformers;\n \n-    public LambdaClassSaver(ClassSaver saver, Transformers transformers) {\n+    public LambdaClassSaver(OutputDirectory saver, Transformers transformers) {\n         this.saver = saver;\n         this.transformers = transformers;\n     }\n@@ -27,7 +27,7 @@ public class LambdaClassSaver {\n     private void reifyLambdaClass(String className, byte[] bytecode) {\n         try {\n             System.out.println(\"Saving lambda class: \" + className);\n-            saver.saveClass(transformers.backportLambdaClass(new ClassReader(bytecode)));\n+            saver.writeClass(transformers.backportLambdaClass(new ClassReader(bytecode)));\n \n         } catch (Throwable t) {\n             // print to stdout to keep in sync with other log output\n"
    },
    {
        "commit_hash": "76ba611e5cb0acb4cfbe4695c1f575fab2353ac5",
        "previous_commit_hash": "09715561e7d539f67c8406d962d2c8f1e90aa26b",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -51,7 +51,7 @@ To run Retrolambda using Maven, add the following to your pom.xml:\n <plugin>\n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>retrolambda-maven-plugin</artifactId>\n-    <version>2.0.3</version>\n+    <version>2.0.4</version>\n     <executions>\n         <execution>\n             <goals>\n@@ -208,7 +208,7 @@ optimizations to that mechanism may break Retrolambda.\n Version History\n ---------------\n \n-### Upcoming\n+### Retrolambda 2.0.4 (2015-07-08)\n \n - Fixed a compile error when calling default methods from another module\n   ([Issue #56](https://github.com/orfjackal/retrolambda/issues/56))\n"
    },
    {
        "commit_hash": "76ba611e5cb0acb4cfbe4695c1f575fab2353ac5",
        "previous_commit_hash": "09715561e7d539f67c8406d962d2c8f1e90aa26b",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.4-SNAPSHOT</version>\n+        <version>2.0.4</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "76ba611e5cb0acb4cfbe4695c1f575fab2353ac5",
        "previous_commit_hash": "09715561e7d539f67c8406d962d2c8f1e90aa26b",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>2.0.4-SNAPSHOT</version>\n+    <version>2.0.4</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "76ba611e5cb0acb4cfbe4695c1f575fab2353ac5",
        "previous_commit_hash": "09715561e7d539f67c8406d962d2c8f1e90aa26b",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.4-SNAPSHOT</version>\n+        <version>2.0.4</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "76ba611e5cb0acb4cfbe4695c1f575fab2353ac5",
        "previous_commit_hash": "09715561e7d539f67c8406d962d2c8f1e90aa26b",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.4-SNAPSHOT</version>\n+        <version>2.0.4</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "76ba611e5cb0acb4cfbe4695c1f575fab2353ac5",
        "previous_commit_hash": "09715561e7d539f67c8406d962d2c8f1e90aa26b",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.4-SNAPSHOT</version>\n+        <version>2.0.4</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "bc192b586fbb80117461c71610bbe805b83b13b8",
        "previous_commit_hash": "76ba611e5cb0acb4cfbe4695c1f575fab2353ac5",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.4</version>\n+        <version>2.0.5-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "bc192b586fbb80117461c71610bbe805b83b13b8",
        "previous_commit_hash": "76ba611e5cb0acb4cfbe4695c1f575fab2353ac5",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>2.0.4</version>\n+    <version>2.0.5-SNAPSHOT</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "bc192b586fbb80117461c71610bbe805b83b13b8",
        "previous_commit_hash": "76ba611e5cb0acb4cfbe4695c1f575fab2353ac5",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.4</version>\n+        <version>2.0.5-SNAPSHOT</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "bc192b586fbb80117461c71610bbe805b83b13b8",
        "previous_commit_hash": "76ba611e5cb0acb4cfbe4695c1f575fab2353ac5",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.4</version>\n+        <version>2.0.5-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "bc192b586fbb80117461c71610bbe805b83b13b8",
        "previous_commit_hash": "76ba611e5cb0acb4cfbe4695c1f575fab2353ac5",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.4</version>\n+        <version>2.0.5-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "4d101af01362eb3ff6a9ad3d9594c39c85fad246",
        "previous_commit_hash": "bc192b586fbb80117461c71610bbe805b83b13b8",
        "diff_stats": {
            "additions": 5,
            "deletions": 0
        },
        "diff_content": "@@ -208,6 +208,11 @@ optimizations to that mechanism may break Retrolambda.\n Version History\n ---------------\n \n+### Upcoming\n+\n+- Support for lambdas with marker interfaces\n+  ([Issue #62](https://github.com/orfjackal/retrolambda/issues/62))\n+\n ### Retrolambda 2.0.4 (2015-07-08)\n \n - Fixed a compile error when calling default methods from another module\n"
    },
    {
        "commit_hash": "4d101af01362eb3ff6a9ad3d9594c39c85fad246",
        "previous_commit_hash": "bc192b586fbb80117461c71610bbe805b83b13b8",
        "diff_stats": {
            "additions": 10,
            "deletions": 0
        },
        "diff_content": "@@ -99,6 +99,16 @@ public class LambdaTest extends SuperClass {\n         Callable<String> LAMBDA = () -> \"foo\";\n     }\n \n+    @Test\n+    public void lambdas_with_marker_interfaces_due_to_intersection_types() throws Exception {\n+        // We must use something other than java.io.Serializable as the marker interface,\n+        // because serializable lambdas are signified by a flag to LambdaMetafactory.altMetafactory\n+        Callable<String> lambda = (Callable<String> & Cloneable) () -> \"foo\";\n+\n+        assertThat(lambda, is(instanceOf(Cloneable.class)));\n+        assertThat(lambda.call(), is(\"foo\"));\n+    }\n+\n     @Test\n     public void method_references_to_virtual_methods() throws Exception {\n         String foo = \"foo\";\n"
    },
    {
        "commit_hash": "4d101af01362eb3ff6a9ad3d9594c39c85fad246",
        "previous_commit_hash": "bc192b586fbb80117461c71610bbe805b83b13b8",
        "diff_stats": {
            "additions": 12,
            "deletions": 1
        },
        "diff_content": "@@ -14,7 +14,14 @@ public class Types {\n \n     public static Object asmToJdkType(Object arg, ClassLoader classLoader, MethodHandles.Lookup caller) throws Exception {\n         if (arg instanceof Type) {\n-            return toMethodType((Type) arg, classLoader);\n+            Type type = (Type) arg;\n+            if (type.getSort() == Type.METHOD) {\n+                return toMethodType(type, classLoader);\n+            } else if (type.getSort() == Type.OBJECT) {\n+                return toClass(type, classLoader);\n+            } else {\n+                throw new IllegalArgumentException(\"Unsupported type: \" + type);\n+            }\n         } else if (arg instanceof Handle) {\n             return toMethodHandle((Handle) arg, classLoader, caller);\n         } else {\n@@ -26,6 +33,10 @@ public class Types {\n         return MethodType.fromMethodDescriptorString(type.getInternalName(), classLoader);\n     }\n \n+    private static Class<?> toClass(Type type, ClassLoader classLoader) throws ClassNotFoundException {\n+        return classLoader.loadClass(type.getInternalName().replace('/', '.'));\n+    }\n+\n     public static MethodHandle toMethodHandle(Handle handle, ClassLoader classLoader, MethodHandles.Lookup lookup) throws Exception {\n         MethodType type = MethodType.fromMethodDescriptorString(handle.getDesc(), classLoader);\n         Class<?> owner = classLoader.loadClass(handle.getOwner().replace('/', '.'));\n"
    },
    {
        "commit_hash": "4d101af01362eb3ff6a9ad3d9594c39c85fad246",
        "previous_commit_hash": "bc192b586fbb80117461c71610bbe805b83b13b8",
        "diff_stats": {
            "additions": 54,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,54 @@\n+// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.lambdas;\n+\n+import org.junit.Test;\n+import org.objectweb.asm.*;\n+\n+import java.lang.invoke.*;\n+import java.util.function.Predicate;\n+\n+import static net.orfjackal.retrolambda.lambdas.Types.asmToJdkType;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.*;\n+\n+@SuppressWarnings(\"UnnecessaryLocalVariable\")\n+public class TypesTest {\n+\n+    private ClassLoader classLoader = getClass().getClassLoader();\n+    private MethodHandles.Lookup lookup = MethodHandles.lookup();\n+\n+    @Test\n+    public void asmToJdkType_MethodType() throws Exception {\n+        Type input = Type.getMethodType(\"(I)Ljava/util/function/Predicate;\");\n+        MethodType output = MethodType.methodType(Predicate.class, int.class);\n+\n+        assertThat(asmToJdkType(input, classLoader, lookup), is(output));\n+    }\n+\n+    @Test\n+    public void asmToJdkType_MethodHandle() throws Exception {\n+        Handle input = new Handle(Opcodes.H_INVOKESTATIC, \"java/lang/String\", \"valueOf\", \"(I)Ljava/lang/String;\");\n+        MethodHandle output = lookup.findStatic(String.class, \"valueOf\", MethodType.methodType(String.class, int.class));\n+\n+        assertThat(asmToJdkType(input, classLoader, lookup).toString(), is(output.toString()));\n+    }\n+\n+    @Test\n+    public void asmToJdkType_Class() throws Exception {\n+        Type input = Type.getType(String.class);\n+        Class<?> output = String.class;\n+\n+        assertThat(asmToJdkType(input, classLoader, lookup), is(equalTo(output)));\n+    }\n+\n+    @Test\n+    public void asmToJdkType_everything_else() throws Exception {\n+        String input = \"foo\";\n+        String output = input;\n+\n+        assertThat(asmToJdkType(input, classLoader, lookup), is(output));\n+    }\n+}\n"
    },
    {
        "commit_hash": "3701dd546cff67ac8bad0cb8e6d50ca0704265bd",
        "previous_commit_hash": "4d101af01362eb3ff6a9ad3d9594c39c85fad246",
        "diff_stats": {
            "additions": 19,
            "deletions": 7
        },
        "diff_content": "@@ -6,8 +6,8 @@ package net.orfjackal.retrolambda.test;\n \n import org.apache.commons.lang.SystemUtils;\n import org.junit.Test;\n-import org.objectweb.asm.ClassReader;\n-import org.objectweb.asm.tree.*;\n+import org.objectweb.asm.*;\n+import org.objectweb.asm.Type;\n \n import java.io.IOException;\n import java.lang.reflect.*;\n@@ -277,15 +277,27 @@ public class LambdaTest extends SuperClass {\n     }\n \n     @Test\n-    public void bytecode_will_not_contain_dangling_references_to_MethodHandles() throws IOException {\n+    public void bytecode_constant_pool_will_not_contain_dangling_references_to_MethodHandles() throws IOException {\n         assumeThat(SystemUtils.JAVA_VERSION_FLOAT, is(lessThan(1.7f)));\n \n         ClassReader cr = new ClassReader(getClass().getName().replace('.', '/'));\n-        ClassNode cn = new ClassNode();\n-        cr.accept(cn, ClassReader.SKIP_CODE);\n+        char[] buf = new char[cr.getMaxStringLength()];\n \n-        for (InnerClassNode innerClass : cn.innerClasses) {\n-            assertThat(innerClass.name, not(startsWith(\"java/lang/invoke\")));\n+        for (int item = 0; item < cr.getItemCount(); item++) {\n+            Object constant = readConstant(item, buf, cr);\n+            if (constant instanceof Type) {\n+                Type type = (Type) constant;\n+                assertThat(\"constant #\" + item, type.getDescriptor(), not(containsString(\"java/lang/invoke\")));\n+            }\n+        }\n+    }\n+\n+    private static Object readConstant(int item, char[] buf, ClassReader cr) {\n+        try {\n+            return cr.readConst(item, buf);\n+        } catch (Exception e) {\n+            // XXX: constant pool entry which is a Methodref, InvokeDynamic or similar non-plain constant\n+            return null;\n         }\n     }\n }\n"
    },
    {
        "commit_hash": "123e3d3222b9e3979ad6b7e059c0353fc2459114",
        "previous_commit_hash": "3701dd546cff67ac8bad0cb8e6d50ca0704265bd",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -51,7 +51,7 @@ To run Retrolambda using Maven, add the following to your pom.xml:\n <plugin>\n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>retrolambda-maven-plugin</artifactId>\n-    <version>2.0.4</version>\n+    <version>2.0.5</version>\n     <executions>\n         <execution>\n             <goals>\n@@ -208,7 +208,7 @@ optimizations to that mechanism may break Retrolambda.\n Version History\n ---------------\n \n-### Upcoming\n+### Retrolambda 2.0.5 (2015-07-19)\n \n - Support for lambdas with marker interfaces\n   ([Issue #62](https://github.com/orfjackal/retrolambda/issues/62))\n"
    },
    {
        "commit_hash": "123e3d3222b9e3979ad6b7e059c0353fc2459114",
        "previous_commit_hash": "3701dd546cff67ac8bad0cb8e6d50ca0704265bd",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.5-SNAPSHOT</version>\n+        <version>2.0.5</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "123e3d3222b9e3979ad6b7e059c0353fc2459114",
        "previous_commit_hash": "3701dd546cff67ac8bad0cb8e6d50ca0704265bd",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>2.0.5-SNAPSHOT</version>\n+    <version>2.0.5</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "123e3d3222b9e3979ad6b7e059c0353fc2459114",
        "previous_commit_hash": "3701dd546cff67ac8bad0cb8e6d50ca0704265bd",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.5-SNAPSHOT</version>\n+        <version>2.0.5</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "123e3d3222b9e3979ad6b7e059c0353fc2459114",
        "previous_commit_hash": "3701dd546cff67ac8bad0cb8e6d50ca0704265bd",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.5-SNAPSHOT</version>\n+        <version>2.0.5</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "123e3d3222b9e3979ad6b7e059c0353fc2459114",
        "previous_commit_hash": "3701dd546cff67ac8bad0cb8e6d50ca0704265bd",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.5-SNAPSHOT</version>\n+        <version>2.0.5</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "ac4a374844eb2af4a6d1b1bfb60b4a55ad2c7550",
        "previous_commit_hash": "123e3d3222b9e3979ad6b7e059c0353fc2459114",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.5</version>\n+        <version>2.0.6-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "ac4a374844eb2af4a6d1b1bfb60b4a55ad2c7550",
        "previous_commit_hash": "123e3d3222b9e3979ad6b7e059c0353fc2459114",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>2.0.5</version>\n+    <version>2.0.6-SNAPSHOT</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "ac4a374844eb2af4a6d1b1bfb60b4a55ad2c7550",
        "previous_commit_hash": "123e3d3222b9e3979ad6b7e059c0353fc2459114",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.5</version>\n+        <version>2.0.6-SNAPSHOT</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "ac4a374844eb2af4a6d1b1bfb60b4a55ad2c7550",
        "previous_commit_hash": "123e3d3222b9e3979ad6b7e059c0353fc2459114",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.5</version>\n+        <version>2.0.6-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "ac4a374844eb2af4a6d1b1bfb60b4a55ad2c7550",
        "previous_commit_hash": "123e3d3222b9e3979ad6b7e059c0353fc2459114",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.5</version>\n+        <version>2.0.6-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "b8c21e43a75776383288b7b3ed42766165f5568b",
        "previous_commit_hash": "ac4a374844eb2af4a6d1b1bfb60b4a55ad2c7550",
        "diff_stats": {
            "additions": 5,
            "deletions": 0
        },
        "diff_content": "@@ -208,6 +208,11 @@ optimizations to that mechanism may break Retrolambda.\n Version History\n ---------------\n \n+### Upcoming\n+\n+- Fixed method references to constructors causing VerifyError on Android \n+  ([Issue #67](https://github.com/orfjackal/retrolambda/issues/67))\n+\n ### Retrolambda 2.0.5 (2015-07-19)\n \n - Support for lambdas with marker interfaces\n"
    },
    {
        "commit_hash": "b8c21e43a75776383288b7b3ed42766165f5568b",
        "previous_commit_hash": "ac4a374844eb2af4a6d1b1bfb60b4a55ad2c7550",
        "diff_stats": {
            "additions": 9,
            "deletions": 11
        },
        "diff_content": "@@ -154,17 +154,15 @@ public class BackportLambdaClass extends ClassVisitor {\n                         && accessMethod.getTag() == H_INVOKESTATIC) {\n                     // The impl is a private constructor which is called through an access method.\n                     // XXX: The current method already did NEW an instance, but we won't use it because\n-                    // the access method will also instantiate it, so we could remove the unused\n-                    // instance from stack using the following code, but this is not strictly necessary\n-                    // because ARETURN is allowed to leave behind a non-empty stack. We could improve\n-                    // this backporter so that it would remove the unnecessary \"NEW, DUP\" instructions,\n-                    // but that would be complicated.\n-                    if (false) {\n-                        super.visitVarInsn(ASTORE, 1);\n-                        super.visitInsn(POP);\n-                        super.visitInsn(POP);\n-                        super.visitVarInsn(ALOAD, 1);\n-                    }\n+                    // the access method will also instantiate it.\n+                    // - The JVM would be OK with a non-empty stack on ARETURN, but it causes a VerifyError\n+                    //   on Android, so here we remove the unused instance from the stack.\n+                    // - We could improve this backporter so that it would remove the unnecessary\n+                    //   \"NEW, DUP\" instructions, but that would be complicated.\n+                    super.visitVarInsn(ASTORE, 1);\n+                    super.visitInsn(POP);\n+                    super.visitInsn(POP);\n+                    super.visitVarInsn(ALOAD, 1);\n                 }\n             } else {\n                 super.visitMethodInsn(opcode, owner, name, desc, itf);\n"
    },
    {
        "commit_hash": "c5a82e201e192c43846a1b611d392f28373d2578",
        "previous_commit_hash": "b8c21e43a75776383288b7b3ed42766165f5568b",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -51,7 +51,7 @@ To run Retrolambda using Maven, add the following to your pom.xml:\n <plugin>\n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>retrolambda-maven-plugin</artifactId>\n-    <version>2.0.5</version>\n+    <version>2.0.6</version>\n     <executions>\n         <execution>\n             <goals>\n@@ -208,7 +208,7 @@ optimizations to that mechanism may break Retrolambda.\n Version History\n ---------------\n \n-### Upcoming\n+### Retrolambda 2.0.6 (2015-09-06)\n \n - Fixed method references to constructors causing VerifyError on Android \n   ([Issue #67](https://github.com/orfjackal/retrolambda/issues/67))\n"
    },
    {
        "commit_hash": "c5a82e201e192c43846a1b611d392f28373d2578",
        "previous_commit_hash": "b8c21e43a75776383288b7b3ed42766165f5568b",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.6-SNAPSHOT</version>\n+        <version>2.0.6</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "c5a82e201e192c43846a1b611d392f28373d2578",
        "previous_commit_hash": "b8c21e43a75776383288b7b3ed42766165f5568b",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>2.0.6-SNAPSHOT</version>\n+    <version>2.0.6</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "c5a82e201e192c43846a1b611d392f28373d2578",
        "previous_commit_hash": "b8c21e43a75776383288b7b3ed42766165f5568b",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.6-SNAPSHOT</version>\n+        <version>2.0.6</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "c5a82e201e192c43846a1b611d392f28373d2578",
        "previous_commit_hash": "b8c21e43a75776383288b7b3ed42766165f5568b",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.6-SNAPSHOT</version>\n+        <version>2.0.6</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "c5a82e201e192c43846a1b611d392f28373d2578",
        "previous_commit_hash": "b8c21e43a75776383288b7b3ed42766165f5568b",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.6-SNAPSHOT</version>\n+        <version>2.0.6</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "39d34e289897fb786c979fd4c689bf876b4d7b49",
        "previous_commit_hash": "c5a82e201e192c43846a1b611d392f28373d2578",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.6</version>\n+        <version>2.0.7-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "39d34e289897fb786c979fd4c689bf876b4d7b49",
        "previous_commit_hash": "c5a82e201e192c43846a1b611d392f28373d2578",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>2.0.6</version>\n+    <version>2.0.7-SNAPSHOT</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "39d34e289897fb786c979fd4c689bf876b4d7b49",
        "previous_commit_hash": "c5a82e201e192c43846a1b611d392f28373d2578",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.6</version>\n+        <version>2.0.7-SNAPSHOT</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "39d34e289897fb786c979fd4c689bf876b4d7b49",
        "previous_commit_hash": "c5a82e201e192c43846a1b611d392f28373d2578",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.6</version>\n+        <version>2.0.7-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "39d34e289897fb786c979fd4c689bf876b4d7b49",
        "previous_commit_hash": "c5a82e201e192c43846a1b611d392f28373d2578",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.6</version>\n+        <version>2.0.7-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "54cbd659596f1f7b028a4e7f14154504fbf02f3c",
        "previous_commit_hash": "39d34e289897fb786c979fd4c689bf876b4d7b49",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -22,7 +22,7 @@ public class OutputDirectory {\n             return;\n         }\n         ClassReader cr = new ClassReader(bytecode);\n-        Path relativePath = Paths.get(cr.getClassName() + \".class\");\n+        Path relativePath = outputDir.getFileSystem().getPath(cr.getClassName() + \".class\");\n         writeFile(relativePath, bytecode);\n     }\n \n"
    },
    {
        "commit_hash": "e9fc4948ee3bfb7fd7cdf12e20788f1bb0de07a8",
        "previous_commit_hash": "39d34e289897fb786c979fd4c689bf876b4d7b49",
        "diff_stats": {
            "additions": 60,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,60 @@\n+// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.lambdas;\n+\n+import org.junit.Test;\n+import org.objectweb.asm.*;\n+\n+import static net.orfjackal.retrolambda.lambdas.Handles.*;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertThat;\n+import static org.objectweb.asm.Opcodes.*;\n+\n+public class HandlesTest {\n+\n+    @Test\n+    public void testGetOpcode() {\n+        assertThat(getOpcode(handle(H_INVOKEVIRTUAL)), is(INVOKEVIRTUAL));\n+        assertThat(getOpcode(handle(H_INVOKESTATIC)), is(INVOKESTATIC));\n+        assertThat(getOpcode(handle(H_INVOKESPECIAL)), is(INVOKESPECIAL));\n+        assertThat(getOpcode(handle(H_NEWINVOKESPECIAL)), is(INVOKESPECIAL));\n+        assertThat(getOpcode(handle(H_INVOKEINTERFACE)), is(INVOKEINTERFACE));\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testGetOpcodeNegative() {\n+        getOpcode(handle(0));\n+    }\n+\n+    @Test\n+    public void testOpcodeToTag() {\n+        assertThat(opcodeToTag(INVOKEVIRTUAL), is(H_INVOKEVIRTUAL));\n+        assertThat(opcodeToTag(INVOKESTATIC), is(H_INVOKESTATIC));\n+        assertThat(opcodeToTag(INVOKESPECIAL), is(H_INVOKESPECIAL));\n+        assertThat(opcodeToTag(INVOKEINTERFACE), is(H_INVOKEINTERFACE));\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testOpcodeToTagNegative() {\n+        opcodeToTag(0);\n+    }\n+\n+    @Test\n+    public void testAccessToTag() {\n+        assertThat(accessToTag(ACC_STATIC, true), is(H_INVOKESTATIC));\n+        assertThat(accessToTag(ACC_STATIC, false), is(H_INVOKESTATIC));\n+\n+        assertThat(accessToTag(ACC_PRIVATE, true), is(H_INVOKESPECIAL));\n+        assertThat(accessToTag(ACC_PRIVATE, false), is(H_INVOKESPECIAL));\n+\n+        assertThat(accessToTag(ACC_PUBLIC, true), is(H_INVOKEINTERFACE));\n+        assertThat(accessToTag(ACC_PUBLIC, false), is(H_INVOKEVIRTUAL));\n+    }\n+\n+    private Handle handle(int tag) {\n+        return new Handle(tag, null, null, null);\n+    }\n+\n+}\n"
    },
    {
        "commit_hash": "fd2b562aef6831e9707ee3ef7651d30fcbe9ab0b",
        "previous_commit_hash": "e02a05bfb431cab9fa47901e6d72541f66981cea",
        "diff_stats": {
            "additions": 29,
            "deletions": 1
        },
        "diff_content": "@@ -4,9 +4,13 @@\n \n package net.orfjackal.retrolambda;\n \n+import com.google.common.base.Charsets;\n+import com.google.common.io.*;\n+import com.google.common.io.Files;\n import org.objectweb.asm.Opcodes;\n \n-import java.io.File;\n+import java.io.*;\n+import java.nio.charset.Charset;\n import java.nio.file.*;\n import java.util.*;\n import java.util.stream.Collectors;\n@@ -20,6 +24,7 @@ public class Config {\n     public static final String OUTPUT_DIR = PREFIX + \"outputDir\";\n     public static final String CLASSPATH = PREFIX + \"classpath\";\n     public static final String INCLUDED_FILES = PREFIX + \"includedFiles\";\n+    public static final String INCLUDED_FILE = PREFIX + \"includedFile\";\n \n     private static final List<String> requiredProperties = new ArrayList<>();\n     private static final List<String> requiredPropertiesHelp = new ArrayList<>();\n@@ -159,6 +164,29 @@ public class Config {\n                 .collect(Collectors.toList());\n     }\n \n+    static {\n+        optionalParameterHelp(INCLUDED_FILE,\n+                \"A file listing the files to process (one file per line), instead of processing all files.\",\n+                \"This is useful for a build tool to support incremental compilation.\");\n+    }\n+\n+    public List<Path> getIncludedFileList() {\n+        String filePath = p.getProperty(INCLUDED_FILE);\n+        if (filePath == null) {\n+            return null;\n+        }\n+        File file = Paths.get(filePath).toFile();\n+\n+        try {\n+            return Files.readLines(file, Charsets.UTF_8).stream()\n+                    .filter(s -> !s.isEmpty())\n+                    .map(Paths::get)\n+                    .collect(Collectors.toList());\n+        } catch (IOException e) {\n+            return Collections.emptyList();\n+        }\n+    }\n+\n     // help\n \n     public String getHelp() {\n"
    },
    {
        "commit_hash": "fd2b562aef6831e9707ee3ef7651d30fcbe9ab0b",
        "previous_commit_hash": "e02a05bfb431cab9fa47901e6d72541f66981cea",
        "diff_stats": {
            "additions": 4,
            "deletions": 2
        },
        "diff_content": "@@ -21,13 +21,15 @@ public class Retrolambda {\n         Path inputDir = config.getInputDir();\n         Path outputDir = config.getOutputDir();\n         String classpath = config.getClasspath();\n-        List<Path> includedFiles = config.getIncludedFiles();\n+        List<Path> includedFiles = new ArrayList<>();\n+        includedFiles.addAll(config.getIncludedFileList());\n+        includedFiles.addAll(config.getIncludedFiles());\n         System.out.println(\"Bytecode version: \" + bytecodeVersion + \" (\" + config.getJavaVersion() + \")\");\n         System.out.println(\"Default methods:  \" + defaultMethodsEnabled);\n         System.out.println(\"Input directory:  \" + inputDir);\n         System.out.println(\"Output directory: \" + outputDir);\n         System.out.println(\"Classpath:        \" + classpath);\n-        if (includedFiles != null) {\n+        if (!includedFiles.isEmpty()) {\n             System.out.println(\"Included files:   \" + includedFiles.size());\n         }\n \n"
    },
    {
        "commit_hash": "fd2b562aef6831e9707ee3ef7651d30fcbe9ab0b",
        "previous_commit_hash": "e02a05bfb431cab9fa47901e6d72541f66981cea",
        "diff_stats": {
            "additions": 44,
            "deletions": 2
        },
        "diff_content": "@@ -4,12 +4,17 @@\n \n package net.orfjackal.retrolambda;\n \n+import com.google.common.base.*;\n+import com.google.common.collect.Lists;\n+import com.google.common.io.Files;\n import org.junit.*;\n import org.junit.rules.ExpectedException;\n \n-import java.io.File;\n+import java.io.*;\n import java.nio.file.Paths;\n import java.util.*;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n \n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.*;\n@@ -72,4 +77,41 @@ public class ConfigTest {\n         systemProperties.setProperty(Config.INCLUDED_FILES, \"/foo/one.class\" + File.pathSeparator + \"/foo/two.class\");\n         assertThat(\"multiple values\", config().getIncludedFiles(), is(Arrays.asList(Paths.get(\"/foo/one.class\"), Paths.get(\"/foo/two.class\"))));\n     }\n-}\n+\n+    @Test\n+    public void included_file() throws IOException {\n+        assertThat(\"not set\", config().getIncludedFileList(), is(nullValue()));\n+\n+        systemProperties.setProperty(Config.INCLUDED_FILE, \"\");\n+        assertThat(\"zero values\", config().getIncludedFileList(), is(empty()));\n+\n+        // Single file\n+        File singleTmp = File.createTempFile(\"test\",\".list\");\n+        singleTmp.deleteOnExit();\n+\n+        List<String> file = Lists.newArrayList(\"foo.java\");\n+        String delimiter = System.getProperty(\"line.separator\");\n+        Files.write(file.stream()\n+                .collect(Collectors.joining(delimiter)), singleTmp, Charsets.UTF_8);\n+\n+        systemProperties.setProperty(Config.INCLUDED_FILE, singleTmp.getAbsolutePath());\n+        assertThat(\"one value\", config().getIncludedFileList(), is(\n+                file.stream()\n+                        .map(f -> Paths.get(f))\n+                        .collect(Collectors.toList())));\n+\n+        // Multiple files\n+        File multiTmp = File.createTempFile(\"test\",\".list\");\n+        multiTmp.deleteOnExit();\n+\n+        List<String> files = Lists.newArrayList(\"foo.java\", \"bar.java\");\n+        Files.write(files.stream()\n+                .collect(Collectors.joining(delimiter)), multiTmp, Charsets.UTF_8);\n+\n+        systemProperties.setProperty(Config.INCLUDED_FILE, multiTmp.getAbsolutePath());\n+        assertThat(\"two values\", config().getIncludedFileList(), is(\n+                files.stream()\n+                        .map(f -> Paths.get(f))\n+                        .collect(Collectors.toList())));\n+    }\n+}\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "2ee88fb03bdf47b46288637e8545708a2ad5399c",
        "previous_commit_hash": "fd2b562aef6831e9707ee3ef7651d30fcbe9ab0b",
        "diff_stats": {
            "additions": 4,
            "deletions": 0
        },
        "diff_content": "@@ -126,6 +126,10 @@ Optional system properties:\n       List of files to process, instead of processing all files.\n       This is useful for a build tool to support incremental compilation.\n \n+  retrolambda.includedFile\n+      A file listing the files to process (one file per line), instead of processing all files.\n+      This is useful for a build tool to support incremental compilation.\n+\n If the Java agent is used, then Retrolambda will use it to capture the\n lambda classes generated by Java. Otherwise Retrolambda will hook into\n Java's internal lambda dumping API, which is more susceptible to suddenly\n"
    },
    {
        "commit_hash": "2ee88fb03bdf47b46288637e8545708a2ad5399c",
        "previous_commit_hash": "fd2b562aef6831e9707ee3ef7651d30fcbe9ab0b",
        "diff_stats": {
            "additions": 12,
            "deletions": 3
        },
        "diff_content": "@@ -4,6 +4,7 @@\n \n package net.orfjackal.retrolambda;\n \n+import com.google.common.collect.Lists;\n import net.orfjackal.retrolambda.files.*;\n import net.orfjackal.retrolambda.interfaces.*;\n import net.orfjackal.retrolambda.lambdas.*;\n@@ -21,14 +22,22 @@ public class Retrolambda {\n         Path inputDir = config.getInputDir();\n         Path outputDir = config.getOutputDir();\n         String classpath = config.getClasspath();\n-        List<Path> includedFiles = new ArrayList<>();\n-        includedFiles.addAll(config.getIncludedFileList());\n-        includedFiles.addAll(config.getIncludedFiles());\n+        List<Path> includedFilesByArgument = config.getIncludedFileList();\n+        List<Path> includedFilesByFileList = config.getIncludedFiles();\n+\n         System.out.println(\"Bytecode version: \" + bytecodeVersion + \" (\" + config.getJavaVersion() + \")\");\n         System.out.println(\"Default methods:  \" + defaultMethodsEnabled);\n         System.out.println(\"Input directory:  \" + inputDir);\n         System.out.println(\"Output directory: \" + outputDir);\n         System.out.println(\"Classpath:        \" + classpath);\n+\n+        List<Path> includedFiles  = Lists.newArrayList();\n+        if (includedFilesByArgument != null) {\n+            includedFiles.addAll(includedFilesByArgument);\n+        }\n+        if (includedFilesByFileList != null) {\n+            includedFiles.addAll(includedFilesByFileList);\n+        }\n         if (!includedFiles.isEmpty()) {\n             System.out.println(\"Included files:   \" + includedFiles.size());\n         }\n"
    },
    {
        "commit_hash": "7d9941a18db91173133ab12eebaa0fafe0246eee",
        "previous_commit_hash": "4cb15a649b5320dbc32e7b053d28ea1abe6fcdb6",
        "diff_stats": {
            "additions": 6,
            "deletions": 6
        },
        "diff_content": "@@ -18,22 +18,22 @@\n         <module name=\"retrolambda-runtime (1)\" />\n       </profile>\n       <profile default=\"false\" name=\"Annotation profile for end-to-end-tests\" enabled=\"true\">\n-        <sourceOutputDir name=\"target\\generated-sources\\annotations\" />\n-        <sourceTestOutputDir name=\"target\\generated-test-sources\\test-annotations\" />\n+        <sourceOutputDir name=\"target/generated-sources/annotations\" />\n+        <sourceTestOutputDir name=\"target/generated-test-sources/test-annotations\" />\n         <outputRelativeToContentRoot value=\"true\" />\n         <processorPath useClasspath=\"true\" />\n         <module name=\"end-to-end-tests\" />\n       </profile>\n       <profile default=\"false\" name=\"Annotation profile for retrolambda\" enabled=\"true\">\n-        <sourceOutputDir name=\"target\\generated-sources\\annotations\" />\n-        <sourceTestOutputDir name=\"target\\generated-test-sources\\test-annotations\" />\n+        <sourceOutputDir name=\"target/generated-sources/annotations\" />\n+        <sourceTestOutputDir name=\"target/generated-test-sources/test-annotations\" />\n         <outputRelativeToContentRoot value=\"true\" />\n         <processorPath useClasspath=\"true\" />\n         <module name=\"retrolambda\" />\n       </profile>\n       <profile default=\"false\" name=\"Annotation profile for retrolambda-maven-plugin\" enabled=\"true\">\n-        <sourceOutputDir name=\"target\\generated-sources\\annotations\" />\n-        <sourceTestOutputDir name=\"target\\generated-test-sources\\test-annotations\" />\n+        <sourceOutputDir name=\"target/generated-sources/annotations\" />\n+        <sourceTestOutputDir name=\"target/generated-test-sources/test-annotations\" />\n         <outputRelativeToContentRoot value=\"true\" />\n         <processorPath useClasspath=\"true\" />\n         <module name=\"retrolambda-maven-plugin\" />\n"
    },
    {
        "commit_hash": "7d9941a18db91173133ab12eebaa0fafe0246eee",
        "previous_commit_hash": "4cb15a649b5320dbc32e7b053d28ea1abe6fcdb6",
        "diff_stats": {
            "additions": 5,
            "deletions": 1
        },
        "diff_content": "@@ -2,6 +2,7 @@\n   <profile version=\"1.0\" is_locked=\"false\">\n     <option name=\"myName\" value=\"Project Default\" />\n     <option name=\"myLocal\" value=\"false\" />\n+    <inspection_tool class=\"ArraysAsListWithZeroOrOneArgument\" enabled=\"true\" level=\"WEAK WARNING\" enabled_by_default=\"true\" />\n     <inspection_tool class=\"CollectionContainsUrl\" enabled=\"true\" level=\"WARNING\" enabled_by_default=\"true\" />\n     <inspection_tool class=\"CollectionsFieldAccessReplaceableByMethodCall\" enabled=\"true\" level=\"WARNING\" enabled_by_default=\"true\" />\n     <inspection_tool class=\"EnumerationCanBeIteration\" enabled=\"true\" level=\"WARNING\" enabled_by_default=\"true\" />\n@@ -39,7 +40,10 @@\n       <option name=\"myAdditionalJavadocTags\" value=\"\" />\n     </inspection_tool>\n     <inspection_tool class=\"ListIndexOfReplaceableByContains\" enabled=\"true\" level=\"WARNING\" enabled_by_default=\"true\" />\n-    <inspection_tool class=\"LongLiteralsEndingWithLowercaseL\" enabled=\"true\" level=\"WARNING\" enabled_by_default=\"true\" />\n+    <inspection_tool class=\"LoggerInitializedWithForeignClass\" enabled=\"false\" level=\"WARNING\" enabled_by_default=\"false\">\n+      <option name=\"loggerClassName\" value=\"org.apache.log4j.Logger,org.slf4j.LoggerFactory,org.apache.commons.logging.LogFactory,java.util.logging.Logger\" />\n+      <option name=\"loggerFactoryMethodName\" value=\"getLogger,getLogger,getLog,getLogger\" />\n+    </inspection_tool>\n     <inspection_tool class=\"MethodMayBeSynchronized\" enabled=\"true\" level=\"WARNING\" enabled_by_default=\"true\" />\n     <inspection_tool class=\"MissingOverrideAnnotation\" enabled=\"true\" level=\"WARNING\" enabled_by_default=\"true\">\n       <option name=\"ignoreObjectMethods\" value=\"false\" />\n"
    },
    {
        "commit_hash": "7d9941a18db91173133ab12eebaa0fafe0246eee",
        "previous_commit_hash": "4cb15a649b5320dbc32e7b053d28ea1abe6fcdb6",
        "diff_stats": {
            "additions": 12,
            "deletions": 3
        },
        "diff_content": "@@ -103,6 +103,7 @@ Required system properties:\n \n   retrolambda.classpath\n       Classpath containing the original class files and their dependencies.\n+      Uses ; or : as the path separator, see java.io.File#pathSeparatorChar\n \n Optional system properties:\n \n@@ -125,10 +126,12 @@ Optional system properties:\n   retrolambda.includedFiles\n       List of files to process, instead of processing all files.\n       This is useful for a build tool to support incremental compilation.\n+      Uses ; or : as the path separator, see java.io.File#pathSeparatorChar\n \n-  retrolambda.includedFile\n-      A file listing the files to process (one file per line), instead of processing all files.\n-      This is useful for a build tool to support incremental compilation.\n+  retrolambda.includedFilesFile\n+      File listing the files to process, instead of processing all files.\n+      Alternative to retrolambda.includedFiles for avoiding the command line\n+      length limit. The file must list one file per line with UTF-8 encoding.\n \n If the Java agent is used, then Retrolambda will use it to capture the\n lambda classes generated by Java. Otherwise Retrolambda will hook into\n@@ -212,6 +215,12 @@ optimizations to that mechanism may break Retrolambda.\n Version History\n ---------------\n \n+### Upcoming\n+\n+- Added the `-Dretrolambda.includedFilesFile` parameter to avoid \n+  the command line length limit\n+  ([Pull request #74](https://github.com/orfjackal/retrolambda/pull/74))\n+\n ### Retrolambda 2.0.6 (2015-09-06)\n \n - Fixed method references to constructors causing VerifyError on Android \n"
    },
    {
        "commit_hash": "7d9941a18db91173133ab12eebaa0fafe0246eee",
        "previous_commit_hash": "4cb15a649b5320dbc32e7b053d28ea1abe6fcdb6",
        "diff_stats": {
            "additions": 26,
            "deletions": 33
        },
        "diff_content": "@@ -4,13 +4,9 @@\n \n package net.orfjackal.retrolambda;\n \n-import com.google.common.base.Charsets;\n-import com.google.common.io.*;\n-import com.google.common.io.Files;\n import org.objectweb.asm.Opcodes;\n \n import java.io.*;\n-import java.nio.charset.Charset;\n import java.nio.file.*;\n import java.util.*;\n import java.util.stream.Collectors;\n@@ -24,7 +20,7 @@ public class Config {\n     public static final String OUTPUT_DIR = PREFIX + \"outputDir\";\n     public static final String CLASSPATH = PREFIX + \"classpath\";\n     public static final String INCLUDED_FILES = PREFIX + \"includedFiles\";\n-    public static final String INCLUDED_FILE = PREFIX + \"includedFile\";\n+    public static final String INCLUDED_FILES_FILE = PREFIX + \"includedFilesFile\";\n \n     private static final List<String> requiredProperties = new ArrayList<>();\n     private static final List<String> requiredPropertiesHelp = new ArrayList<>();\n@@ -130,7 +126,8 @@ public class Config {\n \n     static {\n         requiredParameterHelp(CLASSPATH,\n-                \"Classpath containing the original class files and their dependencies.\");\n+                \"Classpath containing the original class files and their dependencies.\",\n+                \"Uses ; or : as the path separator, see java.io.File#pathSeparatorChar\");\n     }\n \n     public String getClasspath() {\n@@ -145,48 +142,44 @@ public class Config {\n         return value;\n     }\n \n+\n     // incremental files\n \n     static {\n         optionalParameterHelp(INCLUDED_FILES,\n                 \"List of files to process, instead of processing all files.\",\n-                \"This is useful for a build tool to support incremental compilation.\");\n+                \"This is useful for a build tool to support incremental compilation.\",\n+                \"Uses ; or : as the path separator, see java.io.File#pathSeparatorChar\");\n+        optionalParameterHelp(INCLUDED_FILES_FILE,\n+                \"File listing the files to process, instead of processing all files.\",\n+                \"Alternative to \" + INCLUDED_FILES + \" for avoiding the command line\",\n+                \"length limit. The file must list one file per line with UTF-8 encoding.\");\n     }\n \n     public List<Path> getIncludedFiles() {\n         String files = p.getProperty(INCLUDED_FILES);\n-        if (files == null) {\n-            return null;\n-        }\n-        return Arrays.asList(files.split(File.pathSeparator)).stream()\n-                .filter(s -> !s.isEmpty())\n-                .map(Paths::get)\n-                .collect(Collectors.toList());\n-    }\n-\n-    static {\n-        optionalParameterHelp(INCLUDED_FILE,\n-                \"A file listing the files to process (one file per line), instead of processing all files.\",\n-                \"This is useful for a build tool to support incremental compilation.\");\n-    }\n-\n-    public List<Path> getIncludedFileList() {\n-        String filePath = p.getProperty(INCLUDED_FILE);\n-        if (filePath == null) {\n-            return null;\n-        }\n-        File file = Paths.get(filePath).toFile();\n-\n-        try {\n-            return Files.readLines(file, Charsets.UTF_8).stream()\n+        if (files != null) {\n+            return Arrays.asList(files.split(File.pathSeparator)).stream()\n                     .filter(s -> !s.isEmpty())\n                     .map(Paths::get)\n                     .collect(Collectors.toList());\n-        } catch (IOException e) {\n-            return Collections.emptyList();\n         }\n+        String filesFile = p.getProperty(INCLUDED_FILES_FILE);\n+        if (filesFile != null) {\n+            try {\n+                return Files.readAllLines(Paths.get(filesFile))\n+                        .stream()\n+                        .filter(path -> !path.isEmpty())\n+                        .map(Paths::get)\n+                        .collect(Collectors.toList());\n+            } catch (IOException e) {\n+                throw new RuntimeException(\"Failed to read \" + INCLUDED_FILES_FILE + \" from \" + filesFile, e);\n+            }\n+        }\n+        return null;\n     }\n \n+\n     // help\n \n     public String getHelp() {\n"
    },
    {
        "commit_hash": "7d9941a18db91173133ab12eebaa0fafe0246eee",
        "previous_commit_hash": "4cb15a649b5320dbc32e7b053d28ea1abe6fcdb6",
        "diff_stats": {
            "additions": 2,
            "deletions": 13
        },
        "diff_content": "@@ -4,7 +4,6 @@\n \n package net.orfjackal.retrolambda;\n \n-import com.google.common.collect.Lists;\n import net.orfjackal.retrolambda.files.*;\n import net.orfjackal.retrolambda.interfaces.*;\n import net.orfjackal.retrolambda.lambdas.*;\n@@ -22,23 +21,13 @@ public class Retrolambda {\n         Path inputDir = config.getInputDir();\n         Path outputDir = config.getOutputDir();\n         String classpath = config.getClasspath();\n-        List<Path> includedFilesByArgument = config.getIncludedFileList();\n-        List<Path> includedFilesByFileList = config.getIncludedFiles();\n-\n+        List<Path> includedFiles = config.getIncludedFiles();\n         System.out.println(\"Bytecode version: \" + bytecodeVersion + \" (\" + config.getJavaVersion() + \")\");\n         System.out.println(\"Default methods:  \" + defaultMethodsEnabled);\n         System.out.println(\"Input directory:  \" + inputDir);\n         System.out.println(\"Output directory: \" + outputDir);\n         System.out.println(\"Classpath:        \" + classpath);\n-\n-        List<Path> includedFiles  = Lists.newArrayList();\n-        if (includedFilesByArgument != null) {\n-            includedFiles.addAll(includedFilesByArgument);\n-        }\n-        if (includedFilesByFileList != null) {\n-            includedFiles.addAll(includedFilesByFileList);\n-        }\n-        if (!includedFiles.isEmpty()) {\n+        if (includedFiles != null) {\n             System.out.println(\"Included files:   \" + includedFiles.size());\n         }\n \n"
    },
    {
        "commit_hash": "7d9941a18db91173133ab12eebaa0fafe0246eee",
        "previous_commit_hash": "4cb15a649b5320dbc32e7b053d28ea1abe6fcdb6",
        "diff_stats": {
            "additions": 21,
            "deletions": 42
        },
        "diff_content": "@@ -4,17 +4,12 @@\n \n package net.orfjackal.retrolambda;\n \n-import com.google.common.base.*;\n-import com.google.common.collect.Lists;\n-import com.google.common.io.Files;\n import org.junit.*;\n-import org.junit.rules.ExpectedException;\n+import org.junit.rules.*;\n \n import java.io.*;\n-import java.nio.file.Paths;\n+import java.nio.file.*;\n import java.util.*;\n-import java.util.Optional;\n-import java.util.stream.Collectors;\n \n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.*;\n@@ -24,6 +19,9 @@ public class ConfigTest {\n     @Rule\n     public final ExpectedException thrown = ExpectedException.none();\n \n+    @Rule\n+    public final TemporaryFolder tempDir = new TemporaryFolder();\n+\n     private final Properties systemProperties = new Properties();\n \n     private Config config() {\n@@ -79,39 +77,20 @@ public class ConfigTest {\n     }\n \n     @Test\n-    public void included_file() throws IOException {\n-        assertThat(\"not set\", config().getIncludedFileList(), is(nullValue()));\n-\n-        systemProperties.setProperty(Config.INCLUDED_FILE, \"\");\n-        assertThat(\"zero values\", config().getIncludedFileList(), is(empty()));\n-\n-        // Single file\n-        File singleTmp = File.createTempFile(\"test\",\".list\");\n-        singleTmp.deleteOnExit();\n-\n-        List<String> file = Lists.newArrayList(\"foo.java\");\n-        String delimiter = System.getProperty(\"line.separator\");\n-        Files.write(file.stream()\n-                .collect(Collectors.joining(delimiter)), singleTmp, Charsets.UTF_8);\n-\n-        systemProperties.setProperty(Config.INCLUDED_FILE, singleTmp.getAbsolutePath());\n-        assertThat(\"one value\", config().getIncludedFileList(), is(\n-                file.stream()\n-                        .map(f -> Paths.get(f))\n-                        .collect(Collectors.toList())));\n-\n-        // Multiple files\n-        File multiTmp = File.createTempFile(\"test\",\".list\");\n-        multiTmp.deleteOnExit();\n-\n-        List<String> files = Lists.newArrayList(\"foo.java\", \"bar.java\");\n-        Files.write(files.stream()\n-                .collect(Collectors.joining(delimiter)), multiTmp, Charsets.UTF_8);\n-\n-        systemProperties.setProperty(Config.INCLUDED_FILE, multiTmp.getAbsolutePath());\n-        assertThat(\"two values\", config().getIncludedFileList(), is(\n-                files.stream()\n-                        .map(f -> Paths.get(f))\n-                        .collect(Collectors.toList())));\n+    public void included_files_file() throws IOException {\n+        Path listFile = tempDir.newFile(\"list.txt\").toPath();\n+        assertThat(\"not set\", config().getIncludedFiles(), is(nullValue()));\n+\n+        Files.write(listFile, Arrays.asList(\"\", \"\", \"\")); // empty lines are ignored\n+        systemProperties.setProperty(Config.INCLUDED_FILES_FILE, listFile.toString());\n+        assertThat(\"zero values\", config().getIncludedFiles(), is(empty()));\n+\n+        Files.write(listFile, Arrays.asList(\"one.class\"));\n+        systemProperties.setProperty(Config.INCLUDED_FILES_FILE, listFile.toString());\n+        assertThat(\"one value\", config().getIncludedFiles(), is(Arrays.asList(Paths.get(\"one.class\"))));\n+\n+        Files.write(listFile, Arrays.asList(\"one.class\", \"two.class\"));\n+        systemProperties.setProperty(Config.INCLUDED_FILES_FILE, listFile.toString());\n+        assertThat(\"multiple values\", config().getIncludedFiles(), is(Arrays.asList(Paths.get(\"one.class\"), Paths.get(\"two.class\"))));\n     }\n-}\n\\ No newline at end of file\n+}\n"
    },
    {
        "commit_hash": "d3f8a33d9a772006121c74463ad10be059af05f4",
        "previous_commit_hash": "7d9941a18db91173133ab12eebaa0fafe0246eee",
        "diff_stats": {
            "additions": 7,
            "deletions": 3
        },
        "diff_content": "@@ -9,7 +9,7 @@ import org.objectweb.asm.Opcodes;\n import java.io.*;\n import java.nio.file.*;\n import java.util.*;\n-import java.util.stream.Collectors;\n+import java.util.stream.*;\n \n public class Config {\n \n@@ -130,8 +130,12 @@ public class Config {\n                 \"Uses ; or : as the path separator, see java.io.File#pathSeparatorChar\");\n     }\n \n-    public String getClasspath() {\n-        return getRequiredProperty(CLASSPATH);\n+    public List<Path> getClasspath() {\n+        String classpath = getRequiredProperty(CLASSPATH);\n+        return Stream.of(classpath.split(File.pathSeparator))\n+                .filter(path -> !path.isEmpty())\n+                .map(Paths::get)\n+                .collect(Collectors.toList());\n     }\n \n     private String getRequiredProperty(String key) {\n"
    },
    {
        "commit_hash": "d3f8a33d9a772006121c74463ad10be059af05f4",
        "previous_commit_hash": "7d9941a18db91173133ab12eebaa0fafe0246eee",
        "diff_stats": {
            "additions": 4,
            "deletions": 5
        },
        "diff_content": "@@ -20,7 +20,7 @@ public class Retrolambda {\n         boolean defaultMethodsEnabled = config.isDefaultMethodsEnabled();\n         Path inputDir = config.getInputDir();\n         Path outputDir = config.getOutputDir();\n-        String classpath = config.getClasspath();\n+        List<Path> classpath = config.getClasspath();\n         List<Path> includedFiles = config.getIncludedFiles();\n         System.out.println(\"Bytecode version: \" + bytecodeVersion + \" (\" + config.getJavaVersion() + \")\");\n         System.out.println(\"Default methods:  \" + defaultMethodsEnabled);\n@@ -92,10 +92,9 @@ public class Retrolambda {\n         Files.walkFileTree(inputDir, visitor);\n     }\n \n-    private static URL[] asUrls(String classpath) {\n-        String[] paths = classpath.split(System.getProperty(\"path.separator\"));\n-        return Arrays.asList(paths).stream()\n-                .map(s -> Paths.get(s).toUri())\n+    private static URL[] asUrls(List<Path> classpath) {\n+        return classpath.stream()\n+                .map(Path::toUri)\n                 .map(Retrolambda::uriToUrl)\n                 .toArray(URL[]::new);\n     }\n"
    },
    {
        "commit_hash": "d3f8a33d9a772006121c74463ad10be059af05f4",
        "previous_commit_hash": "7d9941a18db91173133ab12eebaa0fafe0246eee",
        "diff_stats": {
            "additions": 24,
            "deletions": 0
        },
        "diff_content": "@@ -62,6 +62,30 @@ public class ConfigTest {\n         assertThat(\"can override the default\", config().getOutputDir(), is(Paths.get(\"output dir\")));\n     }\n \n+    @Test\n+    public void classpath() {\n+        systemProperties.setProperty(Config.CLASSPATH, \"\");\n+        assertThat(\"zero values\", config().getClasspath(), is(empty()));\n+\n+        systemProperties.setProperty(Config.CLASSPATH, \"one.jar\");\n+        assertThat(\"one value\", config().getClasspath(), is(Arrays.asList(Paths.get(\"one.jar\"))));\n+\n+        systemProperties.setProperty(Config.CLASSPATH, \"one.jar\" + File.pathSeparator + \"two.jar\");\n+        assertThat(\"multiple values\", config().getClasspath(), is(Arrays.asList(Paths.get(\"one.jar\"), Paths.get(\"two.jar\"))));\n+    }\n+\n+    @Ignore // TODO\n+    @Test\n+    public void classpath_file() {\n+    }\n+\n+    @Test\n+    public void classpath_is_required() {\n+        thrown.expect(IllegalArgumentException.class);\n+        thrown.expectMessage(\"Missing required property: retrolambda.classpath\");\n+        config().getClasspath();\n+    }\n+\n     @Test\n     public void included_files() {\n         assertThat(\"not set\", config().getIncludedFiles(), is(nullValue()));\n"
    },
    {
        "commit_hash": "b4a4080a04c04ec0db3f1926d4fe7d7376def62a",
        "previous_commit_hash": "d3f8a33d9a772006121c74463ad10be059af05f4",
        "diff_stats": {
            "additions": 8,
            "deletions": 0
        },
        "diff_content": "@@ -123,6 +123,11 @@ Optional system properties:\n       Output directory into where the generated class files are written.\n       Defaults to same as retrolambda.inputDir\n \n+  retrolambda.classpathFile\n+      File listing the classpath entries.\n+      Alternative to retrolambda.classpath for avoiding the command line\n+      length limit. The file must list one file per line with UTF-8 encoding.\n+\n   retrolambda.includedFiles\n       List of files to process, instead of processing all files.\n       This is useful for a build tool to support incremental compilation.\n@@ -217,6 +222,9 @@ Version History\n \n ### Upcoming\n \n+- Added the `-Dretrolambda.classpathFile` parameter to avoid \n+  the command line length limit\n+  ([Issue #70](https://github.com/orfjackal/retrolambda/issues/70))\n - Added the `-Dretrolambda.includedFilesFile` parameter to avoid \n   the command line length limit\n   ([Pull request #74](https://github.com/orfjackal/retrolambda/pull/74))\n"
    },
    {
        "commit_hash": "b4a4080a04c04ec0db3f1926d4fe7d7376def62a",
        "previous_commit_hash": "d3f8a33d9a772006121c74463ad10be059af05f4",
        "diff_stats": {
            "additions": 32,
            "deletions": 17
        },
        "diff_content": "@@ -19,8 +19,9 @@ public class Config {\n     public static final String INPUT_DIR = PREFIX + \"inputDir\";\n     public static final String OUTPUT_DIR = PREFIX + \"outputDir\";\n     public static final String CLASSPATH = PREFIX + \"classpath\";\n+    public static final String CLASSPATH_FILE = CLASSPATH + \"File\";\n     public static final String INCLUDED_FILES = PREFIX + \"includedFiles\";\n-    public static final String INCLUDED_FILES_FILE = PREFIX + \"includedFilesFile\";\n+    public static final String INCLUDED_FILES_FILE = INCLUDED_FILES + \"File\";\n \n     private static final List<String> requiredProperties = new ArrayList<>();\n     private static final List<String> requiredPropertiesHelp = new ArrayList<>();\n@@ -101,7 +102,11 @@ public class Config {\n     }\n \n     public Path getInputDir() {\n-        return Paths.get(getRequiredProperty(INPUT_DIR));\n+        String inputDir = p.getProperty(INPUT_DIR);\n+        if (inputDir != null) {\n+            return Paths.get(inputDir);\n+        }\n+        throw new IllegalArgumentException(\"Missing required property: \" + INPUT_DIR);\n     }\n \n \n@@ -115,10 +120,10 @@ public class Config {\n \n     public Path getOutputDir() {\n         String outputDir = p.getProperty(OUTPUT_DIR);\n-        if (outputDir == null) {\n-            return getInputDir();\n+        if (outputDir != null) {\n+            return Paths.get(outputDir);\n         }\n-        return Paths.get(outputDir);\n+        return getInputDir();\n     }\n \n \n@@ -128,22 +133,32 @@ public class Config {\n         requiredParameterHelp(CLASSPATH,\n                 \"Classpath containing the original class files and their dependencies.\",\n                 \"Uses ; or : as the path separator, see java.io.File#pathSeparatorChar\");\n+        optionalParameterHelp(CLASSPATH_FILE,\n+                \"File listing the classpath entries.\",\n+                \"Alternative to \" + CLASSPATH + \" for avoiding the command line\",\n+                \"length limit. The file must list one file per line with UTF-8 encoding.\");\n     }\n \n     public List<Path> getClasspath() {\n-        String classpath = getRequiredProperty(CLASSPATH);\n-        return Stream.of(classpath.split(File.pathSeparator))\n-                .filter(path -> !path.isEmpty())\n-                .map(Paths::get)\n-                .collect(Collectors.toList());\n-    }\n-\n-    private String getRequiredProperty(String key) {\n-        String value = p.getProperty(key);\n-        if (value == null) {\n-            throw new IllegalArgumentException(\"Missing required property: \" + key);\n+        String classpath = p.getProperty(CLASSPATH);\n+        if (classpath != null) {\n+            return Stream.of(classpath.split(File.pathSeparator))\n+                    .filter(path -> !path.isEmpty())\n+                    .map(Paths::get)\n+                    .collect(Collectors.toList());\n+        }\n+        String classpathFile = p.getProperty(CLASSPATH_FILE);\n+        if (classpathFile != null) {\n+            try {\n+                return Files.readAllLines(Paths.get(classpathFile)).stream()\n+                        .filter(line -> !line.isEmpty())\n+                        .map(Paths::get)\n+                        .collect(Collectors.toList());\n+            } catch (IOException e) {\n+                throw new RuntimeException(\"Failed to read \" + CLASSPATH_FILE + \" from \" + classpathFile, e);\n+            }\n         }\n-        return value;\n+        throw new IllegalArgumentException(\"Missing required property: \" + CLASSPATH);\n     }\n \n \n"
    },
    {
        "commit_hash": "b4a4080a04c04ec0db3f1926d4fe7d7376def62a",
        "previous_commit_hash": "d3f8a33d9a772006121c74463ad10be059af05f4",
        "diff_stats": {
            "additions": 21,
            "deletions": 9
        },
        "diff_content": "@@ -74,9 +74,21 @@ public class ConfigTest {\n         assertThat(\"multiple values\", config().getClasspath(), is(Arrays.asList(Paths.get(\"one.jar\"), Paths.get(\"two.jar\"))));\n     }\n \n-    @Ignore // TODO\n     @Test\n-    public void classpath_file() {\n+    public void classpath_file() throws IOException {\n+        Path file = tempDir.newFile(\"classpath.txt\").toPath();\n+\n+        Files.write(file, Arrays.asList(\"\", \"\", \"\")); // empty lines are ignored\n+        systemProperties.setProperty(Config.CLASSPATH_FILE, file.toString());\n+        assertThat(\"zero values\", config().getClasspath(), is(empty()));\n+\n+        Files.write(file, Arrays.asList(\"one.jar\"));\n+        systemProperties.setProperty(Config.CLASSPATH_FILE, file.toString());\n+        assertThat(\"one value\", config().getClasspath(), is(Arrays.asList(Paths.get(\"one.jar\"))));\n+\n+        Files.write(file, Arrays.asList(\"one.jar\", \"two.jar\"));\n+        systemProperties.setProperty(Config.CLASSPATH_FILE, file.toString());\n+        assertThat(\"multiple values\", config().getClasspath(), is(Arrays.asList(Paths.get(\"one.jar\"), Paths.get(\"two.jar\"))));\n     }\n \n     @Test\n@@ -102,19 +114,19 @@ public class ConfigTest {\n \n     @Test\n     public void included_files_file() throws IOException {\n-        Path listFile = tempDir.newFile(\"list.txt\").toPath();\n+        Path file = tempDir.newFile(\"includedFiles.txt\").toPath();\n         assertThat(\"not set\", config().getIncludedFiles(), is(nullValue()));\n \n-        Files.write(listFile, Arrays.asList(\"\", \"\", \"\")); // empty lines are ignored\n-        systemProperties.setProperty(Config.INCLUDED_FILES_FILE, listFile.toString());\n+        Files.write(file, Arrays.asList(\"\", \"\", \"\")); // empty lines are ignored\n+        systemProperties.setProperty(Config.INCLUDED_FILES_FILE, file.toString());\n         assertThat(\"zero values\", config().getIncludedFiles(), is(empty()));\n \n-        Files.write(listFile, Arrays.asList(\"one.class\"));\n-        systemProperties.setProperty(Config.INCLUDED_FILES_FILE, listFile.toString());\n+        Files.write(file, Arrays.asList(\"one.class\"));\n+        systemProperties.setProperty(Config.INCLUDED_FILES_FILE, file.toString());\n         assertThat(\"one value\", config().getIncludedFiles(), is(Arrays.asList(Paths.get(\"one.class\"))));\n \n-        Files.write(listFile, Arrays.asList(\"one.class\", \"two.class\"));\n-        systemProperties.setProperty(Config.INCLUDED_FILES_FILE, listFile.toString());\n+        Files.write(file, Arrays.asList(\"one.class\", \"two.class\"));\n+        systemProperties.setProperty(Config.INCLUDED_FILES_FILE, file.toString());\n         assertThat(\"multiple values\", config().getIncludedFiles(), is(Arrays.asList(Paths.get(\"one.class\"), Paths.get(\"two.class\"))));\n     }\n }\n"
    },
    {
        "commit_hash": "ca49dac3a86cddd47f3b7f1bea9b94579dbe3564",
        "previous_commit_hash": "b4a4080a04c04ec0db3f1926d4fe7d7376def62a",
        "diff_stats": {
            "additions": 22,
            "deletions": 25
        },
        "diff_content": "@@ -142,25 +142,33 @@ public class Config {\n     public List<Path> getClasspath() {\n         String classpath = p.getProperty(CLASSPATH);\n         if (classpath != null) {\n-            return Stream.of(classpath.split(File.pathSeparator))\n-                    .filter(path -> !path.isEmpty())\n-                    .map(Paths::get)\n-                    .collect(Collectors.toList());\n+            return parsePathList(classpath);\n         }\n         String classpathFile = p.getProperty(CLASSPATH_FILE);\n         if (classpathFile != null) {\n-            try {\n-                return Files.readAllLines(Paths.get(classpathFile)).stream()\n-                        .filter(line -> !line.isEmpty())\n-                        .map(Paths::get)\n-                        .collect(Collectors.toList());\n-            } catch (IOException e) {\n-                throw new RuntimeException(\"Failed to read \" + CLASSPATH_FILE + \" from \" + classpathFile, e);\n-            }\n+            return readPathList(Paths.get(classpathFile));\n         }\n         throw new IllegalArgumentException(\"Missing required property: \" + CLASSPATH);\n     }\n \n+    private static List<Path> parsePathList(String paths) {\n+        return Stream.of(paths.split(File.pathSeparator))\n+                .filter(path -> !path.isEmpty())\n+                .map(Paths::get)\n+                .collect(Collectors.toList());\n+    }\n+\n+    private static List<Path> readPathList(Path file) {\n+        try {\n+            return Files.readAllLines(file).stream()\n+                    .filter(line -> !line.isEmpty())\n+                    .map(Paths::get)\n+                    .collect(Collectors.toList());\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"Failed to read \" + file, e);\n+        }\n+    }\n+\n \n     // incremental files\n \n@@ -178,22 +186,11 @@ public class Config {\n     public List<Path> getIncludedFiles() {\n         String files = p.getProperty(INCLUDED_FILES);\n         if (files != null) {\n-            return Arrays.asList(files.split(File.pathSeparator)).stream()\n-                    .filter(s -> !s.isEmpty())\n-                    .map(Paths::get)\n-                    .collect(Collectors.toList());\n+            return parsePathList(files);\n         }\n         String filesFile = p.getProperty(INCLUDED_FILES_FILE);\n         if (filesFile != null) {\n-            try {\n-                return Files.readAllLines(Paths.get(filesFile))\n-                        .stream()\n-                        .filter(path -> !path.isEmpty())\n-                        .map(Paths::get)\n-                        .collect(Collectors.toList());\n-            } catch (IOException e) {\n-                throw new RuntimeException(\"Failed to read \" + INCLUDED_FILES_FILE + \" from \" + filesFile, e);\n-            }\n+            return readPathList(Paths.get(filesFile));\n         }\n         return null;\n     }\n"
    },
    {
        "commit_hash": "7113a8471ecacee7b0c6a8743b46cff759b45395",
        "previous_commit_hash": "ca49dac3a86cddd47f3b7f1bea9b94579dbe3564",
        "diff_stats": {
            "additions": 10,
            "deletions": 12
        },
        "diff_content": "@@ -96,16 +96,7 @@ Copyright (c) 2013-2015  Esko Luontola <www.orfjackal.net>\n This software is released under the Apache License 2.0.\n The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n-Required system properties:\n-\n-  retrolambda.inputDir\n-      Input directory from where the original class files are read.\n-\n-  retrolambda.classpath\n-      Classpath containing the original class files and their dependencies.\n-      Uses ; or : as the path separator, see java.io.File#pathSeparatorChar\n-\n-Optional system properties:\n+Configurable system properties:\n \n   retrolambda.bytecodeVersion\n       Major version number for the generated bytecode. For a list, see\n@@ -119,11 +110,18 @@ Optional system properties:\n       with one execution of Retrolambda.\n       Disabled by default. Enable by setting to \"true\"\n \n+  retrolambda.inputDir (required)\n+      Input directory from where the original class files are read.\n+\n   retrolambda.outputDir\n       Output directory into where the generated class files are written.\n       Defaults to same as retrolambda.inputDir\n \n-  retrolambda.classpathFile\n+  retrolambda.classpath (required)\n+      Classpath containing the original class files and their dependencies.\n+      Uses ; or : as the path separator, see java.io.File#pathSeparatorChar\n+\n+  retrolambda.classpathFile (alternative)\n       File listing the classpath entries.\n       Alternative to retrolambda.classpath for avoiding the command line\n       length limit. The file must list one file per line with UTF-8 encoding.\n@@ -133,7 +131,7 @@ Optional system properties:\n       This is useful for a build tool to support incremental compilation.\n       Uses ; or : as the path separator, see java.io.File#pathSeparatorChar\n \n-  retrolambda.includedFilesFile\n+  retrolambda.includedFilesFile (alternative)\n       File listing the files to process, instead of processing all files.\n       Alternative to retrolambda.includedFiles for avoiding the command line\n       length limit. The file must list one file per line with UTF-8 encoding.\n"
    },
    {
        "commit_hash": "7113a8471ecacee7b0c6a8743b46cff759b45395",
        "previous_commit_hash": "ca49dac3a86cddd47f3b7f1bea9b94579dbe3564",
        "diff_stats": {
            "additions": 32,
            "deletions": 17
        },
        "diff_content": "@@ -24,8 +24,8 @@ public class Config {\n     public static final String INCLUDED_FILES_FILE = INCLUDED_FILES + \"File\";\n \n     private static final List<String> requiredProperties = new ArrayList<>();\n-    private static final List<String> requiredPropertiesHelp = new ArrayList<>();\n-    private static final List<String> optionalPropertiesHelp = new ArrayList<>();\n+    private static final Map<String, String> alternativeProperties = new HashMap<>();\n+    private static final List<String> propertiesHelp = new ArrayList<>();\n     private static final Map<Integer, String> bytecodeVersionNames = new HashMap<>();\n \n     static {\n@@ -51,13 +51,26 @@ public class Config {\n \n     private boolean hasAllRequiredProperties() {\n         for (String requiredParameter : requiredProperties) {\n-            if (p.getProperty(requiredParameter) == null) {\n+            if (!isConfigured(requiredParameter)) {\n                 return false;\n             }\n         }\n         return true;\n     }\n \n+    private boolean isConfigured(String parameter) {\n+        if (p.getProperty(parameter) != null) {\n+            return true;\n+        }\n+        for (Map.Entry<String, String> alt : alternativeProperties.entrySet()) {\n+            if (alt.getValue().equals(parameter) &&\n+                    p.getProperty(alt.getKey()) != null) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n \n     // bytecode version\n \n@@ -133,7 +146,7 @@ public class Config {\n         requiredParameterHelp(CLASSPATH,\n                 \"Classpath containing the original class files and their dependencies.\",\n                 \"Uses ; or : as the path separator, see java.io.File#pathSeparatorChar\");\n-        optionalParameterHelp(CLASSPATH_FILE,\n+        alternativeParameterHelp(CLASSPATH_FILE, CLASSPATH,\n                 \"File listing the classpath entries.\",\n                 \"Alternative to \" + CLASSPATH + \" for avoiding the command line\",\n                 \"length limit. The file must list one file per line with UTF-8 encoding.\");\n@@ -177,7 +190,7 @@ public class Config {\n                 \"List of files to process, instead of processing all files.\",\n                 \"This is useful for a build tool to support incremental compilation.\",\n                 \"Uses ; or : as the path separator, see java.io.File#pathSeparatorChar\");\n-        optionalParameterHelp(INCLUDED_FILES_FILE,\n+        alternativeParameterHelp(INCLUDED_FILES_FILE, INCLUDED_FILES,\n                 \"File listing the files to process, instead of processing all files.\",\n                 \"Alternative to \" + INCLUDED_FILES + \" for avoiding the command line\",\n                 \"length limit. The file must list one file per line with UTF-8 encoding.\");\n@@ -213,13 +226,9 @@ public class Config {\n                 \"This software is released under the Apache License 2.0.\\n\" +\n                 \"The license text is at http://www.apache.org/licenses/LICENSE-2.0\\n\" +\n                 \"\\n\" +\n-                \"Required system properties:\\n\" +\n+                \"Configurable system properties:\\n\" +\n                 \"\\n\" +\n-                requiredPropertiesHelp.stream().reduce((a, b) -> a + \"\\n\" + b).get() +\n-                \"\\n\" +\n-                \"Optional system properties:\\n\" +\n-                \"\\n\" +\n-                optionalPropertiesHelp.stream().reduce((a, b) -> a + \"\\n\" + b).get() +\n+                propertiesHelp.stream().reduce((a, b) -> a + \"\\n\" + b).get() +\n                 \"\\n\" +\n                 \"If the Java agent is used, then Retrolambda will use it to capture the\\n\" +\n                 \"lambda classes generated by Java. Otherwise Retrolambda will hook into\\n\" +\n@@ -229,18 +238,24 @@ public class Config {\n \n     private static void requiredParameterHelp(String key, String... lines) {\n         requiredProperties.add(key);\n-        requiredPropertiesHelp.add(formatPropertyHelp(key, lines));\n+        propertiesHelp.add(formatPropertyHelp(key, \"required\", lines));\n+    }\n+\n+    private static void alternativeParameterHelp(String key, String replaces, String... lines) {\n+        alternativeProperties.put(key, replaces);\n+        propertiesHelp.add(formatPropertyHelp(key, \"alternative\", lines));\n     }\n \n     private static void optionalParameterHelp(String key, String... lines) {\n-        optionalPropertiesHelp.add(formatPropertyHelp(key, lines));\n+        propertiesHelp.add(formatPropertyHelp(key, \"\", lines));\n     }\n \n-    private static String formatPropertyHelp(String key, String... lines) {\n-        String s = \"  \" + key + \"\\n\";\n+    private static String formatPropertyHelp(String key, String tag, String... lines) {\n+        tag = tag.isEmpty() ? \"\" : \" (\" + tag + \")\";\n+        String help = \"  \" + key + tag + \"\\n\";\n         for (String line : lines) {\n-            s += \"      \" + line + \"\\n\";\n+            help += \"      \" + line + \"\\n\";\n         }\n-        return s;\n+        return help;\n     }\n }\n"
    },
    {
        "commit_hash": "7113a8471ecacee7b0c6a8743b46cff759b45395",
        "previous_commit_hash": "ca49dac3a86cddd47f3b7f1bea9b94579dbe3564",
        "diff_stats": {
            "additions": 18,
            "deletions": 0
        },
        "diff_content": "@@ -28,6 +28,24 @@ public class ConfigTest {\n         return new Config(systemProperties);\n     }\n \n+    @Test\n+    public void is_fully_configured_when_required_properties_are_set() {\n+        assertThat(\"before\", config().isFullyConfigured(), is(false));\n+\n+        systemProperties.setProperty(Config.INPUT_DIR, \"\");\n+        systemProperties.setProperty(Config.CLASSPATH, \"\");\n+\n+        assertThat(\"after\", config().isFullyConfigured(), is(true));\n+    }\n+\n+    @Test\n+    public void can_use_alternative_parameter_instead_of_required_parameter() {\n+        systemProperties.setProperty(Config.INPUT_DIR, \"\");\n+        systemProperties.setProperty(Config.CLASSPATH_FILE, \"\");\n+\n+        assertThat(\"is fully configured?\", config().isFullyConfigured(), is(true));\n+    }\n+\n     @Test\n     public void bytecode_version() {\n         assertThat(\"defaults to Java 7\", config().getBytecodeVersion(), is(51));\n"
    },
    {
        "commit_hash": "fd5b63c7745eeaca99b6b8401611e5cd80d1aa25",
        "previous_commit_hash": "7113a8471ecacee7b0c6a8743b46cff759b45395",
        "diff_stats": {
            "additions": 47,
            "deletions": 21
        },
        "diff_content": "@@ -4,8 +4,9 @@\n \n package net.orfjackal.retrolambda.maven;\n \n-import com.google.common.base.Joiner;\n+import com.google.common.base.*;\n import com.google.common.collect.ImmutableMap;\n+import com.google.common.io.Files;\n import net.orfjackal.retrolambda.*;\n import org.apache.maven.artifact.DependencyResolutionRequiredException;\n import org.apache.maven.execution.MavenSession;\n@@ -143,26 +144,33 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n \n         getLog().info(\"Processing classes with Retrolambda\");\n         String retrolambdaJar = getRetrolambdaJarPath();\n-        executeMojo(\n-                plugin(groupId(\"org.apache.maven.plugins\"),\n-                        artifactId(\"maven-antrun-plugin\"),\n-                        version(\"1.7\")),\n-                goal(\"run\"),\n-                configuration(element(\n-                        \"target\",\n-                        element(\"exec\",\n-                                attributes(\n-                                        attribute(\"executable\", getJavaCommand()),\n-                                        attribute(\"failonerror\", \"true\")),\n-                                element(\"arg\", attribute(\"value\", \"-Dretrolambda.bytecodeVersion=\" + targetBytecodeVersions.get(target))),\n-                                element(\"arg\", attribute(\"value\", \"-Dretrolambda.defaultMethods=\" + defaultMethods)),\n-                                element(\"arg\", attribute(\"value\", \"-Dretrolambda.inputDir=\" + getInputDir().getAbsolutePath())),\n-                                element(\"arg\", attribute(\"value\", \"-Dretrolambda.outputDir=\" + getOutputDir().getAbsolutePath())),\n-                                element(\"arg\", attribute(\"value\", \"-Dretrolambda.classpath=\" + getClasspath())),\n-                                element(\"arg\", attribute(\"value\", \"-javaagent:\" + retrolambdaJar)),\n-                                element(\"arg\", attribute(\"value\", \"-jar\")),\n-                                element(\"arg\", attribute(\"value\", retrolambdaJar))))),\n-                executionEnvironment(project, session, pluginManager));\n+        File classpathFile = getClasspathFile();\n+        try {\n+            executeMojo(\n+                    plugin(groupId(\"org.apache.maven.plugins\"),\n+                            artifactId(\"maven-antrun-plugin\"),\n+                            version(\"1.7\")),\n+                    goal(\"run\"),\n+                    configuration(element(\n+                            \"target\",\n+                            element(\"exec\",\n+                                    attributes(\n+                                            attribute(\"executable\", getJavaCommand()),\n+                                            attribute(\"failonerror\", \"true\")),\n+                                    element(\"arg\", attribute(\"value\", \"-Dretrolambda.bytecodeVersion=\" + targetBytecodeVersions.get(target))),\n+                                    element(\"arg\", attribute(\"value\", \"-Dretrolambda.defaultMethods=\" + defaultMethods)),\n+                                    element(\"arg\", attribute(\"value\", \"-Dretrolambda.inputDir=\" + getInputDir().getAbsolutePath())),\n+                                    element(\"arg\", attribute(\"value\", \"-Dretrolambda.outputDir=\" + getOutputDir().getAbsolutePath())),\n+                                    element(\"arg\", attribute(\"value\", \"-Dretrolambda.classpathFile=\" + classpathFile)),\n+                                    element(\"arg\", attribute(\"value\", \"-javaagent:\" + retrolambdaJar)),\n+                                    element(\"arg\", attribute(\"value\", \"-jar\")),\n+                                    element(\"arg\", attribute(\"value\", retrolambdaJar))))),\n+                    executionEnvironment(project, session, pluginManager));\n+        } finally {\n+            if (!classpathFile.delete()) {\n+                getLog().warn(\"Unable to delete \" + classpathFile);\n+            }\n+        }\n     }\n \n     private void retrieveRetrolambdaJar(String version) throws MojoExecutionException {\n@@ -220,6 +228,24 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n         }\n     }\n \n+    private File getClasspathFile() {\n+        try {\n+            StringBuilder sb = new StringBuilder();\n+            for (String classpathElement : getClasspathElements()) {\n+                sb.append(classpathElement);\n+                sb.append(\"\\n\");\n+            }\n+            File file = File.createTempFile(\"retrolambda\", \"classpath\");\n+            file.deleteOnExit();\n+            Files.write(sb.toString(), file, Charsets.UTF_8);\n+            return file;\n+        } catch (DependencyResolutionRequiredException e) {\n+            throw new RuntimeException(e);\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n     private String getRetrolambdaJarPath() {\n         return getRetrolambdaJarDir() + \"/\" + getRetrolambdaJarName();\n     }\n"
    },
    {
        "commit_hash": "45f3a15e7b281f5a99d548caba5bfdfa775827bb",
        "previous_commit_hash": "fd5b63c7745eeaca99b6b8401611e5cd80d1aa25",
        "diff_stats": {
            "additions": 3,
            "deletions": 14
        },
        "diff_content": "@@ -215,14 +215,7 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n \n     private String getClasspath() {\n         try {\n-            StringBuilder sb = new StringBuilder();\n-            for (String classpathElement : getClasspathElements()) {\n-                if (sb.length() > 0) {\n-                    sb.append(File.pathSeparator);\n-                }\n-                sb.append(classpathElement);\n-            }\n-            return sb.toString();\n+            return Joiner.on(File.pathSeparator).join(getClasspathElements());\n         } catch (DependencyResolutionRequiredException e) {\n             throw new RuntimeException(e);\n         }\n@@ -230,14 +223,10 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n \n     private File getClasspathFile() {\n         try {\n-            StringBuilder sb = new StringBuilder();\n-            for (String classpathElement : getClasspathElements()) {\n-                sb.append(classpathElement);\n-                sb.append(\"\\n\");\n-            }\n+            String classpath = Joiner.on(\"\\n\").join(getClasspathElements());\n             File file = File.createTempFile(\"retrolambda\", \"classpath\");\n             file.deleteOnExit();\n-            Files.write(sb.toString(), file, Charsets.UTF_8);\n+            Files.write(classpath, file, Charsets.UTF_8);\n             return file;\n         } catch (DependencyResolutionRequiredException e) {\n             throw new RuntimeException(e);\n"
    },
    {
        "commit_hash": "611bd3ce47f03751a8ce2b10b2d3cff94a189068",
        "previous_commit_hash": "45f3a15e7b281f5a99d548caba5bfdfa775827bb",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -88,9 +88,9 @@ Your class files should now run on Java 7 or older.\n ```\n Usage: java -Dretrolambda.inputDir=? -Dretrolambda.classpath=? [-javaagent:retrolambda.jar] -jar retrolambda.jar\n \n-Retrolambda is a backporting tool for classes which use lambda expressions\n-and have been compiled with Java 8, to run on Java 7 (maybe even Java 5).\n-See https://github.com/orfjackal/retrolambda\n+Retrolambda takes Java 8 classes and backports lambda expressions and\n+some other language features to work on Java 7, 6 or 5.\n+Web site: https://github.com/orfjackal/retrolambda\n \n Copyright (c) 2013-2015  Esko Luontola <www.orfjackal.net>\n This software is released under the Apache License 2.0.\n"
    },
    {
        "commit_hash": "611bd3ce47f03751a8ce2b10b2d3cff94a189068",
        "previous_commit_hash": "45f3a15e7b281f5a99d548caba5bfdfa775827bb",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -218,9 +218,9 @@ public class Config {\n                 .get();\n         return \"Usage: java \" + options + \" [-javaagent:retrolambda.jar] -jar retrolambda.jar\\n\" +\n                 \"\\n\" +\n-                \"Retrolambda is a backporting tool for classes which use lambda expressions\\n\" +\n-                \"and have been compiled with Java 8, to run on Java 7 (maybe even Java 5).\\n\" +\n-                \"See https://github.com/orfjackal/retrolambda\\n\" +\n+                \"Retrolambda takes Java 8 classes and backports lambda expressions and\\n\" +\n+                \"some other language features to work on Java 7, 6 or 5.\\n\" +\n+                \"Web site: https://github.com/orfjackal/retrolambda\\n\" +\n                 \"\\n\" +\n                 \"Copyright (c) 2013-2015  Esko Luontola <www.orfjackal.net>\\n\" +\n                 \"This software is released under the Apache License 2.0.\\n\" +\n"
    },
    {
        "commit_hash": "665fe6a3f9c15ff67cc2641a2fd8605e9556947d",
        "previous_commit_hash": "689240e35ed3ed75c3fd9d059dfdcece3d256f5e",
        "diff_stats": {
            "additions": 6,
            "deletions": 6
        },
        "diff_content": "@@ -126,12 +126,12 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n         getLog().info(\"Processing classes with Retrolambda\");\n         try {\n             Properties p = new Properties();\n-            p.setProperty(Config.BYTECODE_VERSION, \"\" + targetBytecodeVersions.get(target));\n-            p.setProperty(Config.DEFAULT_METHODS, \"\" + defaultMethods);\n-            p.setProperty(Config.INPUT_DIR, getInputDir().getAbsolutePath());\n-            p.setProperty(Config.OUTPUT_DIR, getOutputDir().getAbsolutePath());\n-            p.setProperty(Config.CLASSPATH, getClasspath());\n-            Retrolambda.run(new Config(p));\n+            p.setProperty(SystemPropertiesConfig.BYTECODE_VERSION, \"\" + targetBytecodeVersions.get(target));\n+            p.setProperty(SystemPropertiesConfig.DEFAULT_METHODS, \"\" + defaultMethods);\n+            p.setProperty(SystemPropertiesConfig.INPUT_DIR, getInputDir().getAbsolutePath());\n+            p.setProperty(SystemPropertiesConfig.OUTPUT_DIR, getOutputDir().getAbsolutePath());\n+            p.setProperty(SystemPropertiesConfig.CLASSPATH, getClasspath());\n+            Retrolambda.run(new SystemPropertiesConfig(p));\n         } catch (Throwable t) {\n             throw new MojoExecutionException(\"Failed to run Retrolambda\", t);\n         }\n"
    },
    {
        "commit_hash": "665fe6a3f9c15ff67cc2641a2fd8605e9556947d",
        "previous_commit_hash": "689240e35ed3ed75c3fd9d059dfdcece3d256f5e",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -64,7 +64,7 @@\n                                     <arg value=\"-Dretrolambda.bytecodeVersion=50\"/>\n                                     <arg value=\"-Dretrolambda.inputDir=${project.build.outputDirectory}\"/>\n                                     <arg value=\"-Dretrolambda.classpath=${compile_classpath}\"/>\n-                                    <arg value=\"-Dretrolambda.includedFiles=${project.build.outputDirectory}/net/orfjackal/retrolambda/Main.class${path.separator}${project.build.outputDirectory}/net/orfjackal/retrolambda/Config.class${path.separator}${project.build.outputDirectory}/net/orfjackal/retrolambda/Retrolambda.class\"/>\n+                                    <arg value=\"-Dretrolambda.includedFiles=${project.build.outputDirectory}/net/orfjackal/retrolambda/Main.class${path.separator}${project.build.outputDirectory}/net/orfjackal/retrolambda/SystemPropertiesConfig.class${path.separator}${project.build.outputDirectory}/net/orfjackal/retrolambda/Retrolambda.class\"/>\n                                     <arg value=\"-cp\"/>\n                                     <arg value=\"${project.build.outputDirectory}\"/>\n                                     <arg value=\"-cp\"/>\n"
    },
    {
        "commit_hash": "665fe6a3f9c15ff67cc2641a2fd8605e9556947d",
        "previous_commit_hash": "689240e35ed3ed75c3fd9d059dfdcece3d256f5e",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -17,7 +17,7 @@ public class Main {\n             System.exit(1);\n         }\n \n-        Config config = new Config(System.getProperties());\n+        SystemPropertiesConfig config = new SystemPropertiesConfig(System.getProperties());\n         if (!config.isFullyConfigured()) {\n             System.out.print(config.getHelp());\n             return;\n"
    },
    {
        "commit_hash": "665fe6a3f9c15ff67cc2641a2fd8605e9556947d",
        "previous_commit_hash": "689240e35ed3ed75c3fd9d059dfdcece3d256f5e",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -15,7 +15,7 @@ import java.util.*;\n \n public class Retrolambda {\n \n-    public static void run(Config config) throws Throwable {\n+    public static void run(SystemPropertiesConfig config) throws Throwable {\n         int bytecodeVersion = config.getBytecodeVersion();\n         boolean defaultMethodsEnabled = config.isDefaultMethodsEnabled();\n         Path inputDir = config.getInputDir();\n"
    },
    {
        "commit_hash": "665fe6a3f9c15ff67cc2641a2fd8605e9556947d",
        "previous_commit_hash": "689240e35ed3ed75c3fd9d059dfdcece3d256f5e",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -11,7 +11,7 @@ import java.nio.file.*;\n import java.util.*;\n import java.util.stream.*;\n \n-public class Config {\n+public class SystemPropertiesConfig {\n \n     private static final String PREFIX = \"retrolambda.\";\n     public static final String BYTECODE_VERSION = PREFIX + \"bytecodeVersion\";\n@@ -41,7 +41,7 @@ public class Config {\n \n     private final Properties p;\n \n-    public Config(Properties p) {\n+    public SystemPropertiesConfig(Properties p) {\n         this.p = p;\n     }\n \n"
    },
    {
        "commit_hash": "665fe6a3f9c15ff67cc2641a2fd8605e9556947d",
        "previous_commit_hash": "689240e35ed3ed75c3fd9d059dfdcece3d256f5e",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -18,7 +18,7 @@ public class DocumentationTest {\n     @Test\n     public void README_contains_the_usage_instructions() throws IOException {\n         String readme = toString(findInClosestParentDir(\"README.md\"));\n-        String help = new Config(new Properties()).getHelp();\n+        String help = new SystemPropertiesConfig(new Properties()).getHelp();\n \n         assertTrue(\"Expected README to contain the following text:\\n\\n\" + help, readme.contains(help));\n     }\n"
    },
    {
        "commit_hash": "665fe6a3f9c15ff67cc2641a2fd8605e9556947d",
        "previous_commit_hash": "689240e35ed3ed75c3fd9d059dfdcece3d256f5e",
        "diff_stats": {
            "additions": 4,
            "deletions": 4
        },
        "diff_content": "@@ -77,11 +77,11 @@ public class RetrolambdaTest {\n     @Test\n     public void copies_resources_to_output_directory() throws Throwable {\n         Properties p = new Properties();\n-        p.setProperty(Config.INPUT_DIR, inputDir.toString());\n-        p.setProperty(Config.OUTPUT_DIR, outputDir.toString());\n-        p.setProperty(Config.CLASSPATH, \"\");\n+        p.setProperty(SystemPropertiesConfig.INPUT_DIR, inputDir.toString());\n+        p.setProperty(SystemPropertiesConfig.OUTPUT_DIR, outputDir.toString());\n+        p.setProperty(SystemPropertiesConfig.CLASSPATH, \"\");\n \n-        Retrolambda.run(new Config(p));\n+        Retrolambda.run(new SystemPropertiesConfig(p));\n \n         assertIsFile(outputDir.resolve(\"file1.txt\"));\n         assertIsFile(outputDir.resolve(\"subdir/file.txt\"));\n"
    },
    {
        "commit_hash": "665fe6a3f9c15ff67cc2641a2fd8605e9556947d",
        "previous_commit_hash": "689240e35ed3ed75c3fd9d059dfdcece3d256f5e",
        "diff_stats": {
            "additions": 23,
            "deletions": 23
        },
        "diff_content": "@@ -14,7 +14,7 @@ import java.util.*;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.*;\n \n-public class ConfigTest {\n+public class SystemPropertiesConfigTest {\n \n     @Rule\n     public final ExpectedException thrown = ExpectedException.none();\n@@ -24,24 +24,24 @@ public class ConfigTest {\n \n     private final Properties systemProperties = new Properties();\n \n-    private Config config() {\n-        return new Config(systemProperties);\n+    private SystemPropertiesConfig config() {\n+        return new SystemPropertiesConfig(systemProperties);\n     }\n \n     @Test\n     public void is_fully_configured_when_required_properties_are_set() {\n         assertThat(\"before\", config().isFullyConfigured(), is(false));\n \n-        systemProperties.setProperty(Config.INPUT_DIR, \"\");\n-        systemProperties.setProperty(Config.CLASSPATH, \"\");\n+        systemProperties.setProperty(SystemPropertiesConfig.INPUT_DIR, \"\");\n+        systemProperties.setProperty(SystemPropertiesConfig.CLASSPATH, \"\");\n \n         assertThat(\"after\", config().isFullyConfigured(), is(true));\n     }\n \n     @Test\n     public void can_use_alternative_parameter_instead_of_required_parameter() {\n-        systemProperties.setProperty(Config.INPUT_DIR, \"\");\n-        systemProperties.setProperty(Config.CLASSPATH_FILE, \"\");\n+        systemProperties.setProperty(SystemPropertiesConfig.INPUT_DIR, \"\");\n+        systemProperties.setProperty(SystemPropertiesConfig.CLASSPATH_FILE, \"\");\n \n         assertThat(\"is fully configured?\", config().isFullyConfigured(), is(true));\n     }\n@@ -51,7 +51,7 @@ public class ConfigTest {\n         assertThat(\"defaults to Java 7\", config().getBytecodeVersion(), is(51));\n         assertThat(\"human printable format\", config().getJavaVersion(), is(\"Java 7\"));\n \n-        systemProperties.setProperty(Config.BYTECODE_VERSION, \"50\");\n+        systemProperties.setProperty(SystemPropertiesConfig.BYTECODE_VERSION, \"50\");\n         assertThat(\"can override the default\", config().getBytecodeVersion(), is(50));\n         assertThat(\"human printable format\", config().getJavaVersion(), is(\"Java 6\"));\n     }\n@@ -60,7 +60,7 @@ public class ConfigTest {\n     public void default_methods() {\n         assertThat(\"defaults to disabled\", config().isDefaultMethodsEnabled(), is(false));\n \n-        systemProperties.setProperty(Config.DEFAULT_METHODS, \"true\");\n+        systemProperties.setProperty(SystemPropertiesConfig.DEFAULT_METHODS, \"true\");\n         assertThat(\"can override the default\", config().isDefaultMethodsEnabled(), is(true));\n     }\n \n@@ -73,22 +73,22 @@ public class ConfigTest {\n \n     @Test\n     public void output_directory() {\n-        systemProperties.setProperty(Config.INPUT_DIR, \"input dir\");\n+        systemProperties.setProperty(SystemPropertiesConfig.INPUT_DIR, \"input dir\");\n         assertThat(\"defaults to input dir\", config().getOutputDir(), is(Paths.get(\"input dir\")));\n \n-        systemProperties.setProperty(Config.OUTPUT_DIR, \"output dir\");\n+        systemProperties.setProperty(SystemPropertiesConfig.OUTPUT_DIR, \"output dir\");\n         assertThat(\"can override the default\", config().getOutputDir(), is(Paths.get(\"output dir\")));\n     }\n \n     @Test\n     public void classpath() {\n-        systemProperties.setProperty(Config.CLASSPATH, \"\");\n+        systemProperties.setProperty(SystemPropertiesConfig.CLASSPATH, \"\");\n         assertThat(\"zero values\", config().getClasspath(), is(empty()));\n \n-        systemProperties.setProperty(Config.CLASSPATH, \"one.jar\");\n+        systemProperties.setProperty(SystemPropertiesConfig.CLASSPATH, \"one.jar\");\n         assertThat(\"one value\", config().getClasspath(), is(Arrays.asList(Paths.get(\"one.jar\"))));\n \n-        systemProperties.setProperty(Config.CLASSPATH, \"one.jar\" + File.pathSeparator + \"two.jar\");\n+        systemProperties.setProperty(SystemPropertiesConfig.CLASSPATH, \"one.jar\" + File.pathSeparator + \"two.jar\");\n         assertThat(\"multiple values\", config().getClasspath(), is(Arrays.asList(Paths.get(\"one.jar\"), Paths.get(\"two.jar\"))));\n     }\n \n@@ -97,15 +97,15 @@ public class ConfigTest {\n         Path file = tempDir.newFile(\"classpath.txt\").toPath();\n \n         Files.write(file, Arrays.asList(\"\", \"\", \"\")); // empty lines are ignored\n-        systemProperties.setProperty(Config.CLASSPATH_FILE, file.toString());\n+        systemProperties.setProperty(SystemPropertiesConfig.CLASSPATH_FILE, file.toString());\n         assertThat(\"zero values\", config().getClasspath(), is(empty()));\n \n         Files.write(file, Arrays.asList(\"one.jar\"));\n-        systemProperties.setProperty(Config.CLASSPATH_FILE, file.toString());\n+        systemProperties.setProperty(SystemPropertiesConfig.CLASSPATH_FILE, file.toString());\n         assertThat(\"one value\", config().getClasspath(), is(Arrays.asList(Paths.get(\"one.jar\"))));\n \n         Files.write(file, Arrays.asList(\"one.jar\", \"two.jar\"));\n-        systemProperties.setProperty(Config.CLASSPATH_FILE, file.toString());\n+        systemProperties.setProperty(SystemPropertiesConfig.CLASSPATH_FILE, file.toString());\n         assertThat(\"multiple values\", config().getClasspath(), is(Arrays.asList(Paths.get(\"one.jar\"), Paths.get(\"two.jar\"))));\n     }\n \n@@ -120,13 +120,13 @@ public class ConfigTest {\n     public void included_files() {\n         assertThat(\"not set\", config().getIncludedFiles(), is(nullValue()));\n \n-        systemProperties.setProperty(Config.INCLUDED_FILES, \"\");\n+        systemProperties.setProperty(SystemPropertiesConfig.INCLUDED_FILES, \"\");\n         assertThat(\"zero values\", config().getIncludedFiles(), is(empty()));\n \n-        systemProperties.setProperty(Config.INCLUDED_FILES, \"/foo/one.class\");\n+        systemProperties.setProperty(SystemPropertiesConfig.INCLUDED_FILES, \"/foo/one.class\");\n         assertThat(\"one value\", config().getIncludedFiles(), is(Arrays.asList(Paths.get(\"/foo/one.class\"))));\n \n-        systemProperties.setProperty(Config.INCLUDED_FILES, \"/foo/one.class\" + File.pathSeparator + \"/foo/two.class\");\n+        systemProperties.setProperty(SystemPropertiesConfig.INCLUDED_FILES, \"/foo/one.class\" + File.pathSeparator + \"/foo/two.class\");\n         assertThat(\"multiple values\", config().getIncludedFiles(), is(Arrays.asList(Paths.get(\"/foo/one.class\"), Paths.get(\"/foo/two.class\"))));\n     }\n \n@@ -136,15 +136,15 @@ public class ConfigTest {\n         assertThat(\"not set\", config().getIncludedFiles(), is(nullValue()));\n \n         Files.write(file, Arrays.asList(\"\", \"\", \"\")); // empty lines are ignored\n-        systemProperties.setProperty(Config.INCLUDED_FILES_FILE, file.toString());\n+        systemProperties.setProperty(SystemPropertiesConfig.INCLUDED_FILES_FILE, file.toString());\n         assertThat(\"zero values\", config().getIncludedFiles(), is(empty()));\n \n         Files.write(file, Arrays.asList(\"one.class\"));\n-        systemProperties.setProperty(Config.INCLUDED_FILES_FILE, file.toString());\n+        systemProperties.setProperty(SystemPropertiesConfig.INCLUDED_FILES_FILE, file.toString());\n         assertThat(\"one value\", config().getIncludedFiles(), is(Arrays.asList(Paths.get(\"one.class\"))));\n \n         Files.write(file, Arrays.asList(\"one.class\", \"two.class\"));\n-        systemProperties.setProperty(Config.INCLUDED_FILES_FILE, file.toString());\n+        systemProperties.setProperty(SystemPropertiesConfig.INCLUDED_FILES_FILE, file.toString());\n         assertThat(\"multiple values\", config().getIncludedFiles(), is(Arrays.asList(Paths.get(\"one.class\"), Paths.get(\"two.class\"))));\n     }\n }\n"
    },
    {
        "commit_hash": "dee27340074a6a415226d6f70872b465dbd394da",
        "previous_commit_hash": "665fe6a3f9c15ff67cc2641a2fd8605e9556947d",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -64,7 +64,7 @@\n                                     <arg value=\"-Dretrolambda.bytecodeVersion=50\"/>\n                                     <arg value=\"-Dretrolambda.inputDir=${project.build.outputDirectory}\"/>\n                                     <arg value=\"-Dretrolambda.classpath=${compile_classpath}\"/>\n-                                    <arg value=\"-Dretrolambda.includedFiles=${project.build.outputDirectory}/net/orfjackal/retrolambda/Main.class${path.separator}${project.build.outputDirectory}/net/orfjackal/retrolambda/SystemPropertiesConfig.class${path.separator}${project.build.outputDirectory}/net/orfjackal/retrolambda/Retrolambda.class\"/>\n+                                    <arg value=\"-Dretrolambda.includedFiles=${project.build.outputDirectory}/net/orfjackal/retrolambda/Main.class${path.separator}${project.build.outputDirectory}/net/orfjackal/retrolambda/Config.class${path.separator}${project.build.outputDirectory}/net/orfjackal/retrolambda/SystemPropertiesConfig.class${path.separator}${project.build.outputDirectory}/net/orfjackal/retrolambda/Retrolambda.class\"/>\n                                     <arg value=\"-cp\"/>\n                                     <arg value=\"${project.build.outputDirectory}\"/>\n                                     <arg value=\"-cp\"/>\n"
    },
    {
        "commit_hash": "dee27340074a6a415226d6f70872b465dbd394da",
        "previous_commit_hash": "665fe6a3f9c15ff67cc2641a2fd8605e9556947d",
        "diff_stats": {
            "additions": 25,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,25 @@\n+// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+public interface Config {\n+\n+    int getBytecodeVersion();\n+\n+    String getJavaVersion();\n+\n+    boolean isDefaultMethodsEnabled();\n+\n+    Path getInputDir();\n+\n+    Path getOutputDir();\n+\n+    List<Path> getClasspath();\n+\n+    List<Path> getIncludedFiles();\n+}\n"
    },
    {
        "commit_hash": "dee27340074a6a415226d6f70872b465dbd394da",
        "previous_commit_hash": "665fe6a3f9c15ff67cc2641a2fd8605e9556947d",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -15,7 +15,7 @@ import java.util.*;\n \n public class Retrolambda {\n \n-    public static void run(SystemPropertiesConfig config) throws Throwable {\n+    public static void run(Config config) throws Throwable {\n         int bytecodeVersion = config.getBytecodeVersion();\n         boolean defaultMethodsEnabled = config.isDefaultMethodsEnabled();\n         Path inputDir = config.getInputDir();\n"
    },
    {
        "commit_hash": "dee27340074a6a415226d6f70872b465dbd394da",
        "previous_commit_hash": "665fe6a3f9c15ff67cc2641a2fd8605e9556947d",
        "diff_stats": {
            "additions": 8,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@ import java.nio.file.*;\n import java.util.*;\n import java.util.stream.*;\n \n-public class SystemPropertiesConfig {\n+public class SystemPropertiesConfig implements Config {\n \n     private static final String PREFIX = \"retrolambda.\";\n     public static final String BYTECODE_VERSION = PREFIX + \"bytecodeVersion\";\n@@ -81,10 +81,12 @@ public class SystemPropertiesConfig {\n                 \"Default value is \" + Opcodes.V1_7 + \" (i.e. Java 7)\");\n     }\n \n+    @Override\n     public int getBytecodeVersion() {\n         return Integer.parseInt(p.getProperty(BYTECODE_VERSION, \"\" + Opcodes.V1_7));\n     }\n \n+    @Override\n     public String getJavaVersion() {\n         return bytecodeVersionNames.getOrDefault(getBytecodeVersion(), \"unknown version\");\n     }\n@@ -102,6 +104,7 @@ public class SystemPropertiesConfig {\n \n     }\n \n+    @Override\n     public boolean isDefaultMethodsEnabled() {\n         return Boolean.parseBoolean(p.getProperty(DEFAULT_METHODS, \"false\"));\n     }\n@@ -114,6 +117,7 @@ public class SystemPropertiesConfig {\n                 \"Input directory from where the original class files are read.\");\n     }\n \n+    @Override\n     public Path getInputDir() {\n         String inputDir = p.getProperty(INPUT_DIR);\n         if (inputDir != null) {\n@@ -131,6 +135,7 @@ public class SystemPropertiesConfig {\n                 \"Defaults to same as \" + INPUT_DIR);\n     }\n \n+    @Override\n     public Path getOutputDir() {\n         String outputDir = p.getProperty(OUTPUT_DIR);\n         if (outputDir != null) {\n@@ -152,6 +157,7 @@ public class SystemPropertiesConfig {\n                 \"length limit. The file must list one file per line with UTF-8 encoding.\");\n     }\n \n+    @Override\n     public List<Path> getClasspath() {\n         String classpath = p.getProperty(CLASSPATH);\n         if (classpath != null) {\n@@ -196,6 +202,7 @@ public class SystemPropertiesConfig {\n                 \"length limit. The file must list one file per line with UTF-8 encoding.\");\n     }\n \n+    @Override\n     public List<Path> getIncludedFiles() {\n         String files = p.getProperty(INCLUDED_FILES);\n         if (files != null) {\n"
    },
    {
        "commit_hash": "c8aee4d97e9ba7d28abfb8ed39921290003cb9df",
        "previous_commit_hash": "dee27340074a6a415226d6f70872b465dbd394da",
        "diff_stats": {
            "additions": 0,
            "deletions": 2
        },
        "diff_content": "@@ -11,8 +11,6 @@ public interface Config {\n \n     int getBytecodeVersion();\n \n-    String getJavaVersion();\n-\n     boolean isDefaultMethodsEnabled();\n \n     Path getInputDir();\n"
    },
    {
        "commit_hash": "c8aee4d97e9ba7d28abfb8ed39921290003cb9df",
        "previous_commit_hash": "dee27340074a6a415226d6f70872b465dbd394da",
        "diff_stats": {
            "additions": 2,
            "deletions": 1
        },
        "diff_content": "@@ -7,6 +7,7 @@ package net.orfjackal.retrolambda;\n import net.orfjackal.retrolambda.files.*;\n import net.orfjackal.retrolambda.interfaces.*;\n import net.orfjackal.retrolambda.lambdas.*;\n+import net.orfjackal.retrolambda.util.Bytecode;\n \n import java.io.IOException;\n import java.net.*;\n@@ -22,7 +23,7 @@ public class Retrolambda {\n         Path outputDir = config.getOutputDir();\n         List<Path> classpath = config.getClasspath();\n         List<Path> includedFiles = config.getIncludedFiles();\n-        System.out.println(\"Bytecode version: \" + bytecodeVersion + \" (\" + config.getJavaVersion() + \")\");\n+        System.out.println(\"Bytecode version: \" + bytecodeVersion + \" (\" + Bytecode.getJavaVersion(bytecodeVersion) + \")\");\n         System.out.println(\"Default methods:  \" + defaultMethodsEnabled);\n         System.out.println(\"Input directory:  \" + inputDir);\n         System.out.println(\"Output directory: \" + outputDir);\n"
    },
    {
        "commit_hash": "c8aee4d97e9ba7d28abfb8ed39921290003cb9df",
        "previous_commit_hash": "dee27340074a6a415226d6f70872b465dbd394da",
        "diff_stats": {
            "additions": 0,
            "deletions": 17
        },
        "diff_content": "@@ -26,18 +26,6 @@ public class SystemPropertiesConfig implements Config {\n     private static final List<String> requiredProperties = new ArrayList<>();\n     private static final Map<String, String> alternativeProperties = new HashMap<>();\n     private static final List<String> propertiesHelp = new ArrayList<>();\n-    private static final Map<Integer, String> bytecodeVersionNames = new HashMap<>();\n-\n-    static {\n-        bytecodeVersionNames.put(Opcodes.V1_1, \"Java 1.1\");\n-        bytecodeVersionNames.put(Opcodes.V1_2, \"Java 1.2\");\n-        bytecodeVersionNames.put(Opcodes.V1_3, \"Java 1.3\");\n-        bytecodeVersionNames.put(Opcodes.V1_4, \"Java 1.4\");\n-        bytecodeVersionNames.put(Opcodes.V1_5, \"Java 5\");\n-        bytecodeVersionNames.put(Opcodes.V1_6, \"Java 6\");\n-        bytecodeVersionNames.put(Opcodes.V1_7, \"Java 7\");\n-        bytecodeVersionNames.put(Opcodes.V1_8, \"Java 8\");\n-    }\n \n     private final Properties p;\n \n@@ -86,11 +74,6 @@ public class SystemPropertiesConfig implements Config {\n         return Integer.parseInt(p.getProperty(BYTECODE_VERSION, \"\" + Opcodes.V1_7));\n     }\n \n-    @Override\n-    public String getJavaVersion() {\n-        return bytecodeVersionNames.getOrDefault(getBytecodeVersion(), \"unknown version\");\n-    }\n-\n \n     // default methods\n \n"
    },
    {
        "commit_hash": "c8aee4d97e9ba7d28abfb8ed39921290003cb9df",
        "previous_commit_hash": "dee27340074a6a415226d6f70872b465dbd394da",
        "diff_stats": {
            "additions": 19,
            "deletions": 0
        },
        "diff_content": "@@ -7,10 +7,29 @@ package net.orfjackal.retrolambda.util;\n import net.orfjackal.retrolambda.lambdas.Handles;\n import org.objectweb.asm.*;\n \n+import java.util.*;\n+\n import static org.objectweb.asm.Opcodes.*;\n \n public class Bytecode {\n \n+    private static final Map<Integer, String> bytecodeVersionNames = new HashMap<>();\n+\n+    static {\n+        bytecodeVersionNames.put(Opcodes.V1_1, \"Java 1.1\");\n+        bytecodeVersionNames.put(Opcodes.V1_2, \"Java 1.2\");\n+        bytecodeVersionNames.put(Opcodes.V1_3, \"Java 1.3\");\n+        bytecodeVersionNames.put(Opcodes.V1_4, \"Java 1.4\");\n+        bytecodeVersionNames.put(Opcodes.V1_5, \"Java 5\");\n+        bytecodeVersionNames.put(Opcodes.V1_6, \"Java 6\");\n+        bytecodeVersionNames.put(Opcodes.V1_7, \"Java 7\");\n+        bytecodeVersionNames.put(Opcodes.V1_8, \"Java 8\");\n+    }\n+\n+    public static String getJavaVersion(int bytecodeVersion) {\n+        return bytecodeVersionNames.getOrDefault(bytecodeVersion, \"unknown version\");\n+    }\n+\n     public static void generateDelegateMethod(ClassVisitor cv, int access, Handle method, Handle target) {\n         MethodVisitor mv = cv.visitMethod(access, method.getName(), method.getDesc(), null, null);\n         mv.visitCode();\n"
    },
    {
        "commit_hash": "c8aee4d97e9ba7d28abfb8ed39921290003cb9df",
        "previous_commit_hash": "dee27340074a6a415226d6f70872b465dbd394da",
        "diff_stats": {
            "additions": 3,
            "deletions": 2
        },
        "diff_content": "@@ -4,6 +4,7 @@\n \n package net.orfjackal.retrolambda;\n \n+import net.orfjackal.retrolambda.util.Bytecode;\n import org.junit.*;\n import org.junit.rules.*;\n \n@@ -49,11 +50,11 @@ public class SystemPropertiesConfigTest {\n     @Test\n     public void bytecode_version() {\n         assertThat(\"defaults to Java 7\", config().getBytecodeVersion(), is(51));\n-        assertThat(\"human printable format\", config().getJavaVersion(), is(\"Java 7\"));\n+        assertThat(\"human printable format\", Bytecode.getJavaVersion(config().getBytecodeVersion()), is(\"Java 7\"));\n \n         systemProperties.setProperty(SystemPropertiesConfig.BYTECODE_VERSION, \"50\");\n         assertThat(\"can override the default\", config().getBytecodeVersion(), is(50));\n-        assertThat(\"human printable format\", config().getJavaVersion(), is(\"Java 6\"));\n+        assertThat(\"human printable format\", Bytecode.getJavaVersion(config().getBytecodeVersion()), is(\"Java 6\"));\n     }\n \n     @Test\n"
    },
    {
        "commit_hash": "71a2748fcd5cccbc4f8ec4b19e6f7ddf8debb449",
        "previous_commit_hash": "c8aee4d97e9ba7d28abfb8ed39921290003cb9df",
        "diff_stats": {
            "additions": 3,
            "deletions": 0
        },
        "diff_content": "@@ -226,6 +226,9 @@ Version History\n - Added the `-Dretrolambda.includedFilesFile` parameter to avoid \n   the command line length limit\n   ([Pull request #74](https://github.com/orfjackal/retrolambda/pull/74))\n+- Made it easier to invoke Retrolambda as a library. Made `Config`\n+  an interface and fixed an assumption of using the default file system\n+  ([Pull request #71](https://github.com/orfjackal/retrolambda/pull/71))\n \n ### Retrolambda 2.0.6 (2015-09-06)\n \n"
    },
    {
        "commit_hash": "6073d0cbdb5d364c6be1843f6fc991154297c342",
        "previous_commit_hash": "71a2748fcd5cccbc4f8ec4b19e6f7ddf8debb449",
        "diff_stats": {
            "additions": 2,
            "deletions": 3
        },
        "diff_content": "@@ -28,9 +28,8 @@ public class Retrolambda {\n         System.out.println(\"Input directory:  \" + inputDir);\n         System.out.println(\"Output directory: \" + outputDir);\n         System.out.println(\"Classpath:        \" + classpath);\n-        if (includedFiles != null) {\n-            System.out.println(\"Included files:   \" + includedFiles.size());\n-        }\n+        System.out.println(\"Included files:   \" + (includedFiles != null ? includedFiles.size() : \"all\"));\n+        System.out.println(\"Agent enabled:    \" + PreMain.isAgentLoaded());\n \n         if (!Files.isDirectory(inputDir)) {\n             System.out.println(\"Nothing to do; not a directory: \" + inputDir);\n"
    },
    {
        "commit_hash": "823b0457e18137d6ff911959044939636fdac1d9",
        "previous_commit_hash": "6073d0cbdb5d364c6be1843f6fc991154297c342",
        "diff_stats": {
            "additions": 3,
            "deletions": 0
        },
        "diff_content": "@@ -229,6 +229,9 @@ Version History\n - Made it easier to invoke Retrolambda as a library. Made `Config`\n   an interface and fixed an assumption of using the default file system\n   ([Pull request #71](https://github.com/orfjackal/retrolambda/pull/71))\n+- Don't create a companion class when an interface has just\n+  a static initialization block because of constant fields\n+  ([Issue #66](https://github.com/orfjackal/retrolambda/issues/66))\n \n ### Retrolambda 2.0.6 (2015-09-06)\n \n"
    },
    {
        "commit_hash": "823b0457e18137d6ff911959044939636fdac1d9",
        "previous_commit_hash": "6073d0cbdb5d364c6be1843f6fc991154297c342",
        "diff_stats": {
            "additions": 1,
            "deletions": 4
        },
        "diff_content": "@@ -14,6 +14,7 @@ import java.lang.annotation.*;\n import java.util.*;\n import java.util.concurrent.Callable;\n \n+import static net.orfjackal.retrolambda.test.TestUtil.companionOf;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.*;\n import static org.junit.Assume.assumeThat;\n@@ -605,8 +606,4 @@ public class DefaultMethodsTest {\n             }\n         };\n     }\n-\n-    private static Class<?> companionOf(Class<?> itf) throws ClassNotFoundException {\n-        return Class.forName(itf.getName() + \"$\");\n-    }\n }\n"
    },
    {
        "commit_hash": "823b0457e18137d6ff911959044939636fdac1d9",
        "previous_commit_hash": "6073d0cbdb5d364c6be1843f6fc991154297c342",
        "diff_stats": {
            "additions": 11,
            "deletions": 0
        },
        "diff_content": "@@ -12,6 +12,7 @@ import java.util.Comparator;\n import java.util.concurrent.Callable;\n import java.util.stream.Stream;\n \n+import static net.orfjackal.retrolambda.test.TestUtil.*;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.*;\n import static org.junit.Assume.assumeThat;\n@@ -105,4 +106,14 @@ public class InterfaceStaticMethodsTest {\n         // it should only fail when this line is executed\n         Comparator.naturalOrder();\n     }\n+\n+    @Test\n+    public void will_not_generate_a_companion_class_when_the_interface_has_just_constant_fields() {\n+        assertThat(InterfaceWithConstants.FOO, is(3));\n+        assertClassDoesNotExist(companionNameOf(InterfaceWithConstants.class));\n+    }\n+\n+    private interface InterfaceWithConstants {\n+        int FOO = (int) Math.sqrt(9); // a constant which needs to be calculated in a static initialization block\n+    }\n }\n"
    },
    {
        "commit_hash": "823b0457e18137d6ff911959044939636fdac1d9",
        "previous_commit_hash": "6073d0cbdb5d364c6be1843f6fc991154297c342",
        "diff_stats": {
            "additions": 3,
            "deletions": 9
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -6,6 +6,8 @@ package net.orfjackal.retrolambda.test;\n \n import org.junit.Test;\n \n+import static net.orfjackal.retrolambda.test.TestUtil.assertClassExists;\n+\n public class LambdaClassesTest {\n \n     @Test\n@@ -16,14 +18,6 @@ public class LambdaClassesTest {\n         assertClassExists(Dummy2.class.getName() + \"$$Lambda$2\");\n     }\n \n-    private static void assertClassExists(String className) {\n-        try {\n-            Class.forName(className);\n-        } catch (ClassNotFoundException e) {\n-            throw new AssertionError(\"Expected a class to exists, but it did not: \" + className, e);\n-        }\n-    }\n-\n \n     @SuppressWarnings(\"UnusedDeclaration\")\n     private class Dummy1 {\n"
    },
    {
        "commit_hash": "823b0457e18137d6ff911959044939636fdac1d9",
        "previous_commit_hash": "6073d0cbdb5d364c6be1843f6fc991154297c342",
        "diff_stats": {
            "additions": 33,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,33 @@\n+// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.test;\n+\n+public class TestUtil {\n+\n+    public static void assertClassExists(String className) {\n+        try {\n+            Class.forName(className);\n+        } catch (ClassNotFoundException e) {\n+            throw new AssertionError(\"Expected a class to exists, but it did not: \" + className, e);\n+        }\n+    }\n+\n+    public static void assertClassDoesNotExist(String className) {\n+        try {\n+            Class.forName(className);\n+            throw new AssertionError(\"Expected a class to not exists, but it did: \" + className);\n+        } catch (ClassNotFoundException e) {\n+            // OK\n+        }\n+    }\n+\n+    public static Class<?> companionOf(Class<?> itf) throws ClassNotFoundException {\n+        return Class.forName(companionNameOf(itf));\n+    }\n+\n+    public static String companionNameOf(Class<?> itf) {\n+        return itf.getName() + \"$\";\n+    }\n+}\n"
    },
    {
        "commit_hash": "823b0457e18137d6ff911959044939636fdac1d9",
        "previous_commit_hash": "6073d0cbdb5d364c6be1843f6fc991154297c342",
        "diff_stats": {
            "additions": 5,
            "deletions": 1
        },
        "diff_content": "@@ -81,7 +81,7 @@ public class ClassHierarchyAnalyzer {\n                     relocatedMethods.put(method, new MethodRef(H_INVOKESTATIC, companion, name, Bytecode.prependArgumentType(desc, Type.getObjectType(owner))));\n                     c.enableCompanionClass();\n \n-                } else if (isStaticMethod(access)) {\n+                } else if (isStaticMethod(access) && !isStaticInitializer(name)) {\n                     relocatedMethods.put(method, new MethodRef(H_INVOKESTATIC, companion, name, desc));\n                     c.enableCompanionClass();\n                 }\n@@ -94,6 +94,10 @@ public class ClassHierarchyAnalyzer {\n         return name.equals(\"<init>\");\n     }\n \n+    private static boolean isStaticInitializer(String name) {\n+        return name.equals(\"<clinit>\");\n+    }\n+\n     private static boolean isAbstractMethod(int access) {\n         return Flags.hasFlag(access, ACC_ABSTRACT);\n     }\n"
    },
    {
        "commit_hash": "6155b8fd01ea9335fb0b67b2e890551c26f4546c",
        "previous_commit_hash": "823b0457e18137d6ff911959044939636fdac1d9",
        "diff_stats": {
            "additions": 5,
            "deletions": 28
        },
        "diff_content": "@@ -5,12 +5,13 @@\n package net.orfjackal.retrolambda.interfaces;\n \n import net.orfjackal.retrolambda.lambdas.Handles;\n-import net.orfjackal.retrolambda.util.*;\n+import net.orfjackal.retrolambda.util.Bytecode;\n import org.objectweb.asm.*;\n \n import java.util.*;\n \n import static java.util.stream.Collectors.toList;\n+import static net.orfjackal.retrolambda.util.Flags.*;\n import static org.objectweb.asm.Opcodes.*;\n \n public class ClassHierarchyAnalyzer {\n@@ -26,7 +27,7 @@ public class ClassHierarchyAnalyzer {\n         ClassInfo c = new ClassInfo(cr);\n         classes.put(c.type, c);\n \n-        if (Flags.hasFlag(cr.getAccess(), ACC_INTERFACE)) {\n+        if (isInterface(cr.getAccess())) {\n             analyzeInterface(c, cr);\n         } else {\n             analyzeClass(c, cr);\n@@ -81,7 +82,7 @@ public class ClassHierarchyAnalyzer {\n                     relocatedMethods.put(method, new MethodRef(H_INVOKESTATIC, companion, name, Bytecode.prependArgumentType(desc, Type.getObjectType(owner))));\n                     c.enableCompanionClass();\n \n-                } else if (isStaticMethod(access) && !isStaticInitializer(name)) {\n+                } else if (isStaticMethod(access) && !isStaticInitializer(name, desc, access)) {\n                     relocatedMethods.put(method, new MethodRef(H_INVOKESTATIC, companion, name, desc));\n                     c.enableCompanionClass();\n                 }\n@@ -90,23 +91,7 @@ public class ClassHierarchyAnalyzer {\n         }, ClassReader.SKIP_CODE);\n     }\n \n-    private static boolean isConstructor(String name) {\n-        return name.equals(\"<init>\");\n-    }\n-\n-    private static boolean isStaticInitializer(String name) {\n-        return name.equals(\"<clinit>\");\n-    }\n-\n-    private static boolean isAbstractMethod(int access) {\n-        return Flags.hasFlag(access, ACC_ABSTRACT);\n-    }\n-\n-    private static boolean isStaticMethod(int access) {\n-        return Flags.hasFlag(access, ACC_STATIC);\n-    }\n-\n-    private static boolean isDefaultMethod(int access) {\n+    public static boolean isDefaultMethod(int access) {\n         return !isAbstractMethod(access)\n                 && !isStaticMethod(access)\n                 && isPublicMethod(access);\n@@ -118,14 +103,6 @@ public class ClassHierarchyAnalyzer {\n                 && isPrivateMethod(access);\n     }\n \n-    private static boolean isPublicMethod(int access) {\n-        return Flags.hasFlag(access, ACC_PUBLIC);\n-    }\n-\n-    private static boolean isPrivateMethod(int access) {\n-        return Flags.hasFlag(access, ACC_PRIVATE);\n-    }\n-\n     public List<ClassInfo> getInterfaces() {\n         return classes.values()\n                 .stream()\n"
    },
    {
        "commit_hash": "6155b8fd01ea9335fb0b67b2e890551c26f4546c",
        "previous_commit_hash": "823b0457e18137d6ff911959044939636fdac1d9",
        "diff_stats": {
            "additions": 1,
            "deletions": 3
        },
        "diff_content": "@@ -9,8 +9,6 @@ import org.objectweb.asm.*;\n \n import java.util.*;\n \n-import static org.objectweb.asm.Opcodes.ACC_INTERFACE;\n-\n public class ClassInfo {\n \n     public final ClassReader reader;\n@@ -63,6 +61,6 @@ public class ClassInfo {\n     }\n \n     public boolean isInterface() {\n-        return Flags.hasFlag(access, ACC_INTERFACE);\n+        return Flags.isInterface(access);\n     }\n }\n"
    },
    {
        "commit_hash": "6155b8fd01ea9335fb0b67b2e890551c26f4546c",
        "previous_commit_hash": "823b0457e18137d6ff911959044939636fdac1d9",
        "diff_stats": {
            "additions": 6,
            "deletions": 5
        },
        "diff_content": "@@ -4,9 +4,10 @@\n \n package net.orfjackal.retrolambda.interfaces;\n \n-import net.orfjackal.retrolambda.util.*;\n+import net.orfjackal.retrolambda.util.Bytecode;\n import org.objectweb.asm.*;\n \n+import static net.orfjackal.retrolambda.util.Flags.*;\n import static org.objectweb.asm.Opcodes.*;\n \n public class ExtractInterfaceCompanionClass extends ClassVisitor {\n@@ -30,15 +31,15 @@ public class ExtractInterfaceCompanionClass extends ClassVisitor {\n \n     @Override\n     public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n-        if (Flags.hasFlag(access, ACC_ABSTRACT)) {\n+        if (isAbstractMethod(access)) {\n             // do not copy abstract methods to the companion class\n             return null;\n         }\n-        if (Flags.isClassInitializer(name, desc, access)) {\n+        if (isStaticInitializer(name, desc, access)) {\n             // we won't copy constant fields from the interface, so a class initializer won't be needed\n             return null;\n         }\n-        if (Flags.hasFlag(access, ACC_PRIVATE)) {\n+        if (isPrivateMethod(access)) {\n             // XXX: Possibly a lambda impl method, which is private (static or instance). It is the easiest for us\n             // to make it visible, which should be quite safe because nothing inherits the companion class.\n             // The clean solution would be to generate an access method for it, but due to the location in code\n@@ -46,7 +47,7 @@ public class ExtractInterfaceCompanionClass extends ClassVisitor {\n             // information from one transformation to another.\n             access &= ~ACC_PRIVATE;\n         }\n-        if (!Flags.hasFlag(access, ACC_STATIC)) {\n+        if (isInstanceMethod(access)) {\n             // default method; make static and take 'this' as the first argument\n             access |= ACC_STATIC;\n             // TODO: this adding of the first argument is duplicated in ClassHierarchyAnalyzer\n"
    },
    {
        "commit_hash": "6155b8fd01ea9335fb0b67b2e890551c26f4546c",
        "previous_commit_hash": "823b0457e18137d6ff911959044939636fdac1d9",
        "diff_stats": {
            "additions": 3,
            "deletions": 5
        },
        "diff_content": "@@ -4,10 +4,10 @@\n \n package net.orfjackal.retrolambda.interfaces;\n \n-import net.orfjackal.retrolambda.util.Flags;\n import org.objectweb.asm.*;\n import org.objectweb.asm.tree.MethodNode;\n \n+import static net.orfjackal.retrolambda.util.Flags.*;\n import static org.objectweb.asm.Opcodes.*;\n \n public class RemoveDefaultMethodBodies extends ClassVisitor {\n@@ -30,13 +30,11 @@ public class RemoveDefaultMethodBodies extends ClassVisitor {\n     }\n \n     private static boolean isPrivateInstanceMethod(int access) {\n-        return Flags.hasFlag(access, ACC_PRIVATE)\n-                && !Flags.hasFlag(access, ACC_STATIC);\n+        return isPrivateMethod(access) && isInstanceMethod(access);\n     }\n \n     private static boolean isDefaultMethod(int access) {\n-        return !Flags.hasFlag(access, ACC_ABSTRACT)\n-                && !Flags.hasFlag(access, ACC_STATIC);\n+        return isConcreteMethod(access) && isInstanceMethod(access);\n     }\n \n     private static class RemoveMethodBody extends MethodNode {\n"
    },
    {
        "commit_hash": "6155b8fd01ea9335fb0b67b2e890551c26f4546c",
        "previous_commit_hash": "823b0457e18137d6ff911959044939636fdac1d9",
        "diff_stats": {
            "additions": 3,
            "deletions": 7
        },
        "diff_content": "@@ -4,10 +4,10 @@\n \n package net.orfjackal.retrolambda.interfaces;\n \n-import net.orfjackal.retrolambda.util.Flags;\n import org.objectweb.asm.*;\n \n-import static org.objectweb.asm.Opcodes.*;\n+import static net.orfjackal.retrolambda.util.Flags.*;\n+import static org.objectweb.asm.Opcodes.ASM5;\n \n public class RemoveStaticMethods extends ClassVisitor {\n \n@@ -17,14 +17,10 @@ public class RemoveStaticMethods extends ClassVisitor {\n \n     @Override\n     public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n-        if (isStaticMethod(access) && !Flags.isClassInitializer(name, desc, access)) {\n+        if (isStaticMethod(access) && !isStaticInitializer(name, desc, access)) {\n             return null;\n         } else {\n             return super.visitMethod(access, name, desc, signature, exceptions);\n         }\n     }\n-\n-    private static boolean isStaticMethod(int access) {\n-        return Flags.hasFlag(access, ACC_STATIC);\n-    }\n }\n"
    },
    {
        "commit_hash": "6155b8fd01ea9335fb0b67b2e890551c26f4546c",
        "previous_commit_hash": "823b0457e18137d6ff911959044939636fdac1d9",
        "diff_stats": {
            "additions": 6,
            "deletions": 7
        },
        "diff_content": "@@ -4,10 +4,9 @@\n \n package net.orfjackal.retrolambda.interfaces;\n \n-import net.orfjackal.retrolambda.util.Flags;\n import org.objectweb.asm.*;\n \n-import static org.objectweb.asm.Opcodes.*;\n+import static net.orfjackal.retrolambda.util.Flags.*;\n \n public class WarnAboutDefaultAndStaticMethods extends ClassVisitor {\n \n@@ -19,7 +18,7 @@ public class WarnAboutDefaultAndStaticMethods extends ClassVisitor {\n \n     @Override\n     public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n-        if (!Flags.hasFlag(access, ACC_INTERFACE)) {\n+        if (!isInterface(access)) {\n             throw new IllegalArgumentException(name + \" is not an interface\");\n         }\n         interfaceName = name;\n@@ -33,14 +32,14 @@ public class WarnAboutDefaultAndStaticMethods extends ClassVisitor {\n         // - static methods\n         // - bridge methods\n         // Allowed by Java 7:\n-        // - class initializer methods (for initializing constants)\n-        if (Flags.hasFlag(access, ACC_STATIC)) {\n-            if (!Flags.isClassInitializer(name, desc, access) &&\n+        // - static initialization blocks (for initializing constants)\n+        if (isStaticMethod(access)) {\n+            if (!isStaticInitializer(name, desc, access) &&\n                     !name.startsWith(\"lambda$\")) {\n                 printWarning(\"a static method\", name);\n             }\n         } else {\n-            if (!Flags.hasFlag(access, ACC_ABSTRACT)) {\n+            if (!isAbstractMethod(access)) {\n                 printWarning(\"a default method\", name);\n             }\n         }\n"
    },
    {
        "commit_hash": "6155b8fd01ea9335fb0b67b2e890551c26f4546c",
        "previous_commit_hash": "823b0457e18137d6ff911959044939636fdac1d9",
        "diff_stats": {
            "additions": 3,
            "deletions": 2
        },
        "diff_content": "@@ -4,13 +4,14 @@\n \n package net.orfjackal.retrolambda.lambdas;\n \n-import net.orfjackal.retrolambda.util.*;\n+import net.orfjackal.retrolambda.util.Bytecode;\n import org.objectweb.asm.*;\n \n import java.lang.reflect.Field;\n import java.util.*;\n import java.util.concurrent.atomic.AtomicInteger;\n \n+import static net.orfjackal.retrolambda.util.Flags.isInterface;\n import static org.objectweb.asm.Opcodes.*;\n \n public class BackportLambdaInvocations extends ClassVisitor {\n@@ -57,7 +58,7 @@ public class BackportLambdaInvocations extends ClassVisitor {\n         if (!implMethod.getOwner().equals(className)) {\n             return implMethod;\n         }\n-        if (Flags.hasFlag(classAccess, ACC_INTERFACE)) {\n+        if (isInterface(classAccess)) {\n             // the method will be relocated to a companion class\n             return implMethod;\n         }\n"
    },
    {
        "commit_hash": "6155b8fd01ea9335fb0b67b2e890551c26f4546c",
        "previous_commit_hash": "823b0457e18137d6ff911959044939636fdac1d9",
        "diff_stats": {
            "additions": 45,
            "deletions": 3
        },
        "diff_content": "@@ -4,7 +4,7 @@\n \n package net.orfjackal.retrolambda.util;\n \n-import static org.objectweb.asm.Opcodes.ACC_STATIC;\n+import static org.objectweb.asm.Opcodes.*;\n \n public class Flags {\n \n@@ -12,9 +12,51 @@ public class Flags {\n         return (subject & flag) == flag;\n     }\n \n-    public static boolean isClassInitializer(String name, String desc, int methodAccess) {\n+    // classes\n+\n+    public static boolean isInterface(int access) {\n+        return hasFlag(access, ACC_INTERFACE);\n+    }\n+\n+    // initialization\n+\n+    public static boolean isConstructor(String name) {\n+        return name.equals(\"<init>\");\n+    }\n+\n+    public static boolean isStaticInitializer(String name, String desc, int access) {\n         return name.equals(\"<clinit>\") &&\n                 desc.equals(\"()V\") &&\n-                hasFlag(methodAccess, ACC_STATIC);\n+                hasFlag(access, ACC_STATIC);\n+    }\n+\n+    // concrete vs abstract\n+\n+    public static boolean isConcreteMethod(int access) {\n+        return !isAbstractMethod(access);\n+    }\n+\n+    public static boolean isAbstractMethod(int access) {\n+        return hasFlag(access, ACC_ABSTRACT);\n+    }\n+\n+    // instance vs static\n+\n+    public static boolean isInstanceMethod(int access) {\n+        return !isStaticMethod(access);\n+    }\n+\n+    public static boolean isStaticMethod(int access) {\n+        return hasFlag(access, ACC_STATIC);\n+    }\n+\n+    // visibility\n+\n+    public static boolean isPublicMethod(int access) {\n+        return hasFlag(access, ACC_PUBLIC);\n+    }\n+\n+    public static boolean isPrivateMethod(int access) {\n+        return hasFlag(access, ACC_PRIVATE);\n     }\n }\n"
    },
    {
        "commit_hash": "26b2938cbdb116c348827513dd7e3bfc2f9ebc1c",
        "previous_commit_hash": "6155b8fd01ea9335fb0b67b2e890551c26f4546c",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -42,7 +42,7 @@\n     <properties>\n         <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n         <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n-        <minimumMavenVersion>3.1</minimumMavenVersion>\n+        <minimumMavenVersion>3.2</minimumMavenVersion>\n         <testJavaHome>${env.JAVA7_HOME}</testJavaHome>\n         <testBytecodeTarget>1.7</testBytecodeTarget>\n         <testFork>false</testFork>\n"
    },
    {
        "commit_hash": "ada90d2283a46dd39dc5507d5b01df60d80813dc",
        "previous_commit_hash": "26b2938cbdb116c348827513dd7e3bfc2f9ebc1c",
        "diff_stats": {
            "additions": 15,
            "deletions": 0
        },
        "diff_content": "@@ -23,3 +23,18 @@ To run all combinations of test configurations, use the script:\n     ./scripts/build.sh\n \n Finally copy the executable JAR from the `retrolambda/target/` directory.\n+\n+\n+Using the Docker-based Development Environment\n+----------------------------------------------\n+\n+To avoid having to install all the Java versions on your computer, there is a\n+Docker image for building Retrolambda.\n+\n+The image is already in Docker Hub, but it can also be built locally with:\n+\n+    make\n+\n+To run a shell inside the container:\n+\n+    make shell\n"
    },
    {
        "commit_hash": "ada90d2283a46dd39dc5507d5b01df60d80813dc",
        "previous_commit_hash": "26b2938cbdb116c348827513dd7e3bfc2f9ebc1c",
        "diff_stats": {
            "additions": 33,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,33 @@\n+#\n+# Makefile to manage this project's development environment.\n+#\n+\n+TAG=luontola/retrolambda-dev\n+NAME=wrapping-retrolambda-shell\n+\n+# Directory that this Makefile is in\n+mkfile_path := $(abspath $(lastword $(MAKEFILE_LIST)))\n+current_path := $(dir $(mkfile_path))\n+\n+# Builds the development docker file\n+docker-build:\n+\tdocker build --tag=$(TAG) ./dev\n+\n+# Clean this docker image\n+docker-clean:\n+\t-docker rmi $(TAG)\n+\n+# Start a development shell\n+shell:\n+\tmkdir -p ~/.m2\n+\tdocker run --rm \\\n+\t\t--name=$(NAME) \\\n+\t\t-P=true \\\n+\t\t-v ~/.m2/repository:/root/.m2/repository \\\n+\t\t-v ~/.m2/settings.xml:/root/.m2/settings.xml \\\n+\t\t-v $(current_path):/project \\\n+\t\t-it $(TAG) /bin/bash\n+\n+# Attach a new terminal to the already running shell\n+shell-attach:\n+\tdocker exec -it -u=$(USER) $(NAME) /bin/bash\n"
    },
    {
        "commit_hash": "ada90d2283a46dd39dc5507d5b01df60d80813dc",
        "previous_commit_hash": "26b2938cbdb116c348827513dd7e3bfc2f9ebc1c",
        "diff_stats": {
            "additions": 31,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,31 @@\n+FROM centos:7\n+\n+# Install all supported JDK versions\n+RUN curl -L --header \"Cookie: oraclelicense=accept-securebackup-cookie\" \\\n+\t\thttp://download.oracle.com/otn-pub/java/jdk/1.5.0_22/jdk-1_5_0_22-linux-amd64-rpm.bin \\\n+\t\t-o jdk-1_5_0_22-linux-amd64-rpm.bin \\\n+\t&& chmod u+x jdk-1_5_0_22-linux-amd64-rpm.bin \\\n+\t&& echo yes | ./jdk-1_5_0_22-linux-amd64-rpm.bin \\\n+\t&& rm -v jdk-1_5_0_22-linux-amd64* \\\n+\t&& yum -y install \\\n+\t\tjava-1.6.0-openjdk-devel \\\n+\t\tjava-1.7.0-openjdk-devel \\\n+\t\tjava-1.8.0-openjdk-devel \\\n+\t&& yum clean all\n+ENV JAVA5_HOME=/usr/java/jdk1.5.0_22\n+ENV JAVA6_HOME=/usr/lib/jvm/java-1.6.0\n+ENV JAVA7_HOME=/usr/lib/jvm/java-1.7.0\n+ENV JAVA8_HOME=/usr/lib/jvm/java-1.8.0\n+ENV JAVA_HOME=$JAVA8_HOME\n+\n+# Install Maven\n+RUN curl http://archive.apache.org/dist/maven/maven-3/3.2.5/binaries/apache-maven-3.2.5-bin.tar.gz \\\n+\t\t-o apache-maven-3.2.5-bin.tar.gz \\\n+\t&& tar -xzf apache-maven-3.2.5-bin.tar.gz -C /opt \\\n+\t&& rm -v apache-maven-3.2.5-bin.tar.gz \\\n+\t&& ln -s /opt/apache-maven-3.2.5/bin/mvn /usr/local/bin/ \\\n+\t&& mkdir /root/.m2\n+COPY toolchains.xml /root/.m2/\n+\n+RUN mkdir /project\n+WORKDIR /project\n"
    },
    {
        "commit_hash": "ada90d2283a46dd39dc5507d5b01df60d80813dc",
        "previous_commit_hash": "26b2938cbdb116c348827513dd7e3bfc2f9ebc1c",
        "diff_stats": {
            "additions": 42,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,42 @@\n+<toolchains>\n+  <toolchain>\n+    <type>jdk</type>\n+    <provides>\n+      <version>1.5</version>\n+      <vendor>sun</vendor>\n+    </provides>\n+    <configuration>\n+      <jdkHome>/usr/java/jdk1.5.0_22</jdkHome>\n+    </configuration>\n+  </toolchain>\n+  <toolchain>\n+    <type>jdk</type>\n+    <provides>\n+      <version>1.6</version>\n+      <vendor>openjdk</vendor>\n+    </provides>\n+    <configuration>\n+      <jdkHome>/usr/lib/jvm/java-1.6.0</jdkHome>\n+    </configuration>\n+  </toolchain>\n+  <toolchain>\n+    <type>jdk</type>\n+    <provides>\n+      <version>1.7</version>\n+      <vendor>openjdk</vendor>\n+    </provides>\n+    <configuration>\n+      <jdkHome>/usr/lib/jvm/java-1.7.0</jdkHome>\n+    </configuration>\n+  </toolchain>\n+  <toolchain>\n+    <type>jdk</type>\n+    <provides>\n+      <version>1.8</version>\n+      <vendor>openjdk</vendor>\n+    </provides>\n+    <configuration>\n+      <jdkHome>/usr/lib/jvm/java-1.8.0</jdkHome>\n+    </configuration>\n+  </toolchain>\n+</toolchains>\n"
    },
    {
        "commit_hash": "34a1c182b7c344d46d2cb98bc451667b8db6d165",
        "previous_commit_hash": "ada90d2283a46dd39dc5507d5b01df60d80813dc",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -220,10 +220,10 @@ Version History\n \n ### Upcoming\n \n-- Added the `-Dretrolambda.classpathFile` parameter to avoid \n+- Added the `-Dretrolambda.classpathFile` parameter to avoid\n   the command line length limit\n   ([Issue #70](https://github.com/orfjackal/retrolambda/issues/70))\n-- Added the `-Dretrolambda.includedFilesFile` parameter to avoid \n+- Added the `-Dretrolambda.includedFilesFile` parameter to avoid\n   the command line length limit\n   ([Pull request #74](https://github.com/orfjackal/retrolambda/pull/74))\n - Made it easier to invoke Retrolambda as a library. Made `Config`\n@@ -235,7 +235,7 @@ Version History\n \n ### Retrolambda 2.0.6 (2015-09-06)\n \n-- Fixed method references to constructors causing VerifyError on Android \n+- Fixed method references to constructors causing VerifyError on Android\n   ([Issue #67](https://github.com/orfjackal/retrolambda/issues/67))\n \n ### Retrolambda 2.0.5 (2015-07-19)\n"
    },
    {
        "commit_hash": "b567e19e8e6413e84c9913fc0cad8f9855084a63",
        "previous_commit_hash": "34a1c182b7c344d46d2cb98bc451667b8db6d165",
        "diff_stats": {
            "additions": 0,
            "deletions": 2
        },
        "diff_content": "@@ -5,8 +5,6 @@ SCRIPTS=`dirname \"$0\"`\n DESCRIPTION=\"$1\"\n set -x\n \n-${SCRIPTS}/build.sh\n-\n rm -rfv staging\n \n mvn clean deploy \\\n"
    },
    {
        "commit_hash": "dbe9fa570c56a0dc3c1ccb5376cb01cd503a66d4",
        "previous_commit_hash": "b567e19e8e6413e84c9913fc0cad8f9855084a63",
        "diff_stats": {
            "additions": 15,
            "deletions": 15
        },
        "diff_content": "@@ -1,23 +1,13 @@\n #!/bin/bash\n set -eux\n \n-# Test the forking mechanism\n+# Run end-to-end tests against all supported Java versions\n \n mvn clean verify \\\n     --errors \\\n-    -P fork,noDefaultMethods\n+    -P noDefaultMethods\n mvn clean verify \\\n-    --errors \\\n-    -P fork\n-\n-# The Maven plugin's minimum requirement is Java 6,\n-# but then the plugin must force forking the process\n-\n-JAVA_HOME=\"$JAVA6_HOME\" mvn clean verify \\\n-    --errors \\\n-    -P java6\n-\n-# Run end-to-end tests against all supported Java versions\n+    --errors\n \n mvn clean verify \\\n     --errors \\\n@@ -33,8 +23,18 @@ mvn clean verify \\\n     --errors \\\n     -P java5\n \n+# Test the forking mechanism\n+\n mvn clean verify \\\n     --errors \\\n-    -P noDefaultMethods\n+    -P fork,noDefaultMethods\n mvn clean verify \\\n-    --errors\n+    --errors \\\n+    -P fork\n+\n+# The Maven plugin's minimum requirement is Java 6,\n+# but then the plugin must force forking the process\n+\n+JAVA_HOME=\"$JAVA6_HOME\" mvn clean verify \\\n+    --errors \\\n+    -P java6\n"
    },
    {
        "commit_hash": "60bcc67bcd80a4897f7734f1425f9298787f18c4",
        "previous_commit_hash": "dbe9fa570c56a0dc3c1ccb5376cb01cd503a66d4",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -273,6 +273,7 @@ Version History\n   methods which are placed in the interface's companion class, to avoid\n   them getting out of sync with their erased method descriptors\n   ([Issue #48](https://github.com/orfjackal/retrolambda/issues/48))\n+- Improved error messages: report which class crashed Retrolambda \n \n ### Retrolambda 2.0.1 (2015-04-06)\n \n"
    },
    {
        "commit_hash": "60bcc67bcd80a4897f7734f1425f9298787f18c4",
        "previous_commit_hash": "dbe9fa570c56a0dc3c1ccb5376cb01cd503a66d4",
        "diff_stats": {
            "additions": 22,
            "deletions": 14
        },
        "diff_content": "@@ -99,27 +99,35 @@ public class Transformers {\n     }\n \n     private byte[] transform(ClassNode node, ClassVisitorChain chain) {\n-        return transform(node::accept, chain);\n+        return transform(node.name, node::accept, chain);\n     }\n \n     private byte[] transform(ClassReader reader, ClassVisitorChain chain) {\n-        return transform(cv -> reader.accept(cv, 0), chain);\n+        return transform(reader.getClassName(), cv -> reader.accept(cv, 0), chain);\n     }\n \n-    private byte[] transform(Consumer<ClassVisitor> reader, ClassVisitorChain chain) {\n-        ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n-        ClassVisitor next = writer;\n+    private byte[] transform(String className, Consumer<ClassVisitor> reader, ClassVisitorChain chain) {\n+        try {\n+            ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n+            ClassVisitor next = writer;\n \n-        next = new LowerBytecodeVersion(next, targetVersion);\n-        if (targetVersion < Opcodes.V1_7) {\n-            next = new SwallowSuppressedExceptions(next);\n-            next = new RemoveMethodHandlesLookupReferences(next);\n-        }\n-        next = new FixInvokeStaticOnInterfaceMethod(next);\n-        next = chain.wrap(next);\n+            next = new LowerBytecodeVersion(next, targetVersion);\n+            if (targetVersion < Opcodes.V1_7) {\n+                next = new SwallowSuppressedExceptions(next);\n+                next = new RemoveMethodHandlesLookupReferences(next);\n+            }\n+            next = new FixInvokeStaticOnInterfaceMethod(next);\n+            next = chain.wrap(next);\n+\n+            reader.accept(next);\n+            return writer.toByteArray();\n \n-        reader.accept(next);\n-        return writer.toByteArray();\n+        } catch (Throwable t) {\n+            if (className != null) {\n+                className = className.replace('/', '.');\n+            }\n+            throw new RuntimeException(\"Failed to transform class \" + className, t);\n+        }\n     }\n \n     private interface ClassVisitorChain {\n"
    },
    {
        "commit_hash": "a1c10ccfc92698ba636172967a5065baf1737986",
        "previous_commit_hash": "60bcc67bcd80a4897f7734f1425f9298787f18c4",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -126,7 +126,7 @@ public class Transformers {\n             if (className != null) {\n                 className = className.replace('/', '.');\n             }\n-            throw new RuntimeException(\"Failed to transform class \" + className, t);\n+            throw new RuntimeException(\"Failed to backport class: \" + className, t);\n         }\n     }\n \n"
    },
    {
        "commit_hash": "a1c10ccfc92698ba636172967a5065baf1737986",
        "previous_commit_hash": "60bcc67bcd80a4897f7734f1425f9298787f18c4",
        "diff_stats": {
            "additions": 7,
            "deletions": 7
        },
        "diff_content": "@@ -8,6 +8,8 @@ import net.orfjackal.retrolambda.Transformers;\n import net.orfjackal.retrolambda.files.OutputDirectory;\n import org.objectweb.asm.ClassReader;\n \n+import java.io.IOException;\n+\n public class LambdaClassSaver {\n \n     private final OutputDirectory saver;\n@@ -25,14 +27,12 @@ public class LambdaClassSaver {\n     }\n \n     private void reifyLambdaClass(String className, byte[] bytecode) {\n+        System.out.println(\"Saving lambda class: \" + className);\n+        bytecode = transformers.backportLambdaClass(new ClassReader(bytecode));\n         try {\n-            System.out.println(\"Saving lambda class: \" + className);\n-            saver.writeClass(transformers.backportLambdaClass(new ClassReader(bytecode)));\n-\n-        } catch (Throwable t) {\n-            // print to stdout to keep in sync with other log output\n-            System.out.println(\"ERROR: Failed to backport lambda class: \" + className);\n-            t.printStackTrace(System.out);\n+            saver.writeClass(bytecode);\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n         }\n     }\n }\n"
    },
    {
        "commit_hash": "7e26014ac3ace5fe0e7a507c77b4e59581214559",
        "previous_commit_hash": "a1c10ccfc92698ba636172967a5065baf1737986",
        "diff_stats": {
            "additions": 0,
            "deletions": 3
        },
        "diff_content": "@@ -123,9 +123,6 @@ public class Transformers {\n             return writer.toByteArray();\n \n         } catch (Throwable t) {\n-            if (className != null) {\n-                className = className.replace('/', '.');\n-            }\n             throw new RuntimeException(\"Failed to backport class: \" + className, t);\n         }\n     }\n"
    },
    {
        "commit_hash": "abba5ba1ff22d599f6dde6fcb694f95826593178",
        "previous_commit_hash": "7e26014ac3ace5fe0e7a507c77b4e59581214559",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -25,7 +25,7 @@ public class Main {\n         try {\n             Retrolambda.run(config);\n         } catch (Throwable t) {\n-            System.out.println(\"Error! Failed to transform some classes\");\n+            System.out.println(\"Error! Failed to run Retrolambda\");\n             t.printStackTrace(System.out);\n             System.exit(1);\n         }\n"
    },
    {
        "commit_hash": "abba5ba1ff22d599f6dde6fcb694f95826593178",
        "previous_commit_hash": "7e26014ac3ace5fe0e7a507c77b4e59581214559",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -44,7 +44,7 @@ public class LambdaClassDumper implements AutoCloseable {\n         if (dumperField != null) {\n             try {\n                 dumperField.set(null, null);\n-            } catch (Exception e) {\n+            } catch (IllegalArgumentException | IllegalAccessException e) {\n                 throw new RuntimeException(e);\n             }\n         }\n"
    },
    {
        "commit_hash": "8e6148f938ce242504bc139a5898605ee13ca1f3",
        "previous_commit_hash": "abba5ba1ff22d599f6dde6fcb694f95826593178",
        "diff_stats": {
            "additions": 3,
            "deletions": 1
        },
        "diff_content": "@@ -232,6 +232,9 @@ Version History\n - Don't create a companion class when an interface has just\n   a static initialization block because of constant fields\n   ([Issue #66](https://github.com/orfjackal/retrolambda/issues/66))\n+- Improved error messages: report the name of the class or lambda method which\n+  crashed Retrolambda\n+  ([Issue #69](https://github.com/orfjackal/retrolambda/issues/69))\n \n ### Retrolambda 2.0.6 (2015-09-06)\n \n@@ -273,7 +276,6 @@ Version History\n   methods which are placed in the interface's companion class, to avoid\n   them getting out of sync with their erased method descriptors\n   ([Issue #48](https://github.com/orfjackal/retrolambda/issues/48))\n-- Improved error messages: report which class crashed Retrolambda \n \n ### Retrolambda 2.0.1 (2015-04-06)\n \n"
    },
    {
        "commit_hash": "8e6148f938ce242504bc139a5898605ee13ca1f3",
        "previous_commit_hash": "abba5ba1ff22d599f6dde6fcb694f95826593178",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -39,7 +39,7 @@ public class LambdaReifier {\n             return getLambdaFactoryMethod();\n \n         } catch (Throwable t) {\n-            throw new RuntimeException(t);\n+            throw new RuntimeException(\"Failed to backport lambda or method reference: \" + lambdaImplMethod, t);\n         } finally {\n             resetGlobals();\n         }\n"
    },
    {
        "commit_hash": "217668857e2856aace1d5d7e129be99150ce143e",
        "previous_commit_hash": "8e6148f938ce242504bc139a5898605ee13ca1f3",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -51,7 +51,7 @@ To run Retrolambda using Maven, add the following to your pom.xml:\n <plugin>\n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>retrolambda-maven-plugin</artifactId>\n-    <version>2.0.6</version>\n+    <version>2.1.0</version>\n     <executions>\n         <execution>\n             <goals>\n@@ -218,7 +218,7 @@ optimizations to that mechanism may break Retrolambda.\n Version History\n ---------------\n \n-### Upcoming\n+### Retrolambda 2.1.0 (2015-12-19)\n \n - Added the `-Dretrolambda.classpathFile` parameter to avoid\n   the command line length limit\n"
    },
    {
        "commit_hash": "217668857e2856aace1d5d7e129be99150ce143e",
        "previous_commit_hash": "8e6148f938ce242504bc139a5898605ee13ca1f3",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.7-SNAPSHOT</version>\n+        <version>2.1.0</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "217668857e2856aace1d5d7e129be99150ce143e",
        "previous_commit_hash": "8e6148f938ce242504bc139a5898605ee13ca1f3",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>2.0.7-SNAPSHOT</version>\n+    <version>2.1.0</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "217668857e2856aace1d5d7e129be99150ce143e",
        "previous_commit_hash": "8e6148f938ce242504bc139a5898605ee13ca1f3",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.7-SNAPSHOT</version>\n+        <version>2.1.0</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "217668857e2856aace1d5d7e129be99150ce143e",
        "previous_commit_hash": "8e6148f938ce242504bc139a5898605ee13ca1f3",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.7-SNAPSHOT</version>\n+        <version>2.1.0</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "217668857e2856aace1d5d7e129be99150ce143e",
        "previous_commit_hash": "8e6148f938ce242504bc139a5898605ee13ca1f3",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.0.7-SNAPSHOT</version>\n+        <version>2.1.0</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "6371ddaa52262d3e42262ad0a409bf0d435eeb10",
        "previous_commit_hash": "217668857e2856aace1d5d7e129be99150ce143e",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.1.0</version>\n+        <version>2.1.1-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "6371ddaa52262d3e42262ad0a409bf0d435eeb10",
        "previous_commit_hash": "217668857e2856aace1d5d7e129be99150ce143e",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>2.1.0</version>\n+    <version>2.1.1-SNAPSHOT</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "6371ddaa52262d3e42262ad0a409bf0d435eeb10",
        "previous_commit_hash": "217668857e2856aace1d5d7e129be99150ce143e",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.1.0</version>\n+        <version>2.1.1-SNAPSHOT</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "6371ddaa52262d3e42262ad0a409bf0d435eeb10",
        "previous_commit_hash": "217668857e2856aace1d5d7e129be99150ce143e",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.1.0</version>\n+        <version>2.1.1-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "6371ddaa52262d3e42262ad0a409bf0d435eeb10",
        "previous_commit_hash": "217668857e2856aace1d5d7e129be99150ce143e",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.1.0</version>\n+        <version>2.1.1-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "b8fdfa467de2b61b8e6fa0bdc2b4c79e8bb5576e",
        "previous_commit_hash": "6371ddaa52262d3e42262ad0a409bf0d435eeb10",
        "diff_stats": {
            "additions": 28,
            "deletions": 4
        },
        "diff_content": "@@ -6,7 +6,11 @@ package net.orfjackal.retrolambda.test;\n \n import org.junit.Test;\n \n+import java.lang.reflect.Method;\n+import java.util.*;\n+\n import static net.orfjackal.retrolambda.test.TestUtil.assertClassExists;\n+import static org.junit.Assert.assertTrue;\n \n public class LambdaClassesTest {\n \n@@ -18,10 +22,31 @@ public class LambdaClassesTest {\n         assertClassExists(Dummy2.class.getName() + \"$$Lambda$2\");\n     }\n \n+    @Test\n+    public void capturing_lambda_contain_no_unexpected_methods() throws ClassNotFoundException {\n+        List<String> expected = new ArrayList<>(Arrays.asList(\"lambdaFactory$\", \"run\"));\n+        Class<?> cls = Class.forName(Dummy1.class.getName() + \"$$Lambda$1\");\n+        for (Method method : cls.getDeclaredMethods()) {\n+            assertTrue(method.getName() + \" not expected\", expected.remove(method.getName()));\n+        }\n+        assertTrue(\"Missing methods: \" + expected, expected.isEmpty());\n+    }\n+\n+    @Test\n+    public void non_capturing_lambda_contain_no_unexpected_methods() throws ClassNotFoundException {\n+        List<String> expected = new ArrayList<>(Arrays.asList(\"lambdaFactory$\", \"run\"));\n+        Class<?> cls = Class.forName(Dummy2.class.getName() + \"$$Lambda$1\");\n+        for (Method method : cls.getDeclaredMethods()) {\n+            assertTrue(method.getName() + \" not expected\", expected.remove(method.getName()));\n+        }\n+        assertTrue(\"Missing methods: \" + expected, expected.isEmpty());\n+    }\n+\n \n     @SuppressWarnings(\"UnusedDeclaration\")\n     private class Dummy1 {\n         private Dummy1() {\n+            // Non-capturing lambdas\n             Runnable lambda1 = () -> {\n             };\n             Runnable lambda2 = () -> {\n@@ -32,10 +57,9 @@ public class LambdaClassesTest {\n     @SuppressWarnings(\"UnusedDeclaration\")\n     private class Dummy2 {\n         private Dummy2() {\n-            Runnable lambda1 = () -> {\n-            };\n-            Runnable lambda2 = () -> {\n-            };\n+            // Capturing lambdas\n+            Runnable lambda1 = () -> System.out.println(hashCode());\n+            Runnable lambda2 = () -> System.out.println(hashCode());\n         }\n     }\n }\n"
    },
    {
        "commit_hash": "b8fdfa467de2b61b8e6fa0bdc2b4c79e8bb5576e",
        "previous_commit_hash": "6371ddaa52262d3e42262ad0a409bf0d435eeb10",
        "diff_stats": {
            "additions": 3,
            "deletions": 0
        },
        "diff_content": "@@ -45,6 +45,9 @@ public class BackportLambdaClass extends ClassVisitor {\n         if (LambdaNaming.isSerializationHook(access, name, desc)) {\n             return null; // remove serialization hooks; we serialize lambda instances as-is\n         }\n+        if (LambdaNaming.isPlatformFactoryMethod(access, name, desc, factoryMethod.getDesc())) {\n+            return null; // remove the JVM's factory method which will not be unused\n+        }\n         MethodVisitor next = super.visitMethod(access, name, desc, signature, exceptions);\n         next = new RemoveMagicLambdaConstructorCall(next);\n         next = new CallPrivateImplMethodsViaAccessMethods(next);\n"
    },
    {
        "commit_hash": "b8fdfa467de2b61b8e6fa0bdc2b4c79e8bb5576e",
        "previous_commit_hash": "6371ddaa52262d3e42262ad0a409bf0d435eeb10",
        "diff_stats": {
            "additions": 6,
            "deletions": 0
        },
        "diff_content": "@@ -31,4 +31,10 @@ public class LambdaNaming {\n                 && desc.equals(\"(Ljava/lang/invoke/SerializedLambda;)Ljava/lang/Object;\")\n                 && Flags.hasFlag(access, ACC_PRIVATE | ACC_STATIC | ACC_SYNTHETIC);\n     }\n+\n+    public static boolean isPlatformFactoryMethod(int access, String name, String desc, String targetDesc) {\n+        return name.equals(\"get$Lambda\")\n+                && desc.equals(targetDesc)\n+                && Flags.hasFlag(access, ACC_PRIVATE | ACC_STATIC);\n+    }\n }\n"
    },
    {
        "commit_hash": "20f959c7b144593262089837657a3c17459d283d",
        "previous_commit_hash": "543960b6e64626968336f6b1c369145d423add4f",
        "diff_stats": {
            "additions": 50,
            "deletions": 27
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2016 Esko Luontola <www.orfjackal.net>\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -10,7 +10,8 @@ import java.lang.reflect.Method;\n import java.util.*;\n \n import static net.orfjackal.retrolambda.test.TestUtil.assertClassExists;\n-import static org.junit.Assert.assertTrue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n \n public class LambdaClassesTest {\n \n@@ -22,31 +23,9 @@ public class LambdaClassesTest {\n         assertClassExists(Dummy2.class.getName() + \"$$Lambda$2\");\n     }\n \n-    @Test\n-    public void capturing_lambda_contain_no_unexpected_methods() throws ClassNotFoundException {\n-        List<String> expected = new ArrayList<>(Arrays.asList(\"lambdaFactory$\", \"run\"));\n-        Class<?> cls = Class.forName(Dummy1.class.getName() + \"$$Lambda$1\");\n-        for (Method method : cls.getDeclaredMethods()) {\n-            assertTrue(method.getName() + \" not expected\", expected.remove(method.getName()));\n-        }\n-        assertTrue(\"Missing methods: \" + expected, expected.isEmpty());\n-    }\n-\n-    @Test\n-    public void non_capturing_lambda_contain_no_unexpected_methods() throws ClassNotFoundException {\n-        List<String> expected = new ArrayList<>(Arrays.asList(\"lambdaFactory$\", \"run\"));\n-        Class<?> cls = Class.forName(Dummy2.class.getName() + \"$$Lambda$1\");\n-        for (Method method : cls.getDeclaredMethods()) {\n-            assertTrue(method.getName() + \" not expected\", expected.remove(method.getName()));\n-        }\n-        assertTrue(\"Missing methods: \" + expected, expected.isEmpty());\n-    }\n-\n-\n     @SuppressWarnings(\"UnusedDeclaration\")\n     private class Dummy1 {\n         private Dummy1() {\n-            // Non-capturing lambdas\n             Runnable lambda1 = () -> {\n             };\n             Runnable lambda2 = () -> {\n@@ -57,9 +36,53 @@ public class LambdaClassesTest {\n     @SuppressWarnings(\"UnusedDeclaration\")\n     private class Dummy2 {\n         private Dummy2() {\n-            // Capturing lambdas\n-            Runnable lambda1 = () -> System.out.println(hashCode());\n-            Runnable lambda2 = () -> System.out.println(hashCode());\n+            Runnable lambda1 = () -> {\n+            };\n+            Runnable lambda2 = () -> {\n+            };\n+        }\n+    }\n+\n+\n+    @Test\n+    public void capturing_lambda_classes_contain_no_unnecessary_methods() throws ClassNotFoundException {\n+        Set<String> expected = new HashSet<>(Arrays.asList(\"lambdaFactory$\", \"run\"));\n+\n+        Class<?> lambdaClass = Class.forName(Capturing.class.getName() + \"$$Lambda$1\");\n+\n+        Set<String> actual = new HashSet<>();\n+        for (Method method : lambdaClass.getDeclaredMethods()) {\n+            actual.add(method.getName());\n+        }\n+        assertThat(actual, is(expected));\n+    }\n+\n+    @SuppressWarnings(\"UnusedDeclaration\")\n+    private class Capturing {\n+        private Capturing() {\n+            Runnable lambda = () -> System.out.println(hashCode());\n+        }\n+    }\n+\n+\n+    @Test\n+    public void non_capturing_lambda_classes_contain_no_unnecessary_methods() throws ClassNotFoundException {\n+        Set<String> expected = new HashSet<>(Arrays.asList(\"lambdaFactory$\", \"run\"));\n+\n+        Class<?> lambdaClass = Class.forName(NonCapturing.class.getName() + \"$$Lambda$1\");\n+\n+        Set<String> actual = new HashSet<>();\n+        for (Method method : lambdaClass.getDeclaredMethods()) {\n+            actual.add(method.getName());\n+        }\n+        assertThat(actual, is(expected));\n+    }\n+\n+    @SuppressWarnings(\"UnusedDeclaration\")\n+    private class NonCapturing {\n+        private NonCapturing() {\n+            Runnable lambda = () -> {\n+            };\n         }\n     }\n }\n"
    },
    {
        "commit_hash": "365b81989333e76915976206073a34c759386e2d",
        "previous_commit_hash": "20f959c7b144593262089837657a3c17459d283d",
        "diff_stats": {
            "additions": 12,
            "deletions": 2
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2016 Esko Luontola <www.orfjackal.net>\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -110,13 +110,23 @@ public class LambdaTest extends SuperClass {\n     }\n \n     @Test\n-    public void method_references_to_virtual_methods() throws Exception {\n+    public void method_references_to_virtual_methods_on_local_variables() throws Exception {\n         String foo = \"foo\";\n         Callable<String> ref = foo::toUpperCase;\n \n         assertThat(ref.call(), is(\"FOO\"));\n     }\n \n+    @Test\n+    public void method_references_to_virtual_methods_on_instance_variables() throws Exception {\n+        Callable<String> ref = instanceVarFoo::toUpperCase;\n+\n+        assertThat(ref.call(), is(\"FOO\"));\n+    }\n+\n+    @SuppressWarnings(\"FieldCanBeLocal\")\n+    private String instanceVarFoo = \"foo\";\n+\n     @Test\n     public void method_references_to_interface_methods() throws Exception {\n         List<String> foos = Arrays.asList(\"foo\");\n"
    },
    {
        "commit_hash": "e8623d439723162f4e30e131f66ed28bc6fa6c82",
        "previous_commit_hash": "365b81989333e76915976206073a34c759386e2d",
        "diff_stats": {
            "additions": 38,
            "deletions": 19
        },
        "diff_content": "@@ -5,6 +5,7 @@\n package net.orfjackal.retrolambda.lambdas;\n \n import org.objectweb.asm.*;\n+import org.objectweb.asm.tree.*;\n \n import static org.objectweb.asm.Opcodes.*;\n \n@@ -50,7 +51,7 @@ public class BackportLambdaClass extends ClassVisitor {\n         }\n         MethodVisitor next = super.visitMethod(access, name, desc, signature, exceptions);\n         next = new RemoveMagicLambdaConstructorCall(next);\n-        next = new CallPrivateImplMethodsViaAccessMethods(next);\n+        next = new CallPrivateImplMethodsViaAccessMethods(access, name, desc, signature, exceptions, next);\n         return next;\n     }\n \n@@ -131,10 +132,13 @@ public class BackportLambdaClass extends ClassVisitor {\n         }\n     }\n \n-    private class CallPrivateImplMethodsViaAccessMethods extends MethodVisitor {\n+    private class CallPrivateImplMethodsViaAccessMethods extends MethodNode {\n+        private final MethodVisitor next;\n \n-        public CallPrivateImplMethodsViaAccessMethods(MethodVisitor next) {\n-            super(ASM5, next);\n+        public CallPrivateImplMethodsViaAccessMethods(int access, String name, String desc, String signature,\n+                                                      String[] exceptions, MethodVisitor next) {\n+            super(ASM5, access, name, desc, signature, exceptions);\n+            this.next = next;\n         }\n \n         @Override\n@@ -146,30 +150,45 @@ public class BackportLambdaClass extends ClassVisitor {\n             if (owner.equals(implMethod.getOwner())\n                     && name.equals(implMethod.getName())\n                     && desc.equals(implMethod.getDesc())) {\n+\n+                if (implMethod.getTag() == H_NEWINVOKESPECIAL\n+                        && accessMethod.getTag() == H_INVOKESTATIC) {\n+                    // The impl is a private constructor which is called through an access method.\n+                    // The current method already did NEW an instance, but we won't use it because\n+                    // the access method will also instantiate it. The JVM would be OK with a non-empty\n+                    // stack on ARETURN, but it causes a VerifyError on Android, so here we remove the\n+                    // unused instance from the stack.\n+                    boolean found = false;\n+                    for (int i = instructions.size() - 1; i >= 1; i--) {\n+                        AbstractInsnNode maybeNew = instructions.get(i - 1);\n+                        AbstractInsnNode maybeDup = instructions.get(i);\n+                        if (maybeNew.getOpcode() == NEW && maybeDup.getOpcode() == DUP) {\n+                            instructions.remove(maybeNew);\n+                            instructions.remove(maybeDup);\n+                            found = true;\n+                            break;\n+                        }\n+                    }\n+                    if (!found) {\n+                        throw new IllegalStateException(\n+                                \"Expected to find NEW, DUP instructions preceding NEWINVOKESPECIAL. Please file this as a bug.\");\n+                    }\n+                }\n+\n                 super.visitMethodInsn(\n                         Handles.getOpcode(accessMethod),\n                         accessMethod.getOwner(),\n                         accessMethod.getName(),\n                         accessMethod.getDesc(),\n                         accessMethod.getTag() == H_INVOKEINTERFACE);\n-\n-                if (implMethod.getTag() == H_NEWINVOKESPECIAL\n-                        && accessMethod.getTag() == H_INVOKESTATIC) {\n-                    // The impl is a private constructor which is called through an access method.\n-                    // XXX: The current method already did NEW an instance, but we won't use it because\n-                    // the access method will also instantiate it.\n-                    // - The JVM would be OK with a non-empty stack on ARETURN, but it causes a VerifyError\n-                    //   on Android, so here we remove the unused instance from the stack.\n-                    // - We could improve this backporter so that it would remove the unnecessary\n-                    //   \"NEW, DUP\" instructions, but that would be complicated.\n-                    super.visitVarInsn(ASTORE, 1);\n-                    super.visitInsn(POP);\n-                    super.visitInsn(POP);\n-                    super.visitVarInsn(ALOAD, 1);\n-                }\n             } else {\n                 super.visitMethodInsn(opcode, owner, name, desc, itf);\n             }\n         }\n+\n+        @Override\n+        public void visitEnd() {\n+            accept(next);\n+        }\n     }\n }\n"
    },
    {
        "commit_hash": "0c13aa4c5420eed780238581a49d5d70ead75fbc",
        "previous_commit_hash": "365b81989333e76915976206073a34c759386e2d",
        "diff_stats": {
            "additions": 95,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,95 @@\n+// Copyright 2016 The Retrolambda Authors. All Rights Reserved.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package net.orfjackal.retrolambda.test;\n+\n+import com.google.common.base.*;\n+import com.google.common.io.ByteStreams;\n+import org.apache.commons.lang.SystemUtils;\n+import org.junit.Test;\n+import org.objectweb.asm.*;\n+import org.objectweb.asm.util.*;\n+\n+import java.io.*;\n+import java.util.Objects;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class RequireNonNullTest {\n+\n+    static class Foo {\n+        Object test(Object x) {\n+            return Objects.requireNonNull(x);\n+        }\n+    }\n+\n+    @Test\n+    public void throwsNPE() throws Exception {\n+        byte[] bytes;\n+        String path = Foo.class.getName().replace('.', '/') + \".class\";\n+        try (InputStream is = getClass().getClassLoader().getResourceAsStream(path)) {\n+            bytes = ByteStreams.toByteArray(is);\n+        }\n+        String actual = dumpMethod(bytes, \"test\");\n+        if (SystemUtils.isJavaVersionAtLeast(1.7f)) {\n+            assertEquals(\n+                    \"// access flags 0x0\\n\"\n+                    + \"test(Ljava/lang/Object;)Ljava/lang/Object;\\n\"\n+                    + \"ALOAD 1\\n\"\n+                    + \"INVOKESTATIC java/util/Objects.requireNonNull (Ljava/lang/Object;)Ljava/lang/Object;\\n\"\n+                    + \"ARETURN\\n\"\n+                    + \"MAXSTACK = 1\\n\"\n+                    + \"MAXLOCALS = 2\",\n+                    actual);\n+        } else {\n+             assertEquals(\n+                    \"// access flags 0x0\\n\"\n+                    + \"test(Ljava/lang/Object;)Ljava/lang/Object;\\n\"\n+                    + \"ALOAD 1\\n\"\n+                    + \"DUP\\n\"\n+                    + \"INVOKEVIRTUAL java/lang/Object.getClass ()Ljava/lang/Class;\\n\"\n+                    + \"POP\\n\"\n+                    + \"ARETURN\\n\"\n+                    + \"MAXSTACK = 2\\n\"\n+                    + \"MAXLOCALS = 2\",\n+                    actual);\n+        }\n+    }\n+\n+    static String dumpMethod(byte[] bytes, final String methodName) throws Exception {\n+        Textifier textifier = new Textifier();\n+        StringWriter sw = new StringWriter();\n+        final ClassVisitor tcv = new TraceClassVisitor(null, textifier, new PrintWriter(sw, true));\n+        ClassVisitor cv =\n+                new ClassVisitor(Opcodes.ASM5) {\n+                    @Override\n+                    public MethodVisitor visitMethod(\n+                            int access,\n+                            String name,\n+                            String desc,\n+                            String signature,\n+                            String[] exceptions) {\n+                        if (!name.equals(methodName)) {\n+                            return super.visitMethod(access, name, desc, signature, exceptions);\n+                        }\n+                        return tcv.visitMethod(access, name, desc, signature, exceptions);\n+                    }\n+                };\n+        ClassReader cr = new ClassReader(bytes);\n+        cr.accept(cv, ClassReader.SKIP_DEBUG | ClassReader.SKIP_FRAMES);\n+        textifier.print(new PrintWriter(sw, true));\n+        return Joiner.on('\\n')\n+                .join(Splitter.on('\\n').omitEmptyStrings().trimResults().split(sw.toString()));\n+    }\n+}\n"
    },
    {
        "commit_hash": "0c13aa4c5420eed780238581a49d5d70ead75fbc",
        "previous_commit_hash": "365b81989333e76915976206073a34c759386e2d",
        "diff_stats": {
            "additions": 2,
            "deletions": 0
        },
        "diff_content": "@@ -6,6 +6,7 @@ package net.orfjackal.retrolambda;\n \n import net.orfjackal.retrolambda.interfaces.*;\n import net.orfjackal.retrolambda.lambdas.*;\n+import net.orfjackal.retrolambda.requirenonnull.RequireNonNull;\n import net.orfjackal.retrolambda.trywithresources.SwallowSuppressedExceptions;\n import org.objectweb.asm.*;\n import org.objectweb.asm.tree.ClassNode;\n@@ -115,6 +116,7 @@ public class Transformers {\n             if (targetVersion < Opcodes.V1_7) {\n                 next = new SwallowSuppressedExceptions(next);\n                 next = new RemoveMethodHandlesLookupReferences(next);\n+                next = new RequireNonNull(next);\n             }\n             next = new FixInvokeStaticOnInterfaceMethod(next);\n             next = chain.wrap(next);\n"
    },
    {
        "commit_hash": "0c13aa4c5420eed780238581a49d5d70ead75fbc",
        "previous_commit_hash": "365b81989333e76915976206073a34c759386e2d",
        "diff_stats": {
            "additions": 57,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,57 @@\n+// Copyright 2016 The Retrolambda Authors. All Rights Reserved.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package net.orfjackal.retrolambda.requirenonnull;\n+\n+import org.objectweb.asm.*;\n+\n+/**\n+ * Rewrites calls to {@code Objects.requireNonNull}, which is only available in JDK 7 and above.\n+ *\n+ * <p>Starting in JDK 9, javac uses {@code requireNonNull} for synthetic null-checks\n+ * (see <a href=\"http://bugs.openjdk.java.net/browse/JDK-8074306\">JDK-8074306</a>).\n+ */\n+public class RequireNonNull extends ClassVisitor {\n+\n+    public RequireNonNull(ClassVisitor next) {\n+        super(Opcodes.ASM5, next);\n+    }\n+\n+    @Override\n+    public MethodVisitor visitMethod(\n+            int access, String name, String desc, String signature, String[] exceptions) {\n+        MethodVisitor next = super.visitMethod(access, name, desc, signature, exceptions);\n+        return new MethodVisitor(Opcodes.ASM5, next) {\n+            @Override\n+            public void visitMethodInsn(\n+                    int opcode, String owner, String name, String desc, boolean itf) {\n+                if (opcode == Opcodes.INVOKESTATIC\n+                        && owner.equals(\"java/util/Objects\")\n+                        && name.equals(\"requireNonNull\")\n+                        && desc.equals(\"(Ljava/lang/Object;)Ljava/lang/Object;\")) {\n+                    super.visitInsn(Opcodes.DUP);\n+                    super.visitMethodInsn(\n+                            Opcodes.INVOKEVIRTUAL,\n+                            \"java/lang/Object\",\n+                            \"getClass\",\n+                            \"()Ljava/lang/Class;\",\n+                            false);\n+                    super.visitInsn(Opcodes.POP);\n+                } else {\n+                    super.visitMethodInsn(opcode, owner, name, desc, itf);\n+                }\n+            }\n+        };\n+    }\n+}\n"
    },
    {
        "commit_hash": "605a10acf6aec9449ce5792068dd733dc62ab336",
        "previous_commit_hash": "365b81989333e76915976206073a34c759386e2d",
        "diff_stats": {
            "additions": 26,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,26 @@\n+#!/bin/bash\n+#\n+# Deploy a jar, source jar, and javadoc jar to Sonatype's snapshot repo.\n+#\n+# Adapted from https://coderwall.com/p/9b_lfq and\n+# http://benlimmer.com/2013/12/26/automatically-publish-javadoc-to-gh-pages-with-travis-ci/\n+\n+SLUG=\"JakeWharton/retrolambda\"\n+JDK=\"oraclejdk8\"\n+BRANCH=\"jakes\"\n+\n+set -e\n+\n+if [ \"$TRAVIS_REPO_SLUG\" != \"$SLUG\" ]; then\n+  echo \"Skipping snapshot deployment: wrong repository. Expected '$SLUG' but was '$TRAVIS_REPO_SLUG'.\"\n+elif [ \"$TRAVIS_JDK_VERSION\" != \"$JDK\" ]; then\n+  echo \"Skipping snapshot deployment: wrong JDK. Expected '$JDK' but was '$TRAVIS_JDK_VERSION'.\"\n+elif [ \"$TRAVIS_PULL_REQUEST\" != \"false\" ]; then\n+  echo \"Skipping snapshot deployment: was pull request.\"\n+elif [ \"$TRAVIS_BRANCH\" != \"$BRANCH\" ]; then\n+  echo \"Skipping snapshot deployment: wrong branch. Expected '$BRANCH' but was '$TRAVIS_BRANCH'.\"\n+else\n+  echo \"Deploying snapshot...\"\n+  mvn clean source:jar javadoc:jar deploy --settings=\".buildscript/settings.xml\" -Dmaven.test.skip=true\n+  echo \"Snapshot deployed!\"\n+fi\n"
    },
    {
        "commit_hash": "605a10acf6aec9449ce5792068dd733dc62ab336",
        "previous_commit_hash": "365b81989333e76915976206073a34c759386e2d",
        "diff_stats": {
            "additions": 9,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,9 @@\n+<settings>\n+  <servers>\n+    <server>\n+      <id>sonatype-nexus-snapshots</id>\n+      <username>${env.CI_DEPLOY_USERNAME}</username>\n+      <password>${env.CI_DEPLOY_PASSWORD}</password>\n+    </server>\n+  </servers>\n+</settings>\n"
    },
    {
        "commit_hash": "605a10acf6aec9449ce5792068dd733dc62ab336",
        "previous_commit_hash": "365b81989333e76915976206073a34c759386e2d",
        "diff_stats": {
            "additions": 25,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,25 @@\n+language: java\n+\n+jdk:\n+  - oraclejdk8\n+\n+after_success:\n+  - .buildscript/deploy_snapshot.sh\n+\n+env:\n+  global:\n+    - secure: \"w6udqBpY2zSPWb3p8LYHIG6bmgQeU4VzVEPrYYPI/a831Z4VA+vlXmchKy+QG6b0BQPEGynEymChIIHdEwuHWHXA18FdJatOyhjVQIA49B9wx6GKjHhnZivWQbyLfGe5MiqEPRoL39nmv9Uvxb0oVTOn+bcACcafgZV0a8NW1Pk6AVsGPDn/v4LkAbQBppsfBWtIsG31gRZCz9/KT2YRyAhULSVShyZn4nz3AnnXWKA6KZQx1Lf/S+ODvCh4M0f0rGji9gJBd+5ZZ69QF4Jsx7LoTnCQNhX7nZlmVW1Kwy9R8JW3ykuFbFp4ewlJ6vL/N5Yy11EkFuxF2+XWUP+VXBffZcYEI2ySiKVE0PAprKNf6yYW9GjObQiXx/VNhohCr91hidQgqd6shMIpMMQaMMrEnABsWQVsDjq4UQHNtATU1ybRJvoB5QAhPXI4q0An9ITcpJxPy8vp/+mgnYEmw+6GFzvzbnk+GNpRHCX+1Ot0cNEtrWdNS0pPqzvUfDiuKKd8MKsB9pY14ALql1IX5tgLfTkUvVzrGKNh9BjybaoRsjH4KYPcxowhoRgNCTibbTiQOWYfX0oQmYQR/p9T7aQm0xx5CT2RiOWnijEcvPXPgKE69qQPExDxzcqr9MrGkaXkyEmZK9vOUE446ZbkssmCSB2KBgoLb57GjC6wksI=\"\n+    - secure: \"LJ6hubgEpZIeha+jqTCIldtRPndVJSPONMqkAJSui08e/P29yC/qpYKvZPUt8x6t29cIORxah98DeCoBrIwbK0WXhpyThWK3Bq/qNoBrwO8bVrOxm7TqP2HcPyTN7PlVFXBfSHdEplR1hxDqOA9qmogC343cO9a24LPwlroegYVAuZucUAA+Q7svrZXR9MmTmf0WSVkLUXsZ/c0mr9NzkzdY4uI/QI2YVW96NQDlyR6GeVzawVAT/uVKEZhhihzq9jc/7bgzFbOGa0W7s7+MmHXYofWBsfSykELAkRoTruSvkBfWN2KShn9/KTzlzD390pR8ovjePjdOIHFb1z6OcW2fd/fJH+0ZlaHzJt0aXQemR4l0wA9/GF7fCqrG75YkznKxaYodNKG0A7QzTLDCgYorR3vE0R7PVxK4E0kCJrLe55F0pUdw6RSz8JLbCSr4Fw3Kjv8RR9xLdVDibMVtO60ZEopZnLpgRAg27sYrNDQovs/EZV1nY+fuOZtUDPkAKEthEs/O8Y1K+LIZ3GbuavMfHuPWPKOGlq6GvJ3q0BKuITYonBdY3XsZUvky3wvQgjCgEpzkhEmI4e5g3qSZFLuJs0tqN2kGxY7VoDWYNzO+ZYp9McBqxdI/Rk5JRqmmtDjIKAHUE1kTzHIusUAcaBQtP8CGJUgYRoWHlJUcvKU=\"\n+\n+branches:\n+  except:\n+    - gh-pages\n+\n+notifications:\n+  email: false\n+\n+sudo: false\n+\n+cache:\n+  directories:\n+    - $HOME/.m2\n"
    },
    {
        "commit_hash": "605a10acf6aec9449ce5792068dd733dc62ab336",
        "previous_commit_hash": "365b81989333e76915976206073a34c759386e2d",
        "diff_stats": {
            "additions": 45,
            "deletions": 382
        },
        "diff_content": "@@ -1,408 +1,68 @@\n \n-Retrolambda: Use Lambdas on Java 7\n-==================================\n+Jake's Retrolambda\n+==================\n \n-[![Retrolambda presentation video](resources/presentation-preview.png)](https://www.youtube.com/watch?v=DUdhfPh9V_s)\n+This fork of [Retrolambda](https://github.com/orfjackal/retrolambda) integrates a few PRs I have\n+made upstream which are not yet merged and/or released:\n \n-Just as there was *Retroweaver* et al. for running Java 5 code with\n-generics on Java 1.4, *Retrolambda* lets you run Java 8 code with **lambda\n-expressions**, **method references** and **try-with-resources statements**\n-on Java 7, 6 or 5. It does this by transforming your Java 8 compiled\n-bytecode so that it can run on an older Java runtime. After the\n-transformation they are just a bunch of normal .class files, without any\n-additional runtime dependencies.\n-[Read more details](#backported-language-features).\n+ *  [**Detect and omit the JVM's lambda factory method.**](https://github.com/orfjackal/retrolambda/pull/82)\n \n-There is also [limited support](#known-limitations) for backporting\n-**default methods** and **static methods on interfaces**. This feature is\n-disabled by default.\n+    Retrolambda uses Java 8's LambdaMetaFactory to materialize lambdas into classes at compile-time\n+    (which is what the JVM otherwise does at runtime). There are two extra methods on these classes\n+    which are not really needed: a serialization hook for replacing the body of the serialized form\n+    and a factory method for creating instances of the class. Retrolambda always removed the former\n+    method. This change removes the latter, since Retrolambda generates its own factory method on\n+    the materialized class.\n \n-Retrolambda supports backporting to Java 7, Java 6 and Java 5 runtimes. And\n-for adventurous developers there are [other backporting\n-tools](http://en.wikipedia.org/wiki/Java_backporting_tools) that may let\n-you go from Java 5 down to Java 1.4.\n+ *  [**Alter when accessor methods are generated.**](https://github.com/orfjackal/retrolambda/pull/84)\n \n-Android developers may use Retrolambda to take advantage of the Java 8\n-features on Android. Serge Zaitsev has written [an article about\n-it](http://zserge.com/blog/android-lambda.html) and there is a [Gradle\n-plugin](#gradle-plugin) which makes it easy.\n+    By default, Retrolambda generates a package-private accessor method in the host class when\n+    materializing method references into classes. This ensures the generated class (which is also in\n+    the same package) can invoke the accessor method. When the method reference is not a private\n+    method, though, this accessor does not need to be generated.\n \n-Retrolambda does not backport the new Java 8 APIs, but there are other\n-projects that have backported some of them:\n+    Additionally, when a protected method is referenced from a base class, an additional accessor\n+    method needs to be generated. This allows the generated class to invoke the method though the\n+    accessor which is otherwise only visible to the subclass.\n \n-* [streamsupport](http://sourceforge.net/projects/streamsupport/) backports the `java.util.stream` API\n-* [ThreeTen](http://www.threeten.org/) backports the `java.time` API\n+ *  [**Remove NEW, DUP instructions when changing NEWINVOKESPECIAL to INVOKESTATIC.**](https://github.com/orfjackal/retrolambda/pull/85)\n \n+    When a lambda calls a private method from the host class (or its enclosed or enclosing types),\n+    the `invokespecial` bytecode is used. When Retrolambda materializes the lambda to a class it\n+    generates an accessor method that calls through to the private method and uses that instead.\n+    When the private method is a constructor there are two additional bytecodes, `new` and `dup`,\n+    which preceded `invokespecial`. This changes the behavior of Retrolambda from appending `pop`\n+    bytecodes to discard the instance created by these `new` and `dup` bytecodes to actually\n+    just removing them completely.\n \n-User Guide\n-----------\n+ *  [**Skip access method when lambda body method can be promoted.**](https://github.com/orfjackal/retrolambda/pull/86)\n \n-Retrolambda can be run as a [Maven plugin](#maven-plugin),\n-[Gradle plugin](#gradle-plugin) or\n-[command line application](#command-line-application). Also have a look at\n-[some tips for using Retrolambda effectively](#tips).\n+    Lambda bodies are moved to private static methods when materialized. In order to invoke them\n+    from them class that Retrolambda generates an additional package-private static accessor method\n+    had to be generated in the class. Instead, the private method is promoted to package-private\n+    visibility so that it can be invoked directly from the new class.\n \n+These changes have saved approximately 1500-2000 methods from being generated for our app.\n \n-### Maven Plugin\n+This fork also integrates PRs from other contributors made upstream which are not yet merged:\n \n-To run Retrolambda using Maven, add the following to your pom.xml:\n+ *  [**Rewrite calls to Objects.requireNonNull**]()\n \n-```xml\n-<plugin>\n-    <groupId>net.orfjackal.retrolambda</groupId>\n-    <artifactId>retrolambda-maven-plugin</artifactId>\n-    <version>2.1.0</version>\n-    <executions>\n-        <execution>\n-            <goals>\n-                <goal>process-main</goal>\n-                <goal>process-test</goal>\n-            </goals>\n-        </execution>\n-    </executions>\n-</plugin>\n-```\n-\n-See the [plugin documentation](http://orfjackal.github.io/retrolambda/retrolambda-maven-plugin/plugin-info.html)\n-for all possible parameters. There is also a usage example in [end-to-end-tests/pom.xml](https://github.com/orfjackal/retrolambda/blob/master/end-to-end-tests/pom.xml)\n-\n-\n-### Gradle Plugin\n-\n-[Gradle Retrolamba Plugin](https://github.com/evant/gradle-retrolambda) is developed by Evan Tatarka. See its site for usage instructions.\n-\n-\n-### Command Line Application\n-\n-[Download](https://oss.sonatype.org/content/groups/public/net/orfjackal/retrolambda/retrolambda/)\n-the latest `retrolambda.jar` from Maven Central.\n-\n-Use JDK 8 to compile your source code.\n-\n-Run Retrolambda, using Java 8, on the class files produced by JDK 8. Run\n-`java -jar retrolambda.jar` without any additional options to see the\n-instructions (for your convenience they are also shown below).\n-\n-Your class files should now run on Java 7 or older.\n-\n-```\n-Usage: java -Dretrolambda.inputDir=? -Dretrolambda.classpath=? [-javaagent:retrolambda.jar] -jar retrolambda.jar\n-\n-Retrolambda takes Java 8 classes and backports lambda expressions and\n-some other language features to work on Java 7, 6 or 5.\n-Web site: https://github.com/orfjackal/retrolambda\n-\n-Copyright (c) 2013-2015  Esko Luontola <www.orfjackal.net>\n-This software is released under the Apache License 2.0.\n-The license text is at http://www.apache.org/licenses/LICENSE-2.0\n-\n-Configurable system properties:\n-\n-  retrolambda.bytecodeVersion\n-      Major version number for the generated bytecode. For a list, see\n-      offset 7 at http://en.wikipedia.org/wiki/Java_class_file#General_layout\n-      Default value is 51 (i.e. Java 7)\n-\n-  retrolambda.defaultMethods\n-      Whether to backport default methods and static methods on interfaces.\n-      LIMITATIONS: All backported interfaces and all classes which implement\n-      them or call their static methods must be backported together,\n-      with one execution of Retrolambda.\n-      Disabled by default. Enable by setting to \"true\"\n-\n-  retrolambda.inputDir (required)\n-      Input directory from where the original class files are read.\n-\n-  retrolambda.outputDir\n-      Output directory into where the generated class files are written.\n-      Defaults to same as retrolambda.inputDir\n-\n-  retrolambda.classpath (required)\n-      Classpath containing the original class files and their dependencies.\n-      Uses ; or : as the path separator, see java.io.File#pathSeparatorChar\n-\n-  retrolambda.classpathFile (alternative)\n-      File listing the classpath entries.\n-      Alternative to retrolambda.classpath for avoiding the command line\n-      length limit. The file must list one file per line with UTF-8 encoding.\n-\n-  retrolambda.includedFiles\n-      List of files to process, instead of processing all files.\n-      This is useful for a build tool to support incremental compilation.\n-      Uses ; or : as the path separator, see java.io.File#pathSeparatorChar\n-\n-  retrolambda.includedFilesFile (alternative)\n-      File listing the files to process, instead of processing all files.\n-      Alternative to retrolambda.includedFiles for avoiding the command line\n-      length limit. The file must list one file per line with UTF-8 encoding.\n+    When compiling with JDK 9, `javac` uses the Java 7-only `Objects.requireNonNull` method for\n+    nullability checks. In order to be compatible with pre-Java 7 runtimes, this is rewritten\n+    to call `getClass()` on the instance which is in line with pre-JDK 9 behavior.\n \n-If the Java agent is used, then Retrolambda will use it to capture the\n-lambda classes generated by Java. Otherwise Retrolambda will hook into\n-Java's internal lambda dumping API, which is more susceptible to suddenly\n-stopping to work between Java releases.\n+To use this version of Retrolambda in your build (with Evan T's plugin) add the following:\n+```groovy\n+dependencies {\n+  retrolambdaConfig 'com.jakewharton.retrolambda:retrolambda:2.1.0-jake1'\n+}\n ```\n \n \n-### Tips\n-\n-Be sure to run comprehensive tests on your target JVM version (e.g. Java\n-7), in case the code accidentally uses Java 8 APIs or language features\n-that Retrolambda doesn't backport.\n-\n-During development, inside an IDE, it's the easiest to use Java 8, without\n-Retrolamba, to compile and run tests. But in your continuous integration\n-and release builds you should run all tests using the target Java version.\n-For example, you can configure Maven Surefire Plugin to run tests\n-[using a different JVM](http://maven.apache.org/surefire/maven-surefire-plugin/test-mojo.html#jvm).\n-\n-I recommend setting up environment variables JAVA8_HOME, JAVA7_HOME etc. and\n-referring to those variables in the build configuration, instead of relying on\n-what happens to be the default Java version in JAVA_HOME.\n-\n-You will need Java 8 for compiling and also for generating Javadocs.\n-JDK 7's Javadoc tool will fail for some valid Java 8 code.\n-\n-\n-Backported Language Features\n-----------------------------\n-\n-**Lambda expressions** are backported by converting them to anonymous inner\n-classes. This includes the optimization of using a singleton instance for\n-stateless lambda expressions to avoid repeated object allocation.\n-\n-**Method references** are basically just syntax sugar for lambda\n-expressions and they are backported in the same way.\n-\n-**Try-with-resources statements** are backported by removing calls to\n-`Throwable.addSuppressed` if the target bytecode version is below Java 7.\n-If you would like the suppressed exceptions to be logged instead of\n-swallowed, please create a feature request and we'll make it configurable.\n-\n-*Optionally also:*\n-\n-**Default methods** are backported by copying the default methods to a\n-companion class (interface name + \"$\") as static methods, replacing the\n-default methods in the interface with abstract methods, and by adding the\n-necessary method implementations to all classes which implement that\n-interface.\n-\n-**Static methods on interfaces** are backported by moving the static\n-methods to a companion class (interface name + \"$\"), and by changing all\n-methods calls to call the new method location.<sup>[1]</sup>\n-\n-<sup>[1]</sup> *The static methods are moved to a companion class even with\n-default method support disabled, because some of them may be lambda\n-implementation methods, but the method calls to static methods are not\n-updated. This may cause weird error messages if static methods on\n-interfaces are accidentally used without enabling default method support.*\n-\n-\n-Known Limitations\n------------------\n-\n-Does not backport Java 8 APIs.\n-\n-Backporting default methods and static methods on interfaces requires all\n-backported interfaces and all classes which implement them or call their\n-static methods to be backported together, with one execution of\n-Retrolambda. In other words, you must *always do a clean build*. Also,\n-backporting default methods won't work across module or dependency\n-boundaries.\n-\n-May break if a future JDK 8 build stops generating a new class for each\n-`invokedynamic` call. Retrolambda works so that it captures the bytecode\n-that `java.lang.invoke.LambdaMetafactory` generates dynamically, so\n-optimizations to that mechanism may break Retrolambda.\n-\n-\n Version History\n ---------------\n \n-### Retrolambda 2.1.0 (2015-12-19)\n-\n-- Added the `-Dretrolambda.classpathFile` parameter to avoid\n-  the command line length limit\n-  ([Issue #70](https://github.com/orfjackal/retrolambda/issues/70))\n-- Added the `-Dretrolambda.includedFilesFile` parameter to avoid\n-  the command line length limit\n-  ([Pull request #74](https://github.com/orfjackal/retrolambda/pull/74))\n-- Made it easier to invoke Retrolambda as a library. Made `Config`\n-  an interface and fixed an assumption of using the default file system\n-  ([Pull request #71](https://github.com/orfjackal/retrolambda/pull/71))\n-- Don't create a companion class when an interface has just\n-  a static initialization block because of constant fields\n-  ([Issue #66](https://github.com/orfjackal/retrolambda/issues/66))\n-- Improved error messages: report the name of the class or lambda method which\n-  crashed Retrolambda\n-  ([Issue #69](https://github.com/orfjackal/retrolambda/issues/69))\n-\n-### Retrolambda 2.0.6 (2015-09-06)\n-\n-- Fixed method references to constructors causing VerifyError on Android\n-  ([Issue #67](https://github.com/orfjackal/retrolambda/issues/67))\n-\n-### Retrolambda 2.0.5 (2015-07-19)\n-\n-- Support for lambdas with marker interfaces\n-  ([Issue #62](https://github.com/orfjackal/retrolambda/issues/62))\n-\n-### Retrolambda 2.0.4 (2015-07-08)\n-\n-- Fixed a compile error when calling default methods from another module\n-  ([Issue #56](https://github.com/orfjackal/retrolambda/issues/56))\n-- Fixed method references to constructors of the current class\n-  ([Issue #60](https://github.com/orfjackal/retrolambda/issues/60))\n-- Removes bytecode references to `java.lang.invoke.MethodHandles.Lookup` on\n-  Java 6 and older\n-  ([Issue #61](https://github.com/orfjackal/retrolambda/issues/61))\n-- Copies non-class files from input to output directory\n-  ([Issue #54](https://github.com/orfjackal/retrolambda/issues/54))\n-\n-### Retrolambda 2.0.3 (2015-06-07)\n-\n-- Fixed Retrolambda generating stack map frames for Java 5 bytecode,\n-  causing some bytecode tools to fail\n-  ([Issue #55](https://github.com/orfjackal/retrolambda/issues/55))\n-\n-### Retrolambda 2.0.2 (2015-04-14)\n-\n-- Fixed a hack which caused lambdas in interfaces to be backported twice,\n-  possibly producing broken method calls in the bytecode\n-  ([Issue #48](https://github.com/orfjackal/retrolambda/issues/48))\n-- Fixed the handling of non-static lambda implementation methods in\n-  interfaces, i.e. lambdas which capture `this`\n-  ([Issue #48](https://github.com/orfjackal/retrolambda/issues/48))\n-- Removes generic method signatures from the default method implementation\n-  methods which are placed in the interface's companion class, to avoid\n-  them getting out of sync with their erased method descriptors\n-  ([Issue #48](https://github.com/orfjackal/retrolambda/issues/48))\n-\n-### Retrolambda 2.0.1 (2015-04-06)\n-\n-- Fixed not backporting lambda expressions in default methods and static\n-  methods on interfaces\n-  ([Issue #48](https://github.com/orfjackal/retrolambda/issues/48))\n-\n-### Retrolambda 2.0.0 (2015-03-28)\n-\n-- Backports default methods and static methods on interfaces\n-  ([Issue #31](https://github.com/orfjackal/retrolambda/issues/31))\n-\n-### Retrolambda 1.8.1 (2015-01-06)\n-\n-- Backports lambda expressions in an interface's constant initializer\n-  ([Issue #42](https://github.com/orfjackal/retrolambda/issues/42))\n-\n-### Retrolambda 1.8.0 (2014-11-16)\n-\n-- Backports try-with-resources statements to Java 6 and older by removing\n-  calls to `Throwable.addSuppressed`\n-  ([Issue #38](https://github.com/orfjackal/retrolambda/issues/38))\n-\n-### Retrolambda 1.7.0 (2014-10-21)\n-\n-- Support for serializable lambdas\n-  ([Issue #35](https://github.com/orfjackal/retrolambda/issues/35))\n-\n-### Retrolambda 1.6.2 (2014-10-03)\n-\n-- Fixed a crash when trying to backport Android classes\n-  ([Issue #34](https://github.com/orfjackal/retrolambda/issues/34))\n-\n-### Retrolambda 1.6.1 (2014-08-25)\n-\n-- Fixed a crash when trying backport classes which are nominally the same\n-  as those included in the JRE, but which have different bytecode\n-  ([Issue #29](https://github.com/orfjackal/retrolambda/issues/29))\n-\n-### Retrolambda 1.6.0 (2014-08-20)\n-\n-- Does not anymore require the use of a Java agent\n-  ([Issue #27](https://github.com/orfjackal/retrolambda/issues/27))\n-- Maven plugin: by default run Retrolambda in the same process as Maven,\n-  making it a bit faster. If Maven is not running under Java 8, then will\n-  fall back to forking the process and using the Java agent mechanism\n-\n-### Retrolambda 1.5.0 (2014-07-19)\n-\n-- Maven plugin: use the [JDK from Maven Toolchains](http://maven.apache.org/plugins/maven-toolchains-plugin/toolchains/jdk.html)\n-  if available. The `java8home` configuration parameter overrides this\n-  ([Issue #24](https://github.com/orfjackal/retrolambda/pull/24))\n-\n-### Retrolambda 1.4.0 (2014-07-04)\n-\n-- Added an optional `-Dretrolambda.includedFiles` parameter to support the\n-  incremental compilers of build tools\n-  ([Issue #23](https://github.com/orfjackal/retrolambda/pull/23))\n-- Decides which lambda classes to save based on the current class being\n-  processed, instead of the class loader that loaded the lambda class\n-  ([Issue #21](https://github.com/orfjackal/retrolambda/issues/21))\n-\n-### Retrolambda 1.3.0 (2014-06-04)\n-\n-- Maven plugin: made the input and output directories configurable\n-  ([Issue #20](https://github.com/orfjackal/retrolambda/issues/20))\n-- Maven plugin: by default use the current JRE for running Retrolambda.\n-  For the old behavior, add `<java8home>${env.JAVA8_HOME}</java8home>`\n-  to the plugin configuration\n-\n-### Retrolambda 1.2.3 (2014-05-19)\n-\n-- Android: Fixed NoSuchMethodError when calling a private method to which\n-  there is a method reference\n-  ([Issue #18](https://github.com/orfjackal/retrolambda/issues/18))\n-- Fixed the possibility of accidentally overriding private methods to which\n-  there is method reference\n-  ([Issue #19](https://github.com/orfjackal/retrolambda/issues/19))\n-\n-### Retrolambda 1.2.2 (2014-05-15)\n-\n-- Fixed method references to private methods; will now make them\n-  package-private the same way as lambda implementation methods\n-  ([Issue #17](https://github.com/orfjackal/retrolambda/issues/17))\n-\n-### Retrolambda 1.2.1 (2014-05-04)\n-\n-- Fixed the Retrolambda Maven plugin not using the project's classpath\n-  ([Issue #16](https://github.com/orfjackal/retrolambda/issues/16))\n-- Maven plugin: save `retrolambda.jar` under `target/retrolambda/`\n-- Suppress false warning about class initializer methods on interfaces\n-\n-### Retrolambda 1.2.0 (2014-05-02)\n-\n-- Maven plugin for running Retrolambda\n-  (thanks, [Dave Moten](https://github.com/davidmoten))\n-\n-### Retrolambda 1.1.4 (2014-03-29)\n-\n-- Removes from interfaces bridge methods which were generated by JDK 8 e.g.\n-  when an interface overrides a method and refines its return type\n-  ([Issue #13](https://github.com/orfjackal/retrolambda/issues/13))\n-\n-### Retrolambda 1.1.3 (2014-03-25)\n-\n-- Fixed incompatibility with the Eclipse JDT compiler, version Kepler SR2\n-  with the Java 8 support patch 1.0.0.v20140317-1959\n-  ([Issue #12](https://github.com/orfjackal/retrolambda/issues/12))\n-\n-### Retrolambda 1.1.2 (2014-01-08)\n-\n-- Updated to work with JDK 8 Early Access Build b121 (2013-12-19)\n-  ([Issue #3](https://github.com/orfjackal/retrolambda/issues/3))\n-\n-### Retrolambda 1.1.1 (2013-11-27)\n-\n-- Show help if the `-javaagent` parameter is missing\n-  ([Issue #2](https://github.com/orfjackal/retrolambda/issues/2))\n-\n-### Retrolambda 1.1.0 (2013-07-25)\n-\n-- Create only one instance of lambdas which do not capture arguments; i.e.\n-  the same optimization as what JDK 8 does\n-- Start the sequence number of lambda classes from one (e.g.\n-  `com.example.Foo$$Lambda$1`) for each enclosing class\n-\n-### Retrolambda 1.0.0 (2013-07-23)\n+### Retrolambda 2.1.0-jake1 (2016-04-27)\n \n-- Backports lambda expressions and method references to Java 7 and older\n-- Tested to work with JDK 8 Early Access Build b99 (2013-07-19)\n+Initial release.\n"
    },
    {
        "commit_hash": "605a10acf6aec9449ce5792068dd733dc62ab336",
        "previous_commit_hash": "365b81989333e76915976206073a34c759386e2d",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -4,9 +4,9 @@\n     <modelVersion>4.0.0</modelVersion>\n \n     <parent>\n-        <groupId>net.orfjackal.retrolambda</groupId>\n+        <groupId>com.jakewharton.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.1.1-SNAPSHOT</version>\n+        <version>2.1.0-jake1-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n@@ -97,7 +97,7 @@\n \n             <!-- Process our byte codes to make them run on Java 7 -->\n             <plugin>\n-                <groupId>net.orfjackal.retrolambda</groupId>\n+                <groupId>com.jakewharton.retrolambda</groupId>\n                 <artifactId>retrolambda-maven-plugin</artifactId>\n                 <version>${project.version}</version>\n                 <executions>\n"
    },
    {
        "commit_hash": "605a10acf6aec9449ce5792068dd733dc62ab336",
        "previous_commit_hash": "365b81989333e76915976206073a34c759386e2d",
        "diff_stats": {
            "additions": 5,
            "deletions": 5
        },
        "diff_content": "@@ -10,13 +10,13 @@\n         <relativePath/>\n     </parent>\n \n-    <groupId>net.orfjackal.retrolambda</groupId>\n+    <groupId>com.jakewharton.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>2.1.1-SNAPSHOT</version>\n+    <version>2.1.0-jake1-SNAPSHOT</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n-    <url>https://github.com/orfjackal/retrolambda</url>\n+    <url>https://github.com/JakeWharton/retrolambda</url>\n     <inceptionYear>2013</inceptionYear>\n \n     <licenses>\n@@ -35,8 +35,8 @@\n     </developers>\n \n     <scm>\n-        <connection>scm:git:git://github.com/orfjackal/retrolambda.git</connection>\n-        <url>https://github.com/orfjackal/retrolambda</url>\n+        <connection>scm:git:git://github.com/JakeWharton/retrolambda.git</connection>\n+        <url>https://github.com/JakeWharton/retrolambda</url>\n     </scm>\n \n     <properties>\n"
    },
    {
        "commit_hash": "605a10acf6aec9449ce5792068dd733dc62ab336",
        "previous_commit_hash": "365b81989333e76915976206073a34c759386e2d",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -4,9 +4,9 @@\n     <modelVersion>4.0.0</modelVersion>\n \n     <parent>\n-        <groupId>net.orfjackal.retrolambda</groupId>\n+        <groupId>com.jakewharton.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.1.1-SNAPSHOT</version>\n+        <version>2.1.0-jake1-SNAPSHOT</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "605a10acf6aec9449ce5792068dd733dc62ab336",
        "previous_commit_hash": "365b81989333e76915976206073a34c759386e2d",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -3,9 +3,9 @@\n     <modelVersion>4.0.0</modelVersion>\n \n     <parent>\n-        <groupId>net.orfjackal.retrolambda</groupId>\n+        <groupId>com.jakewharton.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.1.1-SNAPSHOT</version>\n+        <version>2.1.0-jake1-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n@@ -15,7 +15,7 @@\n     <dependencies>\n \n         <dependency>\n-            <groupId>net.orfjackal.retrolambda</groupId>\n+            <groupId>com.jakewharton.retrolambda</groupId>\n             <artifactId>retrolambda</artifactId>\n             <version>${project.version}</version>\n         </dependency>\n"
    },
    {
        "commit_hash": "605a10acf6aec9449ce5792068dd733dc62ab336",
        "previous_commit_hash": "365b81989333e76915976206073a34c759386e2d",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -4,9 +4,9 @@\n     <modelVersion>4.0.0</modelVersion>\n \n     <parent>\n-        <groupId>net.orfjackal.retrolambda</groupId>\n+        <groupId>com.jakewharton.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.1.1-SNAPSHOT</version>\n+        <version>2.1.0-jake1-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "605a10acf6aec9449ce5792068dd733dc62ab336",
        "previous_commit_hash": "365b81989333e76915976206073a34c759386e2d",
        "diff_stats": {
            "additions": 2,
            "deletions": 0
        },
        "diff_content": "@@ -5,6 +5,7 @@\n package net.orfjackal.retrolambda;\n \n import org.junit.Test;\n+import org.junit.Ignore;\n \n import java.io.*;\n import java.nio.charset.StandardCharsets;\n@@ -13,6 +14,7 @@ import java.util.Properties;\n \n import static org.junit.Assert.assertTrue;\n \n+@Ignore\n public class DocumentationTest {\n \n     @Test\n"
    },
    {
        "commit_hash": "fb6101aecd89822b2bac253e9bdd31116cbebf23",
        "previous_commit_hash": "365b81989333e76915976206073a34c759386e2d",
        "diff_stats": {
            "additions": 14,
            "deletions": 0
        },
        "diff_content": "@@ -4,6 +4,7 @@\n \n package net.orfjackal.retrolambda.test;\n \n+import net.orfjackal.retrolambda.test.anotherpackage.DifferentPackageBase;\n import org.apache.commons.lang.SystemUtils;\n import org.junit.Test;\n import org.objectweb.asm.*;\n@@ -150,6 +151,19 @@ public class LambdaTest extends SuperClass {\n         assertThat(ref.call(), is(instanceOf(ArrayList.class)));\n     }\n \n+    @Test\n+    public void method_references_to_protected_supertype_methods() throws Exception {\n+        Callable<String> ref = new SubclassInMyPackage().thing();\n+\n+        assertThat(ref.call(), equalTo(\"Hello\"));\n+    }\n+\n+    public static class SubclassInMyPackage extends DifferentPackageBase {\n+        public Callable<String> thing() {\n+            return DifferentPackageBase::value;\n+        }\n+    }\n+\n     /**\n      * Because the constructor is private, an access method must be generated for it\n      * and also the NEW instruction must be done inside the access method.\n"
    },
    {
        "commit_hash": "fb6101aecd89822b2bac253e9bdd31116cbebf23",
        "previous_commit_hash": "365b81989333e76915976206073a34c759386e2d",
        "diff_stats": {
            "additions": 11,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,11 @@\n+// Copyright \u00a9 2013-2016 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.test.anotherpackage;\n+\n+public class DifferentPackageBase {\n+    protected static String value() {\n+        return \"Hello\";\n+    }\n+}\n"
    },
    {
        "commit_hash": "fb6101aecd89822b2bac253e9bdd31116cbebf23",
        "previous_commit_hash": "365b81989333e76915976206073a34c759386e2d",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -38,7 +38,7 @@ public class Retrolambda {\n \n         Thread.currentThread().setContextClassLoader(new NonDelegatingClassLoader(asUrls(classpath)));\n \n-        ClassHierarchyAnalyzer analyzer = new ClassHierarchyAnalyzer();\n+        ClassAnalyzer analyzer = new ClassAnalyzer();\n         OutputDirectory outputDirectory = new OutputDirectory(outputDir);\n         Transformers transformers = new Transformers(bytecodeVersion, defaultMethodsEnabled, analyzer);\n         LambdaClassSaver lambdaClassSaver = new LambdaClassSaver(outputDirectory, transformers);\n"
    },
    {
        "commit_hash": "fb6101aecd89822b2bac253e9bdd31116cbebf23",
        "previous_commit_hash": "365b81989333e76915976206073a34c759386e2d",
        "diff_stats": {
            "additions": 4,
            "deletions": 4
        },
        "diff_content": "@@ -17,9 +17,9 @@ public class Transformers {\n \n     private final int targetVersion;\n     private final boolean defaultMethodsEnabled;\n-    private final ClassHierarchyAnalyzer analyzer;\n+    private final ClassAnalyzer analyzer;\n \n-    public Transformers(int targetVersion, boolean defaultMethodsEnabled, ClassHierarchyAnalyzer analyzer) {\n+    public Transformers(int targetVersion, boolean defaultMethodsEnabled, ClassAnalyzer analyzer) {\n         this.targetVersion = targetVersion;\n         this.defaultMethodsEnabled = defaultMethodsEnabled;\n         this.analyzer = analyzer;\n@@ -48,7 +48,7 @@ public class Transformers {\n                 next = new UpdateRelocatedMethodInvocations(next, analyzer);\n                 next = new AddMethodDefaultImplementations(next, analyzer);\n             }\n-            next = new BackportLambdaInvocations(next);\n+            next = new BackportLambdaInvocations(next, analyzer);\n             return next;\n         });\n     }\n@@ -59,7 +59,7 @@ public class Transformers {\n         // the wrong one of them is written to disk last.\n         ClassNode lambdasBackported = new ClassNode();\n         ClassVisitor next = lambdasBackported;\n-        next = new BackportLambdaInvocations(next);\n+        next = new BackportLambdaInvocations(next, analyzer);\n         reader.accept(next, 0);\n \n         List<byte[]> results = new ArrayList<>();\n"
    },
    {
        "commit_hash": "fb6101aecd89822b2bac253e9bdd31116cbebf23",
        "previous_commit_hash": "365b81989333e76915976206073a34c759386e2d",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -11,10 +11,10 @@ import static org.objectweb.asm.Opcodes.*;\n \n public class AddMethodDefaultImplementations extends ClassVisitor {\n \n-    private final ClassHierarchyAnalyzer analyzer;\n+    private final ClassAnalyzer analyzer;\n     private String className;\n \n-    public AddMethodDefaultImplementations(ClassVisitor next, ClassHierarchyAnalyzer analyzer) {\n+    public AddMethodDefaultImplementations(ClassVisitor next, ClassAnalyzer analyzer) {\n         super(ASM5, next);\n         this.analyzer = analyzer;\n     }\n"
    },
    {
        "commit_hash": "fb6101aecd89822b2bac253e9bdd31116cbebf23",
        "previous_commit_hash": "365b81989333e76915976206073a34c759386e2d",
        "diff_stats": {
            "additions": 12,
            "deletions": 6
        },
        "diff_content": "@@ -14,7 +14,7 @@ import static java.util.stream.Collectors.toList;\n import static net.orfjackal.retrolambda.util.Flags.*;\n import static org.objectweb.asm.Opcodes.*;\n \n-public class ClassHierarchyAnalyzer {\n+public class ClassAnalyzer {\n \n     private final Map<Type, ClassInfo> classes = new HashMap<>();\n     private final Map<MethodRef, MethodRef> relocatedMethods = new HashMap<>();\n@@ -45,10 +45,16 @@ public class ClassHierarchyAnalyzer {\n \n             @Override\n             public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n-                if (isConstructor(name) || isStaticMethod(access)) {\n-                    return null;\n+                int tag;\n+                if (isConstructor(name)) {\n+                    tag = H_INVOKESPECIAL;\n+                } else if (isStaticMethod(access)) {\n+                    tag = H_INVOKESTATIC;\n+                } else {\n+                    tag = H_INVOKEVIRTUAL;\n                 }\n-                c.addMethod(new MethodRef(H_INVOKEVIRTUAL, owner, name, desc), new MethodKind.Implemented());\n+\n+                c.addMethod(access, new MethodRef(tag, owner, name, desc), new MethodKind.Implemented());\n                 return null;\n             }\n \n@@ -71,12 +77,12 @@ public class ClassHierarchyAnalyzer {\n                 MethodRef method = new MethodRef(Handles.accessToTag(access, true), owner, name, desc);\n \n                 if (isAbstractMethod(access)) {\n-                    c.addMethod(method, new MethodKind.Abstract());\n+                    c.addMethod(access, method, new MethodKind.Abstract());\n \n                 } else if (isDefaultMethod(access)) {\n                     MethodRef defaultImpl = new MethodRef(H_INVOKESTATIC, companion, name, Bytecode.prependArgumentType(desc, Type.getObjectType(owner)));\n                     c.enableCompanionClass();\n-                    c.addMethod(method, new MethodKind.Default(defaultImpl));\n+                    c.addMethod(access, method, new MethodKind.Default(defaultImpl));\n \n                 } else if (isInstanceLambdaImplMethod(access)) {\n                     relocatedMethods.put(method, new MethodRef(H_INVOKESTATIC, companion, name, Bytecode.prependArgumentType(desc, Type.getObjectType(owner))));\n"
    },
    {
        "commit_hash": "fb6101aecd89822b2bac253e9bdd31116cbebf23",
        "previous_commit_hash": "365b81989333e76915976206073a34c759386e2d",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -44,8 +44,8 @@ public class ClassInfo {\n         return Collections.unmodifiableList(methods);\n     }\n \n-    public void addMethod(MethodRef method, MethodKind kind) {\n-        methods.add(new MethodInfo(method.tag, method.getSignature(), Type.getObjectType(method.owner), kind));\n+    public void addMethod(int access, MethodRef method, MethodKind kind) {\n+        methods.add(new MethodInfo(access, method.tag, method.getSignature(), Type.getObjectType(method.owner), kind));\n     }\n \n     public Optional<Type> getCompanionClass() {\n"
    },
    {
        "commit_hash": "fb6101aecd89822b2bac253e9bdd31116cbebf23",
        "previous_commit_hash": "365b81989333e76915976206073a34c759386e2d",
        "diff_stats": {
            "additions": 7,
            "deletions": 4
        },
        "diff_content": "@@ -11,16 +11,19 @@ import java.util.Objects;\n \n public class MethodInfo {\n \n+    public final int access;\n     public final int tag;\n     public final MethodSignature signature;\n     public final Type owner;\n     public final MethodKind kind;\n \n-    public MethodInfo(String name, String desc, Class<?> owner, MethodKind kind) { // only for tests, so we can ignore the tag\n-        this(-1, new MethodSignature(name, desc), Type.getType(owner), kind);\n+    public MethodInfo(String name, String desc, Class<?> owner, MethodKind kind) {\n+        // only for tests, so we can ignore the tag and access\n+        this(0, -1, new MethodSignature(name, desc), Type.getType(owner), kind);\n     }\n \n-    public MethodInfo(int tag, MethodSignature signature, Type owner, MethodKind kind) {\n+    public MethodInfo(int access, int tag, MethodSignature signature, Type owner, MethodKind kind) {\n+        this.access = access;\n         this.tag = tag;\n         this.signature = signature;\n         this.owner = owner;\n@@ -58,7 +61,7 @@ public class MethodInfo {\n                 .addValue(signature)\n                 .addValue(owner)\n                 .addValue(kind)\n-                .addValue(\"(\" + tag + \")\")\n+                .addValue(\"(tag=\" + tag + \", access=\" + access + \")\")\n                 .toString();\n     }\n }\n"
    },
    {
        "commit_hash": "fb6101aecd89822b2bac253e9bdd31116cbebf23",
        "previous_commit_hash": "365b81989333e76915976206073a34c759386e2d",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -11,9 +11,9 @@ import static org.objectweb.asm.Opcodes.ASM5;\n \n public class UpdateRelocatedMethodInvocations extends ClassVisitor {\n \n-    private final ClassHierarchyAnalyzer analyzer;\n+    private final ClassAnalyzer analyzer;\n \n-    public UpdateRelocatedMethodInvocations(ClassVisitor next, ClassHierarchyAnalyzer analyzer) {\n+    public UpdateRelocatedMethodInvocations(ClassVisitor next, ClassAnalyzer analyzer) {\n         super(ASM5, next);\n         this.analyzer = analyzer;\n     }\n"
    },
    {
        "commit_hash": "fb6101aecd89822b2bac253e9bdd31116cbebf23",
        "previous_commit_hash": "365b81989333e76915976206073a34c759386e2d",
        "diff_stats": {
            "additions": 42,
            "deletions": 7
        },
        "diff_content": "@@ -4,6 +4,7 @@\n \n package net.orfjackal.retrolambda.lambdas;\n \n+import net.orfjackal.retrolambda.interfaces.*;\n import net.orfjackal.retrolambda.util.Bytecode;\n import org.objectweb.asm.*;\n \n@@ -18,10 +19,12 @@ public class BackportLambdaInvocations extends ClassVisitor {\n \n     private int classAccess;\n     private String className;\n+    private final ClassAnalyzer analyzer;\n     private final Map<Handle, Handle> lambdaAccessToImplMethods = new LinkedHashMap<>();\n \n-    public BackportLambdaInvocations(ClassVisitor next) {\n+    public BackportLambdaInvocations(ClassVisitor next, ClassAnalyzer analyzer) {\n         super(ASM5, next);\n+        this.analyzer = analyzer;\n     }\n \n     @Override\n@@ -56,13 +59,19 @@ public class BackportLambdaInvocations extends ClassVisitor {\n \n     Handle getLambdaAccessMethod(Handle implMethod) {\n         if (!implMethod.getOwner().equals(className)) {\n-            return implMethod;\n-        }\n-        if (isInterface(classAccess)) {\n-            // the method will be relocated to a companion class\n-            return implMethod;\n+            if (isNonOwnedMethodVisible(implMethod)) {\n+                return implMethod;\n+            }\n+        } else {\n+            if (isInterface(classAccess)) {\n+                // the method will be relocated to a companion class\n+                return implMethod;\n+            }\n+            if (isOwnedMethodVisible(implMethod)) {\n+                // The method is visible to the companion class and therefore doesn't need an accessor.\n+                return implMethod;\n+            }\n         }\n-        // TODO: do not generate an access method if the impl method is not private (probably not implementable with a single pass)\n         String name = \"access$lambda$\" + lambdaAccessToImplMethods.size();\n         String desc = getLambdaAccessMethodDesc(implMethod);\n         Handle accessMethod = new Handle(H_INVOKESTATIC, className, name, desc);\n@@ -70,6 +79,32 @@ public class BackportLambdaInvocations extends ClassVisitor {\n         return accessMethod;\n     }\n \n+    private boolean isOwnedMethodVisible(Handle implMethod) {\n+        MethodSignature implSignature = new MethodSignature(implMethod.getName(), implMethod.getDesc());\n+\n+        Collection<MethodInfo> methods = analyzer.getMethods(Type.getObjectType(implMethod.getOwner()));\n+        for (MethodInfo method : methods) {\n+            if (method.signature.equals(implSignature)) {\n+                // The method will be visible to the companion class if the private flag is absent.\n+                return (method.access & ACC_PRIVATE) == 0;\n+            }\n+        }\n+        throw new IllegalStateException(\"Non-analyzed method \" + implMethod + \". Report this as a bug.\");\n+    }\n+\n+    private boolean isNonOwnedMethodVisible(Handle implMethod) {\n+        MethodSignature implSignature = new MethodSignature(implMethod.getName(), implMethod.getDesc());\n+\n+        Collection<MethodInfo> methods = analyzer.getMethods(Type.getObjectType(implMethod.getOwner()));\n+        for (MethodInfo method : methods) {\n+            if (method.signature.equals(implSignature)) {\n+                // The method will be visible to the companion class if the protected flag is absent.\n+                return (method.access & ACC_PROTECTED) == 0;\n+            }\n+        }\n+        return true;\n+    }\n+\n     private String getLambdaAccessMethodDesc(Handle implMethod) {\n         if (implMethod.getTag() == H_INVOKESTATIC) {\n             // static method call -> keep as-is\n"
    },
    {
        "commit_hash": "fb6101aecd89822b2bac253e9bdd31116cbebf23",
        "previous_commit_hash": "365b81989333e76915976206073a34c759386e2d",
        "diff_stats": {
            "additions": 34,
            "deletions": 34
        },
        "diff_content": "@@ -6,7 +6,7 @@ package net.orfjackal.retrolambda;\n \n import com.google.common.io.ByteStreams;\n import net.orfjackal.retrolambda.interfaces.*;\n-import org.junit.Test;\n+import org.junit.*;\n import org.objectweb.asm.Type;\n \n import java.io.*;\n@@ -21,9 +21,9 @@ import static org.hamcrest.Matchers.*;\n import static org.objectweb.asm.Opcodes.*;\n \n @SuppressWarnings(\"UnusedDeclaration\")\n-public class ClassHierarchyAnalyzerTest {\n+public class ClassAnalyzerTest {\n \n-    private final ClassHierarchyAnalyzer analyzer = new ClassHierarchyAnalyzer();\n+    private final ClassAnalyzer analyzer = new ClassAnalyzer();\n \n     @Test\n     public void lists_interfaces_and_classes_separately() {\n@@ -44,13 +44,13 @@ public class ClassHierarchyAnalyzerTest {\n                 InterfaceImplementer.class);\n \n         assertThat(\"original\", analyzer.getMethods(Type.getType(Interface.class)),\n-                containsInAnyOrder(new MethodInfo(\"abstractMethod\", \"()V\", Interface.class, new MethodKind.Abstract())));\n+                hasItem(new MethodInfo(\"abstractMethod\", \"()V\", Interface.class, new MethodKind.Abstract())));\n \n         assertThat(\"inherits unchanged\", analyzer.getMethods(Type.getType(ChildInterface.class)),\n-                containsInAnyOrder(new MethodInfo(\"abstractMethod\", \"()V\", Interface.class, new MethodKind.Abstract())));\n+                hasItem(new MethodInfo(\"abstractMethod\", \"()V\", Interface.class, new MethodKind.Abstract())));\n \n         assertThat(\"implements\", analyzer.getMethods(Type.getType(InterfaceImplementer.class)),\n-                containsInAnyOrder(new MethodInfo(\"abstractMethod\", \"()V\", InterfaceImplementer.class, new MethodKind.Implemented())));\n+                hasItem(new MethodInfo(\"abstractMethod\", \"()V\", InterfaceImplementer.class, new MethodKind.Implemented())));\n     }\n \n     private interface Interface {\n@@ -72,10 +72,10 @@ public class ClassHierarchyAnalyzerTest {\n         analyze(InterfaceMethodTypes.class);\n \n         assertThat(analyzer.getMethods(Type.getType(InterfaceMethodTypes.class)),\n-                containsInAnyOrder(\n+                hasItems(\n                         new MethodInfo(\"abstractMethod\", \"()V\", InterfaceMethodTypes.class, new MethodKind.Abstract()),\n                         new MethodInfo(\"defaultMethod\", \"()V\", InterfaceMethodTypes.class, new MethodKind.Default(\n-                                new MethodRef(H_INVOKESTATIC, InterfaceMethodTypes$.class, \"defaultMethod\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$InterfaceMethodTypes;)V\")))));\n+                                new MethodRef(H_INVOKESTATIC, InterfaceMethodTypes$.class, \"defaultMethod\", \"(Lnet/orfjackal/retrolambda/ClassAnalyzerTest$InterfaceMethodTypes;)V\")))));\n     }\n \n     @Test\n@@ -85,7 +85,7 @@ public class ClassHierarchyAnalyzerTest {\n         // An abstract instance method takes precedence over a default method,\n         // so we handle abstract instance methods the same way as concrete instance methods.\n         assertThat(analyzer.getMethods(Type.getType(ClassMethodTypes.class)),\n-                containsInAnyOrder(\n+                hasItems(\n                         new MethodInfo(\"abstractMethod\", \"()V\", ClassMethodTypes.class, new MethodKind.Implemented()),\n                         new MethodInfo(\"instanceMethod\", \"()V\", ClassMethodTypes.class, new MethodKind.Implemented())));\n     }\n@@ -125,19 +125,19 @@ public class ClassHierarchyAnalyzerTest {\n                 containsInAnyOrder(\n                         new MethodInfo(\"abstractMethod\", \"()V\", HasDefaultMethods.class, new MethodKind.Abstract()),\n                         new MethodInfo(\"defaultMethod\", \"()V\", HasDefaultMethods.class, new MethodKind.Default(\n-                                new MethodRef(H_INVOKESTATIC, HasDefaultMethods$.class, \"defaultMethod\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$HasDefaultMethods;)V\")))));\n+                                new MethodRef(H_INVOKESTATIC, HasDefaultMethods$.class, \"defaultMethod\", \"(Lnet/orfjackal/retrolambda/ClassAnalyzerTest$HasDefaultMethods;)V\")))));\n \n         assertThat(\"inherits unchanged\", analyzer.getMethods(Type.getType(DoesNotOverrideDefaultMethods.class)),\n                 containsInAnyOrder(\n                         new MethodInfo(\"abstractMethod\", \"()V\", HasDefaultMethods.class, new MethodKind.Abstract()),\n                         new MethodInfo(\"defaultMethod\", \"()V\", HasDefaultMethods.class, new MethodKind.Default(\n-                                new MethodRef(H_INVOKESTATIC, HasDefaultMethods$.class, \"defaultMethod\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$HasDefaultMethods;)V\")))));\n+                                new MethodRef(H_INVOKESTATIC, HasDefaultMethods$.class, \"defaultMethod\", \"(Lnet/orfjackal/retrolambda/ClassAnalyzerTest$HasDefaultMethods;)V\")))));\n \n         assertThat(\"changes default impl\", analyzer.getMethods(Type.getType(OverridesDefaultMethods.class)),\n                 containsInAnyOrder(\n                         new MethodInfo(\"abstractMethod\", \"()V\", HasDefaultMethods.class, new MethodKind.Abstract()),\n                         new MethodInfo(\"defaultMethod\", \"()V\", OverridesDefaultMethods.class, new MethodKind.Default(\n-                                new MethodRef(H_INVOKESTATIC, OverridesDefaultMethods$.class, \"defaultMethod\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$OverridesDefaultMethods;)V\")))));\n+                                new MethodRef(H_INVOKESTATIC, OverridesDefaultMethods$.class, \"defaultMethod\", \"(Lnet/orfjackal/retrolambda/ClassAnalyzerTest$OverridesDefaultMethods;)V\")))));\n \n         assertThat(\"makes abstract\", analyzer.getMethods(Type.getType(AbstractsDefaultMethods.class)),\n                 containsInAnyOrder(\n@@ -179,11 +179,11 @@ public class ClassHierarchyAnalyzerTest {\n                 ChildClass.class);\n \n         assertThat(\"original\", analyzer.getMethods(Type.getType(BaseClass.class)),\n-                containsInAnyOrder(\n+                hasItem(\n                         new MethodInfo(\"baseMethod\", \"()V\", BaseClass.class, new MethodKind.Implemented())));\n \n         assertThat(\"inherits unchanged\", analyzer.getMethods(Type.getType(ChildClass.class)),\n-                containsInAnyOrder(\n+                hasItem(\n                         new MethodInfo(\"baseMethod\", \"()V\", BaseClass.class, new MethodKind.Implemented())));\n     }\n \n@@ -205,25 +205,25 @@ public class ClassHierarchyAnalyzerTest {\n                 InheritsOverridesDefaultAndDirectlyImplements.class);\n \n         assertThat(\"original\", analyzer.getMethods(Type.getType(DefaultMethods.class)),\n-                containsInAnyOrder(\n+                hasItem(\n                         new MethodInfo(\"foo\", \"()V\", DefaultMethods.class, new MethodKind.Default(\n-                                new MethodRef(H_INVOKESTATIC, DefaultMethods$.class, \"foo\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$DefaultMethods;)V\")))));\n+                                new MethodRef(H_INVOKESTATIC, DefaultMethods$.class, \"foo\", \"(Lnet/orfjackal/retrolambda/ClassAnalyzerTest$DefaultMethods;)V\")))));\n \n         assertThat(\"inherits unchanged\", analyzer.getMethods(Type.getType(InheritsDefault.class)),\n-                containsInAnyOrder(\n+                hasItem(\n                         new MethodInfo(\"foo\", \"()V\", DefaultMethods.class, new MethodKind.Default(\n-                                new MethodRef(H_INVOKESTATIC, DefaultMethods$.class, \"foo\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$DefaultMethods;)V\")))));\n+                                new MethodRef(H_INVOKESTATIC, DefaultMethods$.class, \"foo\", \"(Lnet/orfjackal/retrolambda/ClassAnalyzerTest$DefaultMethods;)V\")))));\n \n         assertThat(\"overrides\", analyzer.getMethods(Type.getType(OverridesDefault.class)),\n-                containsInAnyOrder(\n+                hasItem(\n                         new MethodInfo(\"foo\", \"()V\", OverridesDefault.class, new MethodKind.Implemented())));\n \n         assertThat(\"inherits overridden\", analyzer.getMethods(Type.getType(InheritsOverridesDefault.class)),\n-                containsInAnyOrder(\n+                hasItem(\n                         new MethodInfo(\"foo\", \"()V\", OverridesDefault.class, new MethodKind.Implemented())));\n \n         assertThat(\"inherits overridden\", analyzer.getMethods(Type.getType(InheritsOverridesDefaultAndDirectlyImplements.class)),\n-                containsInAnyOrder(\n+                hasItem(\n                         new MethodInfo(\"foo\", \"()V\", OverridesDefault.class, new MethodKind.Implemented())));\n     }\n \n@@ -261,9 +261,9 @@ public class ClassHierarchyAnalyzerTest {\n                 InheritsOriginalAndOverridden.class);\n \n         MethodInfo original = new MethodInfo(\"foo\", \"()V\", SuperOriginal.class, new MethodKind.Default(\n-                new MethodRef(H_INVOKESTATIC, SuperOriginal$.class, \"foo\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$SuperOriginal;)V\")));\n+                new MethodRef(H_INVOKESTATIC, SuperOriginal$.class, \"foo\", \"(Lnet/orfjackal/retrolambda/ClassAnalyzerTest$SuperOriginal;)V\")));\n         MethodInfo overridden = new MethodInfo(\"foo\", \"()V\", SuperOverridden.class, new MethodKind.Default(\n-                new MethodRef(H_INVOKESTATIC, SuperOverridden$.class, \"foo\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$SuperOverridden;)V\")));\n+                new MethodRef(H_INVOKESTATIC, SuperOverridden$.class, \"foo\", \"(Lnet/orfjackal/retrolambda/ClassAnalyzerTest$SuperOverridden;)V\")));\n \n         assertThat(\"inherits original\", analyzer.getMethods(Type.getType(InheritsOriginal.class)),\n                 containsInAnyOrder(original));\n@@ -315,18 +315,18 @@ public class ClassHierarchyAnalyzerTest {\n                 ExtendsImplementsOriginalAndImplementsOverriddenDefault.class);\n \n         MethodInfo original = new MethodInfo(\"foo\", \"()V\", OriginalDefault.class, new MethodKind.Default(\n-                new MethodRef(H_INVOKESTATIC, OriginalDefault$.class, \"foo\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$OriginalDefault;)V\")));\n+                new MethodRef(H_INVOKESTATIC, OriginalDefault$.class, \"foo\", \"(Lnet/orfjackal/retrolambda/ClassAnalyzerTest$OriginalDefault;)V\")));\n         MethodInfo overridden = new MethodInfo(\"foo\", \"()V\", OverriddenDefault.class, new MethodKind.Default(\n-                new MethodRef(H_INVOKESTATIC, OverriddenDefault$.class, \"foo\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$OverriddenDefault;)V\")));\n+                new MethodRef(H_INVOKESTATIC, OverriddenDefault$.class, \"foo\", \"(Lnet/orfjackal/retrolambda/ClassAnalyzerTest$OverriddenDefault;)V\")));\n \n         assertThat(\"implements original\", analyzer.getMethods(Type.getType(ImplementsOriginal.class)),\n-                containsInAnyOrder(original));\n+                hasItem(original));\n         assertThat(\"implements original and overridden\", analyzer.getMethods(Type.getType(ImplementsOriginalAndOverriddenDefault.class)),\n-                containsInAnyOrder(overridden));\n+                hasItem(overridden));\n         assertThat(\"implements overridden and original\", analyzer.getMethods(Type.getType(ImplementsOverriddenAndOriginalDefault.class)),\n-                containsInAnyOrder(overridden));\n+                hasItem(overridden));\n         assertThat(\"extends implementor of original and implements overridden\", analyzer.getMethods(Type.getType(ExtendsImplementsOriginalAndImplementsOverriddenDefault.class)),\n-                containsInAnyOrder(overridden));\n+                hasItem(overridden));\n     }\n \n     private interface OriginalDefault {\n@@ -365,13 +365,13 @@ public class ClassHierarchyAnalyzerTest {\n                 ImplementsUsesLambdas.class);\n \n         MethodInfo stateless = new MethodInfo(\"stateless\", \"()Ljava/util/concurrent/Callable;\", UsesLambdas.class, new MethodKind.Default(\n-                new MethodRef(H_INVOKESTATIC, UsesLambdas$.class, \"stateless\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$UsesLambdas;)Ljava/util/concurrent/Callable;\")));\n+                new MethodRef(H_INVOKESTATIC, UsesLambdas$.class, \"stateless\", \"(Lnet/orfjackal/retrolambda/ClassAnalyzerTest$UsesLambdas;)Ljava/util/concurrent/Callable;\")));\n         MethodInfo captureThis = new MethodInfo(\"captureThis\", \"()Ljava/util/concurrent/Callable;\", UsesLambdas.class, new MethodKind.Default(\n-                new MethodRef(H_INVOKESTATIC, UsesLambdas$.class, \"captureThis\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$UsesLambdas;)Ljava/util/concurrent/Callable;\")));\n+                new MethodRef(H_INVOKESTATIC, UsesLambdas$.class, \"captureThis\", \"(Lnet/orfjackal/retrolambda/ClassAnalyzerTest$UsesLambdas;)Ljava/util/concurrent/Callable;\")));\n \n         assertThat(\"does not copy instance lambda impl methods to implementers\",\n                 analyzer.getMethods(Type.getType(ImplementsUsesLambdas.class)),\n-                containsInAnyOrder(stateless, captureThis));\n+                hasItems(stateless, captureThis));\n     }\n \n     private interface UsesLambdas {\n@@ -537,13 +537,13 @@ public class ClassHierarchyAnalyzerTest {\n \n     private static List<Class<?>> infosToClasses(List<ClassInfo> classes) {\n         return classes.stream()\n-                .map(ClassHierarchyAnalyzerTest::toClass)\n+                .map(ClassAnalyzerTest::toClass)\n                 .collect(toList());\n     }\n \n     private static List<Class<?>> typesToClasses(List<Type> types) {\n         return types.stream()\n-                .map(ClassHierarchyAnalyzerTest::toClass)\n+                .map(ClassAnalyzerTest::toClass)\n                 .collect(toList());\n     }\n \n"
    },
    {
        "commit_hash": "bf932457e45817cdee07f34c8c2059db44848e03",
        "previous_commit_hash": "365b81989333e76915976206073a34c759386e2d",
        "diff_stats": {
            "additions": 21,
            "deletions": 0
        },
        "diff_content": "@@ -4,6 +4,7 @@\n \n package net.orfjackal.retrolambda.test;\n \n+import com.google.common.collect.ImmutableSet;\n import org.junit.Test;\n \n import java.lang.reflect.Method;\n@@ -85,4 +86,24 @@ public class LambdaClassesTest {\n             };\n         }\n     }\n+\n+\n+    @Test\n+    public void lambda_bodies_contain_no_unnecessary_methods() throws ClassNotFoundException {\n+        Set<String> expected = ImmutableSet.of(\"lambda$main$0\", \"main\");\n+\n+        Set<String> actual = new HashSet<>();\n+        for (Method method : HasLambdaBody.class.getDeclaredMethods()) {\n+            actual.add(method.getName());\n+        }\n+        assertThat(actual, is(expected));\n+    }\n+\n+    @SuppressWarnings(\"UnusedDeclaration\")\n+    private class HasLambdaBody {\n+        private void main() {\n+            Runnable lambda = () -> {\n+            };\n+        }\n+    }\n }\n"
    },
    {
        "commit_hash": "bf932457e45817cdee07f34c8c2059db44848e03",
        "previous_commit_hash": "365b81989333e76915976206073a34c759386e2d",
        "diff_stats": {
            "additions": 3,
            "deletions": 5
        },
        "diff_content": "@@ -4,6 +4,7 @@\n \n package net.orfjackal.retrolambda.interfaces;\n \n+import net.orfjackal.retrolambda.lambdas.LambdaNaming;\n import org.objectweb.asm.*;\n import org.objectweb.asm.tree.MethodNode;\n \n@@ -18,7 +19,8 @@ public class RemoveDefaultMethodBodies extends ClassVisitor {\n \n     @Override\n     public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n-        if (isPrivateInstanceMethod(access)) { // lambda impl methods which capture `this` are private instance methods\n+        if (LambdaNaming.isBodyMethod(access, name)) {\n+            // lambda impl methods which capture `this` are synthetic instance methods\n             return null;\n         }\n         if (isDefaultMethod(access)) {\n@@ -29,10 +31,6 @@ public class RemoveDefaultMethodBodies extends ClassVisitor {\n         }\n     }\n \n-    private static boolean isPrivateInstanceMethod(int access) {\n-        return isPrivateMethod(access) && isInstanceMethod(access);\n-    }\n-\n     private static boolean isDefaultMethod(int access) {\n         return isConcreteMethod(access) && isInstanceMethod(access);\n     }\n"
    },
    {
        "commit_hash": "bf932457e45817cdee07f34c8c2059db44848e03",
        "previous_commit_hash": "365b81989333e76915976206073a34c759386e2d",
        "diff_stats": {
            "additions": 11,
            "deletions": 0
        },
        "diff_content": "@@ -48,6 +48,10 @@ public class BackportLambdaInvocations extends ClassVisitor {\n \n     @Override\n     public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+        if (LambdaNaming.isBodyMethod(access, name)) {\n+            // Ensure our generated lambda class is able to call this method.\n+            access &= ~ACC_PRIVATE;\n+        }\n         if (LambdaNaming.isDeserializationHook(access, name, desc)) {\n             return null; // remove serialization hooks; we serialize lambda instances as-is\n         }\n@@ -62,6 +66,13 @@ public class BackportLambdaInvocations extends ClassVisitor {\n             // the method will be relocated to a companion class\n             return implMethod;\n         }\n+        if (LambdaNaming.isBodyMethodName(implMethod.getName())) {\n+            if (implMethod.getTag() == H_INVOKESPECIAL) {\n+                // The private body method is now package so switch its invocation from special to virtual.\n+                return new Handle(H_INVOKEVIRTUAL, implMethod.getOwner(), implMethod.getName(), implMethod.getDesc());\n+            }\n+            return implMethod;\n+        }\n         // TODO: do not generate an access method if the impl method is not private (probably not implementable with a single pass)\n         String name = \"access$lambda$\" + lambdaAccessToImplMethods.size();\n         String desc = getLambdaAccessMethodDesc(implMethod);\n"
    },
    {
        "commit_hash": "bf932457e45817cdee07f34c8c2059db44848e03",
        "previous_commit_hash": "365b81989333e76915976206073a34c759386e2d",
        "diff_stats": {
            "additions": 8,
            "deletions": 0
        },
        "diff_content": "@@ -37,4 +37,12 @@ public class LambdaNaming {\n                 && desc.equals(targetDesc)\n                 && Flags.hasFlag(access, ACC_PRIVATE | ACC_STATIC);\n     }\n+\n+    public static boolean isBodyMethodName(String name) {\n+        return name.startsWith(\"lambda$\");\n+    }\n+\n+    public static boolean isBodyMethod(int access, String name) {\n+        return isBodyMethodName(name) && Flags.hasFlag(access, ACC_SYNTHETIC);\n+    }\n }\n"
    },
    {
        "commit_hash": "374913535af8791eaf64fbb806e23a257742a051",
        "previous_commit_hash": "4ba9700c8e6b3186bf6e5e5e18cde97e447c9856",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>com.jakewharton.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.1.0-jake1-SNAPSHOT</version>\n+        <version>2.1.0-jake1</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "374913535af8791eaf64fbb806e23a257742a051",
        "previous_commit_hash": "4ba9700c8e6b3186bf6e5e5e18cde97e447c9856",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>com.jakewharton.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>2.1.0-jake1-SNAPSHOT</version>\n+    <version>2.1.0-jake1</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "374913535af8791eaf64fbb806e23a257742a051",
        "previous_commit_hash": "4ba9700c8e6b3186bf6e5e5e18cde97e447c9856",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>com.jakewharton.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.1.0-jake1-SNAPSHOT</version>\n+        <version>2.1.0-jake1</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "374913535af8791eaf64fbb806e23a257742a051",
        "previous_commit_hash": "4ba9700c8e6b3186bf6e5e5e18cde97e447c9856",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>com.jakewharton.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.1.0-jake1-SNAPSHOT</version>\n+        <version>2.1.0-jake1</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "374913535af8791eaf64fbb806e23a257742a051",
        "previous_commit_hash": "4ba9700c8e6b3186bf6e5e5e18cde97e447c9856",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>com.jakewharton.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.1.0-jake1-SNAPSHOT</version>\n+        <version>2.1.0-jake1</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "4ccadc890ee1ab2ccd01c863bb514859d82b2ba6",
        "previous_commit_hash": "374913535af8791eaf64fbb806e23a257742a051",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>com.jakewharton.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.1.0-jake1</version>\n+        <version>2.1.0-jake2-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "4ccadc890ee1ab2ccd01c863bb514859d82b2ba6",
        "previous_commit_hash": "374913535af8791eaf64fbb806e23a257742a051",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>com.jakewharton.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>2.1.0-jake1</version>\n+    <version>2.1.0-jake2-SNAPSHOT</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "4ccadc890ee1ab2ccd01c863bb514859d82b2ba6",
        "previous_commit_hash": "374913535af8791eaf64fbb806e23a257742a051",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>com.jakewharton.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.1.0-jake1</version>\n+        <version>2.1.0-jake2-SNAPSHOT</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "4ccadc890ee1ab2ccd01c863bb514859d82b2ba6",
        "previous_commit_hash": "374913535af8791eaf64fbb806e23a257742a051",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>com.jakewharton.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.1.0-jake1</version>\n+        <version>2.1.0-jake2-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "4ccadc890ee1ab2ccd01c863bb514859d82b2ba6",
        "previous_commit_hash": "374913535af8791eaf64fbb806e23a257742a051",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>com.jakewharton.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.1.0-jake1</version>\n+        <version>2.1.0-jake2-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "757247be7cd95fcb4266d673590251ba6cc3100a",
        "previous_commit_hash": "4ccadc890ee1ab2ccd01c863bb514859d82b2ba6",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -46,7 +46,7 @@ These changes have saved approximately 1500-2000 methods from being generated fo\n \n This fork also integrates PRs from other contributors made upstream which are not yet merged:\n \n- *  [**Rewrite calls to Objects.requireNonNull**]()\n+ *  [**Rewrite calls to Objects.requireNonNull**](https://github.com/orfjackal/retrolambda/pull/93)\n \n     When compiling with JDK 9, `javac` uses the Java 7-only `Objects.requireNonNull` method for\n     nullability checks. In order to be compatible with pre-Java 7 runtimes, this is rewritten\n"
    },
    {
        "commit_hash": "7f54cd156f1e9ef1699d8f8d034d0117d2d27c66",
        "previous_commit_hash": "757247be7cd95fcb4266d673590251ba6cc3100a",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -22,7 +22,7 @@ made upstream which are not yet merged and/or released:\n     method, though, this accessor does not need to be generated.\n \n     Additionally, when a protected method is referenced from a base class, an additional accessor\n-    method needs to be generated. This allows the generated class to invoke the method though the\n+    method needs to be generated. This allows the generated class to invoke the method through the\n     accessor which is otherwise only visible to the subclass.\n \n  *  [**Remove NEW, DUP instructions when changing NEWINVOKESPECIAL to INVOKESTATIC.**](https://github.com/orfjackal/retrolambda/pull/85)\n"
    },
    {
        "commit_hash": "52364bca1dd1e07301792f7dccd362cb5209ab74",
        "previous_commit_hash": "365b81989333e76915976206073a34c759386e2d",
        "diff_stats": {
            "additions": 22,
            "deletions": 0
        },
        "diff_content": "@@ -4,6 +4,7 @@\n \n package net.orfjackal.retrolambda.test;\n \n+import net.orfjackal.retrolambda.test.anotherpackage.DifferentPackageBase;\n import org.apache.commons.lang.SystemUtils;\n import org.junit.Test;\n import org.objectweb.asm.*;\n@@ -150,6 +151,27 @@ public class LambdaTest extends SuperClass {\n         assertThat(ref.call(), is(instanceOf(ArrayList.class)));\n     }\n \n+    @Test\n+    public void method_references_to_protected_supertype_methods() throws Exception {\n+        Callable<String> ref1 = new SubclassInMyPackage().thing();\n+        assertThat(ref1.call(), equalTo(\"Hello\"));\n+\n+        Callable<String> ref2 = new SubclassInSamePackage().thing();\n+        assertThat(ref2.call(), equalTo(\"Hello\"));\n+    }\n+\n+    public static class SubclassInMyPackage extends DifferentPackageBase {\n+        public Callable<String> thing() {\n+            return DifferentPackageBase::value;\n+        }\n+    }\n+\n+    public static class SubclassInSamePackage extends SamePackageBase {\n+        public Callable<String> thing() {\n+            return SamePackageBase::value;\n+        }\n+    }\n+\n     /**\n      * Because the constructor is private, an access method must be generated for it\n      * and also the NEW instruction must be done inside the access method.\n"
    },
    {
        "commit_hash": "52364bca1dd1e07301792f7dccd362cb5209ab74",
        "previous_commit_hash": "365b81989333e76915976206073a34c759386e2d",
        "diff_stats": {
            "additions": 11,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,11 @@\n+// Copyright \u00a9 2013-2016 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.test;\n+\n+public class SamePackageBase {\n+    protected static String value() {\n+        return \"Hello\";\n+    }\n+}\n"
    },
    {
        "commit_hash": "52364bca1dd1e07301792f7dccd362cb5209ab74",
        "previous_commit_hash": "365b81989333e76915976206073a34c759386e2d",
        "diff_stats": {
            "additions": 11,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,11 @@\n+// Copyright \u00a9 2013-2016 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.test.anotherpackage;\n+\n+public class DifferentPackageBase {\n+    protected static String value() {\n+        return \"Hello\";\n+    }\n+}\n"
    },
    {
        "commit_hash": "52364bca1dd1e07301792f7dccd362cb5209ab74",
        "previous_commit_hash": "365b81989333e76915976206073a34c759386e2d",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -38,7 +38,7 @@ public class Retrolambda {\n \n         Thread.currentThread().setContextClassLoader(new NonDelegatingClassLoader(asUrls(classpath)));\n \n-        ClassHierarchyAnalyzer analyzer = new ClassHierarchyAnalyzer();\n+        ClassAnalyzer analyzer = new ClassAnalyzer();\n         OutputDirectory outputDirectory = new OutputDirectory(outputDir);\n         Transformers transformers = new Transformers(bytecodeVersion, defaultMethodsEnabled, analyzer);\n         LambdaClassSaver lambdaClassSaver = new LambdaClassSaver(outputDirectory, transformers);\n"
    },
    {
        "commit_hash": "52364bca1dd1e07301792f7dccd362cb5209ab74",
        "previous_commit_hash": "365b81989333e76915976206073a34c759386e2d",
        "diff_stats": {
            "additions": 4,
            "deletions": 4
        },
        "diff_content": "@@ -17,9 +17,9 @@ public class Transformers {\n \n     private final int targetVersion;\n     private final boolean defaultMethodsEnabled;\n-    private final ClassHierarchyAnalyzer analyzer;\n+    private final ClassAnalyzer analyzer;\n \n-    public Transformers(int targetVersion, boolean defaultMethodsEnabled, ClassHierarchyAnalyzer analyzer) {\n+    public Transformers(int targetVersion, boolean defaultMethodsEnabled, ClassAnalyzer analyzer) {\n         this.targetVersion = targetVersion;\n         this.defaultMethodsEnabled = defaultMethodsEnabled;\n         this.analyzer = analyzer;\n@@ -48,7 +48,7 @@ public class Transformers {\n                 next = new UpdateRelocatedMethodInvocations(next, analyzer);\n                 next = new AddMethodDefaultImplementations(next, analyzer);\n             }\n-            next = new BackportLambdaInvocations(next);\n+            next = new BackportLambdaInvocations(next, analyzer);\n             return next;\n         });\n     }\n@@ -59,7 +59,7 @@ public class Transformers {\n         // the wrong one of them is written to disk last.\n         ClassNode lambdasBackported = new ClassNode();\n         ClassVisitor next = lambdasBackported;\n-        next = new BackportLambdaInvocations(next);\n+        next = new BackportLambdaInvocations(next, analyzer);\n         reader.accept(next, 0);\n \n         List<byte[]> results = new ArrayList<>();\n"
    },
    {
        "commit_hash": "52364bca1dd1e07301792f7dccd362cb5209ab74",
        "previous_commit_hash": "365b81989333e76915976206073a34c759386e2d",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -11,10 +11,10 @@ import static org.objectweb.asm.Opcodes.*;\n \n public class AddMethodDefaultImplementations extends ClassVisitor {\n \n-    private final ClassHierarchyAnalyzer analyzer;\n+    private final ClassAnalyzer analyzer;\n     private String className;\n \n-    public AddMethodDefaultImplementations(ClassVisitor next, ClassHierarchyAnalyzer analyzer) {\n+    public AddMethodDefaultImplementations(ClassVisitor next, ClassAnalyzer analyzer) {\n         super(ASM5, next);\n         this.analyzer = analyzer;\n     }\n"
    },
    {
        "commit_hash": "52364bca1dd1e07301792f7dccd362cb5209ab74",
        "previous_commit_hash": "365b81989333e76915976206073a34c759386e2d",
        "diff_stats": {
            "additions": 12,
            "deletions": 6
        },
        "diff_content": "@@ -14,7 +14,7 @@ import static java.util.stream.Collectors.toList;\n import static net.orfjackal.retrolambda.util.Flags.*;\n import static org.objectweb.asm.Opcodes.*;\n \n-public class ClassHierarchyAnalyzer {\n+public class ClassAnalyzer {\n \n     private final Map<Type, ClassInfo> classes = new HashMap<>();\n     private final Map<MethodRef, MethodRef> relocatedMethods = new HashMap<>();\n@@ -45,10 +45,16 @@ public class ClassHierarchyAnalyzer {\n \n             @Override\n             public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n-                if (isConstructor(name) || isStaticMethod(access)) {\n-                    return null;\n+                int tag;\n+                if (isConstructor(name)) {\n+                    tag = H_INVOKESPECIAL;\n+                } else if (isStaticMethod(access)) {\n+                    tag = H_INVOKESTATIC;\n+                } else {\n+                    tag = H_INVOKEVIRTUAL;\n                 }\n-                c.addMethod(new MethodRef(H_INVOKEVIRTUAL, owner, name, desc), new MethodKind.Implemented());\n+\n+                c.addMethod(access, new MethodRef(tag, owner, name, desc), new MethodKind.Implemented());\n                 return null;\n             }\n \n@@ -71,12 +77,12 @@ public class ClassHierarchyAnalyzer {\n                 MethodRef method = new MethodRef(Handles.accessToTag(access, true), owner, name, desc);\n \n                 if (isAbstractMethod(access)) {\n-                    c.addMethod(method, new MethodKind.Abstract());\n+                    c.addMethod(access, method, new MethodKind.Abstract());\n \n                 } else if (isDefaultMethod(access)) {\n                     MethodRef defaultImpl = new MethodRef(H_INVOKESTATIC, companion, name, Bytecode.prependArgumentType(desc, Type.getObjectType(owner)));\n                     c.enableCompanionClass();\n-                    c.addMethod(method, new MethodKind.Default(defaultImpl));\n+                    c.addMethod(access, method, new MethodKind.Default(defaultImpl));\n \n                 } else if (isInstanceLambdaImplMethod(access)) {\n                     relocatedMethods.put(method, new MethodRef(H_INVOKESTATIC, companion, name, Bytecode.prependArgumentType(desc, Type.getObjectType(owner))));\n"
    },
    {
        "commit_hash": "52364bca1dd1e07301792f7dccd362cb5209ab74",
        "previous_commit_hash": "365b81989333e76915976206073a34c759386e2d",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -44,8 +44,8 @@ public class ClassInfo {\n         return Collections.unmodifiableList(methods);\n     }\n \n-    public void addMethod(MethodRef method, MethodKind kind) {\n-        methods.add(new MethodInfo(method.tag, method.getSignature(), Type.getObjectType(method.owner), kind));\n+    public void addMethod(int access, MethodRef method, MethodKind kind) {\n+        methods.add(new MethodInfo(access, method.tag, method.getSignature(), Type.getObjectType(method.owner), kind));\n     }\n \n     public Optional<Type> getCompanionClass() {\n"
    },
    {
        "commit_hash": "52364bca1dd1e07301792f7dccd362cb5209ab74",
        "previous_commit_hash": "365b81989333e76915976206073a34c759386e2d",
        "diff_stats": {
            "additions": 7,
            "deletions": 4
        },
        "diff_content": "@@ -11,16 +11,19 @@ import java.util.Objects;\n \n public class MethodInfo {\n \n+    public final int access;\n     public final int tag;\n     public final MethodSignature signature;\n     public final Type owner;\n     public final MethodKind kind;\n \n-    public MethodInfo(String name, String desc, Class<?> owner, MethodKind kind) { // only for tests, so we can ignore the tag\n-        this(-1, new MethodSignature(name, desc), Type.getType(owner), kind);\n+    public MethodInfo(String name, String desc, Class<?> owner, MethodKind kind) {\n+        // only for tests, so we can ignore the tag and access\n+        this(0, -1, new MethodSignature(name, desc), Type.getType(owner), kind);\n     }\n \n-    public MethodInfo(int tag, MethodSignature signature, Type owner, MethodKind kind) {\n+    public MethodInfo(int access, int tag, MethodSignature signature, Type owner, MethodKind kind) {\n+        this.access = access;\n         this.tag = tag;\n         this.signature = signature;\n         this.owner = owner;\n@@ -58,7 +61,7 @@ public class MethodInfo {\n                 .addValue(signature)\n                 .addValue(owner)\n                 .addValue(kind)\n-                .addValue(\"(\" + tag + \")\")\n+                .addValue(\"(tag=\" + tag + \", access=\" + access + \")\")\n                 .toString();\n     }\n }\n"
    },
    {
        "commit_hash": "52364bca1dd1e07301792f7dccd362cb5209ab74",
        "previous_commit_hash": "365b81989333e76915976206073a34c759386e2d",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -11,9 +11,9 @@ import static org.objectweb.asm.Opcodes.ASM5;\n \n public class UpdateRelocatedMethodInvocations extends ClassVisitor {\n \n-    private final ClassHierarchyAnalyzer analyzer;\n+    private final ClassAnalyzer analyzer;\n \n-    public UpdateRelocatedMethodInvocations(ClassVisitor next, ClassHierarchyAnalyzer analyzer) {\n+    public UpdateRelocatedMethodInvocations(ClassVisitor next, ClassAnalyzer analyzer) {\n         super(ASM5, next);\n         this.analyzer = analyzer;\n     }\n"
    },
    {
        "commit_hash": "52364bca1dd1e07301792f7dccd362cb5209ab74",
        "previous_commit_hash": "365b81989333e76915976206073a34c759386e2d",
        "diff_stats": {
            "additions": 48,
            "deletions": 7
        },
        "diff_content": "@@ -4,6 +4,7 @@\n \n package net.orfjackal.retrolambda.lambdas;\n \n+import net.orfjackal.retrolambda.interfaces.*;\n import net.orfjackal.retrolambda.util.Bytecode;\n import org.objectweb.asm.*;\n \n@@ -18,10 +19,12 @@ public class BackportLambdaInvocations extends ClassVisitor {\n \n     private int classAccess;\n     private String className;\n+    private final ClassAnalyzer analyzer;\n     private final Map<Handle, Handle> lambdaAccessToImplMethods = new LinkedHashMap<>();\n \n-    public BackportLambdaInvocations(ClassVisitor next) {\n+    public BackportLambdaInvocations(ClassVisitor next, ClassAnalyzer analyzer) {\n         super(ASM5, next);\n+        this.analyzer = analyzer;\n     }\n \n     @Override\n@@ -56,13 +59,19 @@ public class BackportLambdaInvocations extends ClassVisitor {\n \n     Handle getLambdaAccessMethod(Handle implMethod) {\n         if (!implMethod.getOwner().equals(className)) {\n-            return implMethod;\n-        }\n-        if (isInterface(classAccess)) {\n-            // the method will be relocated to a companion class\n-            return implMethod;\n+            if (isNonOwnedMethodVisible(implMethod)) {\n+                return implMethod;\n+            }\n+        } else {\n+            if (isInterface(classAccess)) {\n+                // the method will be relocated to a companion class\n+                return implMethod;\n+            }\n+            if (isOwnedMethodVisible(implMethod)) {\n+                // The method is visible to the companion class and therefore doesn't need an accessor.\n+                return implMethod;\n+            }\n         }\n-        // TODO: do not generate an access method if the impl method is not private (probably not implementable with a single pass)\n         String name = \"access$lambda$\" + lambdaAccessToImplMethods.size();\n         String desc = getLambdaAccessMethodDesc(implMethod);\n         Handle accessMethod = new Handle(H_INVOKESTATIC, className, name, desc);\n@@ -70,6 +79,38 @@ public class BackportLambdaInvocations extends ClassVisitor {\n         return accessMethod;\n     }\n \n+    private boolean isOwnedMethodVisible(Handle implMethod) {\n+        MethodSignature implSignature = new MethodSignature(implMethod.getName(), implMethod.getDesc());\n+\n+        Collection<MethodInfo> methods = analyzer.getMethods(Type.getObjectType(implMethod.getOwner()));\n+        for (MethodInfo method : methods) {\n+            if (method.signature.equals(implSignature)) {\n+                // The method will be visible to the companion class if the private flag is absent.\n+                return (method.access & ACC_PRIVATE) == 0;\n+            }\n+        }\n+        throw new IllegalStateException(\"Non-analyzed method \" + implMethod + \". Report this as a bug.\");\n+    }\n+\n+    private boolean isNonOwnedMethodVisible(Handle implMethod) {\n+        String classPackage = className.substring(0, className.lastIndexOf('/'));\n+        String implPackage = implMethod.getOwner().substring(0, implMethod.getOwner().lastIndexOf('/'));\n+        if (classPackage.equals(implPackage)) {\n+            return true; // All method visibilities in the same package will be visible.\n+        }\n+\n+        MethodSignature implSignature = new MethodSignature(implMethod.getName(), implMethod.getDesc());\n+\n+        Collection<MethodInfo> methods = analyzer.getMethods(Type.getObjectType(implMethod.getOwner()));\n+        for (MethodInfo method : methods) {\n+            if (method.signature.equals(implSignature)) {\n+                // The method will be visible to the companion class if the protected flag is absent.\n+                return (method.access & ACC_PROTECTED) == 0;\n+            }\n+        }\n+        return true;\n+    }\n+\n     private String getLambdaAccessMethodDesc(Handle implMethod) {\n         if (implMethod.getTag() == H_INVOKESTATIC) {\n             // static method call -> keep as-is\n"
    },
    {
        "commit_hash": "52364bca1dd1e07301792f7dccd362cb5209ab74",
        "previous_commit_hash": "365b81989333e76915976206073a34c759386e2d",
        "diff_stats": {
            "additions": 34,
            "deletions": 34
        },
        "diff_content": "@@ -6,7 +6,7 @@ package net.orfjackal.retrolambda;\n \n import com.google.common.io.ByteStreams;\n import net.orfjackal.retrolambda.interfaces.*;\n-import org.junit.Test;\n+import org.junit.*;\n import org.objectweb.asm.Type;\n \n import java.io.*;\n@@ -21,9 +21,9 @@ import static org.hamcrest.Matchers.*;\n import static org.objectweb.asm.Opcodes.*;\n \n @SuppressWarnings(\"UnusedDeclaration\")\n-public class ClassHierarchyAnalyzerTest {\n+public class ClassAnalyzerTest {\n \n-    private final ClassHierarchyAnalyzer analyzer = new ClassHierarchyAnalyzer();\n+    private final ClassAnalyzer analyzer = new ClassAnalyzer();\n \n     @Test\n     public void lists_interfaces_and_classes_separately() {\n@@ -44,13 +44,13 @@ public class ClassHierarchyAnalyzerTest {\n                 InterfaceImplementer.class);\n \n         assertThat(\"original\", analyzer.getMethods(Type.getType(Interface.class)),\n-                containsInAnyOrder(new MethodInfo(\"abstractMethod\", \"()V\", Interface.class, new MethodKind.Abstract())));\n+                hasItem(new MethodInfo(\"abstractMethod\", \"()V\", Interface.class, new MethodKind.Abstract())));\n \n         assertThat(\"inherits unchanged\", analyzer.getMethods(Type.getType(ChildInterface.class)),\n-                containsInAnyOrder(new MethodInfo(\"abstractMethod\", \"()V\", Interface.class, new MethodKind.Abstract())));\n+                hasItem(new MethodInfo(\"abstractMethod\", \"()V\", Interface.class, new MethodKind.Abstract())));\n \n         assertThat(\"implements\", analyzer.getMethods(Type.getType(InterfaceImplementer.class)),\n-                containsInAnyOrder(new MethodInfo(\"abstractMethod\", \"()V\", InterfaceImplementer.class, new MethodKind.Implemented())));\n+                hasItem(new MethodInfo(\"abstractMethod\", \"()V\", InterfaceImplementer.class, new MethodKind.Implemented())));\n     }\n \n     private interface Interface {\n@@ -72,10 +72,10 @@ public class ClassHierarchyAnalyzerTest {\n         analyze(InterfaceMethodTypes.class);\n \n         assertThat(analyzer.getMethods(Type.getType(InterfaceMethodTypes.class)),\n-                containsInAnyOrder(\n+                hasItems(\n                         new MethodInfo(\"abstractMethod\", \"()V\", InterfaceMethodTypes.class, new MethodKind.Abstract()),\n                         new MethodInfo(\"defaultMethod\", \"()V\", InterfaceMethodTypes.class, new MethodKind.Default(\n-                                new MethodRef(H_INVOKESTATIC, InterfaceMethodTypes$.class, \"defaultMethod\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$InterfaceMethodTypes;)V\")))));\n+                                new MethodRef(H_INVOKESTATIC, InterfaceMethodTypes$.class, \"defaultMethod\", \"(Lnet/orfjackal/retrolambda/ClassAnalyzerTest$InterfaceMethodTypes;)V\")))));\n     }\n \n     @Test\n@@ -85,7 +85,7 @@ public class ClassHierarchyAnalyzerTest {\n         // An abstract instance method takes precedence over a default method,\n         // so we handle abstract instance methods the same way as concrete instance methods.\n         assertThat(analyzer.getMethods(Type.getType(ClassMethodTypes.class)),\n-                containsInAnyOrder(\n+                hasItems(\n                         new MethodInfo(\"abstractMethod\", \"()V\", ClassMethodTypes.class, new MethodKind.Implemented()),\n                         new MethodInfo(\"instanceMethod\", \"()V\", ClassMethodTypes.class, new MethodKind.Implemented())));\n     }\n@@ -125,19 +125,19 @@ public class ClassHierarchyAnalyzerTest {\n                 containsInAnyOrder(\n                         new MethodInfo(\"abstractMethod\", \"()V\", HasDefaultMethods.class, new MethodKind.Abstract()),\n                         new MethodInfo(\"defaultMethod\", \"()V\", HasDefaultMethods.class, new MethodKind.Default(\n-                                new MethodRef(H_INVOKESTATIC, HasDefaultMethods$.class, \"defaultMethod\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$HasDefaultMethods;)V\")))));\n+                                new MethodRef(H_INVOKESTATIC, HasDefaultMethods$.class, \"defaultMethod\", \"(Lnet/orfjackal/retrolambda/ClassAnalyzerTest$HasDefaultMethods;)V\")))));\n \n         assertThat(\"inherits unchanged\", analyzer.getMethods(Type.getType(DoesNotOverrideDefaultMethods.class)),\n                 containsInAnyOrder(\n                         new MethodInfo(\"abstractMethod\", \"()V\", HasDefaultMethods.class, new MethodKind.Abstract()),\n                         new MethodInfo(\"defaultMethod\", \"()V\", HasDefaultMethods.class, new MethodKind.Default(\n-                                new MethodRef(H_INVOKESTATIC, HasDefaultMethods$.class, \"defaultMethod\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$HasDefaultMethods;)V\")))));\n+                                new MethodRef(H_INVOKESTATIC, HasDefaultMethods$.class, \"defaultMethod\", \"(Lnet/orfjackal/retrolambda/ClassAnalyzerTest$HasDefaultMethods;)V\")))));\n \n         assertThat(\"changes default impl\", analyzer.getMethods(Type.getType(OverridesDefaultMethods.class)),\n                 containsInAnyOrder(\n                         new MethodInfo(\"abstractMethod\", \"()V\", HasDefaultMethods.class, new MethodKind.Abstract()),\n                         new MethodInfo(\"defaultMethod\", \"()V\", OverridesDefaultMethods.class, new MethodKind.Default(\n-                                new MethodRef(H_INVOKESTATIC, OverridesDefaultMethods$.class, \"defaultMethod\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$OverridesDefaultMethods;)V\")))));\n+                                new MethodRef(H_INVOKESTATIC, OverridesDefaultMethods$.class, \"defaultMethod\", \"(Lnet/orfjackal/retrolambda/ClassAnalyzerTest$OverridesDefaultMethods;)V\")))));\n \n         assertThat(\"makes abstract\", analyzer.getMethods(Type.getType(AbstractsDefaultMethods.class)),\n                 containsInAnyOrder(\n@@ -179,11 +179,11 @@ public class ClassHierarchyAnalyzerTest {\n                 ChildClass.class);\n \n         assertThat(\"original\", analyzer.getMethods(Type.getType(BaseClass.class)),\n-                containsInAnyOrder(\n+                hasItem(\n                         new MethodInfo(\"baseMethod\", \"()V\", BaseClass.class, new MethodKind.Implemented())));\n \n         assertThat(\"inherits unchanged\", analyzer.getMethods(Type.getType(ChildClass.class)),\n-                containsInAnyOrder(\n+                hasItem(\n                         new MethodInfo(\"baseMethod\", \"()V\", BaseClass.class, new MethodKind.Implemented())));\n     }\n \n@@ -205,25 +205,25 @@ public class ClassHierarchyAnalyzerTest {\n                 InheritsOverridesDefaultAndDirectlyImplements.class);\n \n         assertThat(\"original\", analyzer.getMethods(Type.getType(DefaultMethods.class)),\n-                containsInAnyOrder(\n+                hasItem(\n                         new MethodInfo(\"foo\", \"()V\", DefaultMethods.class, new MethodKind.Default(\n-                                new MethodRef(H_INVOKESTATIC, DefaultMethods$.class, \"foo\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$DefaultMethods;)V\")))));\n+                                new MethodRef(H_INVOKESTATIC, DefaultMethods$.class, \"foo\", \"(Lnet/orfjackal/retrolambda/ClassAnalyzerTest$DefaultMethods;)V\")))));\n \n         assertThat(\"inherits unchanged\", analyzer.getMethods(Type.getType(InheritsDefault.class)),\n-                containsInAnyOrder(\n+                hasItem(\n                         new MethodInfo(\"foo\", \"()V\", DefaultMethods.class, new MethodKind.Default(\n-                                new MethodRef(H_INVOKESTATIC, DefaultMethods$.class, \"foo\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$DefaultMethods;)V\")))));\n+                                new MethodRef(H_INVOKESTATIC, DefaultMethods$.class, \"foo\", \"(Lnet/orfjackal/retrolambda/ClassAnalyzerTest$DefaultMethods;)V\")))));\n \n         assertThat(\"overrides\", analyzer.getMethods(Type.getType(OverridesDefault.class)),\n-                containsInAnyOrder(\n+                hasItem(\n                         new MethodInfo(\"foo\", \"()V\", OverridesDefault.class, new MethodKind.Implemented())));\n \n         assertThat(\"inherits overridden\", analyzer.getMethods(Type.getType(InheritsOverridesDefault.class)),\n-                containsInAnyOrder(\n+                hasItem(\n                         new MethodInfo(\"foo\", \"()V\", OverridesDefault.class, new MethodKind.Implemented())));\n \n         assertThat(\"inherits overridden\", analyzer.getMethods(Type.getType(InheritsOverridesDefaultAndDirectlyImplements.class)),\n-                containsInAnyOrder(\n+                hasItem(\n                         new MethodInfo(\"foo\", \"()V\", OverridesDefault.class, new MethodKind.Implemented())));\n     }\n \n@@ -261,9 +261,9 @@ public class ClassHierarchyAnalyzerTest {\n                 InheritsOriginalAndOverridden.class);\n \n         MethodInfo original = new MethodInfo(\"foo\", \"()V\", SuperOriginal.class, new MethodKind.Default(\n-                new MethodRef(H_INVOKESTATIC, SuperOriginal$.class, \"foo\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$SuperOriginal;)V\")));\n+                new MethodRef(H_INVOKESTATIC, SuperOriginal$.class, \"foo\", \"(Lnet/orfjackal/retrolambda/ClassAnalyzerTest$SuperOriginal;)V\")));\n         MethodInfo overridden = new MethodInfo(\"foo\", \"()V\", SuperOverridden.class, new MethodKind.Default(\n-                new MethodRef(H_INVOKESTATIC, SuperOverridden$.class, \"foo\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$SuperOverridden;)V\")));\n+                new MethodRef(H_INVOKESTATIC, SuperOverridden$.class, \"foo\", \"(Lnet/orfjackal/retrolambda/ClassAnalyzerTest$SuperOverridden;)V\")));\n \n         assertThat(\"inherits original\", analyzer.getMethods(Type.getType(InheritsOriginal.class)),\n                 containsInAnyOrder(original));\n@@ -315,18 +315,18 @@ public class ClassHierarchyAnalyzerTest {\n                 ExtendsImplementsOriginalAndImplementsOverriddenDefault.class);\n \n         MethodInfo original = new MethodInfo(\"foo\", \"()V\", OriginalDefault.class, new MethodKind.Default(\n-                new MethodRef(H_INVOKESTATIC, OriginalDefault$.class, \"foo\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$OriginalDefault;)V\")));\n+                new MethodRef(H_INVOKESTATIC, OriginalDefault$.class, \"foo\", \"(Lnet/orfjackal/retrolambda/ClassAnalyzerTest$OriginalDefault;)V\")));\n         MethodInfo overridden = new MethodInfo(\"foo\", \"()V\", OverriddenDefault.class, new MethodKind.Default(\n-                new MethodRef(H_INVOKESTATIC, OverriddenDefault$.class, \"foo\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$OverriddenDefault;)V\")));\n+                new MethodRef(H_INVOKESTATIC, OverriddenDefault$.class, \"foo\", \"(Lnet/orfjackal/retrolambda/ClassAnalyzerTest$OverriddenDefault;)V\")));\n \n         assertThat(\"implements original\", analyzer.getMethods(Type.getType(ImplementsOriginal.class)),\n-                containsInAnyOrder(original));\n+                hasItem(original));\n         assertThat(\"implements original and overridden\", analyzer.getMethods(Type.getType(ImplementsOriginalAndOverriddenDefault.class)),\n-                containsInAnyOrder(overridden));\n+                hasItem(overridden));\n         assertThat(\"implements overridden and original\", analyzer.getMethods(Type.getType(ImplementsOverriddenAndOriginalDefault.class)),\n-                containsInAnyOrder(overridden));\n+                hasItem(overridden));\n         assertThat(\"extends implementor of original and implements overridden\", analyzer.getMethods(Type.getType(ExtendsImplementsOriginalAndImplementsOverriddenDefault.class)),\n-                containsInAnyOrder(overridden));\n+                hasItem(overridden));\n     }\n \n     private interface OriginalDefault {\n@@ -365,13 +365,13 @@ public class ClassHierarchyAnalyzerTest {\n                 ImplementsUsesLambdas.class);\n \n         MethodInfo stateless = new MethodInfo(\"stateless\", \"()Ljava/util/concurrent/Callable;\", UsesLambdas.class, new MethodKind.Default(\n-                new MethodRef(H_INVOKESTATIC, UsesLambdas$.class, \"stateless\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$UsesLambdas;)Ljava/util/concurrent/Callable;\")));\n+                new MethodRef(H_INVOKESTATIC, UsesLambdas$.class, \"stateless\", \"(Lnet/orfjackal/retrolambda/ClassAnalyzerTest$UsesLambdas;)Ljava/util/concurrent/Callable;\")));\n         MethodInfo captureThis = new MethodInfo(\"captureThis\", \"()Ljava/util/concurrent/Callable;\", UsesLambdas.class, new MethodKind.Default(\n-                new MethodRef(H_INVOKESTATIC, UsesLambdas$.class, \"captureThis\", \"(Lnet/orfjackal/retrolambda/ClassHierarchyAnalyzerTest$UsesLambdas;)Ljava/util/concurrent/Callable;\")));\n+                new MethodRef(H_INVOKESTATIC, UsesLambdas$.class, \"captureThis\", \"(Lnet/orfjackal/retrolambda/ClassAnalyzerTest$UsesLambdas;)Ljava/util/concurrent/Callable;\")));\n \n         assertThat(\"does not copy instance lambda impl methods to implementers\",\n                 analyzer.getMethods(Type.getType(ImplementsUsesLambdas.class)),\n-                containsInAnyOrder(stateless, captureThis));\n+                hasItems(stateless, captureThis));\n     }\n \n     private interface UsesLambdas {\n@@ -537,13 +537,13 @@ public class ClassHierarchyAnalyzerTest {\n \n     private static List<Class<?>> infosToClasses(List<ClassInfo> classes) {\n         return classes.stream()\n-                .map(ClassHierarchyAnalyzerTest::toClass)\n+                .map(ClassAnalyzerTest::toClass)\n                 .collect(toList());\n     }\n \n     private static List<Class<?>> typesToClasses(List<Type> types) {\n         return types.stream()\n-                .map(ClassHierarchyAnalyzerTest::toClass)\n+                .map(ClassAnalyzerTest::toClass)\n                 .collect(toList());\n     }\n \n"
    },
    {
        "commit_hash": "c18731cf50764fd5d3e82d4ec19f381d2c84abac",
        "previous_commit_hash": "66ef0f65b1202aac3f243e3b2ef9afbfde66686b",
        "diff_stats": {
            "additions": 7,
            "deletions": 1
        },
        "diff_content": "@@ -63,6 +63,12 @@ dependencies {\n Version History\n ---------------\n \n-### Retrolambda 2.1.0-jake1 (2016-04-27)\n+### Retrolambda 2.1.0-jake2 *(2016-04-27)*\n+\n+ * Fix: Do not generate accessor methods for protected method references in base classes when\n+   the base class is in the same package.\n+\n+\n+### Retrolambda 2.1.0-jake1 *(2016-04-27)*\n \n Initial release.\n"
    },
    {
        "commit_hash": "c18731cf50764fd5d3e82d4ec19f381d2c84abac",
        "previous_commit_hash": "66ef0f65b1202aac3f243e3b2ef9afbfde66686b",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>com.jakewharton.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.1.0-jake2-SNAPSHOT</version>\n+        <version>2.1.0-jake2</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "c18731cf50764fd5d3e82d4ec19f381d2c84abac",
        "previous_commit_hash": "66ef0f65b1202aac3f243e3b2ef9afbfde66686b",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>com.jakewharton.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>2.1.0-jake2-SNAPSHOT</version>\n+    <version>2.1.0-jake2</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "c18731cf50764fd5d3e82d4ec19f381d2c84abac",
        "previous_commit_hash": "66ef0f65b1202aac3f243e3b2ef9afbfde66686b",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>com.jakewharton.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.1.0-jake2-SNAPSHOT</version>\n+        <version>2.1.0-jake2</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "c18731cf50764fd5d3e82d4ec19f381d2c84abac",
        "previous_commit_hash": "66ef0f65b1202aac3f243e3b2ef9afbfde66686b",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>com.jakewharton.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.1.0-jake2-SNAPSHOT</version>\n+        <version>2.1.0-jake2</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "c18731cf50764fd5d3e82d4ec19f381d2c84abac",
        "previous_commit_hash": "66ef0f65b1202aac3f243e3b2ef9afbfde66686b",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>com.jakewharton.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.1.0-jake2-SNAPSHOT</version>\n+        <version>2.1.0-jake2</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "8c565e0f22a1d182398c98e805345dc2d92c3f01",
        "previous_commit_hash": "c18731cf50764fd5d3e82d4ec19f381d2c84abac",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>com.jakewharton.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.1.0-jake2</version>\n+        <version>2.1.0-jake3-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "8c565e0f22a1d182398c98e805345dc2d92c3f01",
        "previous_commit_hash": "c18731cf50764fd5d3e82d4ec19f381d2c84abac",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>com.jakewharton.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>2.1.0-jake2</version>\n+    <version>2.1.0-jake3-SNAPSHOT</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "8c565e0f22a1d182398c98e805345dc2d92c3f01",
        "previous_commit_hash": "c18731cf50764fd5d3e82d4ec19f381d2c84abac",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>com.jakewharton.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.1.0-jake2</version>\n+        <version>2.1.0-jake3-SNAPSHOT</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "8c565e0f22a1d182398c98e805345dc2d92c3f01",
        "previous_commit_hash": "c18731cf50764fd5d3e82d4ec19f381d2c84abac",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>com.jakewharton.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.1.0-jake2</version>\n+        <version>2.1.0-jake3-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "8c565e0f22a1d182398c98e805345dc2d92c3f01",
        "previous_commit_hash": "c18731cf50764fd5d3e82d4ec19f381d2c84abac",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>com.jakewharton.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.1.0-jake2</version>\n+        <version>2.1.0-jake3-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "ecf068f519c6b9bb1ca840bc69d8e1648608e75f",
        "previous_commit_hash": "8c565e0f22a1d182398c98e805345dc2d92c3f01",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -55,7 +55,7 @@ This fork also integrates PRs from other contributors made upstream which are no\n To use this version of Retrolambda in your build (with Evan T's plugin) add the following:\n ```groovy\n dependencies {\n-  retrolambdaConfig 'com.jakewharton.retrolambda:retrolambda:2.1.0-jake1'\n+  retrolambdaConfig 'com.jakewharton.retrolambda:retrolambda:2.1.0-jake2'\n }\n ```\n \n"
    },
    {
        "commit_hash": "a8a22bfa41747e7e933efb2dfb8076f7f9ce4b9c",
        "previous_commit_hash": "2e320388e087c5a4c84d4189a538425766167b06",
        "diff_stats": {
            "additions": 4,
            "deletions": 4
        },
        "diff_content": "@@ -1,13 +1,13 @@\n <component name=\"libraryTable\">\n-  <library name=\"Maven: org.ow2.asm:asm-debug-all:5.0.4\">\n+  <library name=\"Maven: org.ow2.asm:asm-debug-all:5.1\">\n     <CLASSES>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm-debug-all/5.0.4/asm-debug-all-5.0.4.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm-debug-all/5.1/asm-debug-all-5.1.jar!/\" />\n     </CLASSES>\n     <JAVADOC>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm-debug-all/5.0.4/asm-debug-all-5.0.4-javadoc.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm-debug-all/5.1/asm-debug-all-5.1-javadoc.jar!/\" />\n     </JAVADOC>\n     <SOURCES>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm-debug-all/5.0.4/asm-debug-all-5.0.4-sources.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm-debug-all/5.1/asm-debug-all-5.1-sources.jar!/\" />\n     </SOURCES>\n   </library>\n </component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "a8a22bfa41747e7e933efb2dfb8076f7f9ce4b9c",
        "previous_commit_hash": "2e320388e087c5a4c84d4189a538425766167b06",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -14,7 +14,7 @@\n     <orderEntry type=\"library\" name=\"Maven: com.google.guava:guava:11.0.2\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: com.google.code.findbugs:jsr305:1.3.9\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: commons-lang:commons-lang:2.6\" level=\"project\" />\n-    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.ow2.asm:asm-debug-all:5.0.4\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.ow2.asm:asm-debug-all:5.1\" level=\"project\" />\n     <orderEntry type=\"module-library\">\n       <library name=\"Maven: net.orfjackal.retrolambda:java-lang-dummies:1\">\n         <CLASSES>\n"
    },
    {
        "commit_hash": "a8a22bfa41747e7e933efb2dfb8076f7f9ce4b9c",
        "previous_commit_hash": "2e320388e087c5a4c84d4189a538425766167b06",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -87,7 +87,7 @@\n             <dependency>\n                 <groupId>org.ow2.asm</groupId>\n                 <artifactId>asm-debug-all</artifactId>\n-                <version>5.0.4</version>\n+                <version>5.1</version>\n             </dependency>\n \n             <!-- Testing -->\n"
    },
    {
        "commit_hash": "a8a22bfa41747e7e933efb2dfb8076f7f9ce4b9c",
        "previous_commit_hash": "2e320388e087c5a4c84d4189a538425766167b06",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -18,7 +18,7 @@\n     <orderEntry type=\"inheritedJdk\" />\n     <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n     <orderEntry type=\"module\" module-name=\"retrolambda\" />\n-    <orderEntry type=\"library\" name=\"Maven: org.ow2.asm:asm-debug-all:5.0.4\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.ow2.asm:asm-debug-all:5.1\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-plugin-api:2.0\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"PROVIDED\" name=\"Maven: org.apache.maven.plugin-tools:maven-plugin-annotations:3.4\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-artifact:3.0\" level=\"project\" />\n"
    },
    {
        "commit_hash": "a8a22bfa41747e7e933efb2dfb8076f7f9ce4b9c",
        "previous_commit_hash": "2e320388e087c5a4c84d4189a538425766167b06",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -10,7 +10,7 @@\n     </content>\n     <orderEntry type=\"inheritedJdk\" />\n     <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n-    <orderEntry type=\"library\" name=\"Maven: org.ow2.asm:asm-debug-all:5.0.4\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.ow2.asm:asm-debug-all:5.1\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: com.google.guava:guava:18.0\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.12\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-library:1.3\" level=\"project\" />\n"
    },
    {
        "commit_hash": "1e35cfc463dfeda40ef1b90ecf4ecc2163a2110c",
        "previous_commit_hash": "a8a22bfa41747e7e933efb2dfb8076f7f9ce4b9c",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -1,6 +1,6 @@\n <component name=\"CopyrightManager\">\n   <copyright>\n-    <option name=\"notice\" value=\"Copyright \u00a9 2013-&amp;#36;today.year Esko Luontola &lt;www.orfjackal.net&gt;&#10;This software is released under the Apache License 2.0.&#10;The license text is at http://www.apache.org/licenses/LICENSE-2.0\" />\n+    <option name=\"notice\" value=\"Copyright \u00a9 2013-&amp;#36;today.year Esko Luontola and other Retrolambda contributors&#10;This software is released under the Apache License 2.0.&#10;The license text is at http://www.apache.org/licenses/LICENSE-2.0\" />\n     <option name=\"keyword\" value=\"Copyright\" />\n     <option name=\"allowReplaceKeyword\" value=\"\" />\n     <option name=\"myName\" value=\"Apache 2.0\" />\n"
    },
    {
        "commit_hash": "1e35cfc463dfeda40ef1b90ecf4ecc2163a2110c",
        "previous_commit_hash": "a8a22bfa41747e7e933efb2dfb8076f7f9ce4b9c",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -92,7 +92,7 @@ Retrolambda takes Java 8 classes and backports lambda expressions and\n some other language features to work on Java 7, 6 or 5.\n Web site: https://github.com/orfjackal/retrolambda\n \n-Copyright (c) 2013-2015  Esko Luontola <www.orfjackal.net>\n+Copyright (c) 2013-2016  Esko Luontola and other Retrolambda contributors\n This software is released under the Apache License 2.0.\n The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n"
    },
    {
        "commit_hash": "1e35cfc463dfeda40ef1b90ecf4ecc2163a2110c",
        "previous_commit_hash": "a8a22bfa41747e7e933efb2dfb8076f7f9ce4b9c",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2016 Esko Luontola and other Retrolambda contributors\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -212,7 +212,7 @@ public class SystemPropertiesConfig implements Config {\n                 \"some other language features to work on Java 7, 6 or 5.\\n\" +\n                 \"Web site: https://github.com/orfjackal/retrolambda\\n\" +\n                 \"\\n\" +\n-                \"Copyright (c) 2013-2015  Esko Luontola <www.orfjackal.net>\\n\" +\n+                \"Copyright (c) 2013-2016  Esko Luontola and other Retrolambda contributors\\n\" +\n                 \"This software is released under the Apache License 2.0.\\n\" +\n                 \"The license text is at http://www.apache.org/licenses/LICENSE-2.0\\n\" +\n                 \"\\n\" +\n"
    },
    {
        "commit_hash": "afbb2d6b8e23d3612d52284b95f11fe3abb20006",
        "previous_commit_hash": "1e35cfc463dfeda40ef1b90ecf4ecc2163a2110c",
        "diff_stats": {
            "additions": 39,
            "deletions": 78
        },
        "diff_content": "@@ -1,95 +1,56 @@\n-// Copyright 2016 The Retrolambda Authors. All Rights Reserved.\n-//\n-// Licensed under the Apache License, Version 2.0 (the \"License\");\n-// you may not use this file except in compliance with the License.\n-// You may obtain a copy of the License at\n-//\n-//     http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing, software\n-// distributed under the License is distributed on an \"AS IS\" BASIS,\n-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-// See the License for the specific language governing permissions and\n-// limitations under the License.\n+// Copyright \u00a9 2013-2016 Esko Luontola and other Retrolambda contributors\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n package net.orfjackal.retrolambda.test;\n \n-import com.google.common.base.*;\n-import com.google.common.io.ByteStreams;\n-import org.apache.commons.lang.SystemUtils;\n import org.junit.Test;\n-import org.objectweb.asm.*;\n-import org.objectweb.asm.util.*;\n \n-import java.io.*;\n import java.util.Objects;\n \n-import static org.junit.Assert.assertEquals;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.*;\n \n public class RequireNonNullTest {\n \n-    static class Foo {\n-        Object test(Object x) {\n-            return Objects.requireNonNull(x);\n-        }\n+    @Test\n+    public void requireNonNull__silent_when_non_null() {\n+        Objects.requireNonNull(new Object());\n+    }\n+\n+\n+    @Test(expected = NullPointerException.class)\n+    public void requireNonNull__throws_NPE_when_null() {\n+        Objects.requireNonNull(null);\n     }\n \n     @Test\n-    public void throwsNPE() throws Exception {\n-        byte[] bytes;\n-        String path = Foo.class.getName().replace('.', '/') + \".class\";\n-        try (InputStream is = getClass().getClassLoader().getResourceAsStream(path)) {\n-            bytes = ByteStreams.toByteArray(is);\n-        }\n-        String actual = dumpMethod(bytes, \"test\");\n-        if (SystemUtils.isJavaVersionAtLeast(1.7f)) {\n-            assertEquals(\n-                    \"// access flags 0x0\\n\"\n-                    + \"test(Ljava/lang/Object;)Ljava/lang/Object;\\n\"\n-                    + \"ALOAD 1\\n\"\n-                    + \"INVOKESTATIC java/util/Objects.requireNonNull (Ljava/lang/Object;)Ljava/lang/Object;\\n\"\n-                    + \"ARETURN\\n\"\n-                    + \"MAXSTACK = 1\\n\"\n-                    + \"MAXLOCALS = 2\",\n-                    actual);\n-        } else {\n-             assertEquals(\n-                    \"// access flags 0x0\\n\"\n-                    + \"test(Ljava/lang/Object;)Ljava/lang/Object;\\n\"\n-                    + \"ALOAD 1\\n\"\n-                    + \"DUP\\n\"\n-                    + \"INVOKEVIRTUAL java/lang/Object.getClass ()Ljava/lang/Class;\\n\"\n-                    + \"POP\\n\"\n-                    + \"ARETURN\\n\"\n-                    + \"MAXSTACK = 2\\n\"\n-                    + \"MAXLOCALS = 2\",\n-                    actual);\n-        }\n+    public void requireNonNull__returns_the_argument() {\n+        Object expected = new Object();\n+\n+        Object actual = Objects.requireNonNull(expected);\n+\n+        assertThat(actual, is(sameInstance(expected)));\n+    }\n+\n+    @Test\n+    public void synthetic_null_check__silent_when_non_null() {\n+        syntheticNullCheck(new MaybeNull());\n+    }\n+\n+    @Test(expected = NullPointerException.class)\n+    public void synthetic_null_check__throws_NPE_when_null() {\n+        syntheticNullCheck(null);\n+    }\n+\n+    @SuppressWarnings(\"unused\")\n+    private static void syntheticNullCheck(MaybeNull maybeNull) {\n+        // Javac knows that the `foo` field is constant 0, so it generates a null check and the `iconst_0` instruction.\n+        // The null check is a `obj.getClass()` call on older JDKs and `Objects.requireNonNull(obj)` on JDK 9 and above.\n+        int foo = maybeNull.foo;\n     }\n \n-    static String dumpMethod(byte[] bytes, final String methodName) throws Exception {\n-        Textifier textifier = new Textifier();\n-        StringWriter sw = new StringWriter();\n-        final ClassVisitor tcv = new TraceClassVisitor(null, textifier, new PrintWriter(sw, true));\n-        ClassVisitor cv =\n-                new ClassVisitor(Opcodes.ASM5) {\n-                    @Override\n-                    public MethodVisitor visitMethod(\n-                            int access,\n-                            String name,\n-                            String desc,\n-                            String signature,\n-                            String[] exceptions) {\n-                        if (!name.equals(methodName)) {\n-                            return super.visitMethod(access, name, desc, signature, exceptions);\n-                        }\n-                        return tcv.visitMethod(access, name, desc, signature, exceptions);\n-                    }\n-                };\n-        ClassReader cr = new ClassReader(bytes);\n-        cr.accept(cv, ClassReader.SKIP_DEBUG | ClassReader.SKIP_FRAMES);\n-        textifier.print(new PrintWriter(sw, true));\n-        return Joiner.on('\\n')\n-                .join(Splitter.on('\\n').omitEmptyStrings().trimResults().split(sw.toString()));\n+    private static class MaybeNull {\n+        final int foo = 0;\n     }\n }\n"
    },
    {
        "commit_hash": "26b6f2959364ca2c0b1eeb87f8b72ae5b3e27c48",
        "previous_commit_hash": "afbb2d6b8e23d3612d52284b95f11fe3abb20006",
        "diff_stats": {
            "additions": 11,
            "deletions": 0
        },
        "diff_content": "@@ -178,6 +178,12 @@ expressions and they are backported in the same way.\n If you would like the suppressed exceptions to be logged instead of\n swallowed, please create a feature request and we'll make it configurable.\n \n+**Objects.requireNonNull calls** are replaced with calls to `Object.getClass`\n+if the target bytecode version is below Java 7. The synthetic null checks\n+generated by JDK 9 use `Objects.requireNonNull`, whereas earlier JDK versions\n+used `Object.getClass`.\n+\n+\n *Optionally also:*\n \n **Default methods** are backported by copying the default methods to a\n@@ -218,6 +224,11 @@ optimizations to that mechanism may break Retrolambda.\n Version History\n ---------------\n \n+### Upcoming\n+\n+- Backports calls to `Objects.requireNonNull`, improving JDK 9 support\n+  ([Issue #75](https://github.com/orfjackal/retrolambda/issues/75))\n+\n ### Retrolambda 2.1.0 (2015-12-19)\n \n - Added the `-Dretrolambda.classpathFile` parameter to avoid\n"
    },
    {
        "commit_hash": "6daafa575b30cc9e00b3469b7c42e1da94fbd7a8",
        "previous_commit_hash": "26b6f2959364ca2c0b1eeb87f8b72ae5b3e27c48",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -51,7 +51,7 @@ To run Retrolambda using Maven, add the following to your pom.xml:\n <plugin>\n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>retrolambda-maven-plugin</artifactId>\n-    <version>2.1.0</version>\n+    <version>2.2.0</version>\n     <executions>\n         <execution>\n             <goals>\n@@ -224,7 +224,7 @@ optimizations to that mechanism may break Retrolambda.\n Version History\n ---------------\n \n-### Upcoming\n+### Retrolambda 2.2.0 (2016-04-29)\n \n - Backports calls to `Objects.requireNonNull`, improving JDK 9 support\n   ([Issue #75](https://github.com/orfjackal/retrolambda/issues/75))\n"
    },
    {
        "commit_hash": "6daafa575b30cc9e00b3469b7c42e1da94fbd7a8",
        "previous_commit_hash": "26b6f2959364ca2c0b1eeb87f8b72ae5b3e27c48",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.1.1-SNAPSHOT</version>\n+        <version>2.2.0</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "6daafa575b30cc9e00b3469b7c42e1da94fbd7a8",
        "previous_commit_hash": "26b6f2959364ca2c0b1eeb87f8b72ae5b3e27c48",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -6,13 +6,13 @@\n     <parent>\n         <groupId>org.sonatype.oss</groupId>\n         <artifactId>oss-parent</artifactId>\n-        <version>7</version>\n+        <version>9</version>\n         <relativePath/>\n     </parent>\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>2.1.1-SNAPSHOT</version>\n+    <version>2.2.0</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "6daafa575b30cc9e00b3469b7c42e1da94fbd7a8",
        "previous_commit_hash": "26b6f2959364ca2c0b1eeb87f8b72ae5b3e27c48",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.1.1-SNAPSHOT</version>\n+        <version>2.2.0</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "6daafa575b30cc9e00b3469b7c42e1da94fbd7a8",
        "previous_commit_hash": "26b6f2959364ca2c0b1eeb87f8b72ae5b3e27c48",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.1.1-SNAPSHOT</version>\n+        <version>2.2.0</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "6daafa575b30cc9e00b3469b7c42e1da94fbd7a8",
        "previous_commit_hash": "26b6f2959364ca2c0b1eeb87f8b72ae5b3e27c48",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.1.1-SNAPSHOT</version>\n+        <version>2.2.0</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "0ac36bbc5904a8d3d6f659cc8a11387b69c6bae8",
        "previous_commit_hash": "6daafa575b30cc9e00b3469b7c42e1da94fbd7a8",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.2.0</version>\n+        <version>2.2.1-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "0ac36bbc5904a8d3d6f659cc8a11387b69c6bae8",
        "previous_commit_hash": "6daafa575b30cc9e00b3469b7c42e1da94fbd7a8",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>2.2.0</version>\n+    <version>2.2.1-SNAPSHOT</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "0ac36bbc5904a8d3d6f659cc8a11387b69c6bae8",
        "previous_commit_hash": "6daafa575b30cc9e00b3469b7c42e1da94fbd7a8",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.2.0</version>\n+        <version>2.2.1-SNAPSHOT</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "0ac36bbc5904a8d3d6f659cc8a11387b69c6bae8",
        "previous_commit_hash": "6daafa575b30cc9e00b3469b7c42e1da94fbd7a8",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.2.0</version>\n+        <version>2.2.1-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "0ac36bbc5904a8d3d6f659cc8a11387b69c6bae8",
        "previous_commit_hash": "6daafa575b30cc9e00b3469b7c42e1da94fbd7a8",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.2.0</version>\n+        <version>2.2.1-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "206bd9bcdd8b51d67516293fc482f5c29c415a28",
        "previous_commit_hash": "0ac36bbc5904a8d3d6f659cc8a11387b69c6bae8",
        "diff_stats": {
            "additions": 1,
            "deletions": 19
        },
        "diff_content": "@@ -11,32 +11,14 @@\n         <processorPath useClasspath=\"true\" />\n       </profile>\n       <profile default=\"false\" name=\"Maven default annotation processors profile\" enabled=\"true\">\n-        <sourceOutputDir name=\"target/generated-sources/annotations\" />\n-        <sourceTestOutputDir name=\"target/generated-test-sources/test-annotations\" />\n-        <outputRelativeToContentRoot value=\"true\" />\n-        <processorPath useClasspath=\"true\" />\n-        <module name=\"retrolambda-runtime (1)\" />\n-      </profile>\n-      <profile default=\"false\" name=\"Annotation profile for end-to-end-tests\" enabled=\"true\">\n         <sourceOutputDir name=\"target/generated-sources/annotations\" />\n         <sourceTestOutputDir name=\"target/generated-test-sources/test-annotations\" />\n         <outputRelativeToContentRoot value=\"true\" />\n         <processorPath useClasspath=\"true\" />\n         <module name=\"end-to-end-tests\" />\n-      </profile>\n-      <profile default=\"false\" name=\"Annotation profile for retrolambda\" enabled=\"true\">\n-        <sourceOutputDir name=\"target/generated-sources/annotations\" />\n-        <sourceTestOutputDir name=\"target/generated-test-sources/test-annotations\" />\n-        <outputRelativeToContentRoot value=\"true\" />\n-        <processorPath useClasspath=\"true\" />\n         <module name=\"retrolambda\" />\n-      </profile>\n-      <profile default=\"false\" name=\"Annotation profile for retrolambda-maven-plugin\" enabled=\"true\">\n-        <sourceOutputDir name=\"target/generated-sources/annotations\" />\n-        <sourceTestOutputDir name=\"target/generated-test-sources/test-annotations\" />\n-        <outputRelativeToContentRoot value=\"true\" />\n-        <processorPath useClasspath=\"true\" />\n         <module name=\"retrolambda-maven-plugin\" />\n+        <module name=\"retrolambda-runtime (1)\" />\n       </profile>\n     </annotationProcessing>\n     <bytecodeTargetLevel target=\"1.8\">\n"
    },
    {
        "commit_hash": "206bd9bcdd8b51d67516293fc482f5c29c415a28",
        "previous_commit_hash": "0ac36bbc5904a8d3d6f659cc8a11387b69c6bae8",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -38,7 +38,7 @@\n     <option name=\"LAST_EDITED_MODULE_NAME\" />\n     <option name=\"LAST_EDITED_TAB_NAME\" />\n   </component>\n-  <component name=\"ProjectRootManager\" version=\"2\" languageLevel=\"JDK_1_8\" assert-keyword=\"true\" jdk-15=\"true\" project-jdk-name=\"1.8\" project-jdk-type=\"JavaSDK\">\n+  <component name=\"ProjectRootManager\" version=\"2\" languageLevel=\"JDK_1_8\" default=\"false\" assert-keyword=\"true\" jdk-15=\"true\" project-jdk-name=\"1.8\" project-jdk-type=\"JavaSDK\">\n     <output url=\"file://$PROJECT_DIR$/classes\" />\n   </component>\n   <component name=\"VssConfiguration\">\n"
    },
    {
        "commit_hash": "206bd9bcdd8b51d67516293fc482f5c29c415a28",
        "previous_commit_hash": "0ac36bbc5904a8d3d6f659cc8a11387b69c6bae8",
        "diff_stats": {
            "additions": 1,
            "deletions": 2
        },
        "diff_content": "@@ -9,5 +9,4 @@\n       <module fileurl=\"file://$PROJECT_DIR$/retrolambda-maven-plugin/retrolambda-maven-plugin.iml\" filepath=\"$PROJECT_DIR$/retrolambda-maven-plugin/retrolambda-maven-plugin.iml\" />\n     </modules>\n   </component>\n-</project>\n-\n+</project>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "206bd9bcdd8b51d67516293fc482f5c29c415a28",
        "previous_commit_hash": "0ac36bbc5904a8d3d6f659cc8a11387b69c6bae8",
        "diff_stats": {
            "additions": 8,
            "deletions": 8
        },
        "diff_content": "@@ -19,31 +19,31 @@\n     <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n     <orderEntry type=\"module\" module-name=\"retrolambda\" />\n     <orderEntry type=\"library\" name=\"Maven: org.ow2.asm:asm-debug-all:5.1\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: com.google.guava:guava:18.0\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-plugin-api:2.0\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"PROVIDED\" name=\"Maven: org.apache.maven.plugin-tools:maven-plugin-annotations:3.4\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-artifact:3.0\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.codehaus.plexus:plexus-utils:3.0.21\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.twdata.maven:mojo-executor:2.2.0\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-core:3.0\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-model:3.0\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-settings:3.0\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-settings-builder:3.0\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.codehaus.plexus:plexus-interpolation:1.14\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.codehaus.plexus:plexus-component-annotations:1.5.5\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.sonatype.plexus:plexus-sec-dispatcher:1.3\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-repository-metadata:3.0\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-model-builder:3.0\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"RUNTIME\" name=\"Maven: org.apache.maven:maven-aether-provider:3.0\" level=\"project\" />\n-    <orderEntry type=\"library\" name=\"Maven: org.sonatype.aether:aether-impl:1.7\" level=\"project\" />\n-    <orderEntry type=\"library\" name=\"Maven: org.sonatype.aether:aether-spi:1.7\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.sonatype.aether:aether-api:1.7\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.sonatype.aether:aether-util:1.7\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.sonatype.aether:aether-impl:1.7\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.sonatype.aether:aether-spi:1.7\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.sonatype.sisu:sisu-inject-plexus:1.4.2\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.codehaus.plexus:plexus-classworlds:2.2.3\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.sonatype.sisu:sisu-inject-bean:1.4.2\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.sonatype.sisu:sisu-guice:noaop:2.1.7\" level=\"project\" />\n-    <orderEntry type=\"library\" name=\"Maven: org.codehaus.plexus:plexus-interpolation:1.14\" level=\"project\" />\n-    <orderEntry type=\"library\" name=\"Maven: org.codehaus.plexus:plexus-classworlds:2.2.3\" level=\"project\" />\n-    <orderEntry type=\"library\" name=\"Maven: org.codehaus.plexus:plexus-component-annotations:1.5.5\" level=\"project\" />\n-    <orderEntry type=\"library\" name=\"Maven: org.sonatype.plexus:plexus-sec-dispatcher:1.3\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.sonatype.plexus:plexus-cipher:1.4\" level=\"project\" />\n-    <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-model:3.0\" level=\"project\" />\n-    <orderEntry type=\"library\" name=\"Maven: com.google.guava:guava:18.0\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.12\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-library:1.3\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-core:1.3\" level=\"project\" />\n"
    },
    {
        "commit_hash": "7ac6ff08be7f734ce5f9227562bf9a59b60840e8",
        "previous_commit_hash": "a8a5b9b2e551073c9604f2f1620fcb4c1c8e2683",
        "diff_stats": {
            "additions": 18,
            "deletions": 23
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013-2016 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2016 Esko Luontola and other Retrolambda contributors\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -12,7 +12,7 @@ import java.util.*;\n \n import static net.orfjackal.retrolambda.test.TestUtil.assertClassExists;\n import static org.hamcrest.MatcherAssert.assertThat;\n-import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.*;\n \n public class LambdaClassesTest {\n \n@@ -47,15 +47,9 @@ public class LambdaClassesTest {\n \n     @Test\n     public void capturing_lambda_classes_contain_no_unnecessary_methods() throws ClassNotFoundException {\n-        Set<String> expected = new HashSet<>(Arrays.asList(\"lambdaFactory$\", \"run\"));\n-\n         Class<?> lambdaClass = Class.forName(Capturing.class.getName() + \"$$Lambda$1\");\n \n-        Set<String> actual = new HashSet<>();\n-        for (Method method : lambdaClass.getDeclaredMethods()) {\n-            actual.add(method.getName());\n-        }\n-        assertThat(actual, is(expected));\n+        assertThat(getDeclaredMethodNames(lambdaClass), is(ImmutableSet.of(\"lambdaFactory$\", \"run\")));\n     }\n \n     @SuppressWarnings(\"UnusedDeclaration\")\n@@ -68,15 +62,9 @@ public class LambdaClassesTest {\n \n     @Test\n     public void non_capturing_lambda_classes_contain_no_unnecessary_methods() throws ClassNotFoundException {\n-        Set<String> expected = new HashSet<>(Arrays.asList(\"lambdaFactory$\", \"run\"));\n-\n         Class<?> lambdaClass = Class.forName(NonCapturing.class.getName() + \"$$Lambda$1\");\n \n-        Set<String> actual = new HashSet<>();\n-        for (Method method : lambdaClass.getDeclaredMethods()) {\n-            actual.add(method.getName());\n-        }\n-        assertThat(actual, is(expected));\n+        assertThat(getDeclaredMethodNames(lambdaClass), is(ImmutableSet.of(\"lambdaFactory$\", \"run\")));\n     }\n \n     @SuppressWarnings(\"UnusedDeclaration\")\n@@ -90,13 +78,7 @@ public class LambdaClassesTest {\n \n     @Test\n     public void lambda_bodies_contain_no_unnecessary_methods() throws ClassNotFoundException {\n-        Set<String> expected = ImmutableSet.of(\"lambda$main$0\", \"main\");\n-\n-        Set<String> actual = new HashSet<>();\n-        for (Method method : HasLambdaBody.class.getDeclaredMethods()) {\n-            actual.add(method.getName());\n-        }\n-        assertThat(actual, is(expected));\n+        assertThat(getDeclaredMethodNames(HasLambdaBody.class), is(ImmutableSet.of(\"lambda$main$0\", \"main\")));\n     }\n \n     @SuppressWarnings(\"UnusedDeclaration\")\n@@ -106,4 +88,17 @@ public class LambdaClassesTest {\n             };\n         }\n     }\n+\n+\n+    // helpers\n+\n+    private static Set<String> getDeclaredMethodNames(Class<?> clazz) {\n+        Method[] methods = clazz.getDeclaredMethods();\n+        Set<String> uniqueNames = new HashSet<>();\n+        for (Method method : methods) {\n+            uniqueNames.add(method.getName());\n+        }\n+        assertThat(\"unexpected overloaded methods\", methods, arrayWithSize(uniqueNames.size()));\n+        return uniqueNames;\n+    }\n }\n"
    },
    {
        "commit_hash": "e9217764ec4f38e66f3c16cfb4ba730db207e271",
        "previous_commit_hash": "7ac6ff08be7f734ce5f9227562bf9a59b60840e8",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -78,7 +78,7 @@ public class LambdaClassesTest {\n \n     @Test\n     public void lambda_bodies_contain_no_unnecessary_methods() throws ClassNotFoundException {\n-        assertThat(getDeclaredMethodNames(HasLambdaBody.class), is(ImmutableSet.of(\"lambda$main$0\", \"main\")));\n+        assertThat(getDeclaredMethodNames(HasLambdaBody.class), containsInAnyOrder(startsWith(\"lambda$main$\"), equalTo(\"main\")));\n     }\n \n     @SuppressWarnings(\"UnusedDeclaration\")\n"
    },
    {
        "commit_hash": "bc7d1e407b9e7d9426cbcdd32d0a6ec55bd94d5d",
        "previous_commit_hash": "e9217764ec4f38e66f3c16cfb4ba730db207e271",
        "diff_stats": {
            "additions": 11,
            "deletions": 8
        },
        "diff_content": "@@ -47,9 +47,8 @@ public class LambdaClassesTest {\n \n     @Test\n     public void capturing_lambda_classes_contain_no_unnecessary_methods() throws ClassNotFoundException {\n-        Class<?> lambdaClass = Class.forName(Capturing.class.getName() + \"$$Lambda$1\");\n-\n-        assertThat(getDeclaredMethodNames(lambdaClass), is(ImmutableSet.of(\"lambdaFactory$\", \"run\")));\n+        assertThat(getMethodsNames(findLambdaClass(Capturing.class)),\n+                is(ImmutableSet.of(\"lambdaFactory$\", \"run\")));\n     }\n \n     @SuppressWarnings(\"UnusedDeclaration\")\n@@ -62,9 +61,8 @@ public class LambdaClassesTest {\n \n     @Test\n     public void non_capturing_lambda_classes_contain_no_unnecessary_methods() throws ClassNotFoundException {\n-        Class<?> lambdaClass = Class.forName(NonCapturing.class.getName() + \"$$Lambda$1\");\n-\n-        assertThat(getDeclaredMethodNames(lambdaClass), is(ImmutableSet.of(\"lambdaFactory$\", \"run\")));\n+        assertThat(getMethodsNames(findLambdaClass(NonCapturing.class)),\n+                is(ImmutableSet.of(\"lambdaFactory$\", \"run\")));\n     }\n \n     @SuppressWarnings(\"UnusedDeclaration\")\n@@ -78,7 +76,8 @@ public class LambdaClassesTest {\n \n     @Test\n     public void lambda_bodies_contain_no_unnecessary_methods() throws ClassNotFoundException {\n-        assertThat(getDeclaredMethodNames(HasLambdaBody.class), containsInAnyOrder(startsWith(\"lambda$main$\"), equalTo(\"main\")));\n+        assertThat(getMethodsNames(HasLambdaBody.class),\n+                containsInAnyOrder(startsWith(\"lambda$main$\"), equalTo(\"main\")));\n     }\n \n     @SuppressWarnings(\"UnusedDeclaration\")\n@@ -92,7 +91,11 @@ public class LambdaClassesTest {\n \n     // helpers\n \n-    private static Set<String> getDeclaredMethodNames(Class<?> clazz) {\n+    private static Class<?> findLambdaClass(Class<?> clazz) throws ClassNotFoundException {\n+        return Class.forName(clazz.getName() + \"$$Lambda$1\");\n+    }\n+\n+    private static Set<String> getMethodsNames(Class<?> clazz) {\n         Method[] methods = clazz.getDeclaredMethods();\n         Set<String> uniqueNames = new HashSet<>();\n         for (Method method : methods) {\n"
    },
    {
        "commit_hash": "205e7e04b8de5d6d80525da4e6909a774254d906",
        "previous_commit_hash": "bc7d1e407b9e7d9426cbcdd32d0a6ec55bd94d5d",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2016 Esko Luontola and other Retrolambda contributors\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -39,7 +39,7 @@ public final class MethodRef {\n     }\n \n     public Handle toHandle() {\n-        return new Handle(tag, owner, name, desc);\n+        return new Handle(tag, owner, name, desc, tag == Opcodes.H_INVOKEINTERFACE);\n     }\n \n     @Override\n"
    },
    {
        "commit_hash": "205e7e04b8de5d6d80525da4e6909a774254d906",
        "previous_commit_hash": "bc7d1e407b9e7d9426cbcdd32d0a6ec55bd94d5d",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2016 Esko Luontola and other Retrolambda contributors\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -78,14 +78,14 @@ public class BackportLambdaInvocations extends ClassVisitor {\n             if (LambdaNaming.isBodyMethodName(implMethod.getName())) {\n                 if (implMethod.getTag() == H_INVOKESPECIAL) {\n                     // The private body method is now package so switch its invocation from special to virtual.\n-                    return new Handle(H_INVOKEVIRTUAL, implMethod.getOwner(), implMethod.getName(), implMethod.getDesc());\n+                    return new Handle(H_INVOKEVIRTUAL, implMethod.getOwner(), implMethod.getName(), implMethod.getDesc(), false);\n                 }\n                 return implMethod;\n             }\n         }\n         String name = \"access$lambda$\" + lambdaAccessToImplMethods.size();\n         String desc = getLambdaAccessMethodDesc(implMethod);\n-        Handle accessMethod = new Handle(H_INVOKESTATIC, className, name, desc);\n+        Handle accessMethod = new Handle(H_INVOKESTATIC, className, name, desc, false);\n         lambdaAccessToImplMethods.put(accessMethod, implMethod);\n         return accessMethod;\n     }\n"
    },
    {
        "commit_hash": "205e7e04b8de5d6d80525da4e6909a774254d906",
        "previous_commit_hash": "bc7d1e407b9e7d9426cbcdd32d0a6ec55bd94d5d",
        "diff_stats": {
            "additions": 2,
            "deletions": 3
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2016 Esko Luontola and other Retrolambda contributors\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -54,7 +54,6 @@ public class HandlesTest {\n     }\n \n     private Handle handle(int tag) {\n-        return new Handle(tag, null, null, null);\n+        return new Handle(tag, null, null, null, tag == Opcodes.H_INVOKEINTERFACE);\n     }\n-\n }\n"
    },
    {
        "commit_hash": "205e7e04b8de5d6d80525da4e6909a774254d906",
        "previous_commit_hash": "bc7d1e407b9e7d9426cbcdd32d0a6ec55bd94d5d",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2016 Esko Luontola and other Retrolambda contributors\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -30,7 +30,7 @@ public class TypesTest {\n \n     @Test\n     public void asmToJdkType_MethodHandle() throws Exception {\n-        Handle input = new Handle(Opcodes.H_INVOKESTATIC, \"java/lang/String\", \"valueOf\", \"(I)Ljava/lang/String;\");\n+        Handle input = new Handle(Opcodes.H_INVOKESTATIC, \"java/lang/String\", \"valueOf\", \"(I)Ljava/lang/String;\", false);\n         MethodHandle output = lookup.findStatic(String.class, \"valueOf\", MethodType.methodType(String.class, int.class));\n \n         assertThat(asmToJdkType(input, classLoader, lookup).toString(), is(output.toString()));\n"
    },
    {
        "commit_hash": "ab42d79b605e476299f41c660af71caba6622ec2",
        "previous_commit_hash": "205e7e04b8de5d6d80525da4e6909a774254d906",
        "diff_stats": {
            "additions": 3,
            "deletions": 11
        },
        "diff_content": "@@ -75,17 +75,9 @@ public class LambdaClassesTest {\n \n \n     @Test\n-    public void lambda_bodies_contain_no_unnecessary_methods() throws ClassNotFoundException {\n-        assertThat(getMethodsNames(HasLambdaBody.class),\n-                containsInAnyOrder(startsWith(\"lambda$main$\"), equalTo(\"main\")));\n-    }\n-\n-    @SuppressWarnings(\"UnusedDeclaration\")\n-    private class HasLambdaBody {\n-        private void main() {\n-            Runnable lambda = () -> {\n-            };\n-        }\n+    public void enclosing_classes_contain_no_unnecessary_methods_in_addition_to_the_lambda_body() throws ClassNotFoundException {\n+        assertThat(\"non-capturing lambda\", getMethodsNames(NonCapturing.class), contains(startsWith(\"lambda$new$\")));\n+        assertThat(\"capturing lambda\", getMethodsNames(Capturing.class), contains(startsWith(\"lambda$new$\")));\n     }\n \n \n"
    },
    {
        "commit_hash": "05baa1bae1ee79f4292233a74a845146971cb987",
        "previous_commit_hash": "ab42d79b605e476299f41c660af71caba6622ec2",
        "diff_stats": {
            "additions": 19,
            "deletions": 0
        },
        "diff_content": "@@ -224,10 +224,29 @@ optimizations to that mechanism may break Retrolambda.\n Version History\n ---------------\n \n+### Upcoming\n+\n+- Optimize generated code to reduce method count\n+  ([Issue #81](https://github.com/orfjackal/retrolambda/issues/81))\n+    - Alter when accessor methods are generated\n+      ([Pull request #84](https://github.com/orfjackal/retrolambda/pull/84))\n+    - Remove NEW, DUP instructions when changing NEWINVOKESPECIAL to INVOKESTATIC\n+      ([Pull request #85](https://github.com/orfjackal/retrolambda/pull/85))\n+    - Skip access method when lambda body method can be promoted\n+      ([Pull request #86](https://github.com/orfjackal/retrolambda/pull/86))\n+- Fix method reference to protected method in base class in other package\n+  failing with IllegalAccessError\n+  ([Issue #89](https://github.com/orfjackal/retrolambda/issues/89))\n+\n ### Retrolambda 2.2.0 (2016-04-29)\n \n - Backports calls to `Objects.requireNonNull`, improving JDK 9 support\n   ([Issue #75](https://github.com/orfjackal/retrolambda/issues/75))\n+- Optimize generated code to reduce method count\n+  ([Issue #81](https://github.com/orfjackal/retrolambda/issues/81))\n+    - Detect and omit the JVM's lambda factory method\n+      ([Pull request #82](https://github.com/orfjackal/retrolambda/pull/82))\n+\n \n ### Retrolambda 2.1.0 (2015-12-19)\n \n"
    },
    {
        "commit_hash": "806ac902ab3eae61ce8293f6bb9695d674a0b3c8",
        "previous_commit_hash": "05baa1bae1ee79f4292233a74a845146971cb987",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -51,7 +51,7 @@ To run Retrolambda using Maven, add the following to your pom.xml:\n <plugin>\n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>retrolambda-maven-plugin</artifactId>\n-    <version>2.2.0</version>\n+    <version>2.3.0</version>\n     <executions>\n         <execution>\n             <goals>\n@@ -224,7 +224,7 @@ optimizations to that mechanism may break Retrolambda.\n Version History\n ---------------\n \n-### Upcoming\n+### Retrolambda 2.3.0 (2016-04-30)\n \n - Optimize generated code to reduce method count\n   ([Issue #81](https://github.com/orfjackal/retrolambda/issues/81))\n"
    },
    {
        "commit_hash": "806ac902ab3eae61ce8293f6bb9695d674a0b3c8",
        "previous_commit_hash": "05baa1bae1ee79f4292233a74a845146971cb987",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.2.1-SNAPSHOT</version>\n+        <version>2.3.0</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "806ac902ab3eae61ce8293f6bb9695d674a0b3c8",
        "previous_commit_hash": "05baa1bae1ee79f4292233a74a845146971cb987",
        "diff_stats": {
            "additions": 77,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,77 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.test;\n+\n+import org.hamcrest.*;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.net.URL;\n+import java.util.*;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.*;\n+import static org.junit.Assert.assertNotNull;\n+\n+public class ClasspathTest {\n+\n+    @Test\n+    public void maven_plugin_sets_classpath_for_main_dependencies() {\n+        assertThat(InMainSources.useLambdaOfImportedType(Arrays.asList(\"a\", \"b\")), is(Arrays.asList(\"A\", \"B\")));\n+    }\n+\n+    @Test\n+    public void maven_plugin_sets_classpath_for_test_dependencies() {\n+        SelfDescribing lambda = (desc) -> desc.appendText(\"foo\");\n+\n+        StringDescription result = new StringDescription();\n+        lambda.describeTo(result);\n+        assertThat(result.toString(), is(\"foo\"));\n+    }\n+\n+    /**\n+     * This is to reproduce a bug where the Maven plugin does not include\n+     * the main classes on the test classpath, causing Retrolambda to fail\n+     * in loading test classes such as this one (i.e. test classes which\n+     * depend on main classes at class loading time).\n+     */\n+    @Test\n+    public void maven_plugin_includes_the_main_classes_in_the_test_classpath() {\n+        class RequiresMainClassesInTestClasspath extends InMainSources {\n+            public Runnable foo() {\n+                // Any lambda, to make Retrolambda try to process this class\n+                return () -> {\n+                };\n+            }\n+        }\n+        new RequiresMainClassesInTestClasspath().foo();\n+    }\n+\n+    /**\n+     * This is to reproduce a bug where trying to backport a development\n+     * version of JavaFX classes fails because the same classes also exist in\n+     * the JRE's extension directory and Retrolambda accidentally loads the\n+     * old built-in class instead of the new class that is being transformed.\n+     */\n+    @Test\n+    public void prefers_classes_in_explicit_classpath_over_classes_in_the_JRE() {\n+        assertNotNull(getClass().getResource(\"/com/sun/javafx/application/LauncherImpl$$Lambda$1.class\"));\n+    }\n+\n+    /**\n+     * Classes in the {@code java.*} packages can be loaded only by the bootstrap\n+     * class loader, so we must not try to load them with our custom class loader.\n+     * This situation arises when backporting Android applications, because android.jar\n+     * contains {@code java.*} classes.\n+     */\n+    @Test\n+    public void ignores_classes_in_explicit_classpath_that_are_under_the_java_package() throws IOException {\n+        // We have a JAR on the classpath that contains dummy version of java.lang.Object,\n+        // the same way as android.jar, which causes Retrolambda to try loading that class\n+        // because the classes to be backported extend it implicitly.\n+        List<URL> resources = Collections.list(getClass().getClassLoader().getResources(\"java/lang/Object.class\"));\n+        assertThat(resources, (Matcher) hasItem(hasToString(containsString(\"java-lang-dummies.jar\"))));\n+    }\n+}\n"
    },
    {
        "commit_hash": "806ac902ab3eae61ce8293f6bb9695d674a0b3c8",
        "previous_commit_hash": "05baa1bae1ee79f4292233a74a845146971cb987",
        "diff_stats": {
            "additions": 609,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,609 @@\n+// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.test;\n+\n+import net.orfjackal.retrolambda.test.anotherpackage.UsesLambdasInAnotherPackage;\n+import org.apache.commons.lang.SystemUtils;\n+import org.hamcrest.*;\n+import org.junit.*;\n+import org.junit.rules.ExpectedException;\n+\n+import java.lang.annotation.*;\n+import java.util.*;\n+import java.util.concurrent.Callable;\n+\n+import static net.orfjackal.retrolambda.test.TestUtil.companionOf;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.*;\n+import static org.junit.Assume.assumeThat;\n+import static org.mockito.Mockito.mock;\n+\n+@SuppressWarnings({\"Convert2Lambda\", \"Anonymous2MethodRef\", \"RedundantCast\", \"UnusedDeclaration\"})\n+public class DefaultMethodsTest {\n+\n+    @Rule\n+    public final ExpectedException thrown = ExpectedException.none();\n+\n+\n+    // Inheriting & Overriding\n+\n+    @Test\n+    public void default_method_inherited_from_interface() {\n+        DefaultMethods obj = new DefaultMethods() {\n+        };\n+        assertThat(obj.foo(), is(\"original\"));\n+    }\n+\n+    @Test\n+    public void default_method_overridden_in_current_class() {\n+        assertThat(new DefaultMethodOverridingClass().foo(), is(\"overridden\"));\n+    }\n+\n+    @Test\n+    public void default_method_overridden_in_parent_class() {\n+        class C extends DefaultMethodOverridingClass {\n+        }\n+        assertThat(new C().foo(), is(\"overridden\"));\n+    }\n+\n+    @Test\n+    public void default_method_overridden_in_parent_class_and_implements_interface_explicitly() {\n+        class C extends DefaultMethodOverridingClass implements DefaultMethods {\n+        }\n+        assertThat(new C().foo(), is(\"overridden\"));\n+    }\n+\n+    private interface DefaultMethods {\n+        default String foo() {\n+            return \"original\";\n+        }\n+    }\n+\n+    private class DefaultMethodOverridingClass implements DefaultMethods {\n+        @Override\n+        public String foo() {\n+            return \"overridden\";\n+        }\n+    }\n+\n+\n+    @Test\n+    public void default_method_overridden_in_child_interface() {\n+        OverrideChild child = new OverrideChild() {\n+        };\n+        assertThat(child.foo(), is(\"overridden\"));\n+    }\n+\n+    private interface OverrideParent {\n+        default String foo() {\n+            return \"original\";\n+        }\n+    }\n+\n+    private interface OverrideChild extends OverrideParent {\n+        @Override\n+        default String foo() {\n+            return \"overridden\";\n+        }\n+    }\n+\n+\n+    /**\n+     * Based on the example in <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html#jls-9.4.1\">JLS \u00a79.4.1</a>\n+     * (Interfaces - Inheritance and Overriding)\n+     */\n+    @Test\n+    public void inheriting_same_default_methods_through_many_parent_interfaces() {\n+        assertThat(new InheritsOriginal() {\n+        }.foo(), is(\"original\"));\n+\n+        assertThat(new InheritsOverridden() {\n+        }.foo(), is(\"overridden\"));\n+\n+        assertThat(new InheritsOverriddenAndOriginal() {\n+        }.foo(), is(\"overridden\"));\n+\n+        assertThat(new InheritsOriginalAndOverridden() {\n+        }.foo(), is(\"overridden\"));\n+    }\n+\n+    private interface SuperOriginal {\n+        default String foo() {\n+            return \"original\";\n+        }\n+    }\n+\n+    private interface SuperOverridden extends SuperOriginal {\n+        @Override\n+        default String foo() {\n+            return \"overridden\";\n+        }\n+    }\n+\n+    private interface InheritsOriginal extends SuperOriginal {\n+    }\n+\n+    private interface InheritsOverridden extends SuperOverridden {\n+    }\n+\n+    private interface InheritsOverriddenAndOriginal extends SuperOverridden, InheritsOriginal {\n+    }\n+\n+    private interface InheritsOriginalAndOverridden extends InheritsOriginal, SuperOverridden {\n+    }\n+\n+\n+    @Test\n+    public void implements_original_and_overridden_default_method() {\n+        assertThat(new ImplementsOriginal().foo(), is(\"original\"));\n+        assertThat(new ImplementsOriginalAndOverriddenDefault().foo(), is(\"overridden\"));\n+        assertThat(new ImplementsOverriddenAndOriginalDefault().foo(), is(\"overridden\"));\n+        assertThat(new ExtendsImplementsOriginalAndImplementsOverriddenDefault().foo(), is(\"overridden\"));\n+    }\n+\n+    private interface OriginalDefault {\n+        default String foo() {\n+            return \"original\";\n+        }\n+    }\n+\n+    private interface OverriddenDefault extends OriginalDefault {\n+        @Override\n+        default String foo() {\n+            return \"overridden\";\n+        }\n+    }\n+\n+    private class ImplementsOriginal implements OriginalDefault {\n+    }\n+\n+    private class ImplementsOriginalAndOverriddenDefault implements OriginalDefault, OverriddenDefault {\n+    }\n+\n+    private class ImplementsOverriddenAndOriginalDefault implements OverriddenDefault, OriginalDefault {\n+    }\n+\n+    private class ExtendsImplementsOriginalAndImplementsOverriddenDefault extends ImplementsOriginal implements OverriddenDefault {\n+    }\n+\n+\n+    // Bridge Methods\n+\n+    @Test\n+    public void default_method_type_refined_in_child_interface() {\n+        RefineChild child = new RefineChild() {\n+            @Override\n+            public String foo() {\n+                return \"refined\";\n+            }\n+        };\n+        assertThat(\"direct call\", child.foo(), is(\"refined\"));\n+        assertThat(\"bridged call\", ((RefineParent) child).foo(), is((Object) \"refined\"));\n+    }\n+\n+    @Test\n+    public void default_method_type_refined_in_implementing_class() {\n+        class C implements RefineParent {\n+            @Override\n+            public String foo() {\n+                return \"refined\";\n+            }\n+        }\n+        C obj = new C();\n+        assertThat(\"direct call\", obj.foo(), is(\"refined\"));\n+        assertThat(\"bridged call\", ((RefineParent) obj).foo(), is((Object) \"refined\"));\n+    }\n+\n+    private interface RefineParent {\n+        default Object foo() {\n+            return \"original\";\n+        }\n+    }\n+\n+    private interface RefineChild extends RefineParent {\n+        @Override\n+        String foo();\n+    }\n+\n+\n+    @Test\n+    public void default_method_argument_type_refined_in_child_interface() {\n+        RefineArgChild child = new RefineArgChild() {\n+        };\n+        assertThat(\"direct call\", child.foo(\"42\"), is(\"refined 42\"));\n+        assertThat(\"bridged call\", ((RefineArgParent<String>) child).foo(\"42\"), is((Object) \"refined 42\"));\n+    }\n+\n+    @Test\n+    public void default_method_argument_type_refined_in_implementing_class() {\n+        class C implements RefineArgParent<String> {\n+            @Override\n+            public String foo(String arg) {\n+                return \"refined \" + arg;\n+            }\n+        }\n+        C obj = new C();\n+        assertThat(\"direct call\", obj.foo(\"42\"), is(\"refined 42\"));\n+        assertThat(\"bridged call\", ((RefineArgParent<String>) obj).foo(\"42\"), is((Object) \"refined 42\"));\n+    }\n+\n+    private interface RefineArgParent<T> {\n+        default String foo(T arg) {\n+            return \"original \" + arg;\n+        }\n+    }\n+\n+    private interface RefineArgChild extends RefineArgParent<String> {\n+        @Override\n+        default String foo(String arg) {\n+            return \"refined \" + arg;\n+        }\n+    }\n+\n+\n+    @Test\n+    public void default_method_type_refined_and_overridden_in_child_interface() {\n+        OverrideRefineChild child = new OverrideRefineChild() {\n+        };\n+        assertThat(\"direct call\", child.foo(), is(\"overridden and refined\"));\n+        assertThat(\"bridged call\", ((OverrideRefineParent) child).foo(), is((Object) \"overridden and refined\"));\n+    }\n+\n+    private interface OverrideRefineParent {\n+        default Object foo() {\n+            return \"original\";\n+        }\n+    }\n+\n+    private interface OverrideRefineChild extends OverrideRefineParent {\n+        @Override\n+        default String foo() {\n+            return \"overridden and refined\";\n+        }\n+    }\n+\n+\n+    // Primitive Types & Void\n+\n+    @Test\n+    public void default_methods_of_primitive_type() {\n+        Primitives p = new Primitives() {\n+        };\n+        assertThat(\"boolean\", p.getBoolean(), is(true));\n+        assertThat(\"byte\", p.getByte(), is((byte) 2));\n+        assertThat(\"short\", p.getShort(), is((short) 3));\n+        assertThat(\"int\", p.getInt(), is(4));\n+        assertThat(\"long\", p.getLong(), is(5L));\n+        assertThat(\"float\", p.getFloat(), is(6.0f));\n+        assertThat(\"double\", p.getDouble(), is(7.0));\n+        assertThat(\"char\", p.getChar(), is('a'));\n+    }\n+\n+    private interface Primitives {\n+        default boolean getBoolean() {\n+            return true;\n+        }\n+\n+        default byte getByte() {\n+            return 2;\n+        }\n+\n+        default short getShort() {\n+            return 3;\n+        }\n+\n+        default int getInt() {\n+            return 4;\n+        }\n+\n+        default long getLong() {\n+            return 5L;\n+        }\n+\n+        default float getFloat() {\n+            return 6.0f;\n+        }\n+\n+        default double getDouble() {\n+            return 7.0;\n+        }\n+\n+        default char getChar() {\n+            return 'a';\n+        }\n+    }\n+\n+\n+    @Test\n+    public void default_methods_of_void_type() {\n+        modifiedByVoidMethod = 1;\n+        Voids v = new Voids() {\n+        };\n+        v.run();\n+        assertThat(modifiedByVoidMethod, is(2));\n+    }\n+\n+    private static int modifiedByVoidMethod;\n+\n+    private interface Voids {\n+        default void run() {\n+            modifiedByVoidMethod++;\n+        }\n+    }\n+\n+\n+    @Test\n+    public void default_methods_with_primitive_arguments() {\n+        PrimitiveArgs p = new PrimitiveArgs() {\n+        };\n+        assertThat(p.sum(true, (byte) 2, (short) 3, 4, 5, 6, 7, (char) 8), is(36));\n+    }\n+\n+    private interface PrimitiveArgs {\n+        default int sum(boolean bool, byte b, short s, int i, long l, float f, double d, char c) {\n+            return (int) ((bool ? 1 : 0) + b + s + i + l + f + d + c);\n+        }\n+    }\n+\n+\n+    // Calling Super\n+\n+    @Test\n+    public void default_methods_calling_super() {\n+        SuperCallChild child = new SuperCallChild() {\n+        };\n+        assertThat(child.callSuper(), is(11));\n+    }\n+\n+    @Test\n+    public void default_methods_called_with_super() {\n+        class C implements SuperCallChild {\n+            @Override\n+            public int callSuper() {\n+                return 100 + SuperCallChild.super.callSuper();\n+            }\n+\n+            public int siblingCallingSuper() {\n+                return 1000 + SuperCallChild.super.callSuper();\n+            }\n+        }\n+        assertThat(new C().callSuper(), is(111));\n+        assertThat(new C().siblingCallingSuper(), is(1011));\n+    }\n+\n+    private interface SuperCallParent {\n+        default int callSuper() {\n+            return 1;\n+        }\n+    }\n+\n+    private interface SuperCallChild extends SuperCallParent {\n+        @Override\n+        default int callSuper() {\n+            return 10 + SuperCallParent.super.callSuper();\n+        }\n+    }\n+\n+\n+    @Test\n+    public void inheriting_unrelated_default_methods() {\n+        class C implements Conflict1, Conflict2 {\n+            @Override\n+            public String conflict() {\n+                return Conflict1.super.conflict() + Conflict2.super.conflict();\n+            }\n+        }\n+        assertThat(new C().conflict(), is(\"ab\"));\n+    }\n+\n+    private interface Conflict1 {\n+        default String conflict() {\n+            return \"a\";\n+        }\n+    }\n+\n+    private interface Conflict2 {\n+        default String conflict() {\n+            return \"b\";\n+        }\n+    }\n+\n+\n+    // Misc\n+\n+    @Test\n+    public void default_methods_calling_other_interface_methods() {\n+        CallOtherMethods obj = new CallOtherMethods() {\n+            @Override\n+            public int foo() {\n+                return 2;\n+            }\n+        };\n+        assertThat(obj.callsFoo(), is(12));\n+    }\n+\n+    private interface CallOtherMethods {\n+        int foo();\n+\n+        default int callsFoo() {\n+            return foo() + 10;\n+        }\n+    }\n+\n+    /**\n+     * Backporting default methods should not interact badly with backporting lambdas.\n+     */\n+    @Test\n+    public void lambdas_with_default_methods() {\n+        CallOtherMethods lambda = () -> 2;\n+        assertThat(lambda.foo(), is(2));\n+        assertThat(lambda.callsFoo(), is(12));\n+    }\n+\n+    @Test\n+    public void default_methods_with_lambdas() throws Exception {\n+        UsesLambdas obj = new UsesLambdas() {\n+        };\n+        assertThat(obj.stateless().call(), is(\"foo\"));\n+    }\n+\n+    @Test\n+    public void default_methods_with_lambdas_that_capture_this() throws Exception {\n+        UsesLambdas obj = new UsesLambdas() {\n+        };\n+        assertThat(obj.captureThis().call(), is(\"foo\"));\n+    }\n+\n+    private interface UsesLambdas {\n+        default Callable<String> stateless() {\n+            return () -> \"foo\";\n+        }\n+\n+        default Callable<String> captureThis() {\n+            return () -> stateless().call();\n+        }\n+    }\n+\n+    /**\n+     * Lambdas which capture this in default methods will generate the lambda implementation\n+     * method as a private <em>instance</em> method. We must avoid copying those methods to\n+     * the interface implementers as if they were default methods.\n+     */\n+    @Test\n+    public void default_methods_with_lambdas_in_another_package() throws Exception {\n+        assumeThat(SystemUtils.JAVA_VERSION_FLOAT, is(lessThan(1.8f)));\n+\n+        UsesLambdasInAnotherPackage obj = new UsesLambdasInAnotherPackage() {\n+        };\n+        assertThat(obj.stateless().call(), is(\"foo\"));\n+        assertThat(obj.captureThis().call(), is(\"foo\"));\n+        assertThat(\"should contain only delegates to the two default methods\",\n+                obj.getClass().getDeclaredMethods(), arrayWithSize(2));\n+    }\n+\n+    /**\n+     * Though we use {@link InMainSources}, because the Retrolambda Maven plugin\n+     * processes the main sources separately from the test sources, the effect is\n+     * the same as if they were in another module.\n+     */\n+    @Test\n+    public void calling_default_methods_from_another_module_through_interface() {\n+        InMainSources.Interface implementer = new InMainSources.Implementer();\n+        assertThat(implementer.defaultMethod(), is(\"default\"));\n+\n+        InMainSources.Interface overrider = new InMainSources.Overrider();\n+        assertThat(overrider.defaultMethod(), is(\"overridden\"));\n+    }\n+\n+    /**\n+     * Fixes issue of the generated delegate methods being marked as synthetic,\n+     * in which case the Java compiler causes \"error: cannot find symbol\"\n+     * for direct calls to those methods.\n+     */\n+    @Test\n+    public void calling_default_methods_from_another_module_through_class() {\n+        InMainSources.Implementer implementer = new InMainSources.Implementer();\n+        assertThat(implementer.defaultMethod(), is(\"default\"));\n+\n+        InMainSources.Overrider overrider = new InMainSources.Overrider();\n+        assertThat(overrider.defaultMethod(), is(\"overridden\"));\n+    }\n+\n+\n+    /**\n+     * We're unable to backport default methods if we cannot modify the interface,\n+     * e.g. if it's part of the standard library or a third-party library.\n+     */\n+    @Test\n+    public void default_methods_of_library_interfaces_are_ignored_silently() throws Exception {\n+        @SuppressWarnings(\"unchecked\") Iterator<String> dummy = mock(Iterator.class);\n+\n+        // the Iterable interface has default methods in Java 8, but that\n+        // should not prevent us from using it in previous Java versions\n+        Iterable<String> it = new Iterable<String>() {\n+            @Override\n+            public Iterator<String> iterator() {\n+                return dummy;\n+            }\n+        };\n+\n+        assertThat(\"interface should work as usual\", it.iterator(), is(dummy));\n+        assertThat(\"should not copy default methods from library interfaces\",\n+                it.getClass().getDeclaredMethods(), arrayWithSize(1));\n+    }\n+\n+    @Test\n+    public void trying_to_use_default_methods_of_library_interfaces_causes_NoSuchMethodError() {\n+        assumeThat(SystemUtils.JAVA_VERSION_FLOAT, is(lessThan(1.8f)));\n+\n+        class C implements Iterable<String> {\n+            @Override\n+            public Iterator<String> iterator() {\n+                return Collections.emptyIterator();\n+            }\n+        }\n+\n+        thrown.expect(NoSuchMethodError.class);\n+        thrown.expectMessage(\"spliterator\");\n+        // Called directly on the class (invokevirtual) instead of the interface (invokeinterface),\n+        // to make sure that no method was inserted to the class (in which case this call would not fail)\n+        new C().spliterator();\n+    }\n+\n+    /**\n+     * A naive method for removing method bodies would easily also remove their annotations,\n+     * because in ASM method annotations are expressed as calls on the MethodVisitor.\n+     */\n+    @Test\n+    @SuppressWarnings(\"unchecked\")\n+    public void keeps_annotations_on_interface_methods() throws Exception {\n+        assertThat(\"interface\", AnnotatedInterface.class.getAnnotations(),\n+                arrayContaining(someAnnotation(1)));\n+\n+        assertThat(\"abstract method\", AnnotatedInterface.class.getMethod(\"annotatedAbstractMethod\").getAnnotations(),\n+                arrayContaining(someAnnotation(2)));\n+\n+        assertThat(\"default method\", AnnotatedInterface.class.getMethod(\"annotatedDefaultMethod\").getAnnotations(),\n+                arrayContaining(someAnnotation(3)));\n+\n+        assumeThat(SystemUtils.JAVA_VERSION_FLOAT, is(lessThan(1.8f)));\n+        assertThat(\"static method\", companionOf(AnnotatedInterface.class).getMethod(\"annotatedStaticMethod\").getAnnotations(),\n+                arrayContaining(someAnnotation(4)));\n+    }\n+\n+    @SomeAnnotation(1)\n+    private interface AnnotatedInterface {\n+\n+        @SomeAnnotation(2)\n+        void annotatedAbstractMethod();\n+\n+        @SomeAnnotation(3)\n+        default void annotatedDefaultMethod() {\n+        }\n+\n+        @SomeAnnotation(4)\n+        static void annotatedStaticMethod() {\n+        }\n+    }\n+\n+    @Retention(value = RetentionPolicy.RUNTIME)\n+    private @interface SomeAnnotation {\n+        int value();\n+    }\n+\n+    private static Matcher<Annotation> someAnnotation(int value) {\n+        return new TypeSafeMatcher<Annotation>() {\n+            @Override\n+            protected boolean matchesSafely(Annotation item) {\n+                return item instanceof SomeAnnotation && ((SomeAnnotation) item).value() == value;\n+            }\n+\n+            @Override\n+            public void describeTo(Description description) {\n+                description.appendText(\"@SomeAnnotation(\" + value + \")\");\n+            }\n+        };\n+    }\n+}\n"
    },
    {
        "commit_hash": "806ac902ab3eae61ce8293f6bb9695d674a0b3c8",
        "previous_commit_hash": "05baa1bae1ee79f4292233a74a845146971cb987",
        "diff_stats": {
            "additions": 41,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,41 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.test;\n+\n+import org.junit.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+\n+public class InterfaceBridgeMethodsTest {\n+\n+    /**\n+     * JDK 8 adds a bridge method to an interface when it overrides a method\n+     * from the parent interface and refines its return type. This uses Java 8's\n+     * default methods feature, which won't work on Java 7 and below, so we have\n+     * to remove it for it - this makes the bytecode same as what JDK 7 produces.\n+     */\n+    @Test\n+    @SuppressWarnings(\"Convert2Lambda\")\n+    public void will_remove_bridge_methods_from_interfaces() {\n+        BridgeChild child = new BridgeChild() {\n+            @Override\n+            public String foo() {\n+                return \"foo\";\n+            }\n+        };\n+        assertThat(\"direct call\", child.foo(), is(\"foo\"));\n+        assertThat(\"bridged call\", ((BridgeParent) child).foo(), is((Object) \"foo\"));\n+    }\n+\n+    public interface BridgeParent {\n+        Object foo();\n+    }\n+\n+    public interface BridgeChild extends BridgeParent {\n+        @Override\n+        String foo(); // refined return type\n+    }\n+}\n"
    },
    {
        "commit_hash": "806ac902ab3eae61ce8293f6bb9695d674a0b3c8",
        "previous_commit_hash": "05baa1bae1ee79f4292233a74a845146971cb987",
        "diff_stats": {
            "additions": 119,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,119 @@\n+// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.test;\n+\n+import org.apache.commons.lang.SystemUtils;\n+import org.junit.*;\n+import org.junit.rules.ExpectedException;\n+\n+import java.util.Comparator;\n+import java.util.concurrent.Callable;\n+import java.util.stream.Stream;\n+\n+import static net.orfjackal.retrolambda.test.TestUtil.*;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.*;\n+import static org.junit.Assume.assumeThat;\n+\n+@SuppressWarnings(\"Convert2MethodRef\")\n+public class InterfaceStaticMethodsTest {\n+\n+    @Rule\n+    public final ExpectedException thrown = ExpectedException.none();\n+\n+    @Test\n+    public void static_methods_on_interfaces() {\n+        assertThat(Interface.staticMethod(), is(42));\n+    }\n+\n+    @Test\n+    public void static_methods_on_interfaces_taking_arguments() {\n+        assertThat(Interface.staticMethodWithArgs(\"a\", 1, 2L), is(\"a12\"));\n+    }\n+\n+    @Test\n+    public void static_methods_on_interfaces_containing_lambdas() throws Exception {\n+        assertThat(Interface.staticMethodContainingLambdas(), is(123));\n+    }\n+\n+    @Test\n+    public void calling_static_methods_on_interfaces_from_default_methods() {\n+        Interface obj = new Interface() {\n+        };\n+        assertThat(obj.callStaticMethod(), is(42));\n+    }\n+\n+    @Test\n+    public void calling_static_methods_on_interfaces_from_lambdas() throws Exception {\n+        Callable<Integer> c = () -> Interface.staticMethod();\n+        assertThat(c.call(), is(42));\n+    }\n+\n+    @Test\n+    public void calling_static_methods_on_interfaces_from_method_references() throws Exception {\n+        Callable<Integer> c = Interface::staticMethod;\n+        assertThat(c.call(), is(42));\n+    }\n+\n+    private interface Interface {\n+        default int callStaticMethod() {\n+            return staticMethod();\n+        }\n+\n+        static int staticMethod() {\n+            return 42;\n+        }\n+\n+        // arguments of just a couple of different types because we're lazy\n+        static String staticMethodWithArgs(String s, int a, long b) {\n+            return s + a + b;\n+        }\n+\n+        static int staticMethodContainingLambdas() throws Exception {\n+            Callable<Integer> lambda = () -> 123;\n+            return lambda.call();\n+        }\n+    }\n+\n+    /**\n+     * Calling a {@code InterfaceMethodref} constant pool entry with {@code invokestatic}\n+     * is not allowed in Java 7 bytecode. It'll fail at class loading time with\n+     * \"VerifyError: Illegal type at constant pool entry\"\n+     */\n+    @Test\n+    public void calling_static_methods_of_library_interfaces__new_interface() {\n+        assumeThat(SystemUtils.JAVA_VERSION_FLOAT, is(lessThan(1.8f)));\n+\n+        thrown.expect(NoClassDefFoundError.class);\n+        thrown.expectMessage(\"java/util/stream/Stream\");\n+        // We don't want this call to prevent loading this whole test class,\n+        // it should only fail when this line is executed\n+        Stream.of(1, 2, 3);\n+    }\n+\n+    @Test\n+    public void calling_static_methods_of_library_interfaces__new_method_on_old_interface() {\n+        assumeThat(SystemUtils.JAVA_VERSION_FLOAT, is(lessThan(1.8f)));\n+\n+        thrown.expect(IncompatibleClassChangeError.class);\n+        thrown.expectMessage(SystemUtils.isJavaVersionAtLeast(1.6f)\n+                ? equalTo(\"Found interface java.util.Comparator, but class was expected\")\n+                : nullValue(String.class)); // on Java 5 there is no message\n+\n+        // We don't want this call to prevent loading this whole test class,\n+        // it should only fail when this line is executed\n+        Comparator.naturalOrder();\n+    }\n+\n+    @Test\n+    public void will_not_generate_a_companion_class_when_the_interface_has_just_constant_fields() {\n+        assertThat(InterfaceWithConstants.FOO, is(3));\n+        assertClassDoesNotExist(companionNameOf(InterfaceWithConstants.class));\n+    }\n+\n+    private interface InterfaceWithConstants {\n+        int FOO = (int) Math.sqrt(9); // a constant which needs to be calculated in a static initialization block\n+    }\n+}\n"
    },
    {
        "commit_hash": "806ac902ab3eae61ce8293f6bb9695d674a0b3c8",
        "previous_commit_hash": "05baa1bae1ee79f4292233a74a845146971cb987",
        "diff_stats": {
            "additions": 47,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,47 @@\n+// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.test;\n+\n+import com.google.common.io.CharStreams;\n+import org.apache.commons.lang.SystemUtils;\n+import org.junit.Test;\n+\n+import java.io.*;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.*;\n+\n+public class Java5BytecodeTest {\n+\n+    @Test\n+    public void does_not_generate_stack_map_tables_for_Java_5() throws IOException {\n+        String javapOutput = javap(Dummy.class);\n+\n+        if (SystemUtils.isJavaVersionAtLeast(1.6f)) {\n+            assertThat(javapOutput, containsString(\"StackMap\"));\n+        } else {\n+            assertThat(javapOutput, not(containsString(\"StackMap\")));\n+        }\n+    }\n+\n+    private static String javap(Class<?> aClass) throws IOException {\n+        Process process = new ProcessBuilder()\n+                .directory(TestEnv.testClassesDir)\n+                .command(\"javap\", \"-v\", \"-p\", aClass.getName())\n+                .redirectErrorStream(true)\n+                .start();\n+        return CharStreams.toString(new InputStreamReader(process.getInputStream()));\n+    }\n+\n+\n+    public static class Dummy {\n+        public Dummy() {\n+            // cause this method to have a stack map table\n+            for (int i = 0; i < 3; i++) {\n+                System.out.println(i);\n+            }\n+        }\n+    }\n+}\n"
    },
    {
        "commit_hash": "806ac902ab3eae61ce8293f6bb9695d674a0b3c8",
        "previous_commit_hash": "05baa1bae1ee79f4292233a74a845146971cb987",
        "diff_stats": {
            "additions": 99,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,99 @@\n+// Copyright \u00a9 2013-2016 Esko Luontola and other Retrolambda contributors\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.test;\n+\n+import com.google.common.collect.ImmutableSet;\n+import org.junit.Test;\n+\n+import java.lang.reflect.Method;\n+import java.util.*;\n+\n+import static net.orfjackal.retrolambda.test.TestUtil.assertClassExists;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.*;\n+\n+public class LambdaClassesTest {\n+\n+    @Test\n+    public void the_sequence_number_starts_from_1_for_each_enclosing_class() {\n+        assertClassExists(Dummy1.class.getName() + \"$$Lambda$1\");\n+        assertClassExists(Dummy1.class.getName() + \"$$Lambda$2\");\n+        assertClassExists(Dummy2.class.getName() + \"$$Lambda$1\");\n+        assertClassExists(Dummy2.class.getName() + \"$$Lambda$2\");\n+    }\n+\n+    @SuppressWarnings(\"UnusedDeclaration\")\n+    private class Dummy1 {\n+        private Dummy1() {\n+            Runnable lambda1 = () -> {\n+            };\n+            Runnable lambda2 = () -> {\n+            };\n+        }\n+    }\n+\n+    @SuppressWarnings(\"UnusedDeclaration\")\n+    private class Dummy2 {\n+        private Dummy2() {\n+            Runnable lambda1 = () -> {\n+            };\n+            Runnable lambda2 = () -> {\n+            };\n+        }\n+    }\n+\n+\n+    @Test\n+    public void capturing_lambda_classes_contain_no_unnecessary_methods() throws ClassNotFoundException {\n+        assertThat(getMethodsNames(findLambdaClass(Capturing.class)),\n+                is(ImmutableSet.of(\"lambdaFactory$\", \"run\")));\n+    }\n+\n+    @SuppressWarnings(\"UnusedDeclaration\")\n+    private class Capturing {\n+        private Capturing() {\n+            Runnable lambda = () -> System.out.println(hashCode());\n+        }\n+    }\n+\n+\n+    @Test\n+    public void non_capturing_lambda_classes_contain_no_unnecessary_methods() throws ClassNotFoundException {\n+        assertThat(getMethodsNames(findLambdaClass(NonCapturing.class)),\n+                is(ImmutableSet.of(\"lambdaFactory$\", \"run\")));\n+    }\n+\n+    @SuppressWarnings(\"UnusedDeclaration\")\n+    private class NonCapturing {\n+        private NonCapturing() {\n+            Runnable lambda = () -> {\n+            };\n+        }\n+    }\n+\n+\n+    @Test\n+    public void enclosing_classes_contain_no_unnecessary_methods_in_addition_to_the_lambda_body() throws ClassNotFoundException {\n+        assertThat(\"non-capturing lambda\", getMethodsNames(NonCapturing.class), contains(startsWith(\"lambda$new$\")));\n+        assertThat(\"capturing lambda\", getMethodsNames(Capturing.class), contains(startsWith(\"lambda$new$\")));\n+    }\n+\n+\n+    // helpers\n+\n+    private static Class<?> findLambdaClass(Class<?> clazz) throws ClassNotFoundException {\n+        return Class.forName(clazz.getName() + \"$$Lambda$1\");\n+    }\n+\n+    private static Set<String> getMethodsNames(Class<?> clazz) {\n+        Method[] methods = clazz.getDeclaredMethods();\n+        Set<String> uniqueNames = new HashSet<>();\n+        for (Method method : methods) {\n+            uniqueNames.add(method.getName());\n+        }\n+        assertThat(\"unexpected overloaded methods\", methods, arrayWithSize(uniqueNames.size()));\n+        return uniqueNames;\n+    }\n+}\n"
    },
    {
        "commit_hash": "806ac902ab3eae61ce8293f6bb9695d674a0b3c8",
        "previous_commit_hash": "05baa1bae1ee79f4292233a74a845146971cb987",
        "diff_stats": {
            "additions": 341,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,341 @@\n+// Copyright \u00a9 2013-2016 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.test;\n+\n+import net.orfjackal.retrolambda.test.anotherpackage.DifferentPackageBase;\n+import org.apache.commons.lang.SystemUtils;\n+import org.junit.Test;\n+import org.objectweb.asm.*;\n+import org.objectweb.asm.Type;\n+\n+import java.io.IOException;\n+import java.lang.reflect.*;\n+import java.util.*;\n+import java.util.concurrent.Callable;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.*;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assume.assumeThat;\n+\n+public class LambdaTest extends SuperClass {\n+\n+    @Test\n+    public void empty_lambda() {\n+        Runnable lambda = () -> {\n+        };\n+\n+        lambda.run();\n+    }\n+\n+    @Test\n+    public void lambda_returning_a_value() throws Exception {\n+        Callable<String> lambda = () -> \"some value\";\n+\n+        assertThat(lambda.call(), is(\"some value\"));\n+    }\n+\n+    private interface Function1<IN, OUT> {\n+        OUT apply(IN value);\n+    }\n+\n+    @Test\n+    public void lambda_taking_parameters() {\n+        Function1<String, Integer> lambda = (String s) -> s.getBytes().length;\n+\n+        assertThat(lambda.apply(\"foo\"), is(3));\n+    }\n+\n+    @Test\n+    public void lambda_in_project_main_sources() throws Exception {\n+        assertThat(InMainSources.callLambda(), is(42));\n+    }\n+\n+    private int instanceVar = 0;\n+\n+    @Test\n+    public void lambda_using_instance_variables() {\n+        Runnable lambda = () -> {\n+            instanceVar = 42;\n+        };\n+        lambda.run();\n+\n+        assertThat(instanceVar, is(42));\n+    }\n+\n+    @Test\n+    public void lambda_using_local_variables() {\n+        int[] localVar = new int[1];\n+        Runnable lambda = () -> {\n+            localVar[0] = 42;\n+        };\n+        lambda.run();\n+\n+        assertThat(localVar[0], is(42));\n+    }\n+\n+    @Test\n+    public void lambda_using_local_variables_of_primitive_types() throws Exception {\n+        boolean bool = true;\n+        byte b = 2;\n+        short s = 3;\n+        int i = 4;\n+        long l = 5;\n+        float f = 6;\n+        double d = 7;\n+        char c = 8;\n+        Callable<Integer> lambda = () -> (int) ((bool ? 1 : 0) + b + s + i + l + f + d + c);\n+\n+        assertThat(lambda.call(), is(36));\n+    }\n+\n+    @Test\n+    public void lambda_in_the_constant_initializer_of_an_interface() throws Exception {\n+        assertThat(LambdaConstant.LAMBDA.call(), is(\"foo\"));\n+    }\n+\n+    public interface LambdaConstant {\n+        Callable<String> LAMBDA = () -> \"foo\";\n+    }\n+\n+    @Test\n+    public void lambdas_with_marker_interfaces_due_to_intersection_types() throws Exception {\n+        // We must use something other than java.io.Serializable as the marker interface,\n+        // because serializable lambdas are signified by a flag to LambdaMetafactory.altMetafactory\n+        Callable<String> lambda = (Callable<String> & Cloneable) () -> \"foo\";\n+\n+        assertThat(lambda, is(instanceOf(Cloneable.class)));\n+        assertThat(lambda.call(), is(\"foo\"));\n+    }\n+\n+    @Test\n+    public void method_references_to_virtual_methods_on_local_variables() throws Exception {\n+        String foo = \"foo\";\n+        Callable<String> ref = foo::toUpperCase;\n+\n+        assertThat(ref.call(), is(\"FOO\"));\n+    }\n+\n+    @Test\n+    public void method_references_to_virtual_methods_on_instance_variables() throws Exception {\n+        Callable<String> ref = instanceVarFoo::toUpperCase;\n+\n+        assertThat(ref.call(), is(\"FOO\"));\n+    }\n+\n+    @SuppressWarnings(\"FieldCanBeLocal\")\n+    private String instanceVarFoo = \"foo\";\n+\n+    @Test\n+    public void method_references_to_interface_methods() throws Exception {\n+        List<String> foos = Arrays.asList(\"foo\");\n+        Callable<Integer> ref = foos::size;\n+\n+        assertThat(ref.call(), is(1));\n+    }\n+\n+    @Test\n+    public void method_references_to_static_methods() throws Exception {\n+        long expected = System.currentTimeMillis();\n+        Callable<Long> ref = System::currentTimeMillis;\n+\n+        assertThat(ref.call(), is(greaterThanOrEqualTo(expected)));\n+    }\n+\n+    @Test\n+    public void method_references_to_constructors() throws Exception {\n+        Callable<List<String>> ref = ArrayList<String>::new;\n+\n+        assertThat(ref.call(), is(instanceOf(ArrayList.class)));\n+    }\n+\n+    @Test\n+    public void method_references_to_protected_supertype_methods() throws Exception {\n+        Callable<String> ref1 = new SubclassInMyPackage().thing();\n+        assertThat(ref1.call(), equalTo(\"Hello\"));\n+\n+        Callable<String> ref2 = new SubclassInSamePackage().thing();\n+        assertThat(ref2.call(), equalTo(\"Hello\"));\n+    }\n+\n+    public static class SubclassInMyPackage extends DifferentPackageBase {\n+        public Callable<String> thing() {\n+            return DifferentPackageBase::value;\n+        }\n+    }\n+\n+    public static class SubclassInSamePackage extends SamePackageBase {\n+        public Callable<String> thing() {\n+            return SamePackageBase::value;\n+        }\n+    }\n+\n+    /**\n+     * Because the constructor is private, an access method must be generated for it\n+     * and also the NEW instruction must be done inside the access method.\n+     */\n+    @Test\n+    public void method_references_to_private_constructors() throws Exception {\n+        Callable<HasPrivateConstructor> factory = HasPrivateConstructor.factory();\n+        assertThat(factory.call(), is(instanceOf(HasPrivateConstructor.class)));\n+\n+        HasPrivateConstructorWithArgs.Factory factoryArgs = HasPrivateConstructorWithArgs.factory();\n+        assertThat(factoryArgs.create(\"args\"), is(instanceOf(HasPrivateConstructorWithArgs.class)));\n+        assertThat(factoryArgs.create(\"args\").args, is(\"args\"));\n+    }\n+\n+    public static class HasPrivateConstructor {\n+\n+        private HasPrivateConstructor() {\n+        }\n+\n+        public static Callable<HasPrivateConstructor> factory() {\n+            return HasPrivateConstructor::new;\n+        }\n+    }\n+\n+    public static class HasPrivateConstructorWithArgs {\n+        public final String args;\n+\n+        private HasPrivateConstructorWithArgs(String args) {\n+            this.args = args;\n+        }\n+\n+        public static Factory factory() {\n+            return HasPrivateConstructorWithArgs::new;\n+        }\n+\n+        public interface Factory {\n+            HasPrivateConstructorWithArgs create(String args);\n+        }\n+    }\n+\n+\n+    @Test\n+    public void method_references_to_overridden_inherited_methods_with_super() throws Exception {\n+        Callable<String> ref = super::inheritedMethod;\n+\n+        assertThat(ref.call(), is(\"superclass version\"));\n+    }\n+\n+    @Override\n+    String inheritedMethod() {\n+        return \"overridden version\";\n+    }\n+\n+    @Test\n+    public void method_references_to_private_methods() throws Exception {\n+        Callable<String> ref1 = LambdaTest::privateClassMethod;\n+        assertThat(ref1.call(), is(\"foo\"));\n+\n+        Callable<String> ref2 = this::privateInstanceMethod;\n+        assertThat(ref2.call(), is(\"foo\"));\n+\n+        // Normal method calls should still work after our magic\n+        // of making them them accessible from the lambda classes.\n+        assertThat(privateClassMethod(), is(\"foo\"));\n+        assertThat(privateInstanceMethod(), is(\"foo\"));\n+    }\n+\n+    private String privateInstanceMethod() {\n+        return \"foo\";\n+    }\n+\n+    private static String privateClassMethod() {\n+        return \"foo\";\n+    }\n+\n+    /**\n+     * We could make private lambda implementation methods package-private,\n+     * so that the lambda class may call them, but we should not make any\n+     * more methods non-private than is absolutely necessary.\n+     */\n+    @Test\n+    public void will_not_change_the_visibility_of_unrelated_methods() throws Exception {\n+        assertThat(unrelatedPrivateMethod(), is(\"foo\"));\n+\n+        Method method = getClass().getDeclaredMethod(\"unrelatedPrivateMethod\");\n+        int modifiers = method.getModifiers();\n+\n+        assertTrue(\"expected \" + method.getName() + \" to be private, but modifiers were: \" + Modifier.toString(modifiers),\n+                Modifier.isPrivate(modifiers));\n+    }\n+\n+    private String unrelatedPrivateMethod() {\n+        return \"foo\";\n+    }\n+\n+    /**\n+     * We cannot just make the private methods package-private for the\n+     * lambda class to call them, because that may cause a method in subclass\n+     * to override them.\n+     */\n+    @Test\n+    public void will_not_cause_private_methods_to_be_overridable() throws Exception {\n+        class Parent {\n+            private String privateMethod() {\n+                return \"parent version\";\n+            }\n+\n+            Callable<String> parentRef() {\n+                return this::privateMethod;\n+            }\n+        }\n+        class Child extends Parent {\n+            private String privateMethod() { // would override if were not private\n+                return \"child version\";\n+            }\n+\n+            Callable<String> childRef() {\n+                return this::privateMethod;\n+            }\n+        }\n+\n+        Child child = new Child();\n+\n+        // Our test assumes that there exists a private method with\n+        // the same name and signature in super and sub classes.\n+        String name = \"privateMethod\";\n+        assertThat(child.getClass().getDeclaredMethod(name), is(notNullValue()));\n+        assertThat(child.getClass().getSuperclass().getDeclaredMethod(name), is(notNullValue()));\n+\n+        assertThat(child.privateMethod(), is(\"child version\"));\n+        assertThat(child.childRef().call(), is(\"child version\"));\n+\n+        assertThat(((Parent) child).privateMethod(), is(\"parent version\"));\n+        assertThat(child.parentRef().call(), is(\"parent version\"));\n+    }\n+\n+    @Test\n+    public void bytecode_constant_pool_will_not_contain_dangling_references_to_MethodHandles() throws IOException {\n+        assumeThat(SystemUtils.JAVA_VERSION_FLOAT, is(lessThan(1.7f)));\n+\n+        ClassReader cr = new ClassReader(getClass().getName().replace('.', '/'));\n+        char[] buf = new char[cr.getMaxStringLength()];\n+\n+        for (int item = 0; item < cr.getItemCount(); item++) {\n+            Object constant = readConstant(item, buf, cr);\n+            if (constant instanceof Type) {\n+                Type type = (Type) constant;\n+                assertThat(\"constant #\" + item, type.getDescriptor(), not(containsString(\"java/lang/invoke\")));\n+            }\n+        }\n+    }\n+\n+    private static Object readConstant(int item, char[] buf, ClassReader cr) {\n+        try {\n+            return cr.readConst(item, buf);\n+        } catch (Exception e) {\n+            // XXX: constant pool entry which is a Methodref, InvokeDynamic or similar non-plain constant\n+            return null;\n+        }\n+    }\n+}\n+\n+class SuperClass {\n+    String inheritedMethod() {\n+        return \"superclass version\";\n+    }\n+}\n"
    },
    {
        "commit_hash": "806ac902ab3eae61ce8293f6bb9695d674a0b3c8",
        "previous_commit_hash": "05baa1bae1ee79f4292233a74a845146971cb987",
        "diff_stats": {
            "additions": 40,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,40 @@\n+// Copyright \u00a9 2013 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.test;\n+\n+import org.junit.Test;\n+\n+import java.util.concurrent.Callable;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.*;\n+\n+public class OptimizationsTest {\n+\n+    @Test\n+    public void lambdas_which_capture_variables_get_a_new_instance_every_time() {\n+        Callable<Integer> lambda1 = createStatefulLambda();\n+        Callable<Integer> lambda2 = createStatefulLambda();\n+\n+        assertThat(lambda1, is(not(sameInstance(lambda2))));\n+    }\n+\n+    private static Callable<Integer> createStatefulLambda() {\n+        int i = 42;\n+        return () -> i;\n+    }\n+\n+    @Test\n+    public void lambdas_which_do_not_capture_variables_have_only_one_singleton_instance() {\n+        Callable<Integer> lambda1 = createStatelessLambda();\n+        Callable<Integer> lambda2 = createStatelessLambda();\n+\n+        assertThat(lambda1, is(sameInstance(lambda2)));\n+    }\n+\n+    private static Callable<Integer> createStatelessLambda() {\n+        return () -> 42;\n+    }\n+}\n"
    },
    {
        "commit_hash": "806ac902ab3eae61ce8293f6bb9695d674a0b3c8",
        "previous_commit_hash": "05baa1bae1ee79f4292233a74a845146971cb987",
        "diff_stats": {
            "additions": 56,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,56 @@\n+// Copyright \u00a9 2013-2016 Esko Luontola and other Retrolambda contributors\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.test;\n+\n+import org.junit.Test;\n+\n+import java.util.Objects;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.*;\n+\n+public class RequireNonNullTest {\n+\n+    @Test\n+    public void requireNonNull__silent_when_non_null() {\n+        Objects.requireNonNull(new Object());\n+    }\n+\n+\n+    @Test(expected = NullPointerException.class)\n+    public void requireNonNull__throws_NPE_when_null() {\n+        Objects.requireNonNull(null);\n+    }\n+\n+    @Test\n+    public void requireNonNull__returns_the_argument() {\n+        Object expected = new Object();\n+\n+        Object actual = Objects.requireNonNull(expected);\n+\n+        assertThat(actual, is(sameInstance(expected)));\n+    }\n+\n+    @Test\n+    public void synthetic_null_check__silent_when_non_null() {\n+        syntheticNullCheck(new MaybeNull());\n+    }\n+\n+    @Test(expected = NullPointerException.class)\n+    public void synthetic_null_check__throws_NPE_when_null() {\n+        syntheticNullCheck(null);\n+    }\n+\n+    @SuppressWarnings(\"unused\")\n+    private static void syntheticNullCheck(MaybeNull maybeNull) {\n+        // Javac knows that the `foo` field is constant 0, so it generates a null check and the `iconst_0` instruction.\n+        // The null check is a `obj.getClass()` call on older JDKs and `Objects.requireNonNull(obj)` on JDK 9 and above.\n+        int foo = maybeNull.foo;\n+    }\n+\n+    private static class MaybeNull {\n+        final int foo = 0;\n+    }\n+}\n"
    },
    {
        "commit_hash": "806ac902ab3eae61ce8293f6bb9695d674a0b3c8",
        "previous_commit_hash": "05baa1bae1ee79f4292233a74a845146971cb987",
        "diff_stats": {
            "additions": 11,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,11 @@\n+// Copyright \u00a9 2013-2016 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.test;\n+\n+public class SamePackageBase {\n+    protected static String value() {\n+        return \"Hello\";\n+    }\n+}\n"
    },
    {
        "commit_hash": "806ac902ab3eae61ce8293f6bb9695d674a0b3c8",
        "previous_commit_hash": "05baa1bae1ee79f4292233a74a845146971cb987",
        "diff_stats": {
            "additions": 64,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,64 @@\n+// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.test;\n+\n+import org.junit.Test;\n+\n+import java.io.*;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+\n+public class SerializableLambdaTest {\n+\n+    @Test\n+    public void serializable_interface() throws Exception {\n+        SerializableFoo original = (i) -> i + 10;\n+\n+        SerializableFoo serialized = roundTripSerialize(original);\n+\n+        assertThat(serialized.foo(4), is(14));\n+    }\n+\n+    @Test\n+    public void cast_expression_with_serializable_additional_bound() throws Exception {\n+        Foo original = (Foo & Serializable) (i) -> i + 20;\n+\n+        Foo serialized = roundTripSerialize(original);\n+\n+        assertThat(serialized.foo(4), is(24));\n+    }\n+\n+    @Test\n+    public void captured_local_variables() throws Exception {\n+        int var = 30;\n+        SerializableFoo original = (i) -> i + var;\n+\n+        SerializableFoo serialized = roundTripSerialize(original);\n+\n+        assertThat(serialized.foo(4), is(34));\n+    }\n+\n+\n+    // guinea pigs & helpers\n+\n+    public interface Foo {\n+        int foo(int i);\n+    }\n+\n+    public interface SerializableFoo extends Foo, Serializable {\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static <T> T roundTripSerialize(T original) throws Exception {\n+        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+        try (ObjectOutputStream out = new ObjectOutputStream(buffer)) {\n+            out.writeObject(original);\n+        }\n+        try (ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()))) {\n+            return (T) in.readObject();\n+        }\n+    }\n+}\n"
    },
    {
        "commit_hash": "806ac902ab3eae61ce8293f6bb9695d674a0b3c8",
        "previous_commit_hash": "05baa1bae1ee79f4292233a74a845146971cb987",
        "diff_stats": {
            "additions": 23,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,23 @@\n+// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.test;\n+\n+import java.io.*;\n+import java.util.Properties;\n+\n+public class TestEnv {\n+\n+    public static final File testClassesDir;\n+\n+    static {\n+        Properties p = new Properties();\n+        try (InputStream in = TestEnv.class.getResourceAsStream(\"/testing.properties\")) {\n+            p.load(in);\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+        testClassesDir = new File(p.getProperty(\"testClassesDir\"));\n+    }\n+}\n"
    },
    {
        "commit_hash": "806ac902ab3eae61ce8293f6bb9695d674a0b3c8",
        "previous_commit_hash": "05baa1bae1ee79f4292233a74a845146971cb987",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>2.2.1-SNAPSHOT</version>\n+    <version>2.3.0</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "806ac902ab3eae61ce8293f6bb9695d674a0b3c8",
        "previous_commit_hash": "05baa1bae1ee79f4292233a74a845146971cb987",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.2.1-SNAPSHOT</version>\n+        <version>2.3.0</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "806ac902ab3eae61ce8293f6bb9695d674a0b3c8",
        "previous_commit_hash": "05baa1bae1ee79f4292233a74a845146971cb987",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.2.1-SNAPSHOT</version>\n+        <version>2.3.0</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "806ac902ab3eae61ce8293f6bb9695d674a0b3c8",
        "previous_commit_hash": "05baa1bae1ee79f4292233a74a845146971cb987",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.2.1-SNAPSHOT</version>\n+        <version>2.3.0</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "790a9b2c73c309e190deba6657750c8525e1ea80",
        "previous_commit_hash": "806ac902ab3eae61ce8293f6bb9695d674a0b3c8",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.3.0</version>\n+        <version>2.3.1-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "790a9b2c73c309e190deba6657750c8525e1ea80",
        "previous_commit_hash": "806ac902ab3eae61ce8293f6bb9695d674a0b3c8",
        "diff_stats": {
            "additions": 0,
            "deletions": 77
        },
        "diff_content": "@@ -1,77 +0,0 @@\n-// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n-// This software is released under the Apache License 2.0.\n-// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n-\n-package net.orfjackal.retrolambda.test;\n-\n-import org.hamcrest.*;\n-import org.junit.Test;\n-\n-import java.io.IOException;\n-import java.net.URL;\n-import java.util.*;\n-\n-import static org.hamcrest.MatcherAssert.assertThat;\n-import static org.hamcrest.Matchers.*;\n-import static org.junit.Assert.assertNotNull;\n-\n-public class ClasspathTest {\n-\n-    @Test\n-    public void maven_plugin_sets_classpath_for_main_dependencies() {\n-        assertThat(InMainSources.useLambdaOfImportedType(Arrays.asList(\"a\", \"b\")), is(Arrays.asList(\"A\", \"B\")));\n-    }\n-\n-    @Test\n-    public void maven_plugin_sets_classpath_for_test_dependencies() {\n-        SelfDescribing lambda = (desc) -> desc.appendText(\"foo\");\n-\n-        StringDescription result = new StringDescription();\n-        lambda.describeTo(result);\n-        assertThat(result.toString(), is(\"foo\"));\n-    }\n-\n-    /**\n-     * This is to reproduce a bug where the Maven plugin does not include\n-     * the main classes on the test classpath, causing Retrolambda to fail\n-     * in loading test classes such as this one (i.e. test classes which\n-     * depend on main classes at class loading time).\n-     */\n-    @Test\n-    public void maven_plugin_includes_the_main_classes_in_the_test_classpath() {\n-        class RequiresMainClassesInTestClasspath extends InMainSources {\n-            public Runnable foo() {\n-                // Any lambda, to make Retrolambda try to process this class\n-                return () -> {\n-                };\n-            }\n-        }\n-        new RequiresMainClassesInTestClasspath().foo();\n-    }\n-\n-    /**\n-     * This is to reproduce a bug where trying to backport a development\n-     * version of JavaFX classes fails because the same classes also exist in\n-     * the JRE's extension directory and Retrolambda accidentally loads the\n-     * old built-in class instead of the new class that is being transformed.\n-     */\n-    @Test\n-    public void prefers_classes_in_explicit_classpath_over_classes_in_the_JRE() {\n-        assertNotNull(getClass().getResource(\"/com/sun/javafx/application/LauncherImpl$$Lambda$1.class\"));\n-    }\n-\n-    /**\n-     * Classes in the {@code java.*} packages can be loaded only by the bootstrap\n-     * class loader, so we must not try to load them with our custom class loader.\n-     * This situation arises when backporting Android applications, because android.jar\n-     * contains {@code java.*} classes.\n-     */\n-    @Test\n-    public void ignores_classes_in_explicit_classpath_that_are_under_the_java_package() throws IOException {\n-        // We have a JAR on the classpath that contains dummy version of java.lang.Object,\n-        // the same way as android.jar, which causes Retrolambda to try loading that class\n-        // because the classes to be backported extend it implicitly.\n-        List<URL> resources = Collections.list(getClass().getClassLoader().getResources(\"java/lang/Object.class\"));\n-        assertThat(resources, (Matcher) hasItem(hasToString(containsString(\"java-lang-dummies.jar\"))));\n-    }\n-}\n"
    },
    {
        "commit_hash": "790a9b2c73c309e190deba6657750c8525e1ea80",
        "previous_commit_hash": "806ac902ab3eae61ce8293f6bb9695d674a0b3c8",
        "diff_stats": {
            "additions": 0,
            "deletions": 609
        },
        "diff_content": "@@ -1,609 +0,0 @@\n-// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n-// This software is released under the Apache License 2.0.\n-// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n-\n-package net.orfjackal.retrolambda.test;\n-\n-import net.orfjackal.retrolambda.test.anotherpackage.UsesLambdasInAnotherPackage;\n-import org.apache.commons.lang.SystemUtils;\n-import org.hamcrest.*;\n-import org.junit.*;\n-import org.junit.rules.ExpectedException;\n-\n-import java.lang.annotation.*;\n-import java.util.*;\n-import java.util.concurrent.Callable;\n-\n-import static net.orfjackal.retrolambda.test.TestUtil.companionOf;\n-import static org.hamcrest.MatcherAssert.assertThat;\n-import static org.hamcrest.Matchers.*;\n-import static org.junit.Assume.assumeThat;\n-import static org.mockito.Mockito.mock;\n-\n-@SuppressWarnings({\"Convert2Lambda\", \"Anonymous2MethodRef\", \"RedundantCast\", \"UnusedDeclaration\"})\n-public class DefaultMethodsTest {\n-\n-    @Rule\n-    public final ExpectedException thrown = ExpectedException.none();\n-\n-\n-    // Inheriting & Overriding\n-\n-    @Test\n-    public void default_method_inherited_from_interface() {\n-        DefaultMethods obj = new DefaultMethods() {\n-        };\n-        assertThat(obj.foo(), is(\"original\"));\n-    }\n-\n-    @Test\n-    public void default_method_overridden_in_current_class() {\n-        assertThat(new DefaultMethodOverridingClass().foo(), is(\"overridden\"));\n-    }\n-\n-    @Test\n-    public void default_method_overridden_in_parent_class() {\n-        class C extends DefaultMethodOverridingClass {\n-        }\n-        assertThat(new C().foo(), is(\"overridden\"));\n-    }\n-\n-    @Test\n-    public void default_method_overridden_in_parent_class_and_implements_interface_explicitly() {\n-        class C extends DefaultMethodOverridingClass implements DefaultMethods {\n-        }\n-        assertThat(new C().foo(), is(\"overridden\"));\n-    }\n-\n-    private interface DefaultMethods {\n-        default String foo() {\n-            return \"original\";\n-        }\n-    }\n-\n-    private class DefaultMethodOverridingClass implements DefaultMethods {\n-        @Override\n-        public String foo() {\n-            return \"overridden\";\n-        }\n-    }\n-\n-\n-    @Test\n-    public void default_method_overridden_in_child_interface() {\n-        OverrideChild child = new OverrideChild() {\n-        };\n-        assertThat(child.foo(), is(\"overridden\"));\n-    }\n-\n-    private interface OverrideParent {\n-        default String foo() {\n-            return \"original\";\n-        }\n-    }\n-\n-    private interface OverrideChild extends OverrideParent {\n-        @Override\n-        default String foo() {\n-            return \"overridden\";\n-        }\n-    }\n-\n-\n-    /**\n-     * Based on the example in <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html#jls-9.4.1\">JLS \u00a79.4.1</a>\n-     * (Interfaces - Inheritance and Overriding)\n-     */\n-    @Test\n-    public void inheriting_same_default_methods_through_many_parent_interfaces() {\n-        assertThat(new InheritsOriginal() {\n-        }.foo(), is(\"original\"));\n-\n-        assertThat(new InheritsOverridden() {\n-        }.foo(), is(\"overridden\"));\n-\n-        assertThat(new InheritsOverriddenAndOriginal() {\n-        }.foo(), is(\"overridden\"));\n-\n-        assertThat(new InheritsOriginalAndOverridden() {\n-        }.foo(), is(\"overridden\"));\n-    }\n-\n-    private interface SuperOriginal {\n-        default String foo() {\n-            return \"original\";\n-        }\n-    }\n-\n-    private interface SuperOverridden extends SuperOriginal {\n-        @Override\n-        default String foo() {\n-            return \"overridden\";\n-        }\n-    }\n-\n-    private interface InheritsOriginal extends SuperOriginal {\n-    }\n-\n-    private interface InheritsOverridden extends SuperOverridden {\n-    }\n-\n-    private interface InheritsOverriddenAndOriginal extends SuperOverridden, InheritsOriginal {\n-    }\n-\n-    private interface InheritsOriginalAndOverridden extends InheritsOriginal, SuperOverridden {\n-    }\n-\n-\n-    @Test\n-    public void implements_original_and_overridden_default_method() {\n-        assertThat(new ImplementsOriginal().foo(), is(\"original\"));\n-        assertThat(new ImplementsOriginalAndOverriddenDefault().foo(), is(\"overridden\"));\n-        assertThat(new ImplementsOverriddenAndOriginalDefault().foo(), is(\"overridden\"));\n-        assertThat(new ExtendsImplementsOriginalAndImplementsOverriddenDefault().foo(), is(\"overridden\"));\n-    }\n-\n-    private interface OriginalDefault {\n-        default String foo() {\n-            return \"original\";\n-        }\n-    }\n-\n-    private interface OverriddenDefault extends OriginalDefault {\n-        @Override\n-        default String foo() {\n-            return \"overridden\";\n-        }\n-    }\n-\n-    private class ImplementsOriginal implements OriginalDefault {\n-    }\n-\n-    private class ImplementsOriginalAndOverriddenDefault implements OriginalDefault, OverriddenDefault {\n-    }\n-\n-    private class ImplementsOverriddenAndOriginalDefault implements OverriddenDefault, OriginalDefault {\n-    }\n-\n-    private class ExtendsImplementsOriginalAndImplementsOverriddenDefault extends ImplementsOriginal implements OverriddenDefault {\n-    }\n-\n-\n-    // Bridge Methods\n-\n-    @Test\n-    public void default_method_type_refined_in_child_interface() {\n-        RefineChild child = new RefineChild() {\n-            @Override\n-            public String foo() {\n-                return \"refined\";\n-            }\n-        };\n-        assertThat(\"direct call\", child.foo(), is(\"refined\"));\n-        assertThat(\"bridged call\", ((RefineParent) child).foo(), is((Object) \"refined\"));\n-    }\n-\n-    @Test\n-    public void default_method_type_refined_in_implementing_class() {\n-        class C implements RefineParent {\n-            @Override\n-            public String foo() {\n-                return \"refined\";\n-            }\n-        }\n-        C obj = new C();\n-        assertThat(\"direct call\", obj.foo(), is(\"refined\"));\n-        assertThat(\"bridged call\", ((RefineParent) obj).foo(), is((Object) \"refined\"));\n-    }\n-\n-    private interface RefineParent {\n-        default Object foo() {\n-            return \"original\";\n-        }\n-    }\n-\n-    private interface RefineChild extends RefineParent {\n-        @Override\n-        String foo();\n-    }\n-\n-\n-    @Test\n-    public void default_method_argument_type_refined_in_child_interface() {\n-        RefineArgChild child = new RefineArgChild() {\n-        };\n-        assertThat(\"direct call\", child.foo(\"42\"), is(\"refined 42\"));\n-        assertThat(\"bridged call\", ((RefineArgParent<String>) child).foo(\"42\"), is((Object) \"refined 42\"));\n-    }\n-\n-    @Test\n-    public void default_method_argument_type_refined_in_implementing_class() {\n-        class C implements RefineArgParent<String> {\n-            @Override\n-            public String foo(String arg) {\n-                return \"refined \" + arg;\n-            }\n-        }\n-        C obj = new C();\n-        assertThat(\"direct call\", obj.foo(\"42\"), is(\"refined 42\"));\n-        assertThat(\"bridged call\", ((RefineArgParent<String>) obj).foo(\"42\"), is((Object) \"refined 42\"));\n-    }\n-\n-    private interface RefineArgParent<T> {\n-        default String foo(T arg) {\n-            return \"original \" + arg;\n-        }\n-    }\n-\n-    private interface RefineArgChild extends RefineArgParent<String> {\n-        @Override\n-        default String foo(String arg) {\n-            return \"refined \" + arg;\n-        }\n-    }\n-\n-\n-    @Test\n-    public void default_method_type_refined_and_overridden_in_child_interface() {\n-        OverrideRefineChild child = new OverrideRefineChild() {\n-        };\n-        assertThat(\"direct call\", child.foo(), is(\"overridden and refined\"));\n-        assertThat(\"bridged call\", ((OverrideRefineParent) child).foo(), is((Object) \"overridden and refined\"));\n-    }\n-\n-    private interface OverrideRefineParent {\n-        default Object foo() {\n-            return \"original\";\n-        }\n-    }\n-\n-    private interface OverrideRefineChild extends OverrideRefineParent {\n-        @Override\n-        default String foo() {\n-            return \"overridden and refined\";\n-        }\n-    }\n-\n-\n-    // Primitive Types & Void\n-\n-    @Test\n-    public void default_methods_of_primitive_type() {\n-        Primitives p = new Primitives() {\n-        };\n-        assertThat(\"boolean\", p.getBoolean(), is(true));\n-        assertThat(\"byte\", p.getByte(), is((byte) 2));\n-        assertThat(\"short\", p.getShort(), is((short) 3));\n-        assertThat(\"int\", p.getInt(), is(4));\n-        assertThat(\"long\", p.getLong(), is(5L));\n-        assertThat(\"float\", p.getFloat(), is(6.0f));\n-        assertThat(\"double\", p.getDouble(), is(7.0));\n-        assertThat(\"char\", p.getChar(), is('a'));\n-    }\n-\n-    private interface Primitives {\n-        default boolean getBoolean() {\n-            return true;\n-        }\n-\n-        default byte getByte() {\n-            return 2;\n-        }\n-\n-        default short getShort() {\n-            return 3;\n-        }\n-\n-        default int getInt() {\n-            return 4;\n-        }\n-\n-        default long getLong() {\n-            return 5L;\n-        }\n-\n-        default float getFloat() {\n-            return 6.0f;\n-        }\n-\n-        default double getDouble() {\n-            return 7.0;\n-        }\n-\n-        default char getChar() {\n-            return 'a';\n-        }\n-    }\n-\n-\n-    @Test\n-    public void default_methods_of_void_type() {\n-        modifiedByVoidMethod = 1;\n-        Voids v = new Voids() {\n-        };\n-        v.run();\n-        assertThat(modifiedByVoidMethod, is(2));\n-    }\n-\n-    private static int modifiedByVoidMethod;\n-\n-    private interface Voids {\n-        default void run() {\n-            modifiedByVoidMethod++;\n-        }\n-    }\n-\n-\n-    @Test\n-    public void default_methods_with_primitive_arguments() {\n-        PrimitiveArgs p = new PrimitiveArgs() {\n-        };\n-        assertThat(p.sum(true, (byte) 2, (short) 3, 4, 5, 6, 7, (char) 8), is(36));\n-    }\n-\n-    private interface PrimitiveArgs {\n-        default int sum(boolean bool, byte b, short s, int i, long l, float f, double d, char c) {\n-            return (int) ((bool ? 1 : 0) + b + s + i + l + f + d + c);\n-        }\n-    }\n-\n-\n-    // Calling Super\n-\n-    @Test\n-    public void default_methods_calling_super() {\n-        SuperCallChild child = new SuperCallChild() {\n-        };\n-        assertThat(child.callSuper(), is(11));\n-    }\n-\n-    @Test\n-    public void default_methods_called_with_super() {\n-        class C implements SuperCallChild {\n-            @Override\n-            public int callSuper() {\n-                return 100 + SuperCallChild.super.callSuper();\n-            }\n-\n-            public int siblingCallingSuper() {\n-                return 1000 + SuperCallChild.super.callSuper();\n-            }\n-        }\n-        assertThat(new C().callSuper(), is(111));\n-        assertThat(new C().siblingCallingSuper(), is(1011));\n-    }\n-\n-    private interface SuperCallParent {\n-        default int callSuper() {\n-            return 1;\n-        }\n-    }\n-\n-    private interface SuperCallChild extends SuperCallParent {\n-        @Override\n-        default int callSuper() {\n-            return 10 + SuperCallParent.super.callSuper();\n-        }\n-    }\n-\n-\n-    @Test\n-    public void inheriting_unrelated_default_methods() {\n-        class C implements Conflict1, Conflict2 {\n-            @Override\n-            public String conflict() {\n-                return Conflict1.super.conflict() + Conflict2.super.conflict();\n-            }\n-        }\n-        assertThat(new C().conflict(), is(\"ab\"));\n-    }\n-\n-    private interface Conflict1 {\n-        default String conflict() {\n-            return \"a\";\n-        }\n-    }\n-\n-    private interface Conflict2 {\n-        default String conflict() {\n-            return \"b\";\n-        }\n-    }\n-\n-\n-    // Misc\n-\n-    @Test\n-    public void default_methods_calling_other_interface_methods() {\n-        CallOtherMethods obj = new CallOtherMethods() {\n-            @Override\n-            public int foo() {\n-                return 2;\n-            }\n-        };\n-        assertThat(obj.callsFoo(), is(12));\n-    }\n-\n-    private interface CallOtherMethods {\n-        int foo();\n-\n-        default int callsFoo() {\n-            return foo() + 10;\n-        }\n-    }\n-\n-    /**\n-     * Backporting default methods should not interact badly with backporting lambdas.\n-     */\n-    @Test\n-    public void lambdas_with_default_methods() {\n-        CallOtherMethods lambda = () -> 2;\n-        assertThat(lambda.foo(), is(2));\n-        assertThat(lambda.callsFoo(), is(12));\n-    }\n-\n-    @Test\n-    public void default_methods_with_lambdas() throws Exception {\n-        UsesLambdas obj = new UsesLambdas() {\n-        };\n-        assertThat(obj.stateless().call(), is(\"foo\"));\n-    }\n-\n-    @Test\n-    public void default_methods_with_lambdas_that_capture_this() throws Exception {\n-        UsesLambdas obj = new UsesLambdas() {\n-        };\n-        assertThat(obj.captureThis().call(), is(\"foo\"));\n-    }\n-\n-    private interface UsesLambdas {\n-        default Callable<String> stateless() {\n-            return () -> \"foo\";\n-        }\n-\n-        default Callable<String> captureThis() {\n-            return () -> stateless().call();\n-        }\n-    }\n-\n-    /**\n-     * Lambdas which capture this in default methods will generate the lambda implementation\n-     * method as a private <em>instance</em> method. We must avoid copying those methods to\n-     * the interface implementers as if they were default methods.\n-     */\n-    @Test\n-    public void default_methods_with_lambdas_in_another_package() throws Exception {\n-        assumeThat(SystemUtils.JAVA_VERSION_FLOAT, is(lessThan(1.8f)));\n-\n-        UsesLambdasInAnotherPackage obj = new UsesLambdasInAnotherPackage() {\n-        };\n-        assertThat(obj.stateless().call(), is(\"foo\"));\n-        assertThat(obj.captureThis().call(), is(\"foo\"));\n-        assertThat(\"should contain only delegates to the two default methods\",\n-                obj.getClass().getDeclaredMethods(), arrayWithSize(2));\n-    }\n-\n-    /**\n-     * Though we use {@link InMainSources}, because the Retrolambda Maven plugin\n-     * processes the main sources separately from the test sources, the effect is\n-     * the same as if they were in another module.\n-     */\n-    @Test\n-    public void calling_default_methods_from_another_module_through_interface() {\n-        InMainSources.Interface implementer = new InMainSources.Implementer();\n-        assertThat(implementer.defaultMethod(), is(\"default\"));\n-\n-        InMainSources.Interface overrider = new InMainSources.Overrider();\n-        assertThat(overrider.defaultMethod(), is(\"overridden\"));\n-    }\n-\n-    /**\n-     * Fixes issue of the generated delegate methods being marked as synthetic,\n-     * in which case the Java compiler causes \"error: cannot find symbol\"\n-     * for direct calls to those methods.\n-     */\n-    @Test\n-    public void calling_default_methods_from_another_module_through_class() {\n-        InMainSources.Implementer implementer = new InMainSources.Implementer();\n-        assertThat(implementer.defaultMethod(), is(\"default\"));\n-\n-        InMainSources.Overrider overrider = new InMainSources.Overrider();\n-        assertThat(overrider.defaultMethod(), is(\"overridden\"));\n-    }\n-\n-\n-    /**\n-     * We're unable to backport default methods if we cannot modify the interface,\n-     * e.g. if it's part of the standard library or a third-party library.\n-     */\n-    @Test\n-    public void default_methods_of_library_interfaces_are_ignored_silently() throws Exception {\n-        @SuppressWarnings(\"unchecked\") Iterator<String> dummy = mock(Iterator.class);\n-\n-        // the Iterable interface has default methods in Java 8, but that\n-        // should not prevent us from using it in previous Java versions\n-        Iterable<String> it = new Iterable<String>() {\n-            @Override\n-            public Iterator<String> iterator() {\n-                return dummy;\n-            }\n-        };\n-\n-        assertThat(\"interface should work as usual\", it.iterator(), is(dummy));\n-        assertThat(\"should not copy default methods from library interfaces\",\n-                it.getClass().getDeclaredMethods(), arrayWithSize(1));\n-    }\n-\n-    @Test\n-    public void trying_to_use_default_methods_of_library_interfaces_causes_NoSuchMethodError() {\n-        assumeThat(SystemUtils.JAVA_VERSION_FLOAT, is(lessThan(1.8f)));\n-\n-        class C implements Iterable<String> {\n-            @Override\n-            public Iterator<String> iterator() {\n-                return Collections.emptyIterator();\n-            }\n-        }\n-\n-        thrown.expect(NoSuchMethodError.class);\n-        thrown.expectMessage(\"spliterator\");\n-        // Called directly on the class (invokevirtual) instead of the interface (invokeinterface),\n-        // to make sure that no method was inserted to the class (in which case this call would not fail)\n-        new C().spliterator();\n-    }\n-\n-    /**\n-     * A naive method for removing method bodies would easily also remove their annotations,\n-     * because in ASM method annotations are expressed as calls on the MethodVisitor.\n-     */\n-    @Test\n-    @SuppressWarnings(\"unchecked\")\n-    public void keeps_annotations_on_interface_methods() throws Exception {\n-        assertThat(\"interface\", AnnotatedInterface.class.getAnnotations(),\n-                arrayContaining(someAnnotation(1)));\n-\n-        assertThat(\"abstract method\", AnnotatedInterface.class.getMethod(\"annotatedAbstractMethod\").getAnnotations(),\n-                arrayContaining(someAnnotation(2)));\n-\n-        assertThat(\"default method\", AnnotatedInterface.class.getMethod(\"annotatedDefaultMethod\").getAnnotations(),\n-                arrayContaining(someAnnotation(3)));\n-\n-        assumeThat(SystemUtils.JAVA_VERSION_FLOAT, is(lessThan(1.8f)));\n-        assertThat(\"static method\", companionOf(AnnotatedInterface.class).getMethod(\"annotatedStaticMethod\").getAnnotations(),\n-                arrayContaining(someAnnotation(4)));\n-    }\n-\n-    @SomeAnnotation(1)\n-    private interface AnnotatedInterface {\n-\n-        @SomeAnnotation(2)\n-        void annotatedAbstractMethod();\n-\n-        @SomeAnnotation(3)\n-        default void annotatedDefaultMethod() {\n-        }\n-\n-        @SomeAnnotation(4)\n-        static void annotatedStaticMethod() {\n-        }\n-    }\n-\n-    @Retention(value = RetentionPolicy.RUNTIME)\n-    private @interface SomeAnnotation {\n-        int value();\n-    }\n-\n-    private static Matcher<Annotation> someAnnotation(int value) {\n-        return new TypeSafeMatcher<Annotation>() {\n-            @Override\n-            protected boolean matchesSafely(Annotation item) {\n-                return item instanceof SomeAnnotation && ((SomeAnnotation) item).value() == value;\n-            }\n-\n-            @Override\n-            public void describeTo(Description description) {\n-                description.appendText(\"@SomeAnnotation(\" + value + \")\");\n-            }\n-        };\n-    }\n-}\n"
    },
    {
        "commit_hash": "790a9b2c73c309e190deba6657750c8525e1ea80",
        "previous_commit_hash": "806ac902ab3eae61ce8293f6bb9695d674a0b3c8",
        "diff_stats": {
            "additions": 0,
            "deletions": 41
        },
        "diff_content": "@@ -1,41 +0,0 @@\n-// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n-// This software is released under the Apache License 2.0.\n-// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n-\n-package net.orfjackal.retrolambda.test;\n-\n-import org.junit.Test;\n-\n-import static org.hamcrest.MatcherAssert.assertThat;\n-import static org.hamcrest.Matchers.is;\n-\n-public class InterfaceBridgeMethodsTest {\n-\n-    /**\n-     * JDK 8 adds a bridge method to an interface when it overrides a method\n-     * from the parent interface and refines its return type. This uses Java 8's\n-     * default methods feature, which won't work on Java 7 and below, so we have\n-     * to remove it for it - this makes the bytecode same as what JDK 7 produces.\n-     */\n-    @Test\n-    @SuppressWarnings(\"Convert2Lambda\")\n-    public void will_remove_bridge_methods_from_interfaces() {\n-        BridgeChild child = new BridgeChild() {\n-            @Override\n-            public String foo() {\n-                return \"foo\";\n-            }\n-        };\n-        assertThat(\"direct call\", child.foo(), is(\"foo\"));\n-        assertThat(\"bridged call\", ((BridgeParent) child).foo(), is((Object) \"foo\"));\n-    }\n-\n-    public interface BridgeParent {\n-        Object foo();\n-    }\n-\n-    public interface BridgeChild extends BridgeParent {\n-        @Override\n-        String foo(); // refined return type\n-    }\n-}\n"
    },
    {
        "commit_hash": "790a9b2c73c309e190deba6657750c8525e1ea80",
        "previous_commit_hash": "806ac902ab3eae61ce8293f6bb9695d674a0b3c8",
        "diff_stats": {
            "additions": 0,
            "deletions": 119
        },
        "diff_content": "@@ -1,119 +0,0 @@\n-// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n-// This software is released under the Apache License 2.0.\n-// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n-\n-package net.orfjackal.retrolambda.test;\n-\n-import org.apache.commons.lang.SystemUtils;\n-import org.junit.*;\n-import org.junit.rules.ExpectedException;\n-\n-import java.util.Comparator;\n-import java.util.concurrent.Callable;\n-import java.util.stream.Stream;\n-\n-import static net.orfjackal.retrolambda.test.TestUtil.*;\n-import static org.hamcrest.MatcherAssert.assertThat;\n-import static org.hamcrest.Matchers.*;\n-import static org.junit.Assume.assumeThat;\n-\n-@SuppressWarnings(\"Convert2MethodRef\")\n-public class InterfaceStaticMethodsTest {\n-\n-    @Rule\n-    public final ExpectedException thrown = ExpectedException.none();\n-\n-    @Test\n-    public void static_methods_on_interfaces() {\n-        assertThat(Interface.staticMethod(), is(42));\n-    }\n-\n-    @Test\n-    public void static_methods_on_interfaces_taking_arguments() {\n-        assertThat(Interface.staticMethodWithArgs(\"a\", 1, 2L), is(\"a12\"));\n-    }\n-\n-    @Test\n-    public void static_methods_on_interfaces_containing_lambdas() throws Exception {\n-        assertThat(Interface.staticMethodContainingLambdas(), is(123));\n-    }\n-\n-    @Test\n-    public void calling_static_methods_on_interfaces_from_default_methods() {\n-        Interface obj = new Interface() {\n-        };\n-        assertThat(obj.callStaticMethod(), is(42));\n-    }\n-\n-    @Test\n-    public void calling_static_methods_on_interfaces_from_lambdas() throws Exception {\n-        Callable<Integer> c = () -> Interface.staticMethod();\n-        assertThat(c.call(), is(42));\n-    }\n-\n-    @Test\n-    public void calling_static_methods_on_interfaces_from_method_references() throws Exception {\n-        Callable<Integer> c = Interface::staticMethod;\n-        assertThat(c.call(), is(42));\n-    }\n-\n-    private interface Interface {\n-        default int callStaticMethod() {\n-            return staticMethod();\n-        }\n-\n-        static int staticMethod() {\n-            return 42;\n-        }\n-\n-        // arguments of just a couple of different types because we're lazy\n-        static String staticMethodWithArgs(String s, int a, long b) {\n-            return s + a + b;\n-        }\n-\n-        static int staticMethodContainingLambdas() throws Exception {\n-            Callable<Integer> lambda = () -> 123;\n-            return lambda.call();\n-        }\n-    }\n-\n-    /**\n-     * Calling a {@code InterfaceMethodref} constant pool entry with {@code invokestatic}\n-     * is not allowed in Java 7 bytecode. It'll fail at class loading time with\n-     * \"VerifyError: Illegal type at constant pool entry\"\n-     */\n-    @Test\n-    public void calling_static_methods_of_library_interfaces__new_interface() {\n-        assumeThat(SystemUtils.JAVA_VERSION_FLOAT, is(lessThan(1.8f)));\n-\n-        thrown.expect(NoClassDefFoundError.class);\n-        thrown.expectMessage(\"java/util/stream/Stream\");\n-        // We don't want this call to prevent loading this whole test class,\n-        // it should only fail when this line is executed\n-        Stream.of(1, 2, 3);\n-    }\n-\n-    @Test\n-    public void calling_static_methods_of_library_interfaces__new_method_on_old_interface() {\n-        assumeThat(SystemUtils.JAVA_VERSION_FLOAT, is(lessThan(1.8f)));\n-\n-        thrown.expect(IncompatibleClassChangeError.class);\n-        thrown.expectMessage(SystemUtils.isJavaVersionAtLeast(1.6f)\n-                ? equalTo(\"Found interface java.util.Comparator, but class was expected\")\n-                : nullValue(String.class)); // on Java 5 there is no message\n-\n-        // We don't want this call to prevent loading this whole test class,\n-        // it should only fail when this line is executed\n-        Comparator.naturalOrder();\n-    }\n-\n-    @Test\n-    public void will_not_generate_a_companion_class_when_the_interface_has_just_constant_fields() {\n-        assertThat(InterfaceWithConstants.FOO, is(3));\n-        assertClassDoesNotExist(companionNameOf(InterfaceWithConstants.class));\n-    }\n-\n-    private interface InterfaceWithConstants {\n-        int FOO = (int) Math.sqrt(9); // a constant which needs to be calculated in a static initialization block\n-    }\n-}\n"
    },
    {
        "commit_hash": "790a9b2c73c309e190deba6657750c8525e1ea80",
        "previous_commit_hash": "806ac902ab3eae61ce8293f6bb9695d674a0b3c8",
        "diff_stats": {
            "additions": 0,
            "deletions": 47
        },
        "diff_content": "@@ -1,47 +0,0 @@\n-// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n-// This software is released under the Apache License 2.0.\n-// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n-\n-package net.orfjackal.retrolambda.test;\n-\n-import com.google.common.io.CharStreams;\n-import org.apache.commons.lang.SystemUtils;\n-import org.junit.Test;\n-\n-import java.io.*;\n-\n-import static org.hamcrest.MatcherAssert.assertThat;\n-import static org.hamcrest.Matchers.*;\n-\n-public class Java5BytecodeTest {\n-\n-    @Test\n-    public void does_not_generate_stack_map_tables_for_Java_5() throws IOException {\n-        String javapOutput = javap(Dummy.class);\n-\n-        if (SystemUtils.isJavaVersionAtLeast(1.6f)) {\n-            assertThat(javapOutput, containsString(\"StackMap\"));\n-        } else {\n-            assertThat(javapOutput, not(containsString(\"StackMap\")));\n-        }\n-    }\n-\n-    private static String javap(Class<?> aClass) throws IOException {\n-        Process process = new ProcessBuilder()\n-                .directory(TestEnv.testClassesDir)\n-                .command(\"javap\", \"-v\", \"-p\", aClass.getName())\n-                .redirectErrorStream(true)\n-                .start();\n-        return CharStreams.toString(new InputStreamReader(process.getInputStream()));\n-    }\n-\n-\n-    public static class Dummy {\n-        public Dummy() {\n-            // cause this method to have a stack map table\n-            for (int i = 0; i < 3; i++) {\n-                System.out.println(i);\n-            }\n-        }\n-    }\n-}\n"
    },
    {
        "commit_hash": "790a9b2c73c309e190deba6657750c8525e1ea80",
        "previous_commit_hash": "806ac902ab3eae61ce8293f6bb9695d674a0b3c8",
        "diff_stats": {
            "additions": 0,
            "deletions": 99
        },
        "diff_content": "@@ -1,99 +0,0 @@\n-// Copyright \u00a9 2013-2016 Esko Luontola and other Retrolambda contributors\n-// This software is released under the Apache License 2.0.\n-// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n-\n-package net.orfjackal.retrolambda.test;\n-\n-import com.google.common.collect.ImmutableSet;\n-import org.junit.Test;\n-\n-import java.lang.reflect.Method;\n-import java.util.*;\n-\n-import static net.orfjackal.retrolambda.test.TestUtil.assertClassExists;\n-import static org.hamcrest.MatcherAssert.assertThat;\n-import static org.hamcrest.Matchers.*;\n-\n-public class LambdaClassesTest {\n-\n-    @Test\n-    public void the_sequence_number_starts_from_1_for_each_enclosing_class() {\n-        assertClassExists(Dummy1.class.getName() + \"$$Lambda$1\");\n-        assertClassExists(Dummy1.class.getName() + \"$$Lambda$2\");\n-        assertClassExists(Dummy2.class.getName() + \"$$Lambda$1\");\n-        assertClassExists(Dummy2.class.getName() + \"$$Lambda$2\");\n-    }\n-\n-    @SuppressWarnings(\"UnusedDeclaration\")\n-    private class Dummy1 {\n-        private Dummy1() {\n-            Runnable lambda1 = () -> {\n-            };\n-            Runnable lambda2 = () -> {\n-            };\n-        }\n-    }\n-\n-    @SuppressWarnings(\"UnusedDeclaration\")\n-    private class Dummy2 {\n-        private Dummy2() {\n-            Runnable lambda1 = () -> {\n-            };\n-            Runnable lambda2 = () -> {\n-            };\n-        }\n-    }\n-\n-\n-    @Test\n-    public void capturing_lambda_classes_contain_no_unnecessary_methods() throws ClassNotFoundException {\n-        assertThat(getMethodsNames(findLambdaClass(Capturing.class)),\n-                is(ImmutableSet.of(\"lambdaFactory$\", \"run\")));\n-    }\n-\n-    @SuppressWarnings(\"UnusedDeclaration\")\n-    private class Capturing {\n-        private Capturing() {\n-            Runnable lambda = () -> System.out.println(hashCode());\n-        }\n-    }\n-\n-\n-    @Test\n-    public void non_capturing_lambda_classes_contain_no_unnecessary_methods() throws ClassNotFoundException {\n-        assertThat(getMethodsNames(findLambdaClass(NonCapturing.class)),\n-                is(ImmutableSet.of(\"lambdaFactory$\", \"run\")));\n-    }\n-\n-    @SuppressWarnings(\"UnusedDeclaration\")\n-    private class NonCapturing {\n-        private NonCapturing() {\n-            Runnable lambda = () -> {\n-            };\n-        }\n-    }\n-\n-\n-    @Test\n-    public void enclosing_classes_contain_no_unnecessary_methods_in_addition_to_the_lambda_body() throws ClassNotFoundException {\n-        assertThat(\"non-capturing lambda\", getMethodsNames(NonCapturing.class), contains(startsWith(\"lambda$new$\")));\n-        assertThat(\"capturing lambda\", getMethodsNames(Capturing.class), contains(startsWith(\"lambda$new$\")));\n-    }\n-\n-\n-    // helpers\n-\n-    private static Class<?> findLambdaClass(Class<?> clazz) throws ClassNotFoundException {\n-        return Class.forName(clazz.getName() + \"$$Lambda$1\");\n-    }\n-\n-    private static Set<String> getMethodsNames(Class<?> clazz) {\n-        Method[] methods = clazz.getDeclaredMethods();\n-        Set<String> uniqueNames = new HashSet<>();\n-        for (Method method : methods) {\n-            uniqueNames.add(method.getName());\n-        }\n-        assertThat(\"unexpected overloaded methods\", methods, arrayWithSize(uniqueNames.size()));\n-        return uniqueNames;\n-    }\n-}\n"
    },
    {
        "commit_hash": "790a9b2c73c309e190deba6657750c8525e1ea80",
        "previous_commit_hash": "806ac902ab3eae61ce8293f6bb9695d674a0b3c8",
        "diff_stats": {
            "additions": 0,
            "deletions": 341
        },
        "diff_content": "@@ -1,341 +0,0 @@\n-// Copyright \u00a9 2013-2016 Esko Luontola <www.orfjackal.net>\n-// This software is released under the Apache License 2.0.\n-// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n-\n-package net.orfjackal.retrolambda.test;\n-\n-import net.orfjackal.retrolambda.test.anotherpackage.DifferentPackageBase;\n-import org.apache.commons.lang.SystemUtils;\n-import org.junit.Test;\n-import org.objectweb.asm.*;\n-import org.objectweb.asm.Type;\n-\n-import java.io.IOException;\n-import java.lang.reflect.*;\n-import java.util.*;\n-import java.util.concurrent.Callable;\n-\n-import static org.hamcrest.MatcherAssert.assertThat;\n-import static org.hamcrest.Matchers.*;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assume.assumeThat;\n-\n-public class LambdaTest extends SuperClass {\n-\n-    @Test\n-    public void empty_lambda() {\n-        Runnable lambda = () -> {\n-        };\n-\n-        lambda.run();\n-    }\n-\n-    @Test\n-    public void lambda_returning_a_value() throws Exception {\n-        Callable<String> lambda = () -> \"some value\";\n-\n-        assertThat(lambda.call(), is(\"some value\"));\n-    }\n-\n-    private interface Function1<IN, OUT> {\n-        OUT apply(IN value);\n-    }\n-\n-    @Test\n-    public void lambda_taking_parameters() {\n-        Function1<String, Integer> lambda = (String s) -> s.getBytes().length;\n-\n-        assertThat(lambda.apply(\"foo\"), is(3));\n-    }\n-\n-    @Test\n-    public void lambda_in_project_main_sources() throws Exception {\n-        assertThat(InMainSources.callLambda(), is(42));\n-    }\n-\n-    private int instanceVar = 0;\n-\n-    @Test\n-    public void lambda_using_instance_variables() {\n-        Runnable lambda = () -> {\n-            instanceVar = 42;\n-        };\n-        lambda.run();\n-\n-        assertThat(instanceVar, is(42));\n-    }\n-\n-    @Test\n-    public void lambda_using_local_variables() {\n-        int[] localVar = new int[1];\n-        Runnable lambda = () -> {\n-            localVar[0] = 42;\n-        };\n-        lambda.run();\n-\n-        assertThat(localVar[0], is(42));\n-    }\n-\n-    @Test\n-    public void lambda_using_local_variables_of_primitive_types() throws Exception {\n-        boolean bool = true;\n-        byte b = 2;\n-        short s = 3;\n-        int i = 4;\n-        long l = 5;\n-        float f = 6;\n-        double d = 7;\n-        char c = 8;\n-        Callable<Integer> lambda = () -> (int) ((bool ? 1 : 0) + b + s + i + l + f + d + c);\n-\n-        assertThat(lambda.call(), is(36));\n-    }\n-\n-    @Test\n-    public void lambda_in_the_constant_initializer_of_an_interface() throws Exception {\n-        assertThat(LambdaConstant.LAMBDA.call(), is(\"foo\"));\n-    }\n-\n-    public interface LambdaConstant {\n-        Callable<String> LAMBDA = () -> \"foo\";\n-    }\n-\n-    @Test\n-    public void lambdas_with_marker_interfaces_due_to_intersection_types() throws Exception {\n-        // We must use something other than java.io.Serializable as the marker interface,\n-        // because serializable lambdas are signified by a flag to LambdaMetafactory.altMetafactory\n-        Callable<String> lambda = (Callable<String> & Cloneable) () -> \"foo\";\n-\n-        assertThat(lambda, is(instanceOf(Cloneable.class)));\n-        assertThat(lambda.call(), is(\"foo\"));\n-    }\n-\n-    @Test\n-    public void method_references_to_virtual_methods_on_local_variables() throws Exception {\n-        String foo = \"foo\";\n-        Callable<String> ref = foo::toUpperCase;\n-\n-        assertThat(ref.call(), is(\"FOO\"));\n-    }\n-\n-    @Test\n-    public void method_references_to_virtual_methods_on_instance_variables() throws Exception {\n-        Callable<String> ref = instanceVarFoo::toUpperCase;\n-\n-        assertThat(ref.call(), is(\"FOO\"));\n-    }\n-\n-    @SuppressWarnings(\"FieldCanBeLocal\")\n-    private String instanceVarFoo = \"foo\";\n-\n-    @Test\n-    public void method_references_to_interface_methods() throws Exception {\n-        List<String> foos = Arrays.asList(\"foo\");\n-        Callable<Integer> ref = foos::size;\n-\n-        assertThat(ref.call(), is(1));\n-    }\n-\n-    @Test\n-    public void method_references_to_static_methods() throws Exception {\n-        long expected = System.currentTimeMillis();\n-        Callable<Long> ref = System::currentTimeMillis;\n-\n-        assertThat(ref.call(), is(greaterThanOrEqualTo(expected)));\n-    }\n-\n-    @Test\n-    public void method_references_to_constructors() throws Exception {\n-        Callable<List<String>> ref = ArrayList<String>::new;\n-\n-        assertThat(ref.call(), is(instanceOf(ArrayList.class)));\n-    }\n-\n-    @Test\n-    public void method_references_to_protected_supertype_methods() throws Exception {\n-        Callable<String> ref1 = new SubclassInMyPackage().thing();\n-        assertThat(ref1.call(), equalTo(\"Hello\"));\n-\n-        Callable<String> ref2 = new SubclassInSamePackage().thing();\n-        assertThat(ref2.call(), equalTo(\"Hello\"));\n-    }\n-\n-    public static class SubclassInMyPackage extends DifferentPackageBase {\n-        public Callable<String> thing() {\n-            return DifferentPackageBase::value;\n-        }\n-    }\n-\n-    public static class SubclassInSamePackage extends SamePackageBase {\n-        public Callable<String> thing() {\n-            return SamePackageBase::value;\n-        }\n-    }\n-\n-    /**\n-     * Because the constructor is private, an access method must be generated for it\n-     * and also the NEW instruction must be done inside the access method.\n-     */\n-    @Test\n-    public void method_references_to_private_constructors() throws Exception {\n-        Callable<HasPrivateConstructor> factory = HasPrivateConstructor.factory();\n-        assertThat(factory.call(), is(instanceOf(HasPrivateConstructor.class)));\n-\n-        HasPrivateConstructorWithArgs.Factory factoryArgs = HasPrivateConstructorWithArgs.factory();\n-        assertThat(factoryArgs.create(\"args\"), is(instanceOf(HasPrivateConstructorWithArgs.class)));\n-        assertThat(factoryArgs.create(\"args\").args, is(\"args\"));\n-    }\n-\n-    public static class HasPrivateConstructor {\n-\n-        private HasPrivateConstructor() {\n-        }\n-\n-        public static Callable<HasPrivateConstructor> factory() {\n-            return HasPrivateConstructor::new;\n-        }\n-    }\n-\n-    public static class HasPrivateConstructorWithArgs {\n-        public final String args;\n-\n-        private HasPrivateConstructorWithArgs(String args) {\n-            this.args = args;\n-        }\n-\n-        public static Factory factory() {\n-            return HasPrivateConstructorWithArgs::new;\n-        }\n-\n-        public interface Factory {\n-            HasPrivateConstructorWithArgs create(String args);\n-        }\n-    }\n-\n-\n-    @Test\n-    public void method_references_to_overridden_inherited_methods_with_super() throws Exception {\n-        Callable<String> ref = super::inheritedMethod;\n-\n-        assertThat(ref.call(), is(\"superclass version\"));\n-    }\n-\n-    @Override\n-    String inheritedMethod() {\n-        return \"overridden version\";\n-    }\n-\n-    @Test\n-    public void method_references_to_private_methods() throws Exception {\n-        Callable<String> ref1 = LambdaTest::privateClassMethod;\n-        assertThat(ref1.call(), is(\"foo\"));\n-\n-        Callable<String> ref2 = this::privateInstanceMethod;\n-        assertThat(ref2.call(), is(\"foo\"));\n-\n-        // Normal method calls should still work after our magic\n-        // of making them them accessible from the lambda classes.\n-        assertThat(privateClassMethod(), is(\"foo\"));\n-        assertThat(privateInstanceMethod(), is(\"foo\"));\n-    }\n-\n-    private String privateInstanceMethod() {\n-        return \"foo\";\n-    }\n-\n-    private static String privateClassMethod() {\n-        return \"foo\";\n-    }\n-\n-    /**\n-     * We could make private lambda implementation methods package-private,\n-     * so that the lambda class may call them, but we should not make any\n-     * more methods non-private than is absolutely necessary.\n-     */\n-    @Test\n-    public void will_not_change_the_visibility_of_unrelated_methods() throws Exception {\n-        assertThat(unrelatedPrivateMethod(), is(\"foo\"));\n-\n-        Method method = getClass().getDeclaredMethod(\"unrelatedPrivateMethod\");\n-        int modifiers = method.getModifiers();\n-\n-        assertTrue(\"expected \" + method.getName() + \" to be private, but modifiers were: \" + Modifier.toString(modifiers),\n-                Modifier.isPrivate(modifiers));\n-    }\n-\n-    private String unrelatedPrivateMethod() {\n-        return \"foo\";\n-    }\n-\n-    /**\n-     * We cannot just make the private methods package-private for the\n-     * lambda class to call them, because that may cause a method in subclass\n-     * to override them.\n-     */\n-    @Test\n-    public void will_not_cause_private_methods_to_be_overridable() throws Exception {\n-        class Parent {\n-            private String privateMethod() {\n-                return \"parent version\";\n-            }\n-\n-            Callable<String> parentRef() {\n-                return this::privateMethod;\n-            }\n-        }\n-        class Child extends Parent {\n-            private String privateMethod() { // would override if were not private\n-                return \"child version\";\n-            }\n-\n-            Callable<String> childRef() {\n-                return this::privateMethod;\n-            }\n-        }\n-\n-        Child child = new Child();\n-\n-        // Our test assumes that there exists a private method with\n-        // the same name and signature in super and sub classes.\n-        String name = \"privateMethod\";\n-        assertThat(child.getClass().getDeclaredMethod(name), is(notNullValue()));\n-        assertThat(child.getClass().getSuperclass().getDeclaredMethod(name), is(notNullValue()));\n-\n-        assertThat(child.privateMethod(), is(\"child version\"));\n-        assertThat(child.childRef().call(), is(\"child version\"));\n-\n-        assertThat(((Parent) child).privateMethod(), is(\"parent version\"));\n-        assertThat(child.parentRef().call(), is(\"parent version\"));\n-    }\n-\n-    @Test\n-    public void bytecode_constant_pool_will_not_contain_dangling_references_to_MethodHandles() throws IOException {\n-        assumeThat(SystemUtils.JAVA_VERSION_FLOAT, is(lessThan(1.7f)));\n-\n-        ClassReader cr = new ClassReader(getClass().getName().replace('.', '/'));\n-        char[] buf = new char[cr.getMaxStringLength()];\n-\n-        for (int item = 0; item < cr.getItemCount(); item++) {\n-            Object constant = readConstant(item, buf, cr);\n-            if (constant instanceof Type) {\n-                Type type = (Type) constant;\n-                assertThat(\"constant #\" + item, type.getDescriptor(), not(containsString(\"java/lang/invoke\")));\n-            }\n-        }\n-    }\n-\n-    private static Object readConstant(int item, char[] buf, ClassReader cr) {\n-        try {\n-            return cr.readConst(item, buf);\n-        } catch (Exception e) {\n-            // XXX: constant pool entry which is a Methodref, InvokeDynamic or similar non-plain constant\n-            return null;\n-        }\n-    }\n-}\n-\n-class SuperClass {\n-    String inheritedMethod() {\n-        return \"superclass version\";\n-    }\n-}\n"
    },
    {
        "commit_hash": "790a9b2c73c309e190deba6657750c8525e1ea80",
        "previous_commit_hash": "806ac902ab3eae61ce8293f6bb9695d674a0b3c8",
        "diff_stats": {
            "additions": 0,
            "deletions": 40
        },
        "diff_content": "@@ -1,40 +0,0 @@\n-// Copyright \u00a9 2013 Esko Luontola <www.orfjackal.net>\n-// This software is released under the Apache License 2.0.\n-// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n-\n-package net.orfjackal.retrolambda.test;\n-\n-import org.junit.Test;\n-\n-import java.util.concurrent.Callable;\n-\n-import static org.hamcrest.MatcherAssert.assertThat;\n-import static org.hamcrest.Matchers.*;\n-\n-public class OptimizationsTest {\n-\n-    @Test\n-    public void lambdas_which_capture_variables_get_a_new_instance_every_time() {\n-        Callable<Integer> lambda1 = createStatefulLambda();\n-        Callable<Integer> lambda2 = createStatefulLambda();\n-\n-        assertThat(lambda1, is(not(sameInstance(lambda2))));\n-    }\n-\n-    private static Callable<Integer> createStatefulLambda() {\n-        int i = 42;\n-        return () -> i;\n-    }\n-\n-    @Test\n-    public void lambdas_which_do_not_capture_variables_have_only_one_singleton_instance() {\n-        Callable<Integer> lambda1 = createStatelessLambda();\n-        Callable<Integer> lambda2 = createStatelessLambda();\n-\n-        assertThat(lambda1, is(sameInstance(lambda2)));\n-    }\n-\n-    private static Callable<Integer> createStatelessLambda() {\n-        return () -> 42;\n-    }\n-}\n"
    },
    {
        "commit_hash": "790a9b2c73c309e190deba6657750c8525e1ea80",
        "previous_commit_hash": "806ac902ab3eae61ce8293f6bb9695d674a0b3c8",
        "diff_stats": {
            "additions": 0,
            "deletions": 56
        },
        "diff_content": "@@ -1,56 +0,0 @@\n-// Copyright \u00a9 2013-2016 Esko Luontola and other Retrolambda contributors\n-// This software is released under the Apache License 2.0.\n-// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n-\n-package net.orfjackal.retrolambda.test;\n-\n-import org.junit.Test;\n-\n-import java.util.Objects;\n-\n-import static org.hamcrest.MatcherAssert.assertThat;\n-import static org.hamcrest.Matchers.*;\n-\n-public class RequireNonNullTest {\n-\n-    @Test\n-    public void requireNonNull__silent_when_non_null() {\n-        Objects.requireNonNull(new Object());\n-    }\n-\n-\n-    @Test(expected = NullPointerException.class)\n-    public void requireNonNull__throws_NPE_when_null() {\n-        Objects.requireNonNull(null);\n-    }\n-\n-    @Test\n-    public void requireNonNull__returns_the_argument() {\n-        Object expected = new Object();\n-\n-        Object actual = Objects.requireNonNull(expected);\n-\n-        assertThat(actual, is(sameInstance(expected)));\n-    }\n-\n-    @Test\n-    public void synthetic_null_check__silent_when_non_null() {\n-        syntheticNullCheck(new MaybeNull());\n-    }\n-\n-    @Test(expected = NullPointerException.class)\n-    public void synthetic_null_check__throws_NPE_when_null() {\n-        syntheticNullCheck(null);\n-    }\n-\n-    @SuppressWarnings(\"unused\")\n-    private static void syntheticNullCheck(MaybeNull maybeNull) {\n-        // Javac knows that the `foo` field is constant 0, so it generates a null check and the `iconst_0` instruction.\n-        // The null check is a `obj.getClass()` call on older JDKs and `Objects.requireNonNull(obj)` on JDK 9 and above.\n-        int foo = maybeNull.foo;\n-    }\n-\n-    private static class MaybeNull {\n-        final int foo = 0;\n-    }\n-}\n"
    },
    {
        "commit_hash": "790a9b2c73c309e190deba6657750c8525e1ea80",
        "previous_commit_hash": "806ac902ab3eae61ce8293f6bb9695d674a0b3c8",
        "diff_stats": {
            "additions": 0,
            "deletions": 11
        },
        "diff_content": "@@ -1,11 +0,0 @@\n-// Copyright \u00a9 2013-2016 Esko Luontola <www.orfjackal.net>\n-// This software is released under the Apache License 2.0.\n-// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n-\n-package net.orfjackal.retrolambda.test;\n-\n-public class SamePackageBase {\n-    protected static String value() {\n-        return \"Hello\";\n-    }\n-}\n"
    },
    {
        "commit_hash": "790a9b2c73c309e190deba6657750c8525e1ea80",
        "previous_commit_hash": "806ac902ab3eae61ce8293f6bb9695d674a0b3c8",
        "diff_stats": {
            "additions": 0,
            "deletions": 64
        },
        "diff_content": "@@ -1,64 +0,0 @@\n-// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n-// This software is released under the Apache License 2.0.\n-// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n-\n-package net.orfjackal.retrolambda.test;\n-\n-import org.junit.Test;\n-\n-import java.io.*;\n-\n-import static org.hamcrest.MatcherAssert.assertThat;\n-import static org.hamcrest.Matchers.is;\n-\n-public class SerializableLambdaTest {\n-\n-    @Test\n-    public void serializable_interface() throws Exception {\n-        SerializableFoo original = (i) -> i + 10;\n-\n-        SerializableFoo serialized = roundTripSerialize(original);\n-\n-        assertThat(serialized.foo(4), is(14));\n-    }\n-\n-    @Test\n-    public void cast_expression_with_serializable_additional_bound() throws Exception {\n-        Foo original = (Foo & Serializable) (i) -> i + 20;\n-\n-        Foo serialized = roundTripSerialize(original);\n-\n-        assertThat(serialized.foo(4), is(24));\n-    }\n-\n-    @Test\n-    public void captured_local_variables() throws Exception {\n-        int var = 30;\n-        SerializableFoo original = (i) -> i + var;\n-\n-        SerializableFoo serialized = roundTripSerialize(original);\n-\n-        assertThat(serialized.foo(4), is(34));\n-    }\n-\n-\n-    // guinea pigs & helpers\n-\n-    public interface Foo {\n-        int foo(int i);\n-    }\n-\n-    public interface SerializableFoo extends Foo, Serializable {\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private static <T> T roundTripSerialize(T original) throws Exception {\n-        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n-        try (ObjectOutputStream out = new ObjectOutputStream(buffer)) {\n-            out.writeObject(original);\n-        }\n-        try (ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()))) {\n-            return (T) in.readObject();\n-        }\n-    }\n-}\n"
    },
    {
        "commit_hash": "790a9b2c73c309e190deba6657750c8525e1ea80",
        "previous_commit_hash": "806ac902ab3eae61ce8293f6bb9695d674a0b3c8",
        "diff_stats": {
            "additions": 0,
            "deletions": 23
        },
        "diff_content": "@@ -1,23 +0,0 @@\n-// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n-// This software is released under the Apache License 2.0.\n-// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n-\n-package net.orfjackal.retrolambda.test;\n-\n-import java.io.*;\n-import java.util.Properties;\n-\n-public class TestEnv {\n-\n-    public static final File testClassesDir;\n-\n-    static {\n-        Properties p = new Properties();\n-        try (InputStream in = TestEnv.class.getResourceAsStream(\"/testing.properties\")) {\n-            p.load(in);\n-        } catch (IOException e) {\n-            throw new RuntimeException(e);\n-        }\n-        testClassesDir = new File(p.getProperty(\"testClassesDir\"));\n-    }\n-}\n"
    },
    {
        "commit_hash": "790a9b2c73c309e190deba6657750c8525e1ea80",
        "previous_commit_hash": "806ac902ab3eae61ce8293f6bb9695d674a0b3c8",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>2.3.0</version>\n+    <version>2.3.1-SNAPSHOT</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "790a9b2c73c309e190deba6657750c8525e1ea80",
        "previous_commit_hash": "806ac902ab3eae61ce8293f6bb9695d674a0b3c8",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.3.0</version>\n+        <version>2.3.1-SNAPSHOT</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "790a9b2c73c309e190deba6657750c8525e1ea80",
        "previous_commit_hash": "806ac902ab3eae61ce8293f6bb9695d674a0b3c8",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.3.0</version>\n+        <version>2.3.1-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "790a9b2c73c309e190deba6657750c8525e1ea80",
        "previous_commit_hash": "806ac902ab3eae61ce8293f6bb9695d674a0b3c8",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.3.0</version>\n+        <version>2.3.1-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "93ff6adb29732dc267401dd521bbab51a1fa40d0",
        "previous_commit_hash": "790a9b2c73c309e190deba6657750c8525e1ea80",
        "diff_stats": {
            "additions": 3,
            "deletions": 0
        },
        "diff_content": "@@ -9,7 +9,10 @@\n       <sourceFolder url=\"file://$MODULE_DIR$/src/main/java\" isTestSource=\"false\" />\n       <sourceFolder url=\"file://$MODULE_DIR$/src/test/java\" isTestSource=\"true\" />\n       <excludeFolder url=\"file://$MODULE_DIR$/target/antrun\" />\n+      <excludeFolder url=\"file://$MODULE_DIR$/target/apidocs\" />\n       <excludeFolder url=\"file://$MODULE_DIR$/target/classes\" />\n+      <excludeFolder url=\"file://$MODULE_DIR$/target/invoker\" />\n+      <excludeFolder url=\"file://$MODULE_DIR$/target/javadoc-bundle-options\" />\n       <excludeFolder url=\"file://$MODULE_DIR$/target/maven-archiver\" />\n       <excludeFolder url=\"file://$MODULE_DIR$/target/maven-status\" />\n       <excludeFolder url=\"file://$MODULE_DIR$/target/surefire-reports\" />\n"
    },
    {
        "commit_hash": "f0eea0d588bc8850e1e0d79ee5e8543669b79d32",
        "previous_commit_hash": "93ff6adb29732dc267401dd521bbab51a1fa40d0",
        "diff_stats": {
            "additions": 19,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,19 @@\n+// Copyright \u00a9 2013-2016 Esko Luontola and other Retrolambda contributors\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+import org.junit.Test;\n+\n+public final class DefaultPackageTest {\n+    @Test\n+    public void method_reference_to_sibling_class() {\n+        SiblingClass sibling = new SiblingClass();\n+        Runnable lambda = sibling::method;\n+        lambda.run();\n+    }\n+}\n+\n+class SiblingClass {\n+    void method() {\n+    }\n+}\n"
    },
    {
        "commit_hash": "f0eea0d588bc8850e1e0d79ee5e8543669b79d32",
        "previous_commit_hash": "93ff6adb29732dc267401dd521bbab51a1fa40d0",
        "diff_stats": {
            "additions": 6,
            "deletions": 2
        },
        "diff_content": "@@ -104,8 +104,12 @@ public class BackportLambdaInvocations extends ClassVisitor {\n     }\n \n     private boolean isNonOwnedMethodVisible(Handle implMethod) {\n-        String classPackage = className.substring(0, className.lastIndexOf('/'));\n-        String implPackage = implMethod.getOwner().substring(0, implMethod.getOwner().lastIndexOf('/'));\n+        int classNameLastSlash = className.lastIndexOf('/');\n+        String classPackage = classNameLastSlash == -1 ? \"\" : className.substring(0, classNameLastSlash);\n+\n+        int implMethodLastSlash = implMethod.getOwner().lastIndexOf('/');\n+        String implPackage = implMethodLastSlash == -1 ? \"\" : implMethod.getOwner().substring(0, implMethodLastSlash);\n+\n         if (classPackage.equals(implPackage)) {\n             return true; // All method visibilities in the same package will be visible.\n         }\n"
    },
    {
        "commit_hash": "fa0f5a5480c53613b663f3e7d13c0c0401867365",
        "previous_commit_hash": "93ff6adb29732dc267401dd521bbab51a1fa40d0",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -79,7 +79,7 @@\n             <plugin>\n                 <artifactId>maven-surefire-plugin</artifactId>\n                 <configuration>\n-                    <skipTests>true</skipTests>\n+                    <skipTests>false</skipTests>\n                 </configuration>\n             </plugin>\n \n"
    },
    {
        "commit_hash": "fa0f5a5480c53613b663f3e7d13c0c0401867365",
        "previous_commit_hash": "93ff6adb29732dc267401dd521bbab51a1fa40d0",
        "diff_stats": {
            "additions": 29,
            "deletions": 0
        },
        "diff_content": "@@ -8,6 +8,7 @@ import com.google.common.collect.ImmutableSet;\n import org.junit.Test;\n \n import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n import java.util.*;\n \n import static net.orfjackal.retrolambda.test.TestUtil.assertClassExists;\n@@ -80,6 +81,34 @@ public class LambdaClassesTest {\n         assertThat(\"capturing lambda\", getMethodsNames(Capturing.class), contains(startsWith(\"lambda$new$\")));\n     }\n \n+    private class Parent {\n+        protected void foo() {\n+            Runnable lambda = () -> {\n+                System.out.println(\"parent\");\n+            };\n+        }\n+    }\n+\n+    private class Child extends Parent {\n+        @Override\n+        protected void foo() {\n+            super.foo();\n+            Runnable lambda = () -> {\n+                System.out.println(\"child\");\n+            };\n+        }\n+    }\n+\n+    @Test\n+    public void child_class_lambda_doesnt_hide_parent_class_lambda() {\n+        Method[] methods = Child.class.getDeclaredMethods();\n+        Set<String> parentMethods = getMethodsNames(Parent.class);\n+        for (Method method : methods) {\n+            if (method.getName().startsWith(\"lambda$\") && !Modifier.isPrivate(method.getModifiers())) {\n+                assertThat(\"child lambda \" + method.getName() + \" overrides parent\", parentMethods, not(hasItem(method.getName())));\n+            }\n+        }\n+    }\n \n     // helpers\n \n"
    },
    {
        "commit_hash": "567328d58ec33ab55bae05bc2e640aba3f629f13",
        "previous_commit_hash": "93ff6adb29732dc267401dd521bbab51a1fa40d0",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -30,7 +30,7 @@ public class ClassInfo {\n         this.reader = cr;\n         this.access = cr.getAccess();\n         this.type = Type.getObjectType(cr.getClassName());\n-        this.superclass = Type.getObjectType(cr.getSuperName());\n+        this.superclass = cr.getSuperName() != null ? Type.getObjectType(cr.getSuperName()) : null;\n         for (String iface : cr.getInterfaces()) {\n             this.interfaces.add(Type.getObjectType(iface));\n         }\n"
    },
    {
        "commit_hash": "15ee363dd9639dc321d4e080bdc527fc2aaac620",
        "previous_commit_hash": "93ff6adb29732dc267401dd521bbab51a1fa40d0",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -116,6 +116,7 @@ public class Transformers {\n             if (targetVersion < Opcodes.V1_7) {\n                 next = new SwallowSuppressedExceptions(next);\n                 next = new RemoveMethodHandlesLookupReferences(next);\n+                next = new RemoveLambdaHiddenReferences(next);\n                 next = new RequireNonNull(next);\n             }\n             next = new FixInvokeStaticOnInterfaceMethod(next);\n"
    },
    {
        "commit_hash": "15ee363dd9639dc321d4e080bdc527fc2aaac620",
        "previous_commit_hash": "93ff6adb29732dc267401dd521bbab51a1fa40d0",
        "diff_stats": {
            "additions": 31,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,31 @@\n+// Copyright \u00a9 2013-2016 Esko Luontola and other Retrolambda contributors\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.lambdas;\n+\n+import org.objectweb.asm.*;\n+\n+import static org.objectweb.asm.Opcodes.ASM5;\n+\n+public class RemoveLambdaHiddenReferences extends ClassVisitor {\n+\n+    private static final String LAMBDA_FORM_HIDDEN_NAME = \"Ljava/lang/invoke/LambdaForm$Hidden;\";\n+\n+    public RemoveLambdaHiddenReferences(ClassVisitor next) {\n+        super(ASM5, next);\n+    }\n+\n+    @Override\n+    public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+        return new MethodVisitor(ASM5, super.visitMethod(access, name, desc, signature, exceptions)) {\n+            @Override\n+            public AnnotationVisitor visitAnnotation(String desc, boolean visible) {\n+                if (LAMBDA_FORM_HIDDEN_NAME.equals(desc)) {\n+                    return null;\n+                }\n+                return super.visitAnnotation(desc, visible);\n+            }\n+        };\n+    }\n+}\n"
    },
    {
        "commit_hash": "cc74b75b49f2a3bc44753cdcb2765021d7e3b599",
        "previous_commit_hash": "14da0999e07fc6488c88764ea881f211582f545f",
        "diff_stats": {
            "additions": 3,
            "deletions": 0
        },
        "diff_content": "@@ -24,6 +24,9 @@\n         <option name=\"WHILE_BRACE_FORCE\" value=\"3\" />\n         <option name=\"FOR_BRACE_FORCE\" value=\"3\" />\n         <option name=\"FIELD_ANNOTATION_WRAP\" value=\"0\" />\n+        <MarkdownNavigatorCodeStyleSettings>\n+          <option name=\"RIGHT_MARGIN\" value=\"72\" />\n+        </MarkdownNavigatorCodeStyleSettings>\n         <XML>\n           <option name=\"XML_LEGACY_SETTINGS_IMPORTED\" value=\"true\" />\n         </XML>\n"
    },
    {
        "commit_hash": "cc74b75b49f2a3bc44753cdcb2765021d7e3b599",
        "previous_commit_hash": "14da0999e07fc6488c88764ea881f211582f545f",
        "diff_stats": {
            "additions": 4,
            "deletions": 4
        },
        "diff_content": "@@ -1,13 +1,13 @@\n <component name=\"libraryTable\">\n-  <library name=\"Maven: org.ow2.asm:asm-debug-all:5.1\">\n+  <library name=\"Maven: org.ow2.asm:asm-debug-all:5.2\">\n     <CLASSES>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm-debug-all/5.1/asm-debug-all-5.1.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm-debug-all/5.2/asm-debug-all-5.2.jar!/\" />\n     </CLASSES>\n     <JAVADOC>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm-debug-all/5.1/asm-debug-all-5.1-javadoc.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm-debug-all/5.2/asm-debug-all-5.2-javadoc.jar!/\" />\n     </JAVADOC>\n     <SOURCES>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm-debug-all/5.1/asm-debug-all-5.1-sources.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm-debug-all/5.2/asm-debug-all-5.2-sources.jar!/\" />\n     </SOURCES>\n   </library>\n </component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "cc74b75b49f2a3bc44753cdcb2765021d7e3b599",
        "previous_commit_hash": "14da0999e07fc6488c88764ea881f211582f545f",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -14,7 +14,7 @@\n     <orderEntry type=\"library\" name=\"Maven: com.google.guava:guava:11.0.2\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: com.google.code.findbugs:jsr305:1.3.9\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: commons-lang:commons-lang:2.6\" level=\"project\" />\n-    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.ow2.asm:asm-debug-all:5.1\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.ow2.asm:asm-debug-all:5.2\" level=\"project\" />\n     <orderEntry type=\"module-library\">\n       <library name=\"Maven: net.orfjackal.retrolambda:java-lang-dummies:1\">\n         <CLASSES>\n"
    },
    {
        "commit_hash": "cc74b75b49f2a3bc44753cdcb2765021d7e3b599",
        "previous_commit_hash": "14da0999e07fc6488c88764ea881f211582f545f",
        "diff_stats": {
            "additions": 3,
            "deletions": 15
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013-2016 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2017 Esko Luontola and other Retrolambda contributors\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -313,24 +313,12 @@ public class LambdaTest extends SuperClass {\n         assumeThat(SystemUtils.JAVA_VERSION_FLOAT, is(lessThan(1.7f)));\n \n         ClassReader cr = new ClassReader(getClass().getName().replace('.', '/'));\n-        char[] buf = new char[cr.getMaxStringLength()];\n-\n-        for (int item = 0; item < cr.getItemCount(); item++) {\n-            Object constant = readConstant(item, buf, cr);\n+        TestUtil.visitConstantPool(cr, (item, constant) -> {\n             if (constant instanceof Type) {\n                 Type type = (Type) constant;\n                 assertThat(\"constant #\" + item, type.getDescriptor(), not(containsString(\"java/lang/invoke\")));\n             }\n-        }\n-    }\n-\n-    private static Object readConstant(int item, char[] buf, ClassReader cr) {\n-        try {\n-            return cr.readConst(item, buf);\n-        } catch (Exception e) {\n-            // XXX: constant pool entry which is a Methodref, InvokeDynamic or similar non-plain constant\n-            return null;\n-        }\n+        });\n     }\n }\n \n"
    },
    {
        "commit_hash": "cc74b75b49f2a3bc44753cdcb2765021d7e3b599",
        "previous_commit_hash": "14da0999e07fc6488c88764ea881f211582f545f",
        "diff_stats": {
            "additions": 21,
            "deletions": 1
        },
        "diff_content": "@@ -1,9 +1,11 @@\n-// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2017 Esko Luontola and other Retrolambda contributors\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n package net.orfjackal.retrolambda.test;\n \n+import org.objectweb.asm.ClassReader;\n+\n public class TestUtil {\n \n     public static void assertClassExists(String className) {\n@@ -30,4 +32,22 @@ public class TestUtil {\n     public static String companionNameOf(Class<?> itf) {\n         return itf.getName() + \"$\";\n     }\n+\n+    public static void visitConstantPool(ClassReader reader, ConstantPoolVisitor visitor) {\n+        char[] buf = new char[reader.getMaxStringLength()];\n+        for (int item = 0; item < reader.getItemCount(); item++) {\n+            try {\n+                Object constant = reader.readConst(item, buf);\n+                visitor.visit(item, constant);\n+            } catch (Exception e) {\n+                // XXX: constant pool entry which is a Methodref, InvokeDynamic or similar non-plain constant\n+                // FIXME: readConst throws ArrayIndexOutOfBoundsException nearly all the time; how to use it???\n+                //e.printStackTrace();\n+            }\n+        }\n+    }\n+\n+    public interface ConstantPoolVisitor {\n+        void visit(int item, Object constant);\n+    }\n }\n"
    },
    {
        "commit_hash": "cc74b75b49f2a3bc44753cdcb2765021d7e3b599",
        "previous_commit_hash": "14da0999e07fc6488c88764ea881f211582f545f",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -87,7 +87,7 @@\n             <dependency>\n                 <groupId>org.ow2.asm</groupId>\n                 <artifactId>asm-debug-all</artifactId>\n-                <version>5.1</version>\n+                <version>5.2</version>\n             </dependency>\n \n             <!-- Testing -->\n"
    },
    {
        "commit_hash": "cc74b75b49f2a3bc44753cdcb2765021d7e3b599",
        "previous_commit_hash": "14da0999e07fc6488c88764ea881f211582f545f",
        "diff_stats": {
            "additions": 9,
            "deletions": 9
        },
        "diff_content": "@@ -21,32 +21,32 @@\n     <orderEntry type=\"inheritedJdk\" />\n     <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n     <orderEntry type=\"module\" module-name=\"retrolambda\" />\n-    <orderEntry type=\"library\" name=\"Maven: org.ow2.asm:asm-debug-all:5.1\" level=\"project\" />\n-    <orderEntry type=\"library\" name=\"Maven: com.google.guava:guava:18.0\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.ow2.asm:asm-debug-all:5.2\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-plugin-api:2.0\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"PROVIDED\" name=\"Maven: org.apache.maven.plugin-tools:maven-plugin-annotations:3.4\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-artifact:3.0\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.codehaus.plexus:plexus-utils:3.0.21\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.twdata.maven:mojo-executor:2.2.0\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-core:3.0\" level=\"project\" />\n-    <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-model:3.0\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-settings:3.0\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-settings-builder:3.0\" level=\"project\" />\n-    <orderEntry type=\"library\" name=\"Maven: org.codehaus.plexus:plexus-interpolation:1.14\" level=\"project\" />\n-    <orderEntry type=\"library\" name=\"Maven: org.codehaus.plexus:plexus-component-annotations:1.5.5\" level=\"project\" />\n-    <orderEntry type=\"library\" name=\"Maven: org.sonatype.plexus:plexus-sec-dispatcher:1.3\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-repository-metadata:3.0\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-model-builder:3.0\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"RUNTIME\" name=\"Maven: org.apache.maven:maven-aether-provider:3.0\" level=\"project\" />\n-    <orderEntry type=\"library\" name=\"Maven: org.sonatype.aether:aether-api:1.7\" level=\"project\" />\n-    <orderEntry type=\"library\" name=\"Maven: org.sonatype.aether:aether-util:1.7\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.sonatype.aether:aether-impl:1.7\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.sonatype.aether:aether-spi:1.7\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.sonatype.aether:aether-api:1.7\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.sonatype.aether:aether-util:1.7\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.sonatype.sisu:sisu-inject-plexus:1.4.2\" level=\"project\" />\n-    <orderEntry type=\"library\" name=\"Maven: org.codehaus.plexus:plexus-classworlds:2.2.3\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.sonatype.sisu:sisu-inject-bean:1.4.2\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.sonatype.sisu:sisu-guice:noaop:2.1.7\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.codehaus.plexus:plexus-interpolation:1.14\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.codehaus.plexus:plexus-classworlds:2.2.3\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.codehaus.plexus:plexus-component-annotations:1.5.5\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.sonatype.plexus:plexus-sec-dispatcher:1.3\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.sonatype.plexus:plexus-cipher:1.4\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-model:3.0\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: com.google.guava:guava:18.0\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.12\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-library:1.3\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-core:1.3\" level=\"project\" />\n"
    },
    {
        "commit_hash": "cc74b75b49f2a3bc44753cdcb2765021d7e3b599",
        "previous_commit_hash": "14da0999e07fc6488c88764ea881f211582f545f",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -10,7 +10,7 @@\n     </content>\n     <orderEntry type=\"inheritedJdk\" />\n     <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n-    <orderEntry type=\"library\" name=\"Maven: org.ow2.asm:asm-debug-all:5.1\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.ow2.asm:asm-debug-all:5.2\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: com.google.guava:guava:18.0\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.12\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-library:1.3\" level=\"project\" />\n"
    },
    {
        "commit_hash": "ac69680f979bea2959cbd9ca72e6ada1c88c453f",
        "previous_commit_hash": "cc74b75b49f2a3bc44753cdcb2765021d7e3b599",
        "diff_stats": {
            "additions": 15,
            "deletions": 1
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013-2016 Esko Luontola and other Retrolambda contributors\n+// Copyright \u00a9 2013-2017 Esko Luontola and other Retrolambda contributors\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -6,7 +6,9 @@ package net.orfjackal.retrolambda.test;\n \n import com.google.common.collect.ImmutableSet;\n import org.junit.Test;\n+import org.objectweb.asm.ClassReader;\n \n+import java.io.IOException;\n import java.lang.reflect.Method;\n import java.util.*;\n \n@@ -80,6 +82,18 @@ public class LambdaClassesTest {\n         assertThat(\"capturing lambda\", getMethodsNames(Capturing.class), contains(startsWith(\"lambda$new$\")));\n     }\n \n+    @Test\n+    public void does_not_contain_references_to_JDK_lambda_classes() throws IOException {\n+        ClassReader cr = new ClassReader(\"net/orfjackal/retrolambda/test/LambdaClassesTest$Dummy1$$Lambda$1\");\n+\n+        // XXX: fix visitConstantPool and assert the constant pool entries instead of this hack\n+//        TestUtil.visitConstantPool(cr, (item, constant) -> {\n+//        });\n+\n+        String bytecode = new String(cr.b);\n+        assertThat(bytecode, not(containsString(\"java/lang/invoke/LambdaForm\")));\n+    }\n+\n \n     // helpers\n \n"
    },
    {
        "commit_hash": "ac69680f979bea2959cbd9ca72e6ada1c88c453f",
        "previous_commit_hash": "cc74b75b49f2a3bc44753cdcb2765021d7e3b599",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2017 Esko Luontola and other Retrolambda contributors\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -116,9 +116,9 @@ public class Transformers {\n             if (targetVersion < Opcodes.V1_7) {\n                 next = new SwallowSuppressedExceptions(next);\n                 next = new RemoveMethodHandlesLookupReferences(next);\n-                next = new RemoveLambdaHiddenReferences(next);\n                 next = new RequireNonNull(next);\n             }\n+            next = new RemoveLambdaHiddenReferences(next);\n             next = new FixInvokeStaticOnInterfaceMethod(next);\n             next = chain.wrap(next);\n \n"
    },
    {
        "commit_hash": "03127b1f8cf9c86825769d80fb95805f0aafc234",
        "previous_commit_hash": "ac69680f979bea2959cbd9ca72e6ada1c88c453f",
        "diff_stats": {
            "additions": 0,
            "deletions": 1
        },
        "diff_content": "@@ -118,7 +118,6 @@ public class Transformers {\n                 next = new RemoveMethodHandlesLookupReferences(next);\n                 next = new RequireNonNull(next);\n             }\n-            next = new RemoveLambdaHiddenReferences(next);\n             next = new FixInvokeStaticOnInterfaceMethod(next);\n             next = chain.wrap(next);\n \n"
    },
    {
        "commit_hash": "03127b1f8cf9c86825769d80fb95805f0aafc234",
        "previous_commit_hash": "ac69680f979bea2959cbd9ca72e6ada1c88c453f",
        "diff_stats": {
            "additions": 2,
            "deletions": 1
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2017 Esko Luontola and other Retrolambda contributors\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -50,6 +50,7 @@ public class BackportLambdaClass extends ClassVisitor {\n             return null; // remove the JVM's factory method which will not be unused\n         }\n         MethodVisitor next = super.visitMethod(access, name, desc, signature, exceptions);\n+        next = new RemoveLambdaFormHiddenAnnotation(next);\n         next = new RemoveMagicLambdaConstructorCall(next);\n         next = new CallPrivateImplMethodsViaAccessMethods(access, name, desc, signature, exceptions, next);\n         return next;\n"
    },
    {
        "commit_hash": "03127b1f8cf9c86825769d80fb95805f0aafc234",
        "previous_commit_hash": "ac69680f979bea2959cbd9ca72e6ada1c88c453f",
        "diff_stats": {
            "additions": 24,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,24 @@\n+// Copyright \u00a9 2013-2017 Esko Luontola and other Retrolambda contributors\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.lambdas;\n+\n+import org.objectweb.asm.*;\n+\n+public class RemoveLambdaFormHiddenAnnotation extends MethodVisitor {\n+\n+    private static final String LAMBDA_FORM_HIDDEN_NAME = \"Ljava/lang/invoke/LambdaForm$Hidden;\";\n+\n+    public RemoveLambdaFormHiddenAnnotation(MethodVisitor mv) {\n+        super(Opcodes.ASM5, mv);\n+    }\n+\n+    @Override\n+    public AnnotationVisitor visitAnnotation(String desc, boolean visible) {\n+        if (LAMBDA_FORM_HIDDEN_NAME.equals(desc)) {\n+            return null;\n+        }\n+        return super.visitAnnotation(desc, visible);\n+    }\n+}\n"
    },
    {
        "commit_hash": "03127b1f8cf9c86825769d80fb95805f0aafc234",
        "previous_commit_hash": "ac69680f979bea2959cbd9ca72e6ada1c88c453f",
        "diff_stats": {
            "additions": 0,
            "deletions": 31
        },
        "diff_content": "@@ -1,31 +0,0 @@\n-// Copyright \u00a9 2013-2016 Esko Luontola and other Retrolambda contributors\n-// This software is released under the Apache License 2.0.\n-// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n-\n-package net.orfjackal.retrolambda.lambdas;\n-\n-import org.objectweb.asm.*;\n-\n-import static org.objectweb.asm.Opcodes.ASM5;\n-\n-public class RemoveLambdaHiddenReferences extends ClassVisitor {\n-\n-    private static final String LAMBDA_FORM_HIDDEN_NAME = \"Ljava/lang/invoke/LambdaForm$Hidden;\";\n-\n-    public RemoveLambdaHiddenReferences(ClassVisitor next) {\n-        super(ASM5, next);\n-    }\n-\n-    @Override\n-    public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n-        return new MethodVisitor(ASM5, super.visitMethod(access, name, desc, signature, exceptions)) {\n-            @Override\n-            public AnnotationVisitor visitAnnotation(String desc, boolean visible) {\n-                if (LAMBDA_FORM_HIDDEN_NAME.equals(desc)) {\n-                    return null;\n-                }\n-                return super.visitAnnotation(desc, visible);\n-            }\n-        };\n-    }\n-}\n"
    },
    {
        "commit_hash": "6fb044f63b452ef7259c321528e392dc9b19a4f4",
        "previous_commit_hash": "03127b1f8cf9c86825769d80fb95805f0aafc234",
        "diff_stats": {
            "additions": 6,
            "deletions": 0
        },
        "diff_content": "@@ -224,6 +224,12 @@ optimizations to that mechanism may break Retrolambda.\n Version History\n ---------------\n \n+### Upcoming\n+\n+- Removes `java/lang/invoke/LambdaForm$Hidden` annotations from the generated \n+  lambda classes to avoid issues with ProGuard \n+  ([Pull request #118](https://github.com/orfjackal/retrolambda/pull/118))\n+\n ### Retrolambda 2.3.0 (2016-04-30)\n \n - Optimize generated code to reduce method count\n"
    },
    {
        "commit_hash": "64215cb64ce6aac4a3e17d7d96bace943029ed0a",
        "previous_commit_hash": "1b1c6077f7432497d683cc32f5f0086fbd4653e2",
        "diff_stats": {
            "additions": 7,
            "deletions": 8
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013-2016 Esko Luontola and other Retrolambda contributors\n+// Copyright \u00a9 2013-2017 Esko Luontola and other Retrolambda contributors\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -104,13 +104,7 @@ public class BackportLambdaInvocations extends ClassVisitor {\n     }\n \n     private boolean isNonOwnedMethodVisible(Handle implMethod) {\n-        int classNameLastSlash = className.lastIndexOf('/');\n-        String classPackage = classNameLastSlash == -1 ? \"\" : className.substring(0, classNameLastSlash);\n-\n-        int implMethodLastSlash = implMethod.getOwner().lastIndexOf('/');\n-        String implPackage = implMethodLastSlash == -1 ? \"\" : implMethod.getOwner().substring(0, implMethodLastSlash);\n-\n-        if (classPackage.equals(implPackage)) {\n+        if (getPackage(className).equals(getPackage(implMethod.getOwner()))) {\n             return true; // All method visibilities in the same package will be visible.\n         }\n \n@@ -126,6 +120,11 @@ public class BackportLambdaInvocations extends ClassVisitor {\n         return true;\n     }\n \n+    private static String getPackage(String className) {\n+        int lastSlash = className.lastIndexOf('/');\n+        return lastSlash == -1 ? \"\" : className.substring(0, lastSlash);\n+    }\n+\n     private String getLambdaAccessMethodDesc(Handle implMethod) {\n         if (implMethod.getTag() == H_INVOKESTATIC) {\n             // static method call -> keep as-is\n"
    },
    {
        "commit_hash": "d2b0feb4a556766b82bad850f3642de865602c58",
        "previous_commit_hash": "64215cb64ce6aac4a3e17d7d96bace943029ed0a",
        "diff_stats": {
            "additions": 2,
            "deletions": 0
        },
        "diff_content": "@@ -229,6 +229,8 @@ Version History\n - Removes `java/lang/invoke/LambdaForm$Hidden` annotations from the generated \n   lambda classes to avoid issues with ProGuard \n   ([Pull request #118](https://github.com/orfjackal/retrolambda/pull/118))\n+- Fixed backporting classes in the default package\n+  ([Issue #105](https://github.com/orfjackal/retrolambda/issues/105))\n \n ### Retrolambda 2.3.0 (2016-04-30)\n \n"
    },
    {
        "commit_hash": "b734ee8115af28e0337a00c50ba9f4b4f40728e0",
        "previous_commit_hash": "5069d3087437acc86c2cdfc1e88e8b0e5856f17f",
        "diff_stats": {
            "additions": 2,
            "deletions": 0
        },
        "diff_content": "@@ -231,6 +231,8 @@ Version History\n   ([Pull request #118](https://github.com/orfjackal/retrolambda/pull/118))\n - Fixed backporting classes in the default package\n   ([Issue #105](https://github.com/orfjackal/retrolambda/issues/105))\n+- Fixed backporting `java.lang.Object` itself\n+  ([Pull request #113](https://github.com/orfjackal/retrolambda/pull/113))\n \n ### Retrolambda 2.3.0 (2016-04-30)\n \n"
    },
    {
        "commit_hash": "ff659f1d062f2384c29b736759d07fbf154e5a77",
        "previous_commit_hash": "abd862df3ce84aeefbc1ca7aeeb20b6b645da016",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -79,7 +79,7 @@\n             <plugin>\n                 <artifactId>maven-surefire-plugin</artifactId>\n                 <configuration>\n-                    <skipTests>false</skipTests>\n+                    <skipTests>true</skipTests>\n                 </configuration>\n             </plugin>\n \n"
    },
    {
        "commit_hash": "a9bed1492ccb81afdada7fd27025ad35ea91d08a",
        "previous_commit_hash": "ff659f1d062f2384c29b736759d07fbf154e5a77",
        "diff_stats": {
            "additions": 5,
            "deletions": 36
        },
        "diff_content": "@@ -10,7 +10,6 @@ import org.objectweb.asm.ClassReader;\n \n import java.io.IOException;\n import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n import java.util.*;\n \n import static net.orfjackal.retrolambda.test.TestUtil.assertClassExists;\n@@ -50,7 +49,7 @@ public class LambdaClassesTest {\n \n     @Test\n     public void capturing_lambda_classes_contain_no_unnecessary_methods() throws ClassNotFoundException {\n-        assertThat(getMethodsNames(findLambdaClass(Capturing.class)),\n+        assertThat(getMethodNames(findLambdaClass(Capturing.class)),\n                 is(ImmutableSet.of(\"lambdaFactory$\", \"run\")));\n     }\n \n@@ -64,7 +63,7 @@ public class LambdaClassesTest {\n \n     @Test\n     public void non_capturing_lambda_classes_contain_no_unnecessary_methods() throws ClassNotFoundException {\n-        assertThat(getMethodsNames(findLambdaClass(NonCapturing.class)),\n+        assertThat(getMethodNames(findLambdaClass(NonCapturing.class)),\n                 is(ImmutableSet.of(\"lambdaFactory$\", \"run\")));\n     }\n \n@@ -76,40 +75,10 @@ public class LambdaClassesTest {\n         }\n     }\n \n-\n     @Test\n     public void enclosing_classes_contain_no_unnecessary_methods_in_addition_to_the_lambda_body() throws ClassNotFoundException {\n-        assertThat(\"non-capturing lambda\", getMethodsNames(NonCapturing.class), contains(startsWith(\"lambda$new$\")));\n-        assertThat(\"capturing lambda\", getMethodsNames(Capturing.class), contains(startsWith(\"lambda$new$\")));\n-    }\n-\n-    private class Parent {\n-        protected void foo() {\n-            Runnable lambda = () -> {\n-                System.out.println(\"parent\");\n-            };\n-        }\n-    }\n-\n-    private class Child extends Parent {\n-        @Override\n-        protected void foo() {\n-            super.foo();\n-            Runnable lambda = () -> {\n-                System.out.println(\"child\");\n-            };\n-        }\n-    }\n-\n-    @Test\n-    public void child_class_lambda_doesnt_hide_parent_class_lambda() {\n-        Method[] methods = Child.class.getDeclaredMethods();\n-        Set<String> parentMethods = getMethodsNames(Parent.class);\n-        for (Method method : methods) {\n-            if (method.getName().startsWith(\"lambda$\") && !Modifier.isPrivate(method.getModifiers())) {\n-                assertThat(\"child lambda \" + method.getName() + \" overrides parent\", parentMethods, not(hasItem(method.getName())));\n-            }\n-        }\n+        assertThat(\"non-capturing lambda\", getMethodNames(NonCapturing.class), contains(startsWith(\"lambda$new$\")));\n+        assertThat(\"capturing lambda\", getMethodNames(Capturing.class), contains(startsWith(\"lambda$new$\")));\n     }\n \n     @Test\n@@ -131,7 +100,7 @@ public class LambdaClassesTest {\n         return Class.forName(clazz.getName() + \"$$Lambda$1\");\n     }\n \n-    private static Set<String> getMethodsNames(Class<?> clazz) {\n+    private static Set<String> getMethodNames(Class<?> clazz) {\n         Method[] methods = clazz.getDeclaredMethods();\n         Set<String> uniqueNames = new HashSet<>();\n         for (Method method : methods) {\n"
    },
    {
        "commit_hash": "a9bed1492ccb81afdada7fd27025ad35ea91d08a",
        "previous_commit_hash": "ff659f1d062f2384c29b736759d07fbf154e5a77",
        "diff_stats": {
            "additions": 44,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@ package net.orfjackal.retrolambda.test;\n \n import net.orfjackal.retrolambda.test.anotherpackage.DifferentPackageBase;\n import org.apache.commons.lang.SystemUtils;\n-import org.junit.Test;\n+import org.junit.*;\n import org.objectweb.asm.*;\n import org.objectweb.asm.Type;\n \n@@ -308,6 +308,49 @@ public class LambdaTest extends SuperClass {\n         assertThat(child.parentRef().call(), is(\"parent version\"));\n     }\n \n+    /**\n+     * If the lambda impl method is generated as a private instance method,\n+     * we cannot just make it package-private for the lambda class to call them,\n+     * because a subclass may override the lambda by overriding its enclosing method\n+     * and declaring another lambda expression there.\n+     */\n+    @Ignore // TODO: fix issue #109\n+    @Test\n+    public void will_not_cause_lambda_expressions_to_be_overridable() {\n+        List<String> spy = new ArrayList<>();\n+        class Parent {\n+            @SuppressWarnings(\"unused\")\n+            private int i;\n+\n+            public void foo() {\n+                Runnable lambda = () -> { // generates a private \"lambda$foo$0\" method\n+                    i++; // causes this lambda to be generated as an instance method\n+                    spy.add(\"parent\");\n+                };\n+                lambda.run();\n+            }\n+        }\n+        class Child extends Parent {\n+            @SuppressWarnings(\"unused\")\n+            private int i;\n+\n+            @Override\n+            public void foo() {\n+                super.foo();\n+                Runnable lambda = () -> { // generates a private \"lambda$foo$0\" method\n+                    i++; // causes this lambda to be generated as an instance method\n+                    spy.add(\"child\");\n+                };\n+                lambda.run();\n+            }\n+        }\n+\n+        Child c = new Child();\n+        c.foo();\n+\n+        assertThat(spy, is(Arrays.asList(\"parent\", \"child\")));\n+    }\n+\n     @Test\n     public void bytecode_constant_pool_will_not_contain_dangling_references_to_MethodHandles() throws IOException {\n         assumeThat(SystemUtils.JAVA_VERSION_FLOAT, is(lessThan(1.7f)));\n"
    },
    {
        "commit_hash": "4bb6440322e4e248df883db1904a81e2c71c1d50",
        "previous_commit_hash": "a9bed1492ccb81afdada7fd27025ad35ea91d08a",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,13 @@\n+<component name=\"libraryTable\">\n+  <library name=\"Maven: com.esotericsoftware:minlog:1.3\">\n+    <CLASSES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/com/esotericsoftware/minlog/1.3/minlog-1.3.jar!/\" />\n+    </CLASSES>\n+    <JAVADOC>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/com/esotericsoftware/minlog/1.3/minlog-1.3-javadoc.jar!/\" />\n+    </JAVADOC>\n+    <SOURCES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/com/esotericsoftware/minlog/1.3/minlog-1.3-sources.jar!/\" />\n+    </SOURCES>\n+  </library>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "4bb6440322e4e248df883db1904a81e2c71c1d50",
        "previous_commit_hash": "a9bed1492ccb81afdada7fd27025ad35ea91d08a",
        "diff_stats": {
            "additions": 6,
            "deletions": 0
        },
        "diff_content": "@@ -131,6 +131,12 @@\n                 <version>2.6</version>\n             </dependency>\n \n+            <dependency>\n+                <groupId>com.esotericsoftware</groupId>\n+                <artifactId>minlog</artifactId>\n+                <version>1.3</version>\n+            </dependency>\n+\n         </dependencies>\n     </dependencyManagement>\n \n"
    },
    {
        "commit_hash": "4bb6440322e4e248df883db1904a81e2c71c1d50",
        "previous_commit_hash": "a9bed1492ccb81afdada7fd27025ad35ea91d08a",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -22,6 +22,7 @@\n     <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n     <orderEntry type=\"module\" module-name=\"retrolambda\" />\n     <orderEntry type=\"library\" name=\"Maven: org.ow2.asm:asm-debug-all:5.2\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: com.esotericsoftware:minlog:1.3\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-plugin-api:2.0\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"PROVIDED\" name=\"Maven: org.apache.maven.plugin-tools:maven-plugin-annotations:3.4\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-artifact:3.0\" level=\"project\" />\n"
    },
    {
        "commit_hash": "4bb6440322e4e248df883db1904a81e2c71c1d50",
        "previous_commit_hash": "a9bed1492ccb81afdada7fd27025ad35ea91d08a",
        "diff_stats": {
            "additions": 15,
            "deletions": 0
        },
        "diff_content": "@@ -25,6 +25,11 @@\n             <artifactId>guava</artifactId>\n         </dependency>\n \n+        <dependency>\n+            <groupId>com.esotericsoftware</groupId>\n+            <artifactId>minlog</artifactId>\n+        </dependency>\n+\n     </dependencies>\n \n     <build>\n@@ -99,6 +104,10 @@\n                             <pattern>com.google</pattern>\n                             <shadedPattern>net.orfjackal.retrolambda.google</shadedPattern>\n                         </relocation>\n+                        <relocation>\n+                            <pattern>com.esotericsoftware.minlog</pattern>\n+                            <shadedPattern>net.orfjackal.retrolambda.minlog</shadedPattern>\n+                        </relocation>\n                     </relocations>\n                     <filters>\n                         <filter>\n@@ -115,6 +124,12 @@\n                                 <exclude>META-INF/**</exclude>\n                             </excludes>\n                         </filter>\n+                        <filter>\n+                            <artifact>com.esotericsoftware:minlog</artifact>\n+                            <excludes>\n+                                <exclude>META-INF/**</exclude>\n+                            </excludes>\n+                        </filter>\n                     </filters>\n                 </configuration>\n             </plugin>\n"
    },
    {
        "commit_hash": "4bb6440322e4e248df883db1904a81e2c71c1d50",
        "previous_commit_hash": "a9bed1492ccb81afdada7fd27025ad35ea91d08a",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -12,6 +12,7 @@\n     <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n     <orderEntry type=\"library\" name=\"Maven: org.ow2.asm:asm-debug-all:5.2\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: com.google.guava:guava:18.0\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: com.esotericsoftware:minlog:1.3\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.12\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-library:1.3\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-core:1.3\" level=\"project\" />\n"
    },
    {
        "commit_hash": "4bb6440322e4e248df883db1904a81e2c71c1d50",
        "previous_commit_hash": "a9bed1492ccb81afdada7fd27025ad35ea91d08a",
        "diff_stats": {
            "additions": 5,
            "deletions": 4
        },
        "diff_content": "@@ -1,9 +1,11 @@\n-// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2017 Esko Luontola and other Retrolambda contributors\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n package net.orfjackal.retrolambda;\n \n+import com.esotericsoftware.minlog.Log;\n+\n import java.io.*;\n import java.util.Properties;\n \n@@ -13,7 +15,7 @@ public class Main {\n         System.out.println(\"Retrolambda \" + getVersion());\n \n         if (!isRunningJava8()) {\n-            System.out.println(\"Error! Not running under Java 8\");\n+            Log.error(\"Not running under Java 8\");\n             System.exit(1);\n         }\n \n@@ -25,8 +27,7 @@ public class Main {\n         try {\n             Retrolambda.run(config);\n         } catch (Throwable t) {\n-            System.out.println(\"Error! Failed to run Retrolambda\");\n-            t.printStackTrace(System.out);\n+            Log.error(\"Failed to run Retrolambda\", t);\n             System.exit(1);\n         }\n     }\n"
    },
    {
        "commit_hash": "4bb6440322e4e248df883db1904a81e2c71c1d50",
        "previous_commit_hash": "a9bed1492ccb81afdada7fd27025ad35ea91d08a",
        "diff_stats": {
            "additions": 10,
            "deletions": 9
        },
        "diff_content": "@@ -1,9 +1,10 @@\n-// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2017 Esko Luontola and other Retrolambda contributors\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n package net.orfjackal.retrolambda;\n \n+import com.esotericsoftware.minlog.Log;\n import net.orfjackal.retrolambda.files.*;\n import net.orfjackal.retrolambda.interfaces.*;\n import net.orfjackal.retrolambda.lambdas.*;\n@@ -23,16 +24,16 @@ public class Retrolambda {\n         Path outputDir = config.getOutputDir();\n         List<Path> classpath = config.getClasspath();\n         List<Path> includedFiles = config.getIncludedFiles();\n-        System.out.println(\"Bytecode version: \" + bytecodeVersion + \" (\" + Bytecode.getJavaVersion(bytecodeVersion) + \")\");\n-        System.out.println(\"Default methods:  \" + defaultMethodsEnabled);\n-        System.out.println(\"Input directory:  \" + inputDir);\n-        System.out.println(\"Output directory: \" + outputDir);\n-        System.out.println(\"Classpath:        \" + classpath);\n-        System.out.println(\"Included files:   \" + (includedFiles != null ? includedFiles.size() : \"all\"));\n-        System.out.println(\"Agent enabled:    \" + PreMain.isAgentLoaded());\n+        Log.info(\"Bytecode version: \" + bytecodeVersion + \" (\" + Bytecode.getJavaVersion(bytecodeVersion) + \")\");\n+        Log.info(\"Default methods:  \" + defaultMethodsEnabled);\n+        Log.info(\"Input directory:  \" + inputDir);\n+        Log.info(\"Output directory: \" + outputDir);\n+        Log.info(\"Classpath:        \" + classpath);\n+        Log.info(\"Included files:   \" + (includedFiles != null ? includedFiles.size() : \"all\"));\n+        Log.info(\"Agent enabled:    \" + PreMain.isAgentLoaded());\n \n         if (!Files.isDirectory(inputDir)) {\n-            System.out.println(\"Nothing to do; not a directory: \" + inputDir);\n+            Log.info(\"Nothing to do; not a directory: \" + inputDir);\n             return;\n         }\n \n"
    },
    {
        "commit_hash": "4bb6440322e4e248df883db1904a81e2c71c1d50",
        "previous_commit_hash": "a9bed1492ccb81afdada7fd27025ad35ea91d08a",
        "diff_stats": {
            "additions": 3,
            "deletions": 2
        },
        "diff_content": "@@ -1,9 +1,10 @@\n-// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2017 Esko Luontola and other Retrolambda contributors\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n package net.orfjackal.retrolambda.interfaces;\n \n+import com.esotericsoftware.minlog.Log;\n import org.objectweb.asm.*;\n \n import static net.orfjackal.retrolambda.util.Flags.*;\n@@ -47,7 +48,7 @@ public class WarnAboutDefaultAndStaticMethods extends ClassVisitor {\n     }\n \n     private void printWarning(String methodKind, String methodName) {\n-        System.out.println(\"WARNING: The interface \" + interfaceName + \" has \" + methodKind + \" \\\"\" + methodName + \"\\\" \" +\n+        Log.warn(\"The interface \" + interfaceName + \" has \" + methodKind + \" \\\"\" + methodName + \"\\\" \" +\n                 \"but backporting default methods is not enabled\");\n     }\n }\n"
    },
    {
        "commit_hash": "4bb6440322e4e248df883db1904a81e2c71c1d50",
        "previous_commit_hash": "a9bed1492ccb81afdada7fd27025ad35ea91d08a",
        "diff_stats": {
            "additions": 3,
            "deletions": 4
        },
        "diff_content": "@@ -4,6 +4,7 @@\n \n package net.orfjackal.retrolambda.lambdas;\n \n+import com.esotericsoftware.minlog.Log;\n import net.orfjackal.retrolambda.interfaces.*;\n import net.orfjackal.retrolambda.util.Bytecode;\n import org.objectweb.asm.*;\n@@ -42,10 +43,8 @@ public class BackportLambdaInvocations extends ClassVisitor {\n             AtomicInteger counter = (AtomicInteger) counterField.get(null);\n             counter.set(0);\n         } catch (Throwable t) {\n-            // print to stdout to keep in sync with other log output\n-            System.out.println(\"WARNING: Failed to start class numbering from one. Don't worry, it's cosmetic, \" +\n-                    \"but please file a bug report and tell on which JDK version this happened.\");\n-            t.printStackTrace(System.out);\n+            Log.warn(\"Failed to start class numbering from one. Don't worry, it's cosmetic, \" +\n+                    \"but please file a bug report and tell on which JDK version this happened.\", t);\n         }\n     }\n \n"
    },
    {
        "commit_hash": "4bb6440322e4e248df883db1904a81e2c71c1d50",
        "previous_commit_hash": "a9bed1492ccb81afdada7fd27025ad35ea91d08a",
        "diff_stats": {
            "additions": 3,
            "deletions": 2
        },
        "diff_content": "@@ -1,9 +1,10 @@\n-// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2017 Esko Luontola and other Retrolambda contributors\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n package net.orfjackal.retrolambda.lambdas;\n \n+import com.esotericsoftware.minlog.Log;\n import net.orfjackal.retrolambda.Transformers;\n import net.orfjackal.retrolambda.files.OutputDirectory;\n import org.objectweb.asm.ClassReader;\n@@ -27,7 +28,7 @@ public class LambdaClassSaver {\n     }\n \n     private void reifyLambdaClass(String className, byte[] bytecode) {\n-        System.out.println(\"Saving lambda class: \" + className);\n+        Log.info(\"Saving lambda class: \" + className);\n         bytecode = transformers.backportLambdaClass(new ClassReader(bytecode));\n         try {\n             saver.writeClass(bytecode);\n"
    },
    {
        "commit_hash": "6907b5dc0a1553e5d835605e5bb227d2f0a6ae0c",
        "previous_commit_hash": "4bb6440322e4e248df883db1904a81e2c71c1d50",
        "diff_stats": {
            "additions": 7,
            "deletions": 1
        },
        "diff_content": "@@ -92,7 +92,7 @@ Retrolambda takes Java 8 classes and backports lambda expressions and\n some other language features to work on Java 7, 6 or 5.\n Web site: https://github.com/orfjackal/retrolambda\n \n-Copyright (c) 2013-2016  Esko Luontola and other Retrolambda contributors\n+Copyright (c) 2013-2017  Esko Luontola and other Retrolambda contributors\n This software is released under the Apache License 2.0.\n The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -136,6 +136,10 @@ Configurable system properties:\n       Alternative to retrolambda.includedFiles for avoiding the command line\n       length limit. The file must list one file per line with UTF-8 encoding.\n \n+  retrolambda.quiet\n+      Reduces the amount of logging.\n+      Disabled by default. Enable by setting to \"true\"\n+\n If the Java agent is used, then Retrolambda will use it to capture the\n lambda classes generated by Java. Otherwise Retrolambda will hook into\n Java's internal lambda dumping API, which is more susceptible to suddenly\n@@ -226,6 +230,8 @@ Version History\n \n ### Upcoming\n \n+- Added an option to reduce the amount of logging\n+  ([Issue #103](https://github.com/orfjackal/retrolambda/issues/103))\n - Removes `java/lang/invoke/LambdaForm$Hidden` annotations from the generated \n   lambda classes to avoid issues with ProGuard \n   ([Pull request #118](https://github.com/orfjackal/retrolambda/pull/118))\n"
    },
    {
        "commit_hash": "6907b5dc0a1553e5d835605e5bb227d2f0a6ae0c",
        "previous_commit_hash": "4bb6440322e4e248df883db1904a81e2c71c1d50",
        "diff_stats": {
            "additions": 11,
            "deletions": 1
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2017 Esko Luontola and other Retrolambda contributors\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -78,6 +78,14 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n     @Parameter(defaultValue = \"false\", property = \"retrolambdaDefaultMethods\", required = true)\n     public boolean defaultMethods;\n \n+    /**\n+     * Reduces the amount of logging.\n+     *\n+     * @since 2.4.0\n+     */\n+    @Parameter(defaultValue = \"false\", property = \"retrolambdaQuiet\", required = true)\n+    public boolean quiet;\n+\n     /**\n      * Forces Retrolambda to run in a separate process. The default is not to fork,\n      * in which case Maven has to run under Java 8, or this plugin will fall back\n@@ -128,6 +136,7 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n             Properties p = new Properties();\n             p.setProperty(SystemPropertiesConfig.BYTECODE_VERSION, \"\" + targetBytecodeVersions.get(target));\n             p.setProperty(SystemPropertiesConfig.DEFAULT_METHODS, \"\" + defaultMethods);\n+            p.setProperty(SystemPropertiesConfig.QUIET, \"\" + quiet);\n             p.setProperty(SystemPropertiesConfig.INPUT_DIR, getInputDir().getAbsolutePath());\n             p.setProperty(SystemPropertiesConfig.OUTPUT_DIR, getOutputDir().getAbsolutePath());\n             p.setProperty(SystemPropertiesConfig.CLASSPATH, getClasspath());\n@@ -159,6 +168,7 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n                                             attribute(\"failonerror\", \"true\")),\n                                     element(\"arg\", attribute(\"value\", \"-Dretrolambda.bytecodeVersion=\" + targetBytecodeVersions.get(target))),\n                                     element(\"arg\", attribute(\"value\", \"-Dretrolambda.defaultMethods=\" + defaultMethods)),\n+                                    element(\"arg\", attribute(\"value\", \"-Dretrolambda.quiet=\" + quiet)),\n                                     element(\"arg\", attribute(\"value\", \"-Dretrolambda.inputDir=\" + getInputDir().getAbsolutePath())),\n                                     element(\"arg\", attribute(\"value\", \"-Dretrolambda.outputDir=\" + getOutputDir().getAbsolutePath())),\n                                     element(\"arg\", attribute(\"value\", \"-Dretrolambda.classpathFile=\" + classpathFile)),\n"
    },
    {
        "commit_hash": "6907b5dc0a1553e5d835605e5bb227d2f0a6ae0c",
        "previous_commit_hash": "4bb6440322e4e248df883db1904a81e2c71c1d50",
        "diff_stats": {
            "additions": 3,
            "deletions": 1
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2017 Esko Luontola and other Retrolambda contributors\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -20,4 +20,6 @@ public interface Config {\n     List<Path> getClasspath();\n \n     List<Path> getIncludedFiles();\n+\n+    boolean isQuiet();\n }\n"
    },
    {
        "commit_hash": "6907b5dc0a1553e5d835605e5bb227d2f0a6ae0c",
        "previous_commit_hash": "4bb6440322e4e248df883db1904a81e2c71c1d50",
        "diff_stats": {
            "additions": 5,
            "deletions": 0
        },
        "diff_content": "@@ -24,6 +24,11 @@ public class Retrolambda {\n         Path outputDir = config.getOutputDir();\n         List<Path> classpath = config.getClasspath();\n         List<Path> includedFiles = config.getIncludedFiles();\n+        if (config.isQuiet()) {\n+            Log.WARN();\n+        } else {\n+            Log.INFO();\n+        }\n         Log.info(\"Bytecode version: \" + bytecodeVersion + \" (\" + Bytecode.getJavaVersion(bytecodeVersion) + \")\");\n         Log.info(\"Default methods:  \" + defaultMethodsEnabled);\n         Log.info(\"Input directory:  \" + inputDir);\n"
    },
    {
        "commit_hash": "6907b5dc0a1553e5d835605e5bb227d2f0a6ae0c",
        "previous_commit_hash": "4bb6440322e4e248df883db1904a81e2c71c1d50",
        "diff_stats": {
            "additions": 18,
            "deletions": 2
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013-2016 Esko Luontola and other Retrolambda contributors\n+// Copyright \u00a9 2013-2017 Esko Luontola and other Retrolambda contributors\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -22,6 +22,7 @@ public class SystemPropertiesConfig implements Config {\n     public static final String CLASSPATH_FILE = CLASSPATH + \"File\";\n     public static final String INCLUDED_FILES = PREFIX + \"includedFiles\";\n     public static final String INCLUDED_FILES_FILE = INCLUDED_FILES + \"File\";\n+    public static final String QUIET = PREFIX + \"quiet\";\n \n     private static final List<String> requiredProperties = new ArrayList<>();\n     private static final Map<String, String> alternativeProperties = new HashMap<>();\n@@ -199,6 +200,21 @@ public class SystemPropertiesConfig implements Config {\n     }\n \n \n+    // quiet\n+\n+    static {\n+        optionalParameterHelp(QUIET,\n+                \"Reduces the amount of logging.\",\n+                \"Disabled by default. Enable by setting to \\\"true\\\"\");\n+\n+    }\n+\n+    @Override\n+    public boolean isQuiet() {\n+        return Boolean.parseBoolean(p.getProperty(QUIET, \"false\"));\n+    }\n+\n+\n     // help\n \n     public String getHelp() {\n@@ -212,7 +228,7 @@ public class SystemPropertiesConfig implements Config {\n                 \"some other language features to work on Java 7, 6 or 5.\\n\" +\n                 \"Web site: https://github.com/orfjackal/retrolambda\\n\" +\n                 \"\\n\" +\n-                \"Copyright (c) 2013-2016  Esko Luontola and other Retrolambda contributors\\n\" +\n+                \"Copyright (c) 2013-2017  Esko Luontola and other Retrolambda contributors\\n\" +\n                 \"This software is released under the Apache License 2.0.\\n\" +\n                 \"The license text is at http://www.apache.org/licenses/LICENSE-2.0\\n\" +\n                 \"\\n\" +\n"
    },
    {
        "commit_hash": "1b2d49a4d810a782d6d3d5dc860ee2f0f50eb13c",
        "previous_commit_hash": "6907b5dc0a1553e5d835605e5bb227d2f0a6ae0c",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -51,7 +51,7 @@ To run Retrolambda using Maven, add the following to your pom.xml:\n <plugin>\n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>retrolambda-maven-plugin</artifactId>\n-    <version>2.3.0</version>\n+    <version>2.4.0</version>\n     <executions>\n         <execution>\n             <goals>\n@@ -228,7 +228,7 @@ optimizations to that mechanism may break Retrolambda.\n Version History\n ---------------\n \n-### Upcoming\n+### Retrolambda 2.4.0 (2017-01-11)\n \n - Added an option to reduce the amount of logging\n   ([Issue #103](https://github.com/orfjackal/retrolambda/issues/103))\n"
    },
    {
        "commit_hash": "1b2d49a4d810a782d6d3d5dc860ee2f0f50eb13c",
        "previous_commit_hash": "6907b5dc0a1553e5d835605e5bb227d2f0a6ae0c",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.3.1-SNAPSHOT</version>\n+        <version>2.4.0</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "1b2d49a4d810a782d6d3d5dc860ee2f0f50eb13c",
        "previous_commit_hash": "6907b5dc0a1553e5d835605e5bb227d2f0a6ae0c",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>2.3.1-SNAPSHOT</version>\n+    <version>2.4.0</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "1b2d49a4d810a782d6d3d5dc860ee2f0f50eb13c",
        "previous_commit_hash": "6907b5dc0a1553e5d835605e5bb227d2f0a6ae0c",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.3.1-SNAPSHOT</version>\n+        <version>2.4.0</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "1b2d49a4d810a782d6d3d5dc860ee2f0f50eb13c",
        "previous_commit_hash": "6907b5dc0a1553e5d835605e5bb227d2f0a6ae0c",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.3.1-SNAPSHOT</version>\n+        <version>2.4.0</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "1b2d49a4d810a782d6d3d5dc860ee2f0f50eb13c",
        "previous_commit_hash": "6907b5dc0a1553e5d835605e5bb227d2f0a6ae0c",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.3.1-SNAPSHOT</version>\n+        <version>2.4.0</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "9af656ad59d18160169564d1e3fa49ea268d6310",
        "previous_commit_hash": "1b2d49a4d810a782d6d3d5dc860ee2f0f50eb13c",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.4.0</version>\n+        <version>2.4.1-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "9af656ad59d18160169564d1e3fa49ea268d6310",
        "previous_commit_hash": "1b2d49a4d810a782d6d3d5dc860ee2f0f50eb13c",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>2.4.0</version>\n+    <version>2.4.1-SNAPSHOT</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "9af656ad59d18160169564d1e3fa49ea268d6310",
        "previous_commit_hash": "1b2d49a4d810a782d6d3d5dc860ee2f0f50eb13c",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.4.0</version>\n+        <version>2.4.1-SNAPSHOT</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "9af656ad59d18160169564d1e3fa49ea268d6310",
        "previous_commit_hash": "1b2d49a4d810a782d6d3d5dc860ee2f0f50eb13c",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.4.0</version>\n+        <version>2.4.1-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "9af656ad59d18160169564d1e3fa49ea268d6310",
        "previous_commit_hash": "1b2d49a4d810a782d6d3d5dc860ee2f0f50eb13c",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.4.0</version>\n+        <version>2.4.1-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "88efc5298d78d868bf01d20f0c36aeb5cc60ad3f",
        "previous_commit_hash": "9af656ad59d18160169564d1e3fa49ea268d6310",
        "diff_stats": {
            "additions": 7,
            "deletions": 0
        },
        "diff_content": "@@ -228,6 +228,13 @@ optimizations to that mechanism may break Retrolambda.\n Version History\n ---------------\n \n+### Upcoming\n+\n+- Fixed lambda expressions in subclasses accidentally overriding lambda\n+  expressions in their parent. If you are using version 2.2.0 or greater,\n+  it is strongly recommended to upgrade to this version.\n+  ([Issue #109](https://github.com/orfjackal/retrolambda/issues/109))\n+\n ### Retrolambda 2.4.0 (2017-01-11)\n \n - Added an option to reduce the amount of logging\n"
    },
    {
        "commit_hash": "88efc5298d78d868bf01d20f0c36aeb5cc60ad3f",
        "previous_commit_hash": "9af656ad59d18160169564d1e3fa49ea268d6310",
        "diff_stats": {
            "additions": 1,
            "deletions": 2
        },
        "diff_content": "@@ -6,7 +6,7 @@ package net.orfjackal.retrolambda.test;\n \n import net.orfjackal.retrolambda.test.anotherpackage.DifferentPackageBase;\n import org.apache.commons.lang.SystemUtils;\n-import org.junit.*;\n+import org.junit.Test;\n import org.objectweb.asm.*;\n import org.objectweb.asm.Type;\n \n@@ -314,7 +314,6 @@ public class LambdaTest extends SuperClass {\n      * because a subclass may override the lambda by overriding its enclosing method\n      * and declaring another lambda expression there.\n      */\n-    @Ignore // TODO: fix issue #109\n     @Test\n     public void will_not_cause_lambda_expressions_to_be_overridable() {\n         List<String> spy = new ArrayList<>();\n"
    },
    {
        "commit_hash": "88efc5298d78d868bf01d20f0c36aeb5cc60ad3f",
        "previous_commit_hash": "9af656ad59d18160169564d1e3fa49ea268d6310",
        "diff_stats": {
            "additions": 18,
            "deletions": 5
        },
        "diff_content": "@@ -6,7 +6,7 @@ package net.orfjackal.retrolambda.lambdas;\n \n import com.esotericsoftware.minlog.Log;\n import net.orfjackal.retrolambda.interfaces.*;\n-import net.orfjackal.retrolambda.util.Bytecode;\n+import net.orfjackal.retrolambda.util.*;\n import org.objectweb.asm.*;\n \n import java.lang.reflect.Field;\n@@ -51,8 +51,19 @@ public class BackportLambdaInvocations extends ClassVisitor {\n     @Override\n     public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n         if (LambdaNaming.isBodyMethod(access, name)) {\n-            // Ensure our generated lambda class is able to call this method.\n-            access &= ~ACC_PRIVATE;\n+\n+            // Ensure the generated lambda class is able to call this method.\n+            if (Flags.isPrivateMethod(access)) {\n+                access &= ~ACC_PRIVATE; // make non-private\n+\n+                // Making private instance methods non-private is dangerous, because subclasses\n+                // may then override them. That's why we will also make them static, so that they\n+                // will not be overridable.\n+                if (Flags.isInstanceMethod(access)) {\n+                    access |= ACC_STATIC; // make static\n+                    desc = Types.prependArgumentType(Type.getObjectType(className), desc); // add 'this' as first parameter\n+                }\n+            }\n         }\n         if (LambdaNaming.isDeserializationHook(access, name, desc)) {\n             return null; // remove serialization hooks; we serialize lambda instances as-is\n@@ -76,8 +87,10 @@ public class BackportLambdaInvocations extends ClassVisitor {\n             }\n             if (LambdaNaming.isBodyMethodName(implMethod.getName())) {\n                 if (implMethod.getTag() == H_INVOKESPECIAL) {\n-                    // The private body method is now package so switch its invocation from special to virtual.\n-                    return new Handle(H_INVOKEVIRTUAL, implMethod.getOwner(), implMethod.getName(), implMethod.getDesc(), false);\n+                    // The private body method was changed from a private instance method into\n+                    // a non-private static method, so change its invocation from special to static.\n+                    String desc = Types.prependArgumentType(Type.getObjectType(implMethod.getOwner()), implMethod.getDesc());\n+                    return new Handle(H_INVOKESTATIC, implMethod.getOwner(), implMethod.getName(), desc, false);\n                 }\n                 return implMethod;\n             }\n"
    },
    {
        "commit_hash": "d77e2ca6d1a8a3362a698e77eedc9005cacb2751",
        "previous_commit_hash": "88efc5298d78d868bf01d20f0c36aeb5cc60ad3f",
        "diff_stats": {
            "additions": 4,
            "deletions": 0
        },
        "diff_content": "@@ -33,6 +33,10 @@ projects that have backported some of them:\n * [streamsupport](http://sourceforge.net/projects/streamsupport/) backports the `java.util.stream` API\n * [ThreeTen](http://www.threeten.org/) backports the `java.time` API\n \n+Additionally [Animal Sniffer](http://www.mojohaus.org/animal-sniffer/) and \n+[IntelliJ IDEA](https://www.jetbrains.com/idea/) can warn about the use of\n+Java 8 APIs.\n+\n \n User Guide\n ----------\n"
    },
    {
        "commit_hash": "fedb670c0301faadaafd20b08a46e9be2d6ac835",
        "previous_commit_hash": "d77e2ca6d1a8a3362a698e77eedc9005cacb2751",
        "diff_stats": {
            "additions": 4,
            "deletions": 4
        },
        "diff_content": "@@ -1,13 +1,13 @@\n <component name=\"libraryTable\">\n-  <library name=\"Maven: org.apache.maven:maven-plugin-api:2.0\">\n+  <library name=\"Maven: org.apache.maven:maven-plugin-api:3.0\">\n     <CLASSES>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/maven/maven-plugin-api/2.0/maven-plugin-api-2.0.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/maven/maven-plugin-api/3.0/maven-plugin-api-3.0.jar!/\" />\n     </CLASSES>\n     <JAVADOC>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/maven/maven-plugin-api/2.0/maven-plugin-api-2.0-javadoc.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/maven/maven-plugin-api/3.0/maven-plugin-api-3.0-javadoc.jar!/\" />\n     </JAVADOC>\n     <SOURCES>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/maven/maven-plugin-api/2.0/maven-plugin-api-2.0-sources.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/maven/maven-plugin-api/3.0/maven-plugin-api-3.0-sources.jar!/\" />\n     </SOURCES>\n   </library>\n </component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "fedb670c0301faadaafd20b08a46e9be2d6ac835",
        "previous_commit_hash": "d77e2ca6d1a8a3362a698e77eedc9005cacb2751",
        "diff_stats": {
            "additions": 4,
            "deletions": 4
        },
        "diff_content": "@@ -1,13 +1,13 @@\n <component name=\"libraryTable\">\n-  <library name=\"Maven: org.codehaus.plexus:plexus-component-annotations:1.5.5\">\n+  <library name=\"Maven: org.codehaus.plexus:plexus-component-annotations:1.5.4\">\n     <CLASSES>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/codehaus/plexus/plexus-component-annotations/1.5.5/plexus-component-annotations-1.5.5.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/codehaus/plexus/plexus-component-annotations/1.5.4/plexus-component-annotations-1.5.4.jar!/\" />\n     </CLASSES>\n     <JAVADOC>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/codehaus/plexus/plexus-component-annotations/1.5.5/plexus-component-annotations-1.5.5-javadoc.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/codehaus/plexus/plexus-component-annotations/1.5.4/plexus-component-annotations-1.5.4-javadoc.jar!/\" />\n     </JAVADOC>\n     <SOURCES>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/codehaus/plexus/plexus-component-annotations/1.5.5/plexus-component-annotations-1.5.5-sources.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/codehaus/plexus/plexus-component-annotations/1.5.4/plexus-component-annotations-1.5.4-sources.jar!/\" />\n     </SOURCES>\n   </library>\n </component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "fedb670c0301faadaafd20b08a46e9be2d6ac835",
        "previous_commit_hash": "d77e2ca6d1a8a3362a698e77eedc9005cacb2751",
        "diff_stats": {
            "additions": 5,
            "deletions": 1
        },
        "diff_content": "@@ -12,6 +12,10 @@\n     <artifactId>retrolambda-maven-plugin</artifactId>\n     <packaging>maven-plugin</packaging>\n \n+    <prerequisites>\n+        <maven>3.0</maven>\n+    </prerequisites>\n+\n     <dependencies>\n \n         <dependency>\n@@ -23,7 +27,7 @@\n         <dependency>\n             <groupId>org.apache.maven</groupId>\n             <artifactId>maven-plugin-api</artifactId>\n-            <version>2.0</version>\n+            <version>3.0</version>\n         </dependency>\n         <dependency>\n             <groupId>org.apache.maven.plugin-tools</groupId>\n"
    },
    {
        "commit_hash": "fedb670c0301faadaafd20b08a46e9be2d6ac835",
        "previous_commit_hash": "d77e2ca6d1a8a3362a698e77eedc9005cacb2751",
        "diff_stats": {
            "additions": 8,
            "deletions": 8
        },
        "diff_content": "@@ -23,9 +23,15 @@\n     <orderEntry type=\"module\" module-name=\"retrolambda\" />\n     <orderEntry type=\"library\" name=\"Maven: org.ow2.asm:asm-debug-all:5.2\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: com.esotericsoftware:minlog:1.3\" level=\"project\" />\n-    <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-plugin-api:2.0\" level=\"project\" />\n-    <orderEntry type=\"library\" scope=\"PROVIDED\" name=\"Maven: org.apache.maven.plugin-tools:maven-plugin-annotations:3.4\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-plugin-api:3.0\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-model:3.0\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-artifact:3.0\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.sonatype.sisu:sisu-inject-plexus:1.4.2\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.codehaus.plexus:plexus-component-annotations:1.5.4\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.codehaus.plexus:plexus-classworlds:2.2.3\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.sonatype.sisu:sisu-inject-bean:1.4.2\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.sonatype.sisu:sisu-guice:noaop:2.1.7\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"PROVIDED\" name=\"Maven: org.apache.maven.plugin-tools:maven-plugin-annotations:3.4\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.codehaus.plexus:plexus-utils:3.0.21\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.twdata.maven:mojo-executor:2.2.0\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-core:3.0\" level=\"project\" />\n@@ -38,15 +44,9 @@\n     <orderEntry type=\"library\" name=\"Maven: org.sonatype.aether:aether-spi:1.7\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.sonatype.aether:aether-api:1.7\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.sonatype.aether:aether-util:1.7\" level=\"project\" />\n-    <orderEntry type=\"library\" name=\"Maven: org.sonatype.sisu:sisu-inject-plexus:1.4.2\" level=\"project\" />\n-    <orderEntry type=\"library\" name=\"Maven: org.sonatype.sisu:sisu-inject-bean:1.4.2\" level=\"project\" />\n-    <orderEntry type=\"library\" name=\"Maven: org.sonatype.sisu:sisu-guice:noaop:2.1.7\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.codehaus.plexus:plexus-interpolation:1.14\" level=\"project\" />\n-    <orderEntry type=\"library\" name=\"Maven: org.codehaus.plexus:plexus-classworlds:2.2.3\" level=\"project\" />\n-    <orderEntry type=\"library\" name=\"Maven: org.codehaus.plexus:plexus-component-annotations:1.5.5\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.sonatype.plexus:plexus-sec-dispatcher:1.3\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.sonatype.plexus:plexus-cipher:1.4\" level=\"project\" />\n-    <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-model:3.0\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: com.google.guava:guava:18.0\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.12\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-library:1.3\" level=\"project\" />\n"
    },
    {
        "commit_hash": "62e89c3b2b637c24d9f793f23ad0ca4372521499",
        "previous_commit_hash": "fedb670c0301faadaafd20b08a46e9be2d6ac835",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -55,7 +55,7 @@ To run Retrolambda using Maven, add the following to your pom.xml:\n <plugin>\n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>retrolambda-maven-plugin</artifactId>\n-    <version>2.4.0</version>\n+    <version>2.5.0</version>\n     <executions>\n         <execution>\n             <goals>\n@@ -232,7 +232,7 @@ optimizations to that mechanism may break Retrolambda.\n Version History\n ---------------\n \n-### Upcoming\n+### Retrolambda 2.5.0 (2017-01-22)\n \n - Fixed lambda expressions in subclasses accidentally overriding lambda\n   expressions in their parent. If you are using version 2.2.0 or greater,\n"
    },
    {
        "commit_hash": "62e89c3b2b637c24d9f793f23ad0ca4372521499",
        "previous_commit_hash": "fedb670c0301faadaafd20b08a46e9be2d6ac835",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.4.1-SNAPSHOT</version>\n+        <version>2.5.0</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "62e89c3b2b637c24d9f793f23ad0ca4372521499",
        "previous_commit_hash": "fedb670c0301faadaafd20b08a46e9be2d6ac835",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>2.4.1-SNAPSHOT</version>\n+    <version>2.5.0</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "62e89c3b2b637c24d9f793f23ad0ca4372521499",
        "previous_commit_hash": "fedb670c0301faadaafd20b08a46e9be2d6ac835",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.4.1-SNAPSHOT</version>\n+        <version>2.5.0</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "62e89c3b2b637c24d9f793f23ad0ca4372521499",
        "previous_commit_hash": "fedb670c0301faadaafd20b08a46e9be2d6ac835",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.4.1-SNAPSHOT</version>\n+        <version>2.5.0</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "62e89c3b2b637c24d9f793f23ad0ca4372521499",
        "previous_commit_hash": "fedb670c0301faadaafd20b08a46e9be2d6ac835",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.4.1-SNAPSHOT</version>\n+        <version>2.5.0</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "78d383309ae39b529beb1d9d6f2bc75ad7bd6c2a",
        "previous_commit_hash": "62e89c3b2b637c24d9f793f23ad0ca4372521499",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.0</version>\n+        <version>2.5.1-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "78d383309ae39b529beb1d9d6f2bc75ad7bd6c2a",
        "previous_commit_hash": "62e89c3b2b637c24d9f793f23ad0ca4372521499",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>2.5.0</version>\n+    <version>2.5.1-SNAPSHOT</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "78d383309ae39b529beb1d9d6f2bc75ad7bd6c2a",
        "previous_commit_hash": "62e89c3b2b637c24d9f793f23ad0ca4372521499",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.0</version>\n+        <version>2.5.1-SNAPSHOT</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "78d383309ae39b529beb1d9d6f2bc75ad7bd6c2a",
        "previous_commit_hash": "62e89c3b2b637c24d9f793f23ad0ca4372521499",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.0</version>\n+        <version>2.5.1-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "78d383309ae39b529beb1d9d6f2bc75ad7bd6c2a",
        "previous_commit_hash": "62e89c3b2b637c24d9f793f23ad0ca4372521499",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.0</version>\n+        <version>2.5.1-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "db04059b971fa53f7746fba3ec43c5383d00dd0b",
        "previous_commit_hash": "78d383309ae39b529beb1d9d6f2bc75ad7bd6c2a",
        "diff_stats": {
            "additions": 13,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@ package net.orfjackal.retrolambda.test;\n \n import net.orfjackal.retrolambda.test.anotherpackage.DifferentPackageBase;\n import org.apache.commons.lang.SystemUtils;\n-import org.junit.Test;\n+import org.junit.*;\n import org.objectweb.asm.*;\n import org.objectweb.asm.Type;\n \n@@ -247,6 +247,18 @@ public class LambdaTest extends SuperClass {\n         return \"foo\";\n     }\n \n+\n+    @Test\n+    @Ignore // TODO: fix issue #121\n+    public void enclosing_method_of_anonymous_class_inside_lambda_expression() throws Exception {\n+        Callable<Object> lambda = () -> new Object() {\n+        };\n+        Class<?> anonymousClass = lambda.call().getClass();\n+\n+        assertThat(anonymousClass.getEnclosingMethod().getName(),\n+                startsWith(\"lambda$enclosing_method_of_anonymous_class_inside_lambda_expression$\"));\n+    }\n+\n     /**\n      * We could make private lambda implementation methods package-private,\n      * so that the lambda class may call them, but we should not make any\n"
    },
    {
        "commit_hash": "85b22b3ace8cc5956c19f49fbc255b4e0a9421f4",
        "previous_commit_hash": "db04059b971fa53f7746fba3ec43c5383d00dd0b",
        "diff_stats": {
            "additions": 6,
            "deletions": 2
        },
        "diff_content": "@@ -1,7 +1,6 @@\n <component name=\"InspectionProjectProfileManager\">\n-  <profile version=\"1.0\" is_locked=\"false\">\n+  <profile version=\"1.0\">\n     <option name=\"myName\" value=\"Project Default\" />\n-    <option name=\"myLocal\" value=\"false\" />\n     <inspection_tool class=\"ArraysAsListWithZeroOrOneArgument\" enabled=\"true\" level=\"WEAK WARNING\" enabled_by_default=\"true\" />\n     <inspection_tool class=\"CollectionContainsUrl\" enabled=\"true\" level=\"WARNING\" enabled_by_default=\"true\" />\n     <inspection_tool class=\"CollectionsFieldAccessReplaceableByMethodCall\" enabled=\"true\" level=\"WARNING\" enabled_by_default=\"true\" />\n@@ -67,5 +66,10 @@\n       <option name=\"ignoreReferences\" value=\"true\" />\n       <option name=\"ignoreComplexLiterals\" value=\"false\" />\n     </inspection_tool>\n+    <inspection_tool class=\"WeakerAccess\" enabled=\"true\" level=\"WARNING\" enabled_by_default=\"true\">\n+      <option name=\"SUGGEST_PACKAGE_LOCAL_FOR_MEMBERS\" value=\"false\" />\n+      <option name=\"SUGGEST_PACKAGE_LOCAL_FOR_TOP_CLASSES\" value=\"false\" />\n+      <option name=\"SUGGEST_PRIVATE_FOR_INNERS\" value=\"false\" />\n+    </inspection_tool>\n   </profile>\n </component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "85b22b3ace8cc5956c19f49fbc255b4e0a9421f4",
        "previous_commit_hash": "db04059b971fa53f7746fba3ec43c5383d00dd0b",
        "diff_stats": {
            "additions": 0,
            "deletions": 7
        },
        "diff_content": "@@ -1,7 +0,0 @@\n-<component name=\"InspectionProjectProfileManager\">\n-  <settings>\n-    <option name=\"PROJECT_PROFILE\" value=\"Project Default\" />\n-    <option name=\"USE_PROJECT_PROFILE\" value=\"true\" />\n-    <version value=\"1.0\" />\n-  </settings>\n-</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "03f7c2d2e46e2625a5cafc36479be3705dc1a5b5",
        "previous_commit_hash": "85b22b3ace8cc5956c19f49fbc255b4e0a9421f4",
        "diff_stats": {
            "additions": 2,
            "deletions": 1
        },
        "diff_content": "@@ -38,6 +38,7 @@ public abstract class ClasspathVisitor extends SimpleFileVisitor<Path> {\n     protected abstract void visitResource(Path relativePath, byte[] content) throws IOException;\n \n     private static boolean isJavaClass(Path file) {\n-        return file.getFileName().toString().endsWith(\".class\");\n+        String fileName = file.getFileName().toString();\n+        return fileName.endsWith(\".class\") && !fileName.equals(\"module-info.class\");\n     }\n }\n"
    },
    {
        "commit_hash": "006a423ee3005796cd1c6be4f3c011bc81890da7",
        "previous_commit_hash": "85b22b3ace8cc5956c19f49fbc255b4e0a9421f4",
        "diff_stats": {
            "additions": 3,
            "deletions": 2
        },
        "diff_content": "@@ -1,9 +1,10 @@\n-// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2017 Esko Luontola and other Retrolambda contributors\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n-package net.orfjackal.retrolambda.interfaces;\n+package net.orfjackal.retrolambda;\n \n+import net.orfjackal.retrolambda.interfaces.*;\n import net.orfjackal.retrolambda.lambdas.Handles;\n import net.orfjackal.retrolambda.util.Bytecode;\n import org.objectweb.asm.*;\n"
    },
    {
        "commit_hash": "006a423ee3005796cd1c6be4f3c011bc81890da7",
        "previous_commit_hash": "85b22b3ace8cc5956c19f49fbc255b4e0a9421f4",
        "diff_stats": {
            "additions": 2,
            "deletions": 1
        },
        "diff_content": "@@ -1,9 +1,10 @@\n-// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2017 Esko Luontola and other Retrolambda contributors\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n package net.orfjackal.retrolambda.interfaces;\n \n+import net.orfjackal.retrolambda.ClassAnalyzer;\n import net.orfjackal.retrolambda.util.Bytecode;\n import org.objectweb.asm.*;\n \n"
    },
    {
        "commit_hash": "006a423ee3005796cd1c6be4f3c011bc81890da7",
        "previous_commit_hash": "85b22b3ace8cc5956c19f49fbc255b4e0a9421f4",
        "diff_stats": {
            "additions": 2,
            "deletions": 1
        },
        "diff_content": "@@ -1,9 +1,10 @@\n-// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2017 Esko Luontola and other Retrolambda contributors\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n package net.orfjackal.retrolambda.interfaces;\n \n+import net.orfjackal.retrolambda.ClassAnalyzer;\n import net.orfjackal.retrolambda.lambdas.Handles;\n import org.objectweb.asm.*;\n \n"
    },
    {
        "commit_hash": "006a423ee3005796cd1c6be4f3c011bc81890da7",
        "previous_commit_hash": "85b22b3ace8cc5956c19f49fbc255b4e0a9421f4",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -5,6 +5,7 @@\n package net.orfjackal.retrolambda.lambdas;\n \n import com.esotericsoftware.minlog.Log;\n+import net.orfjackal.retrolambda.ClassAnalyzer;\n import net.orfjackal.retrolambda.interfaces.*;\n import net.orfjackal.retrolambda.util.*;\n import org.objectweb.asm.*;\n"
    },
    {
        "commit_hash": "6d5a4c1fd9d094452cfde2096a81ab82a0c1c9ce",
        "previous_commit_hash": "006a423ee3005796cd1c6be4f3c011bc81890da7",
        "diff_stats": {
            "additions": 5,
            "deletions": 0
        },
        "diff_content": "@@ -232,6 +232,11 @@ optimizations to that mechanism may break Retrolambda.\n Version History\n ---------------\n \n+### Upcoming\n+\n+- Fix anonymous classes inside lambda expressions\n+  ([Issue #121](https://github.com/orfjackal/retrolambda/issues/121))\n+\n ### Retrolambda 2.5.0 (2017-01-22)\n \n - Fixed lambda expressions in subclasses accidentally overriding lambda\n"
    },
    {
        "commit_hash": "6d5a4c1fd9d094452cfde2096a81ab82a0c1c9ce",
        "previous_commit_hash": "006a423ee3005796cd1c6be4f3c011bc81890da7",
        "diff_stats": {
            "additions": 1,
            "deletions": 2
        },
        "diff_content": "@@ -6,7 +6,7 @@ package net.orfjackal.retrolambda.test;\n \n import net.orfjackal.retrolambda.test.anotherpackage.DifferentPackageBase;\n import org.apache.commons.lang.SystemUtils;\n-import org.junit.*;\n+import org.junit.Test;\n import org.objectweb.asm.*;\n import org.objectweb.asm.Type;\n \n@@ -249,7 +249,6 @@ public class LambdaTest extends SuperClass {\n \n \n     @Test\n-    @Ignore // TODO: fix issue #121\n     public void enclosing_method_of_anonymous_class_inside_lambda_expression() throws Exception {\n         Callable<Object> lambda = () -> new Object() {\n         };\n"
    },
    {
        "commit_hash": "6d5a4c1fd9d094452cfde2096a81ab82a0c1c9ce",
        "previous_commit_hash": "006a423ee3005796cd1c6be4f3c011bc81890da7",
        "diff_stats": {
            "additions": 35,
            "deletions": 3
        },
        "diff_content": "@@ -5,8 +5,8 @@\n package net.orfjackal.retrolambda;\n \n import net.orfjackal.retrolambda.interfaces.*;\n-import net.orfjackal.retrolambda.lambdas.Handles;\n-import net.orfjackal.retrolambda.util.Bytecode;\n+import net.orfjackal.retrolambda.lambdas.*;\n+import net.orfjackal.retrolambda.util.*;\n import org.objectweb.asm.*;\n \n import java.util.*;\n@@ -19,6 +19,7 @@ public class ClassAnalyzer {\n \n     private final Map<Type, ClassInfo> classes = new HashMap<>();\n     private final Map<MethodRef, MethodRef> relocatedMethods = new HashMap<>();\n+    private final Map<MethodRef, MethodRef> renamedLambdaMethods = new HashMap<>();\n \n     public void analyze(byte[] bytecode) {\n         analyze(new ClassReader(bytecode));\n@@ -33,6 +34,7 @@ public class ClassAnalyzer {\n         } else {\n             analyzeClass(c, cr);\n         }\n+        analyzeClassOrInterface(c, cr);\n     }\n \n     private void analyzeClass(ClassInfo c, ClassReader cr) {\n@@ -98,7 +100,33 @@ public class ClassAnalyzer {\n         }, ClassReader.SKIP_CODE);\n     }\n \n-    public static boolean isDefaultMethod(int access) {\n+    private void analyzeClassOrInterface(ClassInfo c, ClassReader cr) {\n+        cr.accept(new ClassVisitor(ASM5) {\n+            private String owner;\n+\n+            @Override\n+            public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n+                this.owner = name;\n+            }\n+\n+            @Override\n+            public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+                MethodRef method = new MethodRef(Handles.accessToTag(access, true), owner, name, desc);\n+\n+                // XXX: duplicates code in net.orfjackal.retrolambda.lambdas.BackportLambdaInvocations.visitMethod()\n+                if (LambdaNaming.isBodyMethod(access, name)\n+                        && Flags.isPrivateMethod(access)\n+                        && Flags.isInstanceMethod(access)) {\n+                    desc = Types.prependArgumentType(Type.getObjectType(owner), desc); // add 'this' as first parameter\n+                    renamedLambdaMethods.put(method, new MethodRef(H_INVOKESTATIC, owner, name, desc));\n+                }\n+\n+                return null;\n+            }\n+        }, ClassReader.SKIP_CODE);\n+    }\n+\n+    private static boolean isDefaultMethod(int access) {\n         return !isAbstractMethod(access)\n                 && !isStaticMethod(access)\n                 && isPublicMethod(access);\n@@ -139,6 +167,10 @@ public class ClassAnalyzer {\n         return relocatedMethods.getOrDefault(original, original);\n     }\n \n+    public MethodRef getRenamedLambdaMethod(MethodRef original) {\n+        return renamedLambdaMethods.getOrDefault(original, original);\n+    }\n+\n     public MethodRef getMethodDefaultImplementation(MethodRef interfaceMethod) {\n         MethodSignature signature = interfaceMethod.getSignature();\n         for (MethodInfo method : getDefaultMethods(Type.getObjectType(interfaceMethod.owner))) {\n"
    },
    {
        "commit_hash": "6d5a4c1fd9d094452cfde2096a81ab82a0c1c9ce",
        "previous_commit_hash": "006a423ee3005796cd1c6be4f3c011bc81890da7",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -119,6 +119,7 @@ public class Transformers {\n                 next = new RequireNonNull(next);\n             }\n             next = new FixInvokeStaticOnInterfaceMethod(next);\n+            next = new UpdateRenamedEnclosingMethods(next, analyzer);\n             next = chain.wrap(next);\n \n             reader.accept(next);\n"
    },
    {
        "commit_hash": "6d5a4c1fd9d094452cfde2096a81ab82a0c1c9ce",
        "previous_commit_hash": "006a423ee3005796cd1c6be4f3c011bc81890da7",
        "diff_stats": {
            "additions": 27,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,27 @@\n+// Copyright \u00a9 2013-2017 Esko Luontola and other Retrolambda contributors\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.lambdas;\n+\n+import net.orfjackal.retrolambda.ClassAnalyzer;\n+import net.orfjackal.retrolambda.interfaces.MethodRef;\n+import org.objectweb.asm.ClassVisitor;\n+\n+import static org.objectweb.asm.Opcodes.ASM5;\n+\n+public class UpdateRenamedEnclosingMethods extends ClassVisitor {\n+\n+    private final ClassAnalyzer analyzer;\n+\n+    public UpdateRenamedEnclosingMethods(ClassVisitor next, ClassAnalyzer analyzer) {\n+        super(ASM5, next);\n+        this.analyzer = analyzer;\n+    }\n+\n+    @Override\n+    public void visitOuterClass(String owner, String name, String desc) {\n+        MethodRef method = analyzer.getRenamedLambdaMethod(new MethodRef(0, owner, name, desc));\n+        super.visitOuterClass(method.owner, method.name, method.desc);\n+    }\n+}\n"
    },
    {
        "commit_hash": "10cb06ec6a9f5a1d801f2bcf4609a0daf706ef37",
        "previous_commit_hash": "6d5a4c1fd9d094452cfde2096a81ab82a0c1c9ce",
        "diff_stats": {
            "additions": 4,
            "deletions": 3
        },
        "diff_content": "@@ -55,7 +55,7 @@ To run Retrolambda using Maven, add the following to your pom.xml:\n <plugin>\n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>retrolambda-maven-plugin</artifactId>\n-    <version>2.5.0</version>\n+    <version>2.5.1</version>\n     <executions>\n         <execution>\n             <goals>\n@@ -232,9 +232,10 @@ optimizations to that mechanism may break Retrolambda.\n Version History\n ---------------\n \n-### Upcoming\n+### Retrolambda 2.5.1 (2017-02-23)\n \n-- Fix anonymous classes inside lambda expressions\n+- Fixed the enclosing method attribute of anonymous classes declared inside\n+  lambda expressions\n   ([Issue #121](https://github.com/orfjackal/retrolambda/issues/121))\n \n ### Retrolambda 2.5.0 (2017-01-22)\n"
    },
    {
        "commit_hash": "10cb06ec6a9f5a1d801f2bcf4609a0daf706ef37",
        "previous_commit_hash": "6d5a4c1fd9d094452cfde2096a81ab82a0c1c9ce",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.1-SNAPSHOT</version>\n+        <version>2.5.1</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "10cb06ec6a9f5a1d801f2bcf4609a0daf706ef37",
        "previous_commit_hash": "6d5a4c1fd9d094452cfde2096a81ab82a0c1c9ce",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>2.5.1-SNAPSHOT</version>\n+    <version>2.5.1</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "10cb06ec6a9f5a1d801f2bcf4609a0daf706ef37",
        "previous_commit_hash": "6d5a4c1fd9d094452cfde2096a81ab82a0c1c9ce",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.1-SNAPSHOT</version>\n+        <version>2.5.1</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "10cb06ec6a9f5a1d801f2bcf4609a0daf706ef37",
        "previous_commit_hash": "6d5a4c1fd9d094452cfde2096a81ab82a0c1c9ce",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.1-SNAPSHOT</version>\n+        <version>2.5.1</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "10cb06ec6a9f5a1d801f2bcf4609a0daf706ef37",
        "previous_commit_hash": "6d5a4c1fd9d094452cfde2096a81ab82a0c1c9ce",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.1-SNAPSHOT</version>\n+        <version>2.5.1</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "6039108c610f807a94607e947c541a90bb0ba183",
        "previous_commit_hash": "10cb06ec6a9f5a1d801f2bcf4609a0daf706ef37",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.1</version>\n+        <version>2.5.2-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "6039108c610f807a94607e947c541a90bb0ba183",
        "previous_commit_hash": "10cb06ec6a9f5a1d801f2bcf4609a0daf706ef37",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>2.5.1</version>\n+    <version>2.5.2-SNAPSHOT</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "6039108c610f807a94607e947c541a90bb0ba183",
        "previous_commit_hash": "10cb06ec6a9f5a1d801f2bcf4609a0daf706ef37",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.1</version>\n+        <version>2.5.2-SNAPSHOT</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "6039108c610f807a94607e947c541a90bb0ba183",
        "previous_commit_hash": "10cb06ec6a9f5a1d801f2bcf4609a0daf706ef37",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.1</version>\n+        <version>2.5.2-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "6039108c610f807a94607e947c541a90bb0ba183",
        "previous_commit_hash": "10cb06ec6a9f5a1d801f2bcf4609a0daf706ef37",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.1</version>\n+        <version>2.5.2-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "04c3533811a200ebf076117fbe102e2962960d3a",
        "previous_commit_hash": "6039108c610f807a94607e947c541a90bb0ba183",
        "diff_stats": {
            "additions": 3,
            "deletions": 1
        },
        "diff_content": "@@ -31,7 +31,9 @@ Using the Docker-based Development Environment\n To avoid having to install all the Java versions on your computer, there is a\n Docker image for building Retrolambda.\n \n-The image is already in Docker Hub, but it can also be built locally with:\n+The image is already in Docker Hub, but it can also be built locally with the\n+following command. But first you need to download the JDK 5 and 9 installers\n+into the `dev/installers` directory and install [Rocker](https://github.com/grammarly/rocker).\n \n     make\n \n"
    },
    {
        "commit_hash": "04c3533811a200ebf076117fbe102e2962960d3a",
        "previous_commit_hash": "6039108c610f807a94607e947c541a90bb0ba183",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@ current_path := $(dir $(mkfile_path))\n \n # Builds the development docker file\n docker-build:\n-\tdocker build --tag=$(TAG) ./dev\n+\trocker build --var Tag=$(TAG) --file dev/Rockerfile\n \n # Clean this docker image\n docker-clean:\n"
    },
    {
        "commit_hash": "04c3533811a200ebf076117fbe102e2962960d3a",
        "previous_commit_hash": "6039108c610f807a94607e947c541a90bb0ba183",
        "diff_stats": {
            "additions": 13,
            "deletions": 7
        },
        "diff_content": "@@ -1,21 +1,26 @@\n FROM centos:7\n \n-# Install all supported JDK versions\n-RUN curl -L --header \"Cookie: oraclelicense=accept-securebackup-cookie\" \\\n-\t\thttp://download.oracle.com/otn-pub/java/jdk/1.5.0_22/jdk-1_5_0_22-linux-amd64-rpm.bin \\\n-\t\t-o jdk-1_5_0_22-linux-amd64-rpm.bin \\\n+# Install JDK 5\n+MOUNT installers:/installers\n+RUN cd /installers \\\n \t&& chmod u+x jdk-1_5_0_22-linux-amd64-rpm.bin \\\n-\t&& echo yes | ./jdk-1_5_0_22-linux-amd64-rpm.bin \\\n-\t&& rm -v jdk-1_5_0_22-linux-amd64* \\\n-\t&& yum -y install \\\n+\t&& echo yes | ./jdk-1_5_0_22-linux-amd64-rpm.bin\n+\n+# Install JDK 6, 7, 8\n+RUN yum -y install \\\n \t\tjava-1.6.0-openjdk-devel \\\n \t\tjava-1.7.0-openjdk-devel \\\n \t\tjava-1.8.0-openjdk-devel \\\n \t&& yum clean all\n+\n+# Install JDK 9\n+RUN rpm -Uvh /installers/jdk-9.0.1_linux-x64_bin.rpm\n+\n ENV JAVA5_HOME=/usr/java/jdk1.5.0_22\n ENV JAVA6_HOME=/usr/lib/jvm/java-1.6.0\n ENV JAVA7_HOME=/usr/lib/jvm/java-1.7.0\n ENV JAVA8_HOME=/usr/lib/jvm/java-1.8.0\n+ENV JAVA9_HOME=/usr/java/jdk-9.0.1\n ENV JAVA_HOME=$JAVA8_HOME\n \n # Install Maven\n@@ -29,3 +34,4 @@ COPY toolchains.xml /root/.m2/\n \n RUN mkdir /project\n WORKDIR /project\n+TAG {{ .Tag }}\n"
    },
    {
        "commit_hash": "04c3533811a200ebf076117fbe102e2962960d3a",
        "previous_commit_hash": "6039108c610f807a94607e947c541a90bb0ba183",
        "diff_stats": {
            "additions": 2,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,2 @@\n+*\n+!.gitignore\n"
    },
    {
        "commit_hash": "7f8eadce8ae4063fd0e688daed156aa762b00591",
        "previous_commit_hash": "04c3533811a200ebf076117fbe102e2962960d3a",
        "diff_stats": {
            "additions": 2,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@ package net.orfjackal.retrolambda;\n \n import com.esotericsoftware.minlog.Log;\n import net.orfjackal.retrolambda.files.*;\n-import net.orfjackal.retrolambda.interfaces.*;\n+import net.orfjackal.retrolambda.interfaces.ClassInfo;\n import net.orfjackal.retrolambda.lambdas.*;\n import net.orfjackal.retrolambda.util.Bytecode;\n \n@@ -35,6 +35,7 @@ public class Retrolambda {\n         Log.info(\"Output directory: \" + outputDir);\n         Log.info(\"Classpath:        \" + classpath);\n         Log.info(\"Included files:   \" + (includedFiles != null ? includedFiles.size() : \"all\"));\n+        Log.info(\"JVM version:      \" + System.getProperty(\"java.version\"));\n         Log.info(\"Agent enabled:    \" + PreMain.isAgentLoaded());\n \n         if (!Files.isDirectory(inputDir)) {\n"
    },
    {
        "commit_hash": "56d4e7c5e5a0f83a7836e15d3fac351e84db1f33",
        "previous_commit_hash": "7f8eadce8ae4063fd0e688daed156aa762b00591",
        "diff_stats": {
            "additions": 2,
            "deletions": 1
        },
        "diff_content": "@@ -4,6 +4,7 @@\n \n TAG=luontola/retrolambda-dev\n NAME=wrapping-retrolambda-shell\n+DATE=$(shell date +\"%Y-%m-%d\")\n \n # Directory that this Makefile is in\n mkfile_path := $(abspath $(lastword $(MAKEFILE_LIST)))\n@@ -11,7 +12,7 @@ current_path := $(dir $(mkfile_path))\n \n # Builds the development docker file\n docker-build:\n-\trocker build --var Tag=$(TAG) --file dev/Rockerfile\n+\trocker build --var Tag=$(TAG) --var Date=$(DATE) --file dev/Rockerfile\n \n # Clean this docker image\n docker-clean:\n"
    },
    {
        "commit_hash": "56d4e7c5e5a0f83a7836e15d3fac351e84db1f33",
        "previous_commit_hash": "7f8eadce8ae4063fd0e688daed156aa762b00591",
        "diff_stats": {
            "additions": 2,
            "deletions": 1
        },
        "diff_content": "@@ -34,4 +34,5 @@ COPY toolchains.xml /root/.m2/\n \n RUN mkdir /project\n WORKDIR /project\n-TAG {{ .Tag }}\n+TAG {{ .Tag }}:{{ .Date }}\n+TAG {{ .Tag }}:latest\n"
    },
    {
        "commit_hash": "e89645276159587cd2258e092dc0ddae3a0c4336",
        "previous_commit_hash": "56d4e7c5e5a0f83a7836e15d3fac351e84db1f33",
        "diff_stats": {
            "additions": 0,
            "deletions": 3
        },
        "diff_content": "@@ -24,9 +24,6 @@\n         <option name=\"WHILE_BRACE_FORCE\" value=\"3\" />\n         <option name=\"FOR_BRACE_FORCE\" value=\"3\" />\n         <option name=\"FIELD_ANNOTATION_WRAP\" value=\"0\" />\n-        <MarkdownNavigatorCodeStyleSettings>\n-          <option name=\"RIGHT_MARGIN\" value=\"72\" />\n-        </MarkdownNavigatorCodeStyleSettings>\n         <XML>\n           <option name=\"XML_LEGACY_SETTINGS_IMPORTED\" value=\"true\" />\n         </XML>\n"
    },
    {
        "commit_hash": "e89645276159587cd2258e092dc0ddae3a0c4336",
        "previous_commit_hash": "56d4e7c5e5a0f83a7836e15d3fac351e84db1f33",
        "diff_stats": {
            "additions": 99,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,99 @@\n+<component name=\"ProjectCodeStyleConfiguration\">\n+  <code_scheme name=\"Project\" version=\"173\">\n+    <option name=\"OTHER_INDENT_OPTIONS\">\n+      <value>\n+        <option name=\"TAB_SIZE\" value=\"8\" />\n+      </value>\n+    </option>\n+    <option name=\"LINE_SEPARATOR\" value=\"&#10;\" />\n+    <option name=\"IF_BRACE_FORCE\" value=\"3\" />\n+    <option name=\"DOWHILE_BRACE_FORCE\" value=\"3\" />\n+    <option name=\"WHILE_BRACE_FORCE\" value=\"3\" />\n+    <option name=\"FOR_BRACE_FORCE\" value=\"3\" />\n+    <option name=\"FIELD_ANNOTATION_WRAP\" value=\"0\" />\n+    <HTMLCodeStyleSettings>\n+      <option name=\"HTML_ATTRIBUTE_WRAP\" value=\"0\" />\n+    </HTMLCodeStyleSettings>\n+    <JavaCodeStyleSettings>\n+      <option name=\"CLASS_COUNT_TO_USE_IMPORT_ON_DEMAND\" value=\"2\" />\n+      <option name=\"NAMES_COUNT_TO_USE_IMPORT_ON_DEMAND\" value=\"2\" />\n+    </JavaCodeStyleSettings>\n+    <MarkdownNavigatorCodeStyleSettings>\n+      <option name=\"RIGHT_MARGIN\" value=\"72\" />\n+    </MarkdownNavigatorCodeStyleSettings>\n+    <XML>\n+      <option name=\"XML_LEGACY_SETTINGS_IMPORTED\" value=\"true\" />\n+    </XML>\n+    <ADDITIONAL_INDENT_OPTIONS fileType=\"txt\">\n+      <option name=\"INDENT_SIZE\" value=\"2\" />\n+    </ADDITIONAL_INDENT_OPTIONS>\n+    <codeStyleSettings language=\"ECMA Script Level 4\">\n+      <option name=\"IF_BRACE_FORCE\" value=\"3\" />\n+      <option name=\"DOWHILE_BRACE_FORCE\" value=\"3\" />\n+      <option name=\"WHILE_BRACE_FORCE\" value=\"3\" />\n+      <option name=\"FOR_BRACE_FORCE\" value=\"3\" />\n+    </codeStyleSettings>\n+    <codeStyleSettings language=\"GSP\">\n+      <indentOptions>\n+        <option name=\"INDENT_SIZE\" value=\"2\" />\n+      </indentOptions>\n+    </codeStyleSettings>\n+    <codeStyleSettings language=\"Groovy\">\n+      <option name=\"IF_BRACE_FORCE\" value=\"3\" />\n+      <option name=\"WHILE_BRACE_FORCE\" value=\"3\" />\n+      <option name=\"FOR_BRACE_FORCE\" value=\"3\" />\n+      <option name=\"FIELD_ANNOTATION_WRAP\" value=\"0\" />\n+      <indentOptions>\n+        <option name=\"INDENT_SIZE\" value=\"2\" />\n+      </indentOptions>\n+    </codeStyleSettings>\n+    <codeStyleSettings language=\"JAVA\">\n+      <option name=\"IF_BRACE_FORCE\" value=\"3\" />\n+      <option name=\"DOWHILE_BRACE_FORCE\" value=\"3\" />\n+      <option name=\"WHILE_BRACE_FORCE\" value=\"3\" />\n+      <option name=\"FOR_BRACE_FORCE\" value=\"3\" />\n+      <option name=\"FIELD_ANNOTATION_WRAP\" value=\"0\" />\n+      <indentOptions>\n+        <option name=\"TAB_SIZE\" value=\"8\" />\n+      </indentOptions>\n+    </codeStyleSettings>\n+    <codeStyleSettings language=\"JavaScript\">\n+      <option name=\"IF_BRACE_FORCE\" value=\"3\" />\n+      <option name=\"DOWHILE_BRACE_FORCE\" value=\"3\" />\n+      <option name=\"WHILE_BRACE_FORCE\" value=\"3\" />\n+      <option name=\"FOR_BRACE_FORCE\" value=\"3\" />\n+      <indentOptions>\n+        <option name=\"TAB_SIZE\" value=\"8\" />\n+      </indentOptions>\n+    </codeStyleSettings>\n+    <codeStyleSettings language=\"Scala\">\n+      <option name=\"IF_BRACE_FORCE\" value=\"3\" />\n+      <option name=\"DOWHILE_BRACE_FORCE\" value=\"3\" />\n+      <option name=\"WHILE_BRACE_FORCE\" value=\"3\" />\n+      <option name=\"FOR_BRACE_FORCE\" value=\"3\" />\n+      <option name=\"FIELD_ANNOTATION_WRAP\" value=\"0\" />\n+      <indentOptions>\n+        <option name=\"CONTINUATION_INDENT_SIZE\" value=\"8\" />\n+        <option name=\"TAB_SIZE\" value=\"8\" />\n+      </indentOptions>\n+    </codeStyleSettings>\n+    <codeStyleSettings language=\"TypeScript\">\n+      <option name=\"IF_BRACE_FORCE\" value=\"3\" />\n+      <option name=\"DOWHILE_BRACE_FORCE\" value=\"3\" />\n+      <option name=\"WHILE_BRACE_FORCE\" value=\"3\" />\n+      <option name=\"FOR_BRACE_FORCE\" value=\"3\" />\n+    </codeStyleSettings>\n+    <codeStyleSettings language=\"XML\">\n+      <indentOptions>\n+        <option name=\"TAB_SIZE\" value=\"8\" />\n+      </indentOptions>\n+    </codeStyleSettings>\n+    <codeStyleSettings language=\"ruby\">\n+      <indentOptions>\n+        <option name=\"CONTINUATION_INDENT_SIZE\" value=\"8\" />\n+        <option name=\"TAB_SIZE\" value=\"4\" />\n+        <option name=\"USE_RELATIVE_INDENTS\" value=\"false\" />\n+      </indentOptions>\n+    </codeStyleSettings>\n+  </code_scheme>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "e89645276159587cd2258e092dc0ddae3a0c4336",
        "previous_commit_hash": "56d4e7c5e5a0f83a7836e15d3fac351e84db1f33",
        "diff_stats": {
            "additions": 5,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,5 @@\n+<component name=\"ProjectCodeStyleConfiguration\">\n+  <state>\n+    <option name=\"USE_PER_PROJECT_SETTINGS\" value=\"true\" />\n+  </state>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "e89645276159587cd2258e092dc0ddae3a0c4336",
        "previous_commit_hash": "56d4e7c5e5a0f83a7836e15d3fac351e84db1f33",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -1,6 +1,6 @@\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <module org.jetbrains.idea.maven.project.MavenProjectsManager.isMavenModule=\"true\" type=\"JAVA_MODULE\" version=\"4\">\n-  <component name=\"NewModuleRootManager\" LANGUAGE_LEVEL=\"JDK_1_8\" inherit-compiler-output=\"false\">\n+  <component name=\"NewModuleRootManager\" LANGUAGE_LEVEL=\"JDK_1_8\">\n     <output url=\"file://$MODULE_DIR$/target/classes\" />\n     <output-test url=\"file://$MODULE_DIR$/target/test-classes\" />\n     <content url=\"file://$MODULE_DIR$\">\n"
    },
    {
        "commit_hash": "e89645276159587cd2258e092dc0ddae3a0c4336",
        "previous_commit_hash": "56d4e7c5e5a0f83a7836e15d3fac351e84db1f33",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -1,6 +1,6 @@\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <module org.jetbrains.idea.maven.project.MavenProjectsManager.isMavenModule=\"true\" type=\"JAVA_MODULE\" version=\"4\">\n-  <component name=\"NewModuleRootManager\" LANGUAGE_LEVEL=\"JDK_1_8\" inherit-compiler-output=\"false\">\n+  <component name=\"NewModuleRootManager\" LANGUAGE_LEVEL=\"JDK_1_8\">\n     <output url=\"file://$MODULE_DIR$/target/classes\" />\n     <output-test url=\"file://$MODULE_DIR$/target/test-classes\" />\n     <content url=\"file://$MODULE_DIR$\">\n"
    },
    {
        "commit_hash": "e89645276159587cd2258e092dc0ddae3a0c4336",
        "previous_commit_hash": "56d4e7c5e5a0f83a7836e15d3fac351e84db1f33",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -1,6 +1,6 @@\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <module org.jetbrains.idea.maven.project.MavenProjectsManager.isMavenModule=\"true\" type=\"JAVA_MODULE\" version=\"4\">\n-  <component name=\"NewModuleRootManager\" LANGUAGE_LEVEL=\"JDK_1_8\" inherit-compiler-output=\"false\">\n+  <component name=\"NewModuleRootManager\" LANGUAGE_LEVEL=\"JDK_1_8\">\n     <output url=\"file://$MODULE_DIR$/target/classes\" />\n     <output-test url=\"file://$MODULE_DIR$/target/test-classes\" />\n     <content url=\"file://$MODULE_DIR$\">\n"
    },
    {
        "commit_hash": "e89645276159587cd2258e092dc0ddae3a0c4336",
        "previous_commit_hash": "56d4e7c5e5a0f83a7836e15d3fac351e84db1f33",
        "diff_stats": {
            "additions": 2,
            "deletions": 10
        },
        "diff_content": "@@ -1,6 +1,6 @@\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <module org.jetbrains.idea.maven.project.MavenProjectsManager.isMavenModule=\"true\" type=\"JAVA_MODULE\" version=\"4\">\n-  <component name=\"NewModuleRootManager\" LANGUAGE_LEVEL=\"JDK_1_6\" inherit-compiler-output=\"false\">\n+  <component name=\"NewModuleRootManager\" LANGUAGE_LEVEL=\"JDK_1_6\">\n     <output url=\"file://$MODULE_DIR$/target/classes\" />\n     <output-test url=\"file://$MODULE_DIR$/target/test-classes\" />\n     <content url=\"file://$MODULE_DIR$\">\n@@ -8,15 +8,7 @@\n       <sourceFolder url=\"file://$MODULE_DIR$/src/main/resources\" isTestSource=\"false\" />\n       <sourceFolder url=\"file://$MODULE_DIR$/src/main/java\" isTestSource=\"false\" />\n       <sourceFolder url=\"file://$MODULE_DIR$/src/test/java\" isTestSource=\"true\" />\n-      <excludeFolder url=\"file://$MODULE_DIR$/target/antrun\" />\n-      <excludeFolder url=\"file://$MODULE_DIR$/target/apidocs\" />\n-      <excludeFolder url=\"file://$MODULE_DIR$/target/classes\" />\n-      <excludeFolder url=\"file://$MODULE_DIR$/target/invoker\" />\n-      <excludeFolder url=\"file://$MODULE_DIR$/target/javadoc-bundle-options\" />\n-      <excludeFolder url=\"file://$MODULE_DIR$/target/maven-archiver\" />\n-      <excludeFolder url=\"file://$MODULE_DIR$/target/maven-status\" />\n-      <excludeFolder url=\"file://$MODULE_DIR$/target/surefire-reports\" />\n-      <excludeFolder url=\"file://$MODULE_DIR$/target/test-classes\" />\n+      <excludeFolder url=\"file://$MODULE_DIR$/target\" />\n     </content>\n     <orderEntry type=\"inheritedJdk\" />\n     <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n"
    },
    {
        "commit_hash": "e89645276159587cd2258e092dc0ddae3a0c4336",
        "previous_commit_hash": "56d4e7c5e5a0f83a7836e15d3fac351e84db1f33",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -1,6 +1,6 @@\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <module org.jetbrains.idea.maven.project.MavenProjectsManager.isMavenModule=\"true\" type=\"JAVA_MODULE\" version=\"4\">\n-  <component name=\"NewModuleRootManager\" LANGUAGE_LEVEL=\"JDK_1_8\" inherit-compiler-output=\"false\">\n+  <component name=\"NewModuleRootManager\" LANGUAGE_LEVEL=\"JDK_1_8\">\n     <output url=\"file://$MODULE_DIR$/target/classes\" />\n     <output-test url=\"file://$MODULE_DIR$/target/test-classes\" />\n     <content url=\"file://$MODULE_DIR$\">\n"
    },
    {
        "commit_hash": "79436907a77d5703d457e48ec6a570753e37524b",
        "previous_commit_hash": "e89645276159587cd2258e092dc0ddae3a0c4336",
        "diff_stats": {
            "additions": 3,
            "deletions": 7
        },
        "diff_content": "@@ -1,22 +1,17 @@\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <project version=\"4\">\n   <component name=\"CompilerConfiguration\">\n-    <option name=\"DEFAULT_COMPILER\" value=\"Javac\" />\n-    <resourceExtensions />\n     <wildcardResourcePatterns>\n       <entry name=\"!?*.class\" />\n     </wildcardResourcePatterns>\n     <annotationProcessing>\n-      <profile default=\"true\" name=\"Default\" enabled=\"false\">\n-        <processorPath useClasspath=\"true\" />\n-      </profile>\n-      <profile default=\"false\" name=\"Maven default annotation processors profile\" enabled=\"true\">\n+      <profile name=\"Maven default annotation processors profile\" enabled=\"true\">\n         <sourceOutputDir name=\"target/generated-sources/annotations\" />\n         <sourceTestOutputDir name=\"target/generated-test-sources/test-annotations\" />\n         <outputRelativeToContentRoot value=\"true\" />\n-        <processorPath useClasspath=\"true\" />\n         <module name=\"end-to-end-tests\" />\n         <module name=\"retrolambda\" />\n+        <module name=\"retrolambda-api\" />\n         <module name=\"retrolambda-maven-plugin\" />\n         <module name=\"retrolambda-runtime (1)\" />\n       </profile>\n@@ -26,6 +21,7 @@\n       <module name=\"parent\" target=\"1.8\" />\n       <module name=\"project\" target=\"1.8\" />\n       <module name=\"retrolambda\" target=\"1.8\" />\n+      <module name=\"retrolambda-api\" target=\"1.6\" />\n       <module name=\"retrolambda-maven-plugin\" target=\"1.6\" />\n     </bytecodeTargetLevel>\n   </component>\n"
    },
    {
        "commit_hash": "79436907a77d5703d457e48ec6a570753e37524b",
        "previous_commit_hash": "e89645276159587cd2258e092dc0ddae3a0c4336",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -5,8 +5,8 @@\n     <file url=\"file://$PROJECT_DIR$/end-to-end-tests\" charset=\"UTF-8\" />\n     <file url=\"file://$PROJECT_DIR$/parent\" charset=\"UTF-8\" />\n     <file url=\"file://$PROJECT_DIR$/retrolambda\" charset=\"UTF-8\" />\n+    <file url=\"file://$PROJECT_DIR$/retrolambda-api\" charset=\"UTF-8\" />\n     <file url=\"file://$PROJECT_DIR$/retrolambda-maven-plugin\" charset=\"UTF-8\" />\n     <file url=\"PROJECT\" charset=\"UTF-8\" />\n   </component>\n-</project>\n-\n+</project>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "79436907a77d5703d457e48ec6a570753e37524b",
        "previous_commit_hash": "e89645276159587cd2258e092dc0ddae3a0c4336",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,13 @@\n+<component name=\"libraryTable\">\n+  <library name=\"Maven: org.apache.commons:commons-lang3:3.5\">\n+    <CLASSES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/commons/commons-lang3/3.5/commons-lang3-3.5.jar!/\" />\n+    </CLASSES>\n+    <JAVADOC>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/commons/commons-lang3/3.5/commons-lang3-3.5-javadoc.jar!/\" />\n+    </JAVADOC>\n+    <SOURCES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/commons/commons-lang3/3.5/commons-lang3-3.5-sources.jar!/\" />\n+    </SOURCES>\n+  </library>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "79436907a77d5703d457e48ec6a570753e37524b",
        "previous_commit_hash": "e89645276159587cd2258e092dc0ddae3a0c4336",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -6,6 +6,7 @@\n       <module fileurl=\"file://$PROJECT_DIR$/parent/parent.iml\" filepath=\"$PROJECT_DIR$/parent/parent.iml\" />\n       <module fileurl=\"file://$PROJECT_DIR$/project.iml\" filepath=\"$PROJECT_DIR$/project.iml\" />\n       <module fileurl=\"file://$PROJECT_DIR$/retrolambda/retrolambda.iml\" filepath=\"$PROJECT_DIR$/retrolambda/retrolambda.iml\" />\n+      <module fileurl=\"file://$PROJECT_DIR$/retrolambda-api/retrolambda-api.iml\" filepath=\"$PROJECT_DIR$/retrolambda-api/retrolambda-api.iml\" />\n       <module fileurl=\"file://$PROJECT_DIR$/retrolambda-maven-plugin/retrolambda-maven-plugin.iml\" filepath=\"$PROJECT_DIR$/retrolambda-maven-plugin/retrolambda-maven-plugin.iml\" />\n     </modules>\n   </component>\n"
    },
    {
        "commit_hash": "79436907a77d5703d457e48ec6a570753e37524b",
        "previous_commit_hash": "e89645276159587cd2258e092dc0ddae3a0c4336",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -336,7 +336,7 @@\n \n                 <plugin>\n                     <artifactId>maven-shade-plugin</artifactId>\n-                    <version>2.3</version>\n+                    <version>3.1.0</version>\n                     <configuration>\n                         <!-- Keep the generated POM file out of the base directory -->\n                         <dependencyReducedPomLocation>\n"
    },
    {
        "commit_hash": "79436907a77d5703d457e48ec6a570753e37524b",
        "previous_commit_hash": "e89645276159587cd2258e092dc0ddae3a0c4336",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -18,6 +18,7 @@\n     <modules>\n         <module>parent</module>\n         <module>retrolambda</module>\n+        <module>retrolambda-api</module>\n         <module>retrolambda-maven-plugin</module>\n         <module>end-to-end-tests</module>\n     </modules>\n"
    },
    {
        "commit_hash": "79436907a77d5703d457e48ec6a570753e37524b",
        "previous_commit_hash": "e89645276159587cd2258e092dc0ddae3a0c4336",
        "diff_stats": {
            "additions": 41,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,41 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <parent>\n+        <groupId>net.orfjackal.retrolambda</groupId>\n+        <artifactId>parent</artifactId>\n+        <version>2.5.2-SNAPSHOT</version>\n+        <relativePath>../parent/pom.xml</relativePath>\n+    </parent>\n+\n+    <artifactId>retrolambda-api</artifactId>\n+    <packaging>jar</packaging>\n+\n+    <build>\n+        <plugins>\n+\n+            <plugin>\n+                <artifactId>maven-toolchains-plugin</artifactId>\n+                <configuration>\n+                    <toolchains>\n+                        <jdk>\n+                            <version>1.6</version>\n+                        </jdk>\n+                    </toolchains>\n+                </configuration>\n+            </plugin>\n+\n+            <plugin>\n+                <artifactId>maven-compiler-plugin</artifactId>\n+                <configuration>\n+                    <source>1.6</source>\n+                    <target>1.6</target>\n+                </configuration>\n+            </plugin>\n+\n+        </plugins>\n+    </build>\n+\n+</project>\n"
    },
    {
        "commit_hash": "79436907a77d5703d457e48ec6a570753e37524b",
        "previous_commit_hash": "e89645276159587cd2258e092dc0ddae3a0c4336",
        "diff_stats": {
            "additions": 19,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,19 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<module org.jetbrains.idea.maven.project.MavenProjectsManager.isMavenModule=\"true\" type=\"JAVA_MODULE\" version=\"4\">\n+  <component name=\"NewModuleRootManager\" LANGUAGE_LEVEL=\"JDK_1_6\">\n+    <output url=\"file://$MODULE_DIR$/target/classes\" />\n+    <output-test url=\"file://$MODULE_DIR$/target/test-classes\" />\n+    <content url=\"file://$MODULE_DIR$\">\n+      <sourceFolder url=\"file://$MODULE_DIR$/src/main/java\" isTestSource=\"false\" />\n+      <sourceFolder url=\"file://$MODULE_DIR$/src/test/java\" isTestSource=\"true\" />\n+      <excludeFolder url=\"file://$MODULE_DIR$/target\" />\n+    </content>\n+    <orderEntry type=\"inheritedJdk\" />\n+    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.12\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-library:1.3\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-core:1.3\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.mockito:mockito-core:1.10.19\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.objenesis:objenesis:2.1\" level=\"project\" />\n+  </component>\n+</module>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "79436907a77d5703d457e48ec6a570753e37524b",
        "previous_commit_hash": "e89645276159587cd2258e092dc0ddae3a0c4336",
        "diff_stats": {
            "additions": 19,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,19 @@\n+// Copyright \u00a9 2013-2017 Esko Luontola and other Retrolambda contributors\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.api;\n+\n+public class RetrolambdaApi {\n+\n+    private static final String PREFIX = \"retrolambda.\";\n+    public static final String QUIET = PREFIX + \"quiet\";\n+    public static final String INCLUDED_FILES = PREFIX + \"includedFiles\";\n+    public static final String INCLUDED_FILES_FILE = INCLUDED_FILES + \"File\";\n+    public static final String CLASSPATH = PREFIX + \"classpath\";\n+    public static final String CLASSPATH_FILE = CLASSPATH + \"File\";\n+    public static final String OUTPUT_DIR = PREFIX + \"outputDir\";\n+    public static final String INPUT_DIR = PREFIX + \"inputDir\";\n+    public static final String DEFAULT_METHODS = PREFIX + \"defaultMethods\";\n+    public static final String BYTECODE_VERSION = PREFIX + \"bytecodeVersion\";\n+}\n"
    },
    {
        "commit_hash": "79436907a77d5703d457e48ec6a570753e37524b",
        "previous_commit_hash": "e89645276159587cd2258e092dc0ddae3a0c4336",
        "diff_stats": {
            "additions": 11,
            "deletions": 0
        },
        "diff_content": "@@ -23,6 +23,11 @@\n             <artifactId>retrolambda</artifactId>\n             <version>${project.version}</version>\n         </dependency>\n+        <dependency>\n+            <groupId>net.orfjackal.retrolambda</groupId>\n+            <artifactId>retrolambda-api</artifactId>\n+            <version>${project.version}</version>\n+        </dependency>\n \n         <dependency>\n             <groupId>org.apache.maven</groupId>\n@@ -53,6 +58,12 @@\n             <artifactId>guava</artifactId>\n         </dependency>\n \n+        <dependency>\n+            <groupId>org.apache.commons</groupId>\n+            <artifactId>commons-lang3</artifactId>\n+            <version>3.5</version>\n+        </dependency>\n+\n     </dependencies>\n \n     <build>\n"
    },
    {
        "commit_hash": "79436907a77d5703d457e48ec6a570753e37524b",
        "previous_commit_hash": "e89645276159587cd2258e092dc0ddae3a0c4336",
        "diff_stats": {
            "additions": 2,
            "deletions": 0
        },
        "diff_content": "@@ -15,6 +15,7 @@\n     <orderEntry type=\"module\" module-name=\"retrolambda\" />\n     <orderEntry type=\"library\" name=\"Maven: org.ow2.asm:asm-debug-all:5.2\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: com.esotericsoftware:minlog:1.3\" level=\"project\" />\n+    <orderEntry type=\"module\" module-name=\"retrolambda-api\" />\n     <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-plugin-api:3.0\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-model:3.0\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-artifact:3.0\" level=\"project\" />\n@@ -40,6 +41,7 @@\n     <orderEntry type=\"library\" name=\"Maven: org.sonatype.plexus:plexus-sec-dispatcher:1.3\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.sonatype.plexus:plexus-cipher:1.4\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: com.google.guava:guava:18.0\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.apache.commons:commons-lang3:3.5\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.12\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-library:1.3\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-core:1.3\" level=\"project\" />\n"
    },
    {
        "commit_hash": "79436907a77d5703d457e48ec6a570753e37524b",
        "previous_commit_hash": "e89645276159587cd2258e092dc0ddae3a0c4336",
        "diff_stats": {
            "additions": 14,
            "deletions": 9
        },
        "diff_content": "@@ -7,7 +7,8 @@ package net.orfjackal.retrolambda.maven;\n import com.google.common.base.*;\n import com.google.common.collect.ImmutableMap;\n import com.google.common.io.Files;\n-import net.orfjackal.retrolambda.*;\n+import net.orfjackal.retrolambda.api.RetrolambdaApi;\n+import org.apache.commons.lang3.*;\n import org.apache.maven.artifact.DependencyResolutionRequiredException;\n import org.apache.maven.execution.MavenSession;\n import org.apache.maven.plugin.*;\n@@ -124,7 +125,7 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n     }\n \n     private void validateFork() {\n-        if (!fork && !Main.isRunningJava8()) {\n+        if (!fork && !SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_1_8)) {\n             getLog().warn(\"Maven is not running under Java 8 - forced to fork the process\");\n             fork = true;\n         }\n@@ -134,13 +135,17 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n         getLog().info(\"Processing classes with Retrolambda\");\n         try {\n             Properties p = new Properties();\n-            p.setProperty(SystemPropertiesConfig.BYTECODE_VERSION, \"\" + targetBytecodeVersions.get(target));\n-            p.setProperty(SystemPropertiesConfig.DEFAULT_METHODS, \"\" + defaultMethods);\n-            p.setProperty(SystemPropertiesConfig.QUIET, \"\" + quiet);\n-            p.setProperty(SystemPropertiesConfig.INPUT_DIR, getInputDir().getAbsolutePath());\n-            p.setProperty(SystemPropertiesConfig.OUTPUT_DIR, getOutputDir().getAbsolutePath());\n-            p.setProperty(SystemPropertiesConfig.CLASSPATH, getClasspath());\n-            Retrolambda.run(new SystemPropertiesConfig(p));\n+            p.setProperty(RetrolambdaApi.BYTECODE_VERSION, \"\" + targetBytecodeVersions.get(target));\n+            p.setProperty(RetrolambdaApi.DEFAULT_METHODS, \"\" + defaultMethods);\n+            p.setProperty(RetrolambdaApi.QUIET, \"\" + quiet);\n+            p.setProperty(RetrolambdaApi.INPUT_DIR, getInputDir().getAbsolutePath());\n+            p.setProperty(RetrolambdaApi.OUTPUT_DIR, getOutputDir().getAbsolutePath());\n+            p.setProperty(RetrolambdaApi.CLASSPATH, getClasspath());\n+            // XXX: Retrolambda is compiled for Java 8, but this Maven plugin is compiled for Java 6,\n+            // so we need to break the compile-time dependency using reflection\n+            Class.forName(\"net.orfjackal.retrolambda.Retrolambda\")\n+                    .getMethod(\"run\", Properties.class)\n+                    .invoke(null, p);\n         } catch (Throwable t) {\n             throw new MojoExecutionException(\"Failed to run Retrolambda\", t);\n         }\n"
    },
    {
        "commit_hash": "79436907a77d5703d457e48ec6a570753e37524b",
        "previous_commit_hash": "e89645276159587cd2258e092dc0ddae3a0c4336",
        "diff_stats": {
            "additions": 6,
            "deletions": 32
        },
        "diff_content": "@@ -15,6 +15,12 @@\n \n     <dependencies>\n \n+        <dependency>\n+            <groupId>net.orfjackal.retrolambda</groupId>\n+            <artifactId>retrolambda-api</artifactId>\n+            <version>${project.version}</version>\n+        </dependency>\n+\n         <dependency>\n             <groupId>org.ow2.asm</groupId>\n             <artifactId>asm-debug-all</artifactId>\n@@ -50,38 +56,6 @@\n                 </configuration>\n             </plugin>\n \n-            <!-- To allow the Maven plugin be directly compiled against Retrolamdba,\n-                 we must backport Retrolambda itself to Java 6 -->\n-\n-            <plugin>\n-                <artifactId>maven-antrun-plugin</artifactId>\n-                <executions>\n-                    <execution>\n-                        <id>retrolambda-inception</id>\n-                        <phase>process-classes</phase>\n-                        <goals>\n-                            <goal>run</goal>\n-                        </goals>\n-                        <configuration>\n-                            <target>\n-                                <property name=\"compile_classpath\" refid=\"maven.compile.classpath\"/>\n-                                <exec executable=\"${env.JAVA8_HOME}/bin/java\" failonerror=\"true\">\n-                                    <arg value=\"-Dretrolambda.bytecodeVersion=50\"/>\n-                                    <arg value=\"-Dretrolambda.inputDir=${project.build.outputDirectory}\"/>\n-                                    <arg value=\"-Dretrolambda.classpath=${compile_classpath}\"/>\n-                                    <arg value=\"-Dretrolambda.includedFiles=${project.build.outputDirectory}/net/orfjackal/retrolambda/Main.class${path.separator}${project.build.outputDirectory}/net/orfjackal/retrolambda/Config.class${path.separator}${project.build.outputDirectory}/net/orfjackal/retrolambda/SystemPropertiesConfig.class${path.separator}${project.build.outputDirectory}/net/orfjackal/retrolambda/Retrolambda.class\"/>\n-                                    <arg value=\"-cp\"/>\n-                                    <arg value=\"${project.build.outputDirectory}\"/>\n-                                    <arg value=\"-cp\"/>\n-                                    <arg value=\"${compile_classpath}\"/>\n-                                    <arg value=\"net.orfjackal.retrolambda.Main\"/>\n-                                </exec>\n-                            </target>\n-                        </configuration>\n-                    </execution>\n-                </executions>\n-            </plugin>\n-\n             <!-- Create an uber jar containing all dependencies -->\n \n             <plugin>\n"
    },
    {
        "commit_hash": "79436907a77d5703d457e48ec6a570753e37524b",
        "previous_commit_hash": "e89645276159587cd2258e092dc0ddae3a0c4336",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -10,6 +10,7 @@\n     </content>\n     <orderEntry type=\"inheritedJdk\" />\n     <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n+    <orderEntry type=\"module\" module-name=\"retrolambda-api\" />\n     <orderEntry type=\"library\" name=\"Maven: org.ow2.asm:asm-debug-all:5.2\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: com.google.guava:guava:18.0\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: com.esotericsoftware:minlog:1.3\" level=\"project\" />\n"
    },
    {
        "commit_hash": "79436907a77d5703d457e48ec6a570753e37524b",
        "previous_commit_hash": "e89645276159587cd2258e092dc0ddae3a0c4336",
        "diff_stats": {
            "additions": 8,
            "deletions": 0
        },
        "diff_content": "@@ -17,6 +17,14 @@ import java.util.*;\n \n public class Retrolambda {\n \n+    public static void run(Properties systemProperties) throws Throwable {\n+        SystemPropertiesConfig config = new SystemPropertiesConfig(systemProperties);\n+        if (!config.isFullyConfigured()) {\n+            throw new IllegalArgumentException(\"not fully configured\");\n+        }\n+        run(config);\n+    }\n+\n     public static void run(Config config) throws Throwable {\n         int bytecodeVersion = config.getBytecodeVersion();\n         boolean defaultMethodsEnabled = config.isDefaultMethodsEnabled();\n"
    },
    {
        "commit_hash": "79436907a77d5703d457e48ec6a570753e37524b",
        "previous_commit_hash": "e89645276159587cd2258e092dc0ddae3a0c4336",
        "diff_stats": {
            "additions": 2,
            "deletions": 11
        },
        "diff_content": "@@ -11,18 +11,9 @@ import java.nio.file.*;\n import java.util.*;\n import java.util.stream.*;\n \n-public class SystemPropertiesConfig implements Config {\n+import static net.orfjackal.retrolambda.api.RetrolambdaApi.*;\n \n-    private static final String PREFIX = \"retrolambda.\";\n-    public static final String BYTECODE_VERSION = PREFIX + \"bytecodeVersion\";\n-    public static final String DEFAULT_METHODS = PREFIX + \"defaultMethods\";\n-    public static final String INPUT_DIR = PREFIX + \"inputDir\";\n-    public static final String OUTPUT_DIR = PREFIX + \"outputDir\";\n-    public static final String CLASSPATH = PREFIX + \"classpath\";\n-    public static final String CLASSPATH_FILE = CLASSPATH + \"File\";\n-    public static final String INCLUDED_FILES = PREFIX + \"includedFiles\";\n-    public static final String INCLUDED_FILES_FILE = INCLUDED_FILES + \"File\";\n-    public static final String QUIET = PREFIX + \"quiet\";\n+public class SystemPropertiesConfig implements Config {\n \n     private static final List<String> requiredProperties = new ArrayList<>();\n     private static final Map<String, String> alternativeProperties = new HashMap<>();\n"
    },
    {
        "commit_hash": "79436907a77d5703d457e48ec6a570753e37524b",
        "previous_commit_hash": "e89645276159587cd2258e092dc0ddae3a0c4336",
        "diff_stats": {
            "additions": 6,
            "deletions": 5
        },
        "diff_content": "@@ -1,9 +1,10 @@\n-// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2017 Esko Luontola and other Retrolambda contributors\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n package net.orfjackal.retrolambda;\n \n+import net.orfjackal.retrolambda.api.RetrolambdaApi;\n import org.junit.*;\n import org.junit.rules.TemporaryFolder;\n \n@@ -77,11 +78,11 @@ public class RetrolambdaTest {\n     @Test\n     public void copies_resources_to_output_directory() throws Throwable {\n         Properties p = new Properties();\n-        p.setProperty(SystemPropertiesConfig.INPUT_DIR, inputDir.toString());\n-        p.setProperty(SystemPropertiesConfig.OUTPUT_DIR, outputDir.toString());\n-        p.setProperty(SystemPropertiesConfig.CLASSPATH, \"\");\n+        p.setProperty(RetrolambdaApi.INPUT_DIR, inputDir.toString());\n+        p.setProperty(RetrolambdaApi.OUTPUT_DIR, outputDir.toString());\n+        p.setProperty(RetrolambdaApi.CLASSPATH, \"\");\n \n-        Retrolambda.run(new SystemPropertiesConfig(p));\n+        Retrolambda.run(p);\n \n         assertIsFile(outputDir.resolve(\"file1.txt\"));\n         assertIsFile(outputDir.resolve(\"subdir/file.txt\"));\n"
    },
    {
        "commit_hash": "79436907a77d5703d457e48ec6a570753e37524b",
        "previous_commit_hash": "e89645276159587cd2258e092dc0ddae3a0c4336",
        "diff_stats": {
            "additions": 22,
            "deletions": 21
        },
        "diff_content": "@@ -1,9 +1,10 @@\n-// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2017 Esko Luontola and other Retrolambda contributors\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n package net.orfjackal.retrolambda;\n \n+import net.orfjackal.retrolambda.api.RetrolambdaApi;\n import net.orfjackal.retrolambda.util.Bytecode;\n import org.junit.*;\n import org.junit.rules.*;\n@@ -33,16 +34,16 @@ public class SystemPropertiesConfigTest {\n     public void is_fully_configured_when_required_properties_are_set() {\n         assertThat(\"before\", config().isFullyConfigured(), is(false));\n \n-        systemProperties.setProperty(SystemPropertiesConfig.INPUT_DIR, \"\");\n-        systemProperties.setProperty(SystemPropertiesConfig.CLASSPATH, \"\");\n+        systemProperties.setProperty(RetrolambdaApi.INPUT_DIR, \"\");\n+        systemProperties.setProperty(RetrolambdaApi.CLASSPATH, \"\");\n \n         assertThat(\"after\", config().isFullyConfigured(), is(true));\n     }\n \n     @Test\n     public void can_use_alternative_parameter_instead_of_required_parameter() {\n-        systemProperties.setProperty(SystemPropertiesConfig.INPUT_DIR, \"\");\n-        systemProperties.setProperty(SystemPropertiesConfig.CLASSPATH_FILE, \"\");\n+        systemProperties.setProperty(RetrolambdaApi.INPUT_DIR, \"\");\n+        systemProperties.setProperty(RetrolambdaApi.CLASSPATH_FILE, \"\");\n \n         assertThat(\"is fully configured?\", config().isFullyConfigured(), is(true));\n     }\n@@ -52,7 +53,7 @@ public class SystemPropertiesConfigTest {\n         assertThat(\"defaults to Java 7\", config().getBytecodeVersion(), is(51));\n         assertThat(\"human printable format\", Bytecode.getJavaVersion(config().getBytecodeVersion()), is(\"Java 7\"));\n \n-        systemProperties.setProperty(SystemPropertiesConfig.BYTECODE_VERSION, \"50\");\n+        systemProperties.setProperty(RetrolambdaApi.BYTECODE_VERSION, \"50\");\n         assertThat(\"can override the default\", config().getBytecodeVersion(), is(50));\n         assertThat(\"human printable format\", Bytecode.getJavaVersion(config().getBytecodeVersion()), is(\"Java 6\"));\n     }\n@@ -61,7 +62,7 @@ public class SystemPropertiesConfigTest {\n     public void default_methods() {\n         assertThat(\"defaults to disabled\", config().isDefaultMethodsEnabled(), is(false));\n \n-        systemProperties.setProperty(SystemPropertiesConfig.DEFAULT_METHODS, \"true\");\n+        systemProperties.setProperty(RetrolambdaApi.DEFAULT_METHODS, \"true\");\n         assertThat(\"can override the default\", config().isDefaultMethodsEnabled(), is(true));\n     }\n \n@@ -74,22 +75,22 @@ public class SystemPropertiesConfigTest {\n \n     @Test\n     public void output_directory() {\n-        systemProperties.setProperty(SystemPropertiesConfig.INPUT_DIR, \"input dir\");\n+        systemProperties.setProperty(RetrolambdaApi.INPUT_DIR, \"input dir\");\n         assertThat(\"defaults to input dir\", config().getOutputDir(), is(Paths.get(\"input dir\")));\n \n-        systemProperties.setProperty(SystemPropertiesConfig.OUTPUT_DIR, \"output dir\");\n+        systemProperties.setProperty(RetrolambdaApi.OUTPUT_DIR, \"output dir\");\n         assertThat(\"can override the default\", config().getOutputDir(), is(Paths.get(\"output dir\")));\n     }\n \n     @Test\n     public void classpath() {\n-        systemProperties.setProperty(SystemPropertiesConfig.CLASSPATH, \"\");\n+        systemProperties.setProperty(RetrolambdaApi.CLASSPATH, \"\");\n         assertThat(\"zero values\", config().getClasspath(), is(empty()));\n \n-        systemProperties.setProperty(SystemPropertiesConfig.CLASSPATH, \"one.jar\");\n+        systemProperties.setProperty(RetrolambdaApi.CLASSPATH, \"one.jar\");\n         assertThat(\"one value\", config().getClasspath(), is(Arrays.asList(Paths.get(\"one.jar\"))));\n \n-        systemProperties.setProperty(SystemPropertiesConfig.CLASSPATH, \"one.jar\" + File.pathSeparator + \"two.jar\");\n+        systemProperties.setProperty(RetrolambdaApi.CLASSPATH, \"one.jar\" + File.pathSeparator + \"two.jar\");\n         assertThat(\"multiple values\", config().getClasspath(), is(Arrays.asList(Paths.get(\"one.jar\"), Paths.get(\"two.jar\"))));\n     }\n \n@@ -98,15 +99,15 @@ public class SystemPropertiesConfigTest {\n         Path file = tempDir.newFile(\"classpath.txt\").toPath();\n \n         Files.write(file, Arrays.asList(\"\", \"\", \"\")); // empty lines are ignored\n-        systemProperties.setProperty(SystemPropertiesConfig.CLASSPATH_FILE, file.toString());\n+        systemProperties.setProperty(RetrolambdaApi.CLASSPATH_FILE, file.toString());\n         assertThat(\"zero values\", config().getClasspath(), is(empty()));\n \n         Files.write(file, Arrays.asList(\"one.jar\"));\n-        systemProperties.setProperty(SystemPropertiesConfig.CLASSPATH_FILE, file.toString());\n+        systemProperties.setProperty(RetrolambdaApi.CLASSPATH_FILE, file.toString());\n         assertThat(\"one value\", config().getClasspath(), is(Arrays.asList(Paths.get(\"one.jar\"))));\n \n         Files.write(file, Arrays.asList(\"one.jar\", \"two.jar\"));\n-        systemProperties.setProperty(SystemPropertiesConfig.CLASSPATH_FILE, file.toString());\n+        systemProperties.setProperty(RetrolambdaApi.CLASSPATH_FILE, file.toString());\n         assertThat(\"multiple values\", config().getClasspath(), is(Arrays.asList(Paths.get(\"one.jar\"), Paths.get(\"two.jar\"))));\n     }\n \n@@ -121,13 +122,13 @@ public class SystemPropertiesConfigTest {\n     public void included_files() {\n         assertThat(\"not set\", config().getIncludedFiles(), is(nullValue()));\n \n-        systemProperties.setProperty(SystemPropertiesConfig.INCLUDED_FILES, \"\");\n+        systemProperties.setProperty(RetrolambdaApi.INCLUDED_FILES, \"\");\n         assertThat(\"zero values\", config().getIncludedFiles(), is(empty()));\n \n-        systemProperties.setProperty(SystemPropertiesConfig.INCLUDED_FILES, \"/foo/one.class\");\n+        systemProperties.setProperty(RetrolambdaApi.INCLUDED_FILES, \"/foo/one.class\");\n         assertThat(\"one value\", config().getIncludedFiles(), is(Arrays.asList(Paths.get(\"/foo/one.class\"))));\n \n-        systemProperties.setProperty(SystemPropertiesConfig.INCLUDED_FILES, \"/foo/one.class\" + File.pathSeparator + \"/foo/two.class\");\n+        systemProperties.setProperty(RetrolambdaApi.INCLUDED_FILES, \"/foo/one.class\" + File.pathSeparator + \"/foo/two.class\");\n         assertThat(\"multiple values\", config().getIncludedFiles(), is(Arrays.asList(Paths.get(\"/foo/one.class\"), Paths.get(\"/foo/two.class\"))));\n     }\n \n@@ -137,15 +138,15 @@ public class SystemPropertiesConfigTest {\n         assertThat(\"not set\", config().getIncludedFiles(), is(nullValue()));\n \n         Files.write(file, Arrays.asList(\"\", \"\", \"\")); // empty lines are ignored\n-        systemProperties.setProperty(SystemPropertiesConfig.INCLUDED_FILES_FILE, file.toString());\n+        systemProperties.setProperty(RetrolambdaApi.INCLUDED_FILES_FILE, file.toString());\n         assertThat(\"zero values\", config().getIncludedFiles(), is(empty()));\n \n         Files.write(file, Arrays.asList(\"one.class\"));\n-        systemProperties.setProperty(SystemPropertiesConfig.INCLUDED_FILES_FILE, file.toString());\n+        systemProperties.setProperty(RetrolambdaApi.INCLUDED_FILES_FILE, file.toString());\n         assertThat(\"one value\", config().getIncludedFiles(), is(Arrays.asList(Paths.get(\"one.class\"))));\n \n         Files.write(file, Arrays.asList(\"one.class\", \"two.class\"));\n-        systemProperties.setProperty(SystemPropertiesConfig.INCLUDED_FILES_FILE, file.toString());\n+        systemProperties.setProperty(RetrolambdaApi.INCLUDED_FILES_FILE, file.toString());\n         assertThat(\"multiple values\", config().getIncludedFiles(), is(Arrays.asList(Paths.get(\"one.class\"), Paths.get(\"two.class\"))));\n     }\n }\n"
    },
    {
        "commit_hash": "79436907a77d5703d457e48ec6a570753e37524b",
        "previous_commit_hash": "e89645276159587cd2258e092dc0ddae3a0c4336",
        "diff_stats": {
            "additions": 6,
            "deletions": 0
        },
        "diff_content": "@@ -38,3 +38,9 @@ mvn clean verify \\\n JAVA_HOME=\"$JAVA6_HOME\" mvn clean verify \\\n     --errors \\\n     -P java6\n+\n+# Java 9 has stricter bytecode validation than Java 8,\n+# so make sure that Retrolambda can run under Java 9 (without forking)\n+\n+JAVA_HOME=\"$JAVA9_HOME\" mvn clean verify \\\n+    --errors\n"
    },
    {
        "commit_hash": "c534b941226060e6421a244835e65523ab748795",
        "previous_commit_hash": "79436907a77d5703d457e48ec6a570753e37524b",
        "diff_stats": {
            "additions": 23,
            "deletions": 21
        },
        "diff_content": "@@ -109,10 +109,19 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n     public void execute() throws MojoExecutionException {\n         validateTarget();\n         validateFork();\n+\n+        Properties config = new Properties();\n+        config.setProperty(RetrolambdaApi.BYTECODE_VERSION, \"\" + targetBytecodeVersions.get(target));\n+        config.setProperty(RetrolambdaApi.DEFAULT_METHODS, \"\" + defaultMethods);\n+        config.setProperty(RetrolambdaApi.QUIET, \"\" + quiet);\n+        config.setProperty(RetrolambdaApi.INPUT_DIR, getInputDir().getAbsolutePath());\n+        config.setProperty(RetrolambdaApi.OUTPUT_DIR, getOutputDir().getAbsolutePath());\n+        config.setProperty(RetrolambdaApi.CLASSPATH, getClasspath());\n+\n         if (fork) {\n-            processClassesInForkedProcess();\n+            processClassesInForkedProcess(config);\n         } else {\n-            processClassesInCurrentProcess();\n+            processClassesInCurrentProcess(config);\n         }\n     }\n \n@@ -131,27 +140,20 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n         }\n     }\n \n-    private void processClassesInCurrentProcess() throws MojoExecutionException {\n+    private void processClassesInCurrentProcess(Properties config) throws MojoExecutionException {\n         getLog().info(\"Processing classes with Retrolambda\");\n         try {\n-            Properties p = new Properties();\n-            p.setProperty(RetrolambdaApi.BYTECODE_VERSION, \"\" + targetBytecodeVersions.get(target));\n-            p.setProperty(RetrolambdaApi.DEFAULT_METHODS, \"\" + defaultMethods);\n-            p.setProperty(RetrolambdaApi.QUIET, \"\" + quiet);\n-            p.setProperty(RetrolambdaApi.INPUT_DIR, getInputDir().getAbsolutePath());\n-            p.setProperty(RetrolambdaApi.OUTPUT_DIR, getOutputDir().getAbsolutePath());\n-            p.setProperty(RetrolambdaApi.CLASSPATH, getClasspath());\n             // XXX: Retrolambda is compiled for Java 8, but this Maven plugin is compiled for Java 6,\n             // so we need to break the compile-time dependency using reflection\n             Class.forName(\"net.orfjackal.retrolambda.Retrolambda\")\n                     .getMethod(\"run\", Properties.class)\n-                    .invoke(null, p);\n+                    .invoke(null, config);\n         } catch (Throwable t) {\n             throw new MojoExecutionException(\"Failed to run Retrolambda\", t);\n         }\n     }\n \n-    private void processClassesInForkedProcess() throws MojoExecutionException {\n+    private void processClassesInForkedProcess(Properties config) throws MojoExecutionException {\n         String version = getRetrolambdaVersion();\n         getLog().info(\"Retrieving Retrolambda \" + version);\n         retrieveRetrolambdaJar(version);\n@@ -160,6 +162,14 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n         String retrolambdaJar = getRetrolambdaJarPath();\n         File classpathFile = getClasspathFile();\n         try {\n+            List<Element> args = new ArrayList<Element>();\n+            for (Object key : config.keySet()) {\n+                Object value = config.get(key);\n+                args.add(element(\"arg\", attribute(\"value\", \"-D\" + key + \"=\" + value)));\n+            }\n+            args.add(element(\"arg\", attribute(\"value\", \"-javaagent:\" + retrolambdaJar)));\n+            args.add(element(\"arg\", attribute(\"value\", \"-jar\")));\n+            args.add(element(\"arg\", attribute(\"value\", retrolambdaJar)));\n             executeMojo(\n                     plugin(groupId(\"org.apache.maven.plugins\"),\n                             artifactId(\"maven-antrun-plugin\"),\n@@ -171,15 +181,7 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n                                     attributes(\n                                             attribute(\"executable\", getJavaCommand()),\n                                             attribute(\"failonerror\", \"true\")),\n-                                    element(\"arg\", attribute(\"value\", \"-Dretrolambda.bytecodeVersion=\" + targetBytecodeVersions.get(target))),\n-                                    element(\"arg\", attribute(\"value\", \"-Dretrolambda.defaultMethods=\" + defaultMethods)),\n-                                    element(\"arg\", attribute(\"value\", \"-Dretrolambda.quiet=\" + quiet)),\n-                                    element(\"arg\", attribute(\"value\", \"-Dretrolambda.inputDir=\" + getInputDir().getAbsolutePath())),\n-                                    element(\"arg\", attribute(\"value\", \"-Dretrolambda.outputDir=\" + getOutputDir().getAbsolutePath())),\n-                                    element(\"arg\", attribute(\"value\", \"-Dretrolambda.classpathFile=\" + classpathFile)),\n-                                    element(\"arg\", attribute(\"value\", \"-javaagent:\" + retrolambdaJar)),\n-                                    element(\"arg\", attribute(\"value\", \"-jar\")),\n-                                    element(\"arg\", attribute(\"value\", retrolambdaJar))))),\n+                                    args.toArray(new Element[0])))),\n                     executionEnvironment(project, session, pluginManager));\n         } finally {\n             if (!classpathFile.delete()) {\n"
    },
    {
        "commit_hash": "f6e2d0df13c1bfebff459f224bde01f53c777c55",
        "previous_commit_hash": "c534b941226060e6421a244835e65523ab748795",
        "diff_stats": {
            "additions": 5,
            "deletions": 0
        },
        "diff_content": "@@ -232,6 +232,11 @@ optimizations to that mechanism may break Retrolambda.\n Version History\n ---------------\n \n+### Upcoming\n+\n+- Fixed running Retrolambda under Java 9 \n+  ([Issue #137](https://github.com/orfjackal/retrolambda/issues/137))\n+\n ### Retrolambda 2.5.1 (2017-02-23)\n \n - Fixed the enclosing method attribute of anonymous classes declared inside\n"
    },
    {
        "commit_hash": "69e424c71ecfe815ce1c4534fce82806b0612a8b",
        "previous_commit_hash": "84f372a5b922ddc2432cd8c34d88db672f7095b6",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -55,7 +55,7 @@ To run Retrolambda using Maven, add the following to your pom.xml:\n <plugin>\n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>retrolambda-maven-plugin</artifactId>\n-    <version>2.5.1</version>\n+    <version>2.5.2</version>\n     <executions>\n         <execution>\n             <goals>\n@@ -232,9 +232,9 @@ optimizations to that mechanism may break Retrolambda.\n Version History\n ---------------\n \n-### Upcoming\n+### Retrolambda 2.5.2 (2017-12-28)\n \n-- Fixed running Retrolambda under Java 9 \n+- Fixed running Retrolambda under Java 9\n   ([Issue #137](https://github.com/orfjackal/retrolambda/issues/137))\n - Consider `module-info.class` as a resource and do not try backporting it\n   ([Issue #122](https://github.com/orfjackal/retrolambda/issues/122))\n"
    },
    {
        "commit_hash": "69e424c71ecfe815ce1c4534fce82806b0612a8b",
        "previous_commit_hash": "84f372a5b922ddc2432cd8c34d88db672f7095b6",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.2-SNAPSHOT</version>\n+        <version>2.5.2</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "69e424c71ecfe815ce1c4534fce82806b0612a8b",
        "previous_commit_hash": "84f372a5b922ddc2432cd8c34d88db672f7095b6",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>2.5.2-SNAPSHOT</version>\n+    <version>2.5.2</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "69e424c71ecfe815ce1c4534fce82806b0612a8b",
        "previous_commit_hash": "84f372a5b922ddc2432cd8c34d88db672f7095b6",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.2-SNAPSHOT</version>\n+        <version>2.5.2</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "69e424c71ecfe815ce1c4534fce82806b0612a8b",
        "previous_commit_hash": "84f372a5b922ddc2432cd8c34d88db672f7095b6",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.2-SNAPSHOT</version>\n+        <version>2.5.2</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "69e424c71ecfe815ce1c4534fce82806b0612a8b",
        "previous_commit_hash": "84f372a5b922ddc2432cd8c34d88db672f7095b6",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.2-SNAPSHOT</version>\n+        <version>2.5.2</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "69e424c71ecfe815ce1c4534fce82806b0612a8b",
        "previous_commit_hash": "84f372a5b922ddc2432cd8c34d88db672f7095b6",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.2-SNAPSHOT</version>\n+        <version>2.5.2</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "69e424c71ecfe815ce1c4534fce82806b0612a8b",
        "previous_commit_hash": "84f372a5b922ddc2432cd8c34d88db672f7095b6",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -52,7 +52,7 @@ function next-snapshot-version() {\n APP_NAME=\"Retrolambda\"\n NEXT_VERSION=`next-snapshot-version $RELEASE_VERSION`\n \n-demand-file-contains-line README.md \"### $APP_NAME $RELEASE_VERSION (`date --iso-8601`)\"\n+demand-file-contains-line README.md \"### $APP_NAME $RELEASE_VERSION (`date +%Y-%m-%d`)\"\n \n set -x\n \n"
    },
    {
        "commit_hash": "fae284b3ac3e9cb57f59e60edc57940a4dd0cef4",
        "previous_commit_hash": "69e424c71ecfe815ce1c4534fce82806b0612a8b",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.2</version>\n+        <version>2.5.3-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "fae284b3ac3e9cb57f59e60edc57940a4dd0cef4",
        "previous_commit_hash": "69e424c71ecfe815ce1c4534fce82806b0612a8b",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>2.5.2</version>\n+    <version>2.5.3-SNAPSHOT</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "fae284b3ac3e9cb57f59e60edc57940a4dd0cef4",
        "previous_commit_hash": "69e424c71ecfe815ce1c4534fce82806b0612a8b",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.2</version>\n+        <version>2.5.3-SNAPSHOT</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "fae284b3ac3e9cb57f59e60edc57940a4dd0cef4",
        "previous_commit_hash": "69e424c71ecfe815ce1c4534fce82806b0612a8b",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.2</version>\n+        <version>2.5.3-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "fae284b3ac3e9cb57f59e60edc57940a4dd0cef4",
        "previous_commit_hash": "69e424c71ecfe815ce1c4534fce82806b0612a8b",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.2</version>\n+        <version>2.5.3-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "fae284b3ac3e9cb57f59e60edc57940a4dd0cef4",
        "previous_commit_hash": "69e424c71ecfe815ce1c4534fce82806b0612a8b",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.2</version>\n+        <version>2.5.3-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "0e1957358426d6a14da913803d882702fb43004b",
        "previous_commit_hash": "fae284b3ac3e9cb57f59e60edc57940a4dd0cef4",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -19,6 +19,6 @@ mvn nexus-staging:release \\\n git push origin HEAD\n git push origin --tags\n \n-cd ../retrolambda.pages\n+cd ../retrolambda-site\n ./update-maven-site.sh \"$VERSION\"\n git push\n"
    },
    {
        "commit_hash": "f9a14aacea57da9fdf0ad2772f88bd077523e293",
        "previous_commit_hash": "0e1957358426d6a14da913803d882702fb43004b",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,13 @@\n+<component name=\"libraryTable\">\n+  <library name=\"Maven: jakarta-regexp:jakarta-regexp:1.4\">\n+    <CLASSES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/jakarta-regexp/jakarta-regexp/1.4/jakarta-regexp-1.4.jar!/\" />\n+    </CLASSES>\n+    <JAVADOC>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/jakarta-regexp/jakarta-regexp/1.4/jakarta-regexp-1.4-javadoc.jar!/\" />\n+    </JAVADOC>\n+    <SOURCES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/jakarta-regexp/jakarta-regexp/1.4/jakarta-regexp-1.4-sources.jar!/\" />\n+    </SOURCES>\n+  </library>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "f9a14aacea57da9fdf0ad2772f88bd077523e293",
        "previous_commit_hash": "0e1957358426d6a14da913803d882702fb43004b",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,13 @@\n+<component name=\"libraryTable\">\n+  <library name=\"Maven: org.apache.bcel:bcel:5.2\">\n+    <CLASSES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/bcel/bcel/5.2/bcel-5.2.jar!/\" />\n+    </CLASSES>\n+    <JAVADOC>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/bcel/bcel/5.2/bcel-5.2-javadoc.jar!/\" />\n+    </JAVADOC>\n+    <SOURCES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/bcel/bcel/5.2/bcel-5.2-sources.jar!/\" />\n+    </SOURCES>\n+  </library>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "f9a14aacea57da9fdf0ad2772f88bd077523e293",
        "previous_commit_hash": "0e1957358426d6a14da913803d882702fb43004b",
        "diff_stats": {
            "additions": 2,
            "deletions": 0
        },
        "diff_content": "@@ -15,6 +15,8 @@\n     <orderEntry type=\"library\" name=\"Maven: com.google.code.findbugs:jsr305:1.3.9\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: commons-lang:commons-lang:2.6\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.ow2.asm:asm-debug-all:5.2\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.apache.bcel:bcel:5.2\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: jakarta-regexp:jakarta-regexp:1.4\" level=\"project\" />\n     <orderEntry type=\"module-library\">\n       <library name=\"Maven: net.orfjackal.retrolambda:java-lang-dummies:1\">\n         <CLASSES>\n"
    },
    {
        "commit_hash": "f9a14aacea57da9fdf0ad2772f88bd077523e293",
        "previous_commit_hash": "0e1957358426d6a14da913803d882702fb43004b",
        "diff_stats": {
            "additions": 6,
            "deletions": 0
        },
        "diff_content": "@@ -34,6 +34,12 @@\n             <scope>test</scope>\n         </dependency>\n \n+        <dependency>\n+            <groupId>org.apache.bcel</groupId>\n+            <artifactId>bcel</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+\n         <!-- See net.orfjackal.retrolambda.test.ClasspathTest#ignores_classes_in_explicit_classpath_that_are_under_the_java_package -->\n         <dependency>\n             <groupId>net.orfjackal.retrolambda</groupId>\n"
    },
    {
        "commit_hash": "f9a14aacea57da9fdf0ad2772f88bd077523e293",
        "previous_commit_hash": "0e1957358426d6a14da913803d882702fb43004b",
        "diff_stats": {
            "additions": 8,
            "deletions": 8
        },
        "diff_content": "@@ -5,8 +5,8 @@\n package net.orfjackal.retrolambda.test;\n \n import com.google.common.collect.ImmutableSet;\n+import org.apache.bcel.classfile.*;\n import org.junit.Test;\n-import org.objectweb.asm.ClassReader;\n \n import java.io.IOException;\n import java.lang.reflect.Method;\n@@ -83,14 +83,14 @@ public class LambdaClassesTest {\n \n     @Test\n     public void does_not_contain_references_to_JDK_lambda_classes() throws IOException {\n-        ClassReader cr = new ClassReader(\"net/orfjackal/retrolambda/test/LambdaClassesTest$Dummy1$$Lambda$1\");\n+        ConstantPool constantPool = TestUtil.getConstantPool(\"net/orfjackal/retrolambda/test/LambdaClassesTest$Dummy1$$Lambda$1\");\n \n-        // XXX: fix visitConstantPool and assert the constant pool entries instead of this hack\n-//        TestUtil.visitConstantPool(cr, (item, constant) -> {\n-//        });\n-\n-        String bytecode = new String(cr.b);\n-        assertThat(bytecode, not(containsString(\"java/lang/invoke/LambdaForm\")));\n+        for (Constant constant : constantPool.getConstantPool()) {\n+            if (constant != null) {\n+                String s = constantPool.constantToString(constant);\n+                assertThat(s, not(containsString(\"java/lang/invoke/LambdaForm\")));\n+            }\n+        }\n     }\n \n \n"
    },
    {
        "commit_hash": "f9a14aacea57da9fdf0ad2772f88bd077523e293",
        "previous_commit_hash": "0e1957358426d6a14da913803d882702fb43004b",
        "diff_stats": {
            "additions": 11,
            "deletions": 8
        },
        "diff_content": "@@ -5,12 +5,13 @@\n package net.orfjackal.retrolambda.test;\n \n import net.orfjackal.retrolambda.test.anotherpackage.DifferentPackageBase;\n+import org.apache.bcel.Constants;\n+import org.apache.bcel.classfile.*;\n import org.apache.commons.lang.SystemUtils;\n import org.junit.Test;\n-import org.objectweb.asm.*;\n-import org.objectweb.asm.Type;\n \n import java.io.IOException;\n+import java.lang.reflect.Method;\n import java.lang.reflect.*;\n import java.util.*;\n import java.util.concurrent.Callable;\n@@ -365,13 +366,15 @@ public class LambdaTest extends SuperClass {\n     public void bytecode_constant_pool_will_not_contain_dangling_references_to_MethodHandles() throws IOException {\n         assumeThat(SystemUtils.JAVA_VERSION_FLOAT, is(lessThan(1.7f)));\n \n-        ClassReader cr = new ClassReader(getClass().getName().replace('.', '/'));\n-        TestUtil.visitConstantPool(cr, (item, constant) -> {\n-            if (constant instanceof Type) {\n-                Type type = (Type) constant;\n-                assertThat(\"constant #\" + item, type.getDescriptor(), not(containsString(\"java/lang/invoke\")));\n+        ConstantPool constantPool = TestUtil.getConstantPool(getClass().getName().replace('.', '/'));\n+\n+        for (Constant constant : constantPool.getConstantPool()) {\n+            if (constant != null && constant.getTag() == Constants.CONSTANT_Class) {\n+                String s = constantPool.constantToString(constant);\n+                assertThat(s, not(containsString(\"java/lang/invoke\")));\n+                assertThat(s, not(containsString(\"java.lang.invoke\")));\n             }\n-        });\n+        }\n     }\n }\n \n"
    },
    {
        "commit_hash": "f9a14aacea57da9fdf0ad2772f88bd077523e293",
        "previous_commit_hash": "0e1957358426d6a14da913803d882702fb43004b",
        "diff_stats": {
            "additions": 9,
            "deletions": 16
        },
        "diff_content": "@@ -4,7 +4,9 @@\n \n package net.orfjackal.retrolambda.test;\n \n-import org.objectweb.asm.ClassReader;\n+import org.apache.bcel.classfile.*;\n+\n+import java.io.*;\n \n public class TestUtil {\n \n@@ -33,21 +35,12 @@ public class TestUtil {\n         return itf.getName() + \"$\";\n     }\n \n-    public static void visitConstantPool(ClassReader reader, ConstantPoolVisitor visitor) {\n-        char[] buf = new char[reader.getMaxStringLength()];\n-        for (int item = 0; item < reader.getItemCount(); item++) {\n-            try {\n-                Object constant = reader.readConst(item, buf);\n-                visitor.visit(item, constant);\n-            } catch (Exception e) {\n-                // XXX: constant pool entry which is a Methodref, InvokeDynamic or similar non-plain constant\n-                // FIXME: readConst throws ArrayIndexOutOfBoundsException nearly all the time; how to use it???\n-                //e.printStackTrace();\n-            }\n+    public static ConstantPool getConstantPool(String className) throws IOException {\n+        String fileName = className + \".class\";\n+        try (InputStream in = TestUtil.class.getResourceAsStream(\"/\" + fileName)) {\n+            ClassParser parser = new ClassParser(in, className);\n+            JavaClass javaClass = parser.parse();\n+            return javaClass.getConstantPool();\n         }\n     }\n-\n-    public interface ConstantPoolVisitor {\n-        void visit(int item, Object constant);\n-    }\n }\n"
    },
    {
        "commit_hash": "f9a14aacea57da9fdf0ad2772f88bd077523e293",
        "previous_commit_hash": "0e1957358426d6a14da913803d882702fb43004b",
        "diff_stats": {
            "additions": 7,
            "deletions": 0
        },
        "diff_content": "@@ -90,6 +90,13 @@\n                 <version>5.2</version>\n             </dependency>\n \n+            <dependency>\n+                <groupId>org.apache.bcel</groupId>\n+                <artifactId>bcel</artifactId>\n+                <!-- last version to support Java 5-->\n+                <version>5.2</version>\n+            </dependency>\n+\n             <!-- Testing -->\n \n             <dependency>\n"
    },
    {
        "commit_hash": "eca1e56dee48affcf9279365da8d528b50061768",
        "previous_commit_hash": "f9a14aacea57da9fdf0ad2772f88bd077523e293",
        "diff_stats": {
            "additions": 5,
            "deletions": 0
        },
        "diff_content": "@@ -232,6 +232,11 @@ optimizations to that mechanism may break Retrolambda.\n Version History\n ---------------\n \n+### Upcoming\n+\n+- Copy the `SourceFile` attribute of the enclosing class into the lambda class\n+  ([Issue #131](https://github.com/orfjackal/retrolambda/issues/131))\n+\n ### Retrolambda 2.5.2 (2017-12-28)\n \n - Fixed running Retrolambda under Java 9\n"
    },
    {
        "commit_hash": "eca1e56dee48affcf9279365da8d528b50061768",
        "previous_commit_hash": "f9a14aacea57da9fdf0ad2772f88bd077523e293",
        "diff_stats": {
            "additions": 18,
            "deletions": 0
        },
        "diff_content": "@@ -7,6 +7,8 @@ package net.orfjackal.retrolambda.test;\n import com.google.common.collect.ImmutableSet;\n import org.apache.bcel.classfile.*;\n import org.junit.Test;\n+import org.objectweb.asm.ClassReader;\n+import org.objectweb.asm.tree.ClassNode;\n \n import java.io.IOException;\n import java.lang.reflect.Method;\n@@ -93,6 +95,15 @@ public class LambdaClassesTest {\n         }\n     }\n \n+    @Test\n+    public void has_the_same_source_file_attribute_as_the_enclosing_class() throws IOException {\n+        ClassNode enclosing = readClass(\"net/orfjackal/retrolambda/test/LambdaClassesTest\");\n+        ClassNode lambda = readClass(\"net/orfjackal/retrolambda/test/LambdaClassesTest$Dummy1$$Lambda$1\");\n+\n+        assertThat(lambda.sourceFile, is(notNullValue()));\n+        assertThat(lambda.sourceFile, is(enclosing.sourceFile));\n+    }\n+\n \n     // helpers\n \n@@ -109,4 +120,11 @@ public class LambdaClassesTest {\n         assertThat(\"unexpected overloaded methods\", methods, arrayWithSize(uniqueNames.size()));\n         return uniqueNames;\n     }\n+\n+    private static ClassNode readClass(String name) throws IOException {\n+        ClassReader cr = new ClassReader(name);\n+        ClassNode cls = new ClassNode();\n+        cr.accept(cls, ClassReader.SKIP_CODE);\n+        return cls;\n+    }\n }\n"
    },
    {
        "commit_hash": "eca1e56dee48affcf9279365da8d528b50061768",
        "previous_commit_hash": "f9a14aacea57da9fdf0ad2772f88bd077523e293",
        "diff_stats": {
            "additions": 17,
            "deletions": 0
        },
        "diff_content": "@@ -19,6 +19,9 @@ public class BackportLambdaClass extends ClassVisitor {\n     private Handle implMethod;\n     private Handle accessMethod;\n     private LambdaFactoryMethod factoryMethod;\n+    private EnclosingClass enclosingClass;\n+    private String sourceFile;\n+    private String sourceDebug;\n \n     public BackportLambdaClass(ClassVisitor next) {\n         super(ASM5, next);\n@@ -31,6 +34,7 @@ public class BackportLambdaClass extends ClassVisitor {\n         implMethod = LambdaReifier.getLambdaImplMethod();\n         accessMethod = LambdaReifier.getLambdaAccessMethod();\n         factoryMethod = LambdaReifier.getLambdaFactoryMethod();\n+        enclosingClass = LambdaReifier.getEnclosingClass();\n \n         if (superName.equals(LambdaNaming.MAGIC_LAMBDA_IMPL)) {\n             superName = JAVA_LANG_OBJECT;\n@@ -38,6 +42,15 @@ public class BackportLambdaClass extends ClassVisitor {\n         super.visit(version, access, name, signature, superName, interfaces);\n     }\n \n+    @Override\n+    public void visitSource(String source, String debug) {\n+        // This method will never be called if there is no debug information,\n+        // so we won't call super.visitSource() here but only in visitEnd().\n+        // (Probably this method is never called for any lambda, but never say never.)\n+        sourceFile = source;\n+        sourceDebug = debug;\n+    }\n+\n     @Override\n     public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n         if (name.equals(\"<init>\")) {\n@@ -62,6 +75,10 @@ public class BackportLambdaClass extends ClassVisitor {\n             makeSingleton();\n         }\n         generateFactoryMethod();\n+        if (sourceFile == null) {\n+            sourceFile = enclosingClass.sourceFile;\n+        }\n+        super.visitSource(sourceFile, sourceDebug);\n         super.visitEnd();\n     }\n \n"
    },
    {
        "commit_hash": "eca1e56dee48affcf9279365da8d528b50061768",
        "previous_commit_hash": "f9a14aacea57da9fdf0ad2772f88bd077523e293",
        "diff_stats": {
            "additions": 8,
            "deletions": 1
        },
        "diff_content": "@@ -23,6 +23,7 @@ public class BackportLambdaInvocations extends ClassVisitor {\n     private String className;\n     private final ClassAnalyzer analyzer;\n     private final Map<Handle, Handle> lambdaAccessToImplMethods = new LinkedHashMap<>();\n+    private final EnclosingClass enclosingClass = new EnclosingClass();\n \n     public BackportLambdaInvocations(ClassVisitor next, ClassAnalyzer analyzer) {\n         super(ASM5, next);\n@@ -37,6 +38,12 @@ public class BackportLambdaInvocations extends ClassVisitor {\n         super.visit(version, access, name, signature, superName, interfaces);\n     }\n \n+    @Override\n+    public void visitSource(String source, String debug) {\n+        enclosingClass.sourceFile = source;\n+        super.visitSource(source, debug);\n+    }\n+\n     private static void resetLambdaClassSequenceNumber() {\n         try {\n             Field counterField = Class.forName(\"java.lang.invoke.InnerClassLambdaMetafactory\").getDeclaredField(\"counter\");\n@@ -184,7 +191,7 @@ public class BackportLambdaInvocations extends ClassVisitor {\n             Handle implMethod = (Handle) bsmArgs[1];\n             Handle accessMethod = getLambdaAccessMethod(implMethod);\n \n-            LambdaFactoryMethod factory = LambdaReifier.reifyLambdaClass(implMethod, accessMethod,\n+            LambdaFactoryMethod factory = LambdaReifier.reifyLambdaClass(enclosingClass, implMethod, accessMethod,\n                     invoker, invokedName, invokedType, bsm, bsmArgs);\n             super.visitMethodInsn(INVOKESTATIC, factory.getOwner(), factory.getName(), factory.getDesc(), false);\n         }\n"
    },
    {
        "commit_hash": "eca1e56dee48affcf9279365da8d528b50061768",
        "previous_commit_hash": "f9a14aacea57da9fdf0ad2772f88bd077523e293",
        "diff_stats": {
            "additions": 10,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,10 @@\n+// Copyright \u00a9 2013-2017 Esko Luontola and other Retrolambda contributors\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.lambdas;\n+\n+public class EnclosingClass {\n+\n+    public String sourceFile;\n+}\n"
    },
    {
        "commit_hash": "eca1e56dee48affcf9279365da8d528b50061768",
        "previous_commit_hash": "f9a14aacea57da9fdf0ad2772f88bd077523e293",
        "diff_stats": {
            "additions": 13,
            "deletions": 2
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2017 Esko Luontola and other Retrolambda contributors\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -22,14 +22,16 @@ public class LambdaReifier {\n     private static final BlockingDeque<Class<?>> currentInvoker = new LinkedBlockingDeque<>(1);\n     private static final BlockingDeque<Type> currentInvokedType = new LinkedBlockingDeque<>(1);\n     private static final BlockingDeque<String> currentLambdaClass = new LinkedBlockingDeque<>(1);\n+    private static final BlockingDeque<EnclosingClass> currentEnclosingClass = new LinkedBlockingDeque<>(1);\n \n-    public static LambdaFactoryMethod reifyLambdaClass(Handle lambdaImplMethod, Handle lambdaAccessMethod,\n+    public static LambdaFactoryMethod reifyLambdaClass(EnclosingClass enclosingClass, Handle lambdaImplMethod, Handle lambdaAccessMethod,\n                                                        Class<?> invoker, String invokedName, Type invokedType, Handle bsm, Object[] bsmArgs) {\n         try {\n             setLambdaImplMethod(lambdaImplMethod);\n             setLambdaAccessMethod(lambdaAccessMethod);\n             setInvoker(invoker);\n             setInvokedType(invokedType);\n+            setEnclosingClass(enclosingClass);\n \n             // Causes the lambda class to be loaded. Retrolambda's Java agent\n             // will detect it, save it to a file and tell us (via the globals\n@@ -65,6 +67,10 @@ public class LambdaReifier {\n         currentLambdaClass.push(lambdaClass);\n     }\n \n+    public static void setEnclosingClass(EnclosingClass enclosingClass) {\n+        currentEnclosingClass.push(enclosingClass);\n+    }\n+\n     public static boolean isLambdaClassToReify(String className) {\n         Class<?> invoker = currentInvoker.peekFirst();\n         return invoker != null\n@@ -80,6 +86,10 @@ public class LambdaReifier {\n         return currentLambdaAccessMethod.getFirst();\n     }\n \n+    public static EnclosingClass getEnclosingClass() {\n+        return currentEnclosingClass.getFirst();\n+    }\n+\n     public static LambdaFactoryMethod getLambdaFactoryMethod() {\n         String lambdaClass = currentLambdaClass.getFirst();\n         Type invokedType = currentInvokedType.getFirst();\n@@ -92,6 +102,7 @@ public class LambdaReifier {\n         currentInvoker.clear();\n         currentInvokedType.clear();\n         currentLambdaClass.clear();\n+        currentEnclosingClass.clear();\n     }\n \n     private static CallSite callBootstrapMethod(Class<?> invoker, String invokedName, Type invokedType, Handle bsm, Object[] bsmArgs) throws Throwable {\n"
    },
    {
        "commit_hash": "fa120d0494bb8ed09e7c0a24cdd431f8123be8e4",
        "previous_commit_hash": "eca1e56dee48affcf9279365da8d528b50061768",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -55,7 +55,7 @@ To run Retrolambda using Maven, add the following to your pom.xml:\n <plugin>\n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>retrolambda-maven-plugin</artifactId>\n-    <version>2.5.2</version>\n+    <version>2.5.3</version>\n     <executions>\n         <execution>\n             <goals>\n@@ -232,7 +232,7 @@ optimizations to that mechanism may break Retrolambda.\n Version History\n ---------------\n \n-### Upcoming\n+### Retrolambda 2.5.3 (2017-12-28)\n \n - Copy the `SourceFile` attribute of the enclosing class into the lambda class\n   ([Issue #131](https://github.com/orfjackal/retrolambda/issues/131))\n"
    },
    {
        "commit_hash": "fa120d0494bb8ed09e7c0a24cdd431f8123be8e4",
        "previous_commit_hash": "eca1e56dee48affcf9279365da8d528b50061768",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.3-SNAPSHOT</version>\n+        <version>2.5.3</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "fa120d0494bb8ed09e7c0a24cdd431f8123be8e4",
        "previous_commit_hash": "eca1e56dee48affcf9279365da8d528b50061768",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>2.5.3-SNAPSHOT</version>\n+    <version>2.5.3</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "fa120d0494bb8ed09e7c0a24cdd431f8123be8e4",
        "previous_commit_hash": "eca1e56dee48affcf9279365da8d528b50061768",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.3-SNAPSHOT</version>\n+        <version>2.5.3</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "fa120d0494bb8ed09e7c0a24cdd431f8123be8e4",
        "previous_commit_hash": "eca1e56dee48affcf9279365da8d528b50061768",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.3-SNAPSHOT</version>\n+        <version>2.5.3</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "fa120d0494bb8ed09e7c0a24cdd431f8123be8e4",
        "previous_commit_hash": "eca1e56dee48affcf9279365da8d528b50061768",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.3-SNAPSHOT</version>\n+        <version>2.5.3</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "fa120d0494bb8ed09e7c0a24cdd431f8123be8e4",
        "previous_commit_hash": "eca1e56dee48affcf9279365da8d528b50061768",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.3-SNAPSHOT</version>\n+        <version>2.5.3</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "29e39c779a322dcaca9d4c592a67525ad989c535",
        "previous_commit_hash": "fa120d0494bb8ed09e7c0a24cdd431f8123be8e4",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.3</version>\n+        <version>2.5.4-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "29e39c779a322dcaca9d4c592a67525ad989c535",
        "previous_commit_hash": "fa120d0494bb8ed09e7c0a24cdd431f8123be8e4",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>2.5.3</version>\n+    <version>2.5.4-SNAPSHOT</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "29e39c779a322dcaca9d4c592a67525ad989c535",
        "previous_commit_hash": "fa120d0494bb8ed09e7c0a24cdd431f8123be8e4",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.3</version>\n+        <version>2.5.4-SNAPSHOT</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "29e39c779a322dcaca9d4c592a67525ad989c535",
        "previous_commit_hash": "fa120d0494bb8ed09e7c0a24cdd431f8123be8e4",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.3</version>\n+        <version>2.5.4-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "29e39c779a322dcaca9d4c592a67525ad989c535",
        "previous_commit_hash": "fa120d0494bb8ed09e7c0a24cdd431f8123be8e4",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.3</version>\n+        <version>2.5.4-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "29e39c779a322dcaca9d4c592a67525ad989c535",
        "previous_commit_hash": "fa120d0494bb8ed09e7c0a24cdd431f8123be8e4",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.3</version>\n+        <version>2.5.4-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "cdee3ac8e7a005637936252c595d737d2877815c",
        "previous_commit_hash": "29e39c779a322dcaca9d4c592a67525ad989c535",
        "diff_stats": {
            "additions": 5,
            "deletions": 0
        },
        "diff_content": "@@ -228,6 +228,11 @@ May break if a future JDK 8 build stops generating a new class for each\n that `java.lang.invoke.LambdaMetafactory` generates dynamically, so\n optimizations to that mechanism may break Retrolambda.\n \n+Java 9 and higher are not supported; just build your project with Java 8. The\n+new JDKs mostly just add new APIs, which you anyways wouldn't be able to use on\n+on older JREs. To backport new language features, create a new tool for it\n+yourself or pay someone to do it, if you think it's worth the effort. ;)\n+\n \n Version History\n ---------------\n"
    },
    {
        "commit_hash": "89e7debc531847cd0236292d2c027257c0f2628e",
        "previous_commit_hash": "cdee3ac8e7a005637936252c595d737d2877815c",
        "diff_stats": {
            "additions": 5,
            "deletions": 0
        },
        "diff_content": "@@ -237,6 +237,11 @@ yourself or pay someone to do it, if you think it's worth the effort. ;)\n Version History\n ---------------\n \n+### Upcoming\n+\n+- Fix regression in Maven plugin; use classpathFile\n+  ([Issue #141](https://github.com/orfjackal/retrolambda/issues/141))\n+\n ### Retrolambda 2.5.3 (2017-12-28)\n \n - Copy the `SourceFile` attribute of the enclosing class into the lambda class\n"
    },
    {
        "commit_hash": "89e7debc531847cd0236292d2c027257c0f2628e",
        "previous_commit_hash": "cdee3ac8e7a005637936252c595d737d2877815c",
        "diff_stats": {
            "additions": 5,
            "deletions": 1
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013-2017 Esko Luontola and other Retrolambda contributors\n+// Copyright \u00a9 2013-2018 Esko Luontola and other Retrolambda contributors\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -165,6 +165,10 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n             List<Element> args = new ArrayList<Element>();\n             for (Object key : config.keySet()) {\n                 Object value = config.get(key);\n+                if (key.equals(RetrolambdaApi.CLASSPATH)) {\n+                    key = RetrolambdaApi.CLASSPATH_FILE;\n+                    value = classpathFile.getAbsolutePath();\n+                }\n                 args.add(element(\"arg\", attribute(\"value\", \"-D\" + key + \"=\" + value)));\n             }\n             args.add(element(\"arg\", attribute(\"value\", \"-javaagent:\" + retrolambdaJar)));\n"
    },
    {
        "commit_hash": "8475def9412ed31ec7b59a075ff2d925b16f71c9",
        "previous_commit_hash": "89e7debc531847cd0236292d2c027257c0f2628e",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -55,7 +55,7 @@ To run Retrolambda using Maven, add the following to your pom.xml:\n <plugin>\n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>retrolambda-maven-plugin</artifactId>\n-    <version>2.5.3</version>\n+    <version>2.5.4</version>\n     <executions>\n         <execution>\n             <goals>\n@@ -237,7 +237,7 @@ yourself or pay someone to do it, if you think it's worth the effort. ;)\n Version History\n ---------------\n \n-### Upcoming\n+### Retrolambda 2.5.4 (2018-05-30)\n \n - Fix regression in Maven plugin; use classpathFile\n   ([Issue #141](https://github.com/orfjackal/retrolambda/issues/141))\n"
    },
    {
        "commit_hash": "8475def9412ed31ec7b59a075ff2d925b16f71c9",
        "previous_commit_hash": "89e7debc531847cd0236292d2c027257c0f2628e",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.4-SNAPSHOT</version>\n+        <version>2.5.4</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "8475def9412ed31ec7b59a075ff2d925b16f71c9",
        "previous_commit_hash": "89e7debc531847cd0236292d2c027257c0f2628e",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>2.5.4-SNAPSHOT</version>\n+    <version>2.5.4</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "8475def9412ed31ec7b59a075ff2d925b16f71c9",
        "previous_commit_hash": "89e7debc531847cd0236292d2c027257c0f2628e",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.4-SNAPSHOT</version>\n+        <version>2.5.4</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "8475def9412ed31ec7b59a075ff2d925b16f71c9",
        "previous_commit_hash": "89e7debc531847cd0236292d2c027257c0f2628e",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.4-SNAPSHOT</version>\n+        <version>2.5.4</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "8475def9412ed31ec7b59a075ff2d925b16f71c9",
        "previous_commit_hash": "89e7debc531847cd0236292d2c027257c0f2628e",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.4-SNAPSHOT</version>\n+        <version>2.5.4</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "8475def9412ed31ec7b59a075ff2d925b16f71c9",
        "previous_commit_hash": "89e7debc531847cd0236292d2c027257c0f2628e",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.4-SNAPSHOT</version>\n+        <version>2.5.4</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "54ac5e8c79825f20462be7ce344649913fe134d1",
        "previous_commit_hash": "8475def9412ed31ec7b59a075ff2d925b16f71c9",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.4</version>\n+        <version>2.5.5-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "54ac5e8c79825f20462be7ce344649913fe134d1",
        "previous_commit_hash": "8475def9412ed31ec7b59a075ff2d925b16f71c9",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>2.5.4</version>\n+    <version>2.5.5-SNAPSHOT</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "54ac5e8c79825f20462be7ce344649913fe134d1",
        "previous_commit_hash": "8475def9412ed31ec7b59a075ff2d925b16f71c9",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.4</version>\n+        <version>2.5.5-SNAPSHOT</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "54ac5e8c79825f20462be7ce344649913fe134d1",
        "previous_commit_hash": "8475def9412ed31ec7b59a075ff2d925b16f71c9",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.4</version>\n+        <version>2.5.5-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "54ac5e8c79825f20462be7ce344649913fe134d1",
        "previous_commit_hash": "8475def9412ed31ec7b59a075ff2d925b16f71c9",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.4</version>\n+        <version>2.5.5-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "54ac5e8c79825f20462be7ce344649913fe134d1",
        "previous_commit_hash": "8475def9412ed31ec7b59a075ff2d925b16f71c9",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.4</version>\n+        <version>2.5.5-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "5afee5586c635ebc629e94fcd377a34c6ac9a0d3",
        "previous_commit_hash": "54ac5e8c79825f20462be7ce344649913fe134d1",
        "diff_stats": {
            "additions": 56,
            "deletions": 56
        },
        "diff_content": "@@ -67,8 +67,8 @@ To run Retrolambda using Maven, add the following to your pom.xml:\n </plugin>\n ```\n \n-See the [plugin documentation](http://orfjackal.github.io/retrolambda/retrolambda-maven-plugin/plugin-info.html)\n-for all possible parameters. There is also a usage example in [end-to-end-tests/pom.xml](https://github.com/orfjackal/retrolambda/blob/master/end-to-end-tests/pom.xml)\n+See the [plugin documentation](https://luontola.github.io/retrolambda/retrolambda-maven-plugin/plugin-info.html)\n+for all possible parameters. There is also a usage example in [end-to-end-tests/pom.xml](https://github.com/luontola/retrolambda/blob/master/end-to-end-tests/pom.xml)\n \n \n ### Gradle Plugin\n@@ -94,7 +94,7 @@ Usage: java -Dretrolambda.inputDir=? -Dretrolambda.classpath=? [-javaagent:retro\n \n Retrolambda takes Java 8 classes and backports lambda expressions and\n some other language features to work on Java 7, 6 or 5.\n-Web site: https://github.com/orfjackal/retrolambda\n+Web site: https://github.com/luontola/retrolambda\n \n Copyright (c) 2013-2017  Esko Luontola and other Retrolambda contributors\n This software is released under the Apache License 2.0.\n@@ -240,170 +240,170 @@ Version History\n ### Retrolambda 2.5.4 (2018-05-30)\n \n - Fix regression in Maven plugin; use classpathFile\n-  ([Issue #141](https://github.com/orfjackal/retrolambda/issues/141))\n+  ([Issue #141](https://github.com/luontola/retrolambda/issues/141))\n \n ### Retrolambda 2.5.3 (2017-12-28)\n \n - Copy the `SourceFile` attribute of the enclosing class into the lambda class\n-  ([Issue #131](https://github.com/orfjackal/retrolambda/issues/131))\n+  ([Issue #131](https://github.com/luontola/retrolambda/issues/131))\n \n ### Retrolambda 2.5.2 (2017-12-28)\n \n - Fixed running Retrolambda under Java 9\n-  ([Issue #137](https://github.com/orfjackal/retrolambda/issues/137))\n+  ([Issue #137](https://github.com/luontola/retrolambda/issues/137))\n - Consider `module-info.class` as a resource and do not try backporting it\n-  ([Issue #122](https://github.com/orfjackal/retrolambda/issues/122))\n+  ([Issue #122](https://github.com/luontola/retrolambda/issues/122))\n \n ### Retrolambda 2.5.1 (2017-02-23)\n \n - Fixed the enclosing method attribute of anonymous classes declared inside\n   lambda expressions\n-  ([Issue #121](https://github.com/orfjackal/retrolambda/issues/121))\n+  ([Issue #121](https://github.com/luontola/retrolambda/issues/121))\n \n ### Retrolambda 2.5.0 (2017-01-22)\n \n - Fixed lambda expressions in subclasses accidentally overriding lambda\n   expressions in their parent. If you are using version 2.2.0 or greater,\n   it is strongly recommended to upgrade to this version.\n-  ([Issue #109](https://github.com/orfjackal/retrolambda/issues/109))\n+  ([Issue #109](https://github.com/luontola/retrolambda/issues/109))\n \n ### Retrolambda 2.4.0 (2017-01-11)\n \n - Added an option to reduce the amount of logging\n-  ([Issue #103](https://github.com/orfjackal/retrolambda/issues/103))\n+  ([Issue #103](https://github.com/luontola/retrolambda/issues/103))\n - Removes `java/lang/invoke/LambdaForm$Hidden` annotations from the generated \n   lambda classes to avoid issues with ProGuard \n-  ([Pull request #118](https://github.com/orfjackal/retrolambda/pull/118))\n+  ([Pull request #118](https://github.com/luontola/retrolambda/pull/118))\n - Fixed backporting classes in the default package\n-  ([Issue #105](https://github.com/orfjackal/retrolambda/issues/105))\n+  ([Issue #105](https://github.com/luontola/retrolambda/issues/105))\n - Fixed backporting `java.lang.Object` itself\n-  ([Pull request #113](https://github.com/orfjackal/retrolambda/pull/113))\n+  ([Pull request #113](https://github.com/luontola/retrolambda/pull/113))\n \n ### Retrolambda 2.3.0 (2016-04-30)\n \n - Optimize generated code to reduce method count\n-  ([Issue #81](https://github.com/orfjackal/retrolambda/issues/81))\n+  ([Issue #81](https://github.com/luontola/retrolambda/issues/81))\n     - Alter when accessor methods are generated\n-      ([Pull request #84](https://github.com/orfjackal/retrolambda/pull/84))\n+      ([Pull request #84](https://github.com/luontola/retrolambda/pull/84))\n     - Remove NEW, DUP instructions when changing NEWINVOKESPECIAL to INVOKESTATIC\n-      ([Pull request #85](https://github.com/orfjackal/retrolambda/pull/85))\n+      ([Pull request #85](https://github.com/luontola/retrolambda/pull/85))\n     - Skip access method when lambda body method can be promoted\n-      ([Pull request #86](https://github.com/orfjackal/retrolambda/pull/86))\n+      ([Pull request #86](https://github.com/luontola/retrolambda/pull/86))\n - Fix method reference to protected method in base class in other package\n   failing with IllegalAccessError\n-  ([Issue #89](https://github.com/orfjackal/retrolambda/issues/89))\n+  ([Issue #89](https://github.com/luontola/retrolambda/issues/89))\n \n ### Retrolambda 2.2.0 (2016-04-29)\n \n - Backports calls to `Objects.requireNonNull`, improving JDK 9 support\n-  ([Issue #75](https://github.com/orfjackal/retrolambda/issues/75))\n+  ([Issue #75](https://github.com/luontola/retrolambda/issues/75))\n - Optimize generated code to reduce method count\n-  ([Issue #81](https://github.com/orfjackal/retrolambda/issues/81))\n+  ([Issue #81](https://github.com/luontola/retrolambda/issues/81))\n     - Detect and omit the JVM's lambda factory method\n-      ([Pull request #82](https://github.com/orfjackal/retrolambda/pull/82))\n+      ([Pull request #82](https://github.com/luontola/retrolambda/pull/82))\n \n \n ### Retrolambda 2.1.0 (2015-12-19)\n \n - Added the `-Dretrolambda.classpathFile` parameter to avoid\n   the command line length limit\n-  ([Issue #70](https://github.com/orfjackal/retrolambda/issues/70))\n+  ([Issue #70](https://github.com/luontola/retrolambda/issues/70))\n - Added the `-Dretrolambda.includedFilesFile` parameter to avoid\n   the command line length limit\n-  ([Pull request #74](https://github.com/orfjackal/retrolambda/pull/74))\n+  ([Pull request #74](https://github.com/luontola/retrolambda/pull/74))\n - Made it easier to invoke Retrolambda as a library. Made `Config`\n   an interface and fixed an assumption of using the default file system\n-  ([Pull request #71](https://github.com/orfjackal/retrolambda/pull/71))\n+  ([Pull request #71](https://github.com/luontola/retrolambda/pull/71))\n - Don't create a companion class when an interface has just\n   a static initialization block because of constant fields\n-  ([Issue #66](https://github.com/orfjackal/retrolambda/issues/66))\n+  ([Issue #66](https://github.com/luontola/retrolambda/issues/66))\n - Improved error messages: report the name of the class or lambda method which\n   crashed Retrolambda\n-  ([Issue #69](https://github.com/orfjackal/retrolambda/issues/69))\n+  ([Issue #69](https://github.com/luontola/retrolambda/issues/69))\n \n ### Retrolambda 2.0.6 (2015-09-06)\n \n - Fixed method references to constructors causing VerifyError on Android\n-  ([Issue #67](https://github.com/orfjackal/retrolambda/issues/67))\n+  ([Issue #67](https://github.com/luontola/retrolambda/issues/67))\n \n ### Retrolambda 2.0.5 (2015-07-19)\n \n - Support for lambdas with marker interfaces\n-  ([Issue #62](https://github.com/orfjackal/retrolambda/issues/62))\n+  ([Issue #62](https://github.com/luontola/retrolambda/issues/62))\n \n ### Retrolambda 2.0.4 (2015-07-08)\n \n - Fixed a compile error when calling default methods from another module\n-  ([Issue #56](https://github.com/orfjackal/retrolambda/issues/56))\n+  ([Issue #56](https://github.com/luontola/retrolambda/issues/56))\n - Fixed method references to constructors of the current class\n-  ([Issue #60](https://github.com/orfjackal/retrolambda/issues/60))\n+  ([Issue #60](https://github.com/luontola/retrolambda/issues/60))\n - Removes bytecode references to `java.lang.invoke.MethodHandles.Lookup` on\n   Java 6 and older\n-  ([Issue #61](https://github.com/orfjackal/retrolambda/issues/61))\n+  ([Issue #61](https://github.com/luontola/retrolambda/issues/61))\n - Copies non-class files from input to output directory\n-  ([Issue #54](https://github.com/orfjackal/retrolambda/issues/54))\n+  ([Issue #54](https://github.com/luontola/retrolambda/issues/54))\n \n ### Retrolambda 2.0.3 (2015-06-07)\n \n - Fixed Retrolambda generating stack map frames for Java 5 bytecode,\n   causing some bytecode tools to fail\n-  ([Issue #55](https://github.com/orfjackal/retrolambda/issues/55))\n+  ([Issue #55](https://github.com/luontola/retrolambda/issues/55))\n \n ### Retrolambda 2.0.2 (2015-04-14)\n \n - Fixed a hack which caused lambdas in interfaces to be backported twice,\n   possibly producing broken method calls in the bytecode\n-  ([Issue #48](https://github.com/orfjackal/retrolambda/issues/48))\n+  ([Issue #48](https://github.com/luontola/retrolambda/issues/48))\n - Fixed the handling of non-static lambda implementation methods in\n   interfaces, i.e. lambdas which capture `this`\n-  ([Issue #48](https://github.com/orfjackal/retrolambda/issues/48))\n+  ([Issue #48](https://github.com/luontola/retrolambda/issues/48))\n - Removes generic method signatures from the default method implementation\n   methods which are placed in the interface's companion class, to avoid\n   them getting out of sync with their erased method descriptors\n-  ([Issue #48](https://github.com/orfjackal/retrolambda/issues/48))\n+  ([Issue #48](https://github.com/luontola/retrolambda/issues/48))\n \n ### Retrolambda 2.0.1 (2015-04-06)\n \n - Fixed not backporting lambda expressions in default methods and static\n   methods on interfaces\n-  ([Issue #48](https://github.com/orfjackal/retrolambda/issues/48))\n+  ([Issue #48](https://github.com/luontola/retrolambda/issues/48))\n \n ### Retrolambda 2.0.0 (2015-03-28)\n \n - Backports default methods and static methods on interfaces\n-  ([Issue #31](https://github.com/orfjackal/retrolambda/issues/31))\n+  ([Issue #31](https://github.com/luontola/retrolambda/issues/31))\n \n ### Retrolambda 1.8.1 (2015-01-06)\n \n - Backports lambda expressions in an interface's constant initializer\n-  ([Issue #42](https://github.com/orfjackal/retrolambda/issues/42))\n+  ([Issue #42](https://github.com/luontola/retrolambda/issues/42))\n \n ### Retrolambda 1.8.0 (2014-11-16)\n \n - Backports try-with-resources statements to Java 6 and older by removing\n   calls to `Throwable.addSuppressed`\n-  ([Issue #38](https://github.com/orfjackal/retrolambda/issues/38))\n+  ([Issue #38](https://github.com/luontola/retrolambda/issues/38))\n \n ### Retrolambda 1.7.0 (2014-10-21)\n \n - Support for serializable lambdas\n-  ([Issue #35](https://github.com/orfjackal/retrolambda/issues/35))\n+  ([Issue #35](https://github.com/luontola/retrolambda/issues/35))\n \n ### Retrolambda 1.6.2 (2014-10-03)\n \n - Fixed a crash when trying to backport Android classes\n-  ([Issue #34](https://github.com/orfjackal/retrolambda/issues/34))\n+  ([Issue #34](https://github.com/luontola/retrolambda/issues/34))\n \n ### Retrolambda 1.6.1 (2014-08-25)\n \n - Fixed a crash when trying backport classes which are nominally the same\n   as those included in the JRE, but which have different bytecode\n-  ([Issue #29](https://github.com/orfjackal/retrolambda/issues/29))\n+  ([Issue #29](https://github.com/luontola/retrolambda/issues/29))\n \n ### Retrolambda 1.6.0 (2014-08-20)\n \n - Does not anymore require the use of a Java agent\n-  ([Issue #27](https://github.com/orfjackal/retrolambda/issues/27))\n+  ([Issue #27](https://github.com/luontola/retrolambda/issues/27))\n - Maven plugin: by default run Retrolambda in the same process as Maven,\n   making it a bit faster. If Maven is not running under Java 8, then will\n   fall back to forking the process and using the Java agent mechanism\n@@ -412,21 +412,21 @@ Version History\n \n - Maven plugin: use the [JDK from Maven Toolchains](http://maven.apache.org/plugins/maven-toolchains-plugin/toolchains/jdk.html)\n   if available. The `java8home` configuration parameter overrides this\n-  ([Issue #24](https://github.com/orfjackal/retrolambda/pull/24))\n+  ([Issue #24](https://github.com/luontola/retrolambda/pull/24))\n \n ### Retrolambda 1.4.0 (2014-07-04)\n \n - Added an optional `-Dretrolambda.includedFiles` parameter to support the\n   incremental compilers of build tools\n-  ([Issue #23](https://github.com/orfjackal/retrolambda/pull/23))\n+  ([Issue #23](https://github.com/luontola/retrolambda/pull/23))\n - Decides which lambda classes to save based on the current class being\n   processed, instead of the class loader that loaded the lambda class\n-  ([Issue #21](https://github.com/orfjackal/retrolambda/issues/21))\n+  ([Issue #21](https://github.com/luontola/retrolambda/issues/21))\n \n ### Retrolambda 1.3.0 (2014-06-04)\n \n - Maven plugin: made the input and output directories configurable\n-  ([Issue #20](https://github.com/orfjackal/retrolambda/issues/20))\n+  ([Issue #20](https://github.com/luontola/retrolambda/issues/20))\n - Maven plugin: by default use the current JRE for running Retrolambda.\n   For the old behavior, add `<java8home>${env.JAVA8_HOME}</java8home>`\n   to the plugin configuration\n@@ -435,21 +435,21 @@ Version History\n \n - Android: Fixed NoSuchMethodError when calling a private method to which\n   there is a method reference\n-  ([Issue #18](https://github.com/orfjackal/retrolambda/issues/18))\n+  ([Issue #18](https://github.com/luontola/retrolambda/issues/18))\n - Fixed the possibility of accidentally overriding private methods to which\n   there is method reference\n-  ([Issue #19](https://github.com/orfjackal/retrolambda/issues/19))\n+  ([Issue #19](https://github.com/luontola/retrolambda/issues/19))\n \n ### Retrolambda 1.2.2 (2014-05-15)\n \n - Fixed method references to private methods; will now make them\n   package-private the same way as lambda implementation methods\n-  ([Issue #17](https://github.com/orfjackal/retrolambda/issues/17))\n+  ([Issue #17](https://github.com/luontola/retrolambda/issues/17))\n \n ### Retrolambda 1.2.1 (2014-05-04)\n \n - Fixed the Retrolambda Maven plugin not using the project's classpath\n-  ([Issue #16](https://github.com/orfjackal/retrolambda/issues/16))\n+  ([Issue #16](https://github.com/luontola/retrolambda/issues/16))\n - Maven plugin: save `retrolambda.jar` under `target/retrolambda/`\n - Suppress false warning about class initializer methods on interfaces\n \n@@ -462,23 +462,23 @@ Version History\n \n - Removes from interfaces bridge methods which were generated by JDK 8 e.g.\n   when an interface overrides a method and refines its return type\n-  ([Issue #13](https://github.com/orfjackal/retrolambda/issues/13))\n+  ([Issue #13](https://github.com/luontola/retrolambda/issues/13))\n \n ### Retrolambda 1.1.3 (2014-03-25)\n \n - Fixed incompatibility with the Eclipse JDT compiler, version Kepler SR2\n   with the Java 8 support patch 1.0.0.v20140317-1959\n-  ([Issue #12](https://github.com/orfjackal/retrolambda/issues/12))\n+  ([Issue #12](https://github.com/luontola/retrolambda/issues/12))\n \n ### Retrolambda 1.1.2 (2014-01-08)\n \n - Updated to work with JDK 8 Early Access Build b121 (2013-12-19)\n-  ([Issue #3](https://github.com/orfjackal/retrolambda/issues/3))\n+  ([Issue #3](https://github.com/luontola/retrolambda/issues/3))\n \n ### Retrolambda 1.1.1 (2013-11-27)\n \n - Show help if the `-javaagent` parameter is missing\n-  ([Issue #2](https://github.com/orfjackal/retrolambda/issues/2))\n+  ([Issue #2](https://github.com/luontola/retrolambda/issues/2))\n \n ### Retrolambda 1.1.0 (2013-07-25)\n \n"
    },
    {
        "commit_hash": "5afee5586c635ebc629e94fcd377a34c6ac9a0d3",
        "previous_commit_hash": "54ac5e8c79825f20462be7ce344649913fe134d1",
        "diff_stats": {
            "additions": 4,
            "deletions": 5
        },
        "diff_content": "@@ -16,7 +16,7 @@\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n-    <url>https://github.com/orfjackal/retrolambda</url>\n+    <url>https://github.com/luontola/retrolambda</url>\n     <inceptionYear>2013</inceptionYear>\n \n     <licenses>\n@@ -28,15 +28,14 @@\n \n     <developers>\n         <developer>\n-            <id>orfjackal</id>\n             <name>Esko Luontola</name>\n-            <url>http://www.orfjackal.net/</url>\n+            <url>http://luontola.fi</url>\n         </developer>\n     </developers>\n \n     <scm>\n-        <connection>scm:git:git://github.com/orfjackal/retrolambda.git</connection>\n-        <url>https://github.com/orfjackal/retrolambda</url>\n+        <connection>scm:git:git://github.com/luontola/retrolambda.git</connection>\n+        <url>https://github.com/luontola/retrolambda</url>\n     </scm>\n \n     <properties>\n"
    },
    {
        "commit_hash": "5afee5586c635ebc629e94fcd377a34c6ac9a0d3",
        "previous_commit_hash": "54ac5e8c79825f20462be7ce344649913fe134d1",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -60,7 +60,7 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n      * The Java version targeted by the bytecode processing. Possible values are\n      * 1.5, 1.6, 1.7 and 1.8. After processing the classes will be compatible\n      * with the target JVM provided the known limitations are considered. See\n-     * <a href=\"https://github.com/orfjackal/retrolambda\">project documentation</a>\n+     * <a href=\"https://github.com/luontola/retrolambda\">project documentation</a>\n      * for more details.\n      *\n      * @since 1.2.0\n"
    },
    {
        "commit_hash": "5afee5586c635ebc629e94fcd377a34c6ac9a0d3",
        "previous_commit_hash": "54ac5e8c79825f20462be7ce344649913fe134d1",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -217,7 +217,7 @@ public class SystemPropertiesConfig implements Config {\n                 \"\\n\" +\n                 \"Retrolambda takes Java 8 classes and backports lambda expressions and\\n\" +\n                 \"some other language features to work on Java 7, 6 or 5.\\n\" +\n-                \"Web site: https://github.com/orfjackal/retrolambda\\n\" +\n+                \"Web site: https://github.com/luontola/retrolambda\\n\" +\n                 \"\\n\" +\n                 \"Copyright (c) 2013-2017  Esko Luontola and other Retrolambda contributors\\n\" +\n                 \"This software is released under the Apache License 2.0.\\n\" +\n"
    },
    {
        "commit_hash": "7e682a66e6a3d5924104c3bdad2561e5a029c5e5",
        "previous_commit_hash": "5afee5586c635ebc629e94fcd377a34c6ac9a0d3",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -22,7 +22,7 @@ public class ClassAnalyzer {\n     private final Map<MethodRef, MethodRef> renamedLambdaMethods = new HashMap<>();\n \n     public void analyze(byte[] bytecode) {\n-        analyze(new ClassReader(bytecode));\n+        analyze(new ClassReader2(bytecode));\n     }\n \n     public void analyze(ClassReader cr) {\n"
    },
    {
        "commit_hash": "7e682a66e6a3d5924104c3bdad2561e5a029c5e5",
        "previous_commit_hash": "5afee5586c635ebc629e94fcd377a34c6ac9a0d3",
        "diff_stats": {
            "additions": 14,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,14 @@\n+package net.orfjackal.retrolambda;\n+\n+import org.objectweb.asm.*;\n+\n+public class ClassReader2 extends ClassReader {\n+  public ClassReader2(byte[] b) {\n+    super(b);\n+  }\n+\n+  @Override\n+  protected Label readLabel(int offset, Label[] labels) {\n+    return super.readLabel(Math.min(offset, labels.length - 1), labels);\n+  }\n+}\n"
    },
    {
        "commit_hash": "7e682a66e6a3d5924104c3bdad2561e5a029c5e5",
        "previous_commit_hash": "5afee5586c635ebc629e94fcd377a34c6ac9a0d3",
        "diff_stats": {
            "additions": 2,
            "deletions": 1
        },
        "diff_content": "@@ -5,6 +5,7 @@\n package net.orfjackal.retrolambda.files;\n \n import org.objectweb.asm.ClassReader;\n+import net.orfjackal.retrolambda.ClassReader2;\n \n import java.io.IOException;\n import java.nio.file.*;\n@@ -21,7 +22,7 @@ public class OutputDirectory {\n         if (bytecode == null) {\n             return;\n         }\n-        ClassReader cr = new ClassReader(bytecode);\n+        ClassReader cr = new ClassReader2(bytecode);\n         Path relativePath = outputDir.getFileSystem().getPath(cr.getClassName() + \".class\");\n         writeFile(relativePath, bytecode);\n     }\n"
    },
    {
        "commit_hash": "7e682a66e6a3d5924104c3bdad2561e5a029c5e5",
        "previous_commit_hash": "5afee5586c635ebc629e94fcd377a34c6ac9a0d3",
        "diff_stats": {
            "additions": 3,
            "deletions": 1
        },
        "diff_content": "@@ -7,7 +7,9 @@ package net.orfjackal.retrolambda.lambdas;\n import com.esotericsoftware.minlog.Log;\n import net.orfjackal.retrolambda.Transformers;\n import net.orfjackal.retrolambda.files.OutputDirectory;\n+\n import org.objectweb.asm.ClassReader;\n+import net.orfjackal.retrolambda.ClassReader2;\n \n import java.io.IOException;\n \n@@ -29,7 +31,7 @@ public class LambdaClassSaver {\n \n     private void reifyLambdaClass(String className, byte[] bytecode) {\n         Log.info(\"Saving lambda class: \" + className);\n-        bytecode = transformers.backportLambdaClass(new ClassReader(bytecode));\n+        bytecode = transformers.backportLambdaClass(new ClassReader2(bytecode));\n         try {\n             saver.writeClass(bytecode);\n         } catch (IOException e) {\n"
    },
    {
        "commit_hash": "7e682a66e6a3d5924104c3bdad2561e5a029c5e5",
        "previous_commit_hash": "5afee5586c635ebc629e94fcd377a34c6ac9a0d3",
        "diff_stats": {
            "additions": 2,
            "deletions": 1
        },
        "diff_content": "@@ -5,6 +5,7 @@\n package net.orfjackal.retrolambda.lambdas;\n \n import org.objectweb.asm.ClassReader;\n+import net.orfjackal.retrolambda.ClassReader2;\n \n import java.lang.instrument.*;\n import java.security.ProtectionDomain;\n@@ -22,7 +23,7 @@ public class LambdaClassSaverAgent implements ClassFileTransformer {\n         if (className == null) {\n             // Since JDK 8 build b121 or so, lambda classes have a null class name,\n             // but we can read it from the bytecode where the name still exists.\n-            className = new ClassReader(classfileBuffer).getClassName();\n+            className = new ClassReader2(classfileBuffer).getClassName();\n         }\n         if (lambdaClassSaver != null) {\n             lambdaClassSaver.saveIfLambda(className, classfileBuffer);\n"
    },
    {
        "commit_hash": "410a7a5a72bddd8ca784c43502c32ca11ad1daba",
        "previous_commit_hash": "7e682a66e6a3d5924104c3bdad2561e5a029c5e5",
        "diff_stats": {
            "additions": 4,
            "deletions": 0
        },
        "diff_content": "@@ -140,6 +140,10 @@ Configurable system properties:\n       Alternative to retrolambda.includedFiles for avoiding the command line\n       length limit. The file must list one file per line with UTF-8 encoding.\n \n+  retrolambda.javacHacks\n+      Attempts to fix javac bugs (type-annotation emission for local variables).\n+      Disabled by default. Enable by setting to \"true\"\n+\n   retrolambda.quiet\n       Reduces the amount of logging.\n       Disabled by default. Enable by setting to \"true\"\n"
    },
    {
        "commit_hash": "410a7a5a72bddd8ca784c43502c32ca11ad1daba",
        "previous_commit_hash": "7e682a66e6a3d5924104c3bdad2561e5a029c5e5",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -16,4 +16,5 @@ public class RetrolambdaApi {\n     public static final String INPUT_DIR = PREFIX + \"inputDir\";\n     public static final String DEFAULT_METHODS = PREFIX + \"defaultMethods\";\n     public static final String BYTECODE_VERSION = PREFIX + \"bytecodeVersion\";\n+    public static final String JAVAC_HACKS = PREFIX + \"javacHacks\";\n }\n"
    },
    {
        "commit_hash": "410a7a5a72bddd8ca784c43502c32ca11ad1daba",
        "previous_commit_hash": "7e682a66e6a3d5924104c3bdad2561e5a029c5e5",
        "diff_stats": {
            "additions": 7,
            "deletions": 6
        },
        "diff_content": "@@ -4,6 +4,7 @@\n \n package net.orfjackal.retrolambda;\n \n+import net.orfjackal.retrolambda.ext.ow2asm.EnhancedClassReader;\n import net.orfjackal.retrolambda.interfaces.*;\n import net.orfjackal.retrolambda.lambdas.*;\n import net.orfjackal.retrolambda.util.*;\n@@ -21,11 +22,11 @@ public class ClassAnalyzer {\n     private final Map<MethodRef, MethodRef> relocatedMethods = new HashMap<>();\n     private final Map<MethodRef, MethodRef> renamedLambdaMethods = new HashMap<>();\n \n-    public void analyze(byte[] bytecode) {\n-        analyze(new ClassReader2(bytecode));\n+    public void analyze(byte[] bytecode, boolean isJavacHacksEnabled) {\n+        analyze(new EnhancedClassReader(bytecode, isJavacHacksEnabled));\n     }\n \n-    public void analyze(ClassReader cr) {\n+    public void analyze(EnhancedClassReader cr) {\n         ClassInfo c = new ClassInfo(cr);\n         classes.put(c.type, c);\n \n@@ -37,7 +38,7 @@ public class ClassAnalyzer {\n         analyzeClassOrInterface(c, cr);\n     }\n \n-    private void analyzeClass(ClassInfo c, ClassReader cr) {\n+    private void analyzeClass(ClassInfo c, EnhancedClassReader cr) {\n         cr.accept(new ClassVisitor(ASM5) {\n             private String owner;\n \n@@ -64,7 +65,7 @@ public class ClassAnalyzer {\n         }, ClassReader.SKIP_CODE);\n     }\n \n-    private void analyzeInterface(ClassInfo c, ClassReader cr) {\n+    private void analyzeInterface(ClassInfo c, EnhancedClassReader cr) {\n         cr.accept(new ClassVisitor(ASM5) {\n             private String owner;\n             private String companion;\n@@ -100,7 +101,7 @@ public class ClassAnalyzer {\n         }, ClassReader.SKIP_CODE);\n     }\n \n-    private void analyzeClassOrInterface(ClassInfo c, ClassReader cr) {\n+    private void analyzeClassOrInterface(ClassInfo c, EnhancedClassReader cr) {\n         cr.accept(new ClassVisitor(ASM5) {\n             private String owner;\n \n"
    },
    {
        "commit_hash": "410a7a5a72bddd8ca784c43502c32ca11ad1daba",
        "previous_commit_hash": "7e682a66e6a3d5924104c3bdad2561e5a029c5e5",
        "diff_stats": {
            "additions": 0,
            "deletions": 14
        },
        "diff_content": "@@ -1,14 +0,0 @@\n-package net.orfjackal.retrolambda;\n-\n-import org.objectweb.asm.*;\n-\n-public class ClassReader2 extends ClassReader {\n-  public ClassReader2(byte[] b) {\n-    super(b);\n-  }\n-\n-  @Override\n-  protected Label readLabel(int offset, Label[] labels) {\n-    return super.readLabel(Math.min(offset, labels.length - 1), labels);\n-  }\n-}\n"
    },
    {
        "commit_hash": "410a7a5a72bddd8ca784c43502c32ca11ad1daba",
        "previous_commit_hash": "7e682a66e6a3d5924104c3bdad2561e5a029c5e5",
        "diff_stats": {
            "additions": 2,
            "deletions": 0
        },
        "diff_content": "@@ -21,5 +21,7 @@ public interface Config {\n \n     List<Path> getIncludedFiles();\n \n+    boolean isJavacHacksEnabled();\n+\n     boolean isQuiet();\n }\n"
    },
    {
        "commit_hash": "410a7a5a72bddd8ca784c43502c32ca11ad1daba",
        "previous_commit_hash": "7e682a66e6a3d5924104c3bdad2561e5a029c5e5",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -22,7 +22,7 @@ public class PreMain {\n         return agentLoaded;\n     }\n \n-    public static void setLambdaClassSaver(LambdaClassSaver lambdaClassSaver) {\n-        agent.setLambdaClassSaver(lambdaClassSaver);\n+    public static void setLambdaClassSaver(LambdaClassSaver lambdaClassSaver, boolean isJavacHacksEnabled) {\n+        agent.setLambdaClassSaver(lambdaClassSaver, isJavacHacksEnabled);\n     }\n }\n"
    },
    {
        "commit_hash": "410a7a5a72bddd8ca784c43502c32ca11ad1daba",
        "previous_commit_hash": "7e682a66e6a3d5924104c3bdad2561e5a029c5e5",
        "diff_stats": {
            "additions": 8,
            "deletions": 4
        },
        "diff_content": "@@ -32,6 +32,7 @@ public class Retrolambda {\n         Path outputDir = config.getOutputDir();\n         List<Path> classpath = config.getClasspath();\n         List<Path> includedFiles = config.getIncludedFiles();\n+        boolean isJavacHacksEnabled = config.isJavacHacksEnabled();\n         if (config.isQuiet()) {\n             Log.WARN();\n         } else {\n@@ -45,6 +46,9 @@ public class Retrolambda {\n         Log.info(\"Included files:   \" + (includedFiles != null ? includedFiles.size() : \"all\"));\n         Log.info(\"JVM version:      \" + System.getProperty(\"java.version\"));\n         Log.info(\"Agent enabled:    \" + PreMain.isAgentLoaded());\n+        if (isJavacHacksEnabled) {\n+            Log.info(\"javac hacks:      \" + isJavacHacksEnabled);\n+        }\n \n         if (!Files.isDirectory(inputDir)) {\n             Log.info(\"Nothing to do; not a directory: \" + inputDir);\n@@ -56,11 +60,11 @@ public class Retrolambda {\n         ClassAnalyzer analyzer = new ClassAnalyzer();\n         OutputDirectory outputDirectory = new OutputDirectory(outputDir);\n         Transformers transformers = new Transformers(bytecodeVersion, defaultMethodsEnabled, analyzer);\n-        LambdaClassSaver lambdaClassSaver = new LambdaClassSaver(outputDirectory, transformers);\n+        LambdaClassSaver lambdaClassSaver = new LambdaClassSaver(outputDirectory, transformers, isJavacHacksEnabled);\n \n         try (LambdaClassDumper dumper = new LambdaClassDumper(lambdaClassSaver)) {\n             if (PreMain.isAgentLoaded()) {\n-                PreMain.setLambdaClassSaver(lambdaClassSaver);\n+                PreMain.setLambdaClassSaver(lambdaClassSaver, isJavacHacksEnabled);\n             } else {\n                 dumper.install();\n             }\n@@ -68,7 +72,7 @@ public class Retrolambda {\n             visitFiles(inputDir, includedFiles, new ClasspathVisitor() {\n                 @Override\n                 protected void visitClass(byte[] bytecode) {\n-                    analyzer.analyze(bytecode);\n+                    analyzer.analyze(bytecode, isJavacHacksEnabled);\n                 }\n \n                 @Override\n@@ -95,7 +99,7 @@ public class Retrolambda {\n             // We need to load some of the classes (for calling the lambda metafactory)\n             // so we need to take care not to modify any bytecode before loading them.\n             for (byte[] bytecode : transformed) {\n-                outputDirectory.writeClass(bytecode);\n+                outputDirectory.writeClass(bytecode, isJavacHacksEnabled);\n             }\n         }\n     }\n"
    },
    {
        "commit_hash": "410a7a5a72bddd8ca784c43502c32ca11ad1daba",
        "previous_commit_hash": "7e682a66e6a3d5924104c3bdad2561e5a029c5e5",
        "diff_stats": {
            "additions": 15,
            "deletions": 0
        },
        "diff_content": "@@ -191,6 +191,21 @@ public class SystemPropertiesConfig implements Config {\n     }\n \n \n+    // useJavac8ReadLabelHack\n+\n+    static {\n+        optionalParameterHelp(JAVAC_HACKS,\n+                \"Attempts to fix javac bugs (type-annotation emission for local variables).\",\n+                \"Disabled by default. Enable by setting to \\\"true\\\"\");\n+\n+    }\n+\n+    @Override\n+    public boolean isJavacHacksEnabled() {\n+        return Boolean.parseBoolean(p.getProperty(JAVAC_HACKS, \"false\"));\n+    }\n+\n+\n     // quiet\n \n     static {\n"
    },
    {
        "commit_hash": "410a7a5a72bddd8ca784c43502c32ca11ad1daba",
        "previous_commit_hash": "7e682a66e6a3d5924104c3bdad2561e5a029c5e5",
        "diff_stats": {
            "additions": 5,
            "deletions": 4
        },
        "diff_content": "@@ -4,6 +4,7 @@\n \n package net.orfjackal.retrolambda;\n \n+import net.orfjackal.retrolambda.ext.ow2asm.EnhancedClassReader;\n import net.orfjackal.retrolambda.interfaces.*;\n import net.orfjackal.retrolambda.lambdas.*;\n import net.orfjackal.retrolambda.requirenonnull.RequireNonNull;\n@@ -26,7 +27,7 @@ public class Transformers {\n         this.analyzer = analyzer;\n     }\n \n-    public byte[] backportLambdaClass(ClassReader reader) {\n+    public byte[] backportLambdaClass(EnhancedClassReader reader) {\n         return transform(reader, (next) -> {\n             if (defaultMethodsEnabled) {\n                 // Lambda classes are generated dynamically, so they were not\n@@ -43,7 +44,7 @@ public class Transformers {\n         });\n     }\n \n-    public byte[] backportClass(ClassReader reader) {\n+    public byte[] backportClass(EnhancedClassReader reader) {\n         return transform(reader, (next) -> {\n             if (defaultMethodsEnabled) {\n                 next = new UpdateRelocatedMethodInvocations(next, analyzer);\n@@ -54,7 +55,7 @@ public class Transformers {\n         });\n     }\n \n-    public List<byte[]> backportInterface(ClassReader reader) {\n+    public List<byte[]> backportInterface(EnhancedClassReader reader) {\n         // The lambdas must be backported only once, because bad things will happen if a lambda\n         // is called by different class name in the interface and its companion class, and then\n         // the wrong one of them is written to disk last.\n@@ -103,7 +104,7 @@ public class Transformers {\n         return transform(node.name, node::accept, chain);\n     }\n \n-    private byte[] transform(ClassReader reader, ClassVisitorChain chain) {\n+    private byte[] transform(EnhancedClassReader reader, ClassVisitorChain chain) {\n         return transform(reader.getClassName(), cv -> reader.accept(cv, 0), chain);\n     }\n \n"
    },
    {
        "commit_hash": "410a7a5a72bddd8ca784c43502c32ca11ad1daba",
        "previous_commit_hash": "7e682a66e6a3d5924104c3bdad2561e5a029c5e5",
        "diff_stats": {
            "additions": 27,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,27 @@\n+// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.ext.ow2asm;\n+\n+import org.objectweb.asm.*;\n+\n+public class EnhancedClassReader extends ClassReader {\n+\n+    private final boolean isJavacHacksEnabled;\n+\n+    public EnhancedClassReader(byte[] b, boolean isJavacHacksEnabled) {\n+        super(b);\n+        this.isJavacHacksEnabled = isJavacHacksEnabled;\n+    }\n+\n+    @Override\n+    protected Label readLabel(int offset, Label[] labels) {\n+        if (!isJavacHacksEnabled) {\n+            return super.readLabel(offset, labels);\n+        }\n+        // A workaround suggested by Evgeny Mandrikov. See more: https://gitlab.ow2.org/asm/asm/issues/317845\n+        return super.readLabel(Math.min(offset, labels.length - 1), labels);\n+    }\n+\n+}\n"
    },
    {
        "commit_hash": "410a7a5a72bddd8ca784c43502c32ca11ad1daba",
        "previous_commit_hash": "7e682a66e6a3d5924104c3bdad2561e5a029c5e5",
        "diff_stats": {
            "additions": 3,
            "deletions": 4
        },
        "diff_content": "@@ -4,8 +4,7 @@\n \n package net.orfjackal.retrolambda.files;\n \n-import org.objectweb.asm.ClassReader;\n-import net.orfjackal.retrolambda.ClassReader2;\n+import net.orfjackal.retrolambda.ext.ow2asm.EnhancedClassReader;\n \n import java.io.IOException;\n import java.nio.file.*;\n@@ -18,11 +17,11 @@ public class OutputDirectory {\n         this.outputDir = outputDir;\n     }\n \n-    public void writeClass(byte[] bytecode) throws IOException {\n+    public void writeClass(byte[] bytecode, boolean isJavacHacksEnabled) throws IOException {\n         if (bytecode == null) {\n             return;\n         }\n-        ClassReader cr = new ClassReader2(bytecode);\n+        EnhancedClassReader cr = new EnhancedClassReader(bytecode, isJavacHacksEnabled);\n         Path relativePath = outputDir.getFileSystem().getPath(cr.getClassName() + \".class\");\n         writeFile(relativePath, bytecode);\n     }\n"
    },
    {
        "commit_hash": "410a7a5a72bddd8ca784c43502c32ca11ad1daba",
        "previous_commit_hash": "7e682a66e6a3d5924104c3bdad2561e5a029c5e5",
        "diff_stats": {
            "additions": 3,
            "deletions": 2
        },
        "diff_content": "@@ -4,6 +4,7 @@\n \n package net.orfjackal.retrolambda.interfaces;\n \n+import net.orfjackal.retrolambda.ext.ow2asm.EnhancedClassReader;\n import net.orfjackal.retrolambda.util.Flags;\n import org.objectweb.asm.*;\n \n@@ -11,7 +12,7 @@ import java.util.*;\n \n public class ClassInfo {\n \n-    public final ClassReader reader;\n+    public final EnhancedClassReader reader;\n     private final int access;\n     public final Type type;\n     public final Type superclass;\n@@ -26,7 +27,7 @@ public class ClassInfo {\n         this.superclass = null;\n     }\n \n-    public ClassInfo(ClassReader cr) {\n+    public ClassInfo(EnhancedClassReader cr) {\n         this.reader = cr;\n         this.access = cr.getAccess();\n         this.type = Type.getObjectType(cr.getClassName());\n"
    },
    {
        "commit_hash": "410a7a5a72bddd8ca784c43502c32ca11ad1daba",
        "previous_commit_hash": "7e682a66e6a3d5924104c3bdad2561e5a029c5e5",
        "diff_stats": {
            "additions": 6,
            "deletions": 5
        },
        "diff_content": "@@ -8,8 +8,7 @@ import com.esotericsoftware.minlog.Log;\n import net.orfjackal.retrolambda.Transformers;\n import net.orfjackal.retrolambda.files.OutputDirectory;\n \n-import org.objectweb.asm.ClassReader;\n-import net.orfjackal.retrolambda.ClassReader2;\n+import net.orfjackal.retrolambda.ext.ow2asm.EnhancedClassReader;\n \n import java.io.IOException;\n \n@@ -17,10 +16,12 @@ public class LambdaClassSaver {\n \n     private final OutputDirectory saver;\n     private final Transformers transformers;\n+    private final boolean isJavacHacksEnabled;\n \n-    public LambdaClassSaver(OutputDirectory saver, Transformers transformers) {\n+    public LambdaClassSaver(OutputDirectory saver, Transformers transformers, boolean isJavacHacksEnabled) {\n         this.saver = saver;\n         this.transformers = transformers;\n+        this.isJavacHacksEnabled = isJavacHacksEnabled;\n     }\n \n     public void saveIfLambda(String className, byte[] bytecode) {\n@@ -31,9 +32,9 @@ public class LambdaClassSaver {\n \n     private void reifyLambdaClass(String className, byte[] bytecode) {\n         Log.info(\"Saving lambda class: \" + className);\n-        bytecode = transformers.backportLambdaClass(new ClassReader2(bytecode));\n+        bytecode = transformers.backportLambdaClass(new EnhancedClassReader(bytecode, isJavacHacksEnabled));\n         try {\n-            saver.writeClass(bytecode);\n+            saver.writeClass(bytecode, isJavacHacksEnabled);\n         } catch (IOException e) {\n             throw new RuntimeException(e);\n         }\n"
    },
    {
        "commit_hash": "410a7a5a72bddd8ca784c43502c32ca11ad1daba",
        "previous_commit_hash": "7e682a66e6a3d5924104c3bdad2561e5a029c5e5",
        "diff_stats": {
            "additions": 5,
            "deletions": 4
        },
        "diff_content": "@@ -4,8 +4,7 @@\n \n package net.orfjackal.retrolambda.lambdas;\n \n-import org.objectweb.asm.ClassReader;\n-import net.orfjackal.retrolambda.ClassReader2;\n+import net.orfjackal.retrolambda.ext.ow2asm.EnhancedClassReader;\n \n import java.lang.instrument.*;\n import java.security.ProtectionDomain;\n@@ -13,9 +12,11 @@ import java.security.ProtectionDomain;\n public class LambdaClassSaverAgent implements ClassFileTransformer {\n \n     private LambdaClassSaver lambdaClassSaver;\n+    private boolean isJavacHacksEnabled;\n \n-    public void setLambdaClassSaver(LambdaClassSaver lambdaClassSaver) {\n+    public void setLambdaClassSaver(LambdaClassSaver lambdaClassSaver, boolean isJavacHacksEnabled) {\n         this.lambdaClassSaver = lambdaClassSaver;\n+        this.isJavacHacksEnabled = isJavacHacksEnabled;\n     }\n \n     @Override\n@@ -23,7 +24,7 @@ public class LambdaClassSaverAgent implements ClassFileTransformer {\n         if (className == null) {\n             // Since JDK 8 build b121 or so, lambda classes have a null class name,\n             // but we can read it from the bytecode where the name still exists.\n-            className = new ClassReader2(classfileBuffer).getClassName();\n+            className = new EnhancedClassReader(classfileBuffer, isJavacHacksEnabled).getClassName();\n         }\n         if (lambdaClassSaver != null) {\n             lambdaClassSaver.saveIfLambda(className, classfileBuffer);\n"
    },
    {
        "commit_hash": "410a7a5a72bddd8ca784c43502c32ca11ad1daba",
        "previous_commit_hash": "7e682a66e6a3d5924104c3bdad2561e5a029c5e5",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -513,7 +513,7 @@ public class ClassAnalyzerTest {\n         Collections.shuffle(inAnyOrder);\n         for (Class<?> clazz : inAnyOrder) {\n             byte[] bytecode = readBytecode(clazz);\n-            analyzer.analyze(bytecode);\n+            analyzer.analyze(bytecode, false);\n         }\n     }\n \n"
    },
    {
        "commit_hash": "d605bfe72d62162bc1de164f53121559c7c33d86",
        "previous_commit_hash": "410a7a5a72bddd8ca784c43502c32ca11ad1daba",
        "diff_stats": {
            "additions": 9,
            "deletions": 0
        },
        "diff_content": "@@ -79,6 +79,14 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n     @Parameter(defaultValue = \"false\", property = \"retrolambdaDefaultMethods\", required = true)\n     public boolean defaultMethods;\n \n+    /**\n+     * Whether to apply experimental javac issues workarounds.\n+     *\n+     * @since 2.5.5\n+     */\n+    @Parameter(defaultValue = \"false\", property = \"retrolambdaJavacHacks\", required = true)\n+    public boolean javacHacks;\n+\n     /**\n      * Reduces the amount of logging.\n      *\n@@ -117,6 +125,7 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n         config.setProperty(RetrolambdaApi.INPUT_DIR, getInputDir().getAbsolutePath());\n         config.setProperty(RetrolambdaApi.OUTPUT_DIR, getOutputDir().getAbsolutePath());\n         config.setProperty(RetrolambdaApi.CLASSPATH, getClasspath());\n+        config.setProperty(RetrolambdaApi.JAVAC_HACKS, \"\" + javacHacks);\n \n         if (fork) {\n             processClassesInForkedProcess(config);\n"
    },
    {
        "commit_hash": "a441ee0a0d22f178beecf235e271e73275ce28c9",
        "previous_commit_hash": "8fae5c839ec168201e16c62bc40b428cbcca609b",
        "diff_stats": {
            "additions": 3,
            "deletions": 1
        },
        "diff_content": "@@ -13,8 +13,10 @@\n               <option value=\"clean\" />\n               <option value=\"verify\" />\n               <option value=\"-Dmaven.test.redirectTestOutputToFile=false\" />\n+              <option value=\"--errors\" />\n             </list>\n           </option>\n+          <option name=\"pomFileName\" />\n           <option name=\"profilesMap\">\n             <map />\n           </option>\n@@ -25,6 +27,6 @@\n     </MavenSettings>\n     <RunnerSettings RunnerId=\"Run\" />\n     <ConfigurationWrapper RunnerId=\"Run\" />\n-    <method />\n+    <method v=\"2\" />\n   </configuration>\n </component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "a441ee0a0d22f178beecf235e271e73275ce28c9",
        "previous_commit_hash": "8fae5c839ec168201e16c62bc40b428cbcca609b",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -118,6 +118,7 @@\n                     <target>${testBytecodeTarget}</target>\n                     <defaultMethods>${testDefaultMethods}</defaultMethods>\n                     <fork>${testFork}</fork>\n+                    <javacHacks>true</javacHacks>\n                 </configuration>\n             </plugin>\n \n"
    },
    {
        "commit_hash": "a441ee0a0d22f178beecf235e271e73275ce28c9",
        "previous_commit_hash": "8fae5c839ec168201e16c62bc40b428cbcca609b",
        "diff_stats": {
            "additions": 46,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,46 @@\n+// Copyright \u00a9 2013-2018 Esko Luontola and other Retrolambda contributors\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.test;\n+\n+import org.junit.Test;\n+\n+import java.lang.annotation.*;\n+\n+public class JdkBug8073658Test {\n+\n+    // Some versions of `javac` produce incorrect bytecode which\n+    // causes a crash in ASM. See the following issues for details.\n+    // https://github.com/luontola/retrolambda/pull/143\n+    // https://gitlab.ow2.org/asm/asm/issues/317845\n+    // https://bugs.openjdk.java.net/browse/JDK-8073658\n+    @Test\n+    public void test() {\n+        new ClassWithBridgeMethod<>().doit(null);\n+    }\n+}\n+\n+class ClassWithBridgeMethod<T extends Runnable> implements ParameterizedInterface<T> {\n+\n+    @Override\n+    public void doit(final T t) {\n+\n+        @TypeUseAnnotation\n+        Object x = null;\n+\n+        // Some instructions just to widen the scope of annotation for x\n+        System.out.println(x);\n+        System.out.println(x);\n+    }\n+\n+}\n+\n+interface ParameterizedInterface<T> {\n+    void doit(T arg);\n+}\n+\n+@Target({ElementType.TYPE_USE})\n+@Retention(RetentionPolicy.CLASS)\n+@interface TypeUseAnnotation {\n+}\n"
    },
    {
        "commit_hash": "e5f6758ddfecdae0f30aba7a1c1660036b306e19",
        "previous_commit_hash": "a441ee0a0d22f178beecf235e271e73275ce28c9",
        "diff_stats": {
            "additions": 8,
            "deletions": 0
        },
        "diff_content": "@@ -241,6 +241,14 @@ yourself or pay someone to do it, if you think it's worth the effort. ;)\n Version History\n ---------------\n \n+### Upcoming\n+\n+- Fix an `ArrayIndexOutOfBoundsException` crash in ASM due to incorrect bytecode \n+  produced by `javac` under some circumstances. See [JDK-8073658](https://bugs.openjdk.java.net/browse/JDK-8073658)\n+  and [ASM-317845](https://gitlab.ow2.org/asm/asm/issues/317845).\n+  Enable the `javacHacks` parameter for a workaround to this issue.\n+  ([Pull request #143](https://github.com/luontola/retrolambda/pull/143))\n+\n ### Retrolambda 2.5.4 (2018-05-30)\n \n - Fix regression in Maven plugin; use classpathFile\n"
    },
    {
        "commit_hash": "ea49b21357dbf8bdd08714f87ac75e5a61c8582f",
        "previous_commit_hash": "e5f6758ddfecdae0f30aba7a1c1660036b306e19",
        "diff_stats": {
            "additions": 6,
            "deletions": 6
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013-2017 Esko Luontola and other Retrolambda contributors\n+// Copyright \u00a9 2013-2018 Esko Luontola and other Retrolambda contributors\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -23,10 +23,10 @@ public class ClassAnalyzer {\n     private final Map<MethodRef, MethodRef> renamedLambdaMethods = new HashMap<>();\n \n     public void analyze(byte[] bytecode, boolean isJavacHacksEnabled) {\n-        analyze(new EnhancedClassReader(bytecode, isJavacHacksEnabled));\n+        analyze(EnhancedClassReader.create(bytecode, isJavacHacksEnabled));\n     }\n \n-    public void analyze(EnhancedClassReader cr) {\n+    public void analyze(ClassReader cr) {\n         ClassInfo c = new ClassInfo(cr);\n         classes.put(c.type, c);\n \n@@ -38,7 +38,7 @@ public class ClassAnalyzer {\n         analyzeClassOrInterface(c, cr);\n     }\n \n-    private void analyzeClass(ClassInfo c, EnhancedClassReader cr) {\n+    private void analyzeClass(ClassInfo c, ClassReader cr) {\n         cr.accept(new ClassVisitor(ASM5) {\n             private String owner;\n \n@@ -65,7 +65,7 @@ public class ClassAnalyzer {\n         }, ClassReader.SKIP_CODE);\n     }\n \n-    private void analyzeInterface(ClassInfo c, EnhancedClassReader cr) {\n+    private void analyzeInterface(ClassInfo c, ClassReader cr) {\n         cr.accept(new ClassVisitor(ASM5) {\n             private String owner;\n             private String companion;\n@@ -101,7 +101,7 @@ public class ClassAnalyzer {\n         }, ClassReader.SKIP_CODE);\n     }\n \n-    private void analyzeClassOrInterface(ClassInfo c, EnhancedClassReader cr) {\n+    private void analyzeClassOrInterface(ClassInfo c, ClassReader cr) {\n         cr.accept(new ClassVisitor(ASM5) {\n             private String owner;\n \n"
    },
    {
        "commit_hash": "ea49b21357dbf8bdd08714f87ac75e5a61c8582f",
        "previous_commit_hash": "e5f6758ddfecdae0f30aba7a1c1660036b306e19",
        "diff_stats": {
            "additions": 5,
            "deletions": 6
        },
        "diff_content": "@@ -1,10 +1,9 @@\n-// Copyright \u00a9 2013-2017 Esko Luontola and other Retrolambda contributors\n+// Copyright \u00a9 2013-2018 Esko Luontola and other Retrolambda contributors\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n package net.orfjackal.retrolambda;\n \n-import net.orfjackal.retrolambda.ext.ow2asm.EnhancedClassReader;\n import net.orfjackal.retrolambda.interfaces.*;\n import net.orfjackal.retrolambda.lambdas.*;\n import net.orfjackal.retrolambda.requirenonnull.RequireNonNull;\n@@ -27,7 +26,7 @@ public class Transformers {\n         this.analyzer = analyzer;\n     }\n \n-    public byte[] backportLambdaClass(EnhancedClassReader reader) {\n+    public byte[] backportLambdaClass(ClassReader reader) {\n         return transform(reader, (next) -> {\n             if (defaultMethodsEnabled) {\n                 // Lambda classes are generated dynamically, so they were not\n@@ -44,7 +43,7 @@ public class Transformers {\n         });\n     }\n \n-    public byte[] backportClass(EnhancedClassReader reader) {\n+    public byte[] backportClass(ClassReader reader) {\n         return transform(reader, (next) -> {\n             if (defaultMethodsEnabled) {\n                 next = new UpdateRelocatedMethodInvocations(next, analyzer);\n@@ -55,7 +54,7 @@ public class Transformers {\n         });\n     }\n \n-    public List<byte[]> backportInterface(EnhancedClassReader reader) {\n+    public List<byte[]> backportInterface(ClassReader reader) {\n         // The lambdas must be backported only once, because bad things will happen if a lambda\n         // is called by different class name in the interface and its companion class, and then\n         // the wrong one of them is written to disk last.\n@@ -104,7 +103,7 @@ public class Transformers {\n         return transform(node.name, node::accept, chain);\n     }\n \n-    private byte[] transform(EnhancedClassReader reader, ClassVisitorChain chain) {\n+    private byte[] transform(ClassReader reader, ClassVisitorChain chain) {\n         return transform(reader.getClassName(), cv -> reader.accept(cv, 0), chain);\n     }\n \n"
    },
    {
        "commit_hash": "ea49b21357dbf8bdd08714f87ac75e5a61c8582f",
        "previous_commit_hash": "e5f6758ddfecdae0f30aba7a1c1660036b306e19",
        "diff_stats": {
            "additions": 9,
            "deletions": 8
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2018 Esko Luontola and other Retrolambda contributors\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -8,20 +8,21 @@ import org.objectweb.asm.*;\n \n public class EnhancedClassReader extends ClassReader {\n \n-    private final boolean isJavacHacksEnabled;\n+    public static ClassReader create(byte[] bytecode, boolean isJavacHacksEnabled) {\n+        if (isJavacHacksEnabled) {\n+            return new EnhancedClassReader(bytecode);\n+        } else {\n+            return new ClassReader(bytecode);\n+        }\n+    }\n \n-    public EnhancedClassReader(byte[] b, boolean isJavacHacksEnabled) {\n+    private EnhancedClassReader(byte[] b) {\n         super(b);\n-        this.isJavacHacksEnabled = isJavacHacksEnabled;\n     }\n \n     @Override\n     protected Label readLabel(int offset, Label[] labels) {\n-        if (!isJavacHacksEnabled) {\n-            return super.readLabel(offset, labels);\n-        }\n         // A workaround suggested by Evgeny Mandrikov. See more: https://gitlab.ow2.org/asm/asm/issues/317845\n         return super.readLabel(Math.min(offset, labels.length - 1), labels);\n     }\n-\n }\n"
    },
    {
        "commit_hash": "ea49b21357dbf8bdd08714f87ac75e5a61c8582f",
        "previous_commit_hash": "e5f6758ddfecdae0f30aba7a1c1660036b306e19",
        "diff_stats": {
            "additions": 3,
            "deletions": 2
        },
        "diff_content": "@@ -1,10 +1,11 @@\n-// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2018 Esko Luontola and other Retrolambda contributors\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n package net.orfjackal.retrolambda.files;\n \n import net.orfjackal.retrolambda.ext.ow2asm.EnhancedClassReader;\n+import org.objectweb.asm.ClassReader;\n \n import java.io.IOException;\n import java.nio.file.*;\n@@ -21,7 +22,7 @@ public class OutputDirectory {\n         if (bytecode == null) {\n             return;\n         }\n-        EnhancedClassReader cr = new EnhancedClassReader(bytecode, isJavacHacksEnabled);\n+        ClassReader cr = EnhancedClassReader.create(bytecode, isJavacHacksEnabled);\n         Path relativePath = outputDir.getFileSystem().getPath(cr.getClassName() + \".class\");\n         writeFile(relativePath, bytecode);\n     }\n"
    },
    {
        "commit_hash": "ea49b21357dbf8bdd08714f87ac75e5a61c8582f",
        "previous_commit_hash": "e5f6758ddfecdae0f30aba7a1c1660036b306e19",
        "diff_stats": {
            "additions": 3,
            "deletions": 4
        },
        "diff_content": "@@ -1,10 +1,9 @@\n-// Copyright \u00a9 2013-2015 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2018 Esko Luontola and other Retrolambda contributors\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n package net.orfjackal.retrolambda.interfaces;\n \n-import net.orfjackal.retrolambda.ext.ow2asm.EnhancedClassReader;\n import net.orfjackal.retrolambda.util.Flags;\n import org.objectweb.asm.*;\n \n@@ -12,7 +11,7 @@ import java.util.*;\n \n public class ClassInfo {\n \n-    public final EnhancedClassReader reader;\n+    public final ClassReader reader;\n     private final int access;\n     public final Type type;\n     public final Type superclass;\n@@ -27,7 +26,7 @@ public class ClassInfo {\n         this.superclass = null;\n     }\n \n-    public ClassInfo(EnhancedClassReader cr) {\n+    public ClassInfo(ClassReader cr) {\n         this.reader = cr;\n         this.access = cr.getAccess();\n         this.type = Type.getObjectType(cr.getClassName());\n"
    },
    {
        "commit_hash": "ea49b21357dbf8bdd08714f87ac75e5a61c8582f",
        "previous_commit_hash": "e5f6758ddfecdae0f30aba7a1c1660036b306e19",
        "diff_stats": {
            "additions": 3,
            "deletions": 4
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013-2017 Esko Luontola and other Retrolambda contributors\n+// Copyright \u00a9 2013-2018 Esko Luontola and other Retrolambda contributors\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -6,9 +6,8 @@ package net.orfjackal.retrolambda.lambdas;\n \n import com.esotericsoftware.minlog.Log;\n import net.orfjackal.retrolambda.Transformers;\n-import net.orfjackal.retrolambda.files.OutputDirectory;\n-\n import net.orfjackal.retrolambda.ext.ow2asm.EnhancedClassReader;\n+import net.orfjackal.retrolambda.files.OutputDirectory;\n \n import java.io.IOException;\n \n@@ -32,7 +31,7 @@ public class LambdaClassSaver {\n \n     private void reifyLambdaClass(String className, byte[] bytecode) {\n         Log.info(\"Saving lambda class: \" + className);\n-        bytecode = transformers.backportLambdaClass(new EnhancedClassReader(bytecode, isJavacHacksEnabled));\n+        bytecode = transformers.backportLambdaClass(EnhancedClassReader.create(bytecode, isJavacHacksEnabled));\n         try {\n             saver.writeClass(bytecode, isJavacHacksEnabled);\n         } catch (IOException e) {\n"
    },
    {
        "commit_hash": "ea49b21357dbf8bdd08714f87ac75e5a61c8582f",
        "previous_commit_hash": "e5f6758ddfecdae0f30aba7a1c1660036b306e19",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2018 Esko Luontola and other Retrolambda contributors\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -24,7 +24,7 @@ public class LambdaClassSaverAgent implements ClassFileTransformer {\n         if (className == null) {\n             // Since JDK 8 build b121 or so, lambda classes have a null class name,\n             // but we can read it from the bytecode where the name still exists.\n-            className = new EnhancedClassReader(classfileBuffer, isJavacHacksEnabled).getClassName();\n+            className = EnhancedClassReader.create(classfileBuffer, isJavacHacksEnabled).getClassName();\n         }\n         if (lambdaClassSaver != null) {\n             lambdaClassSaver.saveIfLambda(className, classfileBuffer);\n"
    },
    {
        "commit_hash": "f2ecfe7956edec475fbe52659054992830c6f856",
        "previous_commit_hash": "ea49b21357dbf8bdd08714f87ac75e5a61c8582f",
        "diff_stats": {
            "additions": 2,
            "deletions": 4
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013-2017 Esko Luontola and other Retrolambda contributors\n+// Copyright \u00a9 2013-2018 Esko Luontola and other Retrolambda contributors\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -46,9 +46,7 @@ public class Retrolambda {\n         Log.info(\"Included files:   \" + (includedFiles != null ? includedFiles.size() : \"all\"));\n         Log.info(\"JVM version:      \" + System.getProperty(\"java.version\"));\n         Log.info(\"Agent enabled:    \" + PreMain.isAgentLoaded());\n-        if (isJavacHacksEnabled) {\n-            Log.info(\"javac hacks:      \" + isJavacHacksEnabled);\n-        }\n+        Log.info(\"javac hacks:      \" + isJavacHacksEnabled);\n \n         if (!Files.isDirectory(inputDir)) {\n             Log.info(\"Nothing to do; not a directory: \" + inputDir);\n"
    },
    {
        "commit_hash": "390a1d933f419d49045c5e82b4ba0730f7396df8",
        "previous_commit_hash": "f2ecfe7956edec475fbe52659054992830c6f856",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -55,7 +55,7 @@ To run Retrolambda using Maven, add the following to your pom.xml:\n <plugin>\n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>retrolambda-maven-plugin</artifactId>\n-    <version>2.5.4</version>\n+    <version>2.5.5</version>\n     <executions>\n         <execution>\n             <goals>\n@@ -241,7 +241,7 @@ yourself or pay someone to do it, if you think it's worth the effort. ;)\n Version History\n ---------------\n \n-### Upcoming\n+### Retrolambda 2.5.5 (2018-08-14)\n \n - Fix an `ArrayIndexOutOfBoundsException` crash in ASM due to incorrect bytecode \n   produced by `javac` under some circumstances. See [JDK-8073658](https://bugs.openjdk.java.net/browse/JDK-8073658)\n"
    },
    {
        "commit_hash": "390a1d933f419d49045c5e82b4ba0730f7396df8",
        "previous_commit_hash": "f2ecfe7956edec475fbe52659054992830c6f856",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.5-SNAPSHOT</version>\n+        <version>2.5.5</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "390a1d933f419d49045c5e82b4ba0730f7396df8",
        "previous_commit_hash": "f2ecfe7956edec475fbe52659054992830c6f856",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>2.5.5-SNAPSHOT</version>\n+    <version>2.5.5</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "390a1d933f419d49045c5e82b4ba0730f7396df8",
        "previous_commit_hash": "f2ecfe7956edec475fbe52659054992830c6f856",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.5-SNAPSHOT</version>\n+        <version>2.5.5</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "390a1d933f419d49045c5e82b4ba0730f7396df8",
        "previous_commit_hash": "f2ecfe7956edec475fbe52659054992830c6f856",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.5-SNAPSHOT</version>\n+        <version>2.5.5</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "390a1d933f419d49045c5e82b4ba0730f7396df8",
        "previous_commit_hash": "f2ecfe7956edec475fbe52659054992830c6f856",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.5-SNAPSHOT</version>\n+        <version>2.5.5</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "390a1d933f419d49045c5e82b4ba0730f7396df8",
        "previous_commit_hash": "f2ecfe7956edec475fbe52659054992830c6f856",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.5-SNAPSHOT</version>\n+        <version>2.5.5</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "1f26f13c98cd57ecc56a5f8afa4c56e7b98bfa18",
        "previous_commit_hash": "390a1d933f419d49045c5e82b4ba0730f7396df8",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.5</version>\n+        <version>2.5.6-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "1f26f13c98cd57ecc56a5f8afa4c56e7b98bfa18",
        "previous_commit_hash": "390a1d933f419d49045c5e82b4ba0730f7396df8",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>2.5.5</version>\n+    <version>2.5.6-SNAPSHOT</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "1f26f13c98cd57ecc56a5f8afa4c56e7b98bfa18",
        "previous_commit_hash": "390a1d933f419d49045c5e82b4ba0730f7396df8",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.5</version>\n+        <version>2.5.6-SNAPSHOT</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "1f26f13c98cd57ecc56a5f8afa4c56e7b98bfa18",
        "previous_commit_hash": "390a1d933f419d49045c5e82b4ba0730f7396df8",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.5</version>\n+        <version>2.5.6-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "1f26f13c98cd57ecc56a5f8afa4c56e7b98bfa18",
        "previous_commit_hash": "390a1d933f419d49045c5e82b4ba0730f7396df8",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.5</version>\n+        <version>2.5.6-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "1f26f13c98cd57ecc56a5f8afa4c56e7b98bfa18",
        "previous_commit_hash": "390a1d933f419d49045c5e82b4ba0730f7396df8",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.5</version>\n+        <version>2.5.6-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "2b181dc3b0509c4b0b002197b9b13de57540f9c4",
        "previous_commit_hash": "1f26f13c98cd57ecc56a5f8afa4c56e7b98bfa18",
        "diff_stats": {
            "additions": 4,
            "deletions": 4
        },
        "diff_content": "@@ -1,13 +1,13 @@\n <component name=\"libraryTable\">\n-  <library name=\"Maven: org.apache.commons:commons-lang3:3.5\">\n+  <library name=\"Maven: org.apache.commons:commons-lang3:3.8.1\">\n     <CLASSES>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/commons/commons-lang3/3.5/commons-lang3-3.5.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/commons/commons-lang3/3.8.1/commons-lang3-3.8.1.jar!/\" />\n     </CLASSES>\n     <JAVADOC>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/commons/commons-lang3/3.5/commons-lang3-3.5-javadoc.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/commons/commons-lang3/3.8.1/commons-lang3-3.8.1-javadoc.jar!/\" />\n     </JAVADOC>\n     <SOURCES>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/commons/commons-lang3/3.5/commons-lang3-3.5-sources.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/commons/commons-lang3/3.8.1/commons-lang3-3.8.1-sources.jar!/\" />\n     </SOURCES>\n   </library>\n </component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "2b181dc3b0509c4b0b002197b9b13de57540f9c4",
        "previous_commit_hash": "1f26f13c98cd57ecc56a5f8afa4c56e7b98bfa18",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,13 @@\n+<component name=\"libraryTable\">\n+  <library name=\"Maven: org.ow2.asm:asm:7.0\">\n+    <CLASSES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm/7.0/asm-7.0.jar!/\" />\n+    </CLASSES>\n+    <JAVADOC>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm/7.0/asm-7.0-javadoc.jar!/\" />\n+    </JAVADOC>\n+    <SOURCES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm/7.0/asm-7.0-sources.jar!/\" />\n+    </SOURCES>\n+  </library>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "2b181dc3b0509c4b0b002197b9b13de57540f9c4",
        "previous_commit_hash": "1f26f13c98cd57ecc56a5f8afa4c56e7b98bfa18",
        "diff_stats": {
            "additions": 0,
            "deletions": 13
        },
        "diff_content": "@@ -1,13 +0,0 @@\n-<component name=\"libraryTable\">\n-  <library name=\"Maven: org.ow2.asm:asm-debug-all:5.2\">\n-    <CLASSES>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm-debug-all/5.2/asm-debug-all-5.2.jar!/\" />\n-    </CLASSES>\n-    <JAVADOC>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm-debug-all/5.2/asm-debug-all-5.2-javadoc.jar!/\" />\n-    </JAVADOC>\n-    <SOURCES>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm-debug-all/5.2/asm-debug-all-5.2-sources.jar!/\" />\n-    </SOURCES>\n-  </library>\n-</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "2b181dc3b0509c4b0b002197b9b13de57540f9c4",
        "previous_commit_hash": "1f26f13c98cd57ecc56a5f8afa4c56e7b98bfa18",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,13 @@\n+<component name=\"libraryTable\">\n+  <library name=\"Maven: org.ow2.asm:asm-tree:7.0\">\n+    <CLASSES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm-tree/7.0/asm-tree-7.0.jar!/\" />\n+    </CLASSES>\n+    <JAVADOC>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm-tree/7.0/asm-tree-7.0-javadoc.jar!/\" />\n+    </JAVADOC>\n+    <SOURCES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm-tree/7.0/asm-tree-7.0-sources.jar!/\" />\n+    </SOURCES>\n+  </library>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "2b181dc3b0509c4b0b002197b9b13de57540f9c4",
        "previous_commit_hash": "1f26f13c98cd57ecc56a5f8afa4c56e7b98bfa18",
        "diff_stats": {
            "additions": 2,
            "deletions": 1
        },
        "diff_content": "@@ -14,7 +14,8 @@\n     <orderEntry type=\"library\" name=\"Maven: com.google.guava:guava:11.0.2\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: com.google.code.findbugs:jsr305:1.3.9\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: commons-lang:commons-lang:2.6\" level=\"project\" />\n-    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.ow2.asm:asm-debug-all:5.2\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.ow2.asm:asm:7.0\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.ow2.asm:asm-tree:7.0\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.apache.bcel:bcel:5.2\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: jakarta-regexp:jakarta-regexp:1.4\" level=\"project\" />\n     <orderEntry type=\"module-library\">\n"
    },
    {
        "commit_hash": "2b181dc3b0509c4b0b002197b9b13de57540f9c4",
        "previous_commit_hash": "1f26f13c98cd57ecc56a5f8afa4c56e7b98bfa18",
        "diff_stats": {
            "additions": 7,
            "deletions": 1
        },
        "diff_content": "@@ -30,7 +30,13 @@\n \n         <dependency>\n             <groupId>org.ow2.asm</groupId>\n-            <artifactId>asm-debug-all</artifactId>\n+            <artifactId>asm</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>org.ow2.asm</groupId>\n+            <artifactId>asm-tree</artifactId>\n             <scope>test</scope>\n         </dependency>\n \n"
    },
    {
        "commit_hash": "2b181dc3b0509c4b0b002197b9b13de57540f9c4",
        "previous_commit_hash": "1f26f13c98cd57ecc56a5f8afa4c56e7b98bfa18",
        "diff_stats": {
            "additions": 9,
            "deletions": 3
        },
        "diff_content": "@@ -85,8 +85,14 @@\n \n             <dependency>\n                 <groupId>org.ow2.asm</groupId>\n-                <artifactId>asm-debug-all</artifactId>\n-                <version>5.2</version>\n+                <artifactId>asm</artifactId>\n+                <version>7.0</version>\n+            </dependency>\n+\n+            <dependency>\n+                <groupId>org.ow2.asm</groupId>\n+                <artifactId>asm-tree</artifactId>\n+                <version>7.0</version>\n             </dependency>\n \n             <dependency>\n@@ -312,7 +318,7 @@\n \n                 <plugin>\n                     <artifactId>maven-plugin-plugin</artifactId>\n-                    <version>3.4</version>\n+                    <version>3.6.0</version>\n                 </plugin>\n \n                 <plugin>\n"
    },
    {
        "commit_hash": "2b181dc3b0509c4b0b002197b9b13de57540f9c4",
        "previous_commit_hash": "1f26f13c98cd57ecc56a5f8afa4c56e7b98bfa18",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -61,7 +61,7 @@\n         <dependency>\n             <groupId>org.apache.commons</groupId>\n             <artifactId>commons-lang3</artifactId>\n-            <version>3.5</version>\n+            <version>3.8.1</version>\n         </dependency>\n \n     </dependencies>\n"
    },
    {
        "commit_hash": "2b181dc3b0509c4b0b002197b9b13de57540f9c4",
        "previous_commit_hash": "1f26f13c98cd57ecc56a5f8afa4c56e7b98bfa18",
        "diff_stats": {
            "additions": 3,
            "deletions": 2
        },
        "diff_content": "@@ -13,7 +13,8 @@\n     <orderEntry type=\"inheritedJdk\" />\n     <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n     <orderEntry type=\"module\" module-name=\"retrolambda\" />\n-    <orderEntry type=\"library\" name=\"Maven: org.ow2.asm:asm-debug-all:5.2\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.ow2.asm:asm:7.0\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.ow2.asm:asm-tree:7.0\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: com.esotericsoftware:minlog:1.3\" level=\"project\" />\n     <orderEntry type=\"module\" module-name=\"retrolambda-api\" />\n     <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-plugin-api:3.0\" level=\"project\" />\n@@ -41,7 +42,7 @@\n     <orderEntry type=\"library\" name=\"Maven: org.sonatype.plexus:plexus-sec-dispatcher:1.3\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.sonatype.plexus:plexus-cipher:1.4\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: com.google.guava:guava:18.0\" level=\"project\" />\n-    <orderEntry type=\"library\" name=\"Maven: org.apache.commons:commons-lang3:3.5\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.apache.commons:commons-lang3:3.8.1\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.12\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-library:1.3\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-core:1.3\" level=\"project\" />\n"
    },
    {
        "commit_hash": "2b181dc3b0509c4b0b002197b9b13de57540f9c4",
        "previous_commit_hash": "1f26f13c98cd57ecc56a5f8afa4c56e7b98bfa18",
        "diff_stats": {
            "additions": 7,
            "deletions": 1
        },
        "diff_content": "@@ -23,7 +23,12 @@\n \n         <dependency>\n             <groupId>org.ow2.asm</groupId>\n-            <artifactId>asm-debug-all</artifactId>\n+            <artifactId>asm</artifactId>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>org.ow2.asm</groupId>\n+            <artifactId>asm-tree</artifactId>\n         </dependency>\n \n         <dependency>\n@@ -50,6 +55,7 @@\n                             <mainClass>net.orfjackal.retrolambda.Main</mainClass>\n                         </manifest>\n                         <manifestEntries>\n+                            <Can-Retransform-Classes>true</Can-Retransform-Classes>\n                             <Premain-Class>net.orfjackal.retrolambda.PreMain</Premain-Class>\n                         </manifestEntries>\n                     </archive>\n"
    },
    {
        "commit_hash": "2b181dc3b0509c4b0b002197b9b13de57540f9c4",
        "previous_commit_hash": "1f26f13c98cd57ecc56a5f8afa4c56e7b98bfa18",
        "diff_stats": {
            "additions": 2,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,8 @@\n     <orderEntry type=\"inheritedJdk\" />\n     <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n     <orderEntry type=\"module\" module-name=\"retrolambda-api\" />\n-    <orderEntry type=\"library\" name=\"Maven: org.ow2.asm:asm-debug-all:5.2\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.ow2.asm:asm:7.0\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.ow2.asm:asm-tree:7.0\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: com.google.guava:guava:18.0\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: com.esotericsoftware:minlog:1.3\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.12\" level=\"project\" />\n"
    },
    {
        "commit_hash": "2b181dc3b0509c4b0b002197b9b13de57540f9c4",
        "previous_commit_hash": "1f26f13c98cd57ecc56a5f8afa4c56e7b98bfa18",
        "diff_stats": {
            "additions": 36,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,36 @@\n+// Copyright \u00a9 2013-2018 Esko Luontola and other Retrolambda contributors\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda;\n+\n+import net.orfjackal.retrolambda.ext.ow2asm.EnhancedClassReader;\n+import net.orfjackal.retrolambda.lambdas.LambdaClassSaver;\n+import org.objectweb.asm.ClassReader;\n+\n+public class Agent {\n+\n+    private static boolean enabled = false;\n+    private static LambdaClassSaver lambdaClassSaver;\n+    private static boolean isJavacHacksEnabled;\n+\n+    public static void enable() {\n+        enabled = true;\n+    }\n+\n+    public static boolean isEnabled() {\n+        return enabled;\n+    }\n+\n+    public static void setLambdaClassSaver(LambdaClassSaver lambdaClassSaver, boolean isJavacHacksEnabled) {\n+        Agent.lambdaClassSaver = lambdaClassSaver;\n+        Agent.isJavacHacksEnabled = isJavacHacksEnabled;\n+    }\n+\n+    public static void saveLambda(byte[] bytes) {\n+        if (lambdaClassSaver != null) {\n+            ClassReader reader = EnhancedClassReader.create(bytes, isJavacHacksEnabled);\n+            lambdaClassSaver.saveIfLambda(reader.getClassName(), bytes);\n+        }\n+    }\n+}\n"
    },
    {
        "commit_hash": "2b181dc3b0509c4b0b002197b9b13de57540f9c4",
        "previous_commit_hash": "1f26f13c98cd57ecc56a5f8afa4c56e7b98bfa18",
        "diff_stats": {
            "additions": 11,
            "deletions": 11
        },
        "diff_content": "@@ -6,23 +6,23 @@ package net.orfjackal.retrolambda;\n \n import net.orfjackal.retrolambda.lambdas.*;\n \n+import java.io.File;\n import java.lang.instrument.Instrumentation;\n+import java.net.URISyntaxException;\n+import java.util.jar.JarFile;\n \n public class PreMain {\n \n-    private static final LambdaClassSaverAgent agent = new LambdaClassSaverAgent();\n-    private static boolean agentLoaded = false;\n+    public static void premain(String agentArgs, Instrumentation inst) throws Exception {\n+        // Append the agent JAR to the bootstrap search path so that the instrumented InnerClassLambdaMetaFactory\n+        // could refer to Agent.\n+        inst.appendToBootstrapClassLoaderSearch(new JarFile(getAgentJarFile()));\n \n-    public static void premain(String agentArgs, Instrumentation inst) {\n-        inst.addTransformer(agent);\n-        agentLoaded = true;\n+        inst.addTransformer(new InnerClassLambdaMetafactoryTransformer(), true);\n+        inst.retransformClasses(Class.forName(\"java.lang.invoke.InnerClassLambdaMetafactory\"));\n     }\n \n-    public static boolean isAgentLoaded() {\n-        return agentLoaded;\n-    }\n-\n-    public static void setLambdaClassSaver(LambdaClassSaver lambdaClassSaver, boolean isJavacHacksEnabled) {\n-        agent.setLambdaClassSaver(lambdaClassSaver, isJavacHacksEnabled);\n+    private static File getAgentJarFile() throws URISyntaxException {\n+        return new File(PreMain.class.getProtectionDomain().getCodeSource().getLocation().toURI());\n     }\n }\n"
    },
    {
        "commit_hash": "2b181dc3b0509c4b0b002197b9b13de57540f9c4",
        "previous_commit_hash": "1f26f13c98cd57ecc56a5f8afa4c56e7b98bfa18",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -45,7 +45,7 @@ public class Retrolambda {\n         Log.info(\"Classpath:        \" + classpath);\n         Log.info(\"Included files:   \" + (includedFiles != null ? includedFiles.size() : \"all\"));\n         Log.info(\"JVM version:      \" + System.getProperty(\"java.version\"));\n-        Log.info(\"Agent enabled:    \" + PreMain.isAgentLoaded());\n+        Log.info(\"Agent enabled:    \" + Agent.isEnabled());\n         Log.info(\"javac hacks:      \" + isJavacHacksEnabled);\n \n         if (!Files.isDirectory(inputDir)) {\n@@ -61,8 +61,8 @@ public class Retrolambda {\n         LambdaClassSaver lambdaClassSaver = new LambdaClassSaver(outputDirectory, transformers, isJavacHacksEnabled);\n \n         try (LambdaClassDumper dumper = new LambdaClassDumper(lambdaClassSaver)) {\n-            if (PreMain.isAgentLoaded()) {\n-                PreMain.setLambdaClassSaver(lambdaClassSaver, isJavacHacksEnabled);\n+            if (Agent.isEnabled()) {\n+                Agent.setLambdaClassSaver(lambdaClassSaver, isJavacHacksEnabled);\n             } else {\n                 dumper.install();\n             }\n"
    },
    {
        "commit_hash": "2b181dc3b0509c4b0b002197b9b13de57540f9c4",
        "previous_commit_hash": "1f26f13c98cd57ecc56a5f8afa4c56e7b98bfa18",
        "diff_stats": {
            "additions": 61,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,61 @@\n+// Copyright \u00a9 2013-2018 Esko Luontola and other Retrolambda contributors\n+// This software is released under the Apache License 2.0.\n+// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n+\n+package net.orfjackal.retrolambda.lambdas;\n+\n+import com.esotericsoftware.minlog.Log;\n+import net.orfjackal.retrolambda.Agent;\n+import org.objectweb.asm.*;\n+\n+import java.lang.instrument.*;\n+import java.security.ProtectionDomain;\n+\n+public class InnerClassLambdaMetafactoryTransformer implements ClassFileTransformer {\n+    @Override\n+    public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] bytes) throws IllegalClassFormatException {\n+        if (!\"java/lang/invoke/InnerClassLambdaMetafactory\".equals(className)) {\n+            return null;\n+        }\n+\n+        try {\n+            byte[] transformed = transformMetafactory(bytes);\n+            Agent.enable();\n+            return transformed;\n+        } catch (Throwable e) {\n+            Log.error(\"Failed to transform \" + className, e);\n+            return null;\n+        }\n+    }\n+\n+    private byte[] transformMetafactory(byte[] bytes) {\n+        ClassReader cr = new ClassReader(bytes);\n+        ClassWriter cw = new ClassWriter(cr, 0);\n+        ClassVisitor cv = new ClassVisitor(Opcodes.ASM7, cw) {\n+            @Override\n+            public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+                MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n+                if (name.equals(\"spinInnerClass\")) {\n+                    mv = new MethodVisitor(Opcodes.ASM7, mv) {\n+                        @Override\n+                        public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\n+                            super.visitMethodInsn(opcode, owner, name, desc, itf);\n+                            if (name.equals(\"toByteArray\")) {\n+                                mv.visitInsn(Opcodes.DUP);\n+                                mv.visitMethodInsn(Opcodes.INVOKESTATIC, Type.getInternalName(Agent.class), \"saveLambda\", \"([B)V\", false);\n+                            }\n+                        }\n+\n+                        @Override\n+                        public void visitMaxs(int maxStack, int maxLocals) {\n+                            super.visitMaxs(maxStack + 1, maxLocals);\n+                        }\n+                    };\n+                }\n+                return mv;\n+            }\n+        };\n+        cr.accept(cv, 0);\n+        return cw.toByteArray();\n+    }\n+}\n"
    },
    {
        "commit_hash": "2b181dc3b0509c4b0b002197b9b13de57540f9c4",
        "previous_commit_hash": "1f26f13c98cd57ecc56a5f8afa4c56e7b98bfa18",
        "diff_stats": {
            "additions": 0,
            "deletions": 34
        },
        "diff_content": "@@ -1,34 +0,0 @@\n-// Copyright \u00a9 2013-2018 Esko Luontola and other Retrolambda contributors\n-// This software is released under the Apache License 2.0.\n-// The license text is at http://www.apache.org/licenses/LICENSE-2.0\n-\n-package net.orfjackal.retrolambda.lambdas;\n-\n-import net.orfjackal.retrolambda.ext.ow2asm.EnhancedClassReader;\n-\n-import java.lang.instrument.*;\n-import java.security.ProtectionDomain;\n-\n-public class LambdaClassSaverAgent implements ClassFileTransformer {\n-\n-    private LambdaClassSaver lambdaClassSaver;\n-    private boolean isJavacHacksEnabled;\n-\n-    public void setLambdaClassSaver(LambdaClassSaver lambdaClassSaver, boolean isJavacHacksEnabled) {\n-        this.lambdaClassSaver = lambdaClassSaver;\n-        this.isJavacHacksEnabled = isJavacHacksEnabled;\n-    }\n-\n-    @Override\n-    public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {\n-        if (className == null) {\n-            // Since JDK 8 build b121 or so, lambda classes have a null class name,\n-            // but we can read it from the bytecode where the name still exists.\n-            className = EnhancedClassReader.create(classfileBuffer, isJavacHacksEnabled).getClassName();\n-        }\n-        if (lambdaClassSaver != null) {\n-            lambdaClassSaver.saveIfLambda(className, classfileBuffer);\n-        }\n-        return null;\n-    }\n-}\n"
    },
    {
        "commit_hash": "df5e002cdc661cf9bf491c0fc2cb4aefe4aae5ea",
        "previous_commit_hash": "1f26f13c98cd57ecc56a5f8afa4c56e7b98bfa18",
        "diff_stats": {
            "additions": 15,
            "deletions": 7
        },
        "diff_content": "@@ -5,6 +5,7 @@ MOUNT installers:/installers\n RUN cd /installers \\\n \t&& chmod u+x jdk-1_5_0_22-linux-amd64-rpm.bin \\\n \t&& echo yes | ./jdk-1_5_0_22-linux-amd64-rpm.bin\n+ENV JAVA5_HOME=/usr/java/jdk1.5.0_22\n \n # Install JDK 6, 7, 8\n RUN yum -y install \\\n@@ -12,18 +13,25 @@ RUN yum -y install \\\n \t\tjava-1.7.0-openjdk-devel \\\n \t\tjava-1.8.0-openjdk-devel \\\n \t&& yum clean all\n-\n-# Install JDK 9\n-RUN rpm -Uvh /installers/jdk-9.0.1_linux-x64_bin.rpm\n-\n-ENV JAVA5_HOME=/usr/java/jdk1.5.0_22\n ENV JAVA6_HOME=/usr/lib/jvm/java-1.6.0\n ENV JAVA7_HOME=/usr/lib/jvm/java-1.7.0\n ENV JAVA8_HOME=/usr/lib/jvm/java-1.8.0\n-ENV JAVA9_HOME=/usr/java/jdk-9.0.1\n+\n+# Install JDK 9\n+RUN rpm -Uvh /installers/jdk-9.0.4_linux-x64_bin.rpm\n+ENV JAVA9_HOME=/usr/java/jdk-9.0.4\n+\n+# Install JDK 10\n+RUN rpm -Uvh /installers/jdk-10.0.2_linux-x64_bin.rpm\n+ENV JAVA10_HOME=/usr/java/jdk-10.0.2\n+\n+# Install JDK 11\n+RUN rpm -Uvh /installers/jdk-11.0.1_linux-x64_bin.rpm\n+ENV JAVA11_HOME=/usr/java/jdk-11.0.1\n+\n ENV JAVA_HOME=$JAVA8_HOME\n \n-# Install Maven\n+# Install Maven 3.2.5 (the last version to support Java 6)\n RUN curl http://archive.apache.org/dist/maven/maven-3/3.2.5/binaries/apache-maven-3.2.5-bin.tar.gz \\\n \t\t-o apache-maven-3.2.5-bin.tar.gz \\\n \t&& tar -xzf apache-maven-3.2.5-bin.tar.gz -C /opt \\\n"
    },
    {
        "commit_hash": "6c5e85ed21e539d55fb9916f3efb42cc8f6d08af",
        "previous_commit_hash": "df5e002cdc661cf9bf491c0fc2cb4aefe4aae5ea",
        "diff_stats": {
            "additions": 4,
            "deletions": 4
        },
        "diff_content": "@@ -1,13 +1,13 @@\n <component name=\"libraryTable\">\n-  <library name=\"Maven: org.apache.commons:commons-lang3:3.5\">\n+  <library name=\"Maven: org.apache.commons:commons-lang3:3.8.1\">\n     <CLASSES>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/commons/commons-lang3/3.5/commons-lang3-3.5.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/commons/commons-lang3/3.8.1/commons-lang3-3.8.1.jar!/\" />\n     </CLASSES>\n     <JAVADOC>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/commons/commons-lang3/3.5/commons-lang3-3.5-javadoc.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/commons/commons-lang3/3.8.1/commons-lang3-3.8.1-javadoc.jar!/\" />\n     </JAVADOC>\n     <SOURCES>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/commons/commons-lang3/3.5/commons-lang3-3.5-sources.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/commons/commons-lang3/3.8.1/commons-lang3-3.8.1-sources.jar!/\" />\n     </SOURCES>\n   </library>\n </component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "6c5e85ed21e539d55fb9916f3efb42cc8f6d08af",
        "previous_commit_hash": "df5e002cdc661cf9bf491c0fc2cb4aefe4aae5ea",
        "diff_stats": {
            "additions": 4,
            "deletions": 0
        },
        "diff_content": "@@ -241,6 +241,10 @@ yourself or pay someone to do it, if you think it's worth the effort. ;)\n Version History\n ---------------\n \n+### Upcoming\n+\n+- Fix a `NullPointerException` crash in the Maven plugin on Java 10 & 11\n+\n ### Retrolambda 2.5.5 (2018-08-14)\n \n - Fix an `ArrayIndexOutOfBoundsException` crash in ASM due to incorrect bytecode \n"
    },
    {
        "commit_hash": "6c5e85ed21e539d55fb9916f3efb42cc8f6d08af",
        "previous_commit_hash": "df5e002cdc661cf9bf491c0fc2cb4aefe4aae5ea",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -61,7 +61,7 @@\n         <dependency>\n             <groupId>org.apache.commons</groupId>\n             <artifactId>commons-lang3</artifactId>\n-            <version>3.5</version>\n+            <version>3.8.1</version>\n         </dependency>\n \n     </dependencies>\n"
    },
    {
        "commit_hash": "6c5e85ed21e539d55fb9916f3efb42cc8f6d08af",
        "previous_commit_hash": "df5e002cdc661cf9bf491c0fc2cb4aefe4aae5ea",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -41,7 +41,7 @@\n     <orderEntry type=\"library\" name=\"Maven: org.sonatype.plexus:plexus-sec-dispatcher:1.3\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.sonatype.plexus:plexus-cipher:1.4\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: com.google.guava:guava:18.0\" level=\"project\" />\n-    <orderEntry type=\"library\" name=\"Maven: org.apache.commons:commons-lang3:3.5\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.apache.commons:commons-lang3:3.8.1\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.12\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-library:1.3\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-core:1.3\" level=\"project\" />\n"
    },
    {
        "commit_hash": "6c5e85ed21e539d55fb9916f3efb42cc8f6d08af",
        "previous_commit_hash": "df5e002cdc661cf9bf491c0fc2cb4aefe4aae5ea",
        "diff_stats": {
            "additions": 5,
            "deletions": 1
        },
        "diff_content": "@@ -40,7 +40,11 @@ JAVA_HOME=\"$JAVA6_HOME\" mvn clean verify \\\n     -P java6\n \n # Java 9 has stricter bytecode validation than Java 8,\n-# so make sure that Retrolambda can run under Java 9 (without forking)\n+# so make sure that Retrolambda can run under new Java versions (without forking)\n \n JAVA_HOME=\"$JAVA9_HOME\" mvn clean verify \\\n     --errors\n+JAVA_HOME=\"$JAVA10_HOME\" mvn clean verify \\\n+    --errors\n+JAVA_HOME=\"$JAVA11_HOME\" mvn clean verify \\\n+    --errors\n"
    },
    {
        "commit_hash": "cdb21e902c6dd4afd44f68b4b91b340e2504044a",
        "previous_commit_hash": "6c5e85ed21e539d55fb9916f3efb42cc8f6d08af",
        "diff_stats": {
            "additions": 16,
            "deletions": 0
        },
        "diff_content": "@@ -146,6 +146,22 @@\n             </build>\n         </profile>\n \n+        <profile>\n+            <id>noToolchain</id>\n+            <build>\n+                <plugins>\n+                    <plugin>\n+                        <artifactId>maven-toolchains-plugin</artifactId>\n+                        <executions>\n+                            <execution>\n+                                <phase>none</phase>\n+                            </execution>\n+                        </executions>\n+                    </plugin>\n+                </plugins>\n+            </build>\n+        </profile>\n+\n         <profile>\n             <id>eclipse</id>\n             <build>\n"
    },
    {
        "commit_hash": "cdb21e902c6dd4afd44f68b4b91b340e2504044a",
        "previous_commit_hash": "6c5e85ed21e539d55fb9916f3efb42cc8f6d08af",
        "diff_stats": {
            "additions": 12,
            "deletions": 0
        },
        "diff_content": "@@ -48,3 +48,15 @@ JAVA_HOME=\"$JAVA10_HOME\" mvn clean verify \\\n     --errors\n JAVA_HOME=\"$JAVA11_HOME\" mvn clean verify \\\n     --errors\n+\n+# Make sure that the Java agent works on all new Java versions\n+\n+JAVA_HOME=\"$JAVA9_HOME\" mvn clean verify \\\n+    --errors \\\n+    -P fork,noToolchain\n+JAVA_HOME=\"$JAVA10_HOME\" mvn clean verify \\\n+    --errors \\\n+    -P fork,noToolchain\n+JAVA_HOME=\"$JAVA11_HOME\" mvn clean verify \\\n+    --errors \\\n+    -P fork,noToolchain\n"
    },
    {
        "commit_hash": "ca14692ddc6cfa5a5e6c708cd7238fc61bac75e5",
        "previous_commit_hash": "f099ac0ac6caa74e28ab840a70b8532653f718a4",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -4,3 +4,4 @@\n .settings\n .project\n .DS_Store\n+/build.log\n"
    },
    {
        "commit_hash": "ca14692ddc6cfa5a5e6c708cd7238fc61bac75e5",
        "previous_commit_hash": "f099ac0ac6caa74e28ab840a70b8532653f718a4",
        "diff_stats": {
            "additions": 17,
            "deletions": 1
        },
        "diff_content": "@@ -23,12 +23,16 @@ public class InnerClassLambdaMetafactoryTransformer implements ClassFileTransfor\n             Agent.enable();\n             return transformed;\n         } catch (Throwable e) {\n-            Log.error(\"Failed to transform \" + className, e);\n+            Log.error(\"Failed to transform \" + className + \", cannot enable the Java agent. \" +\n+                    \"Please report an issue to Retrolambda with full logs. \" +\n+                    \"Probably you're running on an unsupported Java version.\", e);\n             return null;\n         }\n     }\n \n     private byte[] transformMetafactory(byte[] bytes) {\n+        final boolean[] spinInnerClassFound = {false};\n+        final boolean[] toByteArrayFound = {false};\n         ClassReader cr = new ClassReader(bytes);\n         ClassWriter cw = new ClassWriter(cr, 0);\n         ClassVisitor cv = new ClassVisitor(Opcodes.ASM7, cw) {\n@@ -36,11 +40,17 @@ public class InnerClassLambdaMetafactoryTransformer implements ClassFileTransfor\n             public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n                 MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n                 if (name.equals(\"spinInnerClass\")) {\n+                    spinInnerClassFound[0] = true;\n                     mv = new MethodVisitor(Opcodes.ASM7, mv) {\n                         @Override\n                         public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\n                             super.visitMethodInsn(opcode, owner, name, desc, itf);\n                             if (name.equals(\"toByteArray\")) {\n+                                if (toByteArrayFound[0]) {\n+                                    throw new RuntimeException(\"Found multiple toByteArray calls\");\n+                                } else {\n+                                    toByteArrayFound[0] = true;\n+                                }\n                                 mv.visitInsn(Opcodes.DUP);\n                                 mv.visitMethodInsn(Opcodes.INVOKESTATIC, Type.getInternalName(Agent.class), \"saveLambda\", \"([B)V\", false);\n                             }\n@@ -56,6 +66,12 @@ public class InnerClassLambdaMetafactoryTransformer implements ClassFileTransfor\n             }\n         };\n         cr.accept(cv, 0);\n+        if (!spinInnerClassFound[0]) {\n+            throw new RuntimeException(\"Could not find the spinInnerClass method\");\n+        }\n+        if (!toByteArrayFound[0]) {\n+            throw new RuntimeException(\"Could not find the toByteArray call\");\n+        }\n         return cw.toByteArray();\n     }\n }\n"
    },
    {
        "commit_hash": "ca14692ddc6cfa5a5e6c708cd7238fc61bac75e5",
        "previous_commit_hash": "f099ac0ac6caa74e28ab840a70b8532653f718a4",
        "diff_stats": {
            "additions": 55,
            "deletions": 16
        },
        "diff_content": "@@ -1,62 +1,101 @@\n #!/bin/bash\n-set -eux\n+set -eu\n+\n+# If fork fails because the Java agent cannot be installed,\n+# it will log an error and use the fallback technique.\n+# We need to check the logs for an error to detect the failure.\n+check_build_log () {\n+    grep ERROR build.log && exit 1\n+    rm build.log\n+}\n+\n+set -x\n \n # Run end-to-end tests against all supported Java versions\n \n+## Java 7\n+\n mvn clean verify \\\n     --errors \\\n-    -P noDefaultMethods\n+    -P noDefaultMethods \\\n+    | tee build.log && check_build_log\n+\n mvn clean verify \\\n-    --errors\n+    --errors \\\n+    | tee build.log && check_build_log\n+\n+## Java 6\n \n mvn clean verify \\\n     --errors \\\n-    -P java6,noDefaultMethods\n+    -P java6,noDefaultMethods \\\n+    | tee build.log && check_build_log\n+\n mvn clean verify \\\n     --errors \\\n-    -P java6\n+    -P java6 \\\n+    | tee build.log && check_build_log\n+\n+## Java 5\n \n mvn clean verify \\\n     --errors \\\n-    -P java5,noDefaultMethods\n+    -P java5,noDefaultMethods \\\n+    | tee build.log && check_build_log\n+\n mvn clean verify \\\n     --errors \\\n-    -P java5\n+    -P java5 \\\n+    | tee build.log && check_build_log\n \n # Test the forking mechanism\n \n mvn clean verify \\\n     --errors \\\n-    -P fork,noDefaultMethods\n+    -P fork,noDefaultMethods \\\n+    | tee build.log && check_build_log\n+\n mvn clean verify \\\n     --errors \\\n-    -P fork\n+    -P fork \\\n+    | tee build.log && check_build_log\n \n # The Maven plugin's minimum requirement is Java 6,\n # but then the plugin must force forking the process\n \n JAVA_HOME=\"$JAVA6_HOME\" mvn clean verify \\\n     --errors \\\n-    -P java6\n+    -P java6 \\\n+    | tee build.log && check_build_log\n \n # Java 9 has stricter bytecode validation than Java 8,\n # so make sure that Retrolambda can run under new Java versions (without forking)\n \n JAVA_HOME=\"$JAVA9_HOME\" mvn clean verify \\\n-    --errors\n+    --errors \\\n+    | tee build.log && check_build_log\n+\n JAVA_HOME=\"$JAVA10_HOME\" mvn clean verify \\\n-    --errors\n+    --errors \\\n+    | tee build.log && check_build_log\n+\n JAVA_HOME=\"$JAVA11_HOME\" mvn clean verify \\\n-    --errors\n+    --errors \\\n+    | tee build.log && check_build_log\n \n # Make sure that the Java agent works on all new Java versions\n \n JAVA_HOME=\"$JAVA9_HOME\" mvn clean verify \\\n     --errors \\\n-    -P fork,noToolchain\n+    -P fork,noToolchain \\\n+    | tee build.log && check_build_log\n+\n JAVA_HOME=\"$JAVA10_HOME\" mvn clean verify \\\n     --errors \\\n-    -P fork,noToolchain\n+    -P fork,noToolchain \\\n+    | tee build.log && check_build_log\n+\n JAVA_HOME=\"$JAVA11_HOME\" mvn clean verify \\\n     --errors \\\n-    -P fork,noToolchain\n+    -P fork,noToolchain \\\n+    | tee build.log && check_build_log\n"
    },
    {
        "commit_hash": "791e72b7e23699e9496bb58cb932ff7e90babffa",
        "previous_commit_hash": "ca14692ddc6cfa5a5e6c708cd7238fc61bac75e5",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -318,7 +318,7 @@\n \n                 <plugin>\n                     <artifactId>maven-plugin-plugin</artifactId>\n-                    <version>3.6.0</version>\n+                    <version>3.4</version>\n                 </plugin>\n \n                 <plugin>\n"
    },
    {
        "commit_hash": "41d36b6241cd72553961deb437c5c32dea7ea8d8",
        "previous_commit_hash": "791e72b7e23699e9496bb58cb932ff7e90babffa",
        "diff_stats": {
            "additions": 0,
            "deletions": 13
        },
        "diff_content": "@@ -1,13 +0,0 @@\n-<component name=\"libraryTable\">\n-  <library name=\"Maven: org.apache.commons:commons-lang3:3.8.1\">\n-    <CLASSES>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/commons/commons-lang3/3.8.1/commons-lang3-3.8.1.jar!/\" />\n-    </CLASSES>\n-    <JAVADOC>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/commons/commons-lang3/3.8.1/commons-lang3-3.8.1-javadoc.jar!/\" />\n-    </JAVADOC>\n-    <SOURCES>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/apache/commons/commons-lang3/3.8.1/commons-lang3-3.8.1-sources.jar!/\" />\n-    </SOURCES>\n-  </library>\n-</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "41d36b6241cd72553961deb437c5c32dea7ea8d8",
        "previous_commit_hash": "791e72b7e23699e9496bb58cb932ff7e90babffa",
        "diff_stats": {
            "additions": 2,
            "deletions": 3
        },
        "diff_content": "@@ -59,9 +59,8 @@\n         </dependency>\n \n         <dependency>\n-            <groupId>org.apache.commons</groupId>\n-            <artifactId>commons-lang3</artifactId>\n-            <version>3.8.1</version>\n+            <groupId>commons-lang</groupId>\n+            <artifactId>commons-lang</artifactId>\n         </dependency>\n \n     </dependencies>\n"
    },
    {
        "commit_hash": "41d36b6241cd72553961deb437c5c32dea7ea8d8",
        "previous_commit_hash": "791e72b7e23699e9496bb58cb932ff7e90babffa",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -42,7 +42,7 @@\n     <orderEntry type=\"library\" name=\"Maven: org.sonatype.plexus:plexus-sec-dispatcher:1.3\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: org.sonatype.plexus:plexus-cipher:1.4\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: com.google.guava:guava:18.0\" level=\"project\" />\n-    <orderEntry type=\"library\" name=\"Maven: org.apache.commons:commons-lang3:3.8.1\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: commons-lang:commons-lang:2.6\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.12\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-library:1.3\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.hamcrest:hamcrest-core:1.3\" level=\"project\" />\n"
    },
    {
        "commit_hash": "41d36b6241cd72553961deb437c5c32dea7ea8d8",
        "previous_commit_hash": "791e72b7e23699e9496bb58cb932ff7e90babffa",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -8,7 +8,7 @@ import com.google.common.base.*;\n import com.google.common.collect.ImmutableMap;\n import com.google.common.io.Files;\n import net.orfjackal.retrolambda.api.RetrolambdaApi;\n-import org.apache.commons.lang3.*;\n+import org.apache.commons.lang.SystemUtils;\n import org.apache.maven.artifact.DependencyResolutionRequiredException;\n import org.apache.maven.execution.MavenSession;\n import org.apache.maven.plugin.*;\n@@ -143,7 +143,7 @@ abstract class ProcessClassesMojo extends AbstractMojo {\n     }\n \n     private void validateFork() {\n-        if (!fork && !SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_1_8)) {\n+        if (!fork && !SystemUtils.isJavaVersionAtLeast(1.8f)) {\n             getLog().warn(\"Maven is not running under Java 8 - forced to fork the process\");\n             fork = true;\n         }\n"
    },
    {
        "commit_hash": "c2bab2836a1e392fea08d5aa7a0e29ccf3604c5a",
        "previous_commit_hash": "41d36b6241cd72553961deb437c5c32dea7ea8d8",
        "diff_stats": {
            "additions": 2,
            "deletions": 0
        },
        "diff_content": "@@ -244,6 +244,8 @@ Version History\n ### Upcoming\n \n - Fix a `NullPointerException` crash in the Maven plugin on Java 10 & 11\n+- Fix Java agent to work on Java 9+\n+  ([Pull request #148](https://github.com/luontola/retrolambda/pull/148))\n \n ### Retrolambda 2.5.5 (2018-08-14)\n \n"
    },
    {
        "commit_hash": "bc37bcfc98b50905ed480ad1e87e1740fce38be6",
        "previous_commit_hash": "c2bab2836a1e392fea08d5aa7a0e29ccf3604c5a",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -55,7 +55,7 @@ To run Retrolambda using Maven, add the following to your pom.xml:\n <plugin>\n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>retrolambda-maven-plugin</artifactId>\n-    <version>2.5.5</version>\n+    <version>2.5.6</version>\n     <executions>\n         <execution>\n             <goals>\n@@ -241,7 +241,7 @@ yourself or pay someone to do it, if you think it's worth the effort. ;)\n Version History\n ---------------\n \n-### Upcoming\n+### Retrolambda 2.5.6 (2018-11-30)\n \n - Fix a `NullPointerException` crash in the Maven plugin on Java 10 & 11\n - Fix Java agent to work on Java 9+\n"
    },
    {
        "commit_hash": "bc37bcfc98b50905ed480ad1e87e1740fce38be6",
        "previous_commit_hash": "c2bab2836a1e392fea08d5aa7a0e29ccf3604c5a",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.6-SNAPSHOT</version>\n+        <version>2.5.6</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "bc37bcfc98b50905ed480ad1e87e1740fce38be6",
        "previous_commit_hash": "c2bab2836a1e392fea08d5aa7a0e29ccf3604c5a",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>2.5.6-SNAPSHOT</version>\n+    <version>2.5.6</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "bc37bcfc98b50905ed480ad1e87e1740fce38be6",
        "previous_commit_hash": "c2bab2836a1e392fea08d5aa7a0e29ccf3604c5a",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.6-SNAPSHOT</version>\n+        <version>2.5.6</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "bc37bcfc98b50905ed480ad1e87e1740fce38be6",
        "previous_commit_hash": "c2bab2836a1e392fea08d5aa7a0e29ccf3604c5a",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.6-SNAPSHOT</version>\n+        <version>2.5.6</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "bc37bcfc98b50905ed480ad1e87e1740fce38be6",
        "previous_commit_hash": "c2bab2836a1e392fea08d5aa7a0e29ccf3604c5a",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.6-SNAPSHOT</version>\n+        <version>2.5.6</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "bc37bcfc98b50905ed480ad1e87e1740fce38be6",
        "previous_commit_hash": "c2bab2836a1e392fea08d5aa7a0e29ccf3604c5a",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.6-SNAPSHOT</version>\n+        <version>2.5.6</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "3f1cdde128eb1b3a563bbdce9f97375fc0894d79",
        "previous_commit_hash": "bc37bcfc98b50905ed480ad1e87e1740fce38be6",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.6</version>\n+        <version>2.5.7-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "3f1cdde128eb1b3a563bbdce9f97375fc0894d79",
        "previous_commit_hash": "bc37bcfc98b50905ed480ad1e87e1740fce38be6",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>2.5.6</version>\n+    <version>2.5.7-SNAPSHOT</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "3f1cdde128eb1b3a563bbdce9f97375fc0894d79",
        "previous_commit_hash": "bc37bcfc98b50905ed480ad1e87e1740fce38be6",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.6</version>\n+        <version>2.5.7-SNAPSHOT</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "3f1cdde128eb1b3a563bbdce9f97375fc0894d79",
        "previous_commit_hash": "bc37bcfc98b50905ed480ad1e87e1740fce38be6",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.6</version>\n+        <version>2.5.7-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "3f1cdde128eb1b3a563bbdce9f97375fc0894d79",
        "previous_commit_hash": "bc37bcfc98b50905ed480ad1e87e1740fce38be6",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.6</version>\n+        <version>2.5.7-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "3f1cdde128eb1b3a563bbdce9f97375fc0894d79",
        "previous_commit_hash": "bc37bcfc98b50905ed480ad1e87e1740fce38be6",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.6</version>\n+        <version>2.5.7-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "084242558725981d4e9305ef06f408f42e73f4bc",
        "previous_commit_hash": "3f1cdde128eb1b3a563bbdce9f97375fc0894d79",
        "diff_stats": {
            "additions": 8,
            "deletions": 0
        },
        "diff_content": "@@ -29,6 +29,14 @@ ENV JAVA10_HOME=/usr/java/jdk-10.0.2\n RUN rpm -Uvh /installers/jdk-11.0.1_linux-x64_bin.rpm\n ENV JAVA11_HOME=/usr/java/jdk-11.0.1\n \n+# Install JDK 12\n+RUN rpm -Uvh /installers/jdk-12.0.2_linux-x64_bin.rpm\n+ENV JAVA12_HOME=/usr/java/jdk-12.0.2\n+\n+# Install JDK 13\n+RUN rpm -Uvh /installers/jdk-13.0.2_linux-x64_bin.rpm\n+ENV JAVA13_HOME=/usr/java/jdk-13.0.2\n+\n ENV JAVA_HOME=$JAVA8_HOME\n \n # Install Maven 3.2.5 (the last version to support Java 6)\n"
    },
    {
        "commit_hash": "084242558725981d4e9305ef06f408f42e73f4bc",
        "previous_commit_hash": "3f1cdde128eb1b3a563bbdce9f97375fc0894d79",
        "diff_stats": {
            "additions": 18,
            "deletions": 0
        },
        "diff_content": "@@ -83,6 +83,14 @@ JAVA_HOME=\"$JAVA11_HOME\" mvn clean verify \\\n     --errors \\\n     | tee build.log && check_build_log\n \n+JAVA_HOME=\"$JAVA12_HOME\" mvn clean verify \\\n+    --errors \\\n+    | tee build.log && check_build_log\n+\n+JAVA_HOME=\"$JAVA13_HOME\" mvn clean verify \\\n+    --errors \\\n+    | tee build.log && check_build_log\n+\n # Make sure that the Java agent works on all new Java versions\n \n JAVA_HOME=\"$JAVA9_HOME\" mvn clean verify \\\n@@ -99,3 +107,13 @@ JAVA_HOME=\"$JAVA11_HOME\" mvn clean verify \\\n     --errors \\\n     -P fork,noToolchain \\\n     | tee build.log && check_build_log\n+\n+JAVA_HOME=\"$JAVA12_HOME\" mvn clean verify \\\n+    --errors \\\n+    -P fork,noToolchain \\\n+    | tee build.log && check_build_log\n+\n+JAVA_HOME=\"$JAVA13_HOME\" mvn clean verify \\\n+    --errors \\\n+    -P fork,noToolchain \\\n+    | tee build.log && check_build_log\n"
    },
    {
        "commit_hash": "e62c38bf94405b696f60a0ee1a1ef46a2948d732",
        "previous_commit_hash": "084242558725981d4e9305ef06f408f42e73f4bc",
        "diff_stats": {
            "additions": 5,
            "deletions": 0
        },
        "diff_content": "@@ -241,6 +241,11 @@ yourself or pay someone to do it, if you think it's worth the effort. ;)\n Version History\n ---------------\n \n+### Upcoming\n+\n+- Improved error messages for Java 12 and newer, which have been confirmed\n+  to not work without the Java agent\n+\n ### Retrolambda 2.5.6 (2018-11-30)\n \n - Fix a `NullPointerException` crash in the Maven plugin on Java 10 & 11\n"
    },
    {
        "commit_hash": "e62c38bf94405b696f60a0ee1a1ef46a2948d732",
        "previous_commit_hash": "084242558725981d4e9305ef06f408f42e73f4bc",
        "diff_stats": {
            "additions": 11,
            "deletions": 5
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013-2014 Esko Luontola <www.orfjackal.net>\n+// Copyright \u00a9 2013-2020 Esko Luontola and other Retrolambda contributors\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -56,10 +56,16 @@ public class LambdaClassDumper implements AutoCloseable {\n     }\n \n     private static void makeNonFinal(Field field) throws Exception {\n-        Field modifiers = field.getClass().getDeclaredField(\"modifiers\");\n-        modifiers.setAccessible(true);\n-        int mod = modifiers.getInt(field);\n-        modifiers.setInt(field, mod & ~Modifier.FINAL);\n+        try {\n+            Field modifiers = field.getClass().getDeclaredField(\"modifiers\");\n+            modifiers.setAccessible(true);\n+            int mod = modifiers.getInt(field);\n+            modifiers.setInt(field, mod & ~Modifier.FINAL);\n+        } catch (NoSuchFieldException e) {\n+            throw new RuntimeException(\"Failed to make a field non-final (\" + field + \"). \" +\n+                    \"This known to fail on Java 12 and newer. Prefer using Java 8 or try using the Java agent \" +\n+                    \"(fork=true in the Maven plugin).\", e);\n+        }\n     }\n \n     private static Object newProxyClassesDumper(Path dumpDir) throws Exception {\n"
    },
    {
        "commit_hash": "e62c38bf94405b696f60a0ee1a1ef46a2948d732",
        "previous_commit_hash": "084242558725981d4e9305ef06f408f42e73f4bc",
        "diff_stats": {
            "additions": 1,
            "deletions": 7
        },
        "diff_content": "@@ -83,13 +83,7 @@ JAVA_HOME=\"$JAVA11_HOME\" mvn clean verify \\\n     --errors \\\n     | tee build.log && check_build_log\n \n-JAVA_HOME=\"$JAVA12_HOME\" mvn clean verify \\\n-    --errors \\\n-    | tee build.log && check_build_log\n-\n-JAVA_HOME=\"$JAVA13_HOME\" mvn clean verify \\\n-    --errors \\\n-    | tee build.log && check_build_log\n+# (Java 12+ fails without forking because java.lang.invoke.InnerClassLambdaMetafactory#dumper cannot be made non-final)\n \n # Make sure that the Java agent works on all new Java versions\n \n"
    },
    {
        "commit_hash": "368ffa01d4068c97cea283ed1ef053af4902d55c",
        "previous_commit_hash": "e62c38bf94405b696f60a0ee1a1ef46a2948d732",
        "diff_stats": {
            "additions": 5,
            "deletions": 1
        },
        "diff_content": "@@ -1,12 +1,16 @@\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <project version=\"4\">\n-  <component name=\"Encoding\" useUTFGuessing=\"true\" native2AsciiForPropertiesFiles=\"true\" defaultCharsetForPropertiesFiles=\"UTF-8\">\n+  <component name=\"Encoding\" native2AsciiForPropertiesFiles=\"true\" defaultCharsetForPropertiesFiles=\"UTF-8\">\n     <file url=\"file://$PROJECT_DIR$\" charset=\"UTF-8\" />\n     <file url=\"file://$PROJECT_DIR$/end-to-end-tests\" charset=\"UTF-8\" />\n+    <file url=\"file://$PROJECT_DIR$/end-to-end-tests/src/main/java\" charset=\"UTF-8\" />\n     <file url=\"file://$PROJECT_DIR$/parent\" charset=\"UTF-8\" />\n     <file url=\"file://$PROJECT_DIR$/retrolambda\" charset=\"UTF-8\" />\n     <file url=\"file://$PROJECT_DIR$/retrolambda-api\" charset=\"UTF-8\" />\n+    <file url=\"file://$PROJECT_DIR$/retrolambda-api/src/main/java\" charset=\"UTF-8\" />\n     <file url=\"file://$PROJECT_DIR$/retrolambda-maven-plugin\" charset=\"UTF-8\" />\n+    <file url=\"file://$PROJECT_DIR$/retrolambda-maven-plugin/src/main/java\" charset=\"UTF-8\" />\n+    <file url=\"file://$PROJECT_DIR$/retrolambda/src/main/java\" charset=\"UTF-8\" />\n     <file url=\"PROJECT\" charset=\"UTF-8\" />\n   </component>\n </project>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "368ffa01d4068c97cea283ed1ef053af4902d55c",
        "previous_commit_hash": "e62c38bf94405b696f60a0ee1a1ef46a2948d732",
        "diff_stats": {
            "additions": 0,
            "deletions": 13
        },
        "diff_content": "@@ -1,13 +0,0 @@\n-<component name=\"libraryTable\">\n-  <library name=\"Maven: org.ow2.asm:asm:7.0\">\n-    <CLASSES>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm/7.0/asm-7.0.jar!/\" />\n-    </CLASSES>\n-    <JAVADOC>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm/7.0/asm-7.0-javadoc.jar!/\" />\n-    </JAVADOC>\n-    <SOURCES>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm/7.0/asm-7.0-sources.jar!/\" />\n-    </SOURCES>\n-  </library>\n-</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "368ffa01d4068c97cea283ed1ef053af4902d55c",
        "previous_commit_hash": "e62c38bf94405b696f60a0ee1a1ef46a2948d732",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,13 @@\n+<component name=\"libraryTable\">\n+  <library name=\"Maven: org.ow2.asm:asm:7.3.1\">\n+    <CLASSES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm/7.3.1/asm-7.3.1.jar!/\" />\n+    </CLASSES>\n+    <JAVADOC>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm/7.3.1/asm-7.3.1-javadoc.jar!/\" />\n+    </JAVADOC>\n+    <SOURCES>\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm/7.3.1/asm-7.3.1-sources.jar!/\" />\n+    </SOURCES>\n+  </library>\n+</component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "368ffa01d4068c97cea283ed1ef053af4902d55c",
        "previous_commit_hash": "e62c38bf94405b696f60a0ee1a1ef46a2948d732",
        "diff_stats": {
            "additions": 4,
            "deletions": 4
        },
        "diff_content": "@@ -1,13 +1,13 @@\n <component name=\"libraryTable\">\n-  <library name=\"Maven: org.ow2.asm:asm-tree:7.0\">\n+  <library name=\"Maven: org.ow2.asm:asm-tree:7.3.1\">\n     <CLASSES>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm-tree/7.0/asm-tree-7.0.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm-tree/7.3.1/asm-tree-7.3.1.jar!/\" />\n     </CLASSES>\n     <JAVADOC>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm-tree/7.0/asm-tree-7.0-javadoc.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm-tree/7.3.1/asm-tree-7.3.1-javadoc.jar!/\" />\n     </JAVADOC>\n     <SOURCES>\n-      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm-tree/7.0/asm-tree-7.0-sources.jar!/\" />\n+      <root url=\"jar://$MAVEN_REPOSITORY$/org/ow2/asm/asm-tree/7.3.1/asm-tree-7.3.1-sources.jar!/\" />\n     </SOURCES>\n   </library>\n </component>\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "368ffa01d4068c97cea283ed1ef053af4902d55c",
        "previous_commit_hash": "e62c38bf94405b696f60a0ee1a1ef46a2948d732",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -38,7 +38,7 @@\n     <option name=\"LAST_EDITED_MODULE_NAME\" />\n     <option name=\"LAST_EDITED_TAB_NAME\" />\n   </component>\n-  <component name=\"ProjectRootManager\" version=\"2\" languageLevel=\"JDK_1_8\" default=\"false\" assert-keyword=\"true\" jdk-15=\"true\" project-jdk-name=\"1.8\" project-jdk-type=\"JavaSDK\">\n+  <component name=\"ProjectRootManager\" version=\"2\" languageLevel=\"JDK_1_8\" default=\"false\" project-jdk-name=\"1.8\" project-jdk-type=\"JavaSDK\">\n     <output url=\"file://$PROJECT_DIR$/classes\" />\n   </component>\n   <component name=\"VssConfiguration\">\n"
    },
    {
        "commit_hash": "368ffa01d4068c97cea283ed1ef053af4902d55c",
        "previous_commit_hash": "e62c38bf94405b696f60a0ee1a1ef46a2948d732",
        "diff_stats": {
            "additions": 3,
            "deletions": 0
        },
        "diff_content": "@@ -245,6 +245,9 @@ Version History\n \n - Improved error messages for Java 12 and newer, which have been confirmed\n   to not work without the Java agent\n+  ([Issue #154](https://github.com/luontola/retrolambda/issues/154))\n+- Upgraded the ASM library to improve compatibility with Java 13\n+  ([Issue #154](https://github.com/luontola/retrolambda/issues/154))\n \n ### Retrolambda 2.5.6 (2018-11-30)\n \n"
    },
    {
        "commit_hash": "368ffa01d4068c97cea283ed1ef053af4902d55c",
        "previous_commit_hash": "e62c38bf94405b696f60a0ee1a1ef46a2948d732",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -14,8 +14,8 @@\n     <orderEntry type=\"library\" name=\"Maven: com.google.guava:guava:11.0.2\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: com.google.code.findbugs:jsr305:1.3.9\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: commons-lang:commons-lang:2.6\" level=\"project\" />\n-    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.ow2.asm:asm:7.0\" level=\"project\" />\n-    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.ow2.asm:asm-tree:7.0\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.ow2.asm:asm:7.3.1\" level=\"project\" />\n+    <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.ow2.asm:asm-tree:7.3.1\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: org.apache.bcel:bcel:5.2\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: jakarta-regexp:jakarta-regexp:1.4\" level=\"project\" />\n     <orderEntry type=\"module-library\">\n"
    },
    {
        "commit_hash": "368ffa01d4068c97cea283ed1ef053af4902d55c",
        "previous_commit_hash": "e62c38bf94405b696f60a0ee1a1ef46a2948d732",
        "diff_stats": {
            "additions": 5,
            "deletions": 2
        },
        "diff_content": "@@ -1,4 +1,4 @@\n-// Copyright \u00a9 2013-2017 Esko Luontola and other Retrolambda contributors\n+// Copyright \u00a9 2013-2020 Esko Luontola and other Retrolambda contributors\n // This software is released under the Apache License 2.0.\n // The license text is at http://www.apache.org/licenses/LICENSE-2.0\n \n@@ -255,8 +255,11 @@ public class LambdaTest extends SuperClass {\n         };\n         Class<?> anonymousClass = lambda.call().getClass();\n \n+        // Before Java 13 the enclosing method is a bridge method\n+        // whose name starts with \"lambda$enclosing_method_of_anonymous_class_inside_lambda_expression$\".\n+        // Since Java 13 it's enclosed by the original method.\n         assertThat(anonymousClass.getEnclosingMethod().getName(),\n-                startsWith(\"lambda$enclosing_method_of_anonymous_class_inside_lambda_expression$\"));\n+                containsString(\"enclosing_method_of_anonymous_class_inside_lambda_expression\"));\n     }\n \n     /**\n"
    },
    {
        "commit_hash": "368ffa01d4068c97cea283ed1ef053af4902d55c",
        "previous_commit_hash": "e62c38bf94405b696f60a0ee1a1ef46a2948d732",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -86,13 +86,13 @@\n             <dependency>\n                 <groupId>org.ow2.asm</groupId>\n                 <artifactId>asm</artifactId>\n-                <version>7.0</version>\n+                <version>7.3.1</version>\n             </dependency>\n \n             <dependency>\n                 <groupId>org.ow2.asm</groupId>\n                 <artifactId>asm-tree</artifactId>\n-                <version>7.0</version>\n+                <version>7.3.1</version>\n             </dependency>\n \n             <dependency>\n"
    },
    {
        "commit_hash": "368ffa01d4068c97cea283ed1ef053af4902d55c",
        "previous_commit_hash": "e62c38bf94405b696f60a0ee1a1ef46a2948d732",
        "diff_stats": {
            "additions": 2,
            "deletions": 0
        },
        "diff_content": "@@ -4,6 +4,8 @@\n     <output url=\"file://$MODULE_DIR$/target/classes\" />\n     <output-test url=\"file://$MODULE_DIR$/target/test-classes\" />\n     <content url=\"file://$MODULE_DIR$\">\n+      <excludeFolder url=\"file://$MODULE_DIR$/parent/target/classes\" />\n+      <excludeFolder url=\"file://$MODULE_DIR$/parent/target/test-classes\" />\n       <excludeFolder url=\"file://$MODULE_DIR$/target\" />\n     </content>\n     <orderEntry type=\"inheritedJdk\" />\n"
    },
    {
        "commit_hash": "368ffa01d4068c97cea283ed1ef053af4902d55c",
        "previous_commit_hash": "e62c38bf94405b696f60a0ee1a1ef46a2948d732",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -13,8 +13,8 @@\n     <orderEntry type=\"inheritedJdk\" />\n     <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n     <orderEntry type=\"module\" module-name=\"retrolambda\" />\n-    <orderEntry type=\"library\" name=\"Maven: org.ow2.asm:asm:7.0\" level=\"project\" />\n-    <orderEntry type=\"library\" name=\"Maven: org.ow2.asm:asm-tree:7.0\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.ow2.asm:asm:7.3.1\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.ow2.asm:asm-tree:7.3.1\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: com.esotericsoftware:minlog:1.3\" level=\"project\" />\n     <orderEntry type=\"module\" module-name=\"retrolambda-api\" />\n     <orderEntry type=\"library\" name=\"Maven: org.apache.maven:maven-plugin-api:3.0\" level=\"project\" />\n"
    },
    {
        "commit_hash": "368ffa01d4068c97cea283ed1ef053af4902d55c",
        "previous_commit_hash": "e62c38bf94405b696f60a0ee1a1ef46a2948d732",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -11,8 +11,8 @@\n     <orderEntry type=\"inheritedJdk\" />\n     <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n     <orderEntry type=\"module\" module-name=\"retrolambda-api\" />\n-    <orderEntry type=\"library\" name=\"Maven: org.ow2.asm:asm:7.0\" level=\"project\" />\n-    <orderEntry type=\"library\" name=\"Maven: org.ow2.asm:asm-tree:7.0\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.ow2.asm:asm:7.3.1\" level=\"project\" />\n+    <orderEntry type=\"library\" name=\"Maven: org.ow2.asm:asm-tree:7.3.1\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: com.google.guava:guava:18.0\" level=\"project\" />\n     <orderEntry type=\"library\" name=\"Maven: com.esotericsoftware:minlog:1.3\" level=\"project\" />\n     <orderEntry type=\"library\" scope=\"TEST\" name=\"Maven: junit:junit:4.12\" level=\"project\" />\n"
    },
    {
        "commit_hash": "41ddb5bb368a866acdec2a70c617dfaf17a0648a",
        "previous_commit_hash": "368ffa01d4068c97cea283ed1ef053af4902d55c",
        "diff_stats": {
            "additions": 6,
            "deletions": 6
        },
        "diff_content": "@@ -1,7 +1,7 @@\n #!/bin/bash\n set -eu\n : ${1:? Usage: $0 RELEASE_VERSION}\n-SCRIPTS=`dirname \"$0\"`\n+SCRIPTS=$(dirname \"$0\")\n \n RELEASE_VERSION=\"$1\"\n if [[ ! \"$RELEASE_VERSION\" =~ ^[0-9]+\\.[0-9]+\\.[0-9]+$ ]]; then\n@@ -38,21 +38,21 @@ function set-project-version() {\n function set-documentation-version() {\n     local file=\"README.md\"\n     local version=\"$1\"\n-    sed -i -r -e \"s/^(\\\\s*<version>).+(<\\\\/version>)\\$/\\1$version\\2/\" \"$file\"\n+    gsed -i -r -e \"s/^(\\\\s*<version>).+(<\\\\/version>)\\$/\\1$version\\2/\" \"$file\"\n     assert-file-contains-substring \"$file\" \"<version>$version</version>\"\n }\n \n function next-snapshot-version() {\n-    local prefix=`echo $1 | sed -n -r 's/([0-9]+\\.[0-9]+\\.)[0-9]+/\\1/p'`\n-    local suffix=`echo $1 | sed -n -r 's/[0-9]+\\.[0-9]+\\.([0-9]+)/\\1/p'`\n+    local prefix=$(echo $1 | gsed -n -r 's/([0-9]+\\.[0-9]+\\.)[0-9]+/\\1/p')\n+    local suffix=$(echo $1 | gsed -n -r 's/[0-9]+\\.[0-9]+\\.([0-9]+)/\\1/p')\n     ((suffix++))\n     echo \"$prefix$suffix-SNAPSHOT\"\n }\n \n APP_NAME=\"Retrolambda\"\n-NEXT_VERSION=`next-snapshot-version $RELEASE_VERSION`\n+NEXT_VERSION=$(next-snapshot-version $RELEASE_VERSION)\n \n-demand-file-contains-line README.md \"### $APP_NAME $RELEASE_VERSION (`date +%Y-%m-%d`)\"\n+demand-file-contains-line README.md \"### $APP_NAME $RELEASE_VERSION ($(date +%Y-%m-%d))\"\n \n set -x\n \n"
    },
    {
        "commit_hash": "6da88d989efeb9f7413203dc3bc74ed614301307",
        "previous_commit_hash": "41ddb5bb368a866acdec2a70c617dfaf17a0648a",
        "diff_stats": {
            "additions": 16,
            "deletions": 10
        },
        "diff_content": "@@ -10,24 +10,28 @@ if [[ ! \"$RELEASE_VERSION\" =~ ^[0-9]+\\.[0-9]+\\.[0-9]+$ ]]; then\n fi\n \n function contains-line() {\n+    set -eu\n     grep --line-regexp --quiet --fixed-strings -e \"$1\"\n }\n \n function demand-file-contains-line() {\n-    local file=\"$1\"\n-    local expected=\"$2\"\n+    set -eu\n+    file=\"$1\"\n+    expected=\"$2\"\n     cat \"$file\" | contains-line \"$expected\" || (echo \"Add this line to $file and try again:\"; echo \"$expected\"; exit 1)\n }\n \n function assert-file-contains-substring() {\n-    local file=\"$1\"\n-    local expected=\"$2\"\n+    set -eu\n+    file=\"$1\"\n+    expected=\"$2\"\n     cat \"$file\" | grep --quiet --fixed-strings -e \"$expected\" || (echo \"Error: file $file did not contain $expected\"; exit 1)\n }\n \n function set-project-version() {\n-    local file=\"parent/pom.xml\"\n-    local version=\"$1\"\n+    set -eu\n+    file=\"parent/pom.xml\"\n+    version=\"$1\"\n     mvn versions:set \\\n         -DgenerateBackupPoms=false \\\n         -DnewVersion=\"$version\" \\\n@@ -36,15 +40,17 @@ function set-project-version() {\n }\n \n function set-documentation-version() {\n-    local file=\"README.md\"\n-    local version=\"$1\"\n+    set -eu\n+    file=\"README.md\"\n+    version=\"$1\"\n     gsed -i -r -e \"s/^(\\\\s*<version>).+(<\\\\/version>)\\$/\\1$version\\2/\" \"$file\"\n     assert-file-contains-substring \"$file\" \"<version>$version</version>\"\n }\n \n function next-snapshot-version() {\n-    local prefix=$(echo $1 | gsed -n -r 's/([0-9]+\\.[0-9]+\\.)[0-9]+/\\1/p')\n-    local suffix=$(echo $1 | gsed -n -r 's/[0-9]+\\.[0-9]+\\.([0-9]+)/\\1/p')\n+    set -eu\n+    prefix=$(echo $1 | gsed -n -r 's/([0-9]+\\.[0-9]+\\.)[0-9]+/\\1/p')\n+    suffix=$(echo $1 | gsed -n -r 's/[0-9]+\\.[0-9]+\\.([0-9]+)/\\1/p')\n     ((suffix++))\n     echo \"$prefix$suffix-SNAPSHOT\"\n }\n"
    },
    {
        "commit_hash": "a09f48b9536a350495310c8d73822181b05b57c0",
        "previous_commit_hash": "6da88d989efeb9f7413203dc3bc74ed614301307",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -55,7 +55,7 @@ To run Retrolambda using Maven, add the following to your pom.xml:\n <plugin>\n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>retrolambda-maven-plugin</artifactId>\n-    <version>2.5.6</version>\n+    <version>2.5.7</version>\n     <executions>\n         <execution>\n             <goals>\n@@ -241,7 +241,7 @@ yourself or pay someone to do it, if you think it's worth the effort. ;)\n Version History\n ---------------\n \n-### Upcoming\n+### Retrolambda 2.5.7 (2020-01-23)\n \n - Improved error messages for Java 12 and newer, which have been confirmed\n   to not work without the Java agent\n"
    },
    {
        "commit_hash": "a09f48b9536a350495310c8d73822181b05b57c0",
        "previous_commit_hash": "6da88d989efeb9f7413203dc3bc74ed614301307",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.7-SNAPSHOT</version>\n+        <version>2.5.7</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "a09f48b9536a350495310c8d73822181b05b57c0",
        "previous_commit_hash": "6da88d989efeb9f7413203dc3bc74ed614301307",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>2.5.7-SNAPSHOT</version>\n+    <version>2.5.7</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "a09f48b9536a350495310c8d73822181b05b57c0",
        "previous_commit_hash": "6da88d989efeb9f7413203dc3bc74ed614301307",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.7-SNAPSHOT</version>\n+        <version>2.5.7</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "a09f48b9536a350495310c8d73822181b05b57c0",
        "previous_commit_hash": "6da88d989efeb9f7413203dc3bc74ed614301307",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.7-SNAPSHOT</version>\n+        <version>2.5.7</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "a09f48b9536a350495310c8d73822181b05b57c0",
        "previous_commit_hash": "6da88d989efeb9f7413203dc3bc74ed614301307",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.7-SNAPSHOT</version>\n+        <version>2.5.7</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "a09f48b9536a350495310c8d73822181b05b57c0",
        "previous_commit_hash": "6da88d989efeb9f7413203dc3bc74ed614301307",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.7-SNAPSHOT</version>\n+        <version>2.5.7</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "bc58c431e1f92c0fd25234b8e9436c2582698974",
        "previous_commit_hash": "a09f48b9536a350495310c8d73822181b05b57c0",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.7</version>\n+        <version>2.5.8-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "bc58c431e1f92c0fd25234b8e9436c2582698974",
        "previous_commit_hash": "a09f48b9536a350495310c8d73822181b05b57c0",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@\n \n     <groupId>net.orfjackal.retrolambda</groupId>\n     <artifactId>parent</artifactId>\n-    <version>2.5.7</version>\n+    <version>2.5.8-SNAPSHOT</version>\n     <packaging>pom</packaging>\n \n     <description>Backport of Java 8 lambda expressions to Java 7</description>\n"
    },
    {
        "commit_hash": "bc58c431e1f92c0fd25234b8e9436c2582698974",
        "previous_commit_hash": "a09f48b9536a350495310c8d73822181b05b57c0",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.7</version>\n+        <version>2.5.8-SNAPSHOT</version>\n         <relativePath>parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "bc58c431e1f92c0fd25234b8e9436c2582698974",
        "previous_commit_hash": "a09f48b9536a350495310c8d73822181b05b57c0",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.7</version>\n+        <version>2.5.8-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "bc58c431e1f92c0fd25234b8e9436c2582698974",
        "previous_commit_hash": "a09f48b9536a350495310c8d73822181b05b57c0",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.7</version>\n+        <version>2.5.8-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "bc58c431e1f92c0fd25234b8e9436c2582698974",
        "previous_commit_hash": "a09f48b9536a350495310c8d73822181b05b57c0",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n     <parent>\n         <groupId>net.orfjackal.retrolambda</groupId>\n         <artifactId>parent</artifactId>\n-        <version>2.5.7</version>\n+        <version>2.5.8-SNAPSHOT</version>\n         <relativePath>../parent/pom.xml</relativePath>\n     </parent>\n \n"
    },
    {
        "commit_hash": "fbd82c9a023b363a2cb38afd8dad3fd8fc134ada",
        "previous_commit_hash": "bc58c431e1f92c0fd25234b8e9436c2582698974",
        "diff_stats": {
            "additions": 4,
            "deletions": 3
        },
        "diff_content": "@@ -22,9 +22,10 @@ for adventurous developers there are [other backporting\n tools](http://en.wikipedia.org/wiki/Java_backporting_tools) that may let\n you go from Java 5 down to Java 1.4.\n \n-Android developers may use Retrolambda to take advantage of the Java 8\n-features on Android. Serge Zaitsev has written [an article about\n-it](http://zserge.com/blog/android-lambda.html) and there is a [Gradle\n+Nowadays Android Studio has [built-in support for Java 8 features](https://developer.android.com/studio/write/java8-support),\n+so that is probably the first thing to try out. Otherwise, Retrolambda\n+works also for Android: Serge Zaitsev has written [an article about\n+it](https://zserge.com/posts/android-lambda/) and there is a [Gradle\n plugin](#gradle-plugin) which makes it easy.\n \n Retrolambda does not backport the new Java 8 APIs, but there are other\n"
    }
]