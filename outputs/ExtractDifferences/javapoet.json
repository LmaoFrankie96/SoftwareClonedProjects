[
    {
        "commit_hash": "34550b1cfcc39856d3f58f22ddaa830c48cffa6d",
        "previous_commit_hash": "68abe864e2ab689c64f09b0d3bde6058c81abfd4",
        "diff_stats": {
            "additions": 521,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,521 @@\n+/**\n+ * Copyright (C) 2012 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.protoss.schema;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.Writer;\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Emits Java source files.\n+ *\n+ * <p><strong>Warning:</strong> Shamefully stolen from\n+ * <a href=\"https://raw.github.com/square/dagger/\">Dagger</a>.\n+ *\n+ * @author Jesse Wilson\n+ */\n+public final class JavaWriter implements Closeable {\n+  private static final Pattern TYPE_PATTERN = Pattern.compile(\"(?:[\\\\w$]+\\\\.)*([\\\\w$]+)\");\n+  private static final String INDENT = \"  \";\n+\n+  /** Map fully qualified type names to their short names. */\n+  private final Map<String, String> importedTypes = new HashMap<String, String>();\n+\n+  private String packagePrefix;\n+  private final List<Scope> scopes = new ArrayList<Scope>();\n+  private final Writer out;\n+\n+  /**\n+   * @param out the stream to which Java source will be written. This should be\n+   *     a buffered stream.\n+   */\n+  public JavaWriter(Writer out) {\n+    this.out = out;\n+  }\n+\n+  /**\n+   * Emit a package declaration.\n+   */\n+  public void addPackage(String packageName) throws IOException {\n+    if (this.packagePrefix != null) {\n+      throw new IllegalStateException();\n+    }\n+    if (packageName.isEmpty()) {\n+      this.packagePrefix = \"\";\n+    } else {\n+      out.write(\"package \");\n+      out.write(packageName);\n+      out.write(\";\\n\");\n+      this.packagePrefix = packageName + \".\";\n+    }\n+  }\n+\n+  /**\n+   * Equivalent to {@code addImport(type.getName())}.\n+   */\n+  public void addImport(Class<?> type) throws IOException {\n+    addImport(type.getName());\n+  }\n+\n+  /**\n+   * Emit an import for {@code type}. For the duration of the file, all\n+   * references to this class will be automatically shortened.\n+   */\n+  public void addImport(String type) throws IOException {\n+    Matcher matcher = TYPE_PATTERN.matcher(type);\n+    if (!matcher.matches()) {\n+      throw new IllegalArgumentException(type);\n+    }\n+    if (importedTypes.put(type, matcher.group(1)) != null) {\n+      throw new IllegalArgumentException(type);\n+    }\n+    out.write(\"import \");\n+    out.write(type);\n+    out.write(\";\\n\");\n+  }\n+\n+  /**\n+   * Emits a name like {@code java.lang.String} or {@code\n+   * java.util.List<java.lang.String>}, shorting it with imports if\n+   * possible.\n+   */\n+  private void type(String type) throws IOException {\n+    if (this.packagePrefix == null) {\n+      throw new IllegalStateException();\n+    }\n+\n+    Matcher m = TYPE_PATTERN.matcher(type);\n+    int pos = 0;\n+    while (true) {\n+      boolean found = m.find(pos);\n+\n+      // copy non-matching characters like \"<\"\n+      int typeStart = found ? m.start() : type.length();\n+      out.write(type, pos, typeStart - pos);\n+\n+      if (!found) {\n+        break;\n+      }\n+\n+      // copy a single class name, shortening it if possible\n+      String name = m.group(0);\n+      String imported;\n+      if ((imported = importedTypes.get(name)) != null) {\n+        out.write(imported);\n+      } else if (name.startsWith(packagePrefix)\n+          && name.indexOf('.', packagePrefix.length()) == -1) {\n+        out.write(name.substring(packagePrefix.length()));\n+      } else if (name.startsWith(\"java.lang.\")) {\n+        out.write(name.substring(\"java.lang.\".length()));\n+      } else {\n+        out.write(name);\n+      }\n+      pos = m.end();\n+    }\n+  }\n+\n+  /**\n+   * Emits a type declaration.\n+   *\n+   * @param kind such as \"class\", \"interface\" or \"enum\".\n+   */\n+  public void beginType(String type, String kind, int modifiers) throws IOException {\n+    beginType(type, kind, modifiers, null);\n+  }\n+\n+  /**\n+   * Emits a type declaration.\n+   *\n+   * @param kind such as \"class\", \"interface\" or \"enum\".\n+   * @param extendsType the class to extend, or null for no extends clause.\n+   */\n+  public void beginType(String type, String kind, int modifiers,\n+      String extendsType, String... implementsTypes) throws IOException {\n+    indent();\n+    modifiers(modifiers);\n+    out.write(kind);\n+    out.write(\" \");\n+    type(type);\n+    if (extendsType != null) {\n+      out.write(\"\\n\");\n+      indent();\n+      out.write(\"    extends \");\n+      type(extendsType);\n+    }\n+    if (implementsTypes.length > 0) {\n+      out.write(\"\\n\");\n+      indent();\n+      out.write(\"    implements \");\n+      for (int i = 0; i < implementsTypes.length; i++) {\n+        if (i != 0) {\n+          out.write(\", \");\n+        }\n+        type(implementsTypes[i]);\n+      }\n+    }\n+    out.write(\" {\\n\");\n+    pushScope(Scope.TYPE_DECLARATION);\n+  }\n+\n+  /**\n+   * Completes the current type declaration.\n+   */\n+  public void endType() throws IOException {\n+    popScope(Scope.TYPE_DECLARATION);\n+    indent();\n+    out.write(\"}\\n\");\n+  }\n+\n+  /**\n+   * Emits a field declaration.\n+   */\n+  public void field(String type, String name, int modifiers) throws IOException {\n+    field(type, name, modifiers, null);\n+  }\n+\n+  public void field(String type, String name, int modifiers, String initialValue)\n+      throws IOException {\n+    indent();\n+    modifiers(modifiers);\n+    type(type);\n+    out.write(\" \");\n+    out.write(name);\n+\n+    if (initialValue != null) {\n+      out.write(\" = \");\n+      out.write(initialValue);\n+    }\n+    out.write(\";\\n\");\n+  }\n+\n+  /**\n+   * Emit a method declaration.\n+   *\n+   * @param returnType the method's return type, or null for constructors.\n+   * @param parameters alternating parameter types and names.\n+   * @param name the method name, or the fully qualified class name for\n+   *     constructors.\n+   */\n+  public void beginMethod(String returnType, String name, int modifiers, String... parameters)\n+      throws IOException {\n+    indent();\n+    modifiers(modifiers);\n+    if (returnType != null) {\n+      type(returnType);\n+      out.write(\" \");\n+      out.write(name);\n+    } else {\n+      type(name);\n+    }\n+    out.write(\"(\");\n+    for (int p = 0; p < parameters.length;) {\n+      if (p != 0) {\n+        out.write(\", \");\n+      }\n+      type(parameters[p++]);\n+      out.write(\" \");\n+      type(parameters[p++]);\n+    }\n+    out.write(\")\");\n+    if ((modifiers & Modifier.ABSTRACT) != 0) {\n+      out.write(\";\\n\");\n+      pushScope(Scope.ABSTRACT_METHOD);\n+    } else {\n+      out.write(\" {\\n\");\n+      pushScope(Scope.NON_ABSTRACT_METHOD);\n+    }\n+  }\n+\n+  /**\n+   * Equivalent to {@code annotation(annotation, emptyMap())}.\n+   */\n+  public void annotation(String annotation) throws IOException {\n+    annotation(annotation, Collections.<String, Object>emptyMap());\n+  }\n+\n+  /**\n+   * Equivalent to {@code annotation(annotationType.getName(), emptyMap())}.\n+   */\n+  public void annotation(Class<? extends Annotation> annotationType) throws IOException {\n+    annotation(annotationType.getName(), Collections.<String, Object>emptyMap());\n+  }\n+\n+  /**\n+   * Equivalent to {@code annotation(annotationType.getName(), attributes)}.\n+   */\n+  public void annotation(Class<? extends Annotation> annotationType, Map<String, ?> attributes)\n+      throws IOException {\n+    annotation(annotationType.getName(), attributes);\n+  }\n+\n+  /**\n+   * Annotates the next element with {@code annotation} and {@code attributes}.\n+   *\n+   * @param attributes a map from annotation attribute names to their values.\n+   *     Values are encoded using Object.toString(); use {@link #stringLiteral}\n+   *     for String values. Object arrays are written one element per line.\n+   */\n+  public void annotation(String annotation, Map<String, ?> attributes) throws IOException {\n+    indent();\n+    out.write(\"@\");\n+    type(annotation);\n+    if (!attributes.isEmpty()) {\n+      out.write(\"(\");\n+      pushScope(Scope.ANNOTATION_ATTRIBUTE);\n+      boolean firstAttribute = true;\n+      for (Map.Entry<String, ?> entry : attributes.entrySet()) {\n+        if (firstAttribute) {\n+          firstAttribute = false;\n+          out.write(\"\\n\");\n+        } else {\n+          out.write(\",\\n\");\n+        }\n+        indent();\n+        out.write(entry.getKey());\n+        out.write(\" = \");\n+        Object value = entry.getValue();\n+        annotationValue(value);\n+      }\n+      popScope(Scope.ANNOTATION_ATTRIBUTE);\n+      out.write(\"\\n\");\n+      indent();\n+      out.write(\")\");\n+    }\n+    out.write(\"\\n\");\n+  }\n+\n+  /**\n+   * Writes a single annotation value. If the value is an array, each element in\n+   * the array will be written to its own line.\n+   */\n+  private void annotationValue(Object value) throws IOException {\n+    if (value instanceof Object[]) {\n+      out.write(\"{\");\n+      boolean firstValue = true;\n+      pushScope(Scope.ANNOTATION_ARRAY_VALUE);\n+      for (Object o : ((Object[]) value)) {\n+        if (firstValue) {\n+          firstValue = false;\n+          out.write(\"\\n\");\n+        } else {\n+          out.write(\",\\n\");\n+        }\n+        indent();\n+        out.write(o.toString());\n+      }\n+      popScope(Scope.ANNOTATION_ARRAY_VALUE);\n+      out.write(\"\\n\");\n+      indent();\n+      out.write(\"}\");\n+    } else {\n+      out.write(value.toString());\n+    }\n+  }\n+\n+  /**\n+   * @param pattern a code pattern like \"int i = %s\". Shouldn't contain a\n+   * trailing semicolon or newline character.\n+   */\n+  public void statement(String pattern, Object... args) throws IOException {\n+    checkInMethod();\n+    indent();\n+    out.write(String.format(pattern, args));\n+    out.write(\";\\n\");\n+  }\n+\n+  /**\n+   * @param controlFlow the control flow construct and its code, such as\n+   *     \"if (foo == 5)\". Shouldn't contain braces or newline characters.\n+   */\n+  public void beginControlFlow(String controlFlow) throws IOException {\n+    checkInMethod();\n+    indent();\n+    out.write(controlFlow);\n+    out.write(\" {\\n\");\n+    pushScope(Scope.CONTROL_FLOW);\n+  }\n+\n+  /**\n+   * @param controlFlow the control flow construct and its code, such as\n+   *     \"else if (foo == 10)\". Shouldn't contain braces or newline characters.\n+   */\n+  public void nextControlFlow(String controlFlow) throws IOException {\n+    popScope(Scope.CONTROL_FLOW);\n+    indent();\n+    pushScope(Scope.CONTROL_FLOW);\n+    out.write(\"} \");\n+    out.write(controlFlow);\n+    out.write(\" {\\n\");\n+  }\n+\n+  public void endControlFlow() throws IOException {\n+    endControlFlow(null);\n+  }\n+\n+  /**\n+   * @param controlFlow the optional control flow construct and its code, such\n+   *     as \"while(foo == 20)\". Only used for \"do/while\" control flows.\n+   */\n+  public void endControlFlow(String controlFlow) throws IOException {\n+    popScope(Scope.CONTROL_FLOW);\n+    indent();\n+    if (controlFlow != null) {\n+      out.write(\"} \");\n+      out.write(controlFlow);\n+      out.write(\";\\n\");\n+    } else {\n+      out.write(\"}\\n\");\n+    }\n+  }\n+\n+  /**\n+   * Completes the current method declaration.\n+   */\n+  public void endMethod() throws IOException {\n+    Scope popped = popScope();\n+    if (popped == Scope.NON_ABSTRACT_METHOD) {\n+      indent();\n+      out.write(\"}\\n\");\n+    } else if (popped != Scope.ABSTRACT_METHOD) {\n+      throw new IllegalStateException();\n+    }\n+  }\n+\n+  /**\n+   * Returns the string literal representing {@code data}, including wrapping\n+   * quotes.\n+   */\n+  public static String stringLiteral(String data) {\n+    StringBuilder result = new StringBuilder();\n+    result.append('\"');\n+    for (int i = 0; i < data.length(); i++) {\n+      char c = data.charAt(i);\n+      switch (c) {\n+        case '\"':\n+          result.append(\"\\\\\\\"\");\n+          break;\n+        case '\\\\':\n+          result.append(\"\\\\\\\\\");\n+          break;\n+        case '\\t':\n+          result.append(\"\\\\\\t\");\n+          break;\n+        case '\\b':\n+          result.append(\"\\\\\\b\");\n+          break;\n+        case '\\n':\n+          result.append(\"\\\\\\n\");\n+          break;\n+        case '\\r':\n+          result.append(\"\\\\\\r\");\n+          break;\n+        case '\\f':\n+          result.append(\"\\\\\\f\");\n+          break;\n+        default:\n+          result.append(c);\n+      }\n+    }\n+    result.append('\"');\n+    return result.toString();\n+  }\n+\n+  @Override public void close() throws IOException {\n+    out.close();\n+  }\n+\n+  /**\n+   * Emit modifier names.\n+   */\n+  private void modifiers(int modifiers) throws IOException {\n+    if ((modifiers & Modifier.PUBLIC) != 0) {\n+      out.write(\"public \");\n+    }\n+    if ((modifiers & Modifier.PRIVATE) != 0) {\n+      out.write(\"private \");\n+    }\n+    if ((modifiers & Modifier.PROTECTED) != 0) {\n+      out.write(\"protected \");\n+    }\n+    if ((modifiers & Modifier.STATIC) != 0) {\n+      out.write(\"static \");\n+    }\n+    if ((modifiers & Modifier.FINAL) != 0) {\n+      out.write(\"final \");\n+    }\n+    if ((modifiers & Modifier.ABSTRACT) != 0) {\n+      out.write(\"abstract \");\n+    }\n+    if ((modifiers & Modifier.SYNCHRONIZED) != 0) {\n+      out.write(\"synchronized \");\n+    }\n+    if ((modifiers & Modifier.TRANSIENT) != 0) {\n+      out.write(\"transient \");\n+    }\n+    if ((modifiers & Modifier.VOLATILE) != 0) {\n+      out.write(\"volatile \");\n+    }\n+  }\n+\n+  private void indent() throws IOException {\n+    for (int i = 0; i < scopes.size(); i++) {\n+      out.write(INDENT);\n+    }\n+  }\n+\n+  private void checkInMethod() {\n+    Scope scope = peekScope();\n+    if (scope != Scope.NON_ABSTRACT_METHOD && scope != Scope.CONTROL_FLOW) {\n+      throw new IllegalArgumentException();\n+    }\n+  }\n+\n+  private void pushScope(Scope pushed) {\n+    scopes.add(pushed);\n+  }\n+\n+  private Scope peekScope() {\n+    return scopes.get(scopes.size() - 1);\n+  }\n+\n+  private Scope popScope() {\n+    return scopes.remove(scopes.size() - 1);\n+  }\n+\n+  private void popScope(Scope expected) {\n+    if (scopes.remove(scopes.size() - 1) != expected) {\n+      throw new IllegalStateException();\n+    }\n+  }\n+\n+  private enum Scope {\n+    TYPE_DECLARATION,\n+    ABSTRACT_METHOD,\n+    NON_ABSTRACT_METHOD,\n+    CONTROL_FLOW,\n+    ANNOTATION_ATTRIBUTE,\n+    ANNOTATION_ARRAY_VALUE,\n+  }\n+}\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "e20c87daa96fa048dfe8da4156813a138ee5075a",
        "previous_commit_hash": "3f224dd2a22b200a5c20adf4e3d3751fb51a532b",
        "diff_stats": {
            "additions": 9,
            "deletions": 0
        },
        "diff_content": "@@ -210,6 +210,15 @@ public final class JavaWriter implements Closeable {\n     out.write(\";\\n\");\n   }\n \n+  /**\n+   * Emits an enum constant.\n+   */\n+  public void enumValue(String name) throws IOException {\n+    indent();\n+    out.write(name);\n+    out.write(\",\\n\");\n+  }\n+\n   /**\n    * Emit a method declaration.\n    *\n"
    },
    {
        "commit_hash": "b1c51f175484ddbac853d12e5b31c3aa6ca10bff",
        "previous_commit_hash": "e20c87daa96fa048dfe8da4156813a138ee5075a",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -36,7 +36,7 @@ import java.util.regex.Pattern;\n  *\n  * @author Jesse Wilson\n  */\n-public final class JavaWriter implements Closeable {\n+final class JavaWriter implements Closeable {\n   private static final Pattern TYPE_PATTERN = Pattern.compile(\"(?:[\\\\w$]+\\\\.)*([\\\\w$]+)\");\n   private static final String INDENT = \"  \";\n \n"
    },
    {
        "commit_hash": "c6683d85f18c8de89182a17062197dcbd7ad7fb3",
        "previous_commit_hash": "b1c51f175484ddbac853d12e5b31c3aa6ca10bff",
        "diff_stats": {
            "additions": 7,
            "deletions": 1
        },
        "diff_content": "@@ -290,7 +290,13 @@ final class JavaWriter implements Closeable {\n     indent();\n     out.write(\"@\");\n     type(annotation);\n-    if (!attributes.isEmpty()) {\n+    if (attributes.size() == 1 && attributes.containsKey(\"value\")) {\n+      out.write(\"(\");\n+      pushScope(Scope.ANNOTATION_ATTRIBUTE);\n+      annotationValue(attributes.get(\"value\"));\n+      popScope(Scope.ANNOTATION_ATTRIBUTE);\n+      out.write(\")\");\n+    } else if (!attributes.isEmpty()) {\n       out.write(\"(\");\n       pushScope(Scope.ANNOTATION_ATTRIBUTE);\n       boolean firstAttribute = true;\n"
    },
    {
        "commit_hash": "b0029de71f6051a2ae84040a779b1fea1997deb5",
        "previous_commit_hash": "c6683d85f18c8de89182a17062197dcbd7ad7fb3",
        "diff_stats": {
            "additions": 27,
            "deletions": 1
        },
        "diff_content": "@@ -349,9 +349,35 @@ final class JavaWriter implements Closeable {\n     }\n   }\n \n+  /**\n+   * Writes a comment.\n+   *\n+   * @param pattern a code pattern like \"Generated by %s\". May contain newline\n+   *     characters.\n+   */\n+  public void comment(boolean javadoc, String pattern, Object... args) throws IOException {\n+    String text = String.format(pattern, args);\n+    text = text.replaceAll(\"\\\\*/\", \"* /\"); // Don't inadvertently terminate the comment!\n+    if (text.contains(\"\\n\")) {\n+      indent();\n+      out.write(javadoc ? \"/**\\n\" : \"/*\\n\");\n+      for (String line : text.split(\"\\n\")) {\n+        indent();\n+        out.write(\" * \" + line + \"\\n\");\n+      }\n+      indent();\n+      out.write(\" */\\n\");\n+    } else if (!text.isEmpty()) {\n+      indent();\n+      out.write(javadoc ? \"/** \" : \"/* \");\n+      out.write(text);\n+      out.write(\" */\\n\");\n+    }\n+  }\n+\n   /**\n    * @param pattern a code pattern like \"int i = %s\". Shouldn't contain a\n-   * trailing semicolon or newline character.\n+   *     trailing semicolon or newline character.\n    */\n   public void statement(String pattern, Object... args) throws IOException {\n     checkInMethod();\n"
    },
    {
        "commit_hash": "50b2ef15532cd5c360e3c5912a67f9628a498a32",
        "previous_commit_hash": "ec4abe321f9aa1dd5453bae85aec2e619a81f0dc",
        "diff_stats": {
            "additions": 17,
            "deletions": 1
        },
        "diff_content": "@@ -382,10 +382,26 @@ final class JavaWriter implements Closeable {\n   public void statement(String pattern, Object... args) throws IOException {\n     checkInMethod();\n     indent();\n-    out.write(String.format(pattern, args));\n+    String statement = String.format(pattern, args);\n+    out.write(reindentStatement(statement));\n     out.write(\";\\n\");\n   }\n \n+  /**\n+   * Adds appropriate indenting after each newline in {@code statement}.\n+   */\n+  private String reindentStatement(String statement) {\n+    if (!statement.contains(\"\\n\")) {\n+      return statement;\n+    }\n+    StringBuilder indent = new StringBuilder().append('\\n');\n+    for (int i = 0; i < scopes.size() + 2; i++) {\n+      indent.append(INDENT);\n+    }\n+    statement = statement.replaceAll(\"\\n\", indent.toString());\n+    return statement;\n+  }\n+\n   /**\n    * @param controlFlow the control flow construct and its code, such as\n    *     \"if (foo == 5)\". Shouldn't contain braces or newline characters.\n"
    },
    {
        "commit_hash": "9b4d2d842e152ffb49d42c450be053d8ada4984e",
        "previous_commit_hash": "74f970d661c6148024a9ef31d6362854cc8e2271",
        "diff_stats": {
            "additions": 22,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,22 @@\n+.classpath\n+.project\n+.settings\n+eclipsebin\n+\n+bin\n+gen\n+build\n+out\n+lib\n+\n+target\n+pom.xml.*\n+release.properties\n+\n+.idea\n+*.iml\n+classes\n+\n+obj\n+\n+.DS_Store\n"
    },
    {
        "commit_hash": "9b4d2d842e152ffb49d42c450be053d8ada4984e",
        "previous_commit_hash": "74f970d661c6148024a9ef31d6362854cc8e2271",
        "diff_stats": {
            "additions": 4,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,4 @@\n+language: java\n+\n+notifications:\n+  email: false\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "9b4d2d842e152ffb49d42c450be053d8ada4984e",
        "previous_commit_hash": "74f970d661c6148024a9ef31d6362854cc8e2271",
        "diff_stats": {
            "additions": 7,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,7 @@\n+Change Log\n+==========\n+\n+Version 1.0.0 *(In Development)*\n+--------------------------------\n+\n+Initial release.\n"
    },
    {
        "commit_hash": "9b4d2d842e152ffb49d42c450be053d8ada4984e",
        "previous_commit_hash": "74f970d661c6148024a9ef31d6362854cc8e2271",
        "diff_stats": {
            "additions": 17,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,17 @@\n+Contributing\n+============\n+\n+If you would like to contribute code you can do so through GitHub by forking\n+the repository and sending a pull request.\n+\n+When submitting code, please make every effort to follow existing conventions\n+and style in order to keep the code as readable as possible. Please also make\n+sure your code compiles by running `mvn clean verify`. Checkstyle failures\n+during compilation indicate errors in your style and can be viewed in the\n+`checkstyle-result.xml` file.\n+\n+Before your code can be accepted into the project you must also sign the\n+[Individual Contributor License Agreement (CLA)][1].\n+\n+\n+ [1]: https://spreadsheets.google.com/spreadsheet/viewform?formkey=dDViT2xzUHAwRkI3X3k5Z0lQM091OGc6MQ&ndplr=1\n"
    },
    {
        "commit_hash": "9b4d2d842e152ffb49d42c450be053d8ada4984e",
        "previous_commit_hash": "74f970d661c6148024a9ef31d6362854cc8e2271",
        "diff_stats": {
            "additions": 202,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,202 @@\n+\n+                                 Apache License\n+                           Version 2.0, January 2004\n+                        http://www.apache.org/licenses/\n+\n+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n+\n+   1. Definitions.\n+\n+      \"License\" shall mean the terms and conditions for use, reproduction,\n+      and distribution as defined by Sections 1 through 9 of this document.\n+\n+      \"Licensor\" shall mean the copyright owner or entity authorized by\n+      the copyright owner that is granting the License.\n+\n+      \"Legal Entity\" shall mean the union of the acting entity and all\n+      other entities that control, are controlled by, or are under common\n+      control with that entity. For the purposes of this definition,\n+      \"control\" means (i) the power, direct or indirect, to cause the\n+      direction or management of such entity, whether by contract or\n+      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n+      outstanding shares, or (iii) beneficial ownership of such entity.\n+\n+      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n+      exercising permissions granted by this License.\n+\n+      \"Source\" form shall mean the preferred form for making modifications,\n+      including but not limited to software source code, documentation\n+      source, and configuration files.\n+\n+      \"Object\" form shall mean any form resulting from mechanical\n+      transformation or translation of a Source form, including but\n+      not limited to compiled object code, generated documentation,\n+      and conversions to other media types.\n+\n+      \"Work\" shall mean the work of authorship, whether in Source or\n+      Object form, made available under the License, as indicated by a\n+      copyright notice that is included in or attached to the work\n+      (an example is provided in the Appendix below).\n+\n+      \"Derivative Works\" shall mean any work, whether in Source or Object\n+      form, that is based on (or derived from) the Work and for which the\n+      editorial revisions, annotations, elaborations, or other modifications\n+      represent, as a whole, an original work of authorship. For the purposes\n+      of this License, Derivative Works shall not include works that remain\n+      separable from, or merely link (or bind by name) to the interfaces of,\n+      the Work and Derivative Works thereof.\n+\n+      \"Contribution\" shall mean any work of authorship, including\n+      the original version of the Work and any modifications or additions\n+      to that Work or Derivative Works thereof, that is intentionally\n+      submitted to Licensor for inclusion in the Work by the copyright owner\n+      or by an individual or Legal Entity authorized to submit on behalf of\n+      the copyright owner. For the purposes of this definition, \"submitted\"\n+      means any form of electronic, verbal, or written communication sent\n+      to the Licensor or its representatives, including but not limited to\n+      communication on electronic mailing lists, source code control systems,\n+      and issue tracking systems that are managed by, or on behalf of, the\n+      Licensor for the purpose of discussing and improving the Work, but\n+      excluding communication that is conspicuously marked or otherwise\n+      designated in writing by the copyright owner as \"Not a Contribution.\"\n+\n+      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n+      on behalf of whom a Contribution has been received by Licensor and\n+      subsequently incorporated within the Work.\n+\n+   2. Grant of Copyright License. Subject to the terms and conditions of\n+      this License, each Contributor hereby grants to You a perpetual,\n+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n+      copyright license to reproduce, prepare Derivative Works of,\n+      publicly display, publicly perform, sublicense, and distribute the\n+      Work and such Derivative Works in Source or Object form.\n+\n+   3. Grant of Patent License. Subject to the terms and conditions of\n+      this License, each Contributor hereby grants to You a perpetual,\n+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n+      (except as stated in this section) patent license to make, have made,\n+      use, offer to sell, sell, import, and otherwise transfer the Work,\n+      where such license applies only to those patent claims licensable\n+      by such Contributor that are necessarily infringed by their\n+      Contribution(s) alone or by combination of their Contribution(s)\n+      with the Work to which such Contribution(s) was submitted. If You\n+      institute patent litigation against any entity (including a\n+      cross-claim or counterclaim in a lawsuit) alleging that the Work\n+      or a Contribution incorporated within the Work constitutes direct\n+      or contributory patent infringement, then any patent licenses\n+      granted to You under this License for that Work shall terminate\n+      as of the date such litigation is filed.\n+\n+   4. Redistribution. You may reproduce and distribute copies of the\n+      Work or Derivative Works thereof in any medium, with or without\n+      modifications, and in Source or Object form, provided that You\n+      meet the following conditions:\n+\n+      (a) You must give any other recipients of the Work or\n+          Derivative Works a copy of this License; and\n+\n+      (b) You must cause any modified files to carry prominent notices\n+          stating that You changed the files; and\n+\n+      (c) You must retain, in the Source form of any Derivative Works\n+          that You distribute, all copyright, patent, trademark, and\n+          attribution notices from the Source form of the Work,\n+          excluding those notices that do not pertain to any part of\n+          the Derivative Works; and\n+\n+      (d) If the Work includes a \"NOTICE\" text file as part of its\n+          distribution, then any Derivative Works that You distribute must\n+          include a readable copy of the attribution notices contained\n+          within such NOTICE file, excluding those notices that do not\n+          pertain to any part of the Derivative Works, in at least one\n+          of the following places: within a NOTICE text file distributed\n+          as part of the Derivative Works; within the Source form or\n+          documentation, if provided along with the Derivative Works; or,\n+          within a display generated by the Derivative Works, if and\n+          wherever such third-party notices normally appear. The contents\n+          of the NOTICE file are for informational purposes only and\n+          do not modify the License. You may add Your own attribution\n+          notices within Derivative Works that You distribute, alongside\n+          or as an addendum to the NOTICE text from the Work, provided\n+          that such additional attribution notices cannot be construed\n+          as modifying the License.\n+\n+      You may add Your own copyright statement to Your modifications and\n+      may provide additional or different license terms and conditions\n+      for use, reproduction, or distribution of Your modifications, or\n+      for any such Derivative Works as a whole, provided Your use,\n+      reproduction, and distribution of the Work otherwise complies with\n+      the conditions stated in this License.\n+\n+   5. Submission of Contributions. Unless You explicitly state otherwise,\n+      any Contribution intentionally submitted for inclusion in the Work\n+      by You to the Licensor shall be under the terms and conditions of\n+      this License, without any additional terms or conditions.\n+      Notwithstanding the above, nothing herein shall supersede or modify\n+      the terms of any separate license agreement you may have executed\n+      with Licensor regarding such Contributions.\n+\n+   6. Trademarks. This License does not grant permission to use the trade\n+      names, trademarks, service marks, or product names of the Licensor,\n+      except as required for reasonable and customary use in describing the\n+      origin of the Work and reproducing the content of the NOTICE file.\n+\n+   7. Disclaimer of Warranty. Unless required by applicable law or\n+      agreed to in writing, Licensor provides the Work (and each\n+      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+      implied, including, without limitation, any warranties or conditions\n+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n+      PARTICULAR PURPOSE. You are solely responsible for determining the\n+      appropriateness of using or redistributing the Work and assume any\n+      risks associated with Your exercise of permissions under this License.\n+\n+   8. Limitation of Liability. In no event and under no legal theory,\n+      whether in tort (including negligence), contract, or otherwise,\n+      unless required by applicable law (such as deliberate and grossly\n+      negligent acts) or agreed to in writing, shall any Contributor be\n+      liable to You for damages, including any direct, indirect, special,\n+      incidental, or consequential damages of any character arising as a\n+      result of this License or out of the use or inability to use the\n+      Work (including but not limited to damages for loss of goodwill,\n+      work stoppage, computer failure or malfunction, or any and all\n+      other commercial damages or losses), even if such Contributor\n+      has been advised of the possibility of such damages.\n+\n+   9. Accepting Warranty or Additional Liability. While redistributing\n+      the Work or Derivative Works thereof, You may choose to offer,\n+      and charge a fee for, acceptance of support, warranty, indemnity,\n+      or other liability obligations and/or rights consistent with this\n+      License. However, in accepting such obligations, You may act only\n+      on Your own behalf and on Your sole responsibility, not on behalf\n+      of any other Contributor, and only if You agree to indemnify,\n+      defend, and hold each Contributor harmless for any liability\n+      incurred by, or claims asserted against, such Contributor by reason\n+      of your accepting any such warranty or additional liability.\n+\n+   END OF TERMS AND CONDITIONS\n+\n+   APPENDIX: How to apply the Apache License to your work.\n+\n+      To apply the Apache License to your work, attach the following\n+      boilerplate notice, with the fields enclosed by brackets \"[]\"\n+      replaced with your own identifying information. (Don't include\n+      the brackets!)  The text should be enclosed in the appropriate\n+      comment syntax for the file format. We also recommend that a\n+      file or class name and description of purpose be included on the\n+      same \"printed page\" as the copyright notice for easier\n+      identification within third-party archives.\n+\n+   Copyright [yyyy] [name of copyright owner]\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n"
    },
    {
        "commit_hash": "9b4d2d842e152ffb49d42c450be053d8ada4984e",
        "previous_commit_hash": "74f970d661c6148024a9ef31d6362854cc8e2271",
        "diff_stats": {
            "additions": 4,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,4 @@\n+JavaWriter\n+==========\n+\n+TODO\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "9b4d2d842e152ffb49d42c450be053d8ada4984e",
        "previous_commit_hash": "74f970d661c6148024a9ef31d6362854cc8e2271",
        "diff_stats": {
            "additions": 120,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,120 @@\n+<?xml version=\"1.0\"?>\r\n+<!DOCTYPE module PUBLIC\r\n+    \"-//Puppy Crawl//DTD Check Configuration 1.2//EN\"\r\n+    \"http://www.puppycrawl.com/dtds/configuration_1_2.dtd\">\r\n+\r\n+<module name=\"Checker\">\r\n+    <module name=\"NewlineAtEndOfFile\"/>\r\n+    <module name=\"FileLength\"/>\r\n+    <module name=\"FileTabCharacter\"/>\r\n+\r\n+    <!-- Trailing spaces -->\r\n+    <module name=\"RegexpSingleline\">\r\n+        <property name=\"format\" value=\"\\s+$\"/>\r\n+        <property name=\"message\" value=\"Line has trailing spaces.\"/>\r\n+    </module>\r\n+\r\n+    <module name=\"TreeWalker\">\r\n+        <property name=\"cacheFile\" value=\"${checkstyle.cache.file}\"/>\r\n+\r\n+        <!-- Checks for Javadoc comments.                     -->\r\n+        <!-- See http://checkstyle.sf.net/config_javadoc.html -->\r\n+        <!--module name=\"JavadocMethod\"/-->\r\n+        <!--module name=\"JavadocType\"/-->\r\n+        <!--module name=\"JavadocVariable\"/-->\r\n+        <module name=\"JavadocStyle\"/>\r\n+\r\n+\r\n+        <!-- Checks for Naming Conventions.                  -->\r\n+        <!-- See http://checkstyle.sf.net/config_naming.html -->\r\n+        <module name=\"ConstantName\"/>\r\n+        <module name=\"LocalFinalVariableName\"/>\r\n+        <module name=\"LocalVariableName\"/>\r\n+        <module name=\"MemberName\"/>\r\n+        <module name=\"MethodName\"/>\r\n+        <module name=\"PackageName\"/>\r\n+        <module name=\"ParameterName\"/>\r\n+        <module name=\"StaticVariableName\"/>\r\n+        <module name=\"TypeName\"/>\r\n+\r\n+\r\n+        <!-- Checks for imports                              -->\r\n+        <!-- See http://checkstyle.sf.net/config_import.html -->\r\n+        <module name=\"AvoidStarImport\"/>\r\n+        <module name=\"IllegalImport\"/> <!-- defaults to sun.* packages -->\r\n+        <module name=\"RedundantImport\"/>\r\n+        <module name=\"UnusedImports\"/>\r\n+\r\n+\r\n+        <!-- Checks for Size Violations.                    -->\r\n+        <!-- See http://checkstyle.sf.net/config_sizes.html -->\r\n+        <module name=\"LineLength\">\r\n+            <property name=\"max\" value=\"120\"/>\r\n+        </module>\r\n+        <module name=\"MethodLength\"/>\r\n+        <module name=\"ParameterNumber\"/>\r\n+\r\n+\r\n+        <!-- Checks for whitespace                               -->\r\n+        <!-- See http://checkstyle.sf.net/config_whitespace.html -->\r\n+        <module name=\"GenericWhitespace\"/>\r\n+        <module name=\"EmptyForIteratorPad\"/>\r\n+        <module name=\"MethodParamPad\"/>\r\n+        <module name=\"NoWhitespaceAfter\"/>\r\n+        <module name=\"NoWhitespaceBefore\"/>\r\n+        <module name=\"OperatorWrap\"/>\r\n+        <module name=\"ParenPad\"/>\r\n+        <module name=\"TypecastParenPad\"/>\r\n+        <module name=\"WhitespaceAfter\"/>\r\n+        <module name=\"WhitespaceAround\"/>\r\n+\r\n+\r\n+        <!-- Modifier Checks                                    -->\r\n+        <!-- See http://checkstyle.sf.net/config_modifiers.html -->\r\n+        <module name=\"ModifierOrder\"/>\r\n+        <module name=\"RedundantModifier\"/>\r\n+\r\n+\r\n+        <!-- Checks for blocks. You know, those {}'s         -->\r\n+        <!-- See http://checkstyle.sf.net/config_blocks.html -->\r\n+        <module name=\"AvoidNestedBlocks\"/>\r\n+        <!--module name=\"EmptyBlock\"/-->\r\n+        <module name=\"LeftCurly\"/>\r\n+        <module name=\"NeedBraces\"/>\r\n+        <module name=\"RightCurly\"/>\r\n+\r\n+\r\n+        <!-- Checks for common coding problems               -->\r\n+        <!-- See http://checkstyle.sf.net/config_coding.html -->\r\n+        <!--module name=\"AvoidInlineConditionals\"/-->\r\n+        <module name=\"CovariantEquals\"/>\r\n+        <module name=\"DoubleCheckedLocking\"/>\r\n+        <module name=\"EmptyStatement\"/>\r\n+        <module name=\"EqualsAvoidNull\"/>\r\n+        <module name=\"EqualsHashCode\"/>\r\n+        <!--module name=\"HiddenField\"/-->\r\n+        <module name=\"IllegalInstantiation\"/>\r\n+        <module name=\"InnerAssignment\"/>\r\n+        <module name=\"MagicNumber\"/>\r\n+        <module name=\"MissingSwitchDefault\"/>\r\n+        <module name=\"RedundantThrows\"/>\r\n+        <module name=\"SimplifyBooleanExpression\"/>\r\n+        <module name=\"SimplifyBooleanReturn\"/>\r\n+\r\n+        <!-- Checks for class design                         -->\r\n+        <!-- See http://checkstyle.sf.net/config_design.html -->\r\n+        <!--module name=\"DesignForExtension\"/-->\r\n+        <module name=\"FinalClass\"/>\r\n+        <module name=\"HideUtilityClassConstructor\"/>\r\n+        <module name=\"InterfaceIsType\"/>\r\n+        <!--module name=\"VisibilityModifier\"/-->\r\n+\r\n+\r\n+        <!-- Miscellaneous other checks.                   -->\r\n+        <!-- See http://checkstyle.sf.net/config_misc.html -->\r\n+        <module name=\"ArrayTypeStyle\"/>\r\n+        <!--module name=\"FinalParameters\"/-->\r\n+        <module name=\"TodoComment\"/>\r\n+        <module name=\"UpperEll\"/>\r\n+    </module>\r\n+</module>\r\n"
    },
    {
        "commit_hash": "9b4d2d842e152ffb49d42c450be053d8ada4984e",
        "previous_commit_hash": "74f970d661c6148024a9ef31d6362854cc8e2271",
        "diff_stats": {
            "additions": 92,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,92 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <parent>\n+    <groupId>org.sonatype.oss</groupId>\n+    <artifactId>oss-parent</artifactId>\n+    <version>7</version>\n+  </parent>\n+\n+  <groupId>com.squareup</groupId>\n+  <artifactId>javawriter</artifactId>\n+  <version>1.0.0-SNAPSHOT</version>\n+\n+  <name>JavaWriter</name>\n+  <description>Emits Java source files.</description>\n+  <url>http://github.com/square/javawriter/</url>\n+\n+  <properties>\n+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+\n+    <java.version>1.6</java.version>\n+    <junit.version>4.10</junit.version>\n+  </properties>\n+\n+  <scm>\n+    <url>http://github.com/square/javawriter/</url>\n+    <connection>scm:git:git://github.com/square/javawriter.git</connection>\n+    <developerConnection>scm:git:ssh://git@github.com/square/javawriter.git</developerConnection>\n+    <tag>HEAD</tag>\n+  </scm>\n+\n+  <issueManagement>\n+    <system>GitHub Issues</system>\n+    <url>http://github.com/square/javawriter/issues</url>\n+  </issueManagement>\n+\n+  <licenses>\n+    <license>\n+      <name>Apache 2.0</name>\n+      <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>\n+    </license>\n+  </licenses>\n+\n+  <organization>\n+    <name>Square, Inc.</name>\n+    <url>http://squareup.com</url>\n+  </organization>\n+\n+  <dependencies>\n+    <dependency>\n+      <groupId>junit</groupId>\n+      <artifactId>junit</artifactId>\n+      <version>${junit.version}</version>\n+      <scope>test</scope>\n+    </dependency>\n+  </dependencies>\n+\n+  <build>\n+    <plugins>\n+      <plugin>\n+        <groupId>org.apache.maven.plugins</groupId>\n+        <artifactId>maven-compiler-plugin</artifactId>\n+        <version>3.0</version>\n+        <configuration>\n+          <source>${java.version}</source>\n+          <target>${java.version}</target>\n+        </configuration>\n+      </plugin>\n+\n+      <plugin>\n+        <groupId>org.apache.maven.plugins</groupId>\n+        <artifactId>maven-checkstyle-plugin</artifactId>\n+        <version>2.9.1</version>\n+        <configuration>\n+          <failsOnError>true</failsOnError>\n+          <configLocation>checkstyle.xml</configLocation>\n+          <consoleOutput>true</consoleOutput>\n+        </configuration>\n+        <executions>\n+          <execution>\n+            <phase>verify</phase>\n+            <goals>\n+              <goal>checkstyle</goal>\n+            </goals>\n+          </execution>\n+        </executions>\n+      </plugin>\n+    </plugins>\n+  </build>\n+</project>\n"
    },
    {
        "commit_hash": "9384024b1d13d8e5297bcf3c00f230228f5ffebe",
        "previous_commit_hash": "9b4d2d842e152ffb49d42c450be053d8ada4984e",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -49,7 +49,7 @@\n         <!-- Checks for Size Violations.                    -->\r\n         <!-- See http://checkstyle.sf.net/config_sizes.html -->\r\n         <module name=\"LineLength\">\r\n-            <property name=\"max\" value=\"120\"/>\r\n+            <property name=\"max\" value=\"100\"/>\r\n         </module>\r\n         <module name=\"MethodLength\"/>\r\n         <module name=\"ParameterNumber\"/>\r\n"
    },
    {
        "commit_hash": "9384024b1d13d8e5297bcf3c00f230228f5ffebe",
        "previous_commit_hash": "9b4d2d842e152ffb49d42c450be053d8ada4984e",
        "diff_stats": {
            "additions": 7,
            "deletions": 0
        },
        "diff_content": "@@ -22,6 +22,7 @@\n \n     <java.version>1.6</java.version>\n     <junit.version>4.10</junit.version>\n+    <fest.version>2.0M8</fest.version>\n   </properties>\n \n   <scm>\n@@ -55,6 +56,12 @@\n       <version>${junit.version}</version>\n       <scope>test</scope>\n     </dependency>\n+    <dependency>\n+      <groupId>org.easytesting</groupId>\n+      <artifactId>fest-assert-core</artifactId>\n+      <version>${fest.version}</version>\n+      <scope>test</scope>\n+    </dependency>\n   </dependencies>\n \n   <build>\n"
    },
    {
        "commit_hash": "9384024b1d13d8e5297bcf3c00f230228f5ffebe",
        "previous_commit_hash": "9b4d2d842e152ffb49d42c450be053d8ada4984e",
        "diff_stats": {
            "additions": 168,
            "deletions": 185
        },
        "diff_content": "@@ -21,44 +21,37 @@ import java.io.Writer;\n import java.lang.annotation.Annotation;\n import java.lang.reflect.Modifier;\n import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n import java.util.Collections;\n-import java.util.HashMap;\n+import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.TreeSet;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n-/**\n- * Emits Java source files.\n- *\n- * <p><strong>Warning:</strong> Shamefully stolen from\n- * <a href=\"https://raw.github.com/square/dagger/\">Dagger</a>.\n- *\n- * @author Jesse Wilson\n- */\n-final class JavaWriter implements Closeable {\n+/** Emits Java source files. */\n+public final class JavaWriter implements Closeable {\n   private static final Pattern TYPE_PATTERN = Pattern.compile(\"(?:[\\\\w$]+\\\\.)*([\\\\w$]+)\");\n   private static final String INDENT = \"  \";\n \n   /** Map fully qualified type names to their short names. */\n-  private final Map<String, String> importedTypes = new HashMap<String, String>();\n+  private final Map<String, String> importedTypes = new LinkedHashMap<String, String>();\n \n   private String packagePrefix;\n   private final List<Scope> scopes = new ArrayList<Scope>();\n   private final Writer out;\n \n   /**\n-   * @param out the stream to which Java source will be written. This should be\n-   *     a buffered stream.\n+   * @param out the stream to which Java source will be written. This should be a buffered stream.\n    */\n   public JavaWriter(Writer out) {\n     this.out = out;\n   }\n \n-  /**\n-   * Emit a package declaration.\n-   */\n-  public void addPackage(String packageName) throws IOException {\n+  /** Emit a package declaration. */\n+  public void emitPackage(String packageName) throws IOException {\n     if (this.packagePrefix != null) {\n       throw new IllegalStateException();\n     }\n@@ -73,35 +66,43 @@ final class JavaWriter implements Closeable {\n   }\n \n   /**\n-   * Equivalent to {@code addImport(type.getName())}.\n+   * Emit an import for each {@code type} provided. For the duration of the file, all references to\n+   * these classes will be automatically shortened.\n    */\n-  public void addImport(Class<?> type) throws IOException {\n-    addImport(type.getName());\n+  public void emitImports(String... types) throws IOException {\n+    emitImports(Arrays.asList(types));\n   }\n \n   /**\n-   * Emit an import for {@code type}. For the duration of the file, all\n-   * references to this class will be automatically shortened.\n+   * Emit an import for each {@code type} in the provided {@code Collection}. For the duration of\n+   * the file, all references to these classes will be automatically shortened.\n    */\n-  public void addImport(String type) throws IOException {\n-    Matcher matcher = TYPE_PATTERN.matcher(type);\n-    if (!matcher.matches()) {\n-      throw new IllegalArgumentException(type);\n-    }\n-    if (importedTypes.put(type, matcher.group(1)) != null) {\n-      throw new IllegalArgumentException(type);\n+  public void emitImports(Collection<String> types) throws IOException {\n+    for (String type : new TreeSet<String>(types)) {\n+      Matcher matcher = TYPE_PATTERN.matcher(type);\n+      if (!matcher.matches()) {\n+        throw new IllegalArgumentException(type);\n+      }\n+      if (importedTypes.put(type, matcher.group(1)) != null) {\n+        throw new IllegalArgumentException(type);\n+      }\n+      out.write(\"import \");\n+      out.write(type);\n+      out.write(\";\\n\");\n     }\n-    out.write(\"import \");\n-    out.write(type);\n-    out.write(\";\\n\");\n+    emitEmptyLine();\n   }\n \n   /**\n-   * Emits a name like {@code java.lang.String} or {@code\n-   * java.util.List<java.lang.String>}, shorting it with imports if\n-   * possible.\n+   * Emits a name like {@code java.lang.String} or {@code java.util.List<java.lang.String>},\n+   * shorting it with imports if possible.\n    */\n-  private void type(String type) throws IOException {\n+  private void emitType(String type) throws IOException {\n+    out.write(compressType(type));\n+  }\n+\n+  String compressType(String type) {\n+    StringBuffer sb = new StringBuffer();\n     if (this.packagePrefix == null) {\n       throw new IllegalStateException();\n     }\n@@ -111,29 +112,42 @@ final class JavaWriter implements Closeable {\n     while (true) {\n       boolean found = m.find(pos);\n \n-      // copy non-matching characters like \"<\"\n+      // Copy non-matching characters like \"<\".\n       int typeStart = found ? m.start() : type.length();\n-      out.write(type, pos, typeStart - pos);\n+      sb.append(type, pos, typeStart);\n \n       if (!found) {\n         break;\n       }\n \n-      // copy a single class name, shortening it if possible\n+      // Copy a single class name, shortening it if possible.\n       String name = m.group(0);\n-      String imported;\n-      if ((imported = importedTypes.get(name)) != null) {\n-        out.write(imported);\n-      } else if (name.startsWith(packagePrefix)\n-          && name.indexOf('.', packagePrefix.length()) == -1) {\n-        out.write(name.substring(packagePrefix.length()));\n+      String imported = importedTypes.get(name);\n+      if (imported != null) {\n+        sb.append(imported);\n+      } else if (isClassInPackage(name)) {\n+        sb.append(name.substring(packagePrefix.length()));\n       } else if (name.startsWith(\"java.lang.\")) {\n-        out.write(name.substring(\"java.lang.\".length()));\n+        sb.append(name.substring(\"java.lang.\".length()));\n       } else {\n-        out.write(name);\n+        sb.append(name);\n       }\n       pos = m.end();\n     }\n+    return sb.toString();\n+  }\n+\n+  private boolean isClassInPackage(String name) {\n+    if (name.startsWith(packagePrefix)) {\n+      if (name.indexOf('.', packagePrefix.length()) == -1) {\n+        return true;\n+      }\n+      int index = name.indexOf('.');\n+      if (name.substring(index + 1, index + 2).matches(\"[A-Z]\")) {\n+        return true;\n+      }\n+    }\n+    return false;\n   }\n \n   /**\n@@ -151,18 +165,16 @@ final class JavaWriter implements Closeable {\n    * @param kind such as \"class\", \"interface\" or \"enum\".\n    * @param extendsType the class to extend, or null for no extends clause.\n    */\n-  public void beginType(String type, String kind, int modifiers,\n-      String extendsType, String... implementsTypes) throws IOException {\n+  public void beginType(String type, String kind, int modifiers, String extendsType,\n+      String... implementsTypes) throws IOException {\n     indent();\n-    modifiers(modifiers);\n+    out.write(modifiers(modifiers).toString());\n     out.write(kind);\n     out.write(\" \");\n-    type(type);\n+    emitType(type);\n     if (extendsType != null) {\n-      out.write(\"\\n\");\n-      indent();\n-      out.write(\"    extends \");\n-      type(extendsType);\n+      out.write(\" extends \");\n+      emitType(extendsType);\n     }\n     if (implementsTypes.length > 0) {\n       out.write(\"\\n\");\n@@ -172,34 +184,30 @@ final class JavaWriter implements Closeable {\n         if (i != 0) {\n           out.write(\", \");\n         }\n-        type(implementsTypes[i]);\n+        emitType(implementsTypes[i]);\n       }\n     }\n     out.write(\" {\\n\");\n     pushScope(Scope.TYPE_DECLARATION);\n   }\n \n-  /**\n-   * Completes the current type declaration.\n-   */\n+  /** Completes the current type declaration. */\n   public void endType() throws IOException {\n     popScope(Scope.TYPE_DECLARATION);\n     indent();\n     out.write(\"}\\n\");\n   }\n \n-  /**\n-   * Emits a field declaration.\n-   */\n-  public void field(String type, String name, int modifiers) throws IOException {\n-    field(type, name, modifiers, null);\n+  /** Emits a field declaration. */\n+  public void emitField(String type, String name, int modifiers) throws IOException {\n+    emitField(type, name, modifiers, null);\n   }\n \n-  public void field(String type, String name, int modifiers, String initialValue)\n+  public void emitField(String type, String name, int modifiers, String initialValue)\n       throws IOException {\n     indent();\n-    modifiers(modifiers);\n-    type(type);\n+    out.write(modifiers(modifiers).toString());\n+    emitType(type);\n     out.write(\" \");\n     out.write(name);\n \n@@ -210,42 +218,32 @@ final class JavaWriter implements Closeable {\n     out.write(\";\\n\");\n   }\n \n-  /**\n-   * Emits an enum constant.\n-   */\n-  public void enumValue(String name) throws IOException {\n-    indent();\n-    out.write(name);\n-    out.write(\",\\n\");\n-  }\n-\n   /**\n    * Emit a method declaration.\n    *\n    * @param returnType the method's return type, or null for constructors.\n    * @param parameters alternating parameter types and names.\n-   * @param name the method name, or the fully qualified class name for\n-   *     constructors.\n+   * @param name the method name, or the fully qualified class name for constructors.\n    */\n   public void beginMethod(String returnType, String name, int modifiers, String... parameters)\n       throws IOException {\n     indent();\n-    modifiers(modifiers);\n+    out.write(modifiers(modifiers).toString());\n     if (returnType != null) {\n-      type(returnType);\n+      emitType(returnType);\n       out.write(\" \");\n       out.write(name);\n     } else {\n-      type(name);\n+      emitType(name);\n     }\n     out.write(\"(\");\n     for (int p = 0; p < parameters.length;) {\n       if (p != 0) {\n         out.write(\", \");\n       }\n-      type(parameters[p++]);\n+      emitType(parameters[p++]);\n       out.write(\" \");\n-      type(parameters[p++]);\n+      emitType(parameters[p++]);\n     }\n     out.write(\")\");\n     if ((modifiers & Modifier.ABSTRACT) != 0) {\n@@ -257,46 +255,78 @@ final class JavaWriter implements Closeable {\n     }\n   }\n \n-  /**\n-   * Equivalent to {@code annotation(annotation, emptyMap())}.\n-   */\n-  public void annotation(String annotation) throws IOException {\n-    annotation(annotation, Collections.<String, Object>emptyMap());\n+  /** Emits some Javadoc comments with line separated by {@code \\n}. */\n+  public void emitJavadoc(String javadoc, Object... params) throws IOException {\n+    String formatted = String.format(javadoc, params);\n+    indent();\n+    out.write(\"/**\\n\");\n+    for (String line : formatted.split(\"\\n\")) {\n+      indent();\n+      out.write(\" * \");\n+      out.write(line);\n+      out.write(\"\\n\");\n+    }\n+    indent();\n+    out.write(\" */\\n\");\n   }\n \n-  /**\n-   * Equivalent to {@code annotation(annotationType.getName(), emptyMap())}.\n-   */\n-  public void annotation(Class<? extends Annotation> annotationType) throws IOException {\n-    annotation(annotationType.getName(), Collections.<String, Object>emptyMap());\n+  /** Emits some Javadoc comments. */\n+  public void emitEndOfLineComment(String comment) throws IOException {\n+    out.write(\"// \");\n+    out.write(comment);\n+    out.write(\"\\n\");\n+  }\n+\n+  public void emitEmptyLine() throws IOException {\n+    out.write(\"\\n\");\n+  }\n+\n+  /** Equivalent to {@code annotation(annotation, emptyMap())}. */\n+  public void emitAnnotation(String annotation) throws IOException {\n+    emitAnnotation(annotation, Collections.<String, Object>emptyMap());\n+  }\n+\n+  /** Equivalent to {@code annotation(annotationType.getName(), emptyMap())}. */\n+  public void emitAnnotation(Class<? extends Annotation> annotationType) throws IOException {\n+    emitAnnotation(annotationType.getName(), Collections.<String, Object>emptyMap());\n   }\n \n   /**\n-   * Equivalent to {@code annotation(annotationType.getName(), attributes)}.\n+   * Annotates the next element with {@code annotation} and a {@code value}.\n+   *\n+   * @param value an object used as the default (value) parameter of the annotation. The value will\n+   *     be encoded using Object.toString(); use {@link #stringLiteral} for String values. Object\n+   *     arrays are written one element per line.\n    */\n-  public void annotation(Class<? extends Annotation> annotationType, Map<String, ?> attributes)\n+  public void emitAnnotation(Class<? extends Annotation> annotation, Object value)\n       throws IOException {\n-    annotation(annotationType.getName(), attributes);\n+    indent();\n+    out.write(\"@\");\n+    emitType(annotation.getName());\n+    out.write(\"(\");\n+    emitAnnotationValue(value);\n+    out.write(\")\");\n+    out.write(\"\\n\");\n+  }\n+\n+  /** Equivalent to {@code annotation(annotationType.getName(), attributes)}. */\n+  public void emitAnnotation(Class<? extends Annotation> annotationType, Map<String, ?> attributes)\n+      throws IOException {\n+    emitAnnotation(annotationType.getName(), attributes);\n   }\n \n   /**\n    * Annotates the next element with {@code annotation} and {@code attributes}.\n    *\n-   * @param attributes a map from annotation attribute names to their values.\n-   *     Values are encoded using Object.toString(); use {@link #stringLiteral}\n-   *     for String values. Object arrays are written one element per line.\n+   * @param attributes a map from annotation attribute names to their values. Values are encoded\n+   *     using Object.toString(); use {@link #stringLiteral} for String values. Object arrays are\n+   *     written one element per line.\n    */\n-  public void annotation(String annotation, Map<String, ?> attributes) throws IOException {\n+  public void emitAnnotation(String annotation, Map<String, ?> attributes) throws IOException {\n     indent();\n     out.write(\"@\");\n-    type(annotation);\n-    if (attributes.size() == 1 && attributes.containsKey(\"value\")) {\n-      out.write(\"(\");\n-      pushScope(Scope.ANNOTATION_ATTRIBUTE);\n-      annotationValue(attributes.get(\"value\"));\n-      popScope(Scope.ANNOTATION_ATTRIBUTE);\n-      out.write(\")\");\n-    } else if (!attributes.isEmpty()) {\n+    emitType(annotation);\n+    if (!attributes.isEmpty()) {\n       out.write(\"(\");\n       pushScope(Scope.ANNOTATION_ATTRIBUTE);\n       boolean firstAttribute = true;\n@@ -311,7 +341,7 @@ final class JavaWriter implements Closeable {\n         out.write(entry.getKey());\n         out.write(\" = \");\n         Object value = entry.getValue();\n-        annotationValue(value);\n+        emitAnnotationValue(value);\n       }\n       popScope(Scope.ANNOTATION_ATTRIBUTE);\n       out.write(\"\\n\");\n@@ -322,10 +352,10 @@ final class JavaWriter implements Closeable {\n   }\n \n   /**\n-   * Writes a single annotation value. If the value is an array, each element in\n-   * the array will be written to its own line.\n+   * Writes a single annotation value. If the value is an array, each element in the array will be\n+   * written to its own line.\n    */\n-  private void annotationValue(Object value) throws IOException {\n+  private void emitAnnotationValue(Object value) throws IOException {\n     if (value instanceof Object[]) {\n       out.write(\"{\");\n       boolean firstValue = true;\n@@ -350,61 +380,19 @@ final class JavaWriter implements Closeable {\n   }\n \n   /**\n-   * Writes a comment.\n-   *\n-   * @param pattern a code pattern like \"Generated by %s\". May contain newline\n-   *     characters.\n+   * @param pattern a code pattern like \"int i = %s\". Shouldn't contain a trailing semicolon or\n+   *     newline character.\n    */\n-  public void comment(boolean javadoc, String pattern, Object... args) throws IOException {\n-    String text = String.format(pattern, args);\n-    text = text.replaceAll(\"\\\\*/\", \"* /\"); // Don't inadvertently terminate the comment!\n-    if (text.contains(\"\\n\")) {\n-      indent();\n-      out.write(javadoc ? \"/**\\n\" : \"/*\\n\");\n-      for (String line : text.split(\"\\n\")) {\n-        indent();\n-        out.write(\" * \" + line + \"\\n\");\n-      }\n-      indent();\n-      out.write(\" */\\n\");\n-    } else if (!text.isEmpty()) {\n-      indent();\n-      out.write(javadoc ? \"/** \" : \"/* \");\n-      out.write(text);\n-      out.write(\" */\\n\");\n-    }\n-  }\n-\n-  /**\n-   * @param pattern a code pattern like \"int i = %s\". Shouldn't contain a\n-   *     trailing semicolon or newline character.\n-   */\n-  public void statement(String pattern, Object... args) throws IOException {\n+  public void emitStatement(String pattern, Object... args) throws IOException {\n     checkInMethod();\n     indent();\n-    String statement = String.format(pattern, args);\n-    out.write(reindentStatement(statement));\n+    out.write(String.format(pattern, args));\n     out.write(\";\\n\");\n   }\n \n   /**\n-   * Adds appropriate indenting after each newline in {@code statement}.\n-   */\n-  private String reindentStatement(String statement) {\n-    if (!statement.contains(\"\\n\")) {\n-      return statement;\n-    }\n-    StringBuilder indent = new StringBuilder().append('\\n');\n-    for (int i = 0; i < scopes.size() + 2; i++) {\n-      indent.append(INDENT);\n-    }\n-    statement = statement.replaceAll(\"\\n\", indent.toString());\n-    return statement;\n-  }\n-\n-  /**\n-   * @param controlFlow the control flow construct and its code, such as\n-   *     \"if (foo == 5)\". Shouldn't contain braces or newline characters.\n+   * @param controlFlow the control flow construct and its code, such as \"if (foo == 5)\". Shouldn't\n+   *     contain braces or newline characters.\n    */\n   public void beginControlFlow(String controlFlow) throws IOException {\n     checkInMethod();\n@@ -415,8 +403,8 @@ final class JavaWriter implements Closeable {\n   }\n \n   /**\n-   * @param controlFlow the control flow construct and its code, such as\n-   *     \"else if (foo == 10)\". Shouldn't contain braces or newline characters.\n+   * @param controlFlow the control flow construct and its code, such as \"else if (foo == 10)\".\n+   *     Shouldn't contain braces or newline characters.\n    */\n   public void nextControlFlow(String controlFlow) throws IOException {\n     popScope(Scope.CONTROL_FLOW);\n@@ -432,8 +420,8 @@ final class JavaWriter implements Closeable {\n   }\n \n   /**\n-   * @param controlFlow the optional control flow construct and its code, such\n-   *     as \"while(foo == 20)\". Only used for \"do/while\" control flows.\n+   * @param controlFlow the optional control flow construct and its code, such as\n+   *     \"while(foo == 20)\". Only used for \"do/while\" control flows.\n    */\n   public void endControlFlow(String controlFlow) throws IOException {\n     popScope(Scope.CONTROL_FLOW);\n@@ -447,9 +435,7 @@ final class JavaWriter implements Closeable {\n     }\n   }\n \n-  /**\n-   * Completes the current method declaration.\n-   */\n+  /** Completes the current method declaration. */\n   public void endMethod() throws IOException {\n     Scope popped = popScope();\n     if (popped == Scope.NON_ABSTRACT_METHOD) {\n@@ -460,10 +446,7 @@ final class JavaWriter implements Closeable {\n     }\n   }\n \n-  /**\n-   * Returns the string literal representing {@code data}, including wrapping\n-   * quotes.\n-   */\n+  /** Returns the string literal representing {@code data}, including wrapping quotes. */\n   public static String stringLiteral(String data) {\n     StringBuilder result = new StringBuilder();\n     result.append('\"');\n@@ -503,37 +486,37 @@ final class JavaWriter implements Closeable {\n     out.close();\n   }\n \n-  /**\n-   * Emit modifier names.\n-   */\n-  private void modifiers(int modifiers) throws IOException {\n+  /** Emit modifier names. */\n+  static StringBuffer modifiers(int modifiers) {\n+    StringBuffer out = new StringBuffer();\n     if ((modifiers & Modifier.PUBLIC) != 0) {\n-      out.write(\"public \");\n+      out.append(\"public \");\n     }\n     if ((modifiers & Modifier.PRIVATE) != 0) {\n-      out.write(\"private \");\n+      out.append(\"private \");\n     }\n     if ((modifiers & Modifier.PROTECTED) != 0) {\n-      out.write(\"protected \");\n+      out.append(\"protected \");\n     }\n     if ((modifiers & Modifier.STATIC) != 0) {\n-      out.write(\"static \");\n+      out.append(\"static \");\n     }\n     if ((modifiers & Modifier.FINAL) != 0) {\n-      out.write(\"final \");\n+      out.append(\"final \");\n     }\n     if ((modifiers & Modifier.ABSTRACT) != 0) {\n-      out.write(\"abstract \");\n+      out.append(\"abstract \");\n     }\n     if ((modifiers & Modifier.SYNCHRONIZED) != 0) {\n-      out.write(\"synchronized \");\n+      out.append(\"synchronized \");\n     }\n     if ((modifiers & Modifier.TRANSIENT) != 0) {\n-      out.write(\"transient \");\n+      out.append(\"transient \");\n     }\n     if ((modifiers & Modifier.VOLATILE) != 0) {\n-      out.write(\"volatile \");\n+      out.append(\"volatile \");\n     }\n+    return out;\n   }\n \n   private void indent() throws IOException {\n@@ -575,4 +558,4 @@ final class JavaWriter implements Closeable {\n     ANNOTATION_ATTRIBUTE,\n     ANNOTATION_ARRAY_VALUE,\n   }\n-}\n\\ No newline at end of file\n+}\n"
    },
    {
        "commit_hash": "9384024b1d13d8e5297bcf3c00f230228f5ffebe",
        "previous_commit_hash": "9b4d2d842e152ffb49d42c450be053d8ada4984e",
        "diff_stats": {
            "additions": 4,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,4 @@\n+package com.example;\n+\n+public class Binding<T> {\n+}\n"
    },
    {
        "commit_hash": "9384024b1d13d8e5297bcf3c00f230228f5ffebe",
        "previous_commit_hash": "9b4d2d842e152ffb49d42c450be053d8ada4984e",
        "diff_stats": {
            "additions": 343,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,343 @@\n+/**\n+ * Copyright (C) 2012 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.protoss.schema;\n+\n+import com.example.Binding;\n+import java.io.IOException;\n+import java.io.StringWriter;\n+import java.lang.reflect.Modifier;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import org.junit.Test;\n+\n+import static org.fest.assertions.api.Assertions.assertThat;\n+import static org.junit.Assert.assertEquals;\n+\n+public final class JavaWriterTest {\n+  private final StringWriter stringWriter = new StringWriter();\n+  private final JavaWriter javaWriter = new JavaWriter(stringWriter);\n+\n+  @Test public void typeDeclaration() throws IOException {\n+    javaWriter.emitPackage(\"com.squareup\");\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\", Modifier.PUBLIC | Modifier.FINAL);\n+    javaWriter.endType();\n+    assertCode(\"\"\n+        + \"package com.squareup;\\n\"\n+        + \"public final class Foo {\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void fieldDeclaration() throws IOException {\n+    javaWriter.emitPackage(\"com.squareup\");\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\", 0);\n+    javaWriter.emitField(\"java.lang.String\", \"string\", Modifier.PRIVATE | Modifier.STATIC);\n+    javaWriter.endType();\n+    assertCode(\"\"\n+        + \"package com.squareup;\\n\"\n+        + \"class Foo {\\n\"\n+        + \"  private static String string;\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void fieldDeclarationWithInitialValue() throws IOException {\n+    javaWriter.emitPackage(\"com.squareup\");\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\", 0);\n+    javaWriter.emitField(\"java.lang.String\", \"string\", 0, \"\\\"bar\\\" + \\\"baz\\\"\");\n+    javaWriter.endType();\n+    assertCode(\"\"\n+        + \"package com.squareup;\\n\"\n+        + \"class Foo {\\n\"\n+        + \"  String string = \\\"bar\\\" + \\\"baz\\\";\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void abstractMethodDeclaration() throws IOException {\n+    javaWriter.emitPackage(\"com.squareup\");\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\", 0);\n+    javaWriter.beginMethod(\"java.lang.String\", \"foo\", Modifier.ABSTRACT | Modifier.PUBLIC,\n+        \"java.lang.Object\", \"object\", \"java.lang.String\", \"s\");\n+    javaWriter.endMethod();\n+    javaWriter.endType();\n+    assertCode(\"\"\n+        + \"package com.squareup;\\n\"\n+        + \"class Foo {\\n\"\n+        + \"  public abstract String foo(Object object, String s);\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void nonAbstractMethodDeclaration() throws IOException {\n+    javaWriter.emitPackage(\"com.squareup\");\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\", 0);\n+    javaWriter.beginMethod(\"int\", \"foo\", 0, \"java.lang.String\", \"s\");\n+    javaWriter.endMethod();\n+    javaWriter.endType();\n+    assertCode(\"\"\n+        + \"package com.squareup;\\n\"\n+        + \"class Foo {\\n\"\n+        + \"  int foo(String s) {\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void constructorDeclaration() throws IOException {\n+    javaWriter.emitPackage(\"com.squareup\");\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\", 0);\n+    javaWriter.beginMethod(null, \"com.squareup.Foo\", Modifier.PUBLIC, \"java.lang.String\", \"s\");\n+    javaWriter.endMethod();\n+    javaWriter.endType();\n+    assertCode(\"\"\n+        + \"package com.squareup;\\n\"\n+        + \"class Foo {\\n\"\n+        + \"  public Foo(String s) {\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void statement() throws IOException {\n+    javaWriter.emitPackage(\"com.squareup\");\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\", 0);\n+    javaWriter.beginMethod(\"int\", \"foo\", 0, \"java.lang.String\", \"s\");\n+    javaWriter.emitStatement(\"int j = s.length() + %s\", 13);\n+    javaWriter.endMethod();\n+    javaWriter.endType();\n+    assertCode(\"\"\n+        + \"package com.squareup;\\n\"\n+        + \"class Foo {\\n\"\n+        + \"  int foo(String s) {\\n\"\n+        + \"    int j = s.length() + 13;\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void addImport() throws IOException {\n+    javaWriter.emitPackage(\"com.squareup\");\n+    javaWriter.emitImports(\"java.util.ArrayList\");\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\", Modifier.PUBLIC | Modifier.FINAL);\n+    javaWriter.emitField(\"java.util.ArrayList\", \"list\", 0, \"new java.util.ArrayList()\");\n+    javaWriter.endType();\n+    assertCode(\"\"\n+        + \"package com.squareup;\\n\"\n+        + \"import java.util.ArrayList;\\n\"\n+        + \"\\n\"\n+        + \"public final class Foo {\\n\"\n+        + \"  ArrayList list = new java.util.ArrayList();\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void addImportFromSubpackage() throws IOException {\n+    javaWriter.emitPackage(\"com.squareup\");\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\", Modifier.PUBLIC | Modifier.FINAL);\n+    javaWriter.emitField(\"com.squareup.bar.Baz\", \"baz\", 0);\n+    javaWriter.endType();\n+    assertCode(\"\"\n+        + \"package com.squareup;\\n\"\n+        + \"public final class Foo {\\n\"\n+        + \"  com.squareup.bar.Baz baz;\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void ifControlFlow() throws IOException {\n+    javaWriter.emitPackage(\"com.squareup\");\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\", 0);\n+    javaWriter.beginMethod(\"int\", \"foo\", 0, \"java.lang.String\", \"s\");\n+    javaWriter.beginControlFlow(\"if (s.isEmpty())\");\n+    javaWriter.emitStatement(\"int j = s.length() + %s\", 13);\n+    javaWriter.endControlFlow();\n+    javaWriter.endMethod();\n+    javaWriter.endType();\n+    assertCode(\"\"\n+        + \"package com.squareup;\\n\"\n+        + \"class Foo {\\n\"\n+        + \"  int foo(String s) {\\n\"\n+        + \"    if (s.isEmpty()) {\\n\"\n+        + \"      int j = s.length() + 13;\\n\"\n+        + \"    }\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void doWhileControlFlow() throws IOException {\n+    javaWriter.emitPackage(\"com.squareup\");\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\", 0);\n+    javaWriter.beginMethod(\"int\", \"foo\", 0, \"java.lang.String\", \"s\");\n+    javaWriter.beginControlFlow(\"do\");\n+    javaWriter.emitStatement(\"int j = s.length() + %s\", 13);\n+    javaWriter.endControlFlow(\"while (s.isEmpty())\");\n+    javaWriter.endMethod();\n+    javaWriter.endType();\n+    assertCode(\"\"\n+        + \"package com.squareup;\\n\"\n+        + \"class Foo {\\n\"\n+        + \"  int foo(String s) {\\n\"\n+        + \"    do {\\n\"\n+        + \"      int j = s.length() + 13;\\n\"\n+        + \"    } while (s.isEmpty());\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void tryCatchFinallyControlFlow() throws IOException {\n+    javaWriter.emitPackage(\"com.squareup\");\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\", 0);\n+    javaWriter.beginMethod(\"int\", \"foo\", 0, \"java.lang.String\", \"s\");\n+    javaWriter.beginControlFlow(\"try\");\n+    javaWriter.emitStatement(\"int j = s.length() + %s\", 13);\n+    javaWriter.nextControlFlow(\"catch (RuntimeException e)\");\n+    javaWriter.emitStatement(\"e.printStackTrace()\");\n+    javaWriter.nextControlFlow(\"finally\");\n+    javaWriter.emitStatement(\"int k = %s\", 13);\n+    javaWriter.endControlFlow();\n+    javaWriter.endMethod();\n+    javaWriter.endType();\n+    assertCode(\"\"\n+        + \"package com.squareup;\\n\"\n+        + \"class Foo {\\n\"\n+        + \"  int foo(String s) {\\n\"\n+        + \"    try {\\n\"\n+        + \"      int j = s.length() + 13;\\n\"\n+        + \"    } catch (RuntimeException e) {\\n\"\n+        + \"      e.printStackTrace();\\n\"\n+        + \"    } finally {\\n\"\n+        + \"      int k = 13;\\n\"\n+        + \"    }\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void annotatedType() throws IOException {\n+    javaWriter.emitPackage(\"com.squareup\");\n+    javaWriter.emitImports(\"javax.inject.Singleton\");\n+    javaWriter.emitAnnotation(\"javax.inject.Singleton\");\n+    javaWriter.emitAnnotation(SuppressWarnings.class, JavaWriter.stringLiteral(\"unchecked\"));\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\", 0);\n+    javaWriter.endType();\n+    assertCode(\"\"\n+        + \"package com.squareup;\\n\"\n+        + \"import javax.inject.Singleton;\\n\"\n+        + \"\\n\"\n+        + \"@Singleton\\n\"\n+        + \"@SuppressWarnings(\\\"unchecked\\\")\\n\"\n+        + \"class Foo {\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void annotatedMember() throws IOException {\n+    javaWriter.emitPackage(\"com.squareup\");\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\", 0);\n+    javaWriter.emitAnnotation(Deprecated.class);\n+    javaWriter.emitField(\"java.lang.String\", \"s\", 0);\n+    javaWriter.endType();\n+    assertCode(\"\"\n+        + \"package com.squareup;\\n\"\n+        + \"class Foo {\\n\"\n+        + \"  @Deprecated\\n\"\n+        + \"  String s;\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void annotatedWithAttributes() throws IOException {\n+    Map<String, Object> attributes = new LinkedHashMap<String, Object>();\n+    attributes.put(\"overrides\", true);\n+    attributes.put(\"entryPoints\", new Object[] { \"entryPointA\", \"entryPointB\", \"entryPointC\" });\n+    attributes.put(\"staticInjections\", \"com.squareup.Quux\");\n+\n+    javaWriter.emitPackage(\"com.squareup\");\n+    javaWriter.emitAnnotation(\"Module\", attributes);\n+    javaWriter.beginType(\"com.squareup.FooModule\", \"class\", 0);\n+    javaWriter.endType();\n+    assertCode(\"\"\n+        + \"package com.squareup;\\n\"\n+        + \"@Module(\\n\"\n+        + \"  overrides = true,\\n\"\n+        + \"  entryPoints = {\\n\"\n+        + \"    entryPointA,\\n\"\n+        + \"    entryPointB,\\n\"\n+        + \"    entryPointC\\n\"\n+        + \"  },\\n\"\n+        + \"  staticInjections = com.squareup.Quux\\n\"\n+        + \")\\n\"\n+        + \"class FooModule {\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void parameterizedType() throws IOException {\n+    javaWriter.emitPackage(\"com.squareup\");\n+    javaWriter.emitImports(\"java.util.Map\", \"java.util.Date\");\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\", 0);\n+    javaWriter.emitField(\"java.util.Map<java.lang.String, java.util.Date>\", \"map\", 0);\n+    javaWriter.endType();\n+    assertCode(\"\"\n+        + \"package com.squareup;\\n\"\n+        + \"import java.util.Date;\\n\"\n+        + \"import java.util.Map;\\n\"\n+        + \"\\n\"\n+        + \"class Foo {\\n\"\n+        + \"  Map<String, Date> map;\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void eolComment() throws IOException {\n+    javaWriter.emitEndOfLineComment(\"foo\");\n+    assertCode(\"\"\n+        + \"// foo\\n\");\n+  }\n+\n+  @Test public void javadoc() throws IOException {\n+    javaWriter.emitJavadoc(\"foo\");\n+    assertCode(\"\"\n+        + \"/**\\n\"\n+        + \" * foo\\n\"\n+        + \" */\\n\");\n+  }\n+\n+  @Test public void multilineJavadoc() throws IOException {\n+    javaWriter.emitJavadoc(\"0123456789 0123456789 0123456789 0123456789 0123456789 0123456789\\n\"\n+        + \"0123456789 0123456789 0123456789 0123456789\");\n+    assertCode(\"\"\n+        + \"/**\\n\"\n+        + \" * 0123456789 0123456789 0123456789 0123456789 0123456789 0123456789\\n\"\n+        + \" * 0123456789 0123456789 0123456789 0123456789\\n\"\n+        + \" */\\n\");\n+  }\n+\n+  @Test public void testStringLiteral() {\n+    assertThat(JavaWriter.stringLiteral(\"\")).isEqualTo(\"\\\"\\\"\");\n+    assertThat(JavaWriter.stringLiteral(\"JavaWriter\")).isEqualTo(\"\\\"JavaWriter\\\"\");\n+    assertThat(JavaWriter.stringLiteral(\"\\\\\")).isEqualTo(\"\\\"\\\\\\\\\\\"\");\n+    assertThat(JavaWriter.stringLiteral(\"\\\"\")).isEqualTo(\"\\\"\\\\\\\"\\\"\");\n+    assertThat(JavaWriter.stringLiteral(\"\\t\")).isEqualTo(\"\\\"\\\\\\t\\\"\");\n+    assertThat(JavaWriter.stringLiteral(\"\\n\")).isEqualTo(\"\\\"\\\\\\n\\\"\");\n+  }\n+\n+  @Test public void compressType() throws IOException {\n+    javaWriter.emitPackage(\"blah\");\n+    javaWriter.emitImports(Set.class.getName(), Binding.class.getName());\n+    String actual = javaWriter.compressType(\"java.util.Set<com.example.Binding<blah.Foo.Blah>>\");\n+    assertEquals(\"Set<Binding<Foo.Blah>>\", actual);\n+  }\n+\n+  @Test public void compressDeeperType() throws IOException {\n+    javaWriter.emitPackage(\"blah\");\n+    javaWriter.emitImports(Binding.class.getName());\n+    String actual = javaWriter.compressType(\"com.example.Binding<blah.foo.Foo.Blah>\");\n+    assertEquals(\"Binding<blah.foo.Foo.Blah>\", actual);\n+  }\n+\n+  private void assertCode(String expected) {\n+    assertThat(stringWriter.toString()).isEqualTo(expected);\n+  }\n+}\n"
    },
    {
        "commit_hash": "316a6ceac7a0e07d0ac4093230a2389d6873f284",
        "previous_commit_hash": "d5fad966ac96d672e827ddd174537203a080d0fa",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -13,7 +13,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package com.squareup.protoss.schema;\n+package com.squareup.java;\n \n import java.io.Closeable;\n import java.io.IOException;\n"
    },
    {
        "commit_hash": "316a6ceac7a0e07d0ac4093230a2389d6873f284",
        "previous_commit_hash": "d5fad966ac96d672e827ddd174537203a080d0fa",
        "diff_stats": {
            "additions": 3,
            "deletions": 4
        },
        "diff_content": "@@ -13,7 +13,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package com.squareup.protoss.schema;\n+package com.squareup.java;\n \n import com.example.Binding;\n import java.io.IOException;\n@@ -25,7 +25,6 @@ import java.util.Set;\n import org.junit.Test;\n \n import static org.fest.assertions.api.Assertions.assertThat;\n-import static org.junit.Assert.assertEquals;\n \n public final class JavaWriterTest {\n   private final StringWriter stringWriter = new StringWriter();\n@@ -327,14 +326,14 @@ public final class JavaWriterTest {\n     javaWriter.emitPackage(\"blah\");\n     javaWriter.emitImports(Set.class.getName(), Binding.class.getName());\n     String actual = javaWriter.compressType(\"java.util.Set<com.example.Binding<blah.Foo.Blah>>\");\n-    assertEquals(\"Set<Binding<Foo.Blah>>\", actual);\n+    assertThat(actual).isEqualTo(\"Set<Binding<Foo.Blah>>\");\n   }\n \n   @Test public void compressDeeperType() throws IOException {\n     javaWriter.emitPackage(\"blah\");\n     javaWriter.emitImports(Binding.class.getName());\n     String actual = javaWriter.compressType(\"com.example.Binding<blah.foo.Foo.Blah>\");\n-    assertEquals(\"Binding<blah.foo.Foo.Blah>\", actual);\n+    assertThat(actual).isEqualTo(\"Binding<blah.foo.Foo.Blah>\");\n   }\n \n   private void assertCode(String expected) {\n"
    },
    {
        "commit_hash": "c5b6b36b2e98b59f0711c1bfc8486c32eb3b482a",
        "previous_commit_hash": "316a6ceac7a0e07d0ac4093230a2389d6873f284",
        "diff_stats": {
            "additions": 19,
            "deletions": 1
        },
        "diff_content": "@@ -1,4 +1,22 @@\n JavaWriter\n ==========\n \n-TODO\n\\ No newline at end of file\n+TODO\n+\n+\n+License\n+-------\n+\n+    Copyright 2013 Square, Inc.\n+\n+    Licensed under the Apache License, Version 2.0 (the \"License\");\n+    you may not use this file except in compliance with the License.\n+    You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+    Unless required by applicable law or agreed to in writing, software\n+    distributed under the License is distributed on an \"AS IS\" BASIS,\n+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+    See the License for the specific language governing permissions and\n+    limitations under the License.\n"
    },
    {
        "commit_hash": "c5b6b36b2e98b59f0711c1bfc8486c32eb3b482a",
        "previous_commit_hash": "316a6ceac7a0e07d0ac4093230a2389d6873f284",
        "diff_stats": {
            "additions": 1,
            "deletions": 15
        },
        "diff_content": "@@ -1,18 +1,4 @@\n-/**\n- * Copyright (C) 2012 Square, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n+// Copyright 2013 Square, Inc.\n package com.squareup.java;\n \n import java.io.Closeable;\n"
    },
    {
        "commit_hash": "c5b6b36b2e98b59f0711c1bfc8486c32eb3b482a",
        "previous_commit_hash": "316a6ceac7a0e07d0ac4093230a2389d6873f284",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -1,3 +1,4 @@\n+// Copyright 2013 Square, Inc.\n package com.example;\n \n public class Binding<T> {\n"
    },
    {
        "commit_hash": "c5b6b36b2e98b59f0711c1bfc8486c32eb3b482a",
        "previous_commit_hash": "316a6ceac7a0e07d0ac4093230a2389d6873f284",
        "diff_stats": {
            "additions": 1,
            "deletions": 15
        },
        "diff_content": "@@ -1,18 +1,4 @@\n-/**\n- * Copyright (C) 2012 Square, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n+// Copyright 2013 Square, Inc.\n package com.squareup.java;\n \n import com.example.Binding;\n"
    },
    {
        "commit_hash": "e8cd8f4881897b00043c8114aac7537ab11c4b16",
        "previous_commit_hash": "c5b6b36b2e98b59f0711c1bfc8486c32eb3b482a",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -1,5 +1,5 @@\n-JavaWriter\n-==========\n+JavaSourceWriter\n+================\n \n TODO\n \n"
    },
    {
        "commit_hash": "e8cd8f4881897b00043c8114aac7537ab11c4b16",
        "previous_commit_hash": "c5b6b36b2e98b59f0711c1bfc8486c32eb3b482a",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -18,7 +18,7 @@ import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n /** Emits Java source files. */\n-public final class JavaWriter implements Closeable {\n+public final class JavaSourceWriter implements Closeable {\n   private static final Pattern TYPE_PATTERN = Pattern.compile(\"(?:[\\\\w$]+\\\\.)*([\\\\w$]+)\");\n   private static final String INDENT = \"  \";\n \n@@ -32,7 +32,7 @@ public final class JavaWriter implements Closeable {\n   /**\n    * @param out the stream to which Java source will be written. This should be a buffered stream.\n    */\n-  public JavaWriter(Writer out) {\n+  public JavaSourceWriter(Writer out) {\n     this.out = out;\n   }\n \n"
    },
    {
        "commit_hash": "e8cd8f4881897b00043c8114aac7537ab11c4b16",
        "previous_commit_hash": "c5b6b36b2e98b59f0711c1bfc8486c32eb3b482a",
        "diff_stats": {
            "additions": 10,
            "deletions": 9
        },
        "diff_content": "@@ -12,9 +12,9 @@ import org.junit.Test;\n \n import static org.fest.assertions.api.Assertions.assertThat;\n \n-public final class JavaWriterTest {\n+public final class JavaSourceWriterTest {\n   private final StringWriter stringWriter = new StringWriter();\n-  private final JavaWriter javaWriter = new JavaWriter(stringWriter);\n+  private final JavaSourceWriter javaWriter = new JavaSourceWriter(stringWriter);\n \n   @Test public void typeDeclaration() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n@@ -207,7 +207,8 @@ public final class JavaWriterTest {\n     javaWriter.emitPackage(\"com.squareup\");\n     javaWriter.emitImports(\"javax.inject.Singleton\");\n     javaWriter.emitAnnotation(\"javax.inject.Singleton\");\n-    javaWriter.emitAnnotation(SuppressWarnings.class, JavaWriter.stringLiteral(\"unchecked\"));\n+    javaWriter.emitAnnotation(SuppressWarnings.class,\n+        JavaSourceWriter.stringLiteral(\"unchecked\"));\n     javaWriter.beginType(\"com.squareup.Foo\", \"class\", 0);\n     javaWriter.endType();\n     assertCode(\"\"\n@@ -300,12 +301,12 @@ public final class JavaWriterTest {\n   }\n \n   @Test public void testStringLiteral() {\n-    assertThat(JavaWriter.stringLiteral(\"\")).isEqualTo(\"\\\"\\\"\");\n-    assertThat(JavaWriter.stringLiteral(\"JavaWriter\")).isEqualTo(\"\\\"JavaWriter\\\"\");\n-    assertThat(JavaWriter.stringLiteral(\"\\\\\")).isEqualTo(\"\\\"\\\\\\\\\\\"\");\n-    assertThat(JavaWriter.stringLiteral(\"\\\"\")).isEqualTo(\"\\\"\\\\\\\"\\\"\");\n-    assertThat(JavaWriter.stringLiteral(\"\\t\")).isEqualTo(\"\\\"\\\\\\t\\\"\");\n-    assertThat(JavaWriter.stringLiteral(\"\\n\")).isEqualTo(\"\\\"\\\\\\n\\\"\");\n+    assertThat(JavaSourceWriter.stringLiteral(\"\")).isEqualTo(\"\\\"\\\"\");\n+    assertThat(JavaSourceWriter.stringLiteral(\"JavaWriter\")).isEqualTo(\"\\\"JavaWriter\\\"\");\n+    assertThat(JavaSourceWriter.stringLiteral(\"\\\\\")).isEqualTo(\"\\\"\\\\\\\\\\\"\");\n+    assertThat(JavaSourceWriter.stringLiteral(\"\\\"\")).isEqualTo(\"\\\"\\\\\\\"\\\"\");\n+    assertThat(JavaSourceWriter.stringLiteral(\"\\t\")).isEqualTo(\"\\\"\\\\\\t\\\"\");\n+    assertThat(JavaSourceWriter.stringLiteral(\"\\n\")).isEqualTo(\"\\\"\\\\\\n\\\"\");\n   }\n \n   @Test public void compressType() throws IOException {\n"
    },
    {
        "commit_hash": "aed50f772034c1235482ecc98fb2c9be794a0449",
        "previous_commit_hash": "e8cd8f4881897b00043c8114aac7537ab11c4b16",
        "diff_stats": {
            "additions": 60,
            "deletions": 3
        },
        "diff_content": "@@ -1,7 +1,60 @@\n-JavaSourceWriter\n-================\n+Java Writer\n+===========\n+\n+`JavaWriter` is a utility class which aids in generating Java source files.\n+\n+Source file generation can useful when doing things such as annotation processing or interacting\n+with metadata files (e.g., database schemas, protocol formats). By generating code, you eliminate\n+the need to write boilerplate while also keeping a single source of truth for the metadata.\n+\n+\n+\n+Example\n+-------\n+\n+```java\n+writer.emitPackage(\"com.example\")\n+    .beginType(\"com.example.Person\", \"class\", PUBLIC | FINAL)\n+    .emitField(\"String\", \"firstName\", PRIVATE)\n+    .emitField(\"String\", \"lastName\", PRIVATE)\n+    .emitJavadoc(\"Returns the person's full name.\")\n+    .beginMethod(\"String\", \"getName\", PUBLIC)\n+    .emitStatement(\"return firstName + \\\" \\\" + lastName;\")\n+    .endMethod()\n+    .endType();\n+```\n+\n+Would produce the following source output:\n+\n+```java\n+package com.example;\n+public final class Person {\n+  private String firstName;\n+  private String lastName;\n+  /**\n+   * Returns the person's full name.\n+   */\n+  public String getName() {\n+    return firstName + \" \" + lastName;;\n+  }\n+}\n+```\n+\n+\n+\n+Download\n+--------\n+\n+Download [the latest .jar][dl] or depend via Maven:\n+\n+```xml\n+<dependency>\n+  <groupId>com.squareup</groupId>\n+  <artifactId>javawriter</artifactId>\n+  <version>(insert latest version)</version>\n+</dependency>\n+```\n \n-TODO\n \n \n License\n@@ -20,3 +73,7 @@ License\n     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     See the License for the specific language governing permissions and\n     limitations under the License.\n+\n+\n+\n+ [dl]: http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=com.squareup&a=javawriter&v=LATEST\n"
    },
    {
        "commit_hash": "aed50f772034c1235482ecc98fb2c9be794a0449",
        "previous_commit_hash": "e8cd8f4881897b00043c8114aac7537ab11c4b16",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -14,7 +14,7 @@\n   <version>1.0.0-SNAPSHOT</version>\n \n   <name>JavaWriter</name>\n-  <description>Emits Java source files.</description>\n+  <description>A utility class which aids in generating Java source files.</description>\n   <url>http://github.com/square/javawriter/</url>\n \n   <properties>\n"
    },
    {
        "commit_hash": "aed50f772034c1235482ecc98fb2c9be794a0449",
        "previous_commit_hash": "e8cd8f4881897b00043c8114aac7537ab11c4b16",
        "diff_stats": {
            "additions": 56,
            "deletions": 37
        },
        "diff_content": "@@ -17,8 +17,8 @@ import java.util.TreeSet;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n-/** Emits Java source files. */\n-public final class JavaSourceWriter implements Closeable {\n+/** A utility class which aids in generating Java source files. */\n+public final class JavaWriter implements Closeable {\n   private static final Pattern TYPE_PATTERN = Pattern.compile(\"(?:[\\\\w$]+\\\\.)*([\\\\w$]+)\");\n   private static final String INDENT = \"  \";\n \n@@ -32,12 +32,12 @@ public final class JavaSourceWriter implements Closeable {\n   /**\n    * @param out the stream to which Java source will be written. This should be a buffered stream.\n    */\n-  public JavaSourceWriter(Writer out) {\n+  public JavaWriter(Writer out) {\n     this.out = out;\n   }\n \n   /** Emit a package declaration. */\n-  public void emitPackage(String packageName) throws IOException {\n+  public JavaWriter emitPackage(String packageName) throws IOException {\n     if (this.packagePrefix != null) {\n       throw new IllegalStateException();\n     }\n@@ -49,21 +49,22 @@ public final class JavaSourceWriter implements Closeable {\n       out.write(\";\\n\");\n       this.packagePrefix = packageName + \".\";\n     }\n+    return this;\n   }\n \n   /**\n    * Emit an import for each {@code type} provided. For the duration of the file, all references to\n    * these classes will be automatically shortened.\n    */\n-  public void emitImports(String... types) throws IOException {\n-    emitImports(Arrays.asList(types));\n+  public JavaWriter emitImports(String... types) throws IOException {\n+    return emitImports(Arrays.asList(types));\n   }\n \n   /**\n    * Emit an import for each {@code type} in the provided {@code Collection}. For the duration of\n    * the file, all references to these classes will be automatically shortened.\n    */\n-  public void emitImports(Collection<String> types) throws IOException {\n+  public JavaWriter emitImports(Collection<String> types) throws IOException {\n     for (String type : new TreeSet<String>(types)) {\n       Matcher matcher = TYPE_PATTERN.matcher(type);\n       if (!matcher.matches()) {\n@@ -77,14 +78,16 @@ public final class JavaSourceWriter implements Closeable {\n       out.write(\";\\n\");\n     }\n     emitEmptyLine();\n+    return this;\n   }\n \n   /**\n    * Emits a name like {@code java.lang.String} or {@code java.util.List<java.lang.String>},\n    * shorting it with imports if possible.\n    */\n-  private void emitType(String type) throws IOException {\n+  private JavaWriter emitType(String type) throws IOException {\n     out.write(compressType(type));\n+    return this;\n   }\n \n   String compressType(String type) {\n@@ -141,8 +144,8 @@ public final class JavaSourceWriter implements Closeable {\n    *\n    * @param kind such as \"class\", \"interface\" or \"enum\".\n    */\n-  public void beginType(String type, String kind, int modifiers) throws IOException {\n-    beginType(type, kind, modifiers, null);\n+  public JavaWriter beginType(String type, String kind, int modifiers) throws IOException {\n+    return beginType(type, kind, modifiers, null);\n   }\n \n   /**\n@@ -151,7 +154,7 @@ public final class JavaSourceWriter implements Closeable {\n    * @param kind such as \"class\", \"interface\" or \"enum\".\n    * @param extendsType the class to extend, or null for no extends clause.\n    */\n-  public void beginType(String type, String kind, int modifiers, String extendsType,\n+  public JavaWriter beginType(String type, String kind, int modifiers, String extendsType,\n       String... implementsTypes) throws IOException {\n     indent();\n     out.write(modifiers(modifiers).toString());\n@@ -175,21 +178,23 @@ public final class JavaSourceWriter implements Closeable {\n     }\n     out.write(\" {\\n\");\n     pushScope(Scope.TYPE_DECLARATION);\n+    return this;\n   }\n \n   /** Completes the current type declaration. */\n-  public void endType() throws IOException {\n+  public JavaWriter endType() throws IOException {\n     popScope(Scope.TYPE_DECLARATION);\n     indent();\n     out.write(\"}\\n\");\n+    return this;\n   }\n \n   /** Emits a field declaration. */\n-  public void emitField(String type, String name, int modifiers) throws IOException {\n-    emitField(type, name, modifiers, null);\n+  public JavaWriter emitField(String type, String name, int modifiers) throws IOException {\n+    return emitField(type, name, modifiers, null);\n   }\n \n-  public void emitField(String type, String name, int modifiers, String initialValue)\n+  public JavaWriter emitField(String type, String name, int modifiers, String initialValue)\n       throws IOException {\n     indent();\n     out.write(modifiers(modifiers).toString());\n@@ -202,16 +207,17 @@ public final class JavaSourceWriter implements Closeable {\n       out.write(initialValue);\n     }\n     out.write(\";\\n\");\n+    return this;\n   }\n \n   /**\n    * Emit a method declaration.\n    *\n    * @param returnType the method's return type, or null for constructors.\n-   * @param parameters alternating parameter types and names.\n    * @param name the method name, or the fully qualified class name for constructors.\n+   * @param parameters alternating parameter types and names.\n    */\n-  public void beginMethod(String returnType, String name, int modifiers, String... parameters)\n+  public JavaWriter beginMethod(String returnType, String name, int modifiers, String... parameters)\n       throws IOException {\n     indent();\n     out.write(modifiers(modifiers).toString());\n@@ -239,10 +245,11 @@ public final class JavaSourceWriter implements Closeable {\n       out.write(\" {\\n\");\n       pushScope(Scope.NON_ABSTRACT_METHOD);\n     }\n+    return this;\n   }\n \n   /** Emits some Javadoc comments with line separated by {@code \\n}. */\n-  public void emitJavadoc(String javadoc, Object... params) throws IOException {\n+  public JavaWriter emitJavadoc(String javadoc, Object... params) throws IOException {\n     String formatted = String.format(javadoc, params);\n     indent();\n     out.write(\"/**\\n\");\n@@ -254,27 +261,30 @@ public final class JavaSourceWriter implements Closeable {\n     }\n     indent();\n     out.write(\" */\\n\");\n+    return this;\n   }\n \n   /** Emits some Javadoc comments. */\n-  public void emitEndOfLineComment(String comment) throws IOException {\n+  public JavaWriter emitEndOfLineComment(String comment) throws IOException {\n     out.write(\"// \");\n     out.write(comment);\n     out.write(\"\\n\");\n+    return this;\n   }\n \n-  public void emitEmptyLine() throws IOException {\n+  public JavaWriter emitEmptyLine() throws IOException {\n     out.write(\"\\n\");\n+    return this;\n   }\n \n   /** Equivalent to {@code annotation(annotation, emptyMap())}. */\n-  public void emitAnnotation(String annotation) throws IOException {\n-    emitAnnotation(annotation, Collections.<String, Object>emptyMap());\n+  public JavaWriter emitAnnotation(String annotation) throws IOException {\n+    return emitAnnotation(annotation, Collections.<String, Object>emptyMap());\n   }\n \n   /** Equivalent to {@code annotation(annotationType.getName(), emptyMap())}. */\n-  public void emitAnnotation(Class<? extends Annotation> annotationType) throws IOException {\n-    emitAnnotation(annotationType.getName(), Collections.<String, Object>emptyMap());\n+  public JavaWriter emitAnnotation(Class<? extends Annotation> annotationType) throws IOException {\n+    return emitAnnotation(annotationType.getName(), Collections.<String, Object>emptyMap());\n   }\n \n   /**\n@@ -284,7 +294,7 @@ public final class JavaSourceWriter implements Closeable {\n    *     be encoded using Object.toString(); use {@link #stringLiteral} for String values. Object\n    *     arrays are written one element per line.\n    */\n-  public void emitAnnotation(Class<? extends Annotation> annotation, Object value)\n+  public JavaWriter emitAnnotation(Class<? extends Annotation> annotation, Object value)\n       throws IOException {\n     indent();\n     out.write(\"@\");\n@@ -293,12 +303,13 @@ public final class JavaSourceWriter implements Closeable {\n     emitAnnotationValue(value);\n     out.write(\")\");\n     out.write(\"\\n\");\n+    return this;\n   }\n \n   /** Equivalent to {@code annotation(annotationType.getName(), attributes)}. */\n-  public void emitAnnotation(Class<? extends Annotation> annotationType, Map<String, ?> attributes)\n-      throws IOException {\n-    emitAnnotation(annotationType.getName(), attributes);\n+  public JavaWriter emitAnnotation(Class<? extends Annotation> annotationType,\n+      Map<String, ?> attributes) throws IOException {\n+    return emitAnnotation(annotationType.getName(), attributes);\n   }\n \n   /**\n@@ -308,7 +319,8 @@ public final class JavaSourceWriter implements Closeable {\n    *     using Object.toString(); use {@link #stringLiteral} for String values. Object arrays are\n    *     written one element per line.\n    */\n-  public void emitAnnotation(String annotation, Map<String, ?> attributes) throws IOException {\n+  public JavaWriter emitAnnotation(String annotation, Map<String, ?> attributes)\n+      throws IOException {\n     indent();\n     out.write(\"@\");\n     emitType(annotation);\n@@ -335,13 +347,14 @@ public final class JavaSourceWriter implements Closeable {\n       out.write(\")\");\n     }\n     out.write(\"\\n\");\n+    return this;\n   }\n \n   /**\n    * Writes a single annotation value. If the value is an array, each element in the array will be\n    * written to its own line.\n    */\n-  private void emitAnnotationValue(Object value) throws IOException {\n+  private JavaWriter emitAnnotationValue(Object value) throws IOException {\n     if (value instanceof Object[]) {\n       out.write(\"{\");\n       boolean firstValue = true;\n@@ -363,53 +376,57 @@ public final class JavaSourceWriter implements Closeable {\n     } else {\n       out.write(value.toString());\n     }\n+    return this;\n   }\n \n   /**\n    * @param pattern a code pattern like \"int i = %s\". Shouldn't contain a trailing semicolon or\n    *     newline character.\n    */\n-  public void emitStatement(String pattern, Object... args) throws IOException {\n+  public JavaWriter emitStatement(String pattern, Object... args) throws IOException {\n     checkInMethod();\n     indent();\n     out.write(String.format(pattern, args));\n     out.write(\";\\n\");\n+    return this;\n   }\n \n   /**\n    * @param controlFlow the control flow construct and its code, such as \"if (foo == 5)\". Shouldn't\n    *     contain braces or newline characters.\n    */\n-  public void beginControlFlow(String controlFlow) throws IOException {\n+  public JavaWriter beginControlFlow(String controlFlow) throws IOException {\n     checkInMethod();\n     indent();\n     out.write(controlFlow);\n     out.write(\" {\\n\");\n     pushScope(Scope.CONTROL_FLOW);\n+    return this;\n   }\n \n   /**\n    * @param controlFlow the control flow construct and its code, such as \"else if (foo == 10)\".\n    *     Shouldn't contain braces or newline characters.\n    */\n-  public void nextControlFlow(String controlFlow) throws IOException {\n+  public JavaWriter nextControlFlow(String controlFlow) throws IOException {\n     popScope(Scope.CONTROL_FLOW);\n     indent();\n     pushScope(Scope.CONTROL_FLOW);\n     out.write(\"} \");\n     out.write(controlFlow);\n     out.write(\" {\\n\");\n+    return this;\n   }\n \n-  public void endControlFlow() throws IOException {\n-    endControlFlow(null);\n+  public JavaWriter endControlFlow() throws IOException {\n+    return endControlFlow(null);\n   }\n \n   /**\n    * @param controlFlow the optional control flow construct and its code, such as\n    *     \"while(foo == 20)\". Only used for \"do/while\" control flows.\n    */\n-  public void endControlFlow(String controlFlow) throws IOException {\n+  public JavaWriter endControlFlow(String controlFlow) throws IOException {\n     popScope(Scope.CONTROL_FLOW);\n     indent();\n     if (controlFlow != null) {\n@@ -419,10 +436,11 @@ public final class JavaSourceWriter implements Closeable {\n     } else {\n       out.write(\"}\\n\");\n     }\n+    return this;\n   }\n \n   /** Completes the current method declaration. */\n-  public void endMethod() throws IOException {\n+  public JavaWriter endMethod() throws IOException {\n     Scope popped = popScope();\n     if (popped == Scope.NON_ABSTRACT_METHOD) {\n       indent();\n@@ -430,6 +448,7 @@ public final class JavaSourceWriter implements Closeable {\n     } else if (popped != Scope.ABSTRACT_METHOD) {\n       throw new IllegalStateException();\n     }\n+    return this;\n   }\n \n   /** Returns the string literal representing {@code data}, including wrapping quotes. */\n"
    },
    {
        "commit_hash": "aed50f772034c1235482ecc98fb2c9be794a0449",
        "previous_commit_hash": "e8cd8f4881897b00043c8114aac7537ab11c4b16",
        "diff_stats": {
            "additions": 9,
            "deletions": 9
        },
        "diff_content": "@@ -12,9 +12,9 @@ import org.junit.Test;\n \n import static org.fest.assertions.api.Assertions.assertThat;\n \n-public final class JavaSourceWriterTest {\n+public final class JavaWriterTest {\n   private final StringWriter stringWriter = new StringWriter();\n-  private final JavaSourceWriter javaWriter = new JavaSourceWriter(stringWriter);\n+  private final JavaWriter javaWriter = new JavaWriter(stringWriter);\n \n   @Test public void typeDeclaration() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n@@ -208,7 +208,7 @@ public final class JavaSourceWriterTest {\n     javaWriter.emitImports(\"javax.inject.Singleton\");\n     javaWriter.emitAnnotation(\"javax.inject.Singleton\");\n     javaWriter.emitAnnotation(SuppressWarnings.class,\n-        JavaSourceWriter.stringLiteral(\"unchecked\"));\n+        JavaWriter.stringLiteral(\"unchecked\"));\n     javaWriter.beginType(\"com.squareup.Foo\", \"class\", 0);\n     javaWriter.endType();\n     assertCode(\"\"\n@@ -301,12 +301,12 @@ public final class JavaSourceWriterTest {\n   }\n \n   @Test public void testStringLiteral() {\n-    assertThat(JavaSourceWriter.stringLiteral(\"\")).isEqualTo(\"\\\"\\\"\");\n-    assertThat(JavaSourceWriter.stringLiteral(\"JavaWriter\")).isEqualTo(\"\\\"JavaWriter\\\"\");\n-    assertThat(JavaSourceWriter.stringLiteral(\"\\\\\")).isEqualTo(\"\\\"\\\\\\\\\\\"\");\n-    assertThat(JavaSourceWriter.stringLiteral(\"\\\"\")).isEqualTo(\"\\\"\\\\\\\"\\\"\");\n-    assertThat(JavaSourceWriter.stringLiteral(\"\\t\")).isEqualTo(\"\\\"\\\\\\t\\\"\");\n-    assertThat(JavaSourceWriter.stringLiteral(\"\\n\")).isEqualTo(\"\\\"\\\\\\n\\\"\");\n+    assertThat(JavaWriter.stringLiteral(\"\")).isEqualTo(\"\\\"\\\"\");\n+    assertThat(JavaWriter.stringLiteral(\"JavaWriter\")).isEqualTo(\"\\\"JavaWriter\\\"\");\n+    assertThat(JavaWriter.stringLiteral(\"\\\\\")).isEqualTo(\"\\\"\\\\\\\\\\\"\");\n+    assertThat(JavaWriter.stringLiteral(\"\\\"\")).isEqualTo(\"\\\"\\\\\\\"\\\"\");\n+    assertThat(JavaWriter.stringLiteral(\"\\t\")).isEqualTo(\"\\\"\\\\\\t\\\"\");\n+    assertThat(JavaWriter.stringLiteral(\"\\n\")).isEqualTo(\"\\\"\\\\\\n\\\"\");\n   }\n \n   @Test public void compressType() throws IOException {\n"
    },
    {
        "commit_hash": "6ec8762202ac97e62387dcfb2aa86104befb60de",
        "previous_commit_hash": "d228e891117d8b8358f952bf382013e6d7e43655",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -265,9 +265,9 @@ public final class JavaWriter implements Closeable {\n   }\n \n   /** Emits some Javadoc comments. */\n-  public JavaWriter emitEndOfLineComment(String comment) throws IOException {\n+  public JavaWriter emitEndOfLineComment(String comment, Object... args) throws IOException {\n     out.write(\"// \");\n-    out.write(comment);\n+    out.write(String.format(comment, args));\n     out.write(\"\\n\");\n     return this;\n   }\n"
    },
    {
        "commit_hash": "734c93e52e9b513afbfe018eb4506c0f18ae9312",
        "previous_commit_hash": "6ec8762202ac97e62387dcfb2aa86104befb60de",
        "diff_stats": {
            "additions": 40,
            "deletions": 10
        },
        "diff_content": "@@ -36,7 +36,7 @@ public final class JavaWriter implements Closeable {\n     this.out = out;\n   }\n \n-  /** Emit a package declaration. */\n+  /** Emit a package declaration and empty line. */\n   public JavaWriter emitPackage(String packageName) throws IOException {\n     if (this.packagePrefix != null) {\n       throw new IllegalStateException();\n@@ -46,7 +46,7 @@ public final class JavaWriter implements Closeable {\n     } else {\n       out.write(\"package \");\n       out.write(packageName);\n-      out.write(\";\\n\");\n+      out.write(\";\\n\\n\");\n       this.packagePrefix = packageName + \".\";\n     }\n     return this;\n@@ -77,7 +77,6 @@ public final class JavaWriter implements Closeable {\n       out.write(type);\n       out.write(\";\\n\");\n     }\n-    emitEmptyLine();\n     return this;\n   }\n \n@@ -251,6 +250,7 @@ public final class JavaWriter implements Closeable {\n   /** Emits some Javadoc comments with line separated by {@code \\n}. */\n   public JavaWriter emitJavadoc(String javadoc, Object... params) throws IOException {\n     String formatted = String.format(javadoc, params);\n+\n     indent();\n     out.write(\"/**\\n\");\n     for (String line : formatted.split(\"\\n\")) {\n@@ -277,6 +277,13 @@ public final class JavaWriter implements Closeable {\n     return this;\n   }\n \n+  public JavaWriter emitEnumValue(String name) throws IOException {\n+    indent();\n+    out.write(name);\n+    out.write(\",\\n\");\n+    return this;\n+  }\n+\n   /** Equivalent to {@code annotation(annotation, emptyMap())}. */\n   public JavaWriter emitAnnotation(String annotation) throws IOException {\n     return emitAnnotation(annotation, Collections.<String, Object>emptyMap());\n@@ -288,17 +295,28 @@ public final class JavaWriter implements Closeable {\n   }\n \n   /**\n-   * Annotates the next element with {@code annotation} and a {@code value}.\n+   * Annotates the next element with {@code annotationType} and a {@code value}.\n    *\n    * @param value an object used as the default (value) parameter of the annotation. The value will\n    *     be encoded using Object.toString(); use {@link #stringLiteral} for String values. Object\n    *     arrays are written one element per line.\n    */\n-  public JavaWriter emitAnnotation(Class<? extends Annotation> annotation, Object value)\n+  public JavaWriter emitAnnotation(Class<? extends Annotation> annotationType, Object value)\n       throws IOException {\n+    return emitAnnotation(annotationType.getName(), value);\n+  }\n+\n+  /**\n+   * Annotates the next element with {@code annotation} and a {@code value}.\n+   *\n+   * @param value an object used as the default (value) parameter of the annotation. The value will\n+   *     be encoded using Object.toString(); use {@link #stringLiteral} for String values. Object\n+   *     arrays are written one element per line.\n+   */\n+  public JavaWriter emitAnnotation(String annotation, Object value) throws IOException {\n     indent();\n     out.write(\"@\");\n-    emitType(annotation.getName());\n+    emitType(annotation);\n     out.write(\"(\");\n     emitAnnotationValue(value);\n     out.write(\")\");\n@@ -380,13 +398,19 @@ public final class JavaWriter implements Closeable {\n   }\n \n   /**\n-   * @param pattern a code pattern like \"int i = %s\". Shouldn't contain a trailing semicolon or\n-   *     newline character.\n+   * @param pattern a code pattern like \"int i = %s\". Newlines will be further indented. Should not\n+   *     contain trailing semicolon.\n    */\n   public JavaWriter emitStatement(String pattern, Object... args) throws IOException {\n     checkInMethod();\n+    String[] lines = String.format(pattern, args).split(\"\\n\", -1);\n     indent();\n-    out.write(String.format(pattern, args));\n+    out.write(lines[0]);\n+    for (int i = 1; i < lines.length; i++) {\n+      out.write(\"\\n\");\n+      hangingIndent();\n+      out.write(lines[i]);\n+    }\n     out.write(\";\\n\");\n     return this;\n   }\n@@ -525,7 +549,13 @@ public final class JavaWriter implements Closeable {\n   }\n \n   private void indent() throws IOException {\n-    for (int i = 0; i < scopes.size(); i++) {\n+    for (int i = 0, count = scopes.size(); i < count; i++) {\n+      out.write(INDENT);\n+    }\n+  }\n+\n+  private void hangingIndent() throws IOException {\n+    for (int i = 0, count = scopes.size() + 2; i < count; i++) {\n       out.write(INDENT);\n     }\n   }\n"
    },
    {
        "commit_hash": "734c93e52e9b513afbfe018eb4506c0f18ae9312",
        "previous_commit_hash": "6ec8762202ac97e62387dcfb2aa86104befb60de",
        "diff_stats": {
            "additions": 64,
            "deletions": 3
        },
        "diff_content": "@@ -5,6 +5,7 @@ import com.example.Binding;\n import java.io.IOException;\n import java.io.StringWriter;\n import java.lang.reflect.Modifier;\n+import java.util.Collections;\n import java.util.LinkedHashMap;\n import java.util.Map;\n import java.util.Set;\n@@ -22,10 +23,26 @@ public final class JavaWriterTest {\n     javaWriter.endType();\n     assertCode(\"\"\n         + \"package com.squareup;\\n\"\n+        + \"\\n\"\n         + \"public final class Foo {\\n\"\n         + \"}\\n\");\n   }\n \n+  @Test public void enumDeclaration() throws IOException {\n+    javaWriter.emitPackage(\"com.squareup\");\n+    javaWriter.beginType(\"com.squareup.Foo\", \"enum\", Modifier.PUBLIC);\n+    javaWriter.emitEnumValue(\"BAR\");\n+    javaWriter.emitEnumValue(\"BAZ\");\n+    javaWriter.endType();\n+    assertCode(\"\"\n+        + \"package com.squareup;\\n\"\n+        + \"\\n\"\n+        + \"public enum Foo {\\n\"\n+        + \"  BAR,\\n\"\n+        + \"  BAZ,\\n\"\n+        + \"}\\n\");\n+  }\n+\n   @Test public void fieldDeclaration() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n     javaWriter.beginType(\"com.squareup.Foo\", \"class\", 0);\n@@ -33,6 +50,7 @@ public final class JavaWriterTest {\n     javaWriter.endType();\n     assertCode(\"\"\n         + \"package com.squareup;\\n\"\n+        + \"\\n\"\n         + \"class Foo {\\n\"\n         + \"  private static String string;\\n\"\n         + \"}\\n\");\n@@ -45,6 +63,7 @@ public final class JavaWriterTest {\n     javaWriter.endType();\n     assertCode(\"\"\n         + \"package com.squareup;\\n\"\n+        + \"\\n\"\n         + \"class Foo {\\n\"\n         + \"  String string = \\\"bar\\\" + \\\"baz\\\";\\n\"\n         + \"}\\n\");\n@@ -59,6 +78,7 @@ public final class JavaWriterTest {\n     javaWriter.endType();\n     assertCode(\"\"\n         + \"package com.squareup;\\n\"\n+        + \"\\n\"\n         + \"class Foo {\\n\"\n         + \"  public abstract String foo(Object object, String s);\\n\"\n         + \"}\\n\");\n@@ -72,6 +92,7 @@ public final class JavaWriterTest {\n     javaWriter.endType();\n     assertCode(\"\"\n         + \"package com.squareup;\\n\"\n+        + \"\\n\"\n         + \"class Foo {\\n\"\n         + \"  int foo(String s) {\\n\"\n         + \"  }\\n\"\n@@ -86,6 +107,7 @@ public final class JavaWriterTest {\n     javaWriter.endType();\n     assertCode(\"\"\n         + \"package com.squareup;\\n\"\n+        + \"\\n\"\n         + \"class Foo {\\n\"\n         + \"  public Foo(String s) {\\n\"\n         + \"  }\\n\"\n@@ -101,6 +123,7 @@ public final class JavaWriterTest {\n     javaWriter.endType();\n     assertCode(\"\"\n         + \"package com.squareup;\\n\"\n+        + \"\\n\"\n         + \"class Foo {\\n\"\n         + \"  int foo(String s) {\\n\"\n         + \"    int j = s.length() + 13;\\n\"\n@@ -108,6 +131,26 @@ public final class JavaWriterTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void multiLineStatement() throws IOException {\n+    javaWriter.emitPackage(\"com.squareup\");\n+    javaWriter.beginType(\"com.squareup.Triangle\", \"class\", 0);\n+    javaWriter.beginMethod(\"double\", \"pythagorean\", 0, \"int\", \"a\", \"int\", \"b\");\n+    javaWriter.emitStatement(\"int cSquared = a * a\\n+ b * b\");\n+    javaWriter.emitStatement(\"return Math.sqrt(cSquared)\");\n+    javaWriter.endMethod();\n+    javaWriter.endType();\n+    assertCode(\"\"\n+        + \"package com.squareup;\\n\"\n+        + \"\\n\"\n+        + \"class Triangle {\\n\"\n+        + \"  double pythagorean(int a, int b) {\\n\"\n+        + \"    int cSquared = a * a\\n\"\n+        + \"        + b * b;\\n\"\n+        + \"    return Math.sqrt(cSquared);\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n   @Test public void addImport() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n     javaWriter.emitImports(\"java.util.ArrayList\");\n@@ -116,13 +159,25 @@ public final class JavaWriterTest {\n     javaWriter.endType();\n     assertCode(\"\"\n         + \"package com.squareup;\\n\"\n-        + \"import java.util.ArrayList;\\n\"\n         + \"\\n\"\n+        + \"import java.util.ArrayList;\\n\"\n         + \"public final class Foo {\\n\"\n         + \"  ArrayList list = new java.util.ArrayList();\\n\"\n         + \"}\\n\");\n   }\n \n+  @Test public void emptyImports() throws IOException {\n+    javaWriter.emitPackage(\"com.squareup\");\n+    javaWriter.emitImports(Collections.<String>emptyList());\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\", Modifier.PUBLIC | Modifier.FINAL);\n+    javaWriter.endType();\n+    assertCode(\"\"\n+        + \"package com.squareup;\\n\"\n+        + \"\\n\"\n+        + \"public final class Foo {\\n\"\n+        + \"}\\n\");\n+  }\n+\n   @Test public void addImportFromSubpackage() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n     javaWriter.beginType(\"com.squareup.Foo\", \"class\", Modifier.PUBLIC | Modifier.FINAL);\n@@ -130,6 +185,7 @@ public final class JavaWriterTest {\n     javaWriter.endType();\n     assertCode(\"\"\n         + \"package com.squareup;\\n\"\n+        + \"\\n\"\n         + \"public final class Foo {\\n\"\n         + \"  com.squareup.bar.Baz baz;\\n\"\n         + \"}\\n\");\n@@ -146,6 +202,7 @@ public final class JavaWriterTest {\n     javaWriter.endType();\n     assertCode(\"\"\n         + \"package com.squareup;\\n\"\n+        + \"\\n\"\n         + \"class Foo {\\n\"\n         + \"  int foo(String s) {\\n\"\n         + \"    if (s.isEmpty()) {\\n\"\n@@ -166,6 +223,7 @@ public final class JavaWriterTest {\n     javaWriter.endType();\n     assertCode(\"\"\n         + \"package com.squareup;\\n\"\n+        + \"\\n\"\n         + \"class Foo {\\n\"\n         + \"  int foo(String s) {\\n\"\n         + \"    do {\\n\"\n@@ -190,6 +248,7 @@ public final class JavaWriterTest {\n     javaWriter.endType();\n     assertCode(\"\"\n         + \"package com.squareup;\\n\"\n+        + \"\\n\"\n         + \"class Foo {\\n\"\n         + \"  int foo(String s) {\\n\"\n         + \"    try {\\n\"\n@@ -213,8 +272,8 @@ public final class JavaWriterTest {\n     javaWriter.endType();\n     assertCode(\"\"\n         + \"package com.squareup;\\n\"\n-        + \"import javax.inject.Singleton;\\n\"\n         + \"\\n\"\n+        + \"import javax.inject.Singleton;\\n\"\n         + \"@Singleton\\n\"\n         + \"@SuppressWarnings(\\\"unchecked\\\")\\n\"\n         + \"class Foo {\\n\"\n@@ -229,6 +288,7 @@ public final class JavaWriterTest {\n     javaWriter.endType();\n     assertCode(\"\"\n         + \"package com.squareup;\\n\"\n+        + \"\\n\"\n         + \"class Foo {\\n\"\n         + \"  @Deprecated\\n\"\n         + \"  String s;\\n\"\n@@ -247,6 +307,7 @@ public final class JavaWriterTest {\n     javaWriter.endType();\n     assertCode(\"\"\n         + \"package com.squareup;\\n\"\n+        + \"\\n\"\n         + \"@Module(\\n\"\n         + \"  overrides = true,\\n\"\n         + \"  entryPoints = {\\n\"\n@@ -268,9 +329,9 @@ public final class JavaWriterTest {\n     javaWriter.endType();\n     assertCode(\"\"\n         + \"package com.squareup;\\n\"\n+        + \"\\n\"\n         + \"import java.util.Date;\\n\"\n         + \"import java.util.Map;\\n\"\n-        + \"\\n\"\n         + \"class Foo {\\n\"\n         + \"  Map<String, Date> map;\\n\"\n         + \"}\\n\");\n"
    },
    {
        "commit_hash": "1b5bd192baac07362725fdb73d832ea04cea67b8",
        "previous_commit_hash": "6ec8762202ac97e62387dcfb2aa86104befb60de",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -28,6 +28,7 @@ Would produce the following source output:\n \n ```java\n package com.example;\n+\n public final class Person {\n   private String firstName;\n   private String lastName;\n"
    },
    {
        "commit_hash": "fc8f965e74abe05127db47a97d4f257473b22300",
        "previous_commit_hash": "cab48e38358b092cdeeff6918ecae6b5f51ae4b9",
        "diff_stats": {
            "additions": 2,
            "deletions": 1
        },
        "diff_content": "@@ -1,7 +1,7 @@\n Change Log\n ==========\n \n-Version 1.0.0 *(In Development)*\n---------------------------------\n+Version 1.0.0 *(02-01-2013)*\n+----------------------------\n \n Initial release.\n"
    },
    {
        "commit_hash": "5659e780ea81ab236a36f3285bdd35d1b61801d0",
        "previous_commit_hash": "fc8f965e74abe05127db47a97d4f257473b22300",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javawriter</artifactId>\n-  <version>1.0.0-SNAPSHOT</version>\n+  <version>1.0.0</version>\n \n   <name>JavaWriter</name>\n   <description>A utility class which aids in generating Java source files.</description>\n"
    },
    {
        "commit_hash": "1f713bf474977ce1dc6793d58c7a5c577bdb72f9",
        "previous_commit_hash": "5659e780ea81ab236a36f3285bdd35d1b61801d0",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javawriter</artifactId>\n-  <version>1.0.0</version>\n+  <version>1.0.1-SNAPSHOT</version>\n \n   <name>JavaWriter</name>\n   <description>A utility class which aids in generating Java source files.</description>\n"
    },
    {
        "commit_hash": "a8dc7c680065fc0a7de9ccfec9d50a378c789184",
        "previous_commit_hash": "1f713bf474977ce1dc6793d58c7a5c577bdb72f9",
        "diff_stats": {
            "additions": 6,
            "deletions": 0
        },
        "diff_content": "@@ -1,6 +1,12 @@\n Change Log\n ==========\n \n+Version 1.0.1 *(In Development)*\n+--------------------------------\n+\n+ * Expose `compressType` API.\n+\n+\n Version 1.0.0 *(02-01-2013)*\n ----------------------------\n \n"
    },
    {
        "commit_hash": "a8dc7c680065fc0a7de9ccfec9d50a378c789184",
        "previous_commit_hash": "1f713bf474977ce1dc6793d58c7a5c577bdb72f9",
        "diff_stats": {
            "additions": 3,
            "deletions": 2
        },
        "diff_content": "@@ -89,8 +89,9 @@ public final class JavaWriter implements Closeable {\n     return this;\n   }\n \n-  String compressType(String type) {\n-    StringBuffer sb = new StringBuffer();\n+  /** Try to compress a fully-qualified class name to only the class name. */\n+  public String compressType(String type) {\n+    StringBuilder sb = new StringBuilder();\n     if (this.packagePrefix == null) {\n       throw new IllegalStateException();\n     }\n"
    },
    {
        "commit_hash": "a8dc7c680065fc0a7de9ccfec9d50a378c789184",
        "previous_commit_hash": "1f713bf474977ce1dc6793d58c7a5c577bdb72f9",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -372,14 +372,14 @@ public final class JavaWriterTest {\n \n   @Test public void compressType() throws IOException {\n     javaWriter.emitPackage(\"blah\");\n-    javaWriter.emitImports(Set.class.getName(), Binding.class.getName());\n+    javaWriter.emitImports(Set.class.getCanonicalName(), Binding.class.getCanonicalName());\n     String actual = javaWriter.compressType(\"java.util.Set<com.example.Binding<blah.Foo.Blah>>\");\n     assertThat(actual).isEqualTo(\"Set<Binding<Foo.Blah>>\");\n   }\n \n   @Test public void compressDeeperType() throws IOException {\n     javaWriter.emitPackage(\"blah\");\n-    javaWriter.emitImports(Binding.class.getName());\n+    javaWriter.emitImports(Binding.class.getCanonicalName());\n     String actual = javaWriter.compressType(\"com.example.Binding<blah.foo.Foo.Blah>\");\n     assertThat(actual).isEqualTo(\"Binding<blah.foo.Foo.Blah>\");\n   }\n"
    },
    {
        "commit_hash": "bdd604bb3919ba6454da161c5b241ee41010a67b",
        "previous_commit_hash": "db7bf9095695f8038765b79b99c1d704e59def5f",
        "diff_stats": {
            "additions": 2,
            "deletions": 1
        },
        "diff_content": "@@ -1,8 +1,8 @@\n Change Log\n ==========\n \n-Version 1.0.1 *(In Development)*\n---------------------------------\n+Version 1.0.1 *(02-03-2013)*\n+----------------------------\n \n  * Expose `compressType` API.\n \n"
    },
    {
        "commit_hash": "979eb1cb77cd6363db2b7e8e80aed2987bea7e8a",
        "previous_commit_hash": "bdd604bb3919ba6454da161c5b241ee41010a67b",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javawriter</artifactId>\n-  <version>1.0.1-SNAPSHOT</version>\n+  <version>1.0.1</version>\n \n   <name>JavaWriter</name>\n   <description>A utility class which aids in generating Java source files.</description>\n"
    },
    {
        "commit_hash": "cc394b442bc5eb0630cce75d954d9b62de9ee544",
        "previous_commit_hash": "979eb1cb77cd6363db2b7e8e80aed2987bea7e8a",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javawriter</artifactId>\n-  <version>1.0.1</version>\n+  <version>1.0.2-SNAPSHOT</version>\n \n   <name>JavaWriter</name>\n   <description>A utility class which aids in generating Java source files.</description>\n"
    },
    {
        "commit_hash": "d8cf5d45f93b1b86d1a09f70ca4a8a54cfc68044",
        "previous_commit_hash": "cc394b442bc5eb0630cce75d954d9b62de9ee544",
        "diff_stats": {
            "additions": 6,
            "deletions": 6
        },
        "diff_content": "@@ -157,7 +157,7 @@ public final class JavaWriter implements Closeable {\n   public JavaWriter beginType(String type, String kind, int modifiers, String extendsType,\n       String... implementsTypes) throws IOException {\n     indent();\n-    out.write(modifiers(modifiers).toString());\n+    out.write(modifiers(modifiers));\n     out.write(kind);\n     out.write(\" \");\n     emitType(type);\n@@ -197,7 +197,7 @@ public final class JavaWriter implements Closeable {\n   public JavaWriter emitField(String type, String name, int modifiers, String initialValue)\n       throws IOException {\n     indent();\n-    out.write(modifiers(modifiers).toString());\n+    out.write(modifiers(modifiers));\n     emitType(type);\n     out.write(\" \");\n     out.write(name);\n@@ -220,7 +220,7 @@ public final class JavaWriter implements Closeable {\n   public JavaWriter beginMethod(String returnType, String name, int modifiers, String... parameters)\n       throws IOException {\n     indent();\n-    out.write(modifiers(modifiers).toString());\n+    out.write(modifiers(modifiers));\n     if (returnType != null) {\n       emitType(returnType);\n       out.write(\" \");\n@@ -517,8 +517,8 @@ public final class JavaWriter implements Closeable {\n   }\n \n   /** Emit modifier names. */\n-  static StringBuffer modifiers(int modifiers) {\n-    StringBuffer out = new StringBuffer();\n+  static String modifiers(int modifiers) {\n+    StringBuilder out = new StringBuilder();\n     if ((modifiers & Modifier.PUBLIC) != 0) {\n       out.append(\"public \");\n     }\n@@ -546,7 +546,7 @@ public final class JavaWriter implements Closeable {\n     if ((modifiers & Modifier.VOLATILE) != 0) {\n       out.append(\"volatile \");\n     }\n-    return out;\n+    return out.toString();\n   }\n \n   private void indent() throws IOException {\n"
    },
    {
        "commit_hash": "07bf461e37a3e7197adfb4d5def9a35321d2f2ca",
        "previous_commit_hash": "05345aab024f2ace8f9b2184b09707374f434c2f",
        "diff_stats": {
            "additions": 20,
            "deletions": 0
        },
        "diff_content": "@@ -512,6 +512,26 @@ public final class JavaWriter implements Closeable {\n     return result.toString();\n   }\n \n+  /** Build a string representation of a type and optionally its generic type arguments. */\n+  public static String type(Class<?> raw, String... parameters) {\n+    if (parameters.length == 0) {\n+      return raw.getCanonicalName();\n+    }\n+    if (raw.getTypeParameters().length != parameters.length) {\n+      throw new IllegalArgumentException();\n+    }\n+    StringBuilder result = new StringBuilder();\n+    result.append(raw.getCanonicalName());\n+    result.append(\"<\");\n+    result.append(parameters[0]);\n+    for (int i = 1; i < parameters.length; i++) {\n+      result.append(\", \");\n+      result.append(parameters[i]);\n+    }\n+    result.append(\">\");\n+    return result.toString();\n+  }\n+\n   @Override public void close() throws IOException {\n     out.close();\n   }\n"
    },
    {
        "commit_hash": "07bf461e37a3e7197adfb4d5def9a35321d2f2ca",
        "previous_commit_hash": "05345aab024f2ace8f9b2184b09707374f434c2f",
        "diff_stats": {
            "additions": 28,
            "deletions": 0
        },
        "diff_content": "@@ -12,6 +12,7 @@ import java.util.Set;\n import org.junit.Test;\n \n import static org.fest.assertions.api.Assertions.assertThat;\n+import static org.fest.assertions.api.Assertions.failBecauseExceptionWasNotThrown;;\n \n public final class JavaWriterTest {\n   private final StringWriter stringWriter = new StringWriter();\n@@ -370,6 +371,33 @@ public final class JavaWriterTest {\n     assertThat(JavaWriter.stringLiteral(\"\\n\")).isEqualTo(\"\\\"\\\\\\n\\\"\");\n   }\n \n+  @Test public void testType() {\n+    assertThat(JavaWriter.type(String.class)).as(\"simple type\").isEqualTo(\"java.lang.String\");\n+    assertThat(JavaWriter.type(Set.class)).as(\"raw type\").isEqualTo(\"java.util.Set\");\n+    assertThat(JavaWriter.type(Set.class, \"?\")).as(\"wildcard type\").isEqualTo(\"java.util.Set<?>\");\n+    assertThat(JavaWriter.type(Map.class, JavaWriter.type(String.class), \"?\"))\n+        .as(\"mixed type and wildcard generic type parameters\")\n+        .isEqualTo(\"java.util.Map<java.lang.String, ?>\");\n+    try {\n+      JavaWriter.type(String.class, \"foo\");\n+      failBecauseExceptionWasNotThrown(IllegalArgumentException.class);\n+    } catch (Throwable e) {\n+      assertThat(e).as(\"parameterized non-generic\").isInstanceOf(IllegalArgumentException.class);\n+    }\n+    try {\n+      JavaWriter.type(Map.class, \"foo\");\n+      failBecauseExceptionWasNotThrown(IllegalArgumentException.class);\n+    } catch (Throwable e) {\n+      assertThat(e).as(\"too few type arguments\").isInstanceOf(IllegalArgumentException.class);\n+    }\n+    try {\n+      JavaWriter.type(Set.class, \"foo\", \"bar\");\n+      failBecauseExceptionWasNotThrown(IllegalArgumentException.class);\n+    } catch (Throwable e) {\n+      assertThat(e).as(\"too many type arguments\").isInstanceOf(IllegalArgumentException.class);\n+    }\n+  }\n+\n   @Test public void compressType() throws IOException {\n     javaWriter.emitPackage(\"blah\");\n     javaWriter.emitImports(Set.class.getCanonicalName(), Binding.class.getCanonicalName());\n"
    },
    {
        "commit_hash": "28ebd9fb8b117e135e84d16e98cace1b3dbd0eee",
        "previous_commit_hash": "07bf461e37a3e7197adfb4d5def9a35321d2f2ca",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -292,7 +292,7 @@ public final class JavaWriter implements Closeable {\n \n   /** Equivalent to {@code annotation(annotationType.getName(), emptyMap())}. */\n   public JavaWriter emitAnnotation(Class<? extends Annotation> annotationType) throws IOException {\n-    return emitAnnotation(annotationType.getName(), Collections.<String, Object>emptyMap());\n+    return emitAnnotation(type(annotationType), Collections.<String, Object>emptyMap());\n   }\n \n   /**\n@@ -304,7 +304,7 @@ public final class JavaWriter implements Closeable {\n    */\n   public JavaWriter emitAnnotation(Class<? extends Annotation> annotationType, Object value)\n       throws IOException {\n-    return emitAnnotation(annotationType.getName(), value);\n+    return emitAnnotation(type(annotationType), value);\n   }\n \n   /**\n@@ -328,7 +328,7 @@ public final class JavaWriter implements Closeable {\n   /** Equivalent to {@code annotation(annotationType.getName(), attributes)}. */\n   public JavaWriter emitAnnotation(Class<? extends Annotation> annotationType,\n       Map<String, ?> attributes) throws IOException {\n-    return emitAnnotation(annotationType.getName(), attributes);\n+    return emitAnnotation(type(annotationType), attributes);\n   }\n \n   /**\n"
    },
    {
        "commit_hash": "fd7fad7e35ada981ef07fee0cd616f33c230420c",
        "previous_commit_hash": "28ebd9fb8b117e135e84d16e98cace1b3dbd0eee",
        "diff_stats": {
            "additions": 7,
            "deletions": 0
        },
        "diff_content": "@@ -412,6 +412,13 @@ public final class JavaWriterTest {\n     assertThat(actual).isEqualTo(\"Binding<blah.foo.Foo.Blah>\");\n   }\n \n+  @Test public void compressWildcardType() throws IOException {\n+    javaWriter.emitPackage(\"blah\");\n+    javaWriter.emitImports(Binding.class.getCanonicalName());\n+    String actual = javaWriter.compressType(\"com.example.Binding<? extends blah.Foo.Blah>\");\n+    assertThat(actual).isEqualTo(\"Binding<? extends Foo.Blah>\");\n+  }\n+\n   private void assertCode(String expected) {\n     assertThat(stringWriter.toString()).isEqualTo(expected);\n   }\n"
    },
    {
        "commit_hash": "f5b3a22bd0983d666bfd30207be12de6f6928df1",
        "previous_commit_hash": "a7fcb69d3240dde7d9bdaae014d1aa374ba424ea",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@ import java.util.Set;\n import org.junit.Test;\n \n import static org.fest.assertions.api.Assertions.assertThat;\n-import static org.fest.assertions.api.Assertions.failBecauseExceptionWasNotThrown;;\n+import static org.fest.assertions.api.Assertions.failBecauseExceptionWasNotThrown;\n \n public final class JavaWriterTest {\n   private final StringWriter stringWriter = new StringWriter();\n"
    },
    {
        "commit_hash": "edf8453b903f52c7c7e0df0f8dc969d032c29cb6",
        "previous_commit_hash": "f5b3a22bd0983d666bfd30207be12de6f6928df1",
        "diff_stats": {
            "additions": 7,
            "deletions": 0
        },
        "diff_content": "@@ -1,6 +1,13 @@\n Change Log\n ==========\n \n+Version 1.0.2 *(02-11-2013)*\n+----------------------------\n+\n+ * Add `type` API for helping build generic types.\n+ * Minor performance improvements.\n+\n+\n Version 1.0.1 *(02-03-2013)*\n ----------------------------\n \n"
    },
    {
        "commit_hash": "016e6beeacb5adcd90582902ddd5beef7a38df1d",
        "previous_commit_hash": "edf8453b903f52c7c7e0df0f8dc969d032c29cb6",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javawriter</artifactId>\n-  <version>1.0.2-SNAPSHOT</version>\n+  <version>1.0.2</version>\n \n   <name>JavaWriter</name>\n   <description>A utility class which aids in generating Java source files.</description>\n"
    },
    {
        "commit_hash": "032c5bdf2a9cfccdf38452c17af8465ea898f1ca",
        "previous_commit_hash": "016e6beeacb5adcd90582902ddd5beef7a38df1d",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javawriter</artifactId>\n-  <version>1.0.2</version>\n+  <version>1.0.3-SNAPSHOT</version>\n \n   <name>JavaWriter</name>\n   <description>A utility class which aids in generating Java source files.</description>\n"
    },
    {
        "commit_hash": "bb5f01822f4aefadcaca9c7e0870e3f5734a6b4a",
        "previous_commit_hash": "032c5bdf2a9cfccdf38452c17af8465ea898f1ca",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -1,20 +1,20 @@\n Change Log\n ==========\n \n-Version 1.0.2 *(02-11-2013)*\n+Version 1.0.2 *(2013-02-11)*\n ----------------------------\n \n  * Add `type` API for helping build generic types.\n  * Minor performance improvements.\n \n \n-Version 1.0.1 *(02-03-2013)*\n+Version 1.0.1 *(2013-02-03)*\n ----------------------------\n \n  * Expose `compressType` API.\n \n \n-Version 1.0.0 *(02-01-2013)*\n+Version 1.0.0 *(2013-02-01)*\n ----------------------------\n \n Initial release.\n"
    },
    {
        "commit_hash": "0a6b21afd67b524d14c515c7685476ad978bab9a",
        "previous_commit_hash": "bb5f01822f4aefadcaca9c7e0870e3f5734a6b4a",
        "diff_stats": {
            "additions": 28,
            "deletions": 0
        },
        "diff_content": "@@ -80,6 +80,34 @@ public final class JavaWriter implements Closeable {\n     return this;\n   }\n \n+  /**\n+   * Emit a static import for each {@code type} provided. For the duration of the file,\n+   * all references to these classes will be automatically shortened.\n+   */\n+  public JavaWriter emitStaticImports(String... types) throws IOException {\n+    return emitStaticImports(Arrays.asList(types));\n+  }\n+\n+  /**\n+   * Emit a static import for each {@code type} in the provided {@code Collection}. For the\n+   * duration of the file, all references to these classes will be automatically shortened.\n+   */\n+  public JavaWriter emitStaticImports(Collection<String> types) throws IOException {\n+    for (String type : new TreeSet<String>(types)) {\n+      Matcher matcher = TYPE_PATTERN.matcher(type);\n+      if (!matcher.matches()) {\n+        throw new IllegalArgumentException(type);\n+      }\n+      if (importedTypes.put(type, matcher.group(1)) != null) {\n+        throw new IllegalArgumentException(type);\n+      }\n+      out.write(\"import static \");\n+      out.write(type);\n+      out.write(\";\\n\");\n+    }\n+    return this;\n+  }\n+\n   /**\n    * Emits a name like {@code java.lang.String} or {@code java.util.List<java.lang.String>},\n    * shorting it with imports if possible.\n"
    },
    {
        "commit_hash": "0a6b21afd67b524d14c515c7685476ad978bab9a",
        "previous_commit_hash": "bb5f01822f4aefadcaca9c7e0870e3f5734a6b4a",
        "diff_stats": {
            "additions": 27,
            "deletions": 0
        },
        "diff_content": "@@ -167,6 +167,21 @@ public final class JavaWriterTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void addStaticImport() throws IOException {\n+    javaWriter.emitPackage(\"com.squareup\");\n+    javaWriter.emitStaticImports(\"java.util.ArrayList\");\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\", Modifier.PUBLIC | Modifier.FINAL);\n+    javaWriter.emitField(\"java.util.ArrayList\", \"list\", 0, \"new java.util.ArrayList()\");\n+    javaWriter.endType();\n+    assertCode(\"\"\n+        + \"package com.squareup;\\n\"\n+        + \"\\n\"\n+        + \"import static java.util.ArrayList;\\n\"\n+        + \"public final class Foo {\\n\"\n+        + \"  ArrayList list = new java.util.ArrayList();\\n\"\n+        + \"}\\n\");\n+  }\n+\n   @Test public void emptyImports() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n     javaWriter.emitImports(Collections.<String>emptyList());\n@@ -179,6 +194,18 @@ public final class JavaWriterTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void emptyStaticImports() throws IOException {\n+    javaWriter.emitPackage(\"com.squareup\");\n+    javaWriter.emitStaticImports(Collections.<String>emptyList());\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\", Modifier.PUBLIC | Modifier.FINAL);\n+    javaWriter.endType();\n+    assertCode(\"\"\n+        + \"package com.squareup;\\n\"\n+        + \"\\n\"\n+        + \"public final class Foo {\\n\"\n+        + \"}\\n\");\n+  }\n+\n   @Test public void addImportFromSubpackage() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n     javaWriter.beginType(\"com.squareup.Foo\", \"class\", Modifier.PUBLIC | Modifier.FINAL);\n"
    },
    {
        "commit_hash": "3ca81d8c44559fb11286ba76ade63043c45123d8",
        "previous_commit_hash": "88fc37c1bf9833b0177a6cba8409728a4ab015a3",
        "diff_stats": {
            "additions": 6,
            "deletions": 0
        },
        "diff_content": "@@ -1,6 +1,12 @@\n Change Log\n ==========\n \n+Version 1.0.3 *(2013-02-21)*\n+-----------------------------\n+\n+ * Add support for emitting static imports.\n+\n+\n Version 1.0.2 *(2013-02-11)*\n ----------------------------\n \n"
    },
    {
        "commit_hash": "620fdd08c8a018290ba3260b7d4e47c06c5c5ead",
        "previous_commit_hash": "3ca81d8c44559fb11286ba76ade63043c45123d8",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javawriter</artifactId>\n-  <version>1.0.3-SNAPSHOT</version>\n+  <version>1.0.3</version>\n \n   <name>JavaWriter</name>\n   <description>A utility class which aids in generating Java source files.</description>\n"
    },
    {
        "commit_hash": "5fd4670eb4ea534ae25261eaba7bc3f0075a1ec1",
        "previous_commit_hash": "620fdd08c8a018290ba3260b7d4e47c06c5c5ead",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javawriter</artifactId>\n-  <version>1.0.3</version>\n+  <version>1.0.4-SNAPSHOT</version>\n \n   <name>JavaWriter</name>\n   <description>A utility class which aids in generating Java source files.</description>\n"
    },
    {
        "commit_hash": "b8de08ce0b959f767b6a66776cbca9af686f4c58",
        "previous_commit_hash": "0a6b21afd67b524d14c515c7685476ad978bab9a",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -19,7 +19,7 @@ import java.util.regex.Pattern;\n \n /** A utility class which aids in generating Java source files. */\n public final class JavaWriter implements Closeable {\n-  private static final Pattern TYPE_PATTERN = Pattern.compile(\"(?:[\\\\w$]+\\\\.)*([\\\\w$]+)\");\n+  private static final Pattern TYPE_PATTERN = Pattern.compile(\"(?:[\\\\w$]+\\\\.)*([\\\\w\\\\.*$]+)\");\n   private static final String INDENT = \"  \";\n \n   /** Map fully qualified type names to their short names. */\n"
    },
    {
        "commit_hash": "b8de08ce0b959f767b6a66776cbca9af686f4c58",
        "previous_commit_hash": "0a6b21afd67b524d14c515c7685476ad978bab9a",
        "diff_stats": {
            "additions": 19,
            "deletions": 4
        },
        "diff_content": "@@ -169,16 +169,31 @@ public final class JavaWriterTest {\n \n   @Test public void addStaticImport() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.emitStaticImports(\"java.util.ArrayList\");\n+    javaWriter.emitStaticImports(\"java.lang.System.getProperty\");\n     javaWriter.beginType(\"com.squareup.Foo\", \"class\", Modifier.PUBLIC | Modifier.FINAL);\n-    javaWriter.emitField(\"java.util.ArrayList\", \"list\", 0, \"new java.util.ArrayList()\");\n+    javaWriter.emitField(\"String\", \"bar\", 0, \"getProperty(\\\"bar\\\")\");\n     javaWriter.endType();\n     assertCode(\"\"\n         + \"package com.squareup;\\n\"\n         + \"\\n\"\n-        + \"import static java.util.ArrayList;\\n\"\n+        + \"import static java.lang.System.getProperty;\\n\"\n         + \"public final class Foo {\\n\"\n-        + \"  ArrayList list = new java.util.ArrayList();\\n\"\n+        + \"  String bar = getProperty(\\\"bar\\\");\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void addStaticWildcardImport() throws IOException {\n+    javaWriter.emitPackage(\"com.squareup\");\n+    javaWriter.emitStaticImports(\"java.lang.System.*\");\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\", Modifier.PUBLIC | Modifier.FINAL);\n+    javaWriter.emitField(\"String\", \"bar\", 0, \"getProperty(\\\"bar\\\")\");\n+    javaWriter.endType();\n+    assertCode(\"\"\n+        + \"package com.squareup;\\n\"\n+        + \"\\n\"\n+        + \"import static java.lang.System.*;\\n\"\n+        + \"public final class Foo {\\n\"\n+        + \"  String bar = getProperty(\\\"bar\\\");\\n\"\n         + \"}\\n\");\n   }\n \n"
    },
    {
        "commit_hash": "45c942593f5cdfd276101636a5d7be576b82ceba",
        "previous_commit_hash": "5a34049e7ce96c334077db15459b05257af2a9e3",
        "diff_stats": {
            "additions": 6,
            "deletions": 0
        },
        "diff_content": "@@ -1,6 +1,12 @@\n Change Log\n ==========\n \n+Version 1.0.4 *(2013-03-15)*\n+----------------------------\n+\n+ * Fix: Static import emit now properly supports method imports.\n+\n+\n Version 1.0.3 *(2013-02-21)*\n -----------------------------\n \n"
    },
    {
        "commit_hash": "7c4b5564761d7f6fb50fe5ccf02e07553675acc1",
        "previous_commit_hash": "45c942593f5cdfd276101636a5d7be576b82ceba",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javawriter</artifactId>\n-  <version>1.0.4-SNAPSHOT</version>\n+  <version>1.0.4</version>\n \n   <name>JavaWriter</name>\n   <description>A utility class which aids in generating Java source files.</description>\n"
    },
    {
        "commit_hash": "737879fb79e3cbc17fe6808e4b6b62e94df6168d",
        "previous_commit_hash": "7c4b5564761d7f6fb50fe5ccf02e07553675acc1",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javawriter</artifactId>\n-  <version>1.0.4</version>\n+  <version>1.0.5-SNAPSHOT</version>\n \n   <name>JavaWriter</name>\n   <description>A utility class which aids in generating Java source files.</description>\n"
    },
    {
        "commit_hash": "a5554a5a72d331d5b2b4a425536b612af7659cd2",
        "previous_commit_hash": "737879fb79e3cbc17fe6808e4b6b62e94df6168d",
        "diff_stats": {
            "additions": 24,
            "deletions": 1
        },
        "diff_content": "@@ -167,6 +167,27 @@ public final class JavaWriter implements Closeable {\n     return false;\n   }\n \n+  /**\n+   * Emits an initializer declaration.\n+   *\n+   * @param kind such as \"static\".\n+   */\n+  public JavaWriter beginInitializer(String type) throws IOException {\n+    indent();\n+    out.write(type);\n+    out.write(\" {\\n\");\n+    pushScope(Scope.INITIALIZER);\n+    return this;\n+  }\n+\n+  /** Ends the current initializer declaration */\n+  public JavaWriter endInitializer() throws IOException {\n+    popScope(Scope.INITIALIZER);\n+    indent();\n+    out.write(\"}\\n\");\n+    return this;\n+  }\n+\n   /**\n    * Emits a type declaration.\n    *\n@@ -611,7 +632,8 @@ public final class JavaWriter implements Closeable {\n \n   private void checkInMethod() {\n     Scope scope = peekScope();\n-    if (scope != Scope.NON_ABSTRACT_METHOD && scope != Scope.CONTROL_FLOW) {\n+    if (scope != Scope.NON_ABSTRACT_METHOD && scope != Scope.CONTROL_FLOW\n+            && scope != Scope.INITIALIZER) {\n       throw new IllegalArgumentException();\n     }\n   }\n@@ -641,5 +663,6 @@ public final class JavaWriter implements Closeable {\n     CONTROL_FLOW,\n     ANNOTATION_ATTRIBUTE,\n     ANNOTATION_ARRAY_VALUE,\n+    INITIALIZER\n   }\n }\n"
    },
    {
        "commit_hash": "a79ded543b5934cfad7b19a924c8b5fda7451e28",
        "previous_commit_hash": "a5554a5a72d331d5b2b4a425536b612af7659cd2",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -170,7 +170,7 @@ public final class JavaWriter implements Closeable {\n   /**\n    * Emits an initializer declaration.\n    *\n-   * @param kind such as \"static\".\n+   * @param type such as \"static\".\n    */\n   public JavaWriter beginInitializer(String type) throws IOException {\n     indent();\n@@ -180,7 +180,7 @@ public final class JavaWriter implements Closeable {\n     return this;\n   }\n \n-  /** Ends the current initializer declaration */\n+  /** Ends the current initializer declaration. */\n   public JavaWriter endInitializer() throws IOException {\n     popScope(Scope.INITIALIZER);\n     indent();\n"
    },
    {
        "commit_hash": "6934302400a510980d1bfd8e393be6cd1087e5c2",
        "previous_commit_hash": "a79ded543b5934cfad7b19a924c8b5fda7451e28",
        "diff_stats": {
            "additions": 8,
            "deletions": 4
        },
        "diff_content": "@@ -170,12 +170,16 @@ public final class JavaWriter implements Closeable {\n   /**\n    * Emits an initializer declaration.\n    *\n-   * @param type such as \"static\".\n+   * @param isStatic true if it should be an static initializer, false for an instance initializer.\n    */\n-  public JavaWriter beginInitializer(String type) throws IOException {\n+  public JavaWriter beginInitializer(Boolean isStatic) throws IOException {\n     indent();\n-    out.write(type);\n-    out.write(\" {\\n\");\n+    if (isStatic) {\n+      out.write(\"static\");\n+      out.write(\" {\\n\");\n+    } else {\n+      out.write(\"{\\n\");\n+    }\n     pushScope(Scope.INITIALIZER);\n     return this;\n   }\n"
    },
    {
        "commit_hash": "5f4072b8d9d62764339e8ce79778313396cc167d",
        "previous_commit_hash": "6934302400a510980d1bfd8e393be6cd1087e5c2",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -172,7 +172,7 @@ public final class JavaWriter implements Closeable {\n    *\n    * @param isStatic true if it should be an static initializer, false for an instance initializer.\n    */\n-  public JavaWriter beginInitializer(Boolean isStatic) throws IOException {\n+  public JavaWriter beginInitializer(boolean isStatic) throws IOException {\n     indent();\n     if (isStatic) {\n       out.write(\"static\");\n"
    },
    {
        "commit_hash": "17605c52dfe212a4b9d205f32097e752027fbd0d",
        "previous_commit_hash": "737879fb79e3cbc17fe6808e4b6b62e94df6168d",
        "diff_stats": {
            "additions": 15,
            "deletions": 1
        },
        "diff_content": "@@ -143,7 +143,12 @@ public final class JavaWriter implements Closeable {\n       if (imported != null) {\n         sb.append(imported);\n       } else if (isClassInPackage(name)) {\n-        sb.append(name.substring(packagePrefix.length()));\n+        String compressed = name.substring(packagePrefix.length());\n+        if (isAmbiguous(compressed)) {\n+          sb.append(name);\n+        } else {\n+          sb.append(compressed);\n+        }\n       } else if (name.startsWith(\"java.lang.\")) {\n         sb.append(name.substring(\"java.lang.\".length()));\n       } else {\n@@ -167,6 +172,15 @@ public final class JavaWriter implements Closeable {\n     return false;\n   }\n \n+  /**\n+   * Returns true if the imports contain a class with same simple name as {@code compressed}.\n+   *\n+   * @param compressed simple name of the type\n+   */\n+  private boolean isAmbiguous(String compressed) {\n+    return importedTypes.values().contains(compressed);\n+  }\n+\n   /**\n    * Emits a type declaration.\n    *\n"
    },
    {
        "commit_hash": "17605c52dfe212a4b9d205f32097e752027fbd0d",
        "previous_commit_hash": "737879fb79e3cbc17fe6808e4b6b62e94df6168d",
        "diff_stats": {
            "additions": 7,
            "deletions": 0
        },
        "diff_content": "@@ -461,6 +461,13 @@ public final class JavaWriterTest {\n     assertThat(actual).isEqualTo(\"Binding<? extends Foo.Blah>\");\n   }\n \n+  @Test public void compressSimpleNameCollisionInSamePackage() throws IOException {\n+    javaWriter.emitPackage(\"denominator\");\n+    javaWriter.emitImports(\"javax.inject.Provider\", \"dagger.internal.Binding\");\n+    String actual = javaWriter.compressType(\"dagger.internal.Binding<denominator.Provider>\");\n+    assertThat(actual).isEqualTo(\"Binding<denominator.Provider>\");\n+  }\n+\n   private void assertCode(String expected) {\n     assertThat(stringWriter.toString()).isEqualTo(expected);\n   }\n"
    },
    {
        "commit_hash": "79922973641dec21e1f8383127cbab31f5840687",
        "previous_commit_hash": "834f118d58933a531787fcc59681a8e631b4f03e",
        "diff_stats": {
            "additions": 6,
            "deletions": 0
        },
        "diff_content": "@@ -1,6 +1,12 @@\n Change Log\n ==========\n \n+Version 1.0.5 *(2013-05-08)*\n+----------------------------\n+\n+ * Fix: Fully qualify types whose simple name matches an import.\n+\n+\n Version 1.0.4 *(2013-03-15)*\n ----------------------------\n \n"
    },
    {
        "commit_hash": "fee0bc45e6885e614157dfc2f54e871f1079eba6",
        "previous_commit_hash": "79922973641dec21e1f8383127cbab31f5840687",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javawriter</artifactId>\n-  <version>1.0.5-SNAPSHOT</version>\n+  <version>1.0.5</version>\n \n   <name>JavaWriter</name>\n   <description>A utility class which aids in generating Java source files.</description>\n"
    },
    {
        "commit_hash": "959303064d7dc9b07d50cc47430d6eb10dae1a55",
        "previous_commit_hash": "fee0bc45e6885e614157dfc2f54e871f1079eba6",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javawriter</artifactId>\n-  <version>1.0.5</version>\n+  <version>1.0.6-SNAPSHOT</version>\n \n   <name>JavaWriter</name>\n   <description>A utility class which aids in generating Java source files.</description>\n"
    },
    {
        "commit_hash": "7d57a5909c7c54502db6ffa27ea0ccc08d0cd696",
        "previous_commit_hash": "087d2d7983f27e5a405cbd7aa31d6f098b91c13f",
        "diff_stats": {
            "additions": 2,
            "deletions": 1
        },
        "diff_content": "@@ -332,8 +332,9 @@ public final class JavaWriter implements Closeable {\n     return this;\n   }\n \n-  /** Emits some Javadoc comments. */\n+  /** Emits a single line comment. */\n   public JavaWriter emitEndOfLineComment(String comment, Object... args) throws IOException {\n+    indent();\n     out.write(\"// \");\n     out.write(String.format(comment, args));\n     out.write(\"\\n\");\n"
    },
    {
        "commit_hash": "7d57a5909c7c54502db6ffa27ea0ccc08d0cd696",
        "previous_commit_hash": "087d2d7983f27e5a405cbd7aa31d6f098b91c13f",
        "diff_stats": {
            "additions": 19,
            "deletions": 0
        },
        "diff_content": "@@ -132,6 +132,25 @@ public final class JavaWriterTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void statementFollowedByComment() throws IOException {\n+    javaWriter.emitPackage(\"com.squareup\");\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\", 0);\n+    javaWriter.beginMethod(\"int\", \"foo\", 0, \"java.lang.String\", \"s\");\n+    javaWriter.emitStatement(\"int j = s.length() + %s\", 13);\n+    javaWriter.emitEndOfLineComment(\"foo\");\n+    javaWriter.endMethod();\n+    javaWriter.endType();\n+    assertCode(\"\"\n+        + \"package com.squareup;\\n\"\n+        + \"\\n\"\n+        + \"class Foo {\\n\"\n+        + \"  int foo(String s) {\\n\"\n+        + \"    int j = s.length() + 13;\\n\"\n+        + \"    // foo\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n   @Test public void multiLineStatement() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n     javaWriter.beginType(\"com.squareup.Triangle\", \"class\", 0);\n"
    },
    {
        "commit_hash": "d60e0e45a57a56e1dad6ae9e80aaa7d9f67ddd3c",
        "previous_commit_hash": "7d57a5909c7c54502db6ffa27ea0ccc08d0cd696",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -132,12 +132,12 @@ public final class JavaWriterTest {\n         + \"}\\n\");\n   }\n \n-  @Test public void statementFollowedByComment() throws IOException {\n+  @Test public void statementPrecededByComment() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n     javaWriter.beginType(\"com.squareup.Foo\", \"class\", 0);\n     javaWriter.beginMethod(\"int\", \"foo\", 0, \"java.lang.String\", \"s\");\n-    javaWriter.emitStatement(\"int j = s.length() + %s\", 13);\n     javaWriter.emitEndOfLineComment(\"foo\");\n+    javaWriter.emitStatement(\"int j = s.length() + %s\", 13);\n     javaWriter.endMethod();\n     javaWriter.endType();\n     assertCode(\"\"\n@@ -145,8 +145,8 @@ public final class JavaWriterTest {\n         + \"\\n\"\n         + \"class Foo {\\n\"\n         + \"  int foo(String s) {\\n\"\n-        + \"    int j = s.length() + 13;\\n\"\n         + \"    // foo\\n\"\n+        + \"    int j = s.length() + 13;\\n\"\n         + \"  }\\n\"\n         + \"}\\n\");\n   }\n"
    },
    {
        "commit_hash": "6ecfcee4a4f2f73f9c0212a577e018711e949b56",
        "previous_commit_hash": "087d2d7983f27e5a405cbd7aa31d6f098b91c13f",
        "diff_stats": {
            "additions": 32,
            "deletions": 6
        },
        "diff_content": "@@ -286,6 +286,19 @@ public final class JavaWriter implements Closeable {\n    */\n   public JavaWriter beginMethod(String returnType, String name, int modifiers, String... parameters)\n       throws IOException {\n+    return beginMethod(returnType, name, modifiers, Arrays.asList(parameters), null);\n+  }\n+\n+  /**\n+   * Emit a method declaration.\n+   *\n+   * @param returnType the method's return type, or null for constructors.\n+   * @param name the method name, or the fully qualified class name for constructors.\n+   * @param parameters alternating parameter types and names.\n+   * @param throwsTypes the classes to throw, or null for no throws clause.\n+   */\n+  public JavaWriter beginMethod(String returnType, String name, int modifiers,\n+      List<String> parameters, List<String> throwsTypes) throws IOException {\n     indent();\n     out.write(modifiers(modifiers));\n     if (returnType != null) {\n@@ -296,15 +309,28 @@ public final class JavaWriter implements Closeable {\n       emitType(name);\n     }\n     out.write(\"(\");\n-    for (int p = 0; p < parameters.length;) {\n-      if (p != 0) {\n-        out.write(\", \");\n+    if (parameters != null) {\n+      for (int p = 0; p < parameters.size();) {\n+        if (p != 0) {\n+          out.write(\", \");\n+        }\n+        emitType(parameters.get(p++));\n+        out.write(\" \");\n+        emitType(parameters.get(p++));\n       }\n-      emitType(parameters[p++]);\n-      out.write(\" \");\n-      emitType(parameters[p++]);\n     }\n     out.write(\")\");\n+    if (throwsTypes != null && throwsTypes.size() > 0) {\n+      out.write(\"\\n\");\n+      indent();\n+      out.write(\"    throws \");\n+      for (int i = 0; i < throwsTypes.size(); i++) {\n+        if (i != 0) {\n+          out.write(\", \");\n+        }\n+        emitType(throwsTypes.get(i));\n+      }\n+    }\n     if ((modifiers & Modifier.ABSTRACT) != 0) {\n       out.write(\";\\n\");\n       pushScope(Scope.ABSTRACT_METHOD);\n"
    },
    {
        "commit_hash": "6ecfcee4a4f2f73f9c0212a577e018711e949b56",
        "previous_commit_hash": "087d2d7983f27e5a405cbd7aa31d6f098b91c13f",
        "diff_stats": {
            "additions": 52,
            "deletions": 0
        },
        "diff_content": "@@ -5,6 +5,7 @@ import com.example.Binding;\n import java.io.IOException;\n import java.io.StringWriter;\n import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.LinkedHashMap;\n import java.util.Map;\n@@ -85,6 +86,23 @@ public final class JavaWriterTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void abstractMethodDeclarationWithThrows() throws IOException {\n+    javaWriter.emitPackage(\"com.squareup\");\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\", 0);\n+    javaWriter.beginMethod(\"java.lang.String\", \"foo\", Modifier.ABSTRACT | Modifier.PUBLIC,\n+        Arrays.asList(\"java.lang.Object\", \"object\", \"java.lang.String\", \"s\"),\n+        Arrays.asList(\"IOException\"));\n+    javaWriter.endMethod();\n+    javaWriter.endType();\n+    assertCode(\"\"\n+        + \"package com.squareup;\\n\"\n+        + \"\\n\"\n+        + \"class Foo {\\n\"\n+        + \"  public abstract String foo(Object object, String s)\\n\"\n+        + \"      throws IOException;\\n\"\n+        + \"}\\n\");\n+  }\n+\n   @Test public void nonAbstractMethodDeclaration() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n     javaWriter.beginType(\"com.squareup.Foo\", \"class\", 0);\n@@ -100,6 +118,23 @@ public final class JavaWriterTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void nonAbstractMethodDeclarationWithThrows() throws IOException {\n+    javaWriter.emitPackage(\"com.squareup\");\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\", 0);\n+    javaWriter.beginMethod(\"int\", \"foo\", 0, Arrays.asList(\"java.lang.String\", \"s\"),\n+        Arrays.asList(\"IOException\"));\n+    javaWriter.endMethod();\n+    javaWriter.endType();\n+    assertCode(\"\"\n+        + \"package com.squareup;\\n\"\n+        + \"\\n\"\n+        + \"class Foo {\\n\"\n+        + \"  int foo(String s)\\n\"\n+        + \"      throws IOException {\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n   @Test public void constructorDeclaration() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n     javaWriter.beginType(\"com.squareup.Foo\", \"class\", 0);\n@@ -115,6 +150,23 @@ public final class JavaWriterTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void constructorDeclarationWithThrows() throws IOException {\n+    javaWriter.emitPackage(\"com.squareup\");\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\", 0);\n+    javaWriter.beginMethod(null, \"com.squareup.Foo\", Modifier.PUBLIC,\n+        Arrays.asList(\"java.lang.String\", \"s\"), Arrays.asList(\"IOException\"));\n+    javaWriter.endMethod();\n+    javaWriter.endType();\n+    assertCode(\"\"\n+        + \"package com.squareup;\\n\"\n+        + \"\\n\"\n+        + \"class Foo {\\n\"\n+        + \"  public Foo(String s)\\n\"\n+        + \"      throws IOException {\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n   @Test public void statement() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n     javaWriter.beginType(\"com.squareup.Foo\", \"class\", 0);\n"
    },
    {
        "commit_hash": "2fc51db0fcee90f3c9f342ff1caf6ff073a39ad9",
        "previous_commit_hash": "087d2d7983f27e5a405cbd7aa31d6f098b91c13f",
        "diff_stats": {
            "additions": 41,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,41 @@\n+#!/bin/bash\n+\n+set -ex\n+\n+REPO=\"git@github.com:square/javawriter.git\"\n+GROUP_ID=\"com.squareup\"\n+ARTIFACT_ID=\"javawriter\"\n+\n+DIR=temp-clone\n+\n+# Delete any existing temporary website clone\n+rm -rf $DIR\n+\n+# Clone the current repo into temp folder\n+git clone $REPO $DIR\n+\n+# Move working directory into temp folder\n+cd $DIR\n+\n+# Checkout and track the gh-pages branch\n+git checkout -t origin/gh-pages\n+\n+# Delete everything\n+rm -rf *\n+\n+# Download the latest javadoc\n+curl -L \"http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=$GROUP_ID&a=$ARTIFACT_ID&v=LATEST&c=javadoc\" > javadoc.zip\n+unzip javadoc.zip\n+rm javadoc.zip\n+\n+# Stage all files in git and create a commit\n+git add .\n+git add -u\n+git commit -m \"Website at $(date)\"\n+\n+# Push the new files up to GitHub\n+git push origin gh-pages\n+\n+# Delete our temp folder\n+cd ..\n+rm -rf $DIR\n"
    },
    {
        "commit_hash": "e4928d756f91ba4e8db1d4c2e08dccfd842dd417",
        "previous_commit_hash": "5b494281907282a9f90e448b7642f24f06c1a81f",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -333,7 +333,7 @@ public final class JavaWriter implements Closeable {\n   }\n \n   /** Emits a single line comment. */\n-  public JavaWriter emitEndOfLineComment(String comment, Object... args) throws IOException {\n+  public JavaWriter emitSingleLineCOmment(String comment, Object... args) throws IOException {\n     indent();\n     out.write(\"// \");\n     out.write(String.format(comment, args));\n"
    },
    {
        "commit_hash": "e4928d756f91ba4e8db1d4c2e08dccfd842dd417",
        "previous_commit_hash": "5b494281907282a9f90e448b7642f24f06c1a81f",
        "diff_stats": {
            "additions": 3,
            "deletions": 4
        },
        "diff_content": "@@ -136,7 +136,7 @@ public final class JavaWriterTest {\n     javaWriter.emitPackage(\"com.squareup\");\n     javaWriter.beginType(\"com.squareup.Foo\", \"class\", 0);\n     javaWriter.beginMethod(\"int\", \"foo\", 0, \"java.lang.String\", \"s\");\n-    javaWriter.emitEndOfLineComment(\"foo\");\n+    javaWriter.emitSingleLineCOmment(\"foo\");\n     javaWriter.emitStatement(\"int j = s.length() + %s\", 13);\n     javaWriter.endMethod();\n     javaWriter.endType();\n@@ -400,9 +400,8 @@ public final class JavaWriterTest {\n   }\n \n   @Test public void eolComment() throws IOException {\n-    javaWriter.emitEndOfLineComment(\"foo\");\n-    assertCode(\"\"\n-        + \"// foo\\n\");\n+    javaWriter.emitSingleLineCOmment(\"foo\");\n+    assertCode(\"// foo\\n\");\n   }\n \n   @Test public void javadoc() throws IOException {\n"
    },
    {
        "commit_hash": "dacb4ceca66c2f78f888505b0dd2834e11b1c2c6",
        "previous_commit_hash": "4d9da055a03ce9666b98711d639ab15903d4a953",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javawriter</artifactId>\n-  <version>1.0.6-SNAPSHOT</version>\n+  <version>2.0.0-SNAPSHOT</version>\n \n   <name>JavaWriter</name>\n   <description>A utility class which aids in generating Java source files.</description>\n"
    },
    {
        "commit_hash": "dacb4ceca66c2f78f888505b0dd2834e11b1c2c6",
        "previous_commit_hash": "4d9da055a03ce9666b98711d639ab15903d4a953",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -1,5 +1,5 @@\n // Copyright 2013 Square, Inc.\n-package com.squareup.java;\n+package com.squareup.javawriter;\n \n import java.io.Closeable;\n import java.io.IOException;\n"
    },
    {
        "commit_hash": "dacb4ceca66c2f78f888505b0dd2834e11b1c2c6",
        "previous_commit_hash": "4d9da055a03ce9666b98711d639ab15903d4a953",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -1,5 +1,5 @@\n // Copyright 2013 Square, Inc.\n-package com.squareup.java;\n+package com.squareup.javawriter;\n \n import com.example.Binding;\n import java.io.IOException;\n"
    },
    {
        "commit_hash": "28a626dfd4eb7f26dc2b53e121a18513363c6c8d",
        "previous_commit_hash": "31f85260ae64597c9d5608fab3ae3936d054087c",
        "diff_stats": {
            "additions": 6,
            "deletions": 6
        },
        "diff_content": "@@ -91,7 +91,7 @@ public final class JavaWriterTest {\n     javaWriter.beginType(\"com.squareup.Foo\", \"class\", 0);\n     javaWriter.beginMethod(\"java.lang.String\", \"foo\", Modifier.ABSTRACT | Modifier.PUBLIC,\n         Arrays.asList(\"java.lang.Object\", \"object\", \"java.lang.String\", \"s\"),\n-        Arrays.asList(\"IOException\"));\n+        Arrays.asList(\"java.io.IOException\"));\n     javaWriter.endMethod();\n     javaWriter.endType();\n     assertCode(\"\"\n@@ -99,7 +99,7 @@ public final class JavaWriterTest {\n         + \"\\n\"\n         + \"class Foo {\\n\"\n         + \"  public abstract String foo(Object object, String s)\\n\"\n-        + \"      throws IOException;\\n\"\n+        + \"      throws java.io.IOException;\\n\"\n         + \"}\\n\");\n   }\n \n@@ -122,7 +122,7 @@ public final class JavaWriterTest {\n     javaWriter.emitPackage(\"com.squareup\");\n     javaWriter.beginType(\"com.squareup.Foo\", \"class\", 0);\n     javaWriter.beginMethod(\"int\", \"foo\", 0, Arrays.asList(\"java.lang.String\", \"s\"),\n-        Arrays.asList(\"IOException\"));\n+        Arrays.asList(\"java.io.IOException\"));\n     javaWriter.endMethod();\n     javaWriter.endType();\n     assertCode(\"\"\n@@ -130,7 +130,7 @@ public final class JavaWriterTest {\n         + \"\\n\"\n         + \"class Foo {\\n\"\n         + \"  int foo(String s)\\n\"\n-        + \"      throws IOException {\\n\"\n+        + \"      throws java.io.IOException {\\n\"\n         + \"  }\\n\"\n         + \"}\\n\");\n   }\n@@ -154,7 +154,7 @@ public final class JavaWriterTest {\n     javaWriter.emitPackage(\"com.squareup\");\n     javaWriter.beginType(\"com.squareup.Foo\", \"class\", 0);\n     javaWriter.beginMethod(null, \"com.squareup.Foo\", Modifier.PUBLIC,\n-        Arrays.asList(\"java.lang.String\", \"s\"), Arrays.asList(\"IOException\"));\n+        Arrays.asList(\"java.lang.String\", \"s\"), Arrays.asList(\"java.io.IOException\"));\n     javaWriter.endMethod();\n     javaWriter.endType();\n     assertCode(\"\"\n@@ -162,7 +162,7 @@ public final class JavaWriterTest {\n         + \"\\n\"\n         + \"class Foo {\\n\"\n         + \"  public Foo(String s)\\n\"\n-        + \"      throws IOException {\\n\"\n+        + \"      throws java.io.IOException {\\n\"\n         + \"  }\\n\"\n         + \"}\\n\");\n   }\n"
    },
    {
        "commit_hash": "33475bce98ac10adbac07f0f6a2350b9ad8f7bb7",
        "previous_commit_hash": "28a626dfd4eb7f26dc2b53e121a18513363c6c8d",
        "diff_stats": {
            "additions": 7,
            "deletions": 0
        },
        "diff_content": "@@ -1,6 +1,13 @@\n Change Log\n ==========\n \n+Version 2.0.0 *(2013-06-06)*\n+----------------------------\n+\n+ * Package name is now `com.squareup.javawriter`.\n+ * Support declaring `throws` clause on methods.\n+\n+\n Version 1.0.5 *(2013-05-08)*\n ----------------------------\n \n"
    },
    {
        "commit_hash": "269e7e168421210412c1e882fbcdbe65ad3ec5d6",
        "previous_commit_hash": "33475bce98ac10adbac07f0f6a2350b9ad8f7bb7",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javawriter</artifactId>\n-  <version>2.0.0-SNAPSHOT</version>\n+  <version>2.0.0</version>\n \n   <name>JavaWriter</name>\n   <description>A utility class which aids in generating Java source files.</description>\n"
    },
    {
        "commit_hash": "c22ec0248f118fd2e87b564afe063ecf251473aa",
        "previous_commit_hash": "269e7e168421210412c1e882fbcdbe65ad3ec5d6",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javawriter</artifactId>\n-  <version>2.0.0</version>\n+  <version>2.0.1-SNAPSHOT</version>\n \n   <name>JavaWriter</name>\n   <description>A utility class which aids in generating Java source files.</description>\n"
    },
    {
        "commit_hash": "f8efee128cc0616ceb5ea573e9f0ac42509805fc",
        "previous_commit_hash": "c22ec0248f118fd2e87b564afe063ecf251473aa",
        "diff_stats": {
            "additions": 32,
            "deletions": 19
        },
        "diff_content": "@@ -13,6 +13,7 @@ import java.util.Collections;\n import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.Map.Entry;\n import java.util.TreeSet;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n@@ -437,27 +438,39 @@ public final class JavaWriter implements Closeable {\n     indent();\n     out.write(\"@\");\n     emitType(annotation);\n-    if (!attributes.isEmpty()) {\n-      out.write(\"(\");\n-      pushScope(Scope.ANNOTATION_ATTRIBUTE);\n-      boolean firstAttribute = true;\n-      for (Map.Entry<String, ?> entry : attributes.entrySet()) {\n-        if (firstAttribute) {\n-          firstAttribute = false;\n-          out.write(\"\\n\");\n-        } else {\n-          out.write(\",\\n\");\n+    switch (attributes.size()) {\n+      case 0:\n+        break;\n+      case 1:\n+        Entry<String, ?> onlyEntry = attributes.entrySet().iterator().next();\n+        if (\"value\".equals(onlyEntry.getKey())) {\n+          out.write(\"(\");\n+          emitAnnotationValue(onlyEntry.getValue());\n+          out.write(\")\");\n+          break;\n         }\n+      default:\n+        out.write(\"(\");\n+        pushScope(Scope.ANNOTATION_ATTRIBUTE);\n+        boolean firstAttribute = true;\n+        for (Map.Entry<String, ?> entry : attributes.entrySet()) {\n+          if (firstAttribute) {\n+            firstAttribute = false;\n+            out.write(\"\\n\");\n+          } else {\n+            out.write(\",\\n\");\n+          }\n+          indent();\n+          out.write(entry.getKey());\n+          out.write(\" = \");\n+          Object value = entry.getValue();\n+          emitAnnotationValue(value);\n+        }\n+        popScope(Scope.ANNOTATION_ATTRIBUTE);\n+        out.write(\"\\n\");\n         indent();\n-        out.write(entry.getKey());\n-        out.write(\" = \");\n-        Object value = entry.getValue();\n-        emitAnnotationValue(value);\n-      }\n-      popScope(Scope.ANNOTATION_ATTRIBUTE);\n-      out.write(\"\\n\");\n-      indent();\n-      out.write(\")\");\n+        out.write(\")\");\n+        break;\n     }\n     out.write(\"\\n\");\n     return this;\n"
    },
    {
        "commit_hash": "f8efee128cc0616ceb5ea573e9f0ac42509805fc",
        "previous_commit_hash": "c22ec0248f118fd2e87b564afe063ecf251473aa",
        "diff_stats": {
            "additions": 40,
            "deletions": 3
        },
        "diff_content": "@@ -1,7 +1,10 @@\n // Copyright 2013 Square, Inc.\n package com.squareup.javawriter;\n \n-import com.example.Binding;\n+import static com.squareup.javawriter.JavaWriter.stringLiteral;\n+import static org.fest.assertions.api.Assertions.assertThat;\n+import static org.fest.assertions.api.Assertions.failBecauseExceptionWasNotThrown;\n+\n import java.io.IOException;\n import java.io.StringWriter;\n import java.lang.reflect.Modifier;\n@@ -10,10 +13,10 @@ import java.util.Collections;\n import java.util.LinkedHashMap;\n import java.util.Map;\n import java.util.Set;\n+\n import org.junit.Test;\n \n-import static org.fest.assertions.api.Assertions.assertThat;\n-import static org.fest.assertions.api.Assertions.failBecauseExceptionWasNotThrown;\n+import com.example.Binding;\n \n public final class JavaWriterTest {\n   private final StringWriter stringWriter = new StringWriter();\n@@ -409,6 +412,40 @@ public final class JavaWriterTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void annotatedWithSingleAttribute() throws IOException {\n+    Map<String, Object> attributes = new LinkedHashMap<String, Object>();\n+    attributes.put(\"overrides\", true);\n+\n+    javaWriter.emitPackage(\"com.squareup\");\n+    javaWriter.emitAnnotation(\"Module\", attributes);\n+    javaWriter.beginType(\"com.squareup.FooModule\", \"class\", 0);\n+    javaWriter.endType();\n+    assertCode(\"\"\n+        + \"package com.squareup;\\n\"\n+        + \"\\n\"\n+        + \"@Module(\\n\"\n+        + \"  overrides = true\\n\"\n+        + \")\\n\"\n+        + \"class FooModule {\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void annotatedWithSingleValueAttribute() throws IOException {\n+    Map<String, Object> attributes = new LinkedHashMap<String, Object>();\n+    attributes.put(\"value\", stringLiteral(\"blah.Generator\"));\n+\n+    javaWriter.emitPackage(\"com.squareup\");\n+    javaWriter.emitAnnotation(\"Generated\", attributes);\n+    javaWriter.beginType(\"com.squareup.FooModule\", \"class\", 0);\n+    javaWriter.endType();\n+    assertCode(\"\"\n+        + \"package com.squareup;\\n\"\n+        + \"\\n\"\n+        + \"@Generated(\\\"blah.Generator\\\")\\n\"\n+        + \"class FooModule {\\n\"\n+        + \"}\\n\");\n+  }\n+\n   @Test public void annotatedWithAttributes() throws IOException {\n     Map<String, Object> attributes = new LinkedHashMap<String, Object>();\n     attributes.put(\"overrides\", true);\n"
    },
    {
        "commit_hash": "3deba86fbc98387501b2076b82c35ac78a56de21",
        "previous_commit_hash": "c22ec0248f118fd2e87b564afe063ecf251473aa",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -359,7 +359,7 @@ public final class JavaWriter implements Closeable {\n   }\n \n   /** Emits a single line comment. */\n-  public JavaWriter emitSingleLineCOmment(String comment, Object... args) throws IOException {\n+  public JavaWriter emitSingleLineComment(String comment, Object... args) throws IOException {\n     indent();\n     out.write(\"// \");\n     out.write(String.format(comment, args));\n"
    },
    {
        "commit_hash": "3deba86fbc98387501b2076b82c35ac78a56de21",
        "previous_commit_hash": "c22ec0248f118fd2e87b564afe063ecf251473aa",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -188,7 +188,7 @@ public final class JavaWriterTest {\n     javaWriter.emitPackage(\"com.squareup\");\n     javaWriter.beginType(\"com.squareup.Foo\", \"class\", 0);\n     javaWriter.beginMethod(\"int\", \"foo\", 0, \"java.lang.String\", \"s\");\n-    javaWriter.emitSingleLineCOmment(\"foo\");\n+    javaWriter.emitSingleLineComment(\"foo\");\n     javaWriter.emitStatement(\"int j = s.length() + %s\", 13);\n     javaWriter.endMethod();\n     javaWriter.endType();\n@@ -452,7 +452,7 @@ public final class JavaWriterTest {\n   }\n \n   @Test public void eolComment() throws IOException {\n-    javaWriter.emitSingleLineCOmment(\"foo\");\n+    javaWriter.emitSingleLineComment(\"foo\");\n     assertCode(\"// foo\\n\");\n   }\n \n"
    },
    {
        "commit_hash": "422922f3367ce1c194c6cbfc6fa2901294afcc4e",
        "previous_commit_hash": "89ed905358dd09d005398028198cc388b9b59a94",
        "diff_stats": {
            "additions": 6,
            "deletions": 0
        },
        "diff_content": "@@ -1,6 +1,12 @@\n Change Log\n ==========\n \n+Version 2.0.1 *(2013-06-17)*\n+----------------------------\n+\n+ * Correct casing of `emitSingleLineComment`.\n+\n+\n Version 2.0.0 *(2013-06-06)*\n ----------------------------\n \n"
    },
    {
        "commit_hash": "ba6054b095dcab3d5f1b3d6cbb923c621f1498a7",
        "previous_commit_hash": "422922f3367ce1c194c6cbfc6fa2901294afcc4e",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javawriter</artifactId>\n-  <version>2.0.1-SNAPSHOT</version>\n+  <version>2.0.1</version>\n \n   <name>JavaWriter</name>\n   <description>A utility class which aids in generating Java source files.</description>\n"
    },
    {
        "commit_hash": "8131bca7ca212199102a3cc2567dad731f8e54f3",
        "previous_commit_hash": "ba6054b095dcab3d5f1b3d6cbb923c621f1498a7",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javawriter</artifactId>\n-  <version>2.0.1</version>\n+  <version>2.0.2-SNAPSHOT</version>\n \n   <name>JavaWriter</name>\n   <description>A utility class which aids in generating Java source files.</description>\n"
    },
    {
        "commit_hash": "98ed954c1f0b042321a86d3349746c28bf91441c",
        "previous_commit_hash": "1249d23d0ea84130d28640b08866d25f9169ae17",
        "diff_stats": {
            "additions": 116,
            "deletions": 34
        },
        "diff_content": "@@ -1,23 +1,36 @@\n // Copyright 2013 Square, Inc.\n package com.squareup.javawriter;\n \n+import static javax.lang.model.element.Modifier.ABSTRACT;\n+import static javax.lang.model.element.Modifier.FINAL;\n+import static javax.lang.model.element.Modifier.PRIVATE;\n+import static javax.lang.model.element.Modifier.PROTECTED;\n+import static javax.lang.model.element.Modifier.PUBLIC;\n+import static javax.lang.model.element.Modifier.STATIC;\n+import static javax.lang.model.element.Modifier.SYNCHRONIZED;\n+import static javax.lang.model.element.Modifier.TRANSIENT;\n+import static javax.lang.model.element.Modifier.VOLATILE;\n+\n import java.io.Closeable;\n import java.io.IOException;\n import java.io.Writer;\n import java.lang.annotation.Annotation;\n-import java.lang.reflect.Modifier;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.EnumSet;\n import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Map.Entry;\n+import java.util.Set;\n import java.util.TreeSet;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n+import javax.lang.model.element.Modifier;\n+\n /** A utility class which aids in generating Java source files. */\n public final class JavaWriter implements Closeable {\n   private static final Pattern TYPE_PATTERN = Pattern.compile(\"(?:[\\\\w$]+\\\\.)*([\\\\w\\\\.*$]+)\");\n@@ -207,25 +220,42 @@ public final class JavaWriter implements Closeable {\n     return this;\n   }\n \n+  /**\n+   * @deprecated Use {@link #beginType(String, String, Set)}\n+   */\n+  @Deprecated\n+  public JavaWriter beginType(String type, String kind, int modifiers) throws IOException {\n+    return beginType(type, kind, modifiersAsSet(modifiers), null);\n+  }\n+\n   /**\n    * Emits a type declaration.\n    *\n    * @param kind such as \"class\", \"interface\" or \"enum\".\n    */\n-  public JavaWriter beginType(String type, String kind, int modifiers) throws IOException {\n+  public JavaWriter beginType(String type, String kind, Set<Modifier> modifiers) throws IOException {\n     return beginType(type, kind, modifiers, null);\n   }\n \n+  /**\n+   * @deprecated Use {@link #beginType(String, String, Set, String, String...)}\n+   */\n+  @Deprecated\n+  public JavaWriter beginType(String type, String kind, int modifiers, String extendsType,\n+      String... implementsTypes) throws IOException {\n+    return beginType(type, kind, modifiersAsSet(modifiers), extendsType, implementsTypes);\n+  }\n+\n   /**\n    * Emits a type declaration.\n    *\n    * @param kind such as \"class\", \"interface\" or \"enum\".\n    * @param extendsType the class to extend, or null for no extends clause.\n    */\n-  public JavaWriter beginType(String type, String kind, int modifiers, String extendsType,\n+  public JavaWriter beginType(String type, String kind, Set<Modifier> modifiers, String extendsType,\n       String... implementsTypes) throws IOException {\n     indent();\n-    out.write(modifiers(modifiers));\n+    emitModifiers(modifiers);\n     out.write(kind);\n     out.write(\" \");\n     emitType(type);\n@@ -233,7 +263,7 @@ public final class JavaWriter implements Closeable {\n       out.write(\" extends \");\n       emitType(extendsType);\n     }\n-    if (implementsTypes.length > 0) {\n+    if ((implementsTypes != null) && (implementsTypes.length > 0)) {\n       out.write(\"\\n\");\n       indent();\n       out.write(\"    implements \");\n@@ -257,15 +287,32 @@ public final class JavaWriter implements Closeable {\n     return this;\n   }\n \n-  /** Emits a field declaration. */\n+  /**\n+   * @deprecated Use {@link #emitField(String, String, Set)}.\n+   */\n+  @Deprecated\n   public JavaWriter emitField(String type, String name, int modifiers) throws IOException {\n+    return emitField(type, name, modifiersAsSet(modifiers), null);\n+  }\n+\n+  /** Emits a field declaration. */\n+  public JavaWriter emitField(String type, String name, Set<Modifier> modifiers) throws IOException {\n     return emitField(type, name, modifiers, null);\n   }\n \n+  /**\n+   * @deprecated Use {@link #emitField(String, String, Set, String)}.\n+   */\n+  @Deprecated\n   public JavaWriter emitField(String type, String name, int modifiers, String initialValue)\n       throws IOException {\n+    return emitField(type, name, modifiersAsSet(modifiers), initialValue);\n+  }\n+\n+  public JavaWriter emitField(String type, String name, Set<Modifier> modifiers,\n+      String initialValue) throws IOException {\n     indent();\n-    out.write(modifiers(modifiers));\n+    emitModifiers(modifiers);\n     emitType(type);\n     out.write(\" \");\n     out.write(name);\n@@ -278,30 +325,51 @@ public final class JavaWriter implements Closeable {\n     return this;\n   }\n \n+  /**\n+   * @deprecated Use {@link #beginMethod(String, String, Set, String...)}.\n+   */\n+  @Deprecated\n+  public JavaWriter beginMethod(String returnType, String name, int modifiers, String... parameters)\n+      throws IOException {\n+    return beginMethod(returnType, name, modifiersAsSet(modifiers), Arrays.asList(parameters),\n+        null);\n+  }\n+\n   /**\n    * Emit a method declaration.\n    *\n    * @param returnType the method's return type, or null for constructors.\n    * @param name the method name, or the fully qualified class name for constructors.\n+   * @param modifiers the set of modifiers to be applied to the method\n    * @param parameters alternating parameter types and names.\n    */\n-  public JavaWriter beginMethod(String returnType, String name, int modifiers, String... parameters)\n-      throws IOException {\n+  public JavaWriter beginMethod(String returnType, String name, Set<Modifier> modifiers,\n+      String... parameters) throws IOException {\n     return beginMethod(returnType, name, modifiers, Arrays.asList(parameters), null);\n   }\n \n+  /**\n+   * @deprecated Use {@link #beginMethod(String, String, Set, List, List)}.\n+   */\n+  @Deprecated\n+  public JavaWriter beginMethod(String returnType, String name, int modifiers,\n+      List<String> parameters, List<String> throwsTypes) throws IOException {\n+    return beginMethod(returnType, name, modifiersAsSet(modifiers), parameters, throwsTypes);\n+  }\n+\n   /**\n    * Emit a method declaration.\n    *\n    * @param returnType the method's return type, or null for constructors.\n    * @param name the method name, or the fully qualified class name for constructors.\n+   * @param modifiers the set of modifiers to be applied to the method\n    * @param parameters alternating parameter types and names.\n    * @param throwsTypes the classes to throw, or null for no throws clause.\n    */\n-  public JavaWriter beginMethod(String returnType, String name, int modifiers,\n+  public JavaWriter beginMethod(String returnType, String name, Set<Modifier> modifiers,\n       List<String> parameters, List<String> throwsTypes) throws IOException {\n     indent();\n-    out.write(modifiers(modifiers));\n+    emitModifiers(modifiers);\n     if (returnType != null) {\n       emitType(returnType);\n       out.write(\" \");\n@@ -332,7 +400,7 @@ public final class JavaWriter implements Closeable {\n         emitType(throwsTypes.get(i));\n       }\n     }\n-    if ((modifiers & Modifier.ABSTRACT) != 0) {\n+    if (modifiers.contains(ABSTRACT)) {\n       out.write(\";\\n\");\n       pushScope(Scope.ABSTRACT_METHOD);\n     } else {\n@@ -643,37 +711,51 @@ public final class JavaWriter implements Closeable {\n     out.close();\n   }\n \n-  /** Emit modifier names. */\n-  static String modifiers(int modifiers) {\n-    StringBuilder out = new StringBuilder();\n-    if ((modifiers & Modifier.PUBLIC) != 0) {\n-      out.append(\"public \");\n+  /** Emits the modifiers to the writer. */\n+  private void emitModifiers(Set<Modifier> modifiers) throws IOException {\n+    // Use an EnumSet to ensure the proper ordering\n+    if (!(modifiers instanceof EnumSet)) {\n+      modifiers = EnumSet.copyOf(modifiers);\n+    }\n+    for (Modifier modifier : modifiers) {\n+      out.append(modifier.toString()).append(' ');\n+    }\n+  }\n+\n+  /**\n+   * Returns a set of modifiers for an {@code int} encoded with the values in\n+   * {@link java.lang.reflect.Modifier}.\n+   */\n+  private static EnumSet<Modifier> modifiersAsSet(int modifiers) {\n+    EnumSet<Modifier> modifierSet = EnumSet.noneOf(Modifier.class);\n+    if ((modifiers & java.lang.reflect.Modifier.PUBLIC) != 0) {\n+      modifierSet.add(PUBLIC);\n     }\n-    if ((modifiers & Modifier.PRIVATE) != 0) {\n-      out.append(\"private \");\n+    if ((modifiers & java.lang.reflect.Modifier.PRIVATE) != 0) {\n+      modifierSet.add(PRIVATE);\n     }\n-    if ((modifiers & Modifier.PROTECTED) != 0) {\n-      out.append(\"protected \");\n+    if ((modifiers & java.lang.reflect.Modifier.PROTECTED) != 0) {\n+      modifierSet.add(PROTECTED);\n     }\n-    if ((modifiers & Modifier.STATIC) != 0) {\n-      out.append(\"static \");\n+    if ((modifiers & java.lang.reflect.Modifier.STATIC) != 0) {\n+      modifierSet.add(STATIC);\n     }\n-    if ((modifiers & Modifier.FINAL) != 0) {\n-      out.append(\"final \");\n+    if ((modifiers & java.lang.reflect.Modifier.FINAL) != 0) {\n+      modifierSet.add(FINAL);\n     }\n-    if ((modifiers & Modifier.ABSTRACT) != 0) {\n-      out.append(\"abstract \");\n+    if ((modifiers & java.lang.reflect.Modifier.ABSTRACT) != 0) {\n+      modifierSet.add(ABSTRACT);\n     }\n-    if ((modifiers & Modifier.SYNCHRONIZED) != 0) {\n-      out.append(\"synchronized \");\n+    if ((modifiers & java.lang.reflect.Modifier.SYNCHRONIZED) != 0) {\n+      modifierSet.add(SYNCHRONIZED);\n     }\n-    if ((modifiers & Modifier.TRANSIENT) != 0) {\n-      out.append(\"transient \");\n+    if ((modifiers & java.lang.reflect.Modifier.TRANSIENT) != 0) {\n+      modifierSet.add(TRANSIENT);\n     }\n-    if ((modifiers & Modifier.VOLATILE) != 0) {\n-      out.append(\"volatile \");\n+    if ((modifiers & java.lang.reflect.Modifier.VOLATILE) != 0) {\n+      modifierSet.add(VOLATILE);\n     }\n-    return out.toString();\n+    return modifierSet;\n   }\n \n   private void indent() throws IOException {\n"
    },
    {
        "commit_hash": "98ed954c1f0b042321a86d3349746c28bf91441c",
        "previous_commit_hash": "1249d23d0ea84130d28640b08866d25f9169ae17",
        "diff_stats": {
            "additions": 61,
            "deletions": 50
        },
        "diff_content": "@@ -2,18 +2,25 @@\n package com.squareup.javawriter;\n \n import static com.squareup.javawriter.JavaWriter.stringLiteral;\n+import static javax.lang.model.element.Modifier.ABSTRACT;\n+import static javax.lang.model.element.Modifier.FINAL;\n+import static javax.lang.model.element.Modifier.PRIVATE;\n+import static javax.lang.model.element.Modifier.PUBLIC;\n+import static javax.lang.model.element.Modifier.STATIC;\n import static org.fest.assertions.api.Assertions.assertThat;\n import static org.fest.assertions.api.Assertions.failBecauseExceptionWasNotThrown;\n \n import java.io.IOException;\n import java.io.StringWriter;\n-import java.lang.reflect.Modifier;\n import java.util.Arrays;\n import java.util.Collections;\n+import java.util.EnumSet;\n import java.util.LinkedHashMap;\n import java.util.Map;\n import java.util.Set;\n \n+import javax.lang.model.element.Modifier;\n+\n import org.junit.Test;\n \n import com.example.Binding;\n@@ -24,7 +31,7 @@ public final class JavaWriterTest {\n \n   @Test public void typeDeclaration() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\", Modifier.PUBLIC | Modifier.FINAL);\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\", EnumSet.of(PUBLIC, FINAL));\n     javaWriter.endType();\n     assertCode(\"\"\n         + \"package com.squareup;\\n\"\n@@ -35,7 +42,7 @@ public final class JavaWriterTest {\n \n   @Test public void enumDeclaration() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"enum\", Modifier.PUBLIC);\n+    javaWriter.beginType(\"com.squareup.Foo\", \"enum\", EnumSet.of(PUBLIC));\n     javaWriter.emitEnumValue(\"BAR\");\n     javaWriter.emitEnumValue(\"BAZ\");\n     javaWriter.endType();\n@@ -50,8 +57,8 @@ public final class JavaWriterTest {\n \n   @Test public void fieldDeclaration() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\", 0);\n-    javaWriter.emitField(\"java.lang.String\", \"string\", Modifier.PRIVATE | Modifier.STATIC);\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\", EnumSet.noneOf(Modifier.class));\n+    javaWriter.emitField(\"java.lang.String\", \"string\", EnumSet.of(PRIVATE, STATIC));\n     javaWriter.endType();\n     assertCode(\"\"\n         + \"package com.squareup;\\n\"\n@@ -63,8 +70,9 @@ public final class JavaWriterTest {\n \n   @Test public void fieldDeclarationWithInitialValue() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\", 0);\n-    javaWriter.emitField(\"java.lang.String\", \"string\", 0, \"\\\"bar\\\" + \\\"baz\\\"\");\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\", EnumSet.noneOf(Modifier.class));\n+    javaWriter.emitField(\"java.lang.String\", \"string\", EnumSet.noneOf(Modifier.class),\n+        \"\\\"bar\\\" + \\\"baz\\\"\");\n     javaWriter.endType();\n     assertCode(\"\"\n         + \"package com.squareup;\\n\"\n@@ -76,8 +84,8 @@ public final class JavaWriterTest {\n \n   @Test public void abstractMethodDeclaration() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\", 0);\n-    javaWriter.beginMethod(\"java.lang.String\", \"foo\", Modifier.ABSTRACT | Modifier.PUBLIC,\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\", EnumSet.noneOf(Modifier.class));\n+    javaWriter.beginMethod(\"java.lang.String\", \"foo\", EnumSet.of(ABSTRACT, PUBLIC),\n         \"java.lang.Object\", \"object\", \"java.lang.String\", \"s\");\n     javaWriter.endMethod();\n     javaWriter.endType();\n@@ -91,8 +99,8 @@ public final class JavaWriterTest {\n \n   @Test public void abstractMethodDeclarationWithThrows() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\", 0);\n-    javaWriter.beginMethod(\"java.lang.String\", \"foo\", Modifier.ABSTRACT | Modifier.PUBLIC,\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\", EnumSet.noneOf(Modifier.class));\n+    javaWriter.beginMethod(\"java.lang.String\", \"foo\", EnumSet.of(ABSTRACT, PUBLIC),\n         Arrays.asList(\"java.lang.Object\", \"object\", \"java.lang.String\", \"s\"),\n         Arrays.asList(\"java.io.IOException\"));\n     javaWriter.endMethod();\n@@ -108,8 +116,8 @@ public final class JavaWriterTest {\n \n   @Test public void nonAbstractMethodDeclaration() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\", 0);\n-    javaWriter.beginMethod(\"int\", \"foo\", 0, \"java.lang.String\", \"s\");\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\", EnumSet.noneOf(Modifier.class));\n+    javaWriter.beginMethod(\"int\", \"foo\", EnumSet.noneOf(Modifier.class), \"java.lang.String\", \"s\");\n     javaWriter.endMethod();\n     javaWriter.endType();\n     assertCode(\"\"\n@@ -123,9 +131,9 @@ public final class JavaWriterTest {\n \n   @Test public void nonAbstractMethodDeclarationWithThrows() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\", 0);\n-    javaWriter.beginMethod(\"int\", \"foo\", 0, Arrays.asList(\"java.lang.String\", \"s\"),\n-        Arrays.asList(\"java.io.IOException\"));\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\", EnumSet.noneOf(Modifier.class));\n+    javaWriter.beginMethod(\"int\", \"foo\", EnumSet.noneOf(Modifier.class),\n+        Arrays.asList(\"java.lang.String\", \"s\"), Arrays.asList(\"java.io.IOException\"));\n     javaWriter.endMethod();\n     javaWriter.endType();\n     assertCode(\"\"\n@@ -140,8 +148,8 @@ public final class JavaWriterTest {\n \n   @Test public void constructorDeclaration() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\", 0);\n-    javaWriter.beginMethod(null, \"com.squareup.Foo\", Modifier.PUBLIC, \"java.lang.String\", \"s\");\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\", EnumSet.noneOf(Modifier.class));\n+    javaWriter.beginMethod(null, \"com.squareup.Foo\", EnumSet.of(PUBLIC), \"java.lang.String\", \"s\");\n     javaWriter.endMethod();\n     javaWriter.endType();\n     assertCode(\"\"\n@@ -155,8 +163,8 @@ public final class JavaWriterTest {\n \n   @Test public void constructorDeclarationWithThrows() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\", 0);\n-    javaWriter.beginMethod(null, \"com.squareup.Foo\", Modifier.PUBLIC,\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\", EnumSet.noneOf(Modifier.class));\n+    javaWriter.beginMethod(null, \"com.squareup.Foo\", EnumSet.of(PUBLIC),\n         Arrays.asList(\"java.lang.String\", \"s\"), Arrays.asList(\"java.io.IOException\"));\n     javaWriter.endMethod();\n     javaWriter.endType();\n@@ -172,8 +180,8 @@ public final class JavaWriterTest {\n \n   @Test public void statement() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\", 0);\n-    javaWriter.beginMethod(\"int\", \"foo\", 0, \"java.lang.String\", \"s\");\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\", EnumSet.noneOf(Modifier.class));\n+    javaWriter.beginMethod(\"int\", \"foo\", EnumSet.noneOf(Modifier.class), \"java.lang.String\", \"s\");\n     javaWriter.emitStatement(\"int j = s.length() + %s\", 13);\n     javaWriter.endMethod();\n     javaWriter.endType();\n@@ -189,8 +197,8 @@ public final class JavaWriterTest {\n \n   @Test public void statementPrecededByComment() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\", 0);\n-    javaWriter.beginMethod(\"int\", \"foo\", 0, \"java.lang.String\", \"s\");\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\", EnumSet.noneOf(Modifier.class));\n+    javaWriter.beginMethod(\"int\", \"foo\", EnumSet.noneOf(Modifier.class), \"java.lang.String\", \"s\");\n     javaWriter.emitSingleLineComment(\"foo\");\n     javaWriter.emitStatement(\"int j = s.length() + %s\", 13);\n     javaWriter.endMethod();\n@@ -208,8 +216,9 @@ public final class JavaWriterTest {\n \n   @Test public void multiLineStatement() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Triangle\", \"class\", 0);\n-    javaWriter.beginMethod(\"double\", \"pythagorean\", 0, \"int\", \"a\", \"int\", \"b\");\n+    javaWriter.beginType(\"com.squareup.Triangle\", \"class\", EnumSet.noneOf(Modifier.class));\n+    javaWriter.beginMethod(\"double\", \"pythagorean\", EnumSet.noneOf(Modifier.class),\n+        \"int\", \"a\", \"int\", \"b\");\n     javaWriter.emitStatement(\"int cSquared = a * a\\n+ b * b\");\n     javaWriter.emitStatement(\"return Math.sqrt(cSquared)\");\n     javaWriter.endMethod();\n@@ -229,8 +238,9 @@ public final class JavaWriterTest {\n   @Test public void addImport() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n     javaWriter.emitImports(\"java.util.ArrayList\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\", Modifier.PUBLIC | Modifier.FINAL);\n-    javaWriter.emitField(\"java.util.ArrayList\", \"list\", 0, \"new java.util.ArrayList()\");\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\", EnumSet.of(PUBLIC, FINAL));\n+    javaWriter.emitField(\"java.util.ArrayList\", \"list\", EnumSet.noneOf(Modifier.class),\n+        \"new java.util.ArrayList()\");\n     javaWriter.endType();\n     assertCode(\"\"\n         + \"package com.squareup;\\n\"\n@@ -244,8 +254,8 @@ public final class JavaWriterTest {\n   @Test public void addStaticImport() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n     javaWriter.emitStaticImports(\"java.lang.System.getProperty\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\", Modifier.PUBLIC | Modifier.FINAL);\n-    javaWriter.emitField(\"String\", \"bar\", 0, \"getProperty(\\\"bar\\\")\");\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\", EnumSet.of(PUBLIC, FINAL));\n+    javaWriter.emitField(\"String\", \"bar\", EnumSet.noneOf(Modifier.class), \"getProperty(\\\"bar\\\")\");\n     javaWriter.endType();\n     assertCode(\"\"\n         + \"package com.squareup;\\n\"\n@@ -259,8 +269,8 @@ public final class JavaWriterTest {\n   @Test public void addStaticWildcardImport() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n     javaWriter.emitStaticImports(\"java.lang.System.*\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\", Modifier.PUBLIC | Modifier.FINAL);\n-    javaWriter.emitField(\"String\", \"bar\", 0, \"getProperty(\\\"bar\\\")\");\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\", EnumSet.of(PUBLIC, FINAL));\n+    javaWriter.emitField(\"String\", \"bar\", EnumSet.noneOf(Modifier.class), \"getProperty(\\\"bar\\\")\");\n     javaWriter.endType();\n     assertCode(\"\"\n         + \"package com.squareup;\\n\"\n@@ -274,7 +284,7 @@ public final class JavaWriterTest {\n   @Test public void emptyImports() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n     javaWriter.emitImports(Collections.<String>emptyList());\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\", Modifier.PUBLIC | Modifier.FINAL);\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\", EnumSet.of(PUBLIC, FINAL));\n     javaWriter.endType();\n     assertCode(\"\"\n         + \"package com.squareup;\\n\"\n@@ -286,7 +296,7 @@ public final class JavaWriterTest {\n   @Test public void emptyStaticImports() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n     javaWriter.emitStaticImports(Collections.<String>emptyList());\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\", Modifier.PUBLIC | Modifier.FINAL);\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\", EnumSet.of(PUBLIC, FINAL));\n     javaWriter.endType();\n     assertCode(\"\"\n         + \"package com.squareup;\\n\"\n@@ -297,8 +307,8 @@ public final class JavaWriterTest {\n \n   @Test public void addImportFromSubpackage() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\", Modifier.PUBLIC | Modifier.FINAL);\n-    javaWriter.emitField(\"com.squareup.bar.Baz\", \"baz\", 0);\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\", EnumSet.of(PUBLIC, FINAL));\n+    javaWriter.emitField(\"com.squareup.bar.Baz\", \"baz\", EnumSet.noneOf(Modifier.class));\n     javaWriter.endType();\n     assertCode(\"\"\n         + \"package com.squareup;\\n\"\n@@ -310,8 +320,8 @@ public final class JavaWriterTest {\n \n   @Test public void ifControlFlow() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\", 0);\n-    javaWriter.beginMethod(\"int\", \"foo\", 0, \"java.lang.String\", \"s\");\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\", EnumSet.noneOf(Modifier.class));\n+    javaWriter.beginMethod(\"int\", \"foo\", EnumSet.noneOf(Modifier.class), \"java.lang.String\", \"s\");\n     javaWriter.beginControlFlow(\"if (s.isEmpty())\");\n     javaWriter.emitStatement(\"int j = s.length() + %s\", 13);\n     javaWriter.endControlFlow();\n@@ -331,8 +341,8 @@ public final class JavaWriterTest {\n \n   @Test public void doWhileControlFlow() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\", 0);\n-    javaWriter.beginMethod(\"int\", \"foo\", 0, \"java.lang.String\", \"s\");\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\", EnumSet.noneOf(Modifier.class));\n+    javaWriter.beginMethod(\"int\", \"foo\", EnumSet.noneOf(Modifier.class), \"java.lang.String\", \"s\");\n     javaWriter.beginControlFlow(\"do\");\n     javaWriter.emitStatement(\"int j = s.length() + %s\", 13);\n     javaWriter.endControlFlow(\"while (s.isEmpty())\");\n@@ -352,8 +362,8 @@ public final class JavaWriterTest {\n \n   @Test public void tryCatchFinallyControlFlow() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\", 0);\n-    javaWriter.beginMethod(\"int\", \"foo\", 0, \"java.lang.String\", \"s\");\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\", EnumSet.noneOf(Modifier.class));\n+    javaWriter.beginMethod(\"int\", \"foo\", EnumSet.noneOf(Modifier.class), \"java.lang.String\", \"s\");\n     javaWriter.beginControlFlow(\"try\");\n     javaWriter.emitStatement(\"int j = s.length() + %s\", 13);\n     javaWriter.nextControlFlow(\"catch (RuntimeException e)\");\n@@ -385,7 +395,7 @@ public final class JavaWriterTest {\n     javaWriter.emitAnnotation(\"javax.inject.Singleton\");\n     javaWriter.emitAnnotation(SuppressWarnings.class,\n         JavaWriter.stringLiteral(\"unchecked\"));\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\", 0);\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\", EnumSet.noneOf(Modifier.class));\n     javaWriter.endType();\n     assertCode(\"\"\n         + \"package com.squareup;\\n\"\n@@ -399,9 +409,9 @@ public final class JavaWriterTest {\n \n   @Test public void annotatedMember() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\", 0);\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\", EnumSet.noneOf(Modifier.class));\n     javaWriter.emitAnnotation(Deprecated.class);\n-    javaWriter.emitField(\"java.lang.String\", \"s\", 0);\n+    javaWriter.emitField(\"java.lang.String\", \"s\", EnumSet.noneOf(Modifier.class));\n     javaWriter.endType();\n     assertCode(\"\"\n         + \"package com.squareup;\\n\"\n@@ -418,7 +428,7 @@ public final class JavaWriterTest {\n \n     javaWriter.emitPackage(\"com.squareup\");\n     javaWriter.emitAnnotation(\"Module\", attributes);\n-    javaWriter.beginType(\"com.squareup.FooModule\", \"class\", 0);\n+    javaWriter.beginType(\"com.squareup.FooModule\", \"class\", EnumSet.noneOf(Modifier.class));\n     javaWriter.endType();\n     assertCode(\"\"\n         + \"package com.squareup;\\n\"\n@@ -436,7 +446,7 @@ public final class JavaWriterTest {\n \n     javaWriter.emitPackage(\"com.squareup\");\n     javaWriter.emitAnnotation(\"Generated\", attributes);\n-    javaWriter.beginType(\"com.squareup.FooModule\", \"class\", 0);\n+    javaWriter.beginType(\"com.squareup.FooModule\", \"class\", EnumSet.noneOf(Modifier.class));\n     javaWriter.endType();\n     assertCode(\"\"\n         + \"package com.squareup;\\n\"\n@@ -454,7 +464,7 @@ public final class JavaWriterTest {\n \n     javaWriter.emitPackage(\"com.squareup\");\n     javaWriter.emitAnnotation(\"Module\", attributes);\n-    javaWriter.beginType(\"com.squareup.FooModule\", \"class\", 0);\n+    javaWriter.beginType(\"com.squareup.FooModule\", \"class\", EnumSet.noneOf(Modifier.class));\n     javaWriter.endType();\n     assertCode(\"\"\n         + \"package com.squareup;\\n\"\n@@ -475,8 +485,9 @@ public final class JavaWriterTest {\n   @Test public void parameterizedType() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n     javaWriter.emitImports(\"java.util.Map\", \"java.util.Date\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\", 0);\n-    javaWriter.emitField(\"java.util.Map<java.lang.String, java.util.Date>\", \"map\", 0);\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\", EnumSet.noneOf(Modifier.class));\n+    javaWriter.emitField(\"java.util.Map<java.lang.String, java.util.Date>\", \"map\",\n+        EnumSet.noneOf(Modifier.class));\n     javaWriter.endType();\n     assertCode(\"\"\n         + \"package com.squareup;\\n\"\n"
    },
    {
        "commit_hash": "721d8ac79c1e660d05577d94c32c7f86085c1866",
        "previous_commit_hash": "98ed954c1f0b042321a86d3349746c28bf91441c",
        "diff_stats": {
            "additions": 16,
            "deletions": 1
        },
        "diff_content": "@@ -220,6 +220,15 @@ public final class JavaWriter implements Closeable {\n     return this;\n   }\n \n+ /**\n+  * Emits a type declaration.\n+  *\n+  * @param kind such as \"class\", \"interface\" or \"enum\".\n+  */\n+  public JavaWriter beginType(String type, String kind) throws IOException {\n+    return beginType(type, kind, EnumSet.noneOf(Modifier.class), null);\n+  }\n+\n   /**\n    * @deprecated Use {@link #beginType(String, String, Set)}\n    */\n@@ -287,6 +296,11 @@ public final class JavaWriter implements Closeable {\n     return this;\n   }\n \n+  /** Emits a field declaration. */\n+  public JavaWriter emitField(String type, String name) throws IOException {\n+    return emitField(type, name, EnumSet.noneOf(Modifier.class), null);\n+  }\n+\n   /**\n    * @deprecated Use {@link #emitField(String, String, Set)}.\n    */\n@@ -296,7 +310,8 @@ public final class JavaWriter implements Closeable {\n   }\n \n   /** Emits a field declaration. */\n-  public JavaWriter emitField(String type, String name, Set<Modifier> modifiers) throws IOException {\n+  public JavaWriter emitField(String type, String name, Set<Modifier> modifiers)\n+      throws IOException {\n     return emitField(type, name, modifiers, null);\n   }\n \n"
    },
    {
        "commit_hash": "721d8ac79c1e660d05577d94c32c7f86085c1866",
        "previous_commit_hash": "98ed954c1f0b042321a86d3349746c28bf91441c",
        "diff_stats": {
            "additions": 20,
            "deletions": 20
        },
        "diff_content": "@@ -57,7 +57,7 @@ public final class JavaWriterTest {\n \n   @Test public void fieldDeclaration() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\", EnumSet.noneOf(Modifier.class));\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n     javaWriter.emitField(\"java.lang.String\", \"string\", EnumSet.of(PRIVATE, STATIC));\n     javaWriter.endType();\n     assertCode(\"\"\n@@ -70,7 +70,7 @@ public final class JavaWriterTest {\n \n   @Test public void fieldDeclarationWithInitialValue() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\", EnumSet.noneOf(Modifier.class));\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n     javaWriter.emitField(\"java.lang.String\", \"string\", EnumSet.noneOf(Modifier.class),\n         \"\\\"bar\\\" + \\\"baz\\\"\");\n     javaWriter.endType();\n@@ -84,7 +84,7 @@ public final class JavaWriterTest {\n \n   @Test public void abstractMethodDeclaration() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\", EnumSet.noneOf(Modifier.class));\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n     javaWriter.beginMethod(\"java.lang.String\", \"foo\", EnumSet.of(ABSTRACT, PUBLIC),\n         \"java.lang.Object\", \"object\", \"java.lang.String\", \"s\");\n     javaWriter.endMethod();\n@@ -99,7 +99,7 @@ public final class JavaWriterTest {\n \n   @Test public void abstractMethodDeclarationWithThrows() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\", EnumSet.noneOf(Modifier.class));\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n     javaWriter.beginMethod(\"java.lang.String\", \"foo\", EnumSet.of(ABSTRACT, PUBLIC),\n         Arrays.asList(\"java.lang.Object\", \"object\", \"java.lang.String\", \"s\"),\n         Arrays.asList(\"java.io.IOException\"));\n@@ -116,7 +116,7 @@ public final class JavaWriterTest {\n \n   @Test public void nonAbstractMethodDeclaration() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\", EnumSet.noneOf(Modifier.class));\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n     javaWriter.beginMethod(\"int\", \"foo\", EnumSet.noneOf(Modifier.class), \"java.lang.String\", \"s\");\n     javaWriter.endMethod();\n     javaWriter.endType();\n@@ -131,7 +131,7 @@ public final class JavaWriterTest {\n \n   @Test public void nonAbstractMethodDeclarationWithThrows() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\", EnumSet.noneOf(Modifier.class));\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n     javaWriter.beginMethod(\"int\", \"foo\", EnumSet.noneOf(Modifier.class),\n         Arrays.asList(\"java.lang.String\", \"s\"), Arrays.asList(\"java.io.IOException\"));\n     javaWriter.endMethod();\n@@ -148,7 +148,7 @@ public final class JavaWriterTest {\n \n   @Test public void constructorDeclaration() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\", EnumSet.noneOf(Modifier.class));\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n     javaWriter.beginMethod(null, \"com.squareup.Foo\", EnumSet.of(PUBLIC), \"java.lang.String\", \"s\");\n     javaWriter.endMethod();\n     javaWriter.endType();\n@@ -163,7 +163,7 @@ public final class JavaWriterTest {\n \n   @Test public void constructorDeclarationWithThrows() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\", EnumSet.noneOf(Modifier.class));\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n     javaWriter.beginMethod(null, \"com.squareup.Foo\", EnumSet.of(PUBLIC),\n         Arrays.asList(\"java.lang.String\", \"s\"), Arrays.asList(\"java.io.IOException\"));\n     javaWriter.endMethod();\n@@ -180,7 +180,7 @@ public final class JavaWriterTest {\n \n   @Test public void statement() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\", EnumSet.noneOf(Modifier.class));\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n     javaWriter.beginMethod(\"int\", \"foo\", EnumSet.noneOf(Modifier.class), \"java.lang.String\", \"s\");\n     javaWriter.emitStatement(\"int j = s.length() + %s\", 13);\n     javaWriter.endMethod();\n@@ -197,7 +197,7 @@ public final class JavaWriterTest {\n \n   @Test public void statementPrecededByComment() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\", EnumSet.noneOf(Modifier.class));\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n     javaWriter.beginMethod(\"int\", \"foo\", EnumSet.noneOf(Modifier.class), \"java.lang.String\", \"s\");\n     javaWriter.emitSingleLineComment(\"foo\");\n     javaWriter.emitStatement(\"int j = s.length() + %s\", 13);\n@@ -216,7 +216,7 @@ public final class JavaWriterTest {\n \n   @Test public void multiLineStatement() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Triangle\", \"class\", EnumSet.noneOf(Modifier.class));\n+    javaWriter.beginType(\"com.squareup.Triangle\", \"class\");\n     javaWriter.beginMethod(\"double\", \"pythagorean\", EnumSet.noneOf(Modifier.class),\n         \"int\", \"a\", \"int\", \"b\");\n     javaWriter.emitStatement(\"int cSquared = a * a\\n+ b * b\");\n@@ -308,7 +308,7 @@ public final class JavaWriterTest {\n   @Test public void addImportFromSubpackage() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n     javaWriter.beginType(\"com.squareup.Foo\", \"class\", EnumSet.of(PUBLIC, FINAL));\n-    javaWriter.emitField(\"com.squareup.bar.Baz\", \"baz\", EnumSet.noneOf(Modifier.class));\n+    javaWriter.emitField(\"com.squareup.bar.Baz\", \"baz\");\n     javaWriter.endType();\n     assertCode(\"\"\n         + \"package com.squareup;\\n\"\n@@ -320,7 +320,7 @@ public final class JavaWriterTest {\n \n   @Test public void ifControlFlow() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\", EnumSet.noneOf(Modifier.class));\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n     javaWriter.beginMethod(\"int\", \"foo\", EnumSet.noneOf(Modifier.class), \"java.lang.String\", \"s\");\n     javaWriter.beginControlFlow(\"if (s.isEmpty())\");\n     javaWriter.emitStatement(\"int j = s.length() + %s\", 13);\n@@ -341,7 +341,7 @@ public final class JavaWriterTest {\n \n   @Test public void doWhileControlFlow() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\", EnumSet.noneOf(Modifier.class));\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n     javaWriter.beginMethod(\"int\", \"foo\", EnumSet.noneOf(Modifier.class), \"java.lang.String\", \"s\");\n     javaWriter.beginControlFlow(\"do\");\n     javaWriter.emitStatement(\"int j = s.length() + %s\", 13);\n@@ -362,7 +362,7 @@ public final class JavaWriterTest {\n \n   @Test public void tryCatchFinallyControlFlow() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\", EnumSet.noneOf(Modifier.class));\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n     javaWriter.beginMethod(\"int\", \"foo\", EnumSet.noneOf(Modifier.class), \"java.lang.String\", \"s\");\n     javaWriter.beginControlFlow(\"try\");\n     javaWriter.emitStatement(\"int j = s.length() + %s\", 13);\n@@ -395,7 +395,7 @@ public final class JavaWriterTest {\n     javaWriter.emitAnnotation(\"javax.inject.Singleton\");\n     javaWriter.emitAnnotation(SuppressWarnings.class,\n         JavaWriter.stringLiteral(\"unchecked\"));\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\", EnumSet.noneOf(Modifier.class));\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n     javaWriter.endType();\n     assertCode(\"\"\n         + \"package com.squareup;\\n\"\n@@ -409,9 +409,9 @@ public final class JavaWriterTest {\n \n   @Test public void annotatedMember() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\", EnumSet.noneOf(Modifier.class));\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n     javaWriter.emitAnnotation(Deprecated.class);\n-    javaWriter.emitField(\"java.lang.String\", \"s\", EnumSet.noneOf(Modifier.class));\n+    javaWriter.emitField(\"java.lang.String\", \"s\");\n     javaWriter.endType();\n     assertCode(\"\"\n         + \"package com.squareup;\\n\"\n@@ -464,7 +464,7 @@ public final class JavaWriterTest {\n \n     javaWriter.emitPackage(\"com.squareup\");\n     javaWriter.emitAnnotation(\"Module\", attributes);\n-    javaWriter.beginType(\"com.squareup.FooModule\", \"class\", EnumSet.noneOf(Modifier.class));\n+    javaWriter.beginType(\"com.squareup.FooModule\", \"class\");\n     javaWriter.endType();\n     assertCode(\"\"\n         + \"package com.squareup;\\n\"\n@@ -485,7 +485,7 @@ public final class JavaWriterTest {\n   @Test public void parameterizedType() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n     javaWriter.emitImports(\"java.util.Map\", \"java.util.Date\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\", EnumSet.noneOf(Modifier.class));\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n     javaWriter.emitField(\"java.util.Map<java.lang.String, java.util.Date>\", \"map\",\n         EnumSet.noneOf(Modifier.class));\n     javaWriter.endType();\n"
    },
    {
        "commit_hash": "a203a77e1de6dc01922e54712e701c0d8190616e",
        "previous_commit_hash": "721d8ac79c1e660d05577d94c32c7f86085c1866",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -272,7 +272,7 @@ public final class JavaWriter implements Closeable {\n       out.write(\" extends \");\n       emitType(extendsType);\n     }\n-    if ((implementsTypes != null) && (implementsTypes.length > 0)) {\n+    if (implementsTypes.length > 0) {\n       out.write(\"\\n\");\n       indent();\n       out.write(\"    implements \");\n"
    },
    {
        "commit_hash": "abf8024976130e6106507c59ffa944b35015d3b7",
        "previous_commit_hash": "a203a77e1de6dc01922e54712e701c0d8190616e",
        "diff_stats": {
            "additions": 2,
            "deletions": 1
        },
        "diff_content": "@@ -242,7 +242,8 @@ public final class JavaWriter implements Closeable {\n    *\n    * @param kind such as \"class\", \"interface\" or \"enum\".\n    */\n-  public JavaWriter beginType(String type, String kind, Set<Modifier> modifiers) throws IOException {\n+  public JavaWriter beginType(String type, String kind, Set<Modifier> modifiers)\n+      throws IOException {\n     return beginType(type, kind, modifiers, null);\n   }\n \n"
    },
    {
        "commit_hash": "161ae95d123cd7fdffc2173439aec3319124a149",
        "previous_commit_hash": "e873ce78e441995acd6df28677438093394fe387",
        "diff_stats": {
            "additions": 8,
            "deletions": 0
        },
        "diff_content": "@@ -1,6 +1,14 @@\n Change Log\n ==========\n \n+Version 2.1.0 *(2013-07-15)*\n+----------------------------\n+\n+ * New: All methods now take a `Set` of `Modifier`s rather than an `int`. The `int` methods are\n+   now deprecated for removal in version 3.0.\n+ * Annotations with a single \"value\" attribute will now omit the key.\n+\n+\n Version 2.0.1 *(2013-06-17)*\n ----------------------------\n \n"
    },
    {
        "commit_hash": "7325befff234704ca2f61090b3173a97cce609fe",
        "previous_commit_hash": "161ae95d123cd7fdffc2173439aec3319124a149",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javawriter</artifactId>\n-  <version>2.0.2-SNAPSHOT</version>\n+  <version>2.1.0</version>\n \n   <name>JavaWriter</name>\n   <description>A utility class which aids in generating Java source files.</description>\n"
    },
    {
        "commit_hash": "c4f1b0124950676c668a5cfeb87eb06d1714b10e",
        "previous_commit_hash": "7325befff234704ca2f61090b3173a97cce609fe",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javawriter</artifactId>\n-  <version>2.1.0</version>\n+  <version>2.1.1-SNAPSHOT</version>\n \n   <name>JavaWriter</name>\n   <description>A utility class which aids in generating Java source files.</description>\n"
    },
    {
        "commit_hash": "c567dc6891837ab745c557e6f3d9cf1c42c00e5a",
        "previous_commit_hash": "c4f1b0124950676c668a5cfeb87eb06d1714b10e",
        "diff_stats": {
            "additions": 4,
            "deletions": 4
        },
        "diff_content": "@@ -14,11 +14,11 @@ Example\n \n ```java\n writer.emitPackage(\"com.example\")\n-    .beginType(\"com.example.Person\", \"class\", PUBLIC | FINAL)\n-    .emitField(\"String\", \"firstName\", PRIVATE)\n-    .emitField(\"String\", \"lastName\", PRIVATE)\n+    .beginType(\"com.example.Person\", \"class\", EnumSet.of(PUBLIC, FINAL))\n+    .emitField(\"String\", \"firstName\", EnumSet.of(PRIVATE))\n+    .emitField(\"String\", \"lastName\", EnumSet.of(PRIVATE))\n     .emitJavadoc(\"Returns the person's full name.\")\n-    .beginMethod(\"String\", \"getName\", PUBLIC)\n+    .beginMethod(\"String\", \"getName\", EnumSet.of(PUBLIC))\n     .emitStatement(\"return firstName + \\\" \\\" + lastName;\")\n     .endMethod()\n     .endType();\n"
    },
    {
        "commit_hash": "5f4068a054d3e03d59a94862f34b384d79dc3b6d",
        "previous_commit_hash": "c567dc6891837ab745c557e6f3d9cf1c42c00e5a",
        "diff_stats": {
            "additions": 14,
            "deletions": 10
        },
        "diff_content": "@@ -680,23 +680,27 @@ public final class JavaWriter implements Closeable {\n         case '\\\\':\n           result.append(\"\\\\\\\\\");\n           break;\n-        case '\\t':\n-          result.append(\"\\\\\\t\");\n-          break;\n         case '\\b':\n-          result.append(\"\\\\\\b\");\n+          result.append(\"\\\\b\");\n           break;\n-        case '\\n':\n-          result.append(\"\\\\\\n\");\n+        case '\\t':\n+          result.append(\"\\\\t\");\n           break;\n-        case '\\r':\n-          result.append(\"\\\\\\r\");\n+        case '\\n':\n+          result.append(\"\\\\n\");\n           break;\n         case '\\f':\n-          result.append(\"\\\\\\f\");\n+          result.append(\"\\\\f\");\n+          break;\n+        case '\\r':\n+          result.append(\"\\\\r\");\n           break;\n         default:\n-          result.append(c);\n+          if (Character.isISOControl(c)) {\n+            result.append(String.format(\"\\\\u%04x\", (int) c));\n+          } else {\n+            result.append(c);\n+          }\n       }\n     }\n     result.append('\"');\n"
    },
    {
        "commit_hash": "5f4068a054d3e03d59a94862f34b384d79dc3b6d",
        "previous_commit_hash": "c567dc6891837ab745c557e6f3d9cf1c42c00e5a",
        "diff_stats": {
            "additions": 27,
            "deletions": 2
        },
        "diff_content": "@@ -527,8 +527,33 @@ public final class JavaWriterTest {\n     assertThat(JavaWriter.stringLiteral(\"JavaWriter\")).isEqualTo(\"\\\"JavaWriter\\\"\");\n     assertThat(JavaWriter.stringLiteral(\"\\\\\")).isEqualTo(\"\\\"\\\\\\\\\\\"\");\n     assertThat(JavaWriter.stringLiteral(\"\\\"\")).isEqualTo(\"\\\"\\\\\\\"\\\"\");\n-    assertThat(JavaWriter.stringLiteral(\"\\t\")).isEqualTo(\"\\\"\\\\\\t\\\"\");\n-    assertThat(JavaWriter.stringLiteral(\"\\n\")).isEqualTo(\"\\\"\\\\\\n\\\"\");\n+    assertThat(JavaWriter.stringLiteral(\"\\b\")).isEqualTo(\"\\\"\\\\b\\\"\");\n+    assertThat(JavaWriter.stringLiteral(\"\\t\")).isEqualTo(\"\\\"\\\\t\\\"\");\n+    assertThat(JavaWriter.stringLiteral(\"\\n\")).isEqualTo(\"\\\"\\\\n\\\"\");\n+    assertThat(JavaWriter.stringLiteral(\"\\f\")).isEqualTo(\"\\\"\\\\f\\\"\");\n+    assertThat(JavaWriter.stringLiteral(\"\\r\")).isEqualTo(\"\\\"\\\\r\\\"\");\n+\n+    // Control characters\n+    for (char i = 0x1; i <= 0x1f; i++) {\n+      checkCharEscape(i);\n+    }\n+    for (char i = 0x7f; i <= 0x9f; i++) {\n+      checkCharEscape(i);\n+    }\n+  }\n+\n+  private void checkCharEscape(char codePoint) {\n+    String test = \"\" + codePoint;\n+    String expected;\n+    switch (codePoint) {\n+      case 8: expected = \"\\\"\\\\b\\\"\"; break;\n+      case 9: expected = \"\\\"\\\\t\\\"\"; break;\n+      case 10: expected = \"\\\"\\\\n\\\"\"; break;\n+      case 12: expected = \"\\\"\\\\f\\\"\"; break;\n+      case 13: expected = \"\\\"\\\\r\\\"\"; break;\n+      default: expected = \"\\\"\\\\u\" + String.format(\"%04x\", (int) codePoint) + \"\\\"\";\n+    }\n+    assertThat(JavaWriter.stringLiteral(test)).isEqualTo(expected);\n   }\n \n   @Test public void testType() {\n"
    },
    {
        "commit_hash": "34f722fff1c0d4b4f5d6d9111c6ce98bb2605a72",
        "previous_commit_hash": "c37943b7be8ab364f4eeed9453a06679082a433c",
        "diff_stats": {
            "additions": 6,
            "deletions": 0
        },
        "diff_content": "@@ -1,6 +1,12 @@\n Change Log\n ==========\n \n+Version 2.1.1 *(2013-07-23)*\n+----------------------------\n+\n+ * Fix: `stringLiteral` now correctly handles escapes and control characters.\n+\n+\n Version 2.1.0 *(2013-07-15)*\n ----------------------------\n \n"
    },
    {
        "commit_hash": "84fd31ce9b407dbd1aaea1137dbffbb3065e9b87",
        "previous_commit_hash": "34f722fff1c0d4b4f5d6d9111c6ce98bb2605a72",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javawriter</artifactId>\n-  <version>2.1.1-SNAPSHOT</version>\n+  <version>2.1.1</version>\n \n   <name>JavaWriter</name>\n   <description>A utility class which aids in generating Java source files.</description>\n"
    },
    {
        "commit_hash": "bb64e88ef6b1d1c95c7891586e4f95c834274759",
        "previous_commit_hash": "84fd31ce9b407dbd1aaea1137dbffbb3065e9b87",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javawriter</artifactId>\n-  <version>2.1.1</version>\n+  <version>2.1.2-SNAPSHOT</version>\n \n   <name>JavaWriter</name>\n   <description>A utility class which aids in generating Java source files.</description>\n"
    },
    {
        "commit_hash": "3627ded9cbd309336d7dfbd09eef35ba62bbb617",
        "previous_commit_hash": "bb64e88ef6b1d1c95c7891586e4f95c834274759",
        "diff_stats": {
            "additions": 28,
            "deletions": 14
        },
        "diff_content": "@@ -34,6 +34,7 @@ import javax.lang.model.element.Modifier;\n /** A utility class which aids in generating Java source files. */\n public final class JavaWriter implements Closeable {\n   private static final Pattern TYPE_PATTERN = Pattern.compile(\"(?:[\\\\w$]+\\\\.)*([\\\\w\\\\.*$]+)\");\n+  private static final int MAX_SINGLE_LINE_ATTRIBUTES = 3;\n   private static final String INDENT = \"  \";\n \n   /** Map fully qualified type names to their short names. */\n@@ -527,32 +528,36 @@ public final class JavaWriter implements Closeable {\n         break;\n       case 1:\n         Entry<String, ?> onlyEntry = attributes.entrySet().iterator().next();\n-        if (\"value\".equals(onlyEntry.getKey())) {\n-          out.write(\"(\");\n-          emitAnnotationValue(onlyEntry.getValue());\n-          out.write(\")\");\n-          break;\n+        out.write(\"(\");\n+        if (!\"value\".equals(onlyEntry.getKey())) {\n+          out.write(onlyEntry.getKey());\n+          out.write(\" = \");\n         }\n+        emitAnnotationValue(onlyEntry.getValue());\n+        out.write(\")\");\n+        break;\n       default:\n+        boolean split = attributes.size() > MAX_SINGLE_LINE_ATTRIBUTES\n+            || containsArray(attributes.values());\n         out.write(\"(\");\n         pushScope(Scope.ANNOTATION_ATTRIBUTE);\n-        boolean firstAttribute = true;\n+        String separator = split ? \"\\n\" : \"\";\n         for (Map.Entry<String, ?> entry : attributes.entrySet()) {\n-          if (firstAttribute) {\n-            firstAttribute = false;\n-            out.write(\"\\n\");\n-          } else {\n-            out.write(\",\\n\");\n+          out.write(separator);\n+          separator = split ? \",\\n\" : \", \";\n+          if (split) {\n+            indent();\n           }\n-          indent();\n           out.write(entry.getKey());\n           out.write(\" = \");\n           Object value = entry.getValue();\n           emitAnnotationValue(value);\n         }\n         popScope(Scope.ANNOTATION_ATTRIBUTE);\n-        out.write(\"\\n\");\n-        indent();\n+        if (split) {\n+          out.write(\"\\n\");\n+          indent();\n+        }\n         out.write(\")\");\n         break;\n     }\n@@ -560,6 +565,15 @@ public final class JavaWriter implements Closeable {\n     return this;\n   }\n \n+  private boolean containsArray(Collection<?> values) {\n+    for (Object value : values) {\n+      if (value instanceof Object[]) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n   /**\n    * Writes a single annotation value. If the value is an array, each element in the array will be\n    * written to its own line.\n"
    },
    {
        "commit_hash": "3627ded9cbd309336d7dfbd09eef35ba62bbb617",
        "previous_commit_hash": "bb64e88ef6b1d1c95c7891586e4f95c834274759",
        "diff_stats": {
            "additions": 36,
            "deletions": 3
        },
        "diff_content": "@@ -433,9 +433,7 @@ public final class JavaWriterTest {\n     assertCode(\"\"\n         + \"package com.squareup;\\n\"\n         + \"\\n\"\n-        + \"@Module(\\n\"\n-        + \"  overrides = true\\n\"\n-        + \")\\n\"\n+        + \"@Module(overrides = true)\\n\"\n         + \"class FooModule {\\n\"\n         + \"}\\n\");\n   }\n@@ -456,6 +454,41 @@ public final class JavaWriterTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void annotatedWithTwoNonArrayAttributes() throws IOException {\n+    Map<String, Object> attributes = new LinkedHashMap<String, Object>();\n+    attributes.put(\"overrides\", true);\n+    attributes.put(\"foo\", \"bar\");\n+\n+    javaWriter.emitPackage(\"com.squareup\");\n+    javaWriter.emitAnnotation(\"Module\", attributes);\n+    javaWriter.beginType(\"com.squareup.FooModule\", \"class\", EnumSet.noneOf(Modifier.class));\n+    javaWriter.endType();\n+    assertCode(\"\"\n+        + \"package com.squareup;\\n\"\n+        + \"\\n\"\n+        + \"@Module(overrides = true, foo = bar)\\n\"\n+        + \"class FooModule {\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void annotatedWithThreeNonArrayAttributes() throws IOException {\n+    Map<String, Object> attributes = new LinkedHashMap<String, Object>();\n+    attributes.put(\"overrides\", true);\n+    attributes.put(\"foo\", \"bar\");\n+    attributes.put(\"bar\", \"baz\");\n+\n+    javaWriter.emitPackage(\"com.squareup\");\n+    javaWriter.emitAnnotation(\"Module\", attributes);\n+    javaWriter.beginType(\"com.squareup.FooModule\", \"class\", EnumSet.noneOf(Modifier.class));\n+    javaWriter.endType();\n+    assertCode(\"\"\n+        + \"package com.squareup;\\n\"\n+        + \"\\n\"\n+        + \"@Module(overrides = true, foo = bar, bar = baz)\\n\"\n+        + \"class FooModule {\\n\"\n+        + \"}\\n\");\n+  }\n+\n   @Test public void annotatedWithAttributes() throws IOException {\n     Map<String, Object> attributes = new LinkedHashMap<String, Object>();\n     attributes.put(\"overrides\", true);\n"
    },
    {
        "commit_hash": "2ca0bef491c80675f10b586d1264b317f1f52181",
        "previous_commit_hash": "9d72297471d954536e2898fb37ef23300f0628ac",
        "diff_stats": {
            "additions": 6,
            "deletions": 0
        },
        "diff_content": "@@ -1,6 +1,12 @@\n Change Log\n ==========\n \n+Version 2.1.2 *(2013-08-23)*\n+----------------------------\n+\n+ * Attempt to keep annotations on a single line.\n+\n+\n Version 2.1.1 *(2013-07-23)*\n ----------------------------\n \n"
    },
    {
        "commit_hash": "1746b5ca6600869ad1275c545368eff0ef2609e9",
        "previous_commit_hash": "2ca0bef491c80675f10b586d1264b317f1f52181",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javawriter</artifactId>\n-  <version>2.1.2-SNAPSHOT</version>\n+  <version>2.1.2</version>\n \n   <name>JavaWriter</name>\n   <description>A utility class which aids in generating Java source files.</description>\n"
    },
    {
        "commit_hash": "2a693db7cfab45092a6ba2b1b9051228c7055688",
        "previous_commit_hash": "1746b5ca6600869ad1275c545368eff0ef2609e9",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javawriter</artifactId>\n-  <version>2.1.2</version>\n+  <version>2.1.3-SNAPSHOT</version>\n \n   <name>JavaWriter</name>\n   <description>A utility class which aids in generating Java source files.</description>\n"
    },
    {
        "commit_hash": "1f074c73cf421cbb12fae3ff4c255f7b72cb3de7",
        "previous_commit_hash": "2a693db7cfab45092a6ba2b1b9051228c7055688",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -19,7 +19,7 @@ writer.emitPackage(\"com.example\")\n     .emitField(\"String\", \"lastName\", EnumSet.of(PRIVATE))\n     .emitJavadoc(\"Returns the person's full name.\")\n     .beginMethod(\"String\", \"getName\", EnumSet.of(PUBLIC))\n-    .emitStatement(\"return firstName + \\\" \\\" + lastName;\")\n+    .emitStatement(\"return firstName + \\\" \\\" + lastName\")\n     .endMethod()\n     .endType();\n ```\n@@ -36,7 +36,7 @@ public final class Person {\n    * Returns the person's full name.\n    */\n   public String getName() {\n-    return firstName + \" \" + lastName;;\n+    return firstName + \" \" + lastName;\n   }\n }\n ```\n"
    },
    {
        "commit_hash": "f325443660ccd746d982ef396f3b93ad61db8cbd",
        "previous_commit_hash": "bfcf4f63b10d57fb8f70a1674a0294dbab679a11",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -1,6 +1,7 @@\n .classpath\n .project\n .settings\n+.checkstyle\n eclipsebin\n \n bin\n"
    },
    {
        "commit_hash": "f325443660ccd746d982ef396f3b93ad61db8cbd",
        "previous_commit_hash": "bfcf4f63b10d57fb8f70a1674a0294dbab679a11",
        "diff_stats": {
            "additions": 29,
            "deletions": 15
        },
        "diff_content": "@@ -32,7 +32,7 @@ import java.util.regex.Pattern;\n import javax.lang.model.element.Modifier;\n \n /** A utility class which aids in generating Java source files. */\n-public final class JavaWriter implements Closeable {\n+public class JavaWriter implements Closeable {\n   private static final Pattern TYPE_PATTERN = Pattern.compile(\"(?:[\\\\w$]+\\\\.)*([\\\\w\\\\.*$]+)\");\n   private static final int MAX_SINGLE_LINE_ATTRIBUTES = 3;\n   private static final String INDENT = \"  \";\n@@ -43,6 +43,7 @@ public final class JavaWriter implements Closeable {\n   private String packagePrefix;\n   private final List<Scope> scopes = new ArrayList<Scope>();\n   private final Writer out;\n+  private boolean isCompressingTypes = true;\n \n   /**\n    * @param out the stream to which Java source will be written. This should be a buffered stream.\n@@ -51,6 +52,14 @@ public final class JavaWriter implements Closeable {\n     this.out = out;\n   }\n \n+  public void setCompressingTypes(boolean isCompressingTypes) {\n+    this.isCompressingTypes = isCompressingTypes;\n+  }\n+\n+  public boolean isCompressingTypes() {\n+    return isCompressingTypes;\n+  }\n+\n   /** Emit a package declaration and empty line. */\n   public JavaWriter emitPackage(String packageName) throws IOException {\n     if (this.packagePrefix != null) {\n@@ -125,10 +134,15 @@ public final class JavaWriter implements Closeable {\n \n   /**\n    * Emits a name like {@code java.lang.String} or {@code java.util.List<java.lang.String>},\n-   * shorting it with imports if possible.\n+   * compressing it with imports if possible. Type compression will only be enabled if\n+   * {@link #isCompressingTypes} is true.\n    */\n-  private JavaWriter emitType(String type) throws IOException {\n-    out.write(compressType(type));\n+  private JavaWriter emitCompressedType(String type) throws IOException {\n+    if (isCompressingTypes) {\n+      out.write(compressType(type));\n+    } else {\n+      out.write(type);\n+    }\n     return this;\n   }\n \n@@ -269,10 +283,10 @@ public final class JavaWriter implements Closeable {\n     emitModifiers(modifiers);\n     out.write(kind);\n     out.write(\" \");\n-    emitType(type);\n+    emitCompressedType(type);\n     if (extendsType != null) {\n       out.write(\" extends \");\n-      emitType(extendsType);\n+      emitCompressedType(extendsType);\n     }\n     if (implementsTypes.length > 0) {\n       out.write(\"\\n\");\n@@ -282,7 +296,7 @@ public final class JavaWriter implements Closeable {\n         if (i != 0) {\n           out.write(\", \");\n         }\n-        emitType(implementsTypes[i]);\n+        emitCompressedType(implementsTypes[i]);\n       }\n     }\n     out.write(\" {\\n\");\n@@ -330,7 +344,7 @@ public final class JavaWriter implements Closeable {\n       String initialValue) throws IOException {\n     indent();\n     emitModifiers(modifiers);\n-    emitType(type);\n+    emitCompressedType(type);\n     out.write(\" \");\n     out.write(name);\n \n@@ -388,11 +402,11 @@ public final class JavaWriter implements Closeable {\n     indent();\n     emitModifiers(modifiers);\n     if (returnType != null) {\n-      emitType(returnType);\n+      emitCompressedType(returnType);\n       out.write(\" \");\n       out.write(name);\n     } else {\n-      emitType(name);\n+      emitCompressedType(name);\n     }\n     out.write(\"(\");\n     if (parameters != null) {\n@@ -400,9 +414,9 @@ public final class JavaWriter implements Closeable {\n         if (p != 0) {\n           out.write(\", \");\n         }\n-        emitType(parameters.get(p++));\n+        emitCompressedType(parameters.get(p++));\n         out.write(\" \");\n-        emitType(parameters.get(p++));\n+        emitCompressedType(parameters.get(p++));\n       }\n     }\n     out.write(\")\");\n@@ -414,7 +428,7 @@ public final class JavaWriter implements Closeable {\n         if (i != 0) {\n           out.write(\", \");\n         }\n-        emitType(throwsTypes.get(i));\n+        emitCompressedType(throwsTypes.get(i));\n       }\n     }\n     if (modifiers.contains(ABSTRACT)) {\n@@ -497,7 +511,7 @@ public final class JavaWriter implements Closeable {\n   public JavaWriter emitAnnotation(String annotation, Object value) throws IOException {\n     indent();\n     out.write(\"@\");\n-    emitType(annotation);\n+    emitCompressedType(annotation);\n     out.write(\"(\");\n     emitAnnotationValue(value);\n     out.write(\")\");\n@@ -522,7 +536,7 @@ public final class JavaWriter implements Closeable {\n       throws IOException {\n     indent();\n     out.write(\"@\");\n-    emitType(annotation);\n+    emitCompressedType(annotation);\n     switch (attributes.size()) {\n       case 0:\n         break;\n"
    },
    {
        "commit_hash": "fc70ff2e7bd28eb81138e23bc903e85a5fbb6601",
        "previous_commit_hash": "7076421ad25890d6163e2f639af3339ce3e7a18f",
        "diff_stats": {
            "additions": 6,
            "deletions": 0
        },
        "diff_content": "@@ -1,6 +1,12 @@\n Change Log\n ==========\n \n+Version 2.2.0 *(2013-09-25)*\n+----------------------------\n+\n+ * `setCompressingTypes` controls whether types are emitted as fully-qualified or not.\n+\n+\n Version 2.1.2 *(2013-08-23)*\n ----------------------------\n \n"
    },
    {
        "commit_hash": "e3779806d57b3d0f5ab168f49967e97f90ea22e1",
        "previous_commit_hash": "fc70ff2e7bd28eb81138e23bc903e85a5fbb6601",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javawriter</artifactId>\n-  <version>2.1.3-SNAPSHOT</version>\n+  <version>2.2.0</version>\n \n   <name>JavaWriter</name>\n   <description>A utility class which aids in generating Java source files.</description>\n"
    },
    {
        "commit_hash": "75ffabac0789b5b410a994ed03f939aefc5e9fbe",
        "previous_commit_hash": "e3779806d57b3d0f5ab168f49967e97f90ea22e1",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javawriter</artifactId>\n-  <version>2.2.0</version>\n+  <version>2.2.1-SNAPSHOT</version>\n \n   <name>JavaWriter</name>\n   <description>A utility class which aids in generating Java source files.</description>\n"
    },
    {
        "commit_hash": "557953ee634605ca64dacf3169825aab4e476553",
        "previous_commit_hash": "75ffabac0789b5b410a994ed03f939aefc5e9fbe",
        "diff_stats": {
            "additions": 11,
            "deletions": 2
        },
        "diff_content": "@@ -44,6 +44,7 @@ public class JavaWriter implements Closeable {\n   private final List<Scope> scopes = new ArrayList<Scope>();\n   private final Writer out;\n   private boolean isCompressingTypes = true;\n+  private String indent = INDENT;\n \n   /**\n    * @param out the stream to which Java source will be written. This should be a buffered stream.\n@@ -60,6 +61,14 @@ public class JavaWriter implements Closeable {\n     return isCompressingTypes;\n   }\n \n+  public void setIndent(int indent) {\n+    this.indent = new String(new char[indent]).replace(\"\\0\", \" \");\n+  }\n+\n+  public int getIndent() {\n+    return indent.length();\n+  }\n+\n   /** Emit a package declaration and empty line. */\n   public JavaWriter emitPackage(String packageName) throws IOException {\n     if (this.packagePrefix != null) {\n@@ -808,13 +817,13 @@ public class JavaWriter implements Closeable {\n \n   private void indent() throws IOException {\n     for (int i = 0, count = scopes.size(); i < count; i++) {\n-      out.write(INDENT);\n+      out.write(indent);\n     }\n   }\n \n   private void hangingIndent() throws IOException {\n     for (int i = 0, count = scopes.size() + 2; i < count; i++) {\n-      out.write(INDENT);\n+      out.write(indent);\n     }\n   }\n \n"
    },
    {
        "commit_hash": "557953ee634605ca64dacf3169825aab4e476553",
        "previous_commit_hash": "75ffabac0789b5b410a994ed03f939aefc5e9fbe",
        "diff_stats": {
            "additions": 14,
            "deletions": 0
        },
        "diff_content": "@@ -644,6 +644,20 @@ public final class JavaWriterTest {\n     assertThat(actual).isEqualTo(\"Binding<denominator.Provider>\");\n   }\n \n+  @Test public void configurableIndent() throws IOException {\n+    javaWriter.setIndent(4);\n+    javaWriter.emitPackage(\"com.squareup\");\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n+    javaWriter.emitField(\"String\", \"bar\");\n+    javaWriter.endType();\n+    assertCode(\"\"\n+        + \"package com.squareup;\\n\"\n+        + \"\\n\"\n+        + \"class Foo {\\n\"\n+        + \"    String bar;\\n\"\n+        + \"}\\n\");\n+  }\n+    \n   private void assertCode(String expected) {\n     assertThat(stringWriter.toString()).isEqualTo(expected);\n   }\n"
    },
    {
        "commit_hash": "ad20665e8c915a93c0e8c584b3d4aa40acf04808",
        "previous_commit_hash": "557953ee634605ca64dacf3169825aab4e476553",
        "diff_stats": {
            "additions": 4,
            "deletions": 4
        },
        "diff_content": "@@ -61,12 +61,12 @@ public class JavaWriter implements Closeable {\n     return isCompressingTypes;\n   }\n \n-  public void setIndent(int indent) {\n-    this.indent = new String(new char[indent]).replace(\"\\0\", \" \");\n+  public void setIndent(String indent) {\n+    this.indent = indent;\n   }\n \n-  public int getIndent() {\n-    return indent.length();\n+  public String getIndent() {\n+    return indent;\n   }\n \n   /** Emit a package declaration and empty line. */\n"
    },
    {
        "commit_hash": "ad20665e8c915a93c0e8c584b3d4aa40acf04808",
        "previous_commit_hash": "557953ee634605ca64dacf3169825aab4e476553",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -645,7 +645,7 @@ public final class JavaWriterTest {\n   }\n \n   @Test public void configurableIndent() throws IOException {\n-    javaWriter.setIndent(4);\n+    javaWriter.setIndent(\"    \");\n     javaWriter.emitPackage(\"com.squareup\");\n     javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n     javaWriter.emitField(\"String\", \"bar\");\n"
    },
    {
        "commit_hash": "84b729851e5e44784ac0f3681d9261dc8a40d214",
        "previous_commit_hash": "75ffabac0789b5b410a994ed03f939aefc5e9fbe",
        "diff_stats": {
            "additions": 7,
            "deletions": 0
        },
        "diff_content": "@@ -479,6 +479,13 @@ public class JavaWriter implements Closeable {\n     return this;\n   }\n \n+  public JavaWriter emitLastEnumValue(String name) throws IOException {\n+    indent();\n+    out.write(name);\n+    out.write(\";\\n\");\n+    return this;\n+  }\n+\n   /** Equivalent to {@code annotation(annotation, emptyMap())}. */\n   public JavaWriter emitAnnotation(String annotation) throws IOException {\n     return emitAnnotation(annotation, Collections.<String, Object>emptyMap());\n"
    },
    {
        "commit_hash": "84b729851e5e44784ac0f3681d9261dc8a40d214",
        "previous_commit_hash": "75ffabac0789b5b410a994ed03f939aefc5e9fbe",
        "diff_stats": {
            "additions": 19,
            "deletions": 0
        },
        "diff_content": "@@ -55,6 +55,25 @@ public final class JavaWriterTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void enumDeclarationWithMethod() throws IOException{\n+    javaWriter.emitPackage(\"com.squareup\");\n+    javaWriter.beginType(\"com.squareup.Foo\", \"enum\", EnumSet.of(PUBLIC));\n+    javaWriter.emitEnumValue(\"BAR\");\n+    javaWriter.emitLastEnumValue(\"BAZ\");\n+    javaWriter.beginMethod(\"void\", \"foo\", EnumSet.of(PUBLIC));\n+    javaWriter.endMethod();\n+    javaWriter.endType();\n+    assertCode(\"\"\n+        + \"package com.squareup;\\n\"\n+        + \"\\n\"\n+        + \"public enum Foo {\\n\"\n+        + \"  BAR,\\n\"\n+        + \"  BAZ;\\n\"\n+        + \"  public void foo() {\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n   @Test public void fieldDeclaration() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n     javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n"
    },
    {
        "commit_hash": "1cd91ed6bd46557e7ca23145e99353b7ca7cde38",
        "previous_commit_hash": "75ffabac0789b5b410a994ed03f939aefc5e9fbe",
        "diff_stats": {
            "additions": 10,
            "deletions": 11
        },
        "diff_content": "@@ -1,16 +1,6 @@\n // Copyright 2013 Square, Inc.\n package com.squareup.javawriter;\n \n-import static javax.lang.model.element.Modifier.ABSTRACT;\n-import static javax.lang.model.element.Modifier.FINAL;\n-import static javax.lang.model.element.Modifier.PRIVATE;\n-import static javax.lang.model.element.Modifier.PROTECTED;\n-import static javax.lang.model.element.Modifier.PUBLIC;\n-import static javax.lang.model.element.Modifier.STATIC;\n-import static javax.lang.model.element.Modifier.SYNCHRONIZED;\n-import static javax.lang.model.element.Modifier.TRANSIENT;\n-import static javax.lang.model.element.Modifier.VOLATILE;\n-\n import java.io.Closeable;\n import java.io.IOException;\n import java.io.Writer;\n@@ -28,9 +18,18 @@ import java.util.Set;\n import java.util.TreeSet;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n-\n import javax.lang.model.element.Modifier;\n \n+import static javax.lang.model.element.Modifier.ABSTRACT;\n+import static javax.lang.model.element.Modifier.FINAL;\n+import static javax.lang.model.element.Modifier.PRIVATE;\n+import static javax.lang.model.element.Modifier.PROTECTED;\n+import static javax.lang.model.element.Modifier.PUBLIC;\n+import static javax.lang.model.element.Modifier.STATIC;\n+import static javax.lang.model.element.Modifier.SYNCHRONIZED;\n+import static javax.lang.model.element.Modifier.TRANSIENT;\n+import static javax.lang.model.element.Modifier.VOLATILE;\n+\n /** A utility class which aids in generating Java source files. */\n public class JavaWriter implements Closeable {\n   private static final Pattern TYPE_PATTERN = Pattern.compile(\"(?:[\\\\w$]+\\\\.)*([\\\\w\\\\.*$]+)\");\n"
    },
    {
        "commit_hash": "1cd91ed6bd46557e7ca23145e99353b7ca7cde38",
        "previous_commit_hash": "75ffabac0789b5b410a994ed03f939aefc5e9fbe",
        "diff_stats": {
            "additions": 9,
            "deletions": 12
        },
        "diff_content": "@@ -1,15 +1,7 @@\n // Copyright 2013 Square, Inc.\n package com.squareup.javawriter;\n \n-import static com.squareup.javawriter.JavaWriter.stringLiteral;\n-import static javax.lang.model.element.Modifier.ABSTRACT;\n-import static javax.lang.model.element.Modifier.FINAL;\n-import static javax.lang.model.element.Modifier.PRIVATE;\n-import static javax.lang.model.element.Modifier.PUBLIC;\n-import static javax.lang.model.element.Modifier.STATIC;\n-import static org.fest.assertions.api.Assertions.assertThat;\n-import static org.fest.assertions.api.Assertions.failBecauseExceptionWasNotThrown;\n-\n+import com.example.Binding;\n import java.io.IOException;\n import java.io.StringWriter;\n import java.util.Arrays;\n@@ -18,12 +10,17 @@ import java.util.EnumSet;\n import java.util.LinkedHashMap;\n import java.util.Map;\n import java.util.Set;\n-\n import javax.lang.model.element.Modifier;\n-\n import org.junit.Test;\n \n-import com.example.Binding;\n+import static com.squareup.javawriter.JavaWriter.stringLiteral;\n+import static javax.lang.model.element.Modifier.ABSTRACT;\n+import static javax.lang.model.element.Modifier.FINAL;\n+import static javax.lang.model.element.Modifier.PRIVATE;\n+import static javax.lang.model.element.Modifier.PUBLIC;\n+import static javax.lang.model.element.Modifier.STATIC;\n+import static org.fest.assertions.api.Assertions.assertThat;\n+import static org.fest.assertions.api.Assertions.failBecauseExceptionWasNotThrown;\n \n public final class JavaWriterTest {\n   private final StringWriter stringWriter = new StringWriter();\n"
    },
    {
        "commit_hash": "4847848f804a3723291c2104af14aadca2d9ce86",
        "previous_commit_hash": "1cd91ed6bd46557e7ca23145e99353b7ca7cde38",
        "diff_stats": {
            "additions": 5,
            "deletions": 2
        },
        "diff_content": "@@ -448,8 +448,11 @@ public class JavaWriter implements Closeable {\n     out.write(\"/**\\n\");\n     for (String line : formatted.split(\"\\n\")) {\n       indent();\n-      out.write(\" * \");\n-      out.write(line);\n+      out.write(\" *\");\n+      if (!line.isEmpty()) {\n+        out.write(\" \");\n+        out.write(line);\n+      }\n       out.write(\"\\n\");\n     }\n     indent();\n"
    },
    {
        "commit_hash": "4847848f804a3723291c2104af14aadca2d9ce86",
        "previous_commit_hash": "1cd91ed6bd46557e7ca23145e99353b7ca7cde38",
        "diff_stats": {
            "additions": 11,
            "deletions": 0
        },
        "diff_content": "@@ -552,6 +552,17 @@ public final class JavaWriterTest {\n         + \" */\\n\");\n   }\n \n+  @Test public void multilineJavadocDoesNotEmitTrailingSpaceForEmptyLines() throws IOException {\n+    javaWriter.emitJavadoc(\"Foo\\n\\nBar\");\n+    assertCode(\"\"\n+        + \"/**\\n\"\n+        + \" * Foo\\n\"\n+        + \" *\\n\"\n+        + \" * Bar\\n\"\n+        + \" */\\n\"\n+    );\n+  }\n+\n   @Test public void testStringLiteral() {\n     assertThat(JavaWriter.stringLiteral(\"\")).isEqualTo(\"\\\"\\\"\");\n     assertThat(JavaWriter.stringLiteral(\"JavaWriter\")).isEqualTo(\"\\\"JavaWriter\\\"\");\n"
    },
    {
        "commit_hash": "d7fb4160f0d20bffb75ee2710f2b025fab071a7c",
        "previous_commit_hash": "4847848f804a3723291c2104af14aadca2d9ce86",
        "diff_stats": {
            "additions": 6,
            "deletions": 0
        },
        "diff_content": "@@ -1,6 +1,12 @@\n Change Log\n ==========\n \n+Version 2.2.1 *(2013-10-23)*\n+----------------------------\n+\n+ * Fix: Do not emit trailing whitespace for empty Javadoc lines.\n+\n+\n Version 2.2.0 *(2013-09-25)*\n ----------------------------\n \n"
    },
    {
        "commit_hash": "d9098957bf1c50aacb4dcb311a963392bd38515a",
        "previous_commit_hash": "645210f23a39f2bad3e00278bbcc2b232d4cd94d",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javawriter</artifactId>\n-  <version>2.2.1-SNAPSHOT</version>\n+  <version>2.2.1</version>\n \n   <name>JavaWriter</name>\n   <description>A utility class which aids in generating Java source files.</description>\n"
    },
    {
        "commit_hash": "496986a88f8b0c881d351fd31473a26dcd27fbe2",
        "previous_commit_hash": "d9098957bf1c50aacb4dcb311a963392bd38515a",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javawriter</artifactId>\n-  <version>2.2.1</version>\n+  <version>2.2.2-SNAPSHOT</version>\n \n   <name>JavaWriter</name>\n   <description>A utility class which aids in generating Java source files.</description>\n"
    },
    {
        "commit_hash": "253f56305040657d6c1200a52845d8d0ce5e5512",
        "previous_commit_hash": "041d3f93cf90b7e4bde84f990a938e16a20ef2fc",
        "diff_stats": {
            "additions": 3,
            "deletions": 99
        },
        "diff_content": "@@ -1,6 +1,8 @@\n // Copyright 2013 Square, Inc.\n package com.squareup.javawriter;\n \n+import static javax.lang.model.element.Modifier.ABSTRACT;\n+\n import java.io.Closeable;\n import java.io.IOException;\n import java.io.Writer;\n@@ -18,17 +20,8 @@ import java.util.Set;\n import java.util.TreeSet;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n-import javax.lang.model.element.Modifier;\n \n-import static javax.lang.model.element.Modifier.ABSTRACT;\n-import static javax.lang.model.element.Modifier.FINAL;\n-import static javax.lang.model.element.Modifier.PRIVATE;\n-import static javax.lang.model.element.Modifier.PROTECTED;\n-import static javax.lang.model.element.Modifier.PUBLIC;\n-import static javax.lang.model.element.Modifier.STATIC;\n-import static javax.lang.model.element.Modifier.SYNCHRONIZED;\n-import static javax.lang.model.element.Modifier.TRANSIENT;\n-import static javax.lang.model.element.Modifier.VOLATILE;\n+import javax.lang.model.element.Modifier;\n \n /** A utility class which aids in generating Java source files. */\n public class JavaWriter implements Closeable {\n@@ -252,14 +245,6 @@ public class JavaWriter implements Closeable {\n     return beginType(type, kind, EnumSet.noneOf(Modifier.class), null);\n   }\n \n-  /**\n-   * @deprecated Use {@link #beginType(String, String, Set)}\n-   */\n-  @Deprecated\n-  public JavaWriter beginType(String type, String kind, int modifiers) throws IOException {\n-    return beginType(type, kind, modifiersAsSet(modifiers), null);\n-  }\n-\n   /**\n    * Emits a type declaration.\n    *\n@@ -270,15 +255,6 @@ public class JavaWriter implements Closeable {\n     return beginType(type, kind, modifiers, null);\n   }\n \n-  /**\n-   * @deprecated Use {@link #beginType(String, String, Set, String, String...)}\n-   */\n-  @Deprecated\n-  public JavaWriter beginType(String type, String kind, int modifiers, String extendsType,\n-      String... implementsTypes) throws IOException {\n-    return beginType(type, kind, modifiersAsSet(modifiers), extendsType, implementsTypes);\n-  }\n-\n   /**\n    * Emits a type declaration.\n    *\n@@ -325,29 +301,12 @@ public class JavaWriter implements Closeable {\n     return emitField(type, name, EnumSet.noneOf(Modifier.class), null);\n   }\n \n-  /**\n-   * @deprecated Use {@link #emitField(String, String, Set)}.\n-   */\n-  @Deprecated\n-  public JavaWriter emitField(String type, String name, int modifiers) throws IOException {\n-    return emitField(type, name, modifiersAsSet(modifiers), null);\n-  }\n-\n   /** Emits a field declaration. */\n   public JavaWriter emitField(String type, String name, Set<Modifier> modifiers)\n       throws IOException {\n     return emitField(type, name, modifiers, null);\n   }\n \n-  /**\n-   * @deprecated Use {@link #emitField(String, String, Set, String)}.\n-   */\n-  @Deprecated\n-  public JavaWriter emitField(String type, String name, int modifiers, String initialValue)\n-      throws IOException {\n-    return emitField(type, name, modifiersAsSet(modifiers), initialValue);\n-  }\n-\n   public JavaWriter emitField(String type, String name, Set<Modifier> modifiers,\n       String initialValue) throws IOException {\n     indent();\n@@ -364,16 +323,6 @@ public class JavaWriter implements Closeable {\n     return this;\n   }\n \n-  /**\n-   * @deprecated Use {@link #beginMethod(String, String, Set, String...)}.\n-   */\n-  @Deprecated\n-  public JavaWriter beginMethod(String returnType, String name, int modifiers, String... parameters)\n-      throws IOException {\n-    return beginMethod(returnType, name, modifiersAsSet(modifiers), Arrays.asList(parameters),\n-        null);\n-  }\n-\n   /**\n    * Emit a method declaration.\n    *\n@@ -387,15 +336,6 @@ public class JavaWriter implements Closeable {\n     return beginMethod(returnType, name, modifiers, Arrays.asList(parameters), null);\n   }\n \n-  /**\n-   * @deprecated Use {@link #beginMethod(String, String, Set, List, List)}.\n-   */\n-  @Deprecated\n-  public JavaWriter beginMethod(String returnType, String name, int modifiers,\n-      List<String> parameters, List<String> throwsTypes) throws IOException {\n-    return beginMethod(returnType, name, modifiersAsSet(modifiers), parameters, throwsTypes);\n-  }\n-\n   /**\n    * Emit a method declaration.\n    *\n@@ -781,42 +721,6 @@ public class JavaWriter implements Closeable {\n     }\n   }\n \n-  /**\n-   * Returns a set of modifiers for an {@code int} encoded with the values in\n-   * {@link java.lang.reflect.Modifier}.\n-   */\n-  private static EnumSet<Modifier> modifiersAsSet(int modifiers) {\n-    EnumSet<Modifier> modifierSet = EnumSet.noneOf(Modifier.class);\n-    if ((modifiers & java.lang.reflect.Modifier.PUBLIC) != 0) {\n-      modifierSet.add(PUBLIC);\n-    }\n-    if ((modifiers & java.lang.reflect.Modifier.PRIVATE) != 0) {\n-      modifierSet.add(PRIVATE);\n-    }\n-    if ((modifiers & java.lang.reflect.Modifier.PROTECTED) != 0) {\n-      modifierSet.add(PROTECTED);\n-    }\n-    if ((modifiers & java.lang.reflect.Modifier.STATIC) != 0) {\n-      modifierSet.add(STATIC);\n-    }\n-    if ((modifiers & java.lang.reflect.Modifier.FINAL) != 0) {\n-      modifierSet.add(FINAL);\n-    }\n-    if ((modifiers & java.lang.reflect.Modifier.ABSTRACT) != 0) {\n-      modifierSet.add(ABSTRACT);\n-    }\n-    if ((modifiers & java.lang.reflect.Modifier.SYNCHRONIZED) != 0) {\n-      modifierSet.add(SYNCHRONIZED);\n-    }\n-    if ((modifiers & java.lang.reflect.Modifier.TRANSIENT) != 0) {\n-      modifierSet.add(TRANSIENT);\n-    }\n-    if ((modifiers & java.lang.reflect.Modifier.VOLATILE) != 0) {\n-      modifierSet.add(VOLATILE);\n-    }\n-    return modifierSet;\n-  }\n-\n   private void indent() throws IOException {\n     for (int i = 0, count = scopes.size(); i < count; i++) {\n       out.write(indent);\n"
    },
    {
        "commit_hash": "4c31ac8d8db53ac373c2d7c818e3c77730971fbf",
        "previous_commit_hash": "71e6bc2a4b22cfed6d35f75a623384358fd069a8",
        "diff_stats": {
            "additions": 50,
            "deletions": 27
        },
        "diff_content": "@@ -7,10 +7,11 @@ import java.io.Closeable;\n import java.io.IOException;\n import java.io.Writer;\n import java.lang.annotation.Annotation;\n-import java.util.ArrayList;\n+import java.util.ArrayDeque;\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.Deque;\n import java.util.EnumSet;\n import java.util.LinkedHashMap;\n import java.util.List;\n@@ -33,7 +34,8 @@ public class JavaWriter implements Closeable {\n   private final Map<String, String> importedTypes = new LinkedHashMap<String, String>();\n \n   private String packagePrefix;\n-  private final List<Scope> scopes = new ArrayList<Scope>();\n+  private final Deque<Scope> scopes = new ArrayDeque<Scope>();\n+  private final Deque<String> types = new ArrayDeque<String>();\n   private final Writer out;\n   private boolean isCompressingTypes = true;\n   private String indent = INDENT;\n@@ -224,7 +226,7 @@ public class JavaWriter implements Closeable {\n     } else {\n       out.write(\"{\\n\");\n     }\n-    pushScope(Scope.INITIALIZER);\n+    scopes.push(Scope.INITIALIZER);\n     return this;\n   }\n \n@@ -284,13 +286,15 @@ public class JavaWriter implements Closeable {\n       }\n     }\n     out.write(\" {\\n\");\n-    pushScope(Scope.TYPE_DECLARATION);\n+    scopes.push(Scope.TYPE_DECLARATION);\n+    types.push(type);\n     return this;\n   }\n \n   /** Completes the current type declaration. */\n   public JavaWriter endType() throws IOException {\n     popScope(Scope.TYPE_DECLARATION);\n+    types.pop();\n     indent();\n     out.write(\"}\\n\");\n     return this;\n@@ -326,7 +330,11 @@ public class JavaWriter implements Closeable {\n   /**\n    * Emit a method declaration.\n    *\n-   * @param returnType the method's return type, or null for constructors.\n+   * <p>A {@code null} return type may be used to indicate a constructor, but\n+   * {@link #beginConstructor(Set, String...)} should be preferred. This behavior may be removed in\n+   * a future release.\n+   *\n+   * @param returnType the method's return type, or null for constructors\n    * @param name the method name, or the fully qualified class name for constructors.\n    * @param modifiers the set of modifiers to be applied to the method\n    * @param parameters alternating parameter types and names.\n@@ -339,6 +347,10 @@ public class JavaWriter implements Closeable {\n   /**\n    * Emit a method declaration.\n    *\n+   * <p>A {@code null} return type may be used to indicate a constructor, but\n+   * {@link #beginConstructor(Set, List, List)} should be preferred. This behavior may be removed in\n+   * a future release.\n+   *\n    * @param returnType the method's return type, or null for constructors.\n    * @param name the method name, or the fully qualified class name for constructors.\n    * @param modifiers the set of modifiers to be applied to the method\n@@ -381,14 +393,27 @@ public class JavaWriter implements Closeable {\n     }\n     if (modifiers.contains(ABSTRACT)) {\n       out.write(\";\\n\");\n-      pushScope(Scope.ABSTRACT_METHOD);\n+      scopes.push(Scope.ABSTRACT_METHOD);\n     } else {\n       out.write(\" {\\n\");\n-      pushScope(Scope.NON_ABSTRACT_METHOD);\n+      scopes.push(returnType == null ? Scope.CONSTRUCTOR : Scope.NON_ABSTRACT_METHOD);\n     }\n     return this;\n   }\n \n+  public JavaWriter beginConstructor(Set<Modifier> modifiers, String... parameters)\n+      throws IOException {\n+    beginMethod(null, types.peekFirst(), modifiers, parameters);\n+    return this;\n+  }\n+\n+  public JavaWriter beginConstructor(Set<Modifier> modifiers,\n+      List<String> parameters, List<String> throwsTypes)\n+      throws IOException {\n+    beginMethod(null, types.peekFirst(), modifiers, parameters, throwsTypes);\n+    return this;\n+  }\n+\n   /** Emits some Javadoc comments with line separated by {@code \\n}. */\n   public JavaWriter emitJavadoc(String javadoc, Object... params) throws IOException {\n     String formatted = String.format(javadoc, params);\n@@ -505,7 +530,7 @@ public class JavaWriter implements Closeable {\n         boolean split = attributes.size() > MAX_SINGLE_LINE_ATTRIBUTES\n             || containsArray(attributes.values());\n         out.write(\"(\");\n-        pushScope(Scope.ANNOTATION_ATTRIBUTE);\n+        scopes.push(Scope.ANNOTATION_ATTRIBUTE);\n         String separator = split ? \"\\n\" : \"\";\n         for (Map.Entry<String, ?> entry : attributes.entrySet()) {\n           out.write(separator);\n@@ -547,7 +572,7 @@ public class JavaWriter implements Closeable {\n     if (value instanceof Object[]) {\n       out.write(\"{\");\n       boolean firstValue = true;\n-      pushScope(Scope.ANNOTATION_ARRAY_VALUE);\n+      scopes.push(Scope.ANNOTATION_ARRAY_VALUE);\n       for (Object o : ((Object[]) value)) {\n         if (firstValue) {\n           firstValue = false;\n@@ -595,7 +620,7 @@ public class JavaWriter implements Closeable {\n     indent();\n     out.write(controlFlow);\n     out.write(\" {\\n\");\n-    pushScope(Scope.CONTROL_FLOW);\n+    scopes.push(Scope.CONTROL_FLOW);\n     return this;\n   }\n \n@@ -606,7 +631,7 @@ public class JavaWriter implements Closeable {\n   public JavaWriter nextControlFlow(String controlFlow) throws IOException {\n     popScope(Scope.CONTROL_FLOW);\n     indent();\n-    pushScope(Scope.CONTROL_FLOW);\n+    scopes.push(Scope.CONTROL_FLOW);\n     out.write(\"} \");\n     out.write(controlFlow);\n     out.write(\" {\\n\");\n@@ -636,8 +661,9 @@ public class JavaWriter implements Closeable {\n \n   /** Completes the current method declaration. */\n   public JavaWriter endMethod() throws IOException {\n-    Scope popped = popScope();\n-    if (popped == Scope.NON_ABSTRACT_METHOD) {\n+    Scope popped = scopes.pop();\n+    // support calling a constructor a \"method\" to support the legacy code\n+    if (popped == Scope.NON_ABSTRACT_METHOD || popped == Scope.CONSTRUCTOR) {\n       indent();\n       out.write(\"}\\n\");\n     } else if (popped != Scope.ABSTRACT_METHOD) {\n@@ -646,6 +672,14 @@ public class JavaWriter implements Closeable {\n     return this;\n   }\n \n+  /** Completes the current constructor declaration. */\n+  public JavaWriter endConstructor() throws IOException {\n+    popScope(Scope.CONSTRUCTOR);\n+    indent();\n+    out.write(\"}\\n\");\n+    return this;\n+  }\n+\n   /** Returns the string literal representing {@code data}, including wrapping quotes. */\n   public static String stringLiteral(String data) {\n     StringBuilder result = new StringBuilder();\n@@ -734,27 +768,15 @@ public class JavaWriter implements Closeable {\n   }\n \n   private void checkInMethod() {\n-    Scope scope = peekScope();\n+    Scope scope = scopes.peekFirst();\n     if (scope != Scope.NON_ABSTRACT_METHOD && scope != Scope.CONTROL_FLOW\n         && scope != Scope.INITIALIZER) {\n       throw new IllegalArgumentException();\n     }\n   }\n \n-  private void pushScope(Scope pushed) {\n-    scopes.add(pushed);\n-  }\n-\n-  private Scope peekScope() {\n-    return scopes.get(scopes.size() - 1);\n-  }\n-\n-  private Scope popScope() {\n-    return scopes.remove(scopes.size() - 1);\n-  }\n-\n   private void popScope(Scope expected) {\n-    if (scopes.remove(scopes.size() - 1) != expected) {\n+    if (scopes.pop() != expected) {\n       throw new IllegalStateException();\n     }\n   }\n@@ -763,6 +785,7 @@ public class JavaWriter implements Closeable {\n     TYPE_DECLARATION,\n     ABSTRACT_METHOD,\n     NON_ABSTRACT_METHOD,\n+    CONSTRUCTOR,\n     CONTROL_FLOW,\n     ANNOTATION_ATTRIBUTE,\n     ANNOTATION_ARRAY_VALUE,\n"
    },
    {
        "commit_hash": "4c31ac8d8db53ac373c2d7c818e3c77730971fbf",
        "previous_commit_hash": "71e6bc2a4b22cfed6d35f75a623384358fd069a8",
        "diff_stats": {
            "additions": 40,
            "deletions": 14
        },
        "diff_content": "@@ -1,7 +1,15 @@\n // Copyright 2013 Square, Inc.\n package com.squareup.javawriter;\n \n-import com.example.Binding;\n+import static com.squareup.javawriter.JavaWriter.stringLiteral;\n+import static javax.lang.model.element.Modifier.ABSTRACT;\n+import static javax.lang.model.element.Modifier.FINAL;\n+import static javax.lang.model.element.Modifier.PRIVATE;\n+import static javax.lang.model.element.Modifier.PUBLIC;\n+import static javax.lang.model.element.Modifier.STATIC;\n+import static org.fest.assertions.api.Assertions.assertThat;\n+import static org.fest.assertions.api.Assertions.failBecauseExceptionWasNotThrown;\n+\n import java.io.IOException;\n import java.io.StringWriter;\n import java.util.Arrays;\n@@ -10,17 +18,12 @@ import java.util.EnumSet;\n import java.util.LinkedHashMap;\n import java.util.Map;\n import java.util.Set;\n+\n import javax.lang.model.element.Modifier;\n+\n import org.junit.Test;\n \n-import static com.squareup.javawriter.JavaWriter.stringLiteral;\n-import static javax.lang.model.element.Modifier.ABSTRACT;\n-import static javax.lang.model.element.Modifier.FINAL;\n-import static javax.lang.model.element.Modifier.PRIVATE;\n-import static javax.lang.model.element.Modifier.PUBLIC;\n-import static javax.lang.model.element.Modifier.STATIC;\n-import static org.fest.assertions.api.Assertions.assertThat;\n-import static org.fest.assertions.api.Assertions.failBecauseExceptionWasNotThrown;\n+import com.example.Binding;\n \n public final class JavaWriterTest {\n   private final StringWriter stringWriter = new StringWriter();\n@@ -146,8 +149,8 @@ public final class JavaWriterTest {\n   @Test public void constructorDeclaration() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n     javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n-    javaWriter.beginMethod(null, \"com.squareup.Foo\", EnumSet.of(PUBLIC), \"java.lang.String\", \"s\");\n-    javaWriter.endMethod();\n+    javaWriter.beginConstructor(EnumSet.of(PUBLIC), \"java.lang.String\", \"s\");\n+    javaWriter.endConstructor();\n     javaWriter.endType();\n     assertCode(\"\"\n         + \"package com.squareup;\\n\"\n@@ -158,12 +161,35 @@ public final class JavaWriterTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void constructorDeclarationInNestedTypes() throws IOException {\n+    javaWriter.emitPackage(\"com.squareup\");\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n+    javaWriter.beginConstructor(EnumSet.of(PUBLIC), \"java.lang.String\", \"s\");\n+    javaWriter.endConstructor();\n+    javaWriter.beginType(\"com.squareup.Bar\", \"class\");\n+    javaWriter.beginConstructor(EnumSet.noneOf(Modifier.class));\n+    javaWriter.endConstructor();\n+    javaWriter.endType();\n+    javaWriter.endType();\n+    assertCode(\"\"\n+        + \"package com.squareup;\\n\"\n+        + \"\\n\"\n+        + \"class Foo {\\n\"\n+        + \"  public Foo(String s) {\\n\"\n+        + \"  }\\n\"\n+        + \"  class Bar {\\n\"\n+        + \"    Bar() {\\n\"\n+        + \"    }\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n   @Test public void constructorDeclarationWithThrows() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n     javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n-    javaWriter.beginMethod(null, \"com.squareup.Foo\", EnumSet.of(PUBLIC),\n+    javaWriter.beginConstructor(EnumSet.of(PUBLIC),\n         Arrays.asList(\"java.lang.String\", \"s\"), Arrays.asList(\"java.io.IOException\"));\n-    javaWriter.endMethod();\n+    javaWriter.endConstructor();\n     javaWriter.endType();\n     assertCode(\"\"\n         + \"package com.squareup;\\n\"\n@@ -665,7 +691,7 @@ public final class JavaWriterTest {\n         + \"    String bar;\\n\"\n         + \"}\\n\");\n   }\n-    \n+\n   private void assertCode(String expected) {\n     assertThat(stringWriter.toString()).isEqualTo(expected);\n   }\n"
    },
    {
        "commit_hash": "fd7f36f21386bc851d60a049087216da5ee82f67",
        "previous_commit_hash": "71e6bc2a4b22cfed6d35f75a623384358fd069a8",
        "diff_stats": {
            "additions": 12,
            "deletions": 0
        },
        "diff_content": "@@ -85,6 +85,18 @@ public class JavaWriter implements Closeable {\n     return emitImports(Arrays.asList(types));\n   }\n \n+  /**\n+   * Emit an import for each {@code type} provided. For the duration of the file, all references to\n+   * these classes will be automatically shortened.\n+   */\n+  public JavaWriter emitImports(Class<?>... types) throws IOException {\n+    List<String> classNames = new ArrayList<String>(types.length);\n+    for (Class<?> classToImport : types) {\n+      classNames.add(classToImport.getName());\n+    }\n+    return emitImports(classNames);\n+  }\n+\n   /**\n    * Emit an import for each {@code type} in the provided {@code Collection}. For the duration of\n    * the file, all references to these classes will be automatically shortened.\n"
    },
    {
        "commit_hash": "fd7f36f21386bc851d60a049087216da5ee82f67",
        "previous_commit_hash": "71e6bc2a4b22cfed6d35f75a623384358fd069a8",
        "diff_stats": {
            "additions": 30,
            "deletions": 10
        },
        "diff_content": "@@ -1,26 +1,30 @@\n // Copyright 2013 Square, Inc.\n package com.squareup.javawriter;\n \n-import com.example.Binding;\n+import static com.squareup.javawriter.JavaWriter.stringLiteral;\n+import static javax.lang.model.element.Modifier.ABSTRACT;\n+import static javax.lang.model.element.Modifier.FINAL;\n+import static javax.lang.model.element.Modifier.PRIVATE;\n+import static javax.lang.model.element.Modifier.PUBLIC;\n+import static javax.lang.model.element.Modifier.STATIC;\n+import static org.fest.assertions.api.Assertions.assertThat;\n+import static org.fest.assertions.api.Assertions.failBecauseExceptionWasNotThrown;\n+\n import java.io.IOException;\n import java.io.StringWriter;\n+import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.EnumSet;\n import java.util.LinkedHashMap;\n import java.util.Map;\n import java.util.Set;\n+\n import javax.lang.model.element.Modifier;\n+\n import org.junit.Test;\n \n-import static com.squareup.javawriter.JavaWriter.stringLiteral;\n-import static javax.lang.model.element.Modifier.ABSTRACT;\n-import static javax.lang.model.element.Modifier.FINAL;\n-import static javax.lang.model.element.Modifier.PRIVATE;\n-import static javax.lang.model.element.Modifier.PUBLIC;\n-import static javax.lang.model.element.Modifier.STATIC;\n-import static org.fest.assertions.api.Assertions.assertThat;\n-import static org.fest.assertions.api.Assertions.failBecauseExceptionWasNotThrown;\n+import com.example.Binding;\n \n public final class JavaWriterTest {\n   private final StringWriter stringWriter = new StringWriter();\n@@ -248,6 +252,22 @@ public final class JavaWriterTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void addImportAsClass() throws IOException {\n+    javaWriter.emitPackage(\"com.squareup\");\n+    javaWriter.emitImports(ArrayList.class);\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\", EnumSet.of(PUBLIC, FINAL));\n+    javaWriter.emitField(\"java.util.ArrayList\", \"list\", EnumSet.noneOf(Modifier.class),\n+        \"new java.util.ArrayList()\");\n+    javaWriter.endType();\n+    assertCode(\"\"\n+        + \"package com.squareup;\\n\"\n+        + \"\\n\"\n+        + \"import java.util.ArrayList;\\n\"\n+        + \"public final class Foo {\\n\"\n+        + \"  ArrayList list = new java.util.ArrayList();\\n\"\n+        + \"}\\n\");\n+  }\n+\n   @Test public void addStaticImport() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n     javaWriter.emitStaticImports(\"java.lang.System.getProperty\");\n@@ -665,7 +685,7 @@ public final class JavaWriterTest {\n         + \"    String bar;\\n\"\n         + \"}\\n\");\n   }\n-    \n+\n   private void assertCode(String expected) {\n     assertThat(stringWriter.toString()).isEqualTo(expected);\n   }\n"
    },
    {
        "commit_hash": "388d8e5d0a9afdc3cce29441bcee1e060c65c166",
        "previous_commit_hash": "d019b6f624863b72cbf246b793dbf025d02b219e",
        "diff_stats": {
            "additions": 3,
            "deletions": 2
        },
        "diff_content": "@@ -8,6 +8,7 @@ import java.io.IOException;\n import java.io.Writer;\n import java.lang.annotation.Annotation;\n import java.util.ArrayDeque;\n+import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n@@ -208,8 +209,8 @@ public class JavaWriter implements Closeable {\n       if (name.indexOf('.', packagePrefix.length()) == -1) {\n         return true;\n       }\n-      int index = name.indexOf('.');\n-      if (name.substring(index + 1, index + 2).matches(\"[A-Z]\")) {\n+      // check to see if the part after the package looks like a class\n+      if (Character.isUpperCase(name.charAt(packagePrefix.length()))) {\n         return true;\n       }\n     }\n"
    },
    {
        "commit_hash": "388d8e5d0a9afdc3cce29441bcee1e060c65c166",
        "previous_commit_hash": "d019b6f624863b72cbf246b793dbf025d02b219e",
        "diff_stats": {
            "additions": 14,
            "deletions": 7
        },
        "diff_content": "@@ -668,23 +668,30 @@ public final class JavaWriterTest {\n   }\n \n   @Test public void compressType() throws IOException {\n-    javaWriter.emitPackage(\"blah\");\n+    javaWriter.emitPackage(\"com.blah\");\n     javaWriter.emitImports(Set.class.getCanonicalName(), Binding.class.getCanonicalName());\n-    String actual = javaWriter.compressType(\"java.util.Set<com.example.Binding<blah.Foo.Blah>>\");\n+    String actual =\n+        javaWriter.compressType(\"java.util.Set<com.example.Binding<com.blah.Foo.Blah>>\");\n     assertThat(actual).isEqualTo(\"Set<Binding<Foo.Blah>>\");\n   }\n \n   @Test public void compressDeeperType() throws IOException {\n-    javaWriter.emitPackage(\"blah\");\n+    javaWriter.emitPackage(\"com.blah\");\n     javaWriter.emitImports(Binding.class.getCanonicalName());\n-    String actual = javaWriter.compressType(\"com.example.Binding<blah.foo.Foo.Blah>\");\n-    assertThat(actual).isEqualTo(\"Binding<blah.foo.Foo.Blah>\");\n+    String actual = javaWriter.compressType(\"com.example.Binding<com.blah.foo.Foo.Blah>\");\n+    assertThat(actual).isEqualTo(\"Binding<com.blah.foo.Foo.Blah>\");\n+  }\n+\n+  @Test public void compressNestedType() throws IOException {\n+    javaWriter.emitPackage(\"com.blah\");\n+    String actual = javaWriter.compressType(\"com.blah.Enclosing.Nested\");\n+    assertThat(actual).isEqualTo(\"Enclosing.Nested\");\n   }\n \n   @Test public void compressWildcardType() throws IOException {\n-    javaWriter.emitPackage(\"blah\");\n+    javaWriter.emitPackage(\"com.blah\");\n     javaWriter.emitImports(Binding.class.getCanonicalName());\n-    String actual = javaWriter.compressType(\"com.example.Binding<? extends blah.Foo.Blah>\");\n+    String actual = javaWriter.compressType(\"com.example.Binding<? extends com.blah.Foo.Blah>\");\n     assertThat(actual).isEqualTo(\"Binding<? extends Foo.Blah>\");\n   }\n \n"
    },
    {
        "commit_hash": "4bbfab0f5ef6315cdceb27ccb287932f0d286416",
        "previous_commit_hash": "ad9cbcdeba94925bf7fbf7f0995bca795c5e6ccf",
        "diff_stats": {
            "additions": 4,
            "deletions": 3
        },
        "diff_content": "@@ -780,10 +780,11 @@ public class JavaWriter implements Closeable {\n     }\n   }\n \n+  private static final EnumSet<Scope> METHOD_SCOPES = EnumSet.of(\n+      Scope.NON_ABSTRACT_METHOD, Scope.CONSTRUCTOR, Scope.CONTROL_FLOW, Scope.INITIALIZER);\n+\n   private void checkInMethod() {\n-    Scope scope = scopes.peekFirst();\n-    if (scope != Scope.NON_ABSTRACT_METHOD && scope != Scope.CONTROL_FLOW\n-        && scope != Scope.INITIALIZER) {\n+    if (!METHOD_SCOPES.contains(scopes.peekFirst())) {\n       throw new IllegalArgumentException();\n     }\n   }\n"
    },
    {
        "commit_hash": "4bbfab0f5ef6315cdceb27ccb287932f0d286416",
        "previous_commit_hash": "ad9cbcdeba94925bf7fbf7f0995bca795c5e6ccf",
        "diff_stats": {
            "additions": 17,
            "deletions": 0
        },
        "diff_content": "@@ -162,6 +162,23 @@ public final class JavaWriterTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void simpleConstructor() throws IOException {\n+    javaWriter.emitPackage(\"com.squareup\");\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n+    javaWriter.beginConstructor(EnumSet.of(PUBLIC), \"java.lang.String\", \"s\");\n+    javaWriter.emitStatement(\"if (%s == null) throw new NullPointerException()\", \"s\");\n+    javaWriter.endConstructor();\n+    javaWriter.endType();\n+    assertCode(\"\"\n+        + \"package com.squareup;\\n\"\n+        + \"\\n\"\n+        + \"class Foo {\\n\"\n+        + \"  public Foo(String s) {\\n\"\n+        + \"    if (s == null) throw new NullPointerException();\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n   @Test public void constructorDeclarationInNestedTypes() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n     javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n"
    },
    {
        "commit_hash": "321828a3913ad2fa9042943d65c67c3f9acdcd93",
        "previous_commit_hash": "84b729851e5e44784ac0f3681d9261dc8a40d214",
        "diff_stats": {
            "additions": 17,
            "deletions": 0
        },
        "diff_content": "@@ -20,6 +20,7 @@ import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.EnumSet;\n+import java.util.Iterator;\n import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n@@ -486,6 +487,22 @@ public class JavaWriter implements Closeable {\n     return this;\n   }\n \n+\n+  public JavaWriter emitEnumValues(Iterable<String> names) throws IOException {\n+    final Iterator<String> iterator = names.iterator();\n+\n+    while (iterator.hasNext()) {\n+      final String name = iterator.next();\n+      if (iterator.hasNext()) {\n+        emitEnumValue(name);\n+      } else {\n+        emitLastEnumValue(name);\n+      }\n+    }\n+\n+    return this;\n+  }\n+\n   /** Equivalent to {@code annotation(annotation, emptyMap())}. */\n   public JavaWriter emitAnnotation(String annotation) throws IOException {\n     return emitAnnotation(annotation, Collections.<String, Object>emptyMap());\n"
    },
    {
        "commit_hash": "321828a3913ad2fa9042943d65c67c3f9acdcd93",
        "previous_commit_hash": "84b729851e5e44784ac0f3681d9261dc8a40d214",
        "diff_stats": {
            "additions": 14,
            "deletions": 0
        },
        "diff_content": "@@ -55,6 +55,20 @@ public final class JavaWriterTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void enumDeclarationWithMultipleValues() throws IOException {\n+    javaWriter.emitPackage(\"com.squareup\");\n+    javaWriter.beginType(\"com.squareup.Foo\", \"enum\", EnumSet.of(PUBLIC));\n+    javaWriter.emitEnumValues(Arrays.asList(\"BAR\", \"BAZ\"));\n+    javaWriter.endType();\n+    assertCode(\"\"\n+        + \"package com.squareup;\\n\"\n+        + \"\\n\"\n+        + \"public enum Foo {\\n\"\n+        + \"  BAR,\\n\"\n+        + \"  BAZ;\\n\"\n+        + \"}\\n\");\n+  }\n+\n   @Test public void enumDeclarationWithMethod() throws IOException{\n     javaWriter.emitPackage(\"com.squareup\");\n     javaWriter.beginType(\"com.squareup.Foo\", \"enum\", EnumSet.of(PUBLIC));\n"
    },
    {
        "commit_hash": "35c59c5a2d7d03ef42726712bf28c53c665e8c1c",
        "previous_commit_hash": "321828a3913ad2fa9042943d65c67c3f9acdcd93",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -480,7 +480,7 @@ public class JavaWriter implements Closeable {\n     return this;\n   }\n \n-  public JavaWriter emitLastEnumValue(String name) throws IOException {\n+  private JavaWriter emitLastEnumValue(String name) throws IOException {\n     indent();\n     out.write(name);\n     out.write(\";\\n\");\n"
    },
    {
        "commit_hash": "35c59c5a2d7d03ef42726712bf28c53c665e8c1c",
        "previous_commit_hash": "321828a3913ad2fa9042943d65c67c3f9acdcd93",
        "diff_stats": {
            "additions": 1,
            "deletions": 16
        },
        "diff_content": "@@ -55,25 +55,10 @@ public final class JavaWriterTest {\n         + \"}\\n\");\n   }\n \n-  @Test public void enumDeclarationWithMultipleValues() throws IOException {\n-    javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"enum\", EnumSet.of(PUBLIC));\n-    javaWriter.emitEnumValues(Arrays.asList(\"BAR\", \"BAZ\"));\n-    javaWriter.endType();\n-    assertCode(\"\"\n-        + \"package com.squareup;\\n\"\n-        + \"\\n\"\n-        + \"public enum Foo {\\n\"\n-        + \"  BAR,\\n\"\n-        + \"  BAZ;\\n\"\n-        + \"}\\n\");\n-  }\n-\n   @Test public void enumDeclarationWithMethod() throws IOException{\n     javaWriter.emitPackage(\"com.squareup\");\n     javaWriter.beginType(\"com.squareup.Foo\", \"enum\", EnumSet.of(PUBLIC));\n-    javaWriter.emitEnumValue(\"BAR\");\n-    javaWriter.emitLastEnumValue(\"BAZ\");\n+    javaWriter.emitEnumValues(Arrays.asList(\"BAR\", \"BAZ\"));\n     javaWriter.beginMethod(\"void\", \"foo\", EnumSet.of(PUBLIC));\n     javaWriter.endMethod();\n     javaWriter.endType();\n"
    },
    {
        "commit_hash": "9de3e87b761578d05e782d9315aa2d7f8b9a8a86",
        "previous_commit_hash": "c0f4a89bc087d186bf05ee86ae9de4c12ff17130",
        "diff_stats": {
            "additions": 5,
            "deletions": 6
        },
        "diff_content": "@@ -1,8 +1,6 @@\n // Copyright 2013 Square, Inc.\n package com.squareup.javawriter;\n \n-import static javax.lang.model.element.Modifier.ABSTRACT;\n-\n import java.io.Closeable;\n import java.io.IOException;\n import java.io.Writer;\n@@ -23,9 +21,10 @@ import java.util.Set;\n import java.util.TreeSet;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n-\n import javax.lang.model.element.Modifier;\n \n+import static javax.lang.model.element.Modifier.ABSTRACT;\n+\n /** A utility class which aids in generating Java source files. */\n public class JavaWriter implements Closeable {\n   private static final Pattern TYPE_PATTERN = Pattern.compile(\"(?:[\\\\w$]+\\\\.)*([\\\\w\\\\.*$]+)\");\n@@ -476,12 +475,12 @@ public class JavaWriter implements Closeable {\n     return this;\n   }\n \n-\n+  /** Emit a list of enum values followed by a semi-colon ({@code ;}). */\n   public JavaWriter emitEnumValues(Iterable<String> names) throws IOException {\n-    final Iterator<String> iterator = names.iterator();\n+    Iterator<String> iterator = names.iterator();\n \n     while (iterator.hasNext()) {\n-      final String name = iterator.next();\n+      String name = iterator.next();\n       if (iterator.hasNext()) {\n         emitEnumValue(name);\n       } else {\n"
    },
    {
        "commit_hash": "f11602c51a06c588f22ebcf9a538ab3c3b2b1bec",
        "previous_commit_hash": "9de3e87b761578d05e782d9315aa2d7f8b9a8a86",
        "diff_stats": {
            "additions": 10,
            "deletions": 0
        },
        "diff_content": "@@ -1,6 +1,16 @@\n Change Log\n ==========\n \n+Version 2.3.0 *(2013-11-24)*\n+----------------------------\n+\n+ * New: Configurable indent level via `setIndent`.\n+ * New: `beginConstructor` method is a semantically clearer alternative for constructors.\n+ * New: `emitEnumValues` method emits a list of values followed by semicolon.\n+ * `emitImports` now supports `Class` arguments directly.\n+ * Previously-deprecated, `int`-based modifier methods have been removed.\n+\n+\n Version 2.2.1 *(2013-10-23)*\n ----------------------------\n \n"
    },
    {
        "commit_hash": "ddb0a4312252e327bfb4738a8d835c4111308f43",
        "previous_commit_hash": "f11602c51a06c588f22ebcf9a538ab3c3b2b1bec",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javawriter</artifactId>\n-  <version>2.2.2-SNAPSHOT</version>\n+  <version>2.3.0</version>\n \n   <name>JavaWriter</name>\n   <description>A utility class which aids in generating Java source files.</description>\n"
    },
    {
        "commit_hash": "9f648476fdd63a1d34997e45ab49d696ad305706",
        "previous_commit_hash": "ddb0a4312252e327bfb4738a8d835c4111308f43",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javawriter</artifactId>\n-  <version>2.3.0</version>\n+  <version>2.3.1-SNAPSHOT</version>\n \n   <name>JavaWriter</name>\n   <description>A utility class which aids in generating Java source files.</description>\n"
    },
    {
        "commit_hash": "30f5cf5b81e2a1d62b843f60aac713c45dc7b273",
        "previous_commit_hash": "9f648476fdd63a1d34997e45ab49d696ad305706",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -187,14 +187,14 @@ public class JavaWriter implements Closeable {\n       String imported = importedTypes.get(name);\n       if (imported != null) {\n         sb.append(imported);\n-      } else if (isClassInPackage(name)) {\n+      } else if (isClassInPackage(name, packagePrefix)) {\n         String compressed = name.substring(packagePrefix.length());\n         if (isAmbiguous(compressed)) {\n           sb.append(name);\n         } else {\n           sb.append(compressed);\n         }\n-      } else if (name.startsWith(\"java.lang.\")) {\n+      } else if (isClassInPackage(name, \"java.lang.\")) {\n         sb.append(name.substring(\"java.lang.\".length()));\n       } else {\n         sb.append(name);\n@@ -204,7 +204,7 @@ public class JavaWriter implements Closeable {\n     return sb.toString();\n   }\n \n-  private boolean isClassInPackage(String name) {\n+  private static boolean isClassInPackage(String name, String packagePrefix) {\n     if (name.startsWith(packagePrefix)) {\n       if (name.indexOf('.', packagePrefix.length()) == -1) {\n         return true;\n"
    },
    {
        "commit_hash": "30f5cf5b81e2a1d62b843f60aac713c45dc7b273",
        "previous_commit_hash": "9f648476fdd63a1d34997e45ab49d696ad305706",
        "diff_stats": {
            "additions": 12,
            "deletions": 0
        },
        "diff_content": "@@ -737,6 +737,18 @@ public final class JavaWriterTest {\n     assertThat(actual).isEqualTo(\"Binding<denominator.Provider>\");\n   }\n \n+  @Test public void compressJavaLangClass() throws IOException {\n+    javaWriter.emitPackage(\"com.blah\");\n+    String actual = javaWriter.compressType(\"java.lang.Class\");\n+    assertThat(actual).isEqualTo(\"Class\");\n+  }\n+\n+  @Test public void compressJavaLangSubPackageClass() throws IOException {\n+    javaWriter.emitPackage(\"com.blah\");\n+    String actual = javaWriter.compressType(\"java.lang.annotation.Annotation\");\n+    assertThat(actual).isEqualTo(\"java.lang.annotation.Annotation\");\n+  }\n+\n   @Test public void configurableIndent() throws IOException {\n     javaWriter.setIndent(\"    \");\n     javaWriter.emitPackage(\"com.squareup\");\n"
    },
    {
        "commit_hash": "c887337cf5be0e813a5d515c0ae4c3f52a59d200",
        "previous_commit_hash": "7cf6e171e1309364cd12f73ecce33ce3a6911cdb",
        "diff_stats": {
            "additions": 6,
            "deletions": 0
        },
        "diff_content": "@@ -1,6 +1,12 @@\n Change Log\n ==========\n \n+Version 2.3.1 *(2013-12-16)*\n+----------------------------\n+\n+ * Fix: Properly handle subpackages of `java.lang` in `compressType`.\n+\n+\n Version 2.3.0 *(2013-11-24)*\n ----------------------------\n \n"
    },
    {
        "commit_hash": "9a3c603bde0fbec2b3646fc92c99dbf18c6c6367",
        "previous_commit_hash": "c887337cf5be0e813a5d515c0ae4c3f52a59d200",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javawriter</artifactId>\n-  <version>2.3.1-SNAPSHOT</version>\n+  <version>2.3.1</version>\n \n   <name>JavaWriter</name>\n   <description>A utility class which aids in generating Java source files.</description>\n"
    },
    {
        "commit_hash": "38d013533a0f86959d43f64f26687c252e565b00",
        "previous_commit_hash": "9a3c603bde0fbec2b3646fc92c99dbf18c6c6367",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javawriter</artifactId>\n-  <version>2.3.1</version>\n+  <version>2.3.2-SNAPSHOT</version>\n \n   <name>JavaWriter</name>\n   <description>A utility class which aids in generating Java source files.</description>\n"
    },
    {
        "commit_hash": "84da75698782a506b2c6a6594e183591575f87ad",
        "previous_commit_hash": "38d013533a0f86959d43f64f26687c252e565b00",
        "diff_stats": {
            "additions": 11,
            "deletions": 3
        },
        "diff_content": "@@ -313,17 +313,18 @@ public class JavaWriter implements Closeable {\n     return this;\n   }\n \n-  /** Emits a field declaration. */\n+  /** Emits a field declaration. Should not contain a trailing semicolon. */\n   public JavaWriter emitField(String type, String name) throws IOException {\n     return emitField(type, name, EnumSet.noneOf(Modifier.class), null);\n   }\n \n-  /** Emits a field declaration. */\n+  /** Emits a field declaration. Should not contain a trailing semicolon. */\n   public JavaWriter emitField(String type, String name, Set<Modifier> modifiers)\n       throws IOException {\n     return emitField(type, name, modifiers, null);\n   }\n \n+  /** Emits a field declaration. Should not contain a trailing semicolon. */\n   public JavaWriter emitField(String type, String name, Set<Modifier> modifiers,\n       String initialValue) throws IOException {\n     indent();\n@@ -334,7 +335,14 @@ public class JavaWriter implements Closeable {\n \n     if (initialValue != null) {\n       out.write(\" = \");\n-      out.write(initialValue);\n+\n+      String[] lines = initialValue.split(\"\\n\", -1);\n+      out.write(lines[0]);\n+      for (int i = 1; i < lines.length; i++) {\n+        out.write(\"\\n\");\n+        hangingIndent();\n+        out.write(lines[i]);\n+      }\n     }\n     out.write(\";\\n\");\n     return this;\n"
    },
    {
        "commit_hash": "84da75698782a506b2c6a6594e183591575f87ad",
        "previous_commit_hash": "38d013533a0f86959d43f64f26687c252e565b00",
        "diff_stats": {
            "additions": 16,
            "deletions": 0
        },
        "diff_content": "@@ -101,6 +101,22 @@ public final class JavaWriterTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void fieldDeclarationWithWrappingInitialValue() throws IOException {\n+    javaWriter.emitPackage(\"com.squareup\");\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n+    javaWriter.emitField(\"java.lang.String\", \"string\", EnumSet.noneOf(Modifier.class),\n+        \"\\\"bar\\\"\\n+ \\\"baz\\\"\\n+ \\\"biz\\\"\");\n+    javaWriter.endType();\n+    assertCode(\"\"\n+        + \"package com.squareup;\\n\"\n+        + \"\\n\"\n+        + \"class Foo {\\n\"\n+        + \"  String string = \\\"bar\\\"\\n\"\n+        + \"      + \\\"baz\\\"\\n\"\n+        + \"      + \\\"biz\\\";\\n\"\n+        + \"}\\n\");\n+  }\n+\n   @Test public void abstractMethodDeclaration() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n     javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n"
    },
    {
        "commit_hash": "e66d8ba46f82eaa4bd1842dfa8fcfb5fe1d2ead1",
        "previous_commit_hash": "38d013533a0f86959d43f64f26687c252e565b00",
        "diff_stats": {
            "additions": 9,
            "deletions": 12
        },
        "diff_content": "@@ -1,15 +1,7 @@\n // Copyright 2013 Square, Inc.\n package com.squareup.javawriter;\n \n-import static com.squareup.javawriter.JavaWriter.stringLiteral;\n-import static javax.lang.model.element.Modifier.ABSTRACT;\n-import static javax.lang.model.element.Modifier.FINAL;\n-import static javax.lang.model.element.Modifier.PRIVATE;\n-import static javax.lang.model.element.Modifier.PUBLIC;\n-import static javax.lang.model.element.Modifier.STATIC;\n-import static org.fest.assertions.api.Assertions.assertThat;\n-import static org.fest.assertions.api.Assertions.failBecauseExceptionWasNotThrown;\n-\n+import com.example.Binding;\n import java.io.IOException;\n import java.io.StringWriter;\n import java.util.ArrayList;\n@@ -19,12 +11,17 @@ import java.util.EnumSet;\n import java.util.LinkedHashMap;\n import java.util.Map;\n import java.util.Set;\n-\n import javax.lang.model.element.Modifier;\n-\n import org.junit.Test;\n \n-import com.example.Binding;\n+import static com.squareup.javawriter.JavaWriter.stringLiteral;\n+import static javax.lang.model.element.Modifier.ABSTRACT;\n+import static javax.lang.model.element.Modifier.FINAL;\n+import static javax.lang.model.element.Modifier.PRIVATE;\n+import static javax.lang.model.element.Modifier.PUBLIC;\n+import static javax.lang.model.element.Modifier.STATIC;\n+import static org.fest.assertions.api.Assertions.assertThat;\n+import static org.fest.assertions.api.Assertions.failBecauseExceptionWasNotThrown;\n \n public final class JavaWriterTest {\n   private final StringWriter stringWriter = new StringWriter();\n"
    },
    {
        "commit_hash": "658e10a88c6ce18ada3facf9cbb018529cc106cb",
        "previous_commit_hash": "270570874f5b8697768d5fc4e1fd20964387cd45",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -313,18 +313,18 @@ public class JavaWriter implements Closeable {\n     return this;\n   }\n \n-  /** Emits a field declaration. Should not contain a trailing semicolon. */\n+  /** Emits a field declaration. */\n   public JavaWriter emitField(String type, String name) throws IOException {\n     return emitField(type, name, EnumSet.noneOf(Modifier.class), null);\n   }\n \n-  /** Emits a field declaration. Should not contain a trailing semicolon. */\n+  /** Emits a field declaration. */\n   public JavaWriter emitField(String type, String name, Set<Modifier> modifiers)\n       throws IOException {\n     return emitField(type, name, modifiers, null);\n   }\n \n-  /** Emits a field declaration. Should not contain a trailing semicolon. */\n+  /** Emits a field declaration. */\n   public JavaWriter emitField(String type, String name, Set<Modifier> modifiers,\n       String initialValue) throws IOException {\n     indent();\n"
    },
    {
        "commit_hash": "d11578623414e703d20692ba7b3a44ac32c949f8",
        "previous_commit_hash": "658e10a88c6ce18ada3facf9cbb018529cc106cb",
        "diff_stats": {
            "additions": 8,
            "deletions": 0
        },
        "diff_content": "@@ -476,6 +476,14 @@ public class JavaWriter implements Closeable {\n     return this;\n   }\n \n+  /**\n+   * A simple switch to emit the proper enum depending if its last causing it to be terminated\n+   *    by a semi-colon ({@code ;}).\n+   */\n+  public JavaWriter emitEnumValue(String name, boolean isLast) throws IOException {\n+    return isLast ? emitLastEnumValue(name) : emitEnumValue(name);\n+  }\n+\n   private JavaWriter emitLastEnumValue(String name) throws IOException {\n     indent();\n     out.write(name);\n"
    },
    {
        "commit_hash": "d11578623414e703d20692ba7b3a44ac32c949f8",
        "previous_commit_hash": "658e10a88c6ce18ada3facf9cbb018529cc106cb",
        "diff_stats": {
            "additions": 28,
            "deletions": 7
        },
        "diff_content": "@@ -4,13 +4,8 @@ package com.squareup.javawriter;\n import com.example.Binding;\n import java.io.IOException;\n import java.io.StringWriter;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.EnumSet;\n-import java.util.LinkedHashMap;\n-import java.util.Map;\n-import java.util.Set;\n+import java.util.*;\n+\n import javax.lang.model.element.Modifier;\n import org.junit.Test;\n \n@@ -71,6 +66,32 @@ public final class JavaWriterTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void enumDeclarationWithAnnotationAndMethod() throws IOException{\n+    javaWriter.emitPackage(\"com.squareup\");\n+    javaWriter.beginType(\"com.squareup.Foo\", \"enum\", EnumSet.of(PUBLIC));\n+    List<String> list = Arrays.asList(\"BAR\", \"BAZ\");\n+    int index = 0;\n+    for (Iterator<String> i = list.iterator(); i.hasNext(); ) {\n+      javaWriter.emitAnnotation(\"ProtoEnum\", index);\n+      javaWriter.emitEnumValue(i.next(), !i.hasNext());\n+      index++;\n+    }\n+    javaWriter.beginMethod(\"void\", \"foo\", EnumSet.of(PUBLIC));\n+    javaWriter.endMethod();\n+    javaWriter.endType();\n+    assertCode(\"\"\n+            + \"package com.squareup;\\n\"\n+            + \"\\n\"\n+            + \"public enum Foo {\\n\"\n+            + \"  @ProtoEnum(0)\\n\"\n+            + \"  BAR,\\n\"\n+            + \"  @ProtoEnum(1)\\n\"\n+            + \"  BAZ;\\n\"\n+            + \"  public void foo() {\\n\"\n+            + \"  }\\n\"\n+            + \"}\\n\");\n+  }\n+\n   @Test public void fieldDeclaration() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n     javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n"
    },
    {
        "commit_hash": "4a3118997394ee59b34b77d8bebe0ccf13bf520b",
        "previous_commit_hash": "d11578623414e703d20692ba7b3a44ac32c949f8",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -478,7 +478,7 @@ public class JavaWriter implements Closeable {\n \n   /**\n    * A simple switch to emit the proper enum depending if its last causing it to be terminated\n-   *    by a semi-colon ({@code ;}).\n+   * by a semi-colon ({@code ;}).\n    */\n   public JavaWriter emitEnumValue(String name, boolean isLast) throws IOException {\n     return isLast ? emitLastEnumValue(name) : emitEnumValue(name);\n"
    },
    {
        "commit_hash": "4a3118997394ee59b34b77d8bebe0ccf13bf520b",
        "previous_commit_hash": "d11578623414e703d20692ba7b3a44ac32c949f8",
        "diff_stats": {
            "additions": 9,
            "deletions": 1
        },
        "diff_content": "@@ -4,7 +4,15 @@ package com.squareup.javawriter;\n import com.example.Binding;\n import java.io.IOException;\n import java.io.StringWriter;\n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n \n import javax.lang.model.element.Modifier;\n import org.junit.Test;\n"
    },
    {
        "commit_hash": "763621dc035b65e8e8d75761b645a8a281d5b3fc",
        "previous_commit_hash": "614f7cd72356b9624e24ea9c6f201e3163db47cf",
        "diff_stats": {
            "additions": 121,
            "deletions": 120
        },
        "diff_content": "@@ -1,120 +1,121 @@\n-<?xml version=\"1.0\"?>\r\n-<!DOCTYPE module PUBLIC\r\n-    \"-//Puppy Crawl//DTD Check Configuration 1.2//EN\"\r\n-    \"http://www.puppycrawl.com/dtds/configuration_1_2.dtd\">\r\n-\r\n-<module name=\"Checker\">\r\n-    <module name=\"NewlineAtEndOfFile\"/>\r\n-    <module name=\"FileLength\"/>\r\n-    <module name=\"FileTabCharacter\"/>\r\n-\r\n-    <!-- Trailing spaces -->\r\n-    <module name=\"RegexpSingleline\">\r\n-        <property name=\"format\" value=\"\\s+$\"/>\r\n-        <property name=\"message\" value=\"Line has trailing spaces.\"/>\r\n-    </module>\r\n-\r\n-    <module name=\"TreeWalker\">\r\n-        <property name=\"cacheFile\" value=\"${checkstyle.cache.file}\"/>\r\n-\r\n-        <!-- Checks for Javadoc comments.                     -->\r\n-        <!-- See http://checkstyle.sf.net/config_javadoc.html -->\r\n-        <!--module name=\"JavadocMethod\"/-->\r\n-        <!--module name=\"JavadocType\"/-->\r\n-        <!--module name=\"JavadocVariable\"/-->\r\n-        <module name=\"JavadocStyle\"/>\r\n-\r\n-\r\n-        <!-- Checks for Naming Conventions.                  -->\r\n-        <!-- See http://checkstyle.sf.net/config_naming.html -->\r\n-        <module name=\"ConstantName\"/>\r\n-        <module name=\"LocalFinalVariableName\"/>\r\n-        <module name=\"LocalVariableName\"/>\r\n-        <module name=\"MemberName\"/>\r\n-        <module name=\"MethodName\"/>\r\n-        <module name=\"PackageName\"/>\r\n-        <module name=\"ParameterName\"/>\r\n-        <module name=\"StaticVariableName\"/>\r\n-        <module name=\"TypeName\"/>\r\n-\r\n-\r\n-        <!-- Checks for imports                              -->\r\n-        <!-- See http://checkstyle.sf.net/config_import.html -->\r\n-        <module name=\"AvoidStarImport\"/>\r\n-        <module name=\"IllegalImport\"/> <!-- defaults to sun.* packages -->\r\n-        <module name=\"RedundantImport\"/>\r\n-        <module name=\"UnusedImports\"/>\r\n-\r\n-\r\n-        <!-- Checks for Size Violations.                    -->\r\n-        <!-- See http://checkstyle.sf.net/config_sizes.html -->\r\n-        <module name=\"LineLength\">\r\n-            <property name=\"max\" value=\"100\"/>\r\n-        </module>\r\n-        <module name=\"MethodLength\"/>\r\n-        <module name=\"ParameterNumber\"/>\r\n-\r\n-\r\n-        <!-- Checks for whitespace                               -->\r\n-        <!-- See http://checkstyle.sf.net/config_whitespace.html -->\r\n-        <module name=\"GenericWhitespace\"/>\r\n-        <module name=\"EmptyForIteratorPad\"/>\r\n-        <module name=\"MethodParamPad\"/>\r\n-        <module name=\"NoWhitespaceAfter\"/>\r\n-        <module name=\"NoWhitespaceBefore\"/>\r\n-        <module name=\"OperatorWrap\"/>\r\n-        <module name=\"ParenPad\"/>\r\n-        <module name=\"TypecastParenPad\"/>\r\n-        <module name=\"WhitespaceAfter\"/>\r\n-        <module name=\"WhitespaceAround\"/>\r\n-\r\n-\r\n-        <!-- Modifier Checks                                    -->\r\n-        <!-- See http://checkstyle.sf.net/config_modifiers.html -->\r\n-        <module name=\"ModifierOrder\"/>\r\n-        <module name=\"RedundantModifier\"/>\r\n-\r\n-\r\n-        <!-- Checks for blocks. You know, those {}'s         -->\r\n-        <!-- See http://checkstyle.sf.net/config_blocks.html -->\r\n-        <module name=\"AvoidNestedBlocks\"/>\r\n-        <!--module name=\"EmptyBlock\"/-->\r\n-        <module name=\"LeftCurly\"/>\r\n-        <module name=\"NeedBraces\"/>\r\n-        <module name=\"RightCurly\"/>\r\n-\r\n-\r\n-        <!-- Checks for common coding problems               -->\r\n-        <!-- See http://checkstyle.sf.net/config_coding.html -->\r\n-        <!--module name=\"AvoidInlineConditionals\"/-->\r\n-        <module name=\"CovariantEquals\"/>\r\n-        <module name=\"DoubleCheckedLocking\"/>\r\n-        <module name=\"EmptyStatement\"/>\r\n-        <module name=\"EqualsAvoidNull\"/>\r\n-        <module name=\"EqualsHashCode\"/>\r\n-        <!--module name=\"HiddenField\"/-->\r\n-        <module name=\"IllegalInstantiation\"/>\r\n-        <module name=\"InnerAssignment\"/>\r\n-        <module name=\"MagicNumber\"/>\r\n-        <module name=\"MissingSwitchDefault\"/>\r\n-        <module name=\"RedundantThrows\"/>\r\n-        <module name=\"SimplifyBooleanExpression\"/>\r\n-        <module name=\"SimplifyBooleanReturn\"/>\r\n-\r\n-        <!-- Checks for class design                         -->\r\n-        <!-- See http://checkstyle.sf.net/config_design.html -->\r\n-        <!--module name=\"DesignForExtension\"/-->\r\n-        <module name=\"FinalClass\"/>\r\n-        <module name=\"HideUtilityClassConstructor\"/>\r\n-        <module name=\"InterfaceIsType\"/>\r\n-        <!--module name=\"VisibilityModifier\"/-->\r\n-\r\n-\r\n-        <!-- Miscellaneous other checks.                   -->\r\n-        <!-- See http://checkstyle.sf.net/config_misc.html -->\r\n-        <module name=\"ArrayTypeStyle\"/>\r\n-        <!--module name=\"FinalParameters\"/-->\r\n-        <module name=\"TodoComment\"/>\r\n-        <module name=\"UpperEll\"/>\r\n-    </module>\r\n-</module>\r\n+<?xml version=\"1.0\"?>\n+<!DOCTYPE module PUBLIC\n+    \"-//Puppy Crawl//DTD Check Configuration 1.2//EN\"\n+    \"http://www.puppycrawl.com/dtds/configuration_1_2.dtd\">\n+\n+<module name=\"Checker\">\n+  <module name=\"NewlineAtEndOfFile\"/>\n+  <module name=\"FileLength\"/>\n+  <module name=\"FileTabCharacter\"/>\n+\n+  <!-- Trailing spaces -->\n+  <module name=\"RegexpSingleline\">\n+    <property name=\"format\" value=\"\\s+$\"/>\n+    <property name=\"message\" value=\"Line has trailing spaces.\"/>\n+  </module>\n+\n+  <module name=\"TreeWalker\">\n+    <property name=\"cacheFile\" value=\"${checkstyle.cache.file}\"/>\n+\n+    <!-- Checks for Javadoc comments.                     -->\n+    <!-- See http://checkstyle.sf.net/config_javadoc.html -->\n+    <!--module name=\"JavadocMethod\"/-->\n+    <!--module name=\"JavadocType\"/-->\n+    <!--module name=\"JavadocVariable\"/-->\n+    <module name=\"JavadocStyle\"/>\n+\n+\n+    <!-- Checks for Naming Conventions.                  -->\n+    <!-- See http://checkstyle.sf.net/config_naming.html -->\n+    <module name=\"ConstantName\"/>\n+    <module name=\"LocalFinalVariableName\"/>\n+    <module name=\"LocalVariableName\"/>\n+    <module name=\"MemberName\"/>\n+    <module name=\"MethodName\"/>\n+    <module name=\"PackageName\"/>\n+    <module name=\"ParameterName\"/>\n+    <module name=\"StaticVariableName\"/>\n+    <module name=\"TypeName\"/>\n+\n+\n+    <!-- Checks for imports                              -->\n+    <!-- See http://checkstyle.sf.net/config_import.html -->\n+    <module name=\"AvoidStarImport\"/>\n+    <module name=\"IllegalImport\"/>\n+    <!-- defaults to sun.* packages -->\n+    <module name=\"RedundantImport\"/>\n+    <module name=\"UnusedImports\"/>\n+\n+\n+    <!-- Checks for Size Violations.                    -->\n+    <!-- See http://checkstyle.sf.net/config_sizes.html -->\n+    <module name=\"LineLength\">\n+      <property name=\"max\" value=\"100\"/>\n+    </module>\n+    <module name=\"MethodLength\"/>\n+    <module name=\"ParameterNumber\"/>\n+\n+\n+    <!-- Checks for whitespace                               -->\n+    <!-- See http://checkstyle.sf.net/config_whitespace.html -->\n+    <module name=\"GenericWhitespace\"/>\n+    <module name=\"EmptyForIteratorPad\"/>\n+    <module name=\"MethodParamPad\"/>\n+    <module name=\"NoWhitespaceAfter\"/>\n+    <module name=\"NoWhitespaceBefore\"/>\n+    <module name=\"OperatorWrap\"/>\n+    <module name=\"ParenPad\"/>\n+    <module name=\"TypecastParenPad\"/>\n+    <module name=\"WhitespaceAfter\"/>\n+    <module name=\"WhitespaceAround\"/>\n+\n+\n+    <!-- Modifier Checks                                    -->\n+    <!-- See http://checkstyle.sf.net/config_modifiers.html -->\n+    <module name=\"ModifierOrder\"/>\n+    <module name=\"RedundantModifier\"/>\n+\n+\n+    <!-- Checks for blocks. You know, those {}'s         -->\n+    <!-- See http://checkstyle.sf.net/config_blocks.html -->\n+    <module name=\"AvoidNestedBlocks\"/>\n+    <!--module name=\"EmptyBlock\"/-->\n+    <module name=\"LeftCurly\"/>\n+    <module name=\"NeedBraces\"/>\n+    <module name=\"RightCurly\"/>\n+\n+\n+    <!-- Checks for common coding problems               -->\n+    <!-- See http://checkstyle.sf.net/config_coding.html -->\n+    <!--module name=\"AvoidInlineConditionals\"/-->\n+    <module name=\"CovariantEquals\"/>\n+    <module name=\"DoubleCheckedLocking\"/>\n+    <module name=\"EmptyStatement\"/>\n+    <module name=\"EqualsAvoidNull\"/>\n+    <module name=\"EqualsHashCode\"/>\n+    <!--module name=\"HiddenField\"/-->\n+    <module name=\"IllegalInstantiation\"/>\n+    <module name=\"InnerAssignment\"/>\n+    <module name=\"MagicNumber\"/>\n+    <module name=\"MissingSwitchDefault\"/>\n+    <module name=\"RedundantThrows\"/>\n+    <module name=\"SimplifyBooleanExpression\"/>\n+    <module name=\"SimplifyBooleanReturn\"/>\n+\n+    <!-- Checks for class design                         -->\n+    <!-- See http://checkstyle.sf.net/config_design.html -->\n+    <!--module name=\"DesignForExtension\"/-->\n+    <module name=\"FinalClass\"/>\n+    <module name=\"HideUtilityClassConstructor\"/>\n+    <module name=\"InterfaceIsType\"/>\n+    <!--module name=\"VisibilityModifier\"/-->\n+\n+\n+    <!-- Miscellaneous other checks.                   -->\n+    <!-- See http://checkstyle.sf.net/config_misc.html -->\n+    <module name=\"ArrayTypeStyle\"/>\n+    <!--module name=\"FinalParameters\"/-->\n+    <module name=\"TodoComment\"/>\n+    <module name=\"UpperEll\"/>\n+  </module>\n+</module>\n"
    },
    {
        "commit_hash": "25472fde4ff37b5df72876c4919c202493727358",
        "previous_commit_hash": "763621dc035b65e8e8d75761b645a8a281d5b3fc",
        "diff_stats": {
            "additions": 7,
            "deletions": 0
        },
        "diff_content": "@@ -1,6 +1,13 @@\n Change Log\n ==========\n \n+Version 2.4.0 *(2014-01-10)*\n+----------------------------\n+\n+ * New: Properly indent hanging lines in field initializers.\n+ * New: `emitEnumValue` variant which exposes a boolean of whether the current value is the last.\n+\n+\n Version 2.3.1 *(2013-12-16)*\n ----------------------------\n \n"
    },
    {
        "commit_hash": "5eeae81953555b45b098b53dcda9dedaac3faed1",
        "previous_commit_hash": "25472fde4ff37b5df72876c4919c202493727358",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javawriter</artifactId>\n-  <version>2.3.2-SNAPSHOT</version>\n+  <version>2.4.0</version>\n \n   <name>JavaWriter</name>\n   <description>A utility class which aids in generating Java source files.</description>\n"
    },
    {
        "commit_hash": "f6a479ce01e40365924103baa9f143a44ed4c5ab",
        "previous_commit_hash": "5eeae81953555b45b098b53dcda9dedaac3faed1",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javawriter</artifactId>\n-  <version>2.4.0</version>\n+  <version>2.4.1-SNAPSHOT</version>\n \n   <name>JavaWriter</name>\n   <description>A utility class which aids in generating Java source files.</description>\n"
    },
    {
        "commit_hash": "c268516e64e2deebf570d8a8d6a9f376bfdcc40a",
        "previous_commit_hash": "f6a479ce01e40365924103baa9f143a44ed4c5ab",
        "diff_stats": {
            "additions": 6,
            "deletions": 6
        },
        "diff_content": "@@ -667,10 +667,10 @@ public class JavaWriter implements Closeable {\n    * @param controlFlow the control flow construct and its code, such as \"if (foo == 5)\". Shouldn't\n    *     contain braces or newline characters.\n    */\n-  public JavaWriter beginControlFlow(String controlFlow) throws IOException {\n+  public JavaWriter beginControlFlow(String controlFlow, Object... args) throws IOException {\n     checkInMethod();\n     indent();\n-    out.write(controlFlow);\n+    out.write(String.format(controlFlow, args));\n     out.write(\" {\\n\");\n     scopes.push(Scope.CONTROL_FLOW);\n     return this;\n@@ -680,12 +680,12 @@ public class JavaWriter implements Closeable {\n    * @param controlFlow the control flow construct and its code, such as \"else if (foo == 10)\".\n    *     Shouldn't contain braces or newline characters.\n    */\n-  public JavaWriter nextControlFlow(String controlFlow) throws IOException {\n+  public JavaWriter nextControlFlow(String controlFlow, Object... args) throws IOException {\n     popScope(Scope.CONTROL_FLOW);\n     indent();\n     scopes.push(Scope.CONTROL_FLOW);\n     out.write(\"} \");\n-    out.write(controlFlow);\n+    out.write(String.format(controlFlow, args));\n     out.write(\" {\\n\");\n     return this;\n   }\n@@ -698,12 +698,12 @@ public class JavaWriter implements Closeable {\n    * @param controlFlow the optional control flow construct and its code, such as\n    *     \"while(foo == 20)\". Only used for \"do/while\" control flows.\n    */\n-  public JavaWriter endControlFlow(String controlFlow) throws IOException {\n+  public JavaWriter endControlFlow(String controlFlow, Object... args) throws IOException {\n     popScope(Scope.CONTROL_FLOW);\n     indent();\n     if (controlFlow != null) {\n       out.write(\"} \");\n-      out.write(controlFlow);\n+      out.write(String.format(controlFlow, args));\n       out.write(\";\\n\");\n     } else {\n       out.write(\"}\\n\");\n"
    },
    {
        "commit_hash": "1378c01dbecec5c789797895d3168c1e2fb6a815",
        "previous_commit_hash": "50579db451b464910412afaebec83a082277d49e",
        "diff_stats": {
            "additions": 9,
            "deletions": 3
        },
        "diff_content": "@@ -299,14 +299,19 @@ public class JavaWriter implements Closeable {\n       }\n     }\n     out.write(\" {\\n\");\n-    scopes.push(Scope.TYPE_DECLARATION);\n+    scopes.push(\"interface\".equals(kind) ? Scope.INTERFACE_DECLARATION : Scope.TYPE_DECLARATION);\n     types.push(type);\n     return this;\n   }\n \n   /** Completes the current type declaration. */\n   public JavaWriter endType() throws IOException {\n-    popScope(Scope.TYPE_DECLARATION);\n+    Scope beginScope = scopes.getFirst();\n+    if (Scope.TYPE_DECLARATION.equals(beginScope)) {\n+        popScope(Scope.TYPE_DECLARATION);\n+    } else {\n+        popScope(Scope.INTERFACE_DECLARATION);\n+    }\n     types.pop();\n     indent();\n     out.write(\"}\\n\");\n@@ -412,7 +417,7 @@ public class JavaWriter implements Closeable {\n         emitCompressedType(throwsTypes.get(i));\n       }\n     }\n-    if (modifiers.contains(ABSTRACT)) {\n+    if (modifiers.contains(ABSTRACT) || Scope.INTERFACE_DECLARATION.equals(scopes.getFirst())) {\n       out.write(\";\\n\");\n       scopes.push(Scope.ABSTRACT_METHOD);\n     } else {\n@@ -836,6 +841,7 @@ public class JavaWriter implements Closeable {\n \n   private enum Scope {\n     TYPE_DECLARATION,\n+    INTERFACE_DECLARATION,\n     ABSTRACT_METHOD,\n     NON_ABSTRACT_METHOD,\n     CONSTRUCTOR,\n"
    },
    {
        "commit_hash": "1378c01dbecec5c789797895d3168c1e2fb6a815",
        "previous_commit_hash": "50579db451b464910412afaebec83a082277d49e",
        "diff_stats": {
            "additions": 32,
            "deletions": 0
        },
        "diff_content": "@@ -207,6 +207,38 @@ public final class JavaWriterTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void interfaceMethodDeclaration() throws IOException {\n+    javaWriter.emitPackage(\"com.squareup\");\n+    javaWriter.beginType(\"com.squareup.Foo\", \"interface\");\n+    javaWriter.beginMethod(\"java.lang.String\", \"foo\", EnumSet.noneOf(Modifier.class),\n+        \"java.lang.Object\", \"object\", \"java.lang.String\", \"s\");\n+    javaWriter.endMethod();\n+    javaWriter.endType();\n+    assertCode(\"\"\n+        + \"package com.squareup;\\n\"\n+        + \"\\n\"\n+        + \"interface Foo {\\n\"\n+        + \"  String foo(Object object, String s);\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void interfaceMethodDeclarationWithThrows() throws IOException {\n+    javaWriter.emitPackage(\"com.squareup\");\n+    javaWriter.beginType(\"com.squareup.Foo\", \"interface\");\n+    javaWriter.beginMethod(\"java.lang.String\", \"foo\", EnumSet.noneOf(Modifier.class),\n+        Arrays.asList(\"java.lang.Object\", \"object\", \"java.lang.String\", \"s\"),\n+        Arrays.asList(\"java.io.IOException\"));\n+    javaWriter.endMethod();\n+    javaWriter.endType();\n+    assertCode(\"\"\n+        + \"package com.squareup;\\n\"\n+        + \"\\n\"\n+        + \"interface Foo {\\n\"\n+        + \"  String foo(Object object, String s)\\n\"\n+        + \"      throws java.io.IOException;\\n\"\n+        + \"}\\n\");\n+  }\n+\n   @Test public void constructorDeclaration() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n     javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n"
    },
    {
        "commit_hash": "7e55824bc4fbc54cd8d79092f7cd80a6fb61aece",
        "previous_commit_hash": "1378c01dbecec5c789797895d3168c1e2fb6a815",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -308,9 +308,9 @@ public class JavaWriter implements Closeable {\n   public JavaWriter endType() throws IOException {\n     Scope beginScope = scopes.getFirst();\n     if (Scope.TYPE_DECLARATION.equals(beginScope)) {\n-        popScope(Scope.TYPE_DECLARATION);\n+      popScope(Scope.TYPE_DECLARATION);\n     } else {\n-        popScope(Scope.INTERFACE_DECLARATION);\n+      popScope(Scope.INTERFACE_DECLARATION);\n     }\n     types.pop();\n     indent();\n"
    },
    {
        "commit_hash": "329663e78e3a8ab7765cf8f8964e034ae71e4880",
        "previous_commit_hash": "7e55824bc4fbc54cd8d79092f7cd80a6fb61aece",
        "diff_stats": {
            "additions": 4,
            "deletions": 9
        },
        "diff_content": "@@ -306,12 +306,7 @@ public class JavaWriter implements Closeable {\n \n   /** Completes the current type declaration. */\n   public JavaWriter endType() throws IOException {\n-    Scope beginScope = scopes.getFirst();\n-    if (Scope.TYPE_DECLARATION.equals(beginScope)) {\n-      popScope(Scope.TYPE_DECLARATION);\n-    } else {\n-      popScope(Scope.INTERFACE_DECLARATION);\n-    }\n+    popScope(Scope.TYPE_DECLARATION, Scope.INTERFACE_DECLARATION);\n     types.pop();\n     indent();\n     out.write(\"}\\n\");\n@@ -417,7 +412,7 @@ public class JavaWriter implements Closeable {\n         emitCompressedType(throwsTypes.get(i));\n       }\n     }\n-    if (modifiers.contains(ABSTRACT) || Scope.INTERFACE_DECLARATION.equals(scopes.getFirst())) {\n+    if (modifiers.contains(ABSTRACT) || Scope.INTERFACE_DECLARATION.equals(scopes.peek())) {\n       out.write(\";\\n\");\n       scopes.push(Scope.ABSTRACT_METHOD);\n     } else {\n@@ -833,8 +828,8 @@ public class JavaWriter implements Closeable {\n     }\n   }\n \n-  private void popScope(Scope expected) {\n-    if (scopes.pop() != expected) {\n+  private void popScope(Scope... expected) {\n+    if (!EnumSet.copyOf(Arrays.asList(expected)).contains(scopes.pop())) {\n       throw new IllegalStateException();\n     }\n   }\n"
    },
    {
        "commit_hash": "917a79415736198c54578357e5c9b39bcf082cbb",
        "previous_commit_hash": "50579db451b464910412afaebec83a082277d49e",
        "diff_stats": {
            "additions": 13,
            "deletions": 1
        },
        "diff_content": "@@ -10,10 +10,10 @@ import java.util.Collections;\n import java.util.EnumSet;\n import java.util.Iterator;\n import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n-\n import javax.lang.model.element.Modifier;\n import org.junit.Test;\n \n@@ -805,6 +805,18 @@ public final class JavaWriterTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void outOfOrderModifierSet() throws IOException {\n+    Set<Modifier> modifiers = new LinkedHashSet<Modifier>(Arrays.asList(FINAL, PUBLIC));\n+    javaWriter.emitPackage(\"com.squareup\");\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\", modifiers);\n+    javaWriter.endType();\n+    assertCode(\"\"\n+        + \"package com.squareup;\\n\"\n+        + \"\\n\"\n+        + \"public final class Foo {\\n\"\n+        + \"}\\n\");\n+  }\n+\n   private void assertCode(String expected) {\n     assertThat(stringWriter.toString()).isEqualTo(expected);\n   }\n"
    },
    {
        "commit_hash": "46154db9a98d365e24e146befafaaecfd6a41fc2",
        "previous_commit_hash": "c5de70d09debc3aa90819b073a596f652fd5117e",
        "diff_stats": {
            "additions": 11,
            "deletions": 2
        },
        "diff_content": "@@ -424,14 +424,14 @@ public class JavaWriter implements Closeable {\n \n   public JavaWriter beginConstructor(Set<Modifier> modifiers, String... parameters)\n       throws IOException {\n-    beginMethod(null, types.peekFirst(), modifiers, parameters);\n+    beginMethod(null, rawType(types.peekFirst()), modifiers, parameters);\n     return this;\n   }\n \n   public JavaWriter beginConstructor(Set<Modifier> modifiers,\n       List<String> parameters, List<String> throwsTypes)\n       throws IOException {\n-    beginMethod(null, types.peekFirst(), modifiers, parameters, throwsTypes);\n+    beginMethod(null, rawType(types.peekFirst()), modifiers, parameters, throwsTypes);\n     return this;\n   }\n \n@@ -792,6 +792,15 @@ public class JavaWriter implements Closeable {\n     return result.toString();\n   }\n \n+  /** Build a string representation of the raw type for a (optionally generic) type. */\n+  public static String rawType(String type) {\n+    int lessThanIndex = type.indexOf('<');\n+    if (lessThanIndex != -1) {\n+      return type.substring(0, lessThanIndex);\n+    }\n+    return type;\n+  }\n+\n   @Override public void close() throws IOException {\n     out.close();\n   }\n"
    },
    {
        "commit_hash": "46154db9a98d365e24e146befafaaecfd6a41fc2",
        "previous_commit_hash": "c5de70d09debc3aa90819b073a596f652fd5117e",
        "diff_stats": {
            "additions": 38,
            "deletions": 0
        },
        "diff_content": "@@ -239,6 +239,31 @@ public final class JavaWriterTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void genericsConstructor() throws IOException {\n+      javaWriter.emitPackage(\"com.squareup\");\n+      javaWriter.beginType(\"com.squareup.Foo<T>\", \"class\");\n+      javaWriter.emitField(\"T\", \"fooType\", EnumSet.of(PRIVATE));\n+      javaWriter.beginConstructor(EnumSet.of(PUBLIC), \"T\", \"s\");\n+      javaWriter.emitStatement(\"if (%s == null) throw new NullPointerException()\", \"s\");\n+      javaWriter.endConstructor();\n+      javaWriter.beginMethod(\"T\", \"getFooType\", EnumSet.of(PUBLIC));\n+      javaWriter.emitStatement(\"return fooType\");\n+      javaWriter.endMethod();\n+      javaWriter.endType();\n+      assertCode(\"\"\n+          + \"package com.squareup;\\n\"\n+          + \"\\n\"\n+          + \"class Foo<T> {\\n\"\n+          + \"  private T fooType;\\n\"\n+          + \"  public Foo(T s) {\\n\"\n+          + \"    if (s == null) throw new NullPointerException();\\n\"\n+          + \"  }\\n\"\n+          + \"  public T getFooType() {\\n\"\n+          + \"    return fooType;\\n\"\n+          + \"  }\\n\"\n+          + \"}\\n\");\n+    }\n+\n   @Test public void constructorDeclarationInNestedTypes() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n     javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n@@ -744,6 +769,19 @@ public final class JavaWriterTest {\n     }\n   }\n \n+  @Test public void testRawType() {\n+      assertThat(JavaWriter.rawType(JavaWriter.type(Set.class)))\n+          .as(\"raw type\").isEqualTo(\"java.util.Set\");\n+      assertThat(JavaWriter.rawType(JavaWriter.type(Set.class, \"?\")))\n+          .as(\"wildcard type\").isEqualTo(\"java.util.Set\");\n+      assertThat(JavaWriter.rawType(JavaWriter.type(Set.class, \"String\")))\n+          .as(\"parameterized type\").isEqualTo(\"java.util.Set\");\n+      assertThat(JavaWriter.rawType(JavaWriter.type(Map.class, \"String\", \"Integer\")))\n+          .as(\"parameterized type\").isEqualTo(\"java.util.Map\");\n+      assertThat(JavaWriter.rawType(\"java.util.Set<com.example.Binding<com.blah.Foo.Blah>>\"))\n+          .as(\"nested parameterized type\").isEqualTo(\"java.util.Set\");\n+  }\n+\n   @Test public void compressType() throws IOException {\n     javaWriter.emitPackage(\"com.blah\");\n     javaWriter.emitImports(Set.class.getCanonicalName(), Binding.class.getCanonicalName());\n"
    },
    {
        "commit_hash": "fced3142b50891ec5621e80fa57d849a430d652a",
        "previous_commit_hash": "181c7ca6d6fe328628b855bdf9582b238bf7d896",
        "diff_stats": {
            "additions": 3,
            "deletions": 0
        },
        "diff_content": "@@ -798,6 +798,9 @@ public class JavaWriter implements Closeable {\n \n   /** Emits the modifiers to the writer. */\n   private void emitModifiers(Set<Modifier> modifiers) throws IOException {\n+    if (modifiers.isEmpty()) {\n+      return;\n+    }\n     // Use an EnumSet to ensure the proper ordering\n     if (!(modifiers instanceof EnumSet)) {\n       modifiers = EnumSet.copyOf(modifiers);\n"
    },
    {
        "commit_hash": "fced3142b50891ec5621e80fa57d849a430d652a",
        "previous_commit_hash": "181c7ca6d6fe328628b855bdf9582b238bf7d896",
        "diff_stats": {
            "additions": 11,
            "deletions": 0
        },
        "diff_content": "@@ -849,6 +849,17 @@ public final class JavaWriterTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void emptyNonEnumModifierSet() throws IOException {\n+    javaWriter.emitPackage(\"com.squareup\");\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\", new LinkedHashSet<Modifier>());\n+    javaWriter.endType();\n+    assertCode(\"\"\n+        + \"package com.squareup;\\n\"\n+        + \"\\n\"\n+        + \"class Foo {\\n\"\n+        + \"}\\n\");\n+  }\n+\n   private void assertCode(String expected) {\n     assertThat(stringWriter.toString()).isEqualTo(expected);\n   }\n"
    },
    {
        "commit_hash": "541accbec66db1de2b4b568b559737d101b5dadf",
        "previous_commit_hash": "cb24911fdcfe3a96a54c30f5f63871a7f03c16f9",
        "diff_stats": {
            "additions": 4,
            "deletions": 1
        },
        "diff_content": "@@ -334,7 +334,10 @@ public class JavaWriter implements Closeable {\n     out.write(name);\n \n     if (initialValue != null) {\n-      out.write(\" = \");\n+      out.write(\" =\");\n+      if (!initialValue.startsWith(\"\\n\")) {\n+        out.write(\" \");\n+      }\n \n       String[] lines = initialValue.split(\"\\n\", -1);\n       out.write(lines[0]);\n"
    },
    {
        "commit_hash": "541accbec66db1de2b4b568b559737d101b5dadf",
        "previous_commit_hash": "cb24911fdcfe3a96a54c30f5f63871a7f03c16f9",
        "diff_stats": {
            "additions": 18,
            "deletions": 0
        },
        "diff_content": "@@ -143,6 +143,24 @@ public final class JavaWriterTest {\n         + \"}\\n\");\n   }\n \n+  // If the initializer begins with a newline, don't emit a space after the '='.\n+  @Test public void fieldDeclarationWithNewlineInitialValue() throws IOException {\n+    javaWriter.emitPackage(\"com.squareup\");\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n+    javaWriter.emitField(\"java.lang.String\", \"string\", EnumSet.noneOf(Modifier.class),\n+        \"\\n\\\"bar\\\"\\n+ \\\"baz\\\"\\n+ \\\"biz\\\"\");\n+    javaWriter.endType();\n+    assertCode(\"\"\n+        + \"package com.squareup;\\n\"\n+        + \"\\n\"\n+        + \"class Foo {\\n\"\n+        + \"  String string =\\n\"\n+        + \"      \\\"bar\\\"\\n\"\n+        + \"      + \\\"baz\\\"\\n\"\n+        + \"      + \\\"biz\\\";\\n\"\n+        + \"}\\n\");\n+  }\n+\n   @Test public void abstractMethodDeclaration() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n     javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n"
    },
    {
        "commit_hash": "048d1fc80bb71c269ad4cb1c70b4958e4385d4b5",
        "previous_commit_hash": "93ddadf971a8504ff1781f045d9e0e7520f7c246",
        "diff_stats": {
            "additions": 9,
            "deletions": 0
        },
        "diff_content": "@@ -1,6 +1,15 @@\n Change Log\n ==========\n \n+Version 2.5.0 *(2014-04-18)*\n+----------------------------\n+\n+ * New: Methods in interfaces will always have no body declaration.\n+ * New: Control flow begin declaration now supports String format arguments.\n+ * Fix: Truncate any generic type when emitting constructors.\n+ * Fix: Do not emit trailing whitespace after '=' at end-of-line.\n+\n+\n Version 2.4.0 *(2014-01-10)*\n ----------------------------\n \n"
    },
    {
        "commit_hash": "ace739ded010ec366f3c2a7a1501d01b7979297d",
        "previous_commit_hash": "048d1fc80bb71c269ad4cb1c70b4958e4385d4b5",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javawriter</artifactId>\n-  <version>2.4.1-SNAPSHOT</version>\n+  <version>2.5.0</version>\n \n   <name>JavaWriter</name>\n   <description>A utility class which aids in generating Java source files.</description>\n"
    },
    {
        "commit_hash": "edb9565883a140c635aac17dbcb5555c20d143b7",
        "previous_commit_hash": "ace739ded010ec366f3c2a7a1501d01b7979297d",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javawriter</artifactId>\n-  <version>2.5.0</version>\n+  <version>2.5.1-SNAPSHOT</version>\n \n   <name>JavaWriter</name>\n   <description>A utility class which aids in generating Java source files.</description>\n"
    },
    {
        "commit_hash": "105d4b208fff6cb2831f75a8aac77e0b1cd64bbb",
        "previous_commit_hash": "edb9565883a140c635aac17dbcb5555c20d143b7",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -95,7 +95,7 @@ public class JavaWriter implements Closeable {\n   public JavaWriter emitImports(Class<?>... types) throws IOException {\n     List<String> classNames = new ArrayList<String>(types.length);\n     for (Class<?> classToImport : types) {\n-      classNames.add(classToImport.getName());\n+      classNames.add(classToImport.getCanonicalName());\n     }\n     return emitImports(classNames);\n   }\n"
    },
    {
        "commit_hash": "105d4b208fff6cb2831f75a8aac77e0b1cd64bbb",
        "previous_commit_hash": "edb9565883a140c635aac17dbcb5555c20d143b7",
        "diff_stats": {
            "additions": 19,
            "deletions": 0
        },
        "diff_content": "@@ -458,6 +458,25 @@ public final class JavaWriterTest {\n         + \"}\\n\");\n   }\n \n+  @Test\n+  public void addNestedClassImportAsClass() throws IOException {\n+    javaWriter.emitPackage(\"com.squareup\");\n+    javaWriter.emitImports(NestedClass.class);\n+    javaWriter.beginType(\"com.squareup.Foo\", \"class\", EnumSet.of(PUBLIC, FINAL));\n+    javaWriter.emitField(\"com.squareup.javawriter.JavaWriterTest.NestedClass\", \"nestedClass\",\n+        EnumSet.noneOf(Modifier.class), \"new NestedClass()\");\n+    javaWriter.endType();\n+    assertCode(\"\"\n+        + \"package com.squareup;\\n\"\n+        + \"\\n\"\n+        + \"import com.squareup.javawriter.JavaWriterTest.NestedClass;\\n\"\n+        + \"public final class Foo {\\n\"\n+        + \"  NestedClass nestedClass = new NestedClass();\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  public static class NestedClass {}\n+\n   @Test public void addStaticWildcardImport() throws IOException {\n     javaWriter.emitPackage(\"com.squareup\");\n     javaWriter.emitStaticImports(\"java.lang.System.*\");\n"
    },
    {
        "commit_hash": "3bb28b3ada49c81ee8c3ba890a1638996c795f83",
        "previous_commit_hash": "6fff17a988deb4e0d8c35cf6b7607d7db83035ff",
        "diff_stats": {
            "additions": 7,
            "deletions": 37
        },
        "diff_content": "@@ -735,44 +735,14 @@ public class JavaWriter implements Closeable {\n     return this;\n   }\n \n-  /** Returns the string literal representing {@code data}, including wrapping quotes. */\n+  /**\n+   * Returns the string literal representing {@code data}, including wrapping quotes.\n+   *\n+   * @deprecated use {@link StringLiteral} and its {@link StringLiteral#literal()} method instead.\n+   */\n+  @Deprecated\n   public static String stringLiteral(String data) {\n-    StringBuilder result = new StringBuilder();\n-    result.append('\"');\n-    for (int i = 0; i < data.length(); i++) {\n-      char c = data.charAt(i);\n-      switch (c) {\n-        case '\"':\n-          result.append(\"\\\\\\\"\");\n-          break;\n-        case '\\\\':\n-          result.append(\"\\\\\\\\\");\n-          break;\n-        case '\\b':\n-          result.append(\"\\\\b\");\n-          break;\n-        case '\\t':\n-          result.append(\"\\\\t\");\n-          break;\n-        case '\\n':\n-          result.append(\"\\\\n\");\n-          break;\n-        case '\\f':\n-          result.append(\"\\\\f\");\n-          break;\n-        case '\\r':\n-          result.append(\"\\\\r\");\n-          break;\n-        default:\n-          if (Character.isISOControl(c)) {\n-            result.append(String.format(\"\\\\u%04x\", (int) c));\n-          } else {\n-            result.append(c);\n-          }\n-      }\n-    }\n-    result.append('\"');\n-    return result.toString();\n+    return StringLiteral.forValue(data).literal();\n   }\n \n   /** Build a string representation of a type and optionally its generic type arguments. */\n"
    },
    {
        "commit_hash": "3bb28b3ada49c81ee8c3ba890a1638996c795f83",
        "previous_commit_hash": "6fff17a988deb4e0d8c35cf6b7607d7db83035ff",
        "diff_stats": {
            "additions": 91,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,91 @@\n+// Copyright 2014 Square, Inc.\n+package com.squareup.javawriter;\n+\n+import java.util.Formatter;\n+\n+/**\n+ * Represents a string literal as found in Java source code.\n+ */\n+public final class StringLiteral {\n+  /** Returns a new {@link StringLiteral} instance for the intended value of the literal. */\n+  public static StringLiteral forValue(String value) {\n+    return new StringLiteral(value, stringLiteral(value));\n+  }\n+\n+  /** Returns the string literal representing {@code data}, including wrapping quotes. */\n+  private static String stringLiteral(String value) {\n+    StringBuilder result = new StringBuilder();\n+    result.append('\"');\n+    for (int i = 0; i < value.length(); i++) {\n+      char c = value.charAt(i);\n+      switch (c) {\n+        case '\"':\n+          result.append(\"\\\\\\\"\");\n+          break;\n+        case '\\\\':\n+          result.append(\"\\\\\\\\\");\n+          break;\n+        case '\\b':\n+          result.append(\"\\\\b\");\n+          break;\n+        case '\\t':\n+          result.append(\"\\\\t\");\n+          break;\n+        case '\\n':\n+          result.append(\"\\\\n\");\n+          break;\n+        case '\\f':\n+          result.append(\"\\\\f\");\n+          break;\n+        case '\\r':\n+          result.append(\"\\\\r\");\n+          break;\n+        default:\n+          if (Character.isISOControl(c)) {\n+            new Formatter(result).format(\"\\\\u%04x\", (int) c);\n+          } else {\n+            result.append(c);\n+          }\n+      }\n+    }\n+    result.append('\"');\n+    return result.toString();\n+  }\n+\n+  private final String value;\n+  private final String literal;\n+\n+  private StringLiteral(String value, String literal) {\n+    this.value = value;\n+    this.literal = literal;\n+  }\n+\n+  public String value() {\n+    return value;\n+  }\n+\n+  public String literal() {\n+    return literal;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return literal;\n+  }\n+\n+  @Override\n+  public boolean equals(Object obj) {\n+    if (obj == this) {\n+      return true;\n+    } else if (obj instanceof StringLiteral) {\n+      return this.value.equals(((StringLiteral) obj).value);\n+    } else {\n+      return false;\n+    }\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return value.hashCode();\n+  }\n+}\n"
    },
    {
        "commit_hash": "3bb28b3ada49c81ee8c3ba890a1638996c795f83",
        "previous_commit_hash": "6fff17a988deb4e0d8c35cf6b7607d7db83035ff",
        "diff_stats": {
            "additions": 2,
            "deletions": 37
        },
        "diff_content": "@@ -17,7 +17,6 @@ import java.util.Set;\n import javax.lang.model.element.Modifier;\n import org.junit.Test;\n \n-import static com.squareup.javawriter.JavaWriter.stringLiteral;\n import static javax.lang.model.element.Modifier.ABSTRACT;\n import static javax.lang.model.element.Modifier.FINAL;\n import static javax.lang.model.element.Modifier.PRIVATE;\n@@ -605,7 +604,7 @@ public final class JavaWriterTest {\n     javaWriter.emitImports(\"javax.inject.Singleton\");\n     javaWriter.emitAnnotation(\"javax.inject.Singleton\");\n     javaWriter.emitAnnotation(SuppressWarnings.class,\n-        JavaWriter.stringLiteral(\"unchecked\"));\n+        StringLiteral.forValue(\"unchecked\"));\n     javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n     javaWriter.endType();\n     assertCode(\"\"\n@@ -651,7 +650,7 @@ public final class JavaWriterTest {\n \n   @Test public void annotatedWithSingleValueAttribute() throws IOException {\n     Map<String, Object> attributes = new LinkedHashMap<String, Object>();\n-    attributes.put(\"value\", stringLiteral(\"blah.Generator\"));\n+    attributes.put(\"value\", StringLiteral.forValue(\"blah.Generator\"));\n \n     javaWriter.emitPackage(\"com.squareup\");\n     javaWriter.emitAnnotation(\"Generated\", attributes);\n@@ -777,40 +776,6 @@ public final class JavaWriterTest {\n     );\n   }\n \n-  @Test public void testStringLiteral() {\n-    assertThat(JavaWriter.stringLiteral(\"\")).isEqualTo(\"\\\"\\\"\");\n-    assertThat(JavaWriter.stringLiteral(\"JavaWriter\")).isEqualTo(\"\\\"JavaWriter\\\"\");\n-    assertThat(JavaWriter.stringLiteral(\"\\\\\")).isEqualTo(\"\\\"\\\\\\\\\\\"\");\n-    assertThat(JavaWriter.stringLiteral(\"\\\"\")).isEqualTo(\"\\\"\\\\\\\"\\\"\");\n-    assertThat(JavaWriter.stringLiteral(\"\\b\")).isEqualTo(\"\\\"\\\\b\\\"\");\n-    assertThat(JavaWriter.stringLiteral(\"\\t\")).isEqualTo(\"\\\"\\\\t\\\"\");\n-    assertThat(JavaWriter.stringLiteral(\"\\n\")).isEqualTo(\"\\\"\\\\n\\\"\");\n-    assertThat(JavaWriter.stringLiteral(\"\\f\")).isEqualTo(\"\\\"\\\\f\\\"\");\n-    assertThat(JavaWriter.stringLiteral(\"\\r\")).isEqualTo(\"\\\"\\\\r\\\"\");\n-\n-    // Control characters\n-    for (char i = 0x1; i <= 0x1f; i++) {\n-      checkCharEscape(i);\n-    }\n-    for (char i = 0x7f; i <= 0x9f; i++) {\n-      checkCharEscape(i);\n-    }\n-  }\n-\n-  private void checkCharEscape(char codePoint) {\n-    String test = \"\" + codePoint;\n-    String expected;\n-    switch (codePoint) {\n-      case 8: expected = \"\\\"\\\\b\\\"\"; break;\n-      case 9: expected = \"\\\"\\\\t\\\"\"; break;\n-      case 10: expected = \"\\\"\\\\n\\\"\"; break;\n-      case 12: expected = \"\\\"\\\\f\\\"\"; break;\n-      case 13: expected = \"\\\"\\\\r\\\"\"; break;\n-      default: expected = \"\\\"\\\\u\" + String.format(\"%04x\", (int) codePoint) + \"\\\"\";\n-    }\n-    assertThat(JavaWriter.stringLiteral(test)).isEqualTo(expected);\n-  }\n-\n   @Test public void testType() {\n     assertThat(JavaWriter.type(String.class)).as(\"simple type\").isEqualTo(\"java.lang.String\");\n     assertThat(JavaWriter.type(Set.class)).as(\"raw type\").isEqualTo(\"java.util.Set\");\n"
    },
    {
        "commit_hash": "3bb28b3ada49c81ee8c3ba890a1638996c795f83",
        "previous_commit_hash": "6fff17a988deb4e0d8c35cf6b7607d7db83035ff",
        "diff_stats": {
            "additions": 46,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,46 @@\n+// Copyright 2014 Square, Inc.\n+package com.squareup.javawriter;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+import static org.fest.assertions.api.Assertions.assertThat;\n+\n+@RunWith(JUnit4.class)\n+public final class StringLiteralTest {\n+  @Test public void stringLiteral() {\n+    assertThat(StringLiteral.forValue(\"\").toString()).isEqualTo(\"\\\"\\\"\");\n+    assertThat(StringLiteral.forValue(\"JavaWriter\").toString()).isEqualTo(\"\\\"JavaWriter\\\"\");\n+    assertThat(StringLiteral.forValue(\"\\\\\").toString()).isEqualTo(\"\\\"\\\\\\\\\\\"\");\n+    assertThat(StringLiteral.forValue(\"\\\"\").toString()).isEqualTo(\"\\\"\\\\\\\"\\\"\");\n+    assertThat(StringLiteral.forValue(\"\\b\").toString()).isEqualTo(\"\\\"\\\\b\\\"\");\n+    assertThat(StringLiteral.forValue(\"\\t\").toString()).isEqualTo(\"\\\"\\\\t\\\"\");\n+    assertThat(StringLiteral.forValue(\"\\n\").toString()).isEqualTo(\"\\\"\\\\n\\\"\");\n+    assertThat(StringLiteral.forValue(\"\\f\").toString()).isEqualTo(\"\\\"\\\\f\\\"\");\n+    assertThat(StringLiteral.forValue(\"\\r\").toString()).isEqualTo(\"\\\"\\\\r\\\"\");\n+\n+    // Control characters\n+    for (char i = 0x1; i <= 0x1f; i++) {\n+      checkCharEscape(i);\n+    }\n+    for (char i = 0x7f; i <= 0x9f; i++) {\n+      checkCharEscape(i);\n+    }\n+  }\n+\n+  private void checkCharEscape(char codePoint) {\n+    String test = \"\" + codePoint;\n+    String expected;\n+    switch (codePoint) {\n+      case 8: expected = \"\\\"\\\\b\\\"\"; break;\n+      case 9: expected = \"\\\"\\\\t\\\"\"; break;\n+      case 10: expected = \"\\\"\\\\n\\\"\"; break;\n+      case 12: expected = \"\\\"\\\\f\\\"\"; break;\n+      case 13: expected = \"\\\"\\\\r\\\"\"; break;\n+      default: expected = \"\\\"\\\\u\" + String.format(\"%04x\", (int) codePoint) + \"\\\"\";\n+    }\n+    assertThat(StringLiteral.forValue(test).toString()).isEqualTo(expected);\n+  }\n+\n+}\n"
    },
    {
        "commit_hash": "0043406a2296cddf4afb30dce51e0674dd91475d",
        "previous_commit_hash": "731b6fc063321bb1b5bf9b52ed0b781753b7dcb1",
        "diff_stats": {
            "additions": 10,
            "deletions": 1
        },
        "diff_content": "@@ -40,6 +40,15 @@ public class WildcardName implements TypeName {\n   @Override\n   public Appendable write(Appendable appendable, CompilationUnitContext context)\n       throws IOException {\n-    return null;\n+    appendable.append('?');\n+    if (extendsBound.isPresent()) {\n+      appendable.append(\" extends \");\n+      extendsBound.get().write(appendable, context);\n+    }\n+    if (superBound.isPresent()) {\n+      appendable.append(\" super \");\n+      superBound.get().write(appendable, context);\n+    }\n+    return appendable;\n   }\n }\n"
    },
    {
        "commit_hash": "7cde26246a26db78fc62034daa2964284cfda268",
        "previous_commit_hash": "0043406a2296cddf4afb30dce51e0674dd91475d",
        "diff_stats": {
            "additions": 1,
            "deletions": 3
        },
        "diff_content": "@@ -3,7 +3,6 @@ package dagger.internal.codegen.writer;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Maps;\n-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;\n import java.io.IOException;\n import java.util.Map.Entry;\n import java.util.Set;\n@@ -32,8 +31,7 @@ public class AnnotationWriter implements Writable, HasClassReferences {\n   }\n \n   @Override\n-  public Appendable write(Appendable appendable, CompilationUnitContext context)\n-      throws IOException {\n+  public Appendable write(Appendable appendable, Context context) throws IOException {\n     appendable.append('@');\n     annotationName.write(appendable, context);\n     if (!memberMap.isEmpty()) {\n"
    },
    {
        "commit_hash": "7cde26246a26db78fc62034daa2964284cfda268",
        "previous_commit_hash": "0043406a2296cddf4afb30dce51e0674dd91475d",
        "diff_stats": {
            "additions": 38,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,38 @@\n+package dagger.internal.codegen.writer;\n+\n+import java.io.IOException;\n+import java.util.Set;\n+\n+final class ArrayTypeName implements TypeName {\n+  private final TypeName componentType;\n+\n+  ArrayTypeName(TypeName componentType) {\n+    this.componentType = componentType;\n+  }\n+\n+  @Override\n+  public Set<ClassName> referencedClasses() {\n+    return componentType.referencedClasses();\n+  }\n+\n+  @Override\n+  public Appendable write(Appendable appendable, Context context) throws IOException {\n+    return componentType.write(appendable, context).append(\"[]\");\n+  }\n+\n+  @Override\n+  public boolean equals(Object obj) {\n+    return (obj instanceof ArrayTypeName)\n+        & this.componentType.equals(((ArrayTypeName) obj).componentType);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return componentType.hashCode();\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return Writables.writeToString(this);\n+  }\n+}\n"
    },
    {
        "commit_hash": "7cde26246a26db78fc62034daa2964284cfda268",
        "previous_commit_hash": "0043406a2296cddf4afb30dce51e0674dd91475d",
        "diff_stats": {
            "additions": 1,
            "deletions": 3
        },
        "diff_content": "@@ -3,7 +3,6 @@ package dagger.internal.codegen.writer;\n import com.google.common.base.Function;\n import com.google.common.collect.FluentIterable;\n import com.google.common.collect.Lists;\n-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;\n import java.io.IOException;\n import java.util.List;\n import java.util.Set;\n@@ -30,8 +29,7 @@ public final class BlockWriter implements Writable, HasClassReferences {\n   }\n \n   @Override\n-  public Appendable write(Appendable appendable, CompilationUnitContext context)\n-      throws IOException {\n+  public Appendable write(Appendable appendable, Context context) throws IOException {\n     for (Snippet snippet : snippets) {\n       appendable.append('\\n');\n       snippet.write(appendable, context);\n"
    },
    {
        "commit_hash": "7cde26246a26db78fc62034daa2964284cfda268",
        "previous_commit_hash": "0043406a2296cddf4afb30dce51e0674dd91475d",
        "diff_stats": {
            "additions": 2,
            "deletions": 4
        },
        "diff_content": "@@ -23,7 +23,6 @@ import com.google.common.base.Splitter;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Sets;\n-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;\n import java.io.IOException;\n import java.util.ArrayList;\n import java.util.Collections;\n@@ -48,7 +47,7 @@ import static javax.lang.model.element.NestingKind.TOP_LEVEL;\n  *\n  * @since 2.0\n  */\n-public final class ClassName implements Comparable<ClassName>, TypeName {\n+public final class ClassName implements TypeName, Comparable<ClassName> {\n   private String fullyQualifiedName = null;\n   private final String packageName;\n   /* From top to bottom.  E.g.: this field will contian [\"A\", \"B\"] for pgk.A.B.C */\n@@ -226,8 +225,7 @@ public final class ClassName implements Comparable<ClassName>, TypeName {\n   }\n \n   @Override\n-  public Appendable write(Appendable appendable, CompilationUnitContext context)\n-      throws IOException {\n+  public Appendable write(Appendable appendable, Context context) throws IOException {\n     appendable.append(context.sourceReferenceForClassName(this));\n     return appendable;\n   }\n"
    },
    {
        "commit_hash": "7cde26246a26db78fc62034daa2964284cfda268",
        "previous_commit_hash": "0043406a2296cddf4afb30dce51e0674dd91475d",
        "diff_stats": {
            "additions": 2,
            "deletions": 4
        },
        "diff_content": "@@ -6,7 +6,6 @@ import com.google.common.collect.FluentIterable;\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;\n import java.io.IOException;\n import java.util.Iterator;\n import java.util.List;\n@@ -81,7 +80,7 @@ public final class ClassWriter extends TypeWriter {\n \n   public MethodWriter addMethod(TypeMirror returnType, String name) {\n     MethodWriter methodWriter =\n-        new MethodWriter(TypeReferences.forTypeMirror(returnType), name);\n+        new MethodWriter(TypeNames.forTypeMirror(returnType), name);\n     methodWriters.add(methodWriter);\n     return methodWriter;\n   }\n@@ -100,8 +99,7 @@ public final class ClassWriter extends TypeWriter {\n   }\n \n   @Override\n-  public Appendable write(Appendable appendable, CompilationUnitContext context)\n-      throws IOException {\n+  public Appendable write(Appendable appendable, Context context) throws IOException {\n     writeAnnotations(appendable, context);\n     writeModifiers(appendable).append(\"class \").append(name.simpleName());\n     if (!typeVariables.isEmpty()) {\n"
    },
    {
        "commit_hash": "7cde26246a26db78fc62034daa2964284cfda268",
        "previous_commit_hash": "0043406a2296cddf4afb30dce51e0674dd91475d",
        "diff_stats": {
            "additions": 1,
            "deletions": 3
        },
        "diff_content": "@@ -5,7 +5,6 @@ import com.google.common.collect.FluentIterable;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Maps;\n-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;\n import java.io.IOException;\n import java.util.Iterator;\n import java.util.Map;\n@@ -68,8 +67,7 @@ public class ConstructorWriter extends Modifiable implements Writable, HasClassR\n   }\n \n   @Override\n-  public Appendable write(Appendable appendable, CompilationUnitContext context)\n-      throws IOException {\n+  public Appendable write(Appendable appendable, Context context) throws IOException {\n     writeModifiers(appendable).append(name).append('(');\n     Iterator<VariableWriter> parameterWritersIterator = parameterWriters.values().iterator();\n     if (parameterWritersIterator.hasNext()) {\n"
    },
    {
        "commit_hash": "7cde26246a26db78fc62034daa2964284cfda268",
        "previous_commit_hash": "0043406a2296cddf4afb30dce51e0674dd91475d",
        "diff_stats": {
            "additions": 1,
            "deletions": 3
        },
        "diff_content": "@@ -5,7 +5,6 @@ import com.google.common.base.Optional;\n import com.google.common.collect.FluentIterable;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Iterables;\n-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;\n import java.io.IOException;\n import java.util.Set;\n \n@@ -22,8 +21,7 @@ public class FieldWriter extends VariableWriter {\n   }\n \n   @Override\n-  public Appendable write(Appendable appendable, CompilationUnitContext context)\n-      throws IOException {\n+  public Appendable write(Appendable appendable, Context context) throws IOException {\n     super.write(appendable, context);\n     if (initializer.isPresent()) {\n       appendable.append(\" = \");\n"
    },
    {
        "commit_hash": "7cde26246a26db78fc62034daa2964284cfda268",
        "previous_commit_hash": "0043406a2296cddf4afb30dce51e0674dd91475d",
        "diff_stats": {
            "additions": 1,
            "deletions": 2
        },
        "diff_content": "@@ -4,7 +4,6 @@ import com.google.common.base.Function;\n import com.google.common.base.Joiner;\n import com.google.common.collect.FluentIterable;\n import com.google.common.collect.Lists;\n-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;\n import java.io.IOException;\n import java.util.List;\n import java.util.Set;\n@@ -26,7 +25,7 @@ public class InterfaceWriter extends TypeWriter {\n   }\n \n   @Override\n-  public Appendable write(Appendable appendable, CompilationUnitContext context) throws IOException {\n+  public Appendable write(Appendable appendable, Context context) throws IOException {\n     writeModifiers(appendable).append(\"class \").append(name.simpleName());\n     if (!typeVariables.isEmpty()) {\n       appendable.append('<');\n"
    },
    {
        "commit_hash": "7cde26246a26db78fc62034daa2964284cfda268",
        "previous_commit_hash": "0043406a2296cddf4afb30dce51e0674dd91475d",
        "diff_stats": {
            "additions": 7,
            "deletions": 3
        },
        "diff_content": "@@ -168,7 +168,9 @@ public final class JavaWriter {\n     }\n   }\n \n-  final class CompilationUnitContext {\n+\n+\n+  final class CompilationUnitContext implements Writable.Context {\n     private final ImmutableSortedSet<ClassName> importedClasses;\n \n     CompilationUnitContext(ImmutableSet<ClassName> importedClasses) {\n@@ -176,7 +178,8 @@ public final class JavaWriter {\n           ImmutableSortedSet.copyOf(Ordering.natural().reverse(), importedClasses);\n     }\n \n-    String sourceReferenceForClassName(ClassName className) {\n+    @Override\n+    public String sourceReferenceForClassName(ClassName className) {\n       if (isImported(className)) {\n         return className.simpleName();\n       }\n@@ -202,7 +205,8 @@ public final class JavaWriter {\n     private static final String JAVA_IDENTIFIER_REGEX =\n         \"\\\\p{javaJavaIdentifierStart}\\\\p{javaJavaIdentifierPart}*\";\n \n-    String compressTypesWithin(String snippet) {\n+    @Override\n+    public String compressTypesWithin(String snippet) {\n \n       // TODO(gak): deal with string literals\n       for (ClassName importedClass : importedClasses) {\n"
    },
    {
        "commit_hash": "7cde26246a26db78fc62034daa2964284cfda268",
        "previous_commit_hash": "0043406a2296cddf4afb30dce51e0674dd91475d",
        "diff_stats": {
            "additions": 1,
            "deletions": 3
        },
        "diff_content": "@@ -6,7 +6,6 @@ import com.google.common.collect.FluentIterable;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Maps;\n-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;\n import java.io.IOException;\n import java.util.Iterator;\n import java.util.Map;\n@@ -54,8 +53,7 @@ public class MethodWriter extends Modifiable implements HasClassReferences, Writ\n   }\n \n   @Override\n-  public Appendable write(Appendable appendable, CompilationUnitContext context)\n-      throws IOException {\n+  public Appendable write(Appendable appendable, Context context) throws IOException {\n     writeAnnotations(appendable, context);\n     writeModifiers(appendable);\n     returnType.write(appendable, context);\n"
    },
    {
        "commit_hash": "7cde26246a26db78fc62034daa2964284cfda268",
        "previous_commit_hash": "0043406a2296cddf4afb30dce51e0674dd91475d",
        "diff_stats": {
            "additions": 2,
            "deletions": 3
        },
        "diff_content": "@@ -1,7 +1,7 @@\n package dagger.internal.codegen.writer;\n \n import com.google.common.collect.Lists;\n-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;\n+import dagger.internal.codegen.writer.Writable.Context;\n import java.io.IOException;\n import java.lang.annotation.Annotation;\n import java.util.EnumSet;\n@@ -36,8 +36,7 @@ public abstract class Modifiable {\n     return appendable;\n   }\n \n-  Appendable writeAnnotations(Appendable appendable, CompilationUnitContext context)\n-      throws IOException {\n+  Appendable writeAnnotations(Appendable appendable, Context context) throws IOException {\n     for (AnnotationWriter annotationWriter : annotations) {\n       annotationWriter.write(appendable, context).append('\\n');\n     }\n"
    },
    {
        "commit_hash": "7cde26246a26db78fc62034daa2964284cfda268",
        "previous_commit_hash": "0043406a2296cddf4afb30dce51e0674dd91475d",
        "diff_stats": {
            "additions": 24,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,24 @@\n+package dagger.internal.codegen.writer;\n+\n+import com.google.common.collect.ImmutableSet;\n+import java.io.IOException;\n+import java.util.Set;\n+\n+enum NullName implements TypeName {\n+  NULL;\n+\n+  @Override\n+  public Set<ClassName> referencedClasses() {\n+    return ImmutableSet.of();\n+  }\n+\n+  @Override\n+  public Appendable write(Appendable appendable, Context context) throws IOException {\n+    return appendable.append(\"null\");\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return \"null\";\n+  }\n+}\n"
    },
    {
        "commit_hash": "7cde26246a26db78fc62034daa2964284cfda268",
        "previous_commit_hash": "0043406a2296cddf4afb30dce51e0674dd91475d",
        "diff_stats": {
            "additions": 19,
            "deletions": 7
        },
        "diff_content": "@@ -1,9 +1,8 @@\n package dagger.internal.codegen.writer;\n \n-import com.google.common.base.Joiner;\n+import com.google.common.base.Objects;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;\n import java.io.IOException;\n import java.util.Iterator;\n import java.util.Set;\n@@ -31,8 +30,7 @@ public class ParameterizedTypeName implements TypeName {\n   }\n \n   @Override\n-  public Appendable write(Appendable appendable, CompilationUnitContext context)\n-      throws IOException {\n+  public Appendable write(Appendable appendable, Context context) throws IOException {\n     appendable.append(context.sourceReferenceForClassName(type));\n     Iterator<? extends TypeName> parameterIterator = parameters.iterator();\n     verify(parameterIterator.hasNext(), type.toString());\n@@ -46,11 +44,25 @@ public class ParameterizedTypeName implements TypeName {\n     return appendable;\n   }\n \n+  @Override\n+  public boolean equals(Object obj) {\n+    if (obj instanceof ParameterizedTypeName) {\n+      ParameterizedTypeName that = (ParameterizedTypeName) obj;\n+      return this.type.equals(that.type)\n+          && this.parameters.equals(that.parameters);\n+    } else {\n+      return false;\n+    }\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return Objects.hashCode(type, parameters);\n+  }\n+\n   @Override\n   public String toString() {\n-    StringBuilder builder = new StringBuilder(type.toString()).append('<');\n-    Joiner.on(\", \").appendTo(builder, parameters);\n-    return builder.append('>').toString();\n+    return Writables.writeToString(this);\n   }\n \n   public static ParameterizedTypeName create(ClassName className,\n"
    },
    {
        "commit_hash": "7cde26246a26db78fc62034daa2964284cfda268",
        "previous_commit_hash": "0043406a2296cddf4afb30dce51e0674dd91475d",
        "diff_stats": {
            "additions": 29,
            "deletions": 3
        },
        "diff_content": "@@ -2,7 +2,6 @@ package dagger.internal.codegen.writer;\n \n import com.google.common.base.Ascii;\n import com.google.common.collect.ImmutableSet;\n-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;\n import java.io.IOException;\n import java.util.Set;\n import javax.lang.model.type.PrimitiveType;\n@@ -21,8 +20,7 @@ public enum PrimitiveName implements TypeName {\n   }\n \n   @Override\n-  public Appendable write(Appendable appendable, CompilationUnitContext context)\n-      throws IOException {\n+  public Appendable write(Appendable appendable, Context context) throws IOException {\n     return appendable.append(toString());\n   }\n \n@@ -48,4 +46,32 @@ public enum PrimitiveName implements TypeName {\n         throw new AssertionError();\n     }\n   }\n+\n+  static PrimitiveName forClass(Class<?> primitiveClass) {\n+    if (boolean.class.equals(primitiveClass)) {\n+      return BOOLEAN;\n+    }\n+    if (byte.class.equals(primitiveClass)) {\n+      return BYTE;\n+    }\n+    if (short.class.equals(primitiveClass)) {\n+      return SHORT;\n+    }\n+    if (int.class.equals(primitiveClass)) {\n+      return INT;\n+    }\n+    if (long.class.equals(primitiveClass)) {\n+      return LONG;\n+    }\n+    if (char.class.equals(primitiveClass)) {\n+      return CHAR;\n+    }\n+    if (float.class.equals(primitiveClass)) {\n+      return FLOAT;\n+    }\n+    if (double.class.equals(primitiveClass)) {\n+      return DOUBLE;\n+    }\n+    throw new IllegalArgumentException(primitiveClass + \" is not a primitive type\");\n+  }\n }\n"
    },
    {
        "commit_hash": "7cde26246a26db78fc62034daa2964284cfda268",
        "previous_commit_hash": "0043406a2296cddf4afb30dce51e0674dd91475d",
        "diff_stats": {
            "additions": 1,
            "deletions": 3
        },
        "diff_content": "@@ -3,7 +3,6 @@ package dagger.internal.codegen.writer;\n import com.google.common.base.Function;\n import com.google.common.collect.FluentIterable;\n import com.google.common.collect.ImmutableSet;\n-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;\n import java.io.IOException;\n import java.util.Iterator;\n import java.util.List;\n@@ -44,8 +43,7 @@ public final class Snippet implements HasClassReferences, Writable {\n   }\n \n   @Override\n-  public Appendable write(Appendable appendable, CompilationUnitContext context)\n-      throws IOException {\n+  public Appendable write(Appendable appendable, Context context) throws IOException {\n     return appendable.append(context.compressTypesWithin(value));\n   }\n \n"
    },
    {
        "commit_hash": "7cde26246a26db78fc62034daa2964284cfda268",
        "previous_commit_hash": "0043406a2296cddf4afb30dce51e0674dd91475d",
        "diff_stats": {
            "additions": 36,
            "deletions": 5
        },
        "diff_content": "@@ -5,12 +5,14 @@ import com.google.common.collect.FluentIterable;\n import javax.lang.model.element.TypeElement;\n import javax.lang.model.type.ArrayType;\n import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.NoType;\n+import javax.lang.model.type.NullType;\n import javax.lang.model.type.PrimitiveType;\n import javax.lang.model.type.TypeMirror;\n import javax.lang.model.type.WildcardType;\n import javax.lang.model.util.SimpleTypeVisitor6;\n \n-public class TypeReferences {\n+public class TypeNames {\n   static Function<TypeMirror, TypeName> FOR_TYPE_MIRROR =\n       new Function<TypeMirror, TypeName>() {\n         @Override public TypeName apply(TypeMirror input) {\n@@ -18,6 +20,18 @@ public class TypeReferences {\n         }\n       };\n \n+  public static TypeName forClass(Class<?> clazz) {\n+    if (clazz.isPrimitive()) {\n+      return PrimitiveName.forClass(clazz);\n+    } else if (void.class.equals(clazz)) {\n+      return VoidName.VOID;\n+    } else if (clazz.isArray()) {\n+      return new ArrayTypeName(forClass(clazz.getComponentType()));\n+    } else {\n+      return ClassName.fromClass(clazz);\n+    }\n+  }\n+\n   public static TypeName forTypeMirror(TypeMirror mirror) {\n     return mirror.accept(new SimpleTypeVisitor6<TypeName, Void>() {\n       @Override\n@@ -26,8 +40,8 @@ public class TypeReferences {\n       }\n \n       @Override\n-      public TypeName visitArray(ArrayType t, Void p) {\n-        return super.visitArray(t, p);\n+      public ArrayTypeName visitArray(ArrayType t, Void p) {\n+        return new ArrayTypeName(t.getComponentType().accept(this, null));\n       }\n \n       @Override\n@@ -40,14 +54,31 @@ public class TypeReferences {\n       }\n \n       @Override\n-      public TypeName visitPrimitive(PrimitiveType t, Void p) {\n+      public PrimitiveName visitPrimitive(PrimitiveType t, Void p) {\n         return PrimitiveName.forTypeMirror(t);\n       }\n \n       @Override\n-      public TypeName visitWildcard(WildcardType t, Void p) {\n+      public WildcardName visitWildcard(WildcardType t, Void p) {\n         return WildcardName.forTypeMirror(t);\n       }\n+\n+      @Override\n+      public NullName visitNull(NullType t, Void p) {\n+        return NullName.NULL;\n+      }\n+\n+      @Override\n+      public TypeName visitNoType(NoType t, Void p) {\n+        switch (t.getKind()) {\n+          case VOID:\n+            return VoidName.VOID;\n+          case PACKAGE:\n+            throw new IllegalArgumentException();\n+          default:\n+            throw new IllegalStateException();\n+        }\n+      }\n     }, null);\n   }\n }\n"
    },
    {
        "commit_hash": "7cde26246a26db78fc62034daa2964284cfda268",
        "previous_commit_hash": "0043406a2296cddf4afb30dce51e0674dd91475d",
        "diff_stats": {
            "additions": 2,
            "deletions": 11
        },
        "diff_content": "@@ -2,7 +2,6 @@ package dagger.internal.codegen.writer;\n \n import com.google.common.base.Optional;\n import com.google.common.collect.ImmutableSet;\n-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;\n import java.io.IOException;\n import java.util.Set;\n \n@@ -34,8 +33,7 @@ public class TypeVariableName implements TypeName {\n   }\n \n   @Override\n-  public Appendable write(Appendable appendable, CompilationUnitContext context)\n-      throws IOException {\n+  public Appendable write(Appendable appendable, Context context) throws IOException {\n     appendable.append(name);\n     if (extendsBound.isPresent()) {\n       appendable.append(' ');\n@@ -50,14 +48,7 @@ public class TypeVariableName implements TypeName {\n \n   @Override\n   public String toString() {\n-    StringBuilder builder = new StringBuilder(name);\n-    if (extendsBound.isPresent()) {\n-      builder.append(' ').append(extendsBound.get());\n-    }\n-    if (superBound.isPresent()) {\n-      builder.append(' ').append(superBound.get());\n-    }\n-    return builder.toString();\n+    return Writables.writeToString(this);\n   }\n \n   static TypeVariableName named(String name) {\n"
    },
    {
        "commit_hash": "7cde26246a26db78fc62034daa2964284cfda268",
        "previous_commit_hash": "0043406a2296cddf4afb30dce51e0674dd91475d",
        "diff_stats": {
            "additions": 1,
            "deletions": 3
        },
        "diff_content": "@@ -1,6 +1,5 @@\n package dagger.internal.codegen.writer;\n \n-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;\n import java.io.IOException;\n import java.util.Set;\n \n@@ -23,8 +22,7 @@ public class VariableWriter extends Modifiable implements Writable, HasClassRefe\n   }\n \n   @Override\n-  public Appendable write(Appendable appendable, CompilationUnitContext context)\n-      throws IOException {\n+  public Appendable write(Appendable appendable, Context context) throws IOException {\n     writeModifiers(appendable);\n     type.write(appendable, context);\n     return appendable.append(' ').append(name);\n"
    },
    {
        "commit_hash": "7cde26246a26db78fc62034daa2964284cfda268",
        "previous_commit_hash": "0043406a2296cddf4afb30dce51e0674dd91475d",
        "diff_stats": {
            "additions": 1,
            "deletions": 3
        },
        "diff_content": "@@ -1,7 +1,6 @@\n package dagger.internal.codegen.writer;\n \n import com.google.common.collect.ImmutableSet;\n-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;\n import java.io.IOException;\n import java.util.Set;\n \n@@ -19,8 +18,7 @@ public enum VoidName implements TypeName {\n   }\n \n   @Override\n-  public Appendable write(Appendable appendable, CompilationUnitContext context)\n-      throws IOException {\n+  public Appendable write(Appendable appendable, Context context) throws IOException {\n     return appendable.append(\"void\");\n   }\n }\n"
    },
    {
        "commit_hash": "7cde26246a26db78fc62034daa2964284cfda268",
        "previous_commit_hash": "0043406a2296cddf4afb30dce51e0674dd91475d",
        "diff_stats": {
            "additions": 2,
            "deletions": 4
        },
        "diff_content": "@@ -2,12 +2,11 @@ package dagger.internal.codegen.writer;\n \n import com.google.common.base.Optional;\n import com.google.common.collect.ImmutableSet;\n-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;\n import java.io.IOException;\n import java.util.Set;\n import javax.lang.model.type.WildcardType;\n \n-import static dagger.internal.codegen.writer.TypeReferences.FOR_TYPE_MIRROR;\n+import static dagger.internal.codegen.writer.TypeNames.FOR_TYPE_MIRROR;\n \n public class WildcardName implements TypeName {\n   private final Optional<TypeName> extendsBound;\n@@ -38,8 +37,7 @@ public class WildcardName implements TypeName {\n   }\n \n   @Override\n-  public Appendable write(Appendable appendable, CompilationUnitContext context)\n-      throws IOException {\n+  public Appendable write(Appendable appendable, Context context) throws IOException {\n     appendable.append('?');\n     if (extendsBound.isPresent()) {\n       appendable.append(\" extends \");\n"
    },
    {
        "commit_hash": "7cde26246a26db78fc62034daa2964284cfda268",
        "previous_commit_hash": "0043406a2296cddf4afb30dce51e0674dd91475d",
        "diff_stats": {
            "additions": 6,
            "deletions": 2
        },
        "diff_content": "@@ -1,8 +1,12 @@\n package dagger.internal.codegen.writer;\n \n-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;\n import java.io.IOException;\n \n interface Writable {\n-  Appendable write(Appendable appendable, CompilationUnitContext context) throws IOException;\n+  interface Context {\n+    String sourceReferenceForClassName(ClassName className);\n+    String compressTypesWithin(String snippet);\n+  }\n+\n+  Appendable write(Appendable appendable, Context context) throws IOException;\n }\n"
    },
    {
        "commit_hash": "7cde26246a26db78fc62034daa2964284cfda268",
        "previous_commit_hash": "0043406a2296cddf4afb30dce51e0674dd91475d",
        "diff_stats": {
            "additions": 24,
            "deletions": 3
        },
        "diff_content": "@@ -1,18 +1,39 @@\n package dagger.internal.codegen.writer;\n \n-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;\n+import dagger.internal.codegen.writer.Writable.Context;\n import java.io.IOException;\n \n final class Writables {\n   static Writable toStringWritable(final Object object) {\n     return new Writable() {\n       @Override\n-      public Appendable write(Appendable appendable, CompilationUnitContext ignored)\n-          throws IOException {\n+      public Appendable write(Appendable appendable, Context context) throws IOException {\n         return appendable.append(object.toString());\n       }\n     };\n   }\n \n+  private static Context DEFAULT_CONTEXT = new Context() {\n+    @Override\n+    public String sourceReferenceForClassName(ClassName className) {\n+      return className.canonicalName();\n+    }\n+\n+    @Override\n+    public String compressTypesWithin(String snippet) {\n+      return snippet;\n+    }\n+  };\n+\n+  static String writeToString(Writable writable) {\n+    StringBuilder builder = new StringBuilder();\n+    try {\n+      writable.write(builder, DEFAULT_CONTEXT);\n+    } catch (IOException e) {\n+      throw new AssertionError(\"StringBuilder doesn't throw IOException\", e);\n+    }\n+    return builder.toString();\n+  }\n+\n   private Writables() {}\n }\n"
    },
    {
        "commit_hash": "7cde26246a26db78fc62034daa2964284cfda268",
        "previous_commit_hash": "0043406a2296cddf4afb30dce51e0674dd91475d",
        "diff_stats": {
            "additions": 84,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,84 @@\n+package dagger.internal.codegen.writer;\n+\n+import com.google.testing.compile.CompilationRule;\n+import java.nio.charset.Charset;\n+import java.util.Set;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+import static org.truth0.Truth.ASSERT;\n+\n+@RunWith(JUnit4.class)\n+public class TypeNamesTest {\n+  @Rule public final CompilationRule compilation = new CompilationRule();\n+\n+  private TypeElement getElement(Class<?> clazz) {\n+    return compilation.getElements().getTypeElement(clazz.getCanonicalName());\n+  }\n+\n+  private TypeMirror getType(Class<?> clazz) {\n+    return getElement(clazz).asType();\n+  }\n+\n+  @Test\n+  public void forTypeMirror_basicTypes() {\n+    ASSERT.that(TypeNames.forTypeMirror(getType(Object.class)))\n+        .isEqualTo(ClassName.fromClass(Object.class));\n+    ASSERT.that(TypeNames.forTypeMirror(getType(Charset.class)))\n+        .isEqualTo(ClassName.fromClass(Charset.class));\n+    ASSERT.that(TypeNames.forTypeMirror(getType(TypeNamesTest.class)))\n+        .isEqualTo(ClassName.fromClass(TypeNamesTest.class));\n+  }\n+\n+  @Test\n+  public void forTypeMirror_parameterizedType() {\n+    DeclaredType setType =\n+        compilation.getTypes().getDeclaredType(getElement(Set.class), getType(Object.class));\n+    ASSERT.that(TypeNames.forTypeMirror(setType))\n+        .isEqualTo(ParameterizedTypeName.create(Set.class, ClassName.fromClass(Object.class)));\n+  }\n+\n+  @Test\n+  public void forTypeMirror_primitive() {\n+    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.BOOLEAN)))\n+        .isEqualTo(PrimitiveName.BOOLEAN);\n+    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.BYTE)))\n+        .isEqualTo(PrimitiveName.BYTE);\n+    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.SHORT)))\n+        .isEqualTo(PrimitiveName.SHORT);\n+    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.INT)))\n+        .isEqualTo(PrimitiveName.INT);\n+    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.LONG)))\n+        .isEqualTo(PrimitiveName.LONG);\n+    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.CHAR)))\n+        .isEqualTo(PrimitiveName.CHAR);\n+    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.FLOAT)))\n+        .isEqualTo(PrimitiveName.FLOAT);\n+    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.DOUBLE)))\n+        .isEqualTo(PrimitiveName.DOUBLE);\n+  }\n+\n+  @Test\n+  public void forTypeMirror_arrays() {\n+    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getArrayType(getType(Object.class))))\n+        .isEqualTo(new ArrayTypeName(ClassName.fromClass(Object.class)));\n+  }\n+\n+  @Test\n+  public void forTypeMirror_void() {\n+    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getNoType(TypeKind.VOID)))\n+        .isEqualTo(VoidName.VOID);\n+  }\n+\n+  @Test\n+  public void forTypeMirror_null() {\n+    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getNullType()))\n+        .isEqualTo(NullName.NULL);\n+  }\n+}\n"
    },
    {
        "commit_hash": "aedf7cb9a6c56293d5c000bc2f2c1a134425b41d",
        "previous_commit_hash": "7cde26246a26db78fc62034daa2964284cfda268",
        "diff_stats": {
            "additions": 14,
            "deletions": 4
        },
        "diff_content": "@@ -100,6 +100,13 @@ public final class ClassWriter extends TypeWriter {\n \n   @Override\n   public Appendable write(Appendable appendable, Context context) throws IOException {\n+    context = context.createSubcontext(FluentIterable.from(nestedTypeWriters)\n+        .transform(new Function<TypeWriter, ClassName>() {\n+          @Override public ClassName apply(TypeWriter input) {\n+            return input.name;\n+          }\n+        })\n+        .toSet());\n     writeAnnotations(appendable, context);\n     writeModifiers(appendable).append(\"class \").append(name.simpleName());\n     if (!typeVariables.isEmpty()) {\n@@ -120,22 +127,25 @@ public final class ClassWriter extends TypeWriter {\n         implementedTypesIterator.next().write(appendable, context);\n       }\n     }\n-    appendable.append(\" {\\n\");\n+    appendable.append(\" {\");\n+    if (!fieldWriters.isEmpty()) {\n+      appendable.append('\\n');\n+    }\n     for (VariableWriter fieldWriter : fieldWriters) {\n       fieldWriter.write(new IndentingAppendable(appendable), context).append(\"\\n\");\n     }\n-    appendable.append('\\n');\n     for (ConstructorWriter constructorWriter : constructorWriters) {\n+      appendable.append('\\n');\n       if (!isDefaultConstructor(constructorWriter)) {\n         constructorWriter.write(new IndentingAppendable(appendable), context);\n       }\n     }\n-    appendable.append('\\n');\n     for (MethodWriter methodWriter : methodWriters) {\n+      appendable.append('\\n');\n       methodWriter.write(new IndentingAppendable(appendable), context);\n     }\n-    appendable.append('\\n');\n     for (TypeWriter nestedTypeWriter : nestedTypeWriters) {\n+      appendable.append('\\n');\n       nestedTypeWriter.write(new IndentingAppendable(appendable), context);\n     }\n     appendable.append(\"}\\n\");\n"
    },
    {
        "commit_hash": "aedf7cb9a6c56293d5c000bc2f2c1a134425b41d",
        "previous_commit_hash": "7cde26246a26db78fc62034daa2964284cfda268",
        "diff_stats": {
            "additions": 4,
            "deletions": 0
        },
        "diff_content": "@@ -20,6 +20,10 @@ public class FieldWriter extends VariableWriter {\n     this.initializer = Optional.of(initializer);\n   }\n \n+  public void setInitializer(String initializer, Object... args) {\n+    this.initializer = Optional.of(Snippet.format(initializer, args));\n+  }\n+\n   @Override\n   public Appendable write(Appendable appendable, Context context) throws IOException {\n     super.write(appendable, context);\n"
    },
    {
        "commit_hash": "aedf7cb9a6c56293d5c000bc2f2c1a134425b41d",
        "previous_commit_hash": "7cde26246a26db78fc62034daa2964284cfda268",
        "diff_stats": {
            "additions": 5,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,5 @@\n+package dagger.internal.codegen.writer;\n+\n+interface HasTypeName {\n+  TypeName name();\n+}\n"
    },
    {
        "commit_hash": "aedf7cb9a6c56293d5c000bc2f2c1a134425b41d",
        "previous_commit_hash": "7cde26246a26db78fc62034daa2964284cfda268",
        "diff_stats": {
            "additions": 26,
            "deletions": 11
        },
        "diff_content": "@@ -10,7 +10,9 @@ import com.google.common.collect.ImmutableSortedSet;\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Ordering;\n+import com.google.common.collect.Sets;\n import com.google.common.io.Closer;\n+import dagger.internal.codegen.writer.Writable.Context;\n import java.io.IOException;\n import java.util.List;\n import java.util.Set;\n@@ -110,11 +112,19 @@ public final class JavaWriter {\n         .addAll(explicitImports)\n         .addAll(classNames)\n         .build();\n+    ImmutableSet<ClassName> typeNames = FluentIterable.from(typeWriters)\n+        .transform(new Function<TypeWriter, ClassName>() {\n+          @Override public ClassName apply(TypeWriter input) {\n+            return input.name;\n+          }\n+        })\n+        .toSet();\n     for (ClassName className : importCandidates) {\n       if (!(className.packageName().equals(packageName)\n               && !className.enclosingClassName().isPresent())\n           && !(className.packageName().equals(\"java.lang\")\n-              && className.enclosingSimpleNames().isEmpty())) {\n+              && className.enclosingSimpleNames().isEmpty())\n+          && !typeNames.contains(className.topLevelClassName())) {\n         Optional<ClassName> importCandidate = Optional.of(className);\n         while (importCandidate.isPresent()\n             && importedClassIndex.containsKey(importCandidate.get().simpleName())) {\n@@ -130,11 +140,11 @@ public final class JavaWriter {\n     appendable.append('\\n');\n \n     CompilationUnitContext context =\n-        new CompilationUnitContext(ImmutableSet.copyOf(importedClassIndex.values()));\n+        new CompilationUnitContext(packageName, ImmutableSet.copyOf(importedClassIndex.values()));\n \n     // write types\n     for (TypeWriter typeWriter : typeWriters) {\n-      typeWriter.write(appendable, context).append('\\n');\n+      typeWriter.write(appendable, context.createSubcontext(typeNames)).append('\\n');\n     }\n     return appendable;\n   }\n@@ -169,13 +179,19 @@ public final class JavaWriter {\n   }\n \n \n+  static final class CompilationUnitContext implements Writable.Context {\n+    private final String packageName;\n+    private final ImmutableSortedSet<ClassName> visibleClasses;\n \n-  final class CompilationUnitContext implements Writable.Context {\n-    private final ImmutableSortedSet<ClassName> importedClasses;\n+    CompilationUnitContext(String packageName, Set<ClassName> visibleClasses) {\n+      this.packageName = packageName;\n+      this.visibleClasses =\n+          ImmutableSortedSet.copyOf(Ordering.natural().reverse(), visibleClasses);\n+    }\n \n-    CompilationUnitContext(ImmutableSet<ClassName> importedClasses) {\n-      this.importedClasses =\n-          ImmutableSortedSet.copyOf(Ordering.natural().reverse(), importedClasses);\n+    @Override\n+    public Context createSubcontext(Set<ClassName> newTypes) {\n+      return new CompilationUnitContext(packageName, Sets.union(visibleClasses, newTypes));\n     }\n \n     @Override\n@@ -197,7 +213,7 @@ public final class JavaWriter {\n     private boolean isImported(ClassName className) {\n       return (packageName.equals(className.packageName())\n               && !className.enclosingClassName().isPresent()) // need to account for scope & hiding\n-          || importedClasses.contains(className)\n+          || visibleClasses.contains(className)\n           || (className.packageName().equals(\"java.lang\")\n               && className.enclosingSimpleNames().isEmpty());\n     }\n@@ -207,9 +223,8 @@ public final class JavaWriter {\n \n     @Override\n     public String compressTypesWithin(String snippet) {\n-\n       // TODO(gak): deal with string literals\n-      for (ClassName importedClass : importedClasses) {\n+      for (ClassName importedClass : visibleClasses) {\n         snippet = snippet.replace(importedClass.canonicalName(), importedClass.simpleName());\n       }\n       Pattern samePackagePattern = Pattern.compile(\n"
    },
    {
        "commit_hash": "aedf7cb9a6c56293d5c000bc2f2c1a134425b41d",
        "previous_commit_hash": "7cde26246a26db78fc62034daa2964284cfda268",
        "diff_stats": {
            "additions": 5,
            "deletions": 0
        },
        "diff_content": "@@ -10,6 +10,7 @@ import java.io.IOException;\n import java.util.Iterator;\n import java.util.Map;\n import java.util.Set;\n+import javax.lang.model.element.TypeElement;\n \n import static com.google.common.base.Preconditions.checkArgument;\n \n@@ -31,6 +32,10 @@ public class MethodWriter extends Modifiable implements HasClassReferences, Writ\n     return addParameter(ClassName.fromClass(type), name);\n   }\n \n+  public VariableWriter addParameter(TypeElement type, String name) {\n+    return addParameter(ClassName.fromTypeElement(type), name);\n+  }\n+\n   public VariableWriter addParameter(TypeWriter type, String name) {\n     return addParameter(type.name, name);\n   }\n"
    },
    {
        "commit_hash": "aedf7cb9a6c56293d5c000bc2f2c1a134425b41d",
        "previous_commit_hash": "7cde26246a26db78fc62034daa2964284cfda268",
        "diff_stats": {
            "additions": 3,
            "deletions": 0
        },
        "diff_content": "@@ -57,6 +57,9 @@ public final class Snippet implements HasClassReferences, Writable {\n       if (arg instanceof TypeName) {\n         types.add((TypeName) arg);\n       }\n+      if (arg instanceof HasTypeName) {\n+        types.add(((HasTypeName) arg).name());\n+      }\n     }\n     return new Snippet(value, types.build());\n   }\n"
    },
    {
        "commit_hash": "aedf7cb9a6c56293d5c000bc2f2c1a134425b41d",
        "previous_commit_hash": "7cde26246a26db78fc62034daa2964284cfda268",
        "diff_stats": {
            "additions": 6,
            "deletions": 1
        },
        "diff_content": "@@ -9,7 +9,7 @@ import java.util.List;\n  * Only named types. Doesn't cover anonymous inner classes.\n  */\n public abstract class TypeWriter /* ha ha */ extends Modifiable\n-    implements Writable, TypeName {\n+    implements Writable, HasTypeName, HasClassReferences {\n   final ClassName name;\n   Optional<TypeName> supertype;\n   final List<TypeName> implementedTypes;\n@@ -19,4 +19,9 @@ public abstract class TypeWriter /* ha ha */ extends Modifiable\n     this.supertype = Optional.absent();\n     this.implementedTypes = Lists.newArrayList();\n   }\n+\n+  @Override\n+  public TypeName name() {\n+    return name;\n+  }\n }\n"
    },
    {
        "commit_hash": "aedf7cb9a6c56293d5c000bc2f2c1a134425b41d",
        "previous_commit_hash": "7cde26246a26db78fc62034daa2964284cfda268",
        "diff_stats": {
            "additions": 2,
            "deletions": 0
        },
        "diff_content": "@@ -1,11 +1,13 @@\n package dagger.internal.codegen.writer;\n \n import java.io.IOException;\n+import java.util.Set;\n \n interface Writable {\n   interface Context {\n     String sourceReferenceForClassName(ClassName className);\n     String compressTypesWithin(String snippet);\n+    Context createSubcontext(Set<ClassName> newTypes);\n   }\n \n   Appendable write(Appendable appendable, Context context) throws IOException;\n"
    },
    {
        "commit_hash": "aedf7cb9a6c56293d5c000bc2f2c1a134425b41d",
        "previous_commit_hash": "7cde26246a26db78fc62034daa2964284cfda268",
        "diff_stats": {
            "additions": 6,
            "deletions": 0
        },
        "diff_content": "@@ -2,6 +2,7 @@ package dagger.internal.codegen.writer;\n \n import dagger.internal.codegen.writer.Writable.Context;\n import java.io.IOException;\n+import java.util.Set;\n \n final class Writables {\n   static Writable toStringWritable(final Object object) {\n@@ -23,6 +24,11 @@ final class Writables {\n     public String compressTypesWithin(String snippet) {\n       return snippet;\n     }\n+\n+    @Override\n+    public Context createSubcontext(Set<ClassName> newTypes) {\n+      throw new UnsupportedOperationException();\n+    }\n   };\n \n   static String writeToString(Writable writable) {\n"
    },
    {
        "commit_hash": "e4b6b6cc9919154ade9b148b3d92e25fa97df328",
        "previous_commit_hash": "aedf7cb9a6c56293d5c000bc2f2c1a134425b41d",
        "diff_stats": {
            "additions": 5,
            "deletions": 4
        },
        "diff_content": "@@ -131,8 +131,8 @@ public final class JavaWriter {\n           importCandidate = importCandidate.get().enclosingClassName();\n         }\n         if (importCandidate.isPresent()) {\n-          appendable.append(\"import \").append(className.canonicalName()).append(\";\\n\");\n-          importedClassIndex.put(className.simpleName(), className);\n+          appendable.append(\"import \").append(importCandidate.get().canonicalName()).append(\";\\n\");\n+          importedClassIndex.put(importCandidate.get().simpleName(), importCandidate.get());\n         }\n       }\n     }\n@@ -202,8 +202,9 @@ public final class JavaWriter {\n       Optional<ClassName> enclosingClassName = className.enclosingClassName();\n       while (enclosingClassName.isPresent()) {\n         if (isImported(enclosingClassName.get())) {\n-          return className.canonicalName()\n-              .substring(enclosingClassName.get().canonicalName().length() + 1);\n+          return enclosingClassName.get().simpleName()\n+              + className.canonicalName()\n+                  .substring(enclosingClassName.get().canonicalName().length());\n         }\n         enclosingClassName = enclosingClassName.get().enclosingClassName();\n       }\n"
    },
    {
        "commit_hash": "b1e0d9ecb5203b9dc0fe6ce2499e0e278744d006",
        "previous_commit_hash": "e4b6b6cc9919154ade9b148b3d92e25fa97df328",
        "diff_stats": {
            "additions": 19,
            "deletions": 2
        },
        "diff_content": "@@ -211,9 +211,24 @@ public final class JavaWriter {\n       return className.canonicalName();\n     }\n \n+    private boolean collidesWithVisibleClass(ClassName className) {\n+      return collidesWithVisibleClass(className.simpleName());\n+    }\n+\n+    private boolean collidesWithVisibleClass(String simpleName) {\n+      return FluentIterable.from(visibleClasses)\n+          .transform(new Function<ClassName, String>() {\n+            @Override public String apply(ClassName input) {\n+              return input.simpleName();\n+            }\n+          })\n+          .contains(simpleName);\n+    }\n+\n     private boolean isImported(ClassName className) {\n       return (packageName.equals(className.packageName())\n-              && !className.enclosingClassName().isPresent()) // need to account for scope & hiding\n+              && !className.enclosingClassName().isPresent()\n+              && !collidesWithVisibleClass(className)) // need to account for scope & hiding\n           || visibleClasses.contains(className)\n           || (className.packageName().equals(\"java.lang\")\n               && className.enclosingSimpleNames().isEmpty());\n@@ -233,7 +248,9 @@ public final class JavaWriter {\n       Matcher matcher = samePackagePattern.matcher(snippet);\n       StringBuffer buffer = new StringBuffer();\n       while (matcher.find()) {\n-        matcher.appendReplacement(buffer, \"$1$2\");\n+        matcher.appendReplacement(buffer, collidesWithVisibleClass(matcher.group(1))\n+            ? matcher.group()\n+            : \"$1$2\");\n       }\n       matcher.appendTail(buffer);\n       return buffer.toString();\n"
    },
    {
        "commit_hash": "ad2f5ce47e69a3eafa21a896943445144aa64460",
        "previous_commit_hash": "b1e0d9ecb5203b9dc0fe6ce2499e0e278744d006",
        "diff_stats": {
            "additions": 0,
            "deletions": 29
        },
        "diff_content": "@@ -12,7 +12,6 @@ import java.util.List;\n import java.util.Set;\n import javax.lang.model.element.Modifier;\n import javax.lang.model.element.TypeElement;\n-import javax.lang.model.type.TypeMirror;\n \n import static javax.lang.model.element.Modifier.PRIVATE;\n import static javax.lang.model.element.Modifier.PROTECTED;\n@@ -22,7 +21,6 @@ public final class ClassWriter extends TypeWriter {\n   private final List<TypeWriter> nestedTypeWriters;\n   private final List<FieldWriter> fieldWriters;\n   private final List<ConstructorWriter> constructorWriters;\n-  private final List<MethodWriter> methodWriters;\n   private final List<TypeVariableName> typeVariables;\n \n   ClassWriter(ClassName className) {\n@@ -30,7 +28,6 @@ public final class ClassWriter extends TypeWriter {\n     this.nestedTypeWriters = Lists.newArrayList();\n     this.fieldWriters = Lists.newArrayList();\n     this.constructorWriters = Lists.newArrayList();\n-    this.methodWriters = Lists.newArrayList();\n     this.typeVariables = Lists.newArrayList();\n   }\n \n@@ -72,32 +69,6 @@ public final class ClassWriter extends TypeWriter {\n     return innerClassWriter;\n   }\n \n-  public MethodWriter addMethod(TypeWriter returnType, String name) {\n-    MethodWriter methodWriter = new MethodWriter(returnType.name, name);\n-    methodWriters.add(methodWriter);\n-    return methodWriter;\n-  }\n-\n-  public MethodWriter addMethod(TypeMirror returnType, String name) {\n-    MethodWriter methodWriter =\n-        new MethodWriter(TypeNames.forTypeMirror(returnType), name);\n-    methodWriters.add(methodWriter);\n-    return methodWriter;\n-  }\n-\n-  public MethodWriter addMethod(TypeName returnType, String name) {\n-    MethodWriter methodWriter = new MethodWriter(returnType, name);\n-    methodWriters.add(methodWriter);\n-    return methodWriter;\n-  }\n-\n-  public MethodWriter addMethod(Class<?> returnType, String name) {\n-    MethodWriter methodWriter =\n-        new MethodWriter(ClassName.fromClass(returnType), name);\n-    methodWriters.add(methodWriter);\n-    return methodWriter;\n-  }\n-\n   @Override\n   public Appendable write(Appendable appendable, Context context) throws IOException {\n     context = context.createSubcontext(FluentIterable.from(nestedTypeWriters)\n"
    },
    {
        "commit_hash": "ad2f5ce47e69a3eafa21a896943445144aa64460",
        "previous_commit_hash": "b1e0d9ecb5203b9dc0fe6ce2499e0e278744d006",
        "diff_stats": {
            "additions": 32,
            "deletions": 6
        },
        "diff_content": "@@ -3,20 +3,20 @@ package dagger.internal.codegen.writer;\n import com.google.common.base.Function;\n import com.google.common.base.Joiner;\n import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n import java.io.IOException;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Set;\n \n public class InterfaceWriter extends TypeWriter {\n   private final List<TypeVariableName> typeVariables;\n-  private final List<MethodWriter> methodWriters;\n   private final List<TypeWriter> nestedTypeWriters;\n \n   InterfaceWriter(ClassName name) {\n     super(name);\n     this.typeVariables = Lists.newArrayList();\n-    this.methodWriters = Lists.newArrayList();\n     this.nestedTypeWriters = Lists.newArrayList();\n   }\n \n@@ -26,18 +26,40 @@ public class InterfaceWriter extends TypeWriter {\n \n   @Override\n   public Appendable write(Appendable appendable, Context context) throws IOException {\n-    writeModifiers(appendable).append(\"class \").append(name.simpleName());\n+    context = context.createSubcontext(FluentIterable.from(nestedTypeWriters)\n+        .transform(new Function<TypeWriter, ClassName>() {\n+          @Override public ClassName apply(TypeWriter input) {\n+            return input.name;\n+          }\n+        })\n+        .toSet());\n+    writeAnnotations(appendable, context);\n+    writeModifiers(appendable).append(\"interface \").append(name.simpleName());\n     if (!typeVariables.isEmpty()) {\n       appendable.append('<');\n       Joiner.on(\", \").appendTo(appendable, typeVariables);\n       appendable.append('>');\n     }\n-    appendable.append(\" {\\n\");\n+    if (supertype.isPresent()) {\n+      appendable.append(\" extends \");\n+      supertype.get().write(appendable, context);\n+    }\n+    Iterator<TypeName> implementedTypesIterator = implementedTypes.iterator();\n+    if (implementedTypesIterator.hasNext()) {\n+      appendable.append(\" implements \");\n+      implementedTypesIterator.next().write(appendable, context);\n+      while (implementedTypesIterator.hasNext()) {\n+        appendable.append(\", \");\n+        implementedTypesIterator.next().write(appendable, context);\n+      }\n+    }\n+    appendable.append(\" {\");\n     for (MethodWriter methodWriter : methodWriters) {\n+      appendable.append('\\n');\n       methodWriter.write(new IndentingAppendable(appendable), context);\n     }\n-    appendable.append('\\n');\n     for (TypeWriter nestedTypeWriter : nestedTypeWriters) {\n+      appendable.append('\\n');\n       nestedTypeWriter.write(new IndentingAppendable(appendable), context);\n     }\n     appendable.append(\"}\\n\");\n@@ -46,7 +68,11 @@ public class InterfaceWriter extends TypeWriter {\n \n   @Override\n   public Set<ClassName> referencedClasses() {\n-    return FluentIterable.from(nestedTypeWriters)\n+    @SuppressWarnings(\"unchecked\")\n+    Iterable<? extends HasClassReferences> concat =\n+        Iterables.concat(nestedTypeWriters, methodWriters, implementedTypes, supertype.asSet(),\n+            annotations);\n+    return FluentIterable.from(concat)\n         .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {\n           @Override\n           public Set<ClassName> apply(HasClassReferences input) {\n"
    },
    {
        "commit_hash": "ad2f5ce47e69a3eafa21a896943445144aa64460",
        "previous_commit_hash": "b1e0d9ecb5203b9dc0fe6ce2499e0e278744d006",
        "diff_stats": {
            "additions": 29,
            "deletions": 0
        },
        "diff_content": "@@ -3,6 +3,7 @@ package dagger.internal.codegen.writer;\n import com.google.common.base.Optional;\n import com.google.common.collect.Lists;\n import java.util.List;\n+import javax.lang.model.type.TypeMirror;\n \n \n /**\n@@ -13,15 +14,43 @@ public abstract class TypeWriter /* ha ha */ extends Modifiable\n   final ClassName name;\n   Optional<TypeName> supertype;\n   final List<TypeName> implementedTypes;\n+  final List<MethodWriter> methodWriters;\n \n   TypeWriter(ClassName name) {\n     this.name = name;\n     this.supertype = Optional.absent();\n     this.implementedTypes = Lists.newArrayList();\n+    this.methodWriters = Lists.newArrayList();\n   }\n \n   @Override\n   public TypeName name() {\n     return name;\n   }\n+\n+  public MethodWriter addMethod(TypeWriter returnType, String name) {\n+    MethodWriter methodWriter = new MethodWriter(returnType.name, name);\n+    methodWriters.add(methodWriter);\n+    return methodWriter;\n+  }\n+\n+  public MethodWriter addMethod(TypeMirror returnType, String name) {\n+    MethodWriter methodWriter =\n+        new MethodWriter(TypeNames.forTypeMirror(returnType), name);\n+    methodWriters.add(methodWriter);\n+    return methodWriter;\n+  }\n+\n+  public MethodWriter addMethod(TypeName returnType, String name) {\n+    MethodWriter methodWriter = new MethodWriter(returnType, name);\n+    methodWriters.add(methodWriter);\n+    return methodWriter;\n+  }\n+\n+  public MethodWriter addMethod(Class<?> returnType, String name) {\n+    MethodWriter methodWriter =\n+        new MethodWriter(ClassName.fromClass(returnType), name);\n+    methodWriters.add(methodWriter);\n+    return methodWriter;\n+  }\n }\n"
    },
    {
        "commit_hash": "8483d5f9309c645ed2677d88181a864a3ab8d332",
        "previous_commit_hash": "ad2f5ce47e69a3eafa21a896943445144aa64460",
        "diff_stats": {
            "additions": 17,
            "deletions": 13
        },
        "diff_content": "@@ -5,10 +5,12 @@ import com.google.common.base.Joiner;\n import com.google.common.collect.FluentIterable;\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n import java.io.IOException;\n import java.util.Iterator;\n import java.util.List;\n+import java.util.Map;\n import java.util.Set;\n import javax.lang.model.element.Modifier;\n import javax.lang.model.element.TypeElement;\n@@ -19,14 +21,14 @@ import static javax.lang.model.element.Modifier.PUBLIC;\n \n public final class ClassWriter extends TypeWriter {\n   private final List<TypeWriter> nestedTypeWriters;\n-  private final List<FieldWriter> fieldWriters;\n+  private final Map<String, FieldWriter> fieldWriters;\n   private final List<ConstructorWriter> constructorWriters;\n   private final List<TypeVariableName> typeVariables;\n \n   ClassWriter(ClassName className) {\n     super(className);\n     this.nestedTypeWriters = Lists.newArrayList();\n-    this.fieldWriters = Lists.newArrayList();\n+    this.fieldWriters = Maps.newLinkedHashMap();\n     this.constructorWriters = Lists.newArrayList();\n     this.typeVariables = Lists.newArrayList();\n   }\n@@ -40,20 +42,22 @@ public final class ClassWriter extends TypeWriter {\n   }\n \n   public FieldWriter addField(Class<?> type, String name) {\n-    FieldWriter fieldWriter = new FieldWriter(ClassName.fromClass(type), name);\n-    fieldWriters.add(fieldWriter);\n-    return fieldWriter;\n+    return addField(ClassName.fromClass(type), name);\n   }\n \n   public FieldWriter addField(TypeElement type, String name) {\n-    FieldWriter fieldWriter = new FieldWriter(ClassName.fromTypeElement(type), name);\n-    fieldWriters.add(fieldWriter);\n-    return fieldWriter;\n+    return addField(ClassName.fromTypeElement(type), name);\n   }\n \n   public FieldWriter addField(TypeName type, String name) {\n-    FieldWriter fieldWriter = new FieldWriter(type, name);\n-    fieldWriters.add(fieldWriter);\n+    String candidateName = name;\n+    int differentiator = 1;\n+    while (fieldWriters.containsKey(candidateName)) {\n+      candidateName = name + differentiator;\n+      differentiator++;\n+    }\n+    FieldWriter fieldWriter = new FieldWriter(type, candidateName);\n+    fieldWriters.put(candidateName, fieldWriter);\n     return fieldWriter;\n   }\n \n@@ -102,7 +106,7 @@ public final class ClassWriter extends TypeWriter {\n     if (!fieldWriters.isEmpty()) {\n       appendable.append('\\n');\n     }\n-    for (VariableWriter fieldWriter : fieldWriters) {\n+    for (VariableWriter fieldWriter : fieldWriters.values()) {\n       fieldWriter.write(new IndentingAppendable(appendable), context).append(\"\\n\");\n     }\n     for (ConstructorWriter constructorWriter : constructorWriters) {\n@@ -135,8 +139,8 @@ public final class ClassWriter extends TypeWriter {\n   @Override\n   public Set<ClassName> referencedClasses() {\n     Iterable<? extends HasClassReferences> concat =\n-        Iterables.concat(nestedTypeWriters, fieldWriters, constructorWriters, methodWriters,\n-            implementedTypes, supertype.asSet(), annotations);\n+        Iterables.concat(nestedTypeWriters, fieldWriters.values(), constructorWriters,\n+            methodWriters, implementedTypes, supertype.asSet(), annotations);\n     return FluentIterable.from(concat)\n         .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {\n           @Override\n"
    },
    {
        "commit_hash": "8483d5f9309c645ed2677d88181a864a3ab8d332",
        "previous_commit_hash": "ad2f5ce47e69a3eafa21a896943445144aa64460",
        "diff_stats": {
            "additions": 2,
            "deletions": 1
        },
        "diff_content": "@@ -11,6 +11,7 @@ import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Ordering;\n import com.google.common.collect.Sets;\n+import com.google.common.escape.Escapers;\n import com.google.common.io.Closer;\n import dagger.internal.codegen.writer.Writable.Context;\n import java.io.IOException;\n@@ -249,7 +250,7 @@ public final class JavaWriter {\n       StringBuffer buffer = new StringBuffer();\n       while (matcher.find()) {\n         matcher.appendReplacement(buffer, collidesWithVisibleClass(matcher.group(1))\n-            ? matcher.group()\n+            ? Escapers.builder().addEscape('$', \"\\\\$\").build().escape(matcher.group())\n             : \"$1$2\");\n       }\n       matcher.appendTail(buffer);\n"
    },
    {
        "commit_hash": "a4b5551cf7586c20845bffc6829e9dd227a2316e",
        "previous_commit_hash": "66c9095d027da6aad0ad7cc24e01422beedf901b",
        "diff_stats": {
            "additions": 10,
            "deletions": 0
        },
        "diff_content": "@@ -27,6 +27,7 @@ import static javax.lang.model.element.Modifier.ABSTRACT;\n \n /** A utility class which aids in generating Java source files. */\n public class JavaWriter implements Closeable {\n+  private static final Pattern TYPE_TRAILER = Pattern.compile(\"(.*?)(\\\\.\\\\.\\\\.|(?:\\\\[\\\\])+)$\");\n   private static final Pattern TYPE_PATTERN = Pattern.compile(\"(?:[\\\\w$]+\\\\.)*([\\\\w\\\\.*$]+)\");\n   private static final int MAX_SINGLE_LINE_ATTRIBUTES = 3;\n   private static final String INDENT = \"  \";\n@@ -164,6 +165,11 @@ public class JavaWriter implements Closeable {\n \n   /** Try to compress a fully-qualified class name to only the class name. */\n   public String compressType(String type) {\n+    Matcher trailer = TYPE_TRAILER.matcher(type);\n+    if (trailer.matches()) {\n+      type = trailer.group(1);\n+    }\n+\n     StringBuilder sb = new StringBuilder();\n     if (this.packagePrefix == null) {\n       throw new IllegalStateException();\n@@ -201,6 +207,10 @@ public class JavaWriter implements Closeable {\n       }\n       pos = m.end();\n     }\n+\n+    if (trailer.matches()) {\n+      sb.append(trailer.group(2));\n+    }\n     return sb.toString();\n   }\n \n"
    },
    {
        "commit_hash": "a4b5551cf7586c20845bffc6829e9dd227a2316e",
        "previous_commit_hash": "66c9095d027da6aad0ad7cc24e01422beedf901b",
        "diff_stats": {
            "additions": 16,
            "deletions": 0
        },
        "diff_content": "@@ -863,6 +863,22 @@ public final class JavaWriterTest {\n     assertThat(actual).isEqualTo(\"java.lang.annotation.Annotation\");\n   }\n \n+  @Test public void compressVarargsType() throws IOException {\n+    javaWriter.emitPackage(\"com.blah\");\n+    javaWriter.emitImports(\"java.util.File\");\n+    String actual = javaWriter.compressType(\"java.util.File...\");\n+    assertThat(actual).isEqualTo(\"File...\");\n+  }\n+\n+  @Test public void compressArrayType() throws IOException {\n+    javaWriter.emitPackage(\"com.blah\");\n+    javaWriter.emitImports(\"java.util.File\");\n+    String actual1 = javaWriter.compressType(\"java.util.File[]\");\n+    assertThat(actual1).isEqualTo(\"File[]\");\n+    String actual2 = javaWriter.compressType(\"java.util.File[][][]\");\n+    assertThat(actual2).isEqualTo(\"File[][][]\");\n+  }\n+\n   @Test public void configurableIndent() throws IOException {\n     javaWriter.setIndent(\"    \");\n     javaWriter.emitPackage(\"com.squareup\");\n"
    },
    {
        "commit_hash": "4969b4a2ecf44c52b998be58f1f00f79a3186acb",
        "previous_commit_hash": "8483d5f9309c645ed2677d88181a864a3ab8d332",
        "diff_stats": {
            "additions": 0,
            "deletions": 1
        },
        "diff_content": "@@ -179,7 +179,6 @@ public final class JavaWriter {\n     }\n   }\n \n-\n   static final class CompilationUnitContext implements Writable.Context {\n     private final String packageName;\n     private final ImmutableSortedSet<ClassName> visibleClasses;\n"
    },
    {
        "commit_hash": "4969b4a2ecf44c52b998be58f1f00f79a3186acb",
        "previous_commit_hash": "8483d5f9309c645ed2677d88181a864a3ab8d332",
        "diff_stats": {
            "additions": 0,
            "deletions": 1
        },
        "diff_content": "@@ -14,7 +14,6 @@ import javax.lang.model.element.TypeElement;\n \n import static com.google.common.base.Preconditions.checkArgument;\n \n-\n public class MethodWriter extends Modifiable implements HasClassReferences, Writable {\n   private final TypeName returnType;\n   private final String name;\n"
    },
    {
        "commit_hash": "4969b4a2ecf44c52b998be58f1f00f79a3186acb",
        "previous_commit_hash": "8483d5f9309c645ed2677d88181a864a3ab8d332",
        "diff_stats": {
            "additions": 0,
            "deletions": 1
        },
        "diff_content": "@@ -28,7 +28,6 @@ public abstract class Modifiable {\n     return annotationWriter;\n   }\n \n-\n   Appendable writeModifiers(Appendable appendable) throws IOException {\n     for (Modifier modifier : modifiers) {\n       appendable.append(modifier.toString()).append(' ');\n"
    },
    {
        "commit_hash": "4969b4a2ecf44c52b998be58f1f00f79a3186acb",
        "previous_commit_hash": "8483d5f9309c645ed2677d88181a864a3ab8d332",
        "diff_stats": {
            "additions": 0,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,6 @@ import com.google.common.collect.Lists;\n import java.util.List;\n import javax.lang.model.type.TypeMirror;\n \n-\n /**\n  * Only named types. Doesn't cover anonymous inner classes.\n  */\n"
    },
    {
        "commit_hash": "4969b4a2ecf44c52b998be58f1f00f79a3186acb",
        "previous_commit_hash": "8483d5f9309c645ed2677d88181a864a3ab8d332",
        "diff_stats": {
            "additions": 0,
            "deletions": 1
        },
        "diff_content": "@@ -3,7 +3,6 @@ package dagger.internal.codegen.writer;\n import java.io.IOException;\n import java.util.Set;\n \n-\n public class VariableWriter extends Modifiable implements Writable, HasClassReferences {\n   private final TypeName type;\n   private final String name;\n"
    },
    {
        "commit_hash": "084e7cca454573372b86ff0749d100853132dcc4",
        "previous_commit_hash": "4969b4a2ecf44c52b998be58f1f00f79a3186acb",
        "diff_stats": {
            "additions": 12,
            "deletions": 15
        },
        "diff_content": "@@ -21,15 +21,11 @@ import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n import javax.annotation.processing.Filer;\n import javax.lang.model.element.Element;\n-import javax.lang.model.element.Modifier;\n import javax.lang.model.element.PackageElement;\n import javax.tools.JavaFileObject;\n \n-import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkNotNull;\n-import static javax.lang.model.element.Modifier.PRIVATE;\n-import static javax.lang.model.element.Modifier.PROTECTED;\n-import static javax.lang.model.element.Modifier.STATIC;\n+import static java.util.Collections.unmodifiableList;\n \n /**\n  * Writes a single compilation unit.\n@@ -48,7 +44,7 @@ public final class JavaWriter {\n   }\n \n   private final String packageName;\n-  // TODO(gak): disallow multiple types in a file\n+  // TODO(gak): disallow multiple types in a file?\n   private final List<TypeWriter> typeWriters;\n   private final List<ClassName> explicitImports;\n \n@@ -58,20 +54,17 @@ public final class JavaWriter {\n     this.explicitImports = Lists.newArrayList();\n   }\n \n+  public List<TypeWriter> getTypeWriters() {\n+    return unmodifiableList(typeWriters);\n+  }\n+\n   public JavaWriter addImport(Class<?> importedClass) {\n     explicitImports.add(ClassName.fromClass(importedClass));\n     return this;\n   }\n \n   public ClassWriter addClass(String simpleName) {\n-    Set<Modifier> modifiers = ImmutableSet.<Modifier>of();\n-    checkNotNull(modifiers);\n     checkNotNull(simpleName);\n-    checkArgument(!modifiers.contains(PROTECTED));\n-    checkArgument(!modifiers.contains(PRIVATE));\n-    checkArgument(!modifiers.contains(STATIC));\n-    checkNotNull(Optional.<Class<?>>absent());\n-    checkNotNull(ImmutableSet.<Class<?>>of());\n     ClassWriter classWriter = new ClassWriter(ClassName.create(packageName, simpleName));\n     typeWriters.add(classWriter);\n     return classWriter;\n@@ -152,8 +145,12 @@ public final class JavaWriter {\n \n   public void file(Filer filer, Iterable<? extends Element> originatingElements)\n       throws IOException {\n-    JavaFileObject sourceFile = filer.createSourceFile(\n-        Iterables.getOnlyElement(typeWriters).name.canonicalName(),\n+    file(filer, Iterables.getOnlyElement(typeWriters).name.canonicalName(), originatingElements);\n+  }\n+\n+  public void file(Filer filer, CharSequence name,  Iterable<? extends Element> originatingElements)\n+      throws IOException {\n+    JavaFileObject sourceFile = filer.createSourceFile(name,\n         Iterables.toArray(originatingElements, Element.class));\n     Closer closer = Closer.create();\n     try {\n"
    },
    {
        "commit_hash": "084e7cca454573372b86ff0749d100853132dcc4",
        "previous_commit_hash": "4969b4a2ecf44c52b998be58f1f00f79a3186acb",
        "diff_stats": {
            "additions": 6,
            "deletions": 1
        },
        "diff_content": "@@ -1,5 +1,6 @@\n package dagger.internal.codegen.writer;\n \n+import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n import dagger.internal.codegen.writer.Writable.Context;\n import java.io.IOException;\n@@ -19,7 +20,11 @@ public abstract class Modifiable {\n   }\n \n   public void addModifiers(Modifier first, Modifier... rest) {\n-    this.modifiers.addAll(Lists.asList(first, rest));\n+    addModifiers(Lists.asList(first, rest));\n+  }\n+\n+  public void addModifiers(Iterable<Modifier> modifiers) {\n+    Iterables.addAll(this.modifiers, modifiers);\n   }\n \n   public AnnotationWriter annotate(Class<? extends Annotation> annotation) {\n"
    },
    {
        "commit_hash": "084e7cca454573372b86ff0749d100853132dcc4",
        "previous_commit_hash": "4969b4a2ecf44c52b998be58f1f00f79a3186acb",
        "diff_stats": {
            "additions": 12,
            "deletions": 4
        },
        "diff_content": "@@ -1,9 +1,12 @@\n package dagger.internal.codegen.writer;\n \n import com.google.common.base.Function;\n+import com.google.common.base.Joiner;\n import com.google.common.collect.FluentIterable;\n import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n import java.io.IOException;\n+import java.util.Collections;\n import java.util.Iterator;\n import java.util.List;\n import java.util.Set;\n@@ -12,7 +15,7 @@ public final class Snippet implements HasClassReferences, Writable {\n   private final String value;\n   private final ImmutableSet<TypeName> types;\n \n-  Snippet(String value, ImmutableSet<TypeName> types) {\n+  private Snippet(String value, ImmutableSet<TypeName> types) {\n     this.value = value;\n     this.types = types;\n   }\n@@ -64,8 +67,13 @@ public final class Snippet implements HasClassReferences, Writable {\n     return new Snippet(value, types.build());\n   }\n \n-  public static Snippet create(String value, Iterable<TypeName> types) {\n-    return new Snippet(value, ImmutableSet.copyOf(types));\n+  public static Snippet format(String format, Iterable<? extends Object> args) {\n+    return format(format, Iterables.toArray(args, Object.class));\n+  }\n+\n+  public static Snippet memberSelectSnippet(Iterable<? extends Object> selectors) {\n+    return format(Joiner.on('.').join(Collections.nCopies(Iterables.size(selectors), \"%s\")),\n+        selectors);\n   }\n \n   public static Snippet makeParametersSnippet(List<Snippet> parameterSnippets) {\n@@ -82,6 +90,6 @@ public final class Snippet implements HasClassReferences, Writable {\n       stringBuilder.append(\", \").append(nextSnippet.value());\n       typesBuilder.addAll(nextSnippet.types());\n     }\n-    return Snippet.create(stringBuilder.toString(), typesBuilder.build());\n+    return new Snippet(stringBuilder.toString(), ImmutableSet.copyOf(typesBuilder.build()));\n   }\n }\n"
    },
    {
        "commit_hash": "084e7cca454573372b86ff0749d100853132dcc4",
        "previous_commit_hash": "4969b4a2ecf44c52b998be58f1f00f79a3186acb",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -23,7 +23,7 @@ public abstract class TypeWriter /* ha ha */ extends Modifiable\n   }\n \n   @Override\n-  public TypeName name() {\n+  public ClassName name() {\n     return name;\n   }\n \n"
    },
    {
        "commit_hash": "3fbe8c818ee4c0161ae9f14b1121c9eb8d934524",
        "previous_commit_hash": "084e7cca454573372b86ff0749d100853132dcc4",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -12,7 +12,7 @@ import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n \n-import static org.truth0.Truth.ASSERT;\n+import static com.google.common.truth.Truth.ASSERT;\n \n @RunWith(JUnit4.class)\n public class TypeNamesTest {\n"
    },
    {
        "commit_hash": "fc7374057a8042083bcb37ec2775b97a1b83105c",
        "previous_commit_hash": "3fbe8c818ee4c0161ae9f14b1121c9eb8d934524",
        "diff_stats": {
            "additions": 1,
            "deletions": 37
        },
        "diff_content": "@@ -11,14 +11,11 @@ import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Ordering;\n import com.google.common.collect.Sets;\n-import com.google.common.escape.Escapers;\n import com.google.common.io.Closer;\n import dagger.internal.codegen.writer.Writable.Context;\n import java.io.IOException;\n import java.util.List;\n import java.util.Set;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n import javax.annotation.processing.Filer;\n import javax.lang.model.element.Element;\n import javax.lang.model.element.PackageElement;\n@@ -76,18 +73,6 @@ public final class JavaWriter {\n     return writer;\n   }\n \n-  static ImmutableSet<ClassName> collectReferencedClasses(\n-      Iterable<? extends HasClassReferences> iterable) {\n-    return FluentIterable.from(iterable)\n-        .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {\n-          @Override\n-          public Set<ClassName> apply(HasClassReferences input) {\n-            return input.referencedClasses();\n-          }\n-        })\n-        .toSet();\n-  }\n-\n   public Appendable write(Appendable appendable) throws IOException {\n     appendable.append(\"package \").append(packageName).append(';').append(\"\\n\\n\");\n \n@@ -100,6 +85,7 @@ public final class JavaWriter {\n           }\n         })\n         .toSet();\n+\n     BiMap<String, ClassName> importedClassIndex = HashBiMap.create();\n     // TODO(gak): check for collisions with types declared in this compilation unit too\n     ImmutableSortedSet<ClassName> importCandidates = ImmutableSortedSet.<ClassName>naturalOrder()\n@@ -230,27 +216,5 @@ public final class JavaWriter {\n           || (className.packageName().equals(\"java.lang\")\n               && className.enclosingSimpleNames().isEmpty());\n     }\n-\n-    private static final String JAVA_IDENTIFIER_REGEX =\n-        \"\\\\p{javaJavaIdentifierStart}\\\\p{javaJavaIdentifierPart}*\";\n-\n-    @Override\n-    public String compressTypesWithin(String snippet) {\n-      // TODO(gak): deal with string literals\n-      for (ClassName importedClass : visibleClasses) {\n-        snippet = snippet.replace(importedClass.canonicalName(), importedClass.simpleName());\n-      }\n-      Pattern samePackagePattern = Pattern.compile(\n-          packageName.replace(\".\", \"\\\\.\") + \"\\\\.(\" + JAVA_IDENTIFIER_REGEX + \")([^\\\\.])\");\n-      Matcher matcher = samePackagePattern.matcher(snippet);\n-      StringBuffer buffer = new StringBuffer();\n-      while (matcher.find()) {\n-        matcher.appendReplacement(buffer, collidesWithVisibleClass(matcher.group(1))\n-            ? Escapers.builder().addEscape('$', \"\\\\$\").build().escape(matcher.group())\n-            : \"$1$2\");\n-      }\n-      matcher.appendTail(buffer);\n-      return buffer.toString();\n-    }\n   }\n }\n"
    },
    {
        "commit_hash": "fc7374057a8042083bcb37ec2775b97a1b83105c",
        "previous_commit_hash": "3fbe8c818ee4c0161ae9f14b1121c9eb8d934524",
        "diff_stats": {
            "additions": 35,
            "deletions": 12
        },
        "diff_content": "@@ -3,25 +3,33 @@ package dagger.internal.codegen.writer;\n import com.google.common.base.Function;\n import com.google.common.base.Joiner;\n import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Iterables;\n import java.io.IOException;\n import java.util.Collections;\n+import java.util.Formatter;\n import java.util.Iterator;\n import java.util.List;\n import java.util.Set;\n \n public final class Snippet implements HasClassReferences, Writable {\n-  private final String value;\n+  private final String format;\n   private final ImmutableSet<TypeName> types;\n+  private final ImmutableList<Object> args;\n \n-  private Snippet(String value, ImmutableSet<TypeName> types) {\n-    this.value = value;\n+  private Snippet(String format, ImmutableSet<TypeName> types, ImmutableList<Object> args) {\n+    this.format = format;\n     this.types = types;\n+    this.args = args;\n   }\n \n-  public String value() {\n-    return value;\n+  public String format() {\n+    return format;\n+  }\n+\n+  public ImmutableList<Object> args() {\n+    return args;\n   }\n \n   public ImmutableSet<TypeName> types() {\n@@ -30,7 +38,7 @@ public final class Snippet implements HasClassReferences, Writable {\n \n   @Override\n   public String toString() {\n-    return value;\n+    return Writables.writeToString(this);\n   }\n \n   @Override\n@@ -47,11 +55,23 @@ public final class Snippet implements HasClassReferences, Writable {\n \n   @Override\n   public Appendable write(Appendable appendable, Context context) throws IOException {\n-    return appendable.append(context.compressTypesWithin(value));\n+    ImmutableList.Builder<Object> formattedArgsBuilder = ImmutableList.builder();\n+    for (Object arg : args) {\n+      if (arg instanceof Writable) {\n+        formattedArgsBuilder.add(((Writable) arg).write(new StringBuilder(), context).toString());\n+      } else {\n+        formattedArgsBuilder.add(arg);\n+      }\n+    }\n+\n+    @SuppressWarnings(\"resource\") // intentionally don't close the formatter\n+    Formatter formatter = new Formatter(appendable);\n+    formatter.format(format, formattedArgsBuilder.build().toArray(new Object[0]));\n+\n+    return appendable;\n   }\n \n   public static Snippet format(String format, Object... args) {\n-    String value = String.format(format, args);\n     ImmutableSet.Builder<TypeName> types = ImmutableSet.builder();\n     for (Object arg : args) {\n       if (arg instanceof Snippet) {\n@@ -64,7 +84,7 @@ public final class Snippet implements HasClassReferences, Writable {\n         types.add(((HasTypeName) arg).name());\n       }\n     }\n-    return new Snippet(value, types.build());\n+    return new Snippet(format, types.build(), ImmutableList.copyOf(args));\n   }\n \n   public static Snippet format(String format, Iterable<? extends Object> args) {\n@@ -80,16 +100,19 @@ public final class Snippet implements HasClassReferences, Writable {\n     Iterator<Snippet> iterator = parameterSnippets.iterator();\n     StringBuilder stringBuilder = new StringBuilder();\n     ImmutableSet.Builder<TypeName> typesBuilder = ImmutableSet.builder();\n+    ImmutableList.Builder<Object> argsBuilder = ImmutableList.builder();\n     if (iterator.hasNext()) {\n       Snippet firstSnippet = iterator.next();\n-      stringBuilder.append(firstSnippet.value());\n+      stringBuilder.append(firstSnippet.format());\n       typesBuilder.addAll(firstSnippet.types());\n+      argsBuilder.addAll(firstSnippet.args());\n     }\n     while (iterator.hasNext()) {\n       Snippet nextSnippet = iterator.next();\n-      stringBuilder.append(\", \").append(nextSnippet.value());\n+      stringBuilder.append(\", \").append(nextSnippet.format());\n       typesBuilder.addAll(nextSnippet.types());\n+      argsBuilder.addAll(nextSnippet.args());\n     }\n-    return new Snippet(stringBuilder.toString(), ImmutableSet.copyOf(typesBuilder.build()));\n+    return new Snippet(stringBuilder.toString(), typesBuilder.build(), argsBuilder.build());\n   }\n }\n"
    },
    {
        "commit_hash": "fc7374057a8042083bcb37ec2775b97a1b83105c",
        "previous_commit_hash": "3fbe8c818ee4c0161ae9f14b1121c9eb8d934524",
        "diff_stats": {
            "additions": 0,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,6 @@ import java.util.Set;\n interface Writable {\n   interface Context {\n     String sourceReferenceForClassName(ClassName className);\n-    String compressTypesWithin(String snippet);\n     Context createSubcontext(Set<ClassName> newTypes);\n   }\n \n"
    },
    {
        "commit_hash": "fc7374057a8042083bcb37ec2775b97a1b83105c",
        "previous_commit_hash": "3fbe8c818ee4c0161ae9f14b1121c9eb8d934524",
        "diff_stats": {
            "additions": 0,
            "deletions": 5
        },
        "diff_content": "@@ -20,11 +20,6 @@ final class Writables {\n       return className.canonicalName();\n     }\n \n-    @Override\n-    public String compressTypesWithin(String snippet) {\n-      return snippet;\n-    }\n-\n     @Override\n     public Context createSubcontext(Set<ClassName> newTypes) {\n       throw new UnsupportedOperationException();\n"
    },
    {
        "commit_hash": "ac78f10cf6365dfbd9b1676d40eb1580c3856148",
        "previous_commit_hash": "fc7374057a8042083bcb37ec2775b97a1b83105c",
        "diff_stats": {
            "additions": 16,
            "deletions": 16
        },
        "diff_content": "@@ -12,7 +12,7 @@ import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n \n-import static com.google.common.truth.Truth.ASSERT;\n+import static com.google.common.truth.Truth.assert_;\n \n @RunWith(JUnit4.class)\n public class TypeNamesTest {\n@@ -28,11 +28,11 @@ public class TypeNamesTest {\n \n   @Test\n   public void forTypeMirror_basicTypes() {\n-    ASSERT.that(TypeNames.forTypeMirror(getType(Object.class)))\n+    assert_().that(TypeNames.forTypeMirror(getType(Object.class)))\n         .isEqualTo(ClassName.fromClass(Object.class));\n-    ASSERT.that(TypeNames.forTypeMirror(getType(Charset.class)))\n+    assert_().that(TypeNames.forTypeMirror(getType(Charset.class)))\n         .isEqualTo(ClassName.fromClass(Charset.class));\n-    ASSERT.that(TypeNames.forTypeMirror(getType(TypeNamesTest.class)))\n+    assert_().that(TypeNames.forTypeMirror(getType(TypeNamesTest.class)))\n         .isEqualTo(ClassName.fromClass(TypeNamesTest.class));\n   }\n \n@@ -40,45 +40,45 @@ public class TypeNamesTest {\n   public void forTypeMirror_parameterizedType() {\n     DeclaredType setType =\n         compilation.getTypes().getDeclaredType(getElement(Set.class), getType(Object.class));\n-    ASSERT.that(TypeNames.forTypeMirror(setType))\n+    assert_().that(TypeNames.forTypeMirror(setType))\n         .isEqualTo(ParameterizedTypeName.create(Set.class, ClassName.fromClass(Object.class)));\n   }\n \n   @Test\n   public void forTypeMirror_primitive() {\n-    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.BOOLEAN)))\n+    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.BOOLEAN)))\n         .isEqualTo(PrimitiveName.BOOLEAN);\n-    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.BYTE)))\n+    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.BYTE)))\n         .isEqualTo(PrimitiveName.BYTE);\n-    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.SHORT)))\n+    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.SHORT)))\n         .isEqualTo(PrimitiveName.SHORT);\n-    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.INT)))\n+    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.INT)))\n         .isEqualTo(PrimitiveName.INT);\n-    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.LONG)))\n+    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.LONG)))\n         .isEqualTo(PrimitiveName.LONG);\n-    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.CHAR)))\n+    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.CHAR)))\n         .isEqualTo(PrimitiveName.CHAR);\n-    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.FLOAT)))\n+    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.FLOAT)))\n         .isEqualTo(PrimitiveName.FLOAT);\n-    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.DOUBLE)))\n+    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.DOUBLE)))\n         .isEqualTo(PrimitiveName.DOUBLE);\n   }\n \n   @Test\n   public void forTypeMirror_arrays() {\n-    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getArrayType(getType(Object.class))))\n+    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getArrayType(getType(Object.class))))\n         .isEqualTo(new ArrayTypeName(ClassName.fromClass(Object.class)));\n   }\n \n   @Test\n   public void forTypeMirror_void() {\n-    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getNoType(TypeKind.VOID)))\n+    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getNoType(TypeKind.VOID)))\n         .isEqualTo(VoidName.VOID);\n   }\n \n   @Test\n   public void forTypeMirror_null() {\n-    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getNullType()))\n+    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getNullType()))\n         .isEqualTo(NullName.NULL);\n   }\n }\n"
    },
    {
        "commit_hash": "67bd94d79728595dbcbc4fae3f28c51075d788ba",
        "previous_commit_hash": "ac78f10cf6365dfbd9b1676d40eb1580c3856148",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -31,7 +31,7 @@ final class Writables {\n     try {\n       writable.write(builder, DEFAULT_CONTEXT);\n     } catch (IOException e) {\n-      throw new AssertionError(\"StringBuilder doesn't throw IOException\", e);\n+      throw new AssertionError(\"StringBuilder doesn't throw IOException\" + e);\n     }\n     return builder.toString();\n   }\n"
    },
    {
        "commit_hash": "cb4224b5de1e3a3c3e0795d7f6abd22ec0796772",
        "previous_commit_hash": "67bd94d79728595dbcbc4fae3f28c51075d788ba",
        "diff_stats": {
            "additions": 0,
            "deletions": 8
        },
        "diff_content": "@@ -20,14 +20,12 @@ import static javax.lang.model.element.Modifier.PROTECTED;\n import static javax.lang.model.element.Modifier.PUBLIC;\n \n public final class ClassWriter extends TypeWriter {\n-  private final List<TypeWriter> nestedTypeWriters;\n   private final Map<String, FieldWriter> fieldWriters;\n   private final List<ConstructorWriter> constructorWriters;\n   private final List<TypeVariableName> typeVariables;\n \n   ClassWriter(ClassName className) {\n     super(className);\n-    this.nestedTypeWriters = Lists.newArrayList();\n     this.fieldWriters = Maps.newLinkedHashMap();\n     this.constructorWriters = Lists.newArrayList();\n     this.typeVariables = Lists.newArrayList();\n@@ -67,12 +65,6 @@ public final class ClassWriter extends TypeWriter {\n     return constructorWriter;\n   }\n \n-  public ClassWriter addNestedClass(String name) {\n-    ClassWriter innerClassWriter = new ClassWriter(this.name.nestedClassNamed(name));\n-    nestedTypeWriters.add(innerClassWriter);\n-    return innerClassWriter;\n-  }\n-\n   @Override\n   public Appendable write(Appendable appendable, Context context) throws IOException {\n     context = context.createSubcontext(FluentIterable.from(nestedTypeWriters)\n"
    },
    {
        "commit_hash": "cb4224b5de1e3a3c3e0795d7f6abd22ec0796772",
        "previous_commit_hash": "67bd94d79728595dbcbc4fae3f28c51075d788ba",
        "diff_stats": {
            "additions": 0,
            "deletions": 3
        },
        "diff_content": "@@ -12,12 +12,9 @@ import java.util.Set;\n \n public class InterfaceWriter extends TypeWriter {\n   private final List<TypeVariableName> typeVariables;\n-  private final List<TypeWriter> nestedTypeWriters;\n-\n   InterfaceWriter(ClassName name) {\n     super(name);\n     this.typeVariables = Lists.newArrayList();\n-    this.nestedTypeWriters = Lists.newArrayList();\n   }\n \n   public void addTypeVariable(TypeVariableName typeVariable) {\n"
    },
    {
        "commit_hash": "cb4224b5de1e3a3c3e0795d7f6abd22ec0796772",
        "previous_commit_hash": "67bd94d79728595dbcbc4fae3f28c51075d788ba",
        "diff_stats": {
            "additions": 16,
            "deletions": 3
        },
        "diff_content": "@@ -10,10 +10,12 @@ import com.google.common.collect.ImmutableSortedSet;\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Ordering;\n+import com.google.common.collect.Queues;\n import com.google.common.collect.Sets;\n import com.google.common.io.Closer;\n import dagger.internal.codegen.writer.Writable.Context;\n import java.io.IOException;\n+import java.util.Deque;\n import java.util.List;\n import java.util.Set;\n import javax.annotation.processing.Filer;\n@@ -86,8 +88,6 @@ public final class JavaWriter {\n         })\n         .toSet();\n \n-    BiMap<String, ClassName> importedClassIndex = HashBiMap.create();\n-    // TODO(gak): check for collisions with types declared in this compilation unit too\n     ImmutableSortedSet<ClassName> importCandidates = ImmutableSortedSet.<ClassName>naturalOrder()\n         .addAll(explicitImports)\n         .addAll(classNames)\n@@ -99,6 +99,18 @@ public final class JavaWriter {\n           }\n         })\n         .toSet();\n+\n+    ImmutableSet.Builder<String> declaredSimpleNamesBuilder = ImmutableSet.builder();\n+    Deque<TypeWriter> declaredTypes = Queues.newArrayDeque(typeWriters);\n+    while (!declaredTypes.isEmpty()) {\n+      TypeWriter currentType = declaredTypes.pop();\n+      declaredSimpleNamesBuilder.add(currentType.name().simpleName());\n+      declaredTypes.addAll(currentType.nestedTypeWriters);\n+    }\n+\n+    ImmutableSet<String> declaredSimpleNames = declaredSimpleNamesBuilder.build();\n+\n+    BiMap<String, ClassName> importedClassIndex = HashBiMap.create();\n     for (ClassName className : importCandidates) {\n       if (!(className.packageName().equals(packageName)\n               && !className.enclosingClassName().isPresent())\n@@ -107,7 +119,8 @@ public final class JavaWriter {\n           && !typeNames.contains(className.topLevelClassName())) {\n         Optional<ClassName> importCandidate = Optional.of(className);\n         while (importCandidate.isPresent()\n-            && importedClassIndex.containsKey(importCandidate.get().simpleName())) {\n+            && (importedClassIndex.containsKey(importCandidate.get().simpleName())\n+                || declaredSimpleNames.contains(importCandidate.get().simpleName()))) {\n           importCandidate = importCandidate.get().enclosingClassName();\n         }\n         if (importCandidate.isPresent()) {\n"
    },
    {
        "commit_hash": "cb4224b5de1e3a3c3e0795d7f6abd22ec0796772",
        "previous_commit_hash": "67bd94d79728595dbcbc4fae3f28c51075d788ba",
        "diff_stats": {
            "additions": 8,
            "deletions": 0
        },
        "diff_content": "@@ -14,12 +14,14 @@ public abstract class TypeWriter /* ha ha */ extends Modifiable\n   Optional<TypeName> supertype;\n   final List<TypeName> implementedTypes;\n   final List<MethodWriter> methodWriters;\n+  final List<TypeWriter> nestedTypeWriters;\n \n   TypeWriter(ClassName name) {\n     this.name = name;\n     this.supertype = Optional.absent();\n     this.implementedTypes = Lists.newArrayList();\n     this.methodWriters = Lists.newArrayList();\n+    nestedTypeWriters = Lists.newArrayList();\n   }\n \n   @Override\n@@ -52,4 +54,10 @@ public abstract class TypeWriter /* ha ha */ extends Modifiable\n     methodWriters.add(methodWriter);\n     return methodWriter;\n   }\n+\n+  public ClassWriter addNestedClass(String name) {\n+    ClassWriter innerClassWriter = new ClassWriter(this.name.nestedClassNamed(name));\n+    nestedTypeWriters.add(innerClassWriter);\n+    return innerClassWriter;\n+  }\n }\n"
    },
    {
        "commit_hash": "cb4224b5de1e3a3c3e0795d7f6abd22ec0796772",
        "previous_commit_hash": "67bd94d79728595dbcbc4fae3f28c51075d788ba",
        "diff_stats": {
            "additions": 33,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,33 @@\n+/*\n+ * Copyright (C) 2014 Google, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package dagger.internal.codegen.writer;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+@RunWith(JUnit4.class)\n+public class JavaWriterTest {\n+  @Test public void referencedAndDeclaredSimpleName() {\n+    JavaWriter javaWriter = JavaWriter.inPackage(\"test\");\n+    ClassWriter topClass = javaWriter.addClass(\"Top\");\n+    topClass.addNestedClass(\"Middle\").addNestedClass(\"Bottom\");\n+    topClass.addField(ClassName.create(\"some.other.pkg\", \"Bottom\"), \"field\");\n+    assertThat(topClass.toString()).doesNotContain(\"import some.other.pkg.Bottom;\");\n+  }\n+}\n"
    },
    {
        "commit_hash": "76c7100587385ad91fb2b6ace8ece9ae645b574f",
        "previous_commit_hash": "cb4224b5de1e3a3c3e0795d7f6abd22ec0796772",
        "diff_stats": {
            "additions": 4,
            "deletions": 0
        },
        "diff_content": "@@ -27,6 +27,10 @@ public class MethodWriter extends Modifiable implements HasClassReferences, Writ\n     this.body = Optional.absent();\n   }\n \n+  public String name() {\n+    return name;\n+  }\n+\n   public VariableWriter addParameter(Class<?> type, String name) {\n     return addParameter(ClassName.fromClass(type), name);\n   }\n"
    },
    {
        "commit_hash": "7d8bc458b56dc14d7c5af165688fd736cb022069",
        "previous_commit_hash": "76c7100587385ad91fb2b6ace8ece9ae645b574f",
        "diff_stats": {
            "additions": 1,
            "deletions": 33
        },
        "diff_content": "@@ -5,60 +5,27 @@ import com.google.common.base.Joiner;\n import com.google.common.collect.FluentIterable;\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n-import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n import java.io.IOException;\n import java.util.Iterator;\n import java.util.List;\n-import java.util.Map;\n import java.util.Set;\n import javax.lang.model.element.Modifier;\n-import javax.lang.model.element.TypeElement;\n \n import static javax.lang.model.element.Modifier.PRIVATE;\n import static javax.lang.model.element.Modifier.PROTECTED;\n import static javax.lang.model.element.Modifier.PUBLIC;\n \n public final class ClassWriter extends TypeWriter {\n-  private final Map<String, FieldWriter> fieldWriters;\n   private final List<ConstructorWriter> constructorWriters;\n   private final List<TypeVariableName> typeVariables;\n \n   ClassWriter(ClassName className) {\n     super(className);\n-    this.fieldWriters = Maps.newLinkedHashMap();\n     this.constructorWriters = Lists.newArrayList();\n     this.typeVariables = Lists.newArrayList();\n   }\n \n-  public void addImplementedType(TypeName typeReference) {\n-    implementedTypes.add(typeReference);\n-  }\n-\n-  public void addImplementedType(TypeElement typeElement) {\n-    implementedTypes.add(ClassName.fromTypeElement(typeElement));\n-  }\n-\n-  public FieldWriter addField(Class<?> type, String name) {\n-    return addField(ClassName.fromClass(type), name);\n-  }\n-\n-  public FieldWriter addField(TypeElement type, String name) {\n-    return addField(ClassName.fromTypeElement(type), name);\n-  }\n-\n-  public FieldWriter addField(TypeName type, String name) {\n-    String candidateName = name;\n-    int differentiator = 1;\n-    while (fieldWriters.containsKey(candidateName)) {\n-      candidateName = name + differentiator;\n-      differentiator++;\n-    }\n-    FieldWriter fieldWriter = new FieldWriter(type, candidateName);\n-    fieldWriters.put(candidateName, fieldWriter);\n-    return fieldWriter;\n-  }\n-\n   public ConstructorWriter addConstructor() {\n     ConstructorWriter constructorWriter = new ConstructorWriter(name.simpleName());\n     constructorWriters.add(constructorWriter);\n@@ -130,6 +97,7 @@ public final class ClassWriter extends TypeWriter {\n \n   @Override\n   public Set<ClassName> referencedClasses() {\n+    @SuppressWarnings(\"unchecked\")\n     Iterable<? extends HasClassReferences> concat =\n         Iterables.concat(nestedTypeWriters, fieldWriters.values(), constructorWriters,\n             methodWriters, implementedTypes, supertype.asSet(), annotations);\n"
    },
    {
        "commit_hash": "7d8bc458b56dc14d7c5af165688fd736cb022069",
        "previous_commit_hash": "76c7100587385ad91fb2b6ace8ece9ae645b574f",
        "diff_stats": {
            "additions": 168,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,168 @@\n+package dagger.internal.codegen.writer;\n+\n+import com.google.common.base.Function;\n+import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.lang.model.element.Modifier;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static javax.lang.model.element.Modifier.PRIVATE;\n+import static javax.lang.model.element.Modifier.PROTECTED;\n+import static javax.lang.model.element.Modifier.PUBLIC;\n+\n+public class EnumWriter extends TypeWriter {\n+  private final Map<String, ConstantWriter> constantWriters = Maps.newLinkedHashMap();\n+  private final List<ConstructorWriter> constructorWriters = Lists.newArrayList();\n+\n+  EnumWriter(ClassName name) {\n+    super(name);\n+  }\n+\n+  public ConstantWriter addConstant(String name) {\n+    ConstantWriter constantWriter = new ConstantWriter(name);\n+    constantWriters.put(name, constantWriter);\n+    return constantWriter;\n+  }\n+\n+  public ConstructorWriter addConstructor() {\n+    ConstructorWriter constructorWriter = new ConstructorWriter(name.simpleName());\n+    constructorWriters.add(constructorWriter);\n+    return constructorWriter;\n+  }\n+\n+  @Override\n+  public Appendable write(Appendable appendable, Context context) throws IOException {\n+    context = context.createSubcontext(FluentIterable.from(nestedTypeWriters)\n+        .transform(new Function<TypeWriter, ClassName>() {\n+          @Override public ClassName apply(TypeWriter input) {\n+            return input.name;\n+          }\n+        })\n+        .toSet());\n+    writeAnnotations(appendable, context);\n+    writeModifiers(appendable).append(\"enum \").append(name.simpleName());\n+    Iterator<TypeName> implementedTypesIterator = implementedTypes.iterator();\n+    if (implementedTypesIterator.hasNext()) {\n+      appendable.append(\" implements \");\n+      implementedTypesIterator.next().write(appendable, context);\n+      while (implementedTypesIterator.hasNext()) {\n+        appendable.append(\", \");\n+        implementedTypesIterator.next().write(appendable, context);\n+      }\n+    }\n+    appendable.append(\" {\");\n+\n+    checkState(!constantWriters.isEmpty(), \"Cannot write an enum with no constants.\");\n+    appendable.append('\\n');\n+    ImmutableList<ConstantWriter> constantWriterList =\n+        ImmutableList.copyOf(constantWriters.values());\n+    for (ConstantWriter constantWriter :\n+        constantWriterList.subList(0, constantWriterList.size() - 1)) {\n+      constantWriter.write(appendable, context);\n+      appendable.append(\",\\n\");\n+    }\n+    constantWriterList.get(constantWriterList.size() - 1).write(appendable, context);\n+    appendable.append(\";\\n\");\n+\n+    if (!fieldWriters.isEmpty()) {\n+      appendable.append('\\n');\n+    }\n+    for (VariableWriter fieldWriter : fieldWriters.values()) {\n+      fieldWriter.write(new IndentingAppendable(appendable), context).append(\"\\n\");\n+    }\n+    for (ConstructorWriter constructorWriter : constructorWriters) {\n+      appendable.append('\\n');\n+      if (!isDefaultConstructor(constructorWriter)) {\n+        constructorWriter.write(new IndentingAppendable(appendable), context);\n+      }\n+    }\n+    for (MethodWriter methodWriter : methodWriters) {\n+      appendable.append('\\n');\n+      methodWriter.write(new IndentingAppendable(appendable), context);\n+    }\n+    for (TypeWriter nestedTypeWriter : nestedTypeWriters) {\n+      appendable.append('\\n');\n+      nestedTypeWriter.write(new IndentingAppendable(appendable), context);\n+    }\n+    appendable.append(\"}\\n\");\n+    return appendable;\n+  }\n+\n+  private static final Set<Modifier> VISIBILIY_MODIFIERS =\n+      Sets.immutableEnumSet(PUBLIC, PROTECTED, PRIVATE);\n+\n+  private boolean isDefaultConstructor(ConstructorWriter constructorWriter) {\n+    return Sets.intersection(VISIBILIY_MODIFIERS, modifiers)\n+        .equals(Sets.intersection(VISIBILIY_MODIFIERS, constructorWriter.modifiers))\n+        && constructorWriter.body().isEmpty();\n+  }\n+\n+  @Override\n+  public Set<ClassName> referencedClasses() {\n+    @SuppressWarnings(\"unchecked\")\n+    Iterable<? extends HasClassReferences> concat =\n+        Iterables.concat(nestedTypeWriters, constantWriters.values(), fieldWriters.values(),\n+            constructorWriters,\n+            methodWriters, implementedTypes, supertype.asSet(), annotations);\n+    return FluentIterable.from(concat)\n+        .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {\n+          @Override\n+          public Set<ClassName> apply(HasClassReferences input) {\n+            return input.referencedClasses();\n+          }\n+        })\n+        .toSet();\n+  }\n+\n+  public static final class ConstantWriter implements Writable, HasClassReferences {\n+    private final String name;\n+    private final List<Snippet> constructorSnippets;\n+\n+    private ConstantWriter(String name) {\n+      this.name = name;\n+      this.constructorSnippets = Lists.newArrayList();\n+    }\n+\n+    ConstantWriter addArgument(Snippet snippet) {\n+      constructorSnippets.add(snippet);\n+      return this;\n+    }\n+\n+    @Override\n+    public Appendable write(Appendable appendable, Context context) throws IOException {\n+      appendable.append(name);\n+      Iterator<Snippet> snippetIterator = constructorSnippets.iterator();\n+      if (snippetIterator.hasNext()) {\n+        appendable.append('(');\n+        snippetIterator.next().write(appendable, context);\n+        while (snippetIterator.hasNext()) {\n+          appendable.append(\", \");\n+          snippetIterator.next().write(appendable, context);\n+        }\n+        appendable.append(')');\n+      }\n+      return appendable;\n+    }\n+\n+    @Override\n+    public Set<ClassName> referencedClasses() {\n+      return FluentIterable.from(constructorSnippets)\n+          .transformAndConcat(new Function<Snippet, Set<ClassName>>() {\n+            @Override\n+            public Set<ClassName> apply(Snippet input) {\n+              return input.referencedClasses();\n+            }\n+          })\n+          .toSet();\n+    }\n+  }\n+}\n"
    },
    {
        "commit_hash": "7d8bc458b56dc14d7c5af165688fd736cb022069",
        "previous_commit_hash": "76c7100587385ad91fb2b6ace8ece9ae645b574f",
        "diff_stats": {
            "additions": 7,
            "deletions": 0
        },
        "diff_content": "@@ -69,6 +69,13 @@ public final class JavaWriter {\n     return classWriter;\n   }\n \n+  public EnumWriter addEnum(String simpleName) {\n+    checkNotNull(simpleName);\n+    EnumWriter writer = new EnumWriter(ClassName.create(simpleName, simpleName));\n+    typeWriters.add(writer);\n+    return writer;\n+  }\n+\n   public InterfaceWriter addInterface(String simpleName) {\n     InterfaceWriter writer = new InterfaceWriter(ClassName.create(packageName, simpleName));\n     typeWriters.add(writer);\n"
    },
    {
        "commit_hash": "7d8bc458b56dc14d7c5af165688fd736cb022069",
        "previous_commit_hash": "76c7100587385ad91fb2b6ace8ece9ae645b574f",
        "diff_stats": {
            "additions": 34,
            "deletions": 1
        },
        "diff_content": "@@ -2,7 +2,10 @@ package dagger.internal.codegen.writer;\n \n import com.google.common.base.Optional;\n import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n import java.util.List;\n+import java.util.Map;\n+import javax.lang.model.element.TypeElement;\n import javax.lang.model.type.TypeMirror;\n \n /**\n@@ -15,13 +18,15 @@ public abstract class TypeWriter /* ha ha */ extends Modifiable\n   final List<TypeName> implementedTypes;\n   final List<MethodWriter> methodWriters;\n   final List<TypeWriter> nestedTypeWriters;\n+  final Map<String, FieldWriter> fieldWriters;\n \n   TypeWriter(ClassName name) {\n     this.name = name;\n     this.supertype = Optional.absent();\n     this.implementedTypes = Lists.newArrayList();\n     this.methodWriters = Lists.newArrayList();\n-    nestedTypeWriters = Lists.newArrayList();\n+    this.nestedTypeWriters = Lists.newArrayList();\n+    this.fieldWriters = Maps.newLinkedHashMap();\n   }\n \n   @Override\n@@ -60,4 +65,32 @@ public abstract class TypeWriter /* ha ha */ extends Modifiable\n     nestedTypeWriters.add(innerClassWriter);\n     return innerClassWriter;\n   }\n+\n+  public void addImplementedType(TypeName typeReference) {\n+    implementedTypes.add(typeReference);\n+  }\n+\n+  public void addImplementedType(TypeElement typeElement) {\n+    implementedTypes.add(ClassName.fromTypeElement(typeElement));\n+  }\n+\n+  public FieldWriter addField(Class<?> type, String name) {\n+    return addField(ClassName.fromClass(type), name);\n+  }\n+\n+  public FieldWriter addField(TypeElement type, String name) {\n+    return addField(ClassName.fromTypeElement(type), name);\n+  }\n+\n+  public FieldWriter addField(TypeName type, String name) {\n+    String candidateName = name;\n+    int differentiator = 1;\n+    while (fieldWriters.containsKey(candidateName)) {\n+      candidateName = name + differentiator;\n+      differentiator++;\n+    }\n+    FieldWriter fieldWriter = new FieldWriter(type, candidateName);\n+    fieldWriters.put(candidateName, fieldWriter);\n+    return fieldWriter;\n+  }\n }\n"
    },
    {
        "commit_hash": "d256511ea5deec12b20fb3abd0b1cc0475c1c1a1",
        "previous_commit_hash": "7d8bc458b56dc14d7c5af165688fd736cb022069",
        "diff_stats": {
            "additions": 4,
            "deletions": 2
        },
        "diff_content": "@@ -3,13 +3,15 @@ package dagger.internal.codegen.writer;\n import java.io.IOException;\n import java.util.Set;\n \n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n public class VariableWriter extends Modifiable implements Writable, HasClassReferences {\n   private final TypeName type;\n   private final String name;\n \n   VariableWriter(TypeName type, String name) {\n-    this.type = type;\n-    this.name = name;\n+    this.type = checkNotNull(type);\n+    this.name = checkNotNull(name);\n   }\n \n   public TypeName type() {\n"
    },
    {
        "commit_hash": "b4a4db4798dc5105719e97c70e71d47bffd836dd",
        "previous_commit_hash": "d256511ea5deec12b20fb3abd0b1cc0475c1c1a1",
        "diff_stats": {
            "additions": 112,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright (C) 2014 Google, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package dagger.internal.codegen.writer;\n+\n+import dagger.internal.codegen.writer.ClassNameTest.OuterClass.InnerClass;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.testing.compile.CompilationRule;\n+import dagger.internal.codegen.writer.ClassName;\n+import java.util.Map;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.util.Elements;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import static com.google.common.truth.Truth.assert_;\n+import static org.junit.Assert.fail;\n+\n+@RunWith(JUnit4.class)\n+public class ClassNameTest {\n+  @Rule public CompilationRule compilationRule = new CompilationRule();\n+\n+  @Test public void bestGuessForString_simpleClass() {\n+    assert_().that(ClassName.bestGuessFromString(String.class.getName()))\n+        .isEqualTo(ClassName.create(\"java.lang\", \"String\"));\n+  }\n+\n+  static class OuterClass {\n+    static class InnerClass {}\n+  }\n+\n+  @Test public void bestGuessForString_nestedClass() {\n+    assert_().that(ClassName.bestGuessFromString(Map.Entry.class.getCanonicalName()))\n+        .isEqualTo(ClassName.create(\"java.util\", ImmutableList.of(\"Map\"), \"Entry\"));\n+    assert_().that(ClassName.bestGuessFromString(OuterClass.InnerClass.class.getCanonicalName()))\n+        .isEqualTo(\n+            ClassName.create(\"dagger.internal.codegen\",\n+                ImmutableList.of(\"ClassNameTest\", \"OuterClass\"), \"InnerClass\"));\n+  }\n+\n+  @Test public void bestGuessForString_defaultPackage() {\n+    assert_().that(ClassName.bestGuessFromString(\"SomeClass\"))\n+        .isEqualTo(ClassName.create(\"\", \"SomeClass\"));\n+    assert_().that(ClassName.bestGuessFromString(\"SomeClass.Nested\"))\n+        .isEqualTo(ClassName.create(\"\", ImmutableList.of(\"SomeClass\"), \"Nested\"));\n+    assert_().that(ClassName.bestGuessFromString(\"SomeClass.Nested.EvenMore\"))\n+        .isEqualTo(ClassName.create(\"\", ImmutableList.of(\"SomeClass\", \"Nested\"), \"EvenMore\"));\n+  }\n+\n+  @Test public void bestGuessForString_confusingInput() {\n+    try {\n+      ClassName.bestGuessFromString(\"com.test.$\");\n+      fail();\n+    } catch (IllegalArgumentException expected) {}\n+    try {\n+      ClassName.bestGuessFromString(\"com.test.LooksLikeAClass.pkg\");\n+      fail();\n+    } catch (IllegalArgumentException expected) {}\n+    try {\n+      ClassName.bestGuessFromString(\"!@#$gibberish%^&*\");\n+      fail();\n+    } catch (IllegalArgumentException expected) {}\n+  }\n+\n+  @Test public void classNameFromTypeElement() {\n+    Elements elements = compilationRule.getElements();\n+    TypeElement element = elements.getTypeElement(Object.class.getCanonicalName());\n+    assert_().that(ClassName.fromTypeElement(element).canonicalName())\n+        .isEqualTo(\"java.lang.Object\");\n+  }\n+\n+  @Test public void peerNamed_topLevelClass() {\n+    Elements elements = compilationRule.getElements();\n+    TypeElement element = elements.getTypeElement(ClassNameTest.class.getCanonicalName());\n+    ClassName className = ClassName.fromTypeElement(element);\n+    ClassName peerName = className.peerNamed(\"Foo\");\n+    assert_().that(peerName.canonicalName())\n+        .isEqualTo(\"dagger.internal.codegen.Foo\");\n+  }\n+\n+  @Test public void peerNamed_nestedClass() {\n+    Elements elements = compilationRule.getElements();\n+    TypeElement element = elements.getTypeElement(OuterClass.class.getCanonicalName());\n+    ClassName className = ClassName.fromTypeElement(element);\n+    ClassName peerName = className.peerNamed(\"Foo\");\n+    assert_().that(peerName.canonicalName())\n+        .isEqualTo(\"dagger.internal.codegen.ClassNameTest.Foo\");\n+  }\n+\n+  @Test public void peerNamed_deeplyNestedClass() {\n+    Elements elements = compilationRule.getElements();\n+    TypeElement element = elements.getTypeElement(InnerClass.class.getCanonicalName());\n+    ClassName className = ClassName.fromTypeElement(element);\n+    ClassName peerName = className.peerNamed(\"Foo\");\n+    assert_().that(peerName.canonicalName())\n+        .isEqualTo(\"dagger.internal.codegen.ClassNameTest.OuterClass.Foo\");\n+  }\n+}\n"
    },
    {
        "commit_hash": "c474b698e0cd17625e44741578ae73f894fcf219",
        "previous_commit_hash": "b4a4db4798dc5105719e97c70e71d47bffd836dd",
        "diff_stats": {
            "additions": 4,
            "deletions": 4
        },
        "diff_content": "@@ -48,7 +48,7 @@ public class ClassNameTest {\n         .isEqualTo(ClassName.create(\"java.util\", ImmutableList.of(\"Map\"), \"Entry\"));\n     assert_().that(ClassName.bestGuessFromString(OuterClass.InnerClass.class.getCanonicalName()))\n         .isEqualTo(\n-            ClassName.create(\"dagger.internal.codegen\",\n+            ClassName.create(\"dagger.internal.codegen.writer\",\n                 ImmutableList.of(\"ClassNameTest\", \"OuterClass\"), \"InnerClass\"));\n   }\n \n@@ -89,7 +89,7 @@ public class ClassNameTest {\n     ClassName className = ClassName.fromTypeElement(element);\n     ClassName peerName = className.peerNamed(\"Foo\");\n     assert_().that(peerName.canonicalName())\n-        .isEqualTo(\"dagger.internal.codegen.Foo\");\n+        .isEqualTo(\"dagger.internal.codegen.writer.Foo\");\n   }\n \n   @Test public void peerNamed_nestedClass() {\n@@ -98,7 +98,7 @@ public class ClassNameTest {\n     ClassName className = ClassName.fromTypeElement(element);\n     ClassName peerName = className.peerNamed(\"Foo\");\n     assert_().that(peerName.canonicalName())\n-        .isEqualTo(\"dagger.internal.codegen.ClassNameTest.Foo\");\n+        .isEqualTo(\"dagger.internal.codegen.writer.ClassNameTest.Foo\");\n   }\n \n   @Test public void peerNamed_deeplyNestedClass() {\n@@ -107,6 +107,6 @@ public class ClassNameTest {\n     ClassName className = ClassName.fromTypeElement(element);\n     ClassName peerName = className.peerNamed(\"Foo\");\n     assert_().that(peerName.canonicalName())\n-        .isEqualTo(\"dagger.internal.codegen.ClassNameTest.OuterClass.Foo\");\n+        .isEqualTo(\"dagger.internal.codegen.writer.ClassNameTest.OuterClass.Foo\");\n   }\n }\n"
    },
    {
        "commit_hash": "8a0fcc1f83c86369f70b600c2e34855176ca41d4",
        "previous_commit_hash": "5bcd82961ef990e45c51aa0e5cdf423c856d33f3",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -91,7 +91,7 @@\n     <module name=\"CovariantEquals\"/>\n     <module name=\"DoubleCheckedLocking\"/>\n     <module name=\"EmptyStatement\"/>\n-    <module name=\"EqualsAvoidNull\"/>\n+    <!--<module name=\"EqualsAvoidNull\"/>-->\n     <module name=\"EqualsHashCode\"/>\n     <!--module name=\"HiddenField\"/-->\n     <module name=\"IllegalInstantiation\"/>\n"
    },
    {
        "commit_hash": "8a0fcc1f83c86369f70b600c2e34855176ca41d4",
        "previous_commit_hash": "5bcd82961ef990e45c51aa0e5cdf423c856d33f3",
        "diff_stats": {
            "additions": 0,
            "deletions": 7
        },
        "diff_content": "@@ -1,7 +0,0 @@\n-package dagger.internal.codegen.writer;\n-\n-import java.util.Set;\n-\n-public interface HasClassReferences {\n-  Set<ClassName> referencedClasses();\n-}\n"
    },
    {
        "commit_hash": "8a0fcc1f83c86369f70b600c2e34855176ca41d4",
        "previous_commit_hash": "5bcd82961ef990e45c51aa0e5cdf423c856d33f3",
        "diff_stats": {
            "additions": 0,
            "deletions": 5
        },
        "diff_content": "@@ -1,5 +0,0 @@\n-package dagger.internal.codegen.writer;\n-\n-interface HasTypeName {\n-  TypeName name();\n-}\n"
    },
    {
        "commit_hash": "8a0fcc1f83c86369f70b600c2e34855176ca41d4",
        "previous_commit_hash": "5bcd82961ef990e45c51aa0e5cdf423c856d33f3",
        "diff_stats": {
            "additions": 0,
            "deletions": 240
        },
        "diff_content": "@@ -1,240 +0,0 @@\n-package dagger.internal.codegen.writer;\n-\n-import com.google.common.base.Function;\n-import com.google.common.base.Optional;\n-import com.google.common.collect.BiMap;\n-import com.google.common.collect.FluentIterable;\n-import com.google.common.collect.HashBiMap;\n-import com.google.common.collect.ImmutableSet;\n-import com.google.common.collect.ImmutableSortedSet;\n-import com.google.common.collect.Iterables;\n-import com.google.common.collect.Lists;\n-import com.google.common.collect.Ordering;\n-import com.google.common.collect.Queues;\n-import com.google.common.collect.Sets;\n-import com.google.common.io.Closer;\n-import dagger.internal.codegen.writer.Writable.Context;\n-import java.io.IOException;\n-import java.util.Deque;\n-import java.util.List;\n-import java.util.Set;\n-import javax.annotation.processing.Filer;\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.PackageElement;\n-import javax.tools.JavaFileObject;\n-\n-import static com.google.common.base.Preconditions.checkNotNull;\n-import static java.util.Collections.unmodifiableList;\n-\n-/**\n- * Writes a single compilation unit.\n- */\n-public final class JavaWriter {\n-  public static JavaWriter inPackage(String packageName) {\n-    return new JavaWriter(packageName);\n-  }\n-\n-  public static JavaWriter inPackage(Package enclosingPackage) {\n-    return new JavaWriter(enclosingPackage.getName());\n-  }\n-\n-  public static JavaWriter inPackage(PackageElement packageElement) {\n-    return new JavaWriter(packageElement.getQualifiedName().toString());\n-  }\n-\n-  private final String packageName;\n-  // TODO(gak): disallow multiple types in a file?\n-  private final List<TypeWriter> typeWriters;\n-  private final List<ClassName> explicitImports;\n-\n-  private JavaWriter(String packageName) {\n-    this.packageName = packageName;\n-    this.typeWriters = Lists.newArrayList();\n-    this.explicitImports = Lists.newArrayList();\n-  }\n-\n-  public List<TypeWriter> getTypeWriters() {\n-    return unmodifiableList(typeWriters);\n-  }\n-\n-  public JavaWriter addImport(Class<?> importedClass) {\n-    explicitImports.add(ClassName.fromClass(importedClass));\n-    return this;\n-  }\n-\n-  public ClassWriter addClass(String simpleName) {\n-    checkNotNull(simpleName);\n-    ClassWriter classWriter = new ClassWriter(ClassName.create(packageName, simpleName));\n-    typeWriters.add(classWriter);\n-    return classWriter;\n-  }\n-\n-  public EnumWriter addEnum(String simpleName) {\n-    checkNotNull(simpleName);\n-    EnumWriter writer = new EnumWriter(ClassName.create(simpleName, simpleName));\n-    typeWriters.add(writer);\n-    return writer;\n-  }\n-\n-  public InterfaceWriter addInterface(String simpleName) {\n-    InterfaceWriter writer = new InterfaceWriter(ClassName.create(packageName, simpleName));\n-    typeWriters.add(writer);\n-    return writer;\n-  }\n-\n-  public Appendable write(Appendable appendable) throws IOException {\n-    appendable.append(\"package \").append(packageName).append(';').append(\"\\n\\n\");\n-\n-    // write imports\n-    ImmutableSet<ClassName> classNames = FluentIterable.from(typeWriters)\n-        .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {\n-          @Override\n-          public Set<ClassName> apply(HasClassReferences input) {\n-            return input.referencedClasses();\n-          }\n-        })\n-        .toSet();\n-\n-    ImmutableSortedSet<ClassName> importCandidates = ImmutableSortedSet.<ClassName>naturalOrder()\n-        .addAll(explicitImports)\n-        .addAll(classNames)\n-        .build();\n-    ImmutableSet<ClassName> typeNames = FluentIterable.from(typeWriters)\n-        .transform(new Function<TypeWriter, ClassName>() {\n-          @Override public ClassName apply(TypeWriter input) {\n-            return input.name;\n-          }\n-        })\n-        .toSet();\n-\n-    ImmutableSet.Builder<String> declaredSimpleNamesBuilder = ImmutableSet.builder();\n-    Deque<TypeWriter> declaredTypes = Queues.newArrayDeque(typeWriters);\n-    while (!declaredTypes.isEmpty()) {\n-      TypeWriter currentType = declaredTypes.pop();\n-      declaredSimpleNamesBuilder.add(currentType.name().simpleName());\n-      declaredTypes.addAll(currentType.nestedTypeWriters);\n-    }\n-\n-    ImmutableSet<String> declaredSimpleNames = declaredSimpleNamesBuilder.build();\n-\n-    BiMap<String, ClassName> importedClassIndex = HashBiMap.create();\n-    for (ClassName className : importCandidates) {\n-      if (!(className.packageName().equals(packageName)\n-              && !className.enclosingClassName().isPresent())\n-          && !(className.packageName().equals(\"java.lang\")\n-              && className.enclosingSimpleNames().isEmpty())\n-          && !typeNames.contains(className.topLevelClassName())) {\n-        Optional<ClassName> importCandidate = Optional.of(className);\n-        while (importCandidate.isPresent()\n-            && (importedClassIndex.containsKey(importCandidate.get().simpleName())\n-                || declaredSimpleNames.contains(importCandidate.get().simpleName()))) {\n-          importCandidate = importCandidate.get().enclosingClassName();\n-        }\n-        if (importCandidate.isPresent()) {\n-          appendable.append(\"import \").append(importCandidate.get().canonicalName()).append(\";\\n\");\n-          importedClassIndex.put(importCandidate.get().simpleName(), importCandidate.get());\n-        }\n-      }\n-    }\n-\n-    appendable.append('\\n');\n-\n-    CompilationUnitContext context =\n-        new CompilationUnitContext(packageName, ImmutableSet.copyOf(importedClassIndex.values()));\n-\n-    // write types\n-    for (TypeWriter typeWriter : typeWriters) {\n-      typeWriter.write(appendable, context.createSubcontext(typeNames)).append('\\n');\n-    }\n-    return appendable;\n-  }\n-\n-  public void file(Filer filer, Iterable<? extends Element> originatingElements)\n-      throws IOException {\n-    file(filer, Iterables.getOnlyElement(typeWriters).name.canonicalName(), originatingElements);\n-  }\n-\n-  public void file(Filer filer, CharSequence name,  Iterable<? extends Element> originatingElements)\n-      throws IOException {\n-    JavaFileObject sourceFile = filer.createSourceFile(name,\n-        Iterables.toArray(originatingElements, Element.class));\n-    Closer closer = Closer.create();\n-    try {\n-      write(closer.register(sourceFile.openWriter()));\n-    } catch (Exception e) {\n-      try {\n-        sourceFile.delete();\n-      } catch (Exception e2) {\n-        // couldn't delete the file\n-      }\n-      throw closer.rethrow(e);\n-    } finally {\n-      closer.close();\n-    }\n-  }\n-\n-  @Override\n-  public String toString() {\n-    try {\n-      return write(new StringBuilder()).toString();\n-    } catch (IOException e) {\n-      throw new AssertionError();\n-    }\n-  }\n-\n-  static final class CompilationUnitContext implements Writable.Context {\n-    private final String packageName;\n-    private final ImmutableSortedSet<ClassName> visibleClasses;\n-\n-    CompilationUnitContext(String packageName, Set<ClassName> visibleClasses) {\n-      this.packageName = packageName;\n-      this.visibleClasses =\n-          ImmutableSortedSet.copyOf(Ordering.natural().reverse(), visibleClasses);\n-    }\n-\n-    @Override\n-    public Context createSubcontext(Set<ClassName> newTypes) {\n-      return new CompilationUnitContext(packageName, Sets.union(visibleClasses, newTypes));\n-    }\n-\n-    @Override\n-    public String sourceReferenceForClassName(ClassName className) {\n-      if (isImported(className)) {\n-        return className.simpleName();\n-      }\n-      Optional<ClassName> enclosingClassName = className.enclosingClassName();\n-      while (enclosingClassName.isPresent()) {\n-        if (isImported(enclosingClassName.get())) {\n-          return enclosingClassName.get().simpleName()\n-              + className.canonicalName()\n-                  .substring(enclosingClassName.get().canonicalName().length());\n-        }\n-        enclosingClassName = enclosingClassName.get().enclosingClassName();\n-      }\n-      return className.canonicalName();\n-    }\n-\n-    private boolean collidesWithVisibleClass(ClassName className) {\n-      return collidesWithVisibleClass(className.simpleName());\n-    }\n-\n-    private boolean collidesWithVisibleClass(String simpleName) {\n-      return FluentIterable.from(visibleClasses)\n-          .transform(new Function<ClassName, String>() {\n-            @Override public String apply(ClassName input) {\n-              return input.simpleName();\n-            }\n-          })\n-          .contains(simpleName);\n-    }\n-\n-    private boolean isImported(ClassName className) {\n-      return (packageName.equals(className.packageName())\n-              && !className.enclosingClassName().isPresent()\n-              && !collidesWithVisibleClass(className)) // need to account for scope & hiding\n-          || visibleClasses.contains(className)\n-          || (className.packageName().equals(\"java.lang\")\n-              && className.enclosingSimpleNames().isEmpty());\n-    }\n-  }\n-}\n"
    },
    {
        "commit_hash": "8a0fcc1f83c86369f70b600c2e34855176ca41d4",
        "previous_commit_hash": "5bcd82961ef990e45c51aa0e5cdf423c856d33f3",
        "diff_stats": {
            "additions": 0,
            "deletions": 24
        },
        "diff_content": "@@ -1,24 +0,0 @@\n-package dagger.internal.codegen.writer;\n-\n-import com.google.common.collect.ImmutableSet;\n-import java.io.IOException;\n-import java.util.Set;\n-\n-enum NullName implements TypeName {\n-  NULL;\n-\n-  @Override\n-  public Set<ClassName> referencedClasses() {\n-    return ImmutableSet.of();\n-  }\n-\n-  @Override\n-  public Appendable write(Appendable appendable, Context context) throws IOException {\n-    return appendable.append(\"null\");\n-  }\n-\n-  @Override\n-  public String toString() {\n-    return \"null\";\n-  }\n-}\n"
    },
    {
        "commit_hash": "8a0fcc1f83c86369f70b600c2e34855176ca41d4",
        "previous_commit_hash": "5bcd82961ef990e45c51aa0e5cdf423c856d33f3",
        "diff_stats": {
            "additions": 0,
            "deletions": 91
        },
        "diff_content": "@@ -1,91 +0,0 @@\n-// Copyright 2014 Square, Inc.\n-package dagger.internal.codegen.writer;\n-\n-import java.util.Formatter;\n-\n-/**\n- * Represents a string literal as found in Java source code.\n- */\n-public final class StringLiteral {\n-  /** Returns a new {@link StringLiteral} instance for the intended value of the literal. */\n-  public static StringLiteral forValue(String value) {\n-    return new StringLiteral(value, stringLiteral(value));\n-  }\n-\n-  /** Returns the string literal representing {@code data}, including wrapping quotes. */\n-  private static String stringLiteral(String value) {\n-    StringBuilder result = new StringBuilder();\n-    result.append('\"');\n-    for (int i = 0; i < value.length(); i++) {\n-      char c = value.charAt(i);\n-      switch (c) {\n-        case '\"':\n-          result.append(\"\\\\\\\"\");\n-          break;\n-        case '\\\\':\n-          result.append(\"\\\\\\\\\");\n-          break;\n-        case '\\b':\n-          result.append(\"\\\\b\");\n-          break;\n-        case '\\t':\n-          result.append(\"\\\\t\");\n-          break;\n-        case '\\n':\n-          result.append(\"\\\\n\");\n-          break;\n-        case '\\f':\n-          result.append(\"\\\\f\");\n-          break;\n-        case '\\r':\n-          result.append(\"\\\\r\");\n-          break;\n-        default:\n-          if (Character.isISOControl(c)) {\n-            new Formatter(result).format(\"\\\\u%04x\", (int) c);\n-          } else {\n-            result.append(c);\n-          }\n-      }\n-    }\n-    result.append('\"');\n-    return result.toString();\n-  }\n-\n-  private final String value;\n-  private final String literal;\n-\n-  private StringLiteral(String value, String literal) {\n-    this.value = value;\n-    this.literal = literal;\n-  }\n-\n-  public String value() {\n-    return value;\n-  }\n-\n-  public String literal() {\n-    return literal;\n-  }\n-\n-  @Override\n-  public String toString() {\n-    return literal;\n-  }\n-\n-  @Override\n-  public boolean equals(Object obj) {\n-    if (obj == this) {\n-      return true;\n-    } else if (obj instanceof StringLiteral) {\n-      return this.value.equals(((StringLiteral) obj).value);\n-    } else {\n-      return false;\n-    }\n-  }\n-\n-  @Override\n-  public int hashCode() {\n-    return value.hashCode();\n-  }\n-}\n"
    },
    {
        "commit_hash": "8a0fcc1f83c86369f70b600c2e34855176ca41d4",
        "previous_commit_hash": "5bcd82961ef990e45c51aa0e5cdf423c856d33f3",
        "diff_stats": {
            "additions": 0,
            "deletions": 4
        },
        "diff_content": "@@ -1,4 +0,0 @@\n-package dagger.internal.codegen.writer;\n-\n-public interface TypeName extends HasClassReferences, Writable {\n-}\n"
    },
    {
        "commit_hash": "8a0fcc1f83c86369f70b600c2e34855176ca41d4",
        "previous_commit_hash": "5bcd82961ef990e45c51aa0e5cdf423c856d33f3",
        "diff_stats": {
            "additions": 0,
            "deletions": 24
        },
        "diff_content": "@@ -1,24 +0,0 @@\n-package dagger.internal.codegen.writer;\n-\n-import com.google.common.collect.ImmutableSet;\n-import java.io.IOException;\n-import java.util.Set;\n-\n-public enum VoidName implements TypeName {\n-  VOID;\n-\n-  @Override\n-  public Set<ClassName> referencedClasses() {\n-    return ImmutableSet.of();\n-  }\n-\n-  @Override\n-  public String toString() {\n-    return \"void\";\n-  }\n-\n-  @Override\n-  public Appendable write(Appendable appendable, Context context) throws IOException {\n-    return appendable.append(\"void\");\n-  }\n-}\n"
    },
    {
        "commit_hash": "8a0fcc1f83c86369f70b600c2e34855176ca41d4",
        "previous_commit_hash": "5bcd82961ef990e45c51aa0e5cdf423c856d33f3",
        "diff_stats": {
            "additions": 0,
            "deletions": 13
        },
        "diff_content": "@@ -1,13 +0,0 @@\n-package dagger.internal.codegen.writer;\n-\n-import java.io.IOException;\n-import java.util.Set;\n-\n-interface Writable {\n-  interface Context {\n-    String sourceReferenceForClassName(ClassName className);\n-    Context createSubcontext(Set<ClassName> newTypes);\n-  }\n-\n-  Appendable write(Appendable appendable, Context context) throws IOException;\n-}\n"
    },
    {
        "commit_hash": "8a0fcc1f83c86369f70b600c2e34855176ca41d4",
        "previous_commit_hash": "5bcd82961ef990e45c51aa0e5cdf423c856d33f3",
        "diff_stats": {
            "additions": 0,
            "deletions": 33
        },
        "diff_content": "@@ -1,33 +0,0 @@\n-/*\n- * Copyright (C) 2014 Google, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package dagger.internal.codegen.writer;\n-\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.junit.runners.JUnit4;\n-\n-import static com.google.common.truth.Truth.assertThat;\n-\n-@RunWith(JUnit4.class)\n-public class JavaWriterTest {\n-  @Test public void referencedAndDeclaredSimpleName() {\n-    JavaWriter javaWriter = JavaWriter.inPackage(\"test\");\n-    ClassWriter topClass = javaWriter.addClass(\"Top\");\n-    topClass.addNestedClass(\"Middle\").addNestedClass(\"Bottom\");\n-    topClass.addField(ClassName.create(\"some.other.pkg\", \"Bottom\"), \"field\");\n-    assertThat(topClass.toString()).doesNotContain(\"import some.other.pkg.Bottom;\");\n-  }\n-}\n"
    },
    {
        "commit_hash": "8a0fcc1f83c86369f70b600c2e34855176ca41d4",
        "previous_commit_hash": "5bcd82961ef990e45c51aa0e5cdf423c856d33f3",
        "diff_stats": {
            "additions": 20,
            "deletions": 7
        },
        "diff_content": "@@ -22,7 +22,9 @@\n \n     <java.version>1.6</java.version>\n     <junit.version>4.10</junit.version>\n-    <fest.version>2.0M8</fest.version>\n+    <guava.version>18.0</guava.version>\n+    <truth.version>1.0-SNAPSHOT</truth.version>\n+    <compile-testing.version>1.0-SNAPSHOT</compile-testing.version>\n   </properties>\n \n   <scm>\n@@ -51,15 +53,26 @@\n \n   <dependencies>\n     <dependency>\n-      <groupId>junit</groupId>\n-      <artifactId>junit</artifactId>\n-      <version>${junit.version}</version>\n+      <groupId>com.google.guava</groupId>\n+      <artifactId>guava</artifactId>\n+      <version>${guava.version}</version>\n+    </dependency>\n+    <dependency>\n+      <groupId>com.google.truth</groupId>\n+      <artifactId>truth</artifactId>\n+      <version>${truth.version}</version>\n       <scope>test</scope>\n     </dependency>\n     <dependency>\n-      <groupId>org.easytesting</groupId>\n-      <artifactId>fest-assert-core</artifactId>\n-      <version>${fest.version}</version>\n+      <groupId>com.google.testing.compile</groupId>\n+      <artifactId>compile-testing</artifactId>\n+      <version>${compile-testing.version}</version>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>junit</groupId>\n+      <artifactId>junit</artifactId>\n+      <version>${junit.version}</version>\n       <scope>test</scope>\n     </dependency>\n   </dependencies>\n"
    },
    {
        "commit_hash": "8a0fcc1f83c86369f70b600c2e34855176ca41d4",
        "previous_commit_hash": "5bcd82961ef990e45c51aa0e5cdf423c856d33f3",
        "diff_stats": {
            "additions": 18,
            "deletions": 3
        },
        "diff_content": "@@ -1,4 +1,19 @@\n-package dagger.internal.codegen.writer;\n+/*\n+ * Copyright (C) 2014 Google, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter;\n \n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Iterables;\n@@ -8,9 +23,9 @@ import java.util.Map.Entry;\n import java.util.Set;\n import java.util.SortedMap;\n \n-import static dagger.internal.codegen.writer.Writables.toStringWritable;\n+import static com.squareup.javawriter.Writables.toStringWritable;\n \n-public class AnnotationWriter implements Writable, HasClassReferences {\n+public final class AnnotationWriter implements Writable, HasClassReferences {\n   private final ClassName annotationName;\n   private final SortedMap<String, Writable> memberMap = Maps.newTreeMap();\n \n"
    },
    {
        "commit_hash": "8a0fcc1f83c86369f70b600c2e34855176ca41d4",
        "previous_commit_hash": "5bcd82961ef990e45c51aa0e5cdf423c856d33f3",
        "diff_stats": {
            "additions": 16,
            "deletions": 1
        },
        "diff_content": "@@ -1,4 +1,19 @@\n-package dagger.internal.codegen.writer;\n+/*\n+ * Copyright (C) 2014 Google, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter;\n \n import java.io.IOException;\n import java.util.Set;\n"
    },
    {
        "commit_hash": "8a0fcc1f83c86369f70b600c2e34855176ca41d4",
        "previous_commit_hash": "5bcd82961ef990e45c51aa0e5cdf423c856d33f3",
        "diff_stats": {
            "additions": 16,
            "deletions": 1
        },
        "diff_content": "@@ -1,4 +1,19 @@\n-package dagger.internal.codegen.writer;\n+/*\n+ * Copyright (C) 2014 Google, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter;\n \n import com.google.common.base.Function;\n import com.google.common.collect.FluentIterable;\n"
    },
    {
        "commit_hash": "8a0fcc1f83c86369f70b600c2e34855176ca41d4",
        "previous_commit_hash": "5bcd82961ef990e45c51aa0e5cdf423c856d33f3",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -13,7 +13,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package dagger.internal.codegen.writer;\n+package com.squareup.javawriter;\n \n import com.google.common.base.Ascii;\n import com.google.common.base.Joiner;\n@@ -50,7 +50,7 @@ import static javax.lang.model.element.NestingKind.TOP_LEVEL;\n public final class ClassName implements TypeName, Comparable<ClassName> {\n   private String fullyQualifiedName = null;\n   private final String packageName;\n-  /* From top to bottom.  E.g.: this field will contian [\"A\", \"B\"] for pgk.A.B.C */\n+  /* From top to bottom.  E.g.: this field will contain [\"A\", \"B\"] for pgk.A.B.C */\n   private final ImmutableList<String> enclosingSimpleNames;\n   private final String simpleName;\n \n"
    },
    {
        "commit_hash": "8a0fcc1f83c86369f70b600c2e34855176ca41d4",
        "previous_commit_hash": "5bcd82961ef990e45c51aa0e5cdf423c856d33f3",
        "diff_stats": {
            "additions": 16,
            "deletions": 1
        },
        "diff_content": "@@ -1,4 +1,19 @@\n-package dagger.internal.codegen.writer;\n+/*\n+ * Copyright (C) 2014 Google, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter;\n \n import com.google.common.base.Function;\n import com.google.common.base.Joiner;\n"
    },
    {
        "commit_hash": "8a0fcc1f83c86369f70b600c2e34855176ca41d4",
        "previous_commit_hash": "5bcd82961ef990e45c51aa0e5cdf423c856d33f3",
        "diff_stats": {
            "additions": 17,
            "deletions": 2
        },
        "diff_content": "@@ -1,4 +1,19 @@\n-package dagger.internal.codegen.writer;\n+/*\n+ * Copyright (C) 2014 Google, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter;\n \n import com.google.common.base.Function;\n import com.google.common.collect.FluentIterable;\n@@ -13,7 +28,7 @@ import javax.lang.model.element.TypeElement;\n \n import static com.google.common.base.Preconditions.checkArgument;\n \n-public class ConstructorWriter extends Modifiable implements Writable, HasClassReferences {\n+public final class ConstructorWriter extends Modifiable implements Writable, HasClassReferences {\n   private final String name;\n   private final Map<String, VariableWriter> parameterWriters;\n   private final BlockWriter blockWriter;\n"
    },
    {
        "commit_hash": "8a0fcc1f83c86369f70b600c2e34855176ca41d4",
        "previous_commit_hash": "5bcd82961ef990e45c51aa0e5cdf423c856d33f3",
        "diff_stats": {
            "additions": 19,
            "deletions": 4
        },
        "diff_content": "@@ -1,4 +1,19 @@\n-package dagger.internal.codegen.writer;\n+/*\n+ * Copyright (C) 2014 Google, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter;\n \n import com.google.common.base.Function;\n import com.google.common.collect.FluentIterable;\n@@ -19,7 +34,7 @@ import static javax.lang.model.element.Modifier.PRIVATE;\n import static javax.lang.model.element.Modifier.PROTECTED;\n import static javax.lang.model.element.Modifier.PUBLIC;\n \n-public class EnumWriter extends TypeWriter {\n+public final class EnumWriter extends TypeWriter {\n   private final Map<String, ConstantWriter> constantWriters = Maps.newLinkedHashMap();\n   private final List<ConstructorWriter> constructorWriters = Lists.newArrayList();\n \n@@ -65,8 +80,8 @@ public class EnumWriter extends TypeWriter {\n     appendable.append('\\n');\n     ImmutableList<ConstantWriter> constantWriterList =\n         ImmutableList.copyOf(constantWriters.values());\n-    for (ConstantWriter constantWriter :\n-        constantWriterList.subList(0, constantWriterList.size() - 1)) {\n+    for (ConstantWriter constantWriter\n+        : constantWriterList.subList(0, constantWriterList.size() - 1)) {\n       constantWriter.write(appendable, context);\n       appendable.append(\",\\n\");\n     }\n"
    },
    {
        "commit_hash": "8a0fcc1f83c86369f70b600c2e34855176ca41d4",
        "previous_commit_hash": "5bcd82961ef990e45c51aa0e5cdf423c856d33f3",
        "diff_stats": {
            "additions": 17,
            "deletions": 2
        },
        "diff_content": "@@ -1,4 +1,19 @@\n-package dagger.internal.codegen.writer;\n+/*\n+ * Copyright (C) 2014 Google, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter;\n \n import com.google.common.base.Function;\n import com.google.common.base.Optional;\n@@ -8,7 +23,7 @@ import com.google.common.collect.Iterables;\n import java.io.IOException;\n import java.util.Set;\n \n-public class FieldWriter extends VariableWriter {\n+public final class FieldWriter extends VariableWriter {\n   private Optional<Snippet> initializer;\n \n   FieldWriter(TypeName type, String name) {\n"
    },
    {
        "commit_hash": "8a0fcc1f83c86369f70b600c2e34855176ca41d4",
        "previous_commit_hash": "5bcd82961ef990e45c51aa0e5cdf423c856d33f3",
        "diff_stats": {
            "additions": 22,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,22 @@\n+/*\n+ * Copyright (C) 2014 Google, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter;\n+\n+import java.util.Set;\n+\n+public interface HasClassReferences {\n+  Set<ClassName> referencedClasses();\n+}\n"
    },
    {
        "commit_hash": "8a0fcc1f83c86369f70b600c2e34855176ca41d4",
        "previous_commit_hash": "5bcd82961ef990e45c51aa0e5cdf423c856d33f3",
        "diff_stats": {
            "additions": 20,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,20 @@\n+/*\n+ * Copyright (C) 2014 Google, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter;\n+\n+interface HasTypeName {\n+  TypeName name();\n+}\n"
    },
    {
        "commit_hash": "8a0fcc1f83c86369f70b600c2e34855176ca41d4",
        "previous_commit_hash": "5bcd82961ef990e45c51aa0e5cdf423c856d33f3",
        "diff_stats": {
            "additions": 16,
            "deletions": 1
        },
        "diff_content": "@@ -1,4 +1,19 @@\n-package dagger.internal.codegen.writer;\n+/*\n+ * Copyright (C) 2014 Google, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter;\n \n import com.google.common.collect.AbstractIterator;\n import java.io.IOException;\n"
    },
    {
        "commit_hash": "8a0fcc1f83c86369f70b600c2e34855176ca41d4",
        "previous_commit_hash": "5bcd82961ef990e45c51aa0e5cdf423c856d33f3",
        "diff_stats": {
            "additions": 17,
            "deletions": 2
        },
        "diff_content": "@@ -1,4 +1,19 @@\n-package dagger.internal.codegen.writer;\n+/*\n+ * Copyright (C) 2014 Google, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter;\n \n import com.google.common.base.Function;\n import com.google.common.base.Joiner;\n@@ -10,7 +25,7 @@ import java.util.Iterator;\n import java.util.List;\n import java.util.Set;\n \n-public class InterfaceWriter extends TypeWriter {\n+public final class InterfaceWriter extends TypeWriter {\n   private final List<TypeVariableName> typeVariables;\n   InterfaceWriter(ClassName name) {\n     super(name);\n"
    },
    {
        "commit_hash": "8a0fcc1f83c86369f70b600c2e34855176ca41d4",
        "previous_commit_hash": "5bcd82961ef990e45c51aa0e5cdf423c856d33f3",
        "diff_stats": {
            "additions": 189,
            "deletions": 777
        },
        "diff_content": "@@ -1,843 +1,255 @@\n-// Copyright 2013 Square, Inc.\n+/*\n+ * Copyright (C) 2014 Google, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n package com.squareup.javawriter;\n \n-import java.io.Closeable;\n+import com.google.common.base.Function;\n+import com.google.common.base.Optional;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.ImmutableSortedSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Ordering;\n+import com.google.common.collect.Queues;\n+import com.google.common.collect.Sets;\n+import com.google.common.io.Closer;\n+import com.squareup.javawriter.Writable.Context;\n import java.io.IOException;\n-import java.io.Writer;\n-import java.lang.annotation.Annotation;\n-import java.util.ArrayDeque;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.Collections;\n import java.util.Deque;\n-import java.util.EnumSet;\n-import java.util.Iterator;\n-import java.util.LinkedHashMap;\n import java.util.List;\n-import java.util.Map;\n-import java.util.Map.Entry;\n import java.util.Set;\n-import java.util.TreeSet;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-import javax.lang.model.element.Modifier;\n+import javax.annotation.processing.Filer;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.PackageElement;\n+import javax.tools.JavaFileObject;\n \n-import static javax.lang.model.element.Modifier.ABSTRACT;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static java.util.Collections.unmodifiableList;\n \n-/** A utility class which aids in generating Java source files. */\n-public class JavaWriter implements Closeable {\n-  private static final Pattern TYPE_TRAILER = Pattern.compile(\"(.*?)(\\\\.\\\\.\\\\.|(?:\\\\[\\\\])+)$\");\n-  private static final Pattern TYPE_PATTERN = Pattern.compile(\"(?:[\\\\w$]+\\\\.)*([\\\\w\\\\.*$]+)\");\n-  private static final int MAX_SINGLE_LINE_ATTRIBUTES = 3;\n-  private static final String INDENT = \"  \";\n-\n-  /** Map fully qualified type names to their short names. */\n-  private final Map<String, String> importedTypes = new LinkedHashMap<String, String>();\n-\n-  private String packagePrefix;\n-  private final Deque<Scope> scopes = new ArrayDeque<Scope>();\n-  private final Deque<String> types = new ArrayDeque<String>();\n-  private final Writer out;\n-  private boolean isCompressingTypes = true;\n-  private String indent = INDENT;\n-\n-  /**\n-   * @param out the stream to which Java source will be written. This should be a buffered stream.\n-   */\n-  public JavaWriter(Writer out) {\n-    this.out = out;\n-  }\n-\n-  public void setCompressingTypes(boolean isCompressingTypes) {\n-    this.isCompressingTypes = isCompressingTypes;\n-  }\n-\n-  public boolean isCompressingTypes() {\n-    return isCompressingTypes;\n+/**\n+ * Writes a single compilation unit.\n+ */\n+public final class JavaWriter {\n+  public static JavaWriter inPackage(String packageName) {\n+    return new JavaWriter(packageName);\n   }\n \n-  public void setIndent(String indent) {\n-    this.indent = indent;\n+  public static JavaWriter inPackage(Package enclosingPackage) {\n+    return new JavaWriter(enclosingPackage.getName());\n   }\n \n-  public String getIndent() {\n-    return indent;\n+  public static JavaWriter inPackage(PackageElement packageElement) {\n+    return new JavaWriter(packageElement.getQualifiedName().toString());\n   }\n \n-  /** Emit a package declaration and empty line. */\n-  public JavaWriter emitPackage(String packageName) throws IOException {\n-    if (this.packagePrefix != null) {\n-      throw new IllegalStateException();\n-    }\n-    if (packageName.isEmpty()) {\n-      this.packagePrefix = \"\";\n-    } else {\n-      out.write(\"package \");\n-      out.write(packageName);\n-      out.write(\";\\n\\n\");\n-      this.packagePrefix = packageName + \".\";\n-    }\n-    return this;\n-  }\n+  private final String packageName;\n+  // TODO(gak): disallow multiple types in a file?\n+  private final List<TypeWriter> typeWriters;\n+  private final List<ClassName> explicitImports;\n \n-  /**\n-   * Emit an import for each {@code type} provided. For the duration of the file, all references to\n-   * these classes will be automatically shortened.\n-   */\n-  public JavaWriter emitImports(String... types) throws IOException {\n-    return emitImports(Arrays.asList(types));\n+  private JavaWriter(String packageName) {\n+    this.packageName = packageName;\n+    this.typeWriters = Lists.newArrayList();\n+    this.explicitImports = Lists.newArrayList();\n   }\n \n-  /**\n-   * Emit an import for each {@code type} provided. For the duration of the file, all references to\n-   * these classes will be automatically shortened.\n-   */\n-  public JavaWriter emitImports(Class<?>... types) throws IOException {\n-    List<String> classNames = new ArrayList<String>(types.length);\n-    for (Class<?> classToImport : types) {\n-      classNames.add(classToImport.getCanonicalName());\n-    }\n-    return emitImports(classNames);\n+  public List<TypeWriter> getTypeWriters() {\n+    return unmodifiableList(typeWriters);\n   }\n \n-  /**\n-   * Emit an import for each {@code type} in the provided {@code Collection}. For the duration of\n-   * the file, all references to these classes will be automatically shortened.\n-   */\n-  public JavaWriter emitImports(Collection<String> types) throws IOException {\n-    for (String type : new TreeSet<String>(types)) {\n-      Matcher matcher = TYPE_PATTERN.matcher(type);\n-      if (!matcher.matches()) {\n-        throw new IllegalArgumentException(type);\n-      }\n-      if (importedTypes.put(type, matcher.group(1)) != null) {\n-        throw new IllegalArgumentException(type);\n-      }\n-      out.write(\"import \");\n-      out.write(type);\n-      out.write(\";\\n\");\n-    }\n+  public JavaWriter addImport(Class<?> importedClass) {\n+    explicitImports.add(ClassName.fromClass(importedClass));\n     return this;\n   }\n \n-  /**\n-   * Emit a static import for each {@code type} provided. For the duration of the file,\n-   * all references to these classes will be automatically shortened.\n-   */\n-  public JavaWriter emitStaticImports(String... types) throws IOException {\n-    return emitStaticImports(Arrays.asList(types));\n+  public ClassWriter addClass(String simpleName) {\n+    checkNotNull(simpleName);\n+    ClassWriter classWriter = new ClassWriter(ClassName.create(packageName, simpleName));\n+    typeWriters.add(classWriter);\n+    return classWriter;\n   }\n \n-  /**\n-   * Emit a static import for each {@code type} in the provided {@code Collection}. For the\n-   * duration of the file, all references to these classes will be automatically shortened.\n-   */\n-  public JavaWriter emitStaticImports(Collection<String> types) throws IOException {\n-    for (String type : new TreeSet<String>(types)) {\n-      Matcher matcher = TYPE_PATTERN.matcher(type);\n-      if (!matcher.matches()) {\n-        throw new IllegalArgumentException(type);\n-      }\n-      if (importedTypes.put(type, matcher.group(1)) != null) {\n-        throw new IllegalArgumentException(type);\n-      }\n-      out.write(\"import static \");\n-      out.write(type);\n-      out.write(\";\\n\");\n-    }\n-    return this;\n+  public EnumWriter addEnum(String simpleName) {\n+    checkNotNull(simpleName);\n+    EnumWriter writer = new EnumWriter(ClassName.create(simpleName, simpleName));\n+    typeWriters.add(writer);\n+    return writer;\n   }\n \n-  /**\n-   * Emits a name like {@code java.lang.String} or {@code java.util.List<java.lang.String>},\n-   * compressing it with imports if possible. Type compression will only be enabled if\n-   * {@link #isCompressingTypes} is true.\n-   */\n-  private JavaWriter emitCompressedType(String type) throws IOException {\n-    if (isCompressingTypes) {\n-      out.write(compressType(type));\n-    } else {\n-      out.write(type);\n-    }\n-    return this;\n+  public InterfaceWriter addInterface(String simpleName) {\n+    InterfaceWriter writer = new InterfaceWriter(ClassName.create(packageName, simpleName));\n+    typeWriters.add(writer);\n+    return writer;\n   }\n \n-  /** Try to compress a fully-qualified class name to only the class name. */\n-  public String compressType(String type) {\n-    Matcher trailer = TYPE_TRAILER.matcher(type);\n-    if (trailer.matches()) {\n-      type = trailer.group(1);\n-    }\n+  public Appendable write(Appendable appendable) throws IOException {\n+    appendable.append(\"package \").append(packageName).append(';').append(\"\\n\\n\");\n \n-    StringBuilder sb = new StringBuilder();\n-    if (this.packagePrefix == null) {\n-      throw new IllegalStateException();\n-    }\n-\n-    Matcher m = TYPE_PATTERN.matcher(type);\n-    int pos = 0;\n-    while (true) {\n-      boolean found = m.find(pos);\n-\n-      // Copy non-matching characters like \"<\".\n-      int typeStart = found ? m.start() : type.length();\n-      sb.append(type, pos, typeStart);\n-\n-      if (!found) {\n-        break;\n-      }\n-\n-      // Copy a single class name, shortening it if possible.\n-      String name = m.group(0);\n-      String imported = importedTypes.get(name);\n-      if (imported != null) {\n-        sb.append(imported);\n-      } else if (isClassInPackage(name, packagePrefix)) {\n-        String compressed = name.substring(packagePrefix.length());\n-        if (isAmbiguous(compressed)) {\n-          sb.append(name);\n-        } else {\n-          sb.append(compressed);\n+    // write imports\n+    ImmutableSet<ClassName> classNames = FluentIterable.from(typeWriters)\n+        .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {\n+          @Override\n+          public Set<ClassName> apply(HasClassReferences input) {\n+            return input.referencedClasses();\n+          }\n+        })\n+        .toSet();\n+\n+    ImmutableSortedSet<ClassName> importCandidates = ImmutableSortedSet.<ClassName>naturalOrder()\n+        .addAll(explicitImports)\n+        .addAll(classNames)\n+        .build();\n+    ImmutableSet<ClassName> typeNames = FluentIterable.from(typeWriters)\n+        .transform(new Function<TypeWriter, ClassName>() {\n+          @Override public ClassName apply(TypeWriter input) {\n+            return input.name;\n+          }\n+        })\n+        .toSet();\n+\n+    ImmutableSet.Builder<String> declaredSimpleNamesBuilder = ImmutableSet.builder();\n+    Deque<TypeWriter> declaredTypes = Queues.newArrayDeque(typeWriters);\n+    while (!declaredTypes.isEmpty()) {\n+      TypeWriter currentType = declaredTypes.pop();\n+      declaredSimpleNamesBuilder.add(currentType.name().simpleName());\n+      declaredTypes.addAll(currentType.nestedTypeWriters);\n+    }\n+\n+    ImmutableSet<String> declaredSimpleNames = declaredSimpleNamesBuilder.build();\n+\n+    BiMap<String, ClassName> importedClassIndex = HashBiMap.create();\n+    for (ClassName className : importCandidates) {\n+      if (!(className.packageName().equals(packageName)\n+              && !className.enclosingClassName().isPresent())\n+          && !(className.packageName().equals(\"java.lang\")\n+              && className.enclosingSimpleNames().isEmpty())\n+          && !typeNames.contains(className.topLevelClassName())) {\n+        Optional<ClassName> importCandidate = Optional.of(className);\n+        while (importCandidate.isPresent()\n+            && (importedClassIndex.containsKey(importCandidate.get().simpleName())\n+                || declaredSimpleNames.contains(importCandidate.get().simpleName()))) {\n+          importCandidate = importCandidate.get().enclosingClassName();\n         }\n-      } else if (isClassInPackage(name, \"java.lang.\")) {\n-        sb.append(name.substring(\"java.lang.\".length()));\n-      } else {\n-        sb.append(name);\n-      }\n-      pos = m.end();\n-    }\n-\n-    if (trailer.matches()) {\n-      sb.append(trailer.group(2));\n-    }\n-    return sb.toString();\n-  }\n-\n-  private static boolean isClassInPackage(String name, String packagePrefix) {\n-    if (name.startsWith(packagePrefix)) {\n-      if (name.indexOf('.', packagePrefix.length()) == -1) {\n-        return true;\n-      }\n-      // check to see if the part after the package looks like a class\n-      if (Character.isUpperCase(name.charAt(packagePrefix.length()))) {\n-        return true;\n-      }\n-    }\n-    return false;\n-  }\n-\n-  /**\n-   * Returns true if the imports contain a class with same simple name as {@code compressed}.\n-   *\n-   * @param compressed simple name of the type\n-   */\n-  private boolean isAmbiguous(String compressed) {\n-    return importedTypes.values().contains(compressed);\n-  }\n-\n-  /**\n-   * Emits an initializer declaration.\n-   *\n-   * @param isStatic true if it should be an static initializer, false for an instance initializer.\n-   */\n-  public JavaWriter beginInitializer(boolean isStatic) throws IOException {\n-    indent();\n-    if (isStatic) {\n-      out.write(\"static\");\n-      out.write(\" {\\n\");\n-    } else {\n-      out.write(\"{\\n\");\n-    }\n-    scopes.push(Scope.INITIALIZER);\n-    return this;\n-  }\n-\n-  /** Ends the current initializer declaration. */\n-  public JavaWriter endInitializer() throws IOException {\n-    popScope(Scope.INITIALIZER);\n-    indent();\n-    out.write(\"}\\n\");\n-    return this;\n-  }\n-\n- /**\n-  * Emits a type declaration.\n-  *\n-  * @param kind such as \"class\", \"interface\" or \"enum\".\n-  */\n-  public JavaWriter beginType(String type, String kind) throws IOException {\n-    return beginType(type, kind, EnumSet.noneOf(Modifier.class), null);\n-  }\n-\n-  /**\n-   * Emits a type declaration.\n-   *\n-   * @param kind such as \"class\", \"interface\" or \"enum\".\n-   */\n-  public JavaWriter beginType(String type, String kind, Set<Modifier> modifiers)\n-      throws IOException {\n-    return beginType(type, kind, modifiers, null);\n-  }\n-\n-  /**\n-   * Emits a type declaration.\n-   *\n-   * @param kind such as \"class\", \"interface\" or \"enum\".\n-   * @param extendsType the class to extend, or null for no extends clause.\n-   */\n-  public JavaWriter beginType(String type, String kind, Set<Modifier> modifiers, String extendsType,\n-      String... implementsTypes) throws IOException {\n-    indent();\n-    emitModifiers(modifiers);\n-    out.write(kind);\n-    out.write(\" \");\n-    emitCompressedType(type);\n-    if (extendsType != null) {\n-      out.write(\" extends \");\n-      emitCompressedType(extendsType);\n-    }\n-    if (implementsTypes.length > 0) {\n-      out.write(\"\\n\");\n-      indent();\n-      out.write(\"    implements \");\n-      for (int i = 0; i < implementsTypes.length; i++) {\n-        if (i != 0) {\n-          out.write(\", \");\n+        if (importCandidate.isPresent()) {\n+          appendable.append(\"import \").append(importCandidate.get().canonicalName()).append(\";\\n\");\n+          importedClassIndex.put(importCandidate.get().simpleName(), importCandidate.get());\n         }\n-        emitCompressedType(implementsTypes[i]);\n       }\n     }\n-    out.write(\" {\\n\");\n-    scopes.push(\"interface\".equals(kind) ? Scope.INTERFACE_DECLARATION : Scope.TYPE_DECLARATION);\n-    types.push(type);\n-    return this;\n-  }\n-\n-  /** Completes the current type declaration. */\n-  public JavaWriter endType() throws IOException {\n-    popScope(Scope.TYPE_DECLARATION, Scope.INTERFACE_DECLARATION);\n-    types.pop();\n-    indent();\n-    out.write(\"}\\n\");\n-    return this;\n-  }\n-\n-  /** Emits a field declaration. */\n-  public JavaWriter emitField(String type, String name) throws IOException {\n-    return emitField(type, name, EnumSet.noneOf(Modifier.class), null);\n-  }\n-\n-  /** Emits a field declaration. */\n-  public JavaWriter emitField(String type, String name, Set<Modifier> modifiers)\n-      throws IOException {\n-    return emitField(type, name, modifiers, null);\n-  }\n-\n-  /** Emits a field declaration. */\n-  public JavaWriter emitField(String type, String name, Set<Modifier> modifiers,\n-      String initialValue) throws IOException {\n-    indent();\n-    emitModifiers(modifiers);\n-    emitCompressedType(type);\n-    out.write(\" \");\n-    out.write(name);\n \n-    if (initialValue != null) {\n-      out.write(\" =\");\n-      if (!initialValue.startsWith(\"\\n\")) {\n-        out.write(\" \");\n-      }\n+    appendable.append('\\n');\n \n-      String[] lines = initialValue.split(\"\\n\", -1);\n-      out.write(lines[0]);\n-      for (int i = 1; i < lines.length; i++) {\n-        out.write(\"\\n\");\n-        hangingIndent();\n-        out.write(lines[i]);\n-      }\n-    }\n-    out.write(\";\\n\");\n-    return this;\n-  }\n+    CompilationUnitContext context =\n+        new CompilationUnitContext(packageName, ImmutableSet.copyOf(importedClassIndex.values()));\n \n-  /**\n-   * Emit a method declaration.\n-   *\n-   * <p>A {@code null} return type may be used to indicate a constructor, but\n-   * {@link #beginConstructor(Set, String...)} should be preferred. This behavior may be removed in\n-   * a future release.\n-   *\n-   * @param returnType the method's return type, or null for constructors\n-   * @param name the method name, or the fully qualified class name for constructors.\n-   * @param modifiers the set of modifiers to be applied to the method\n-   * @param parameters alternating parameter types and names.\n-   */\n-  public JavaWriter beginMethod(String returnType, String name, Set<Modifier> modifiers,\n-      String... parameters) throws IOException {\n-    return beginMethod(returnType, name, modifiers, Arrays.asList(parameters), null);\n-  }\n-\n-  /**\n-   * Emit a method declaration.\n-   *\n-   * <p>A {@code null} return type may be used to indicate a constructor, but\n-   * {@link #beginConstructor(Set, List, List)} should be preferred. This behavior may be removed in\n-   * a future release.\n-   *\n-   * @param returnType the method's return type, or null for constructors.\n-   * @param name the method name, or the fully qualified class name for constructors.\n-   * @param modifiers the set of modifiers to be applied to the method\n-   * @param parameters alternating parameter types and names.\n-   * @param throwsTypes the classes to throw, or null for no throws clause.\n-   */\n-  public JavaWriter beginMethod(String returnType, String name, Set<Modifier> modifiers,\n-      List<String> parameters, List<String> throwsTypes) throws IOException {\n-    indent();\n-    emitModifiers(modifiers);\n-    if (returnType != null) {\n-      emitCompressedType(returnType);\n-      out.write(\" \");\n-      out.write(name);\n-    } else {\n-      emitCompressedType(name);\n-    }\n-    out.write(\"(\");\n-    if (parameters != null) {\n-      for (int p = 0; p < parameters.size();) {\n-        if (p != 0) {\n-          out.write(\", \");\n-        }\n-        emitCompressedType(parameters.get(p++));\n-        out.write(\" \");\n-        emitCompressedType(parameters.get(p++));\n-      }\n-    }\n-    out.write(\")\");\n-    if (throwsTypes != null && throwsTypes.size() > 0) {\n-      out.write(\"\\n\");\n-      indent();\n-      out.write(\"    throws \");\n-      for (int i = 0; i < throwsTypes.size(); i++) {\n-        if (i != 0) {\n-          out.write(\", \");\n-        }\n-        emitCompressedType(throwsTypes.get(i));\n-      }\n-    }\n-    if (modifiers.contains(ABSTRACT) || Scope.INTERFACE_DECLARATION.equals(scopes.peek())) {\n-      out.write(\";\\n\");\n-      scopes.push(Scope.ABSTRACT_METHOD);\n-    } else {\n-      out.write(\" {\\n\");\n-      scopes.push(returnType == null ? Scope.CONSTRUCTOR : Scope.NON_ABSTRACT_METHOD);\n+    // write types\n+    for (TypeWriter typeWriter : typeWriters) {\n+      typeWriter.write(appendable, context.createSubcontext(typeNames)).append('\\n');\n     }\n-    return this;\n+    return appendable;\n   }\n \n-  public JavaWriter beginConstructor(Set<Modifier> modifiers, String... parameters)\n+  public void file(Filer filer, Iterable<? extends Element> originatingElements)\n       throws IOException {\n-    beginMethod(null, rawType(types.peekFirst()), modifiers, parameters);\n-    return this;\n+    file(filer, Iterables.getOnlyElement(typeWriters).name.canonicalName(), originatingElements);\n   }\n \n-  public JavaWriter beginConstructor(Set<Modifier> modifiers,\n-      List<String> parameters, List<String> throwsTypes)\n+  public void file(Filer filer, CharSequence name,  Iterable<? extends Element> originatingElements)\n       throws IOException {\n-    beginMethod(null, rawType(types.peekFirst()), modifiers, parameters, throwsTypes);\n-    return this;\n-  }\n-\n-  /** Emits some Javadoc comments with line separated by {@code \\n}. */\n-  public JavaWriter emitJavadoc(String javadoc, Object... params) throws IOException {\n-    String formatted = String.format(javadoc, params);\n-\n-    indent();\n-    out.write(\"/**\\n\");\n-    for (String line : formatted.split(\"\\n\")) {\n-      indent();\n-      out.write(\" *\");\n-      if (!line.isEmpty()) {\n-        out.write(\" \");\n-        out.write(line);\n+    JavaFileObject sourceFile = filer.createSourceFile(name,\n+        Iterables.toArray(originatingElements, Element.class));\n+    Closer closer = Closer.create();\n+    try {\n+      write(closer.register(sourceFile.openWriter()));\n+    } catch (Exception e) {\n+      try {\n+        sourceFile.delete();\n+      } catch (Exception e2) {\n+        // couldn't delete the file\n       }\n-      out.write(\"\\n\");\n+      throw closer.rethrow(e);\n+    } finally {\n+      closer.close();\n     }\n-    indent();\n-    out.write(\" */\\n\");\n-    return this;\n   }\n \n-  /** Emits a single line comment. */\n-  public JavaWriter emitSingleLineComment(String comment, Object... args) throws IOException {\n-    indent();\n-    out.write(\"// \");\n-    out.write(String.format(comment, args));\n-    out.write(\"\\n\");\n-    return this;\n-  }\n-\n-  public JavaWriter emitEmptyLine() throws IOException {\n-    out.write(\"\\n\");\n-    return this;\n-  }\n-\n-  public JavaWriter emitEnumValue(String name) throws IOException {\n-    indent();\n-    out.write(name);\n-    out.write(\",\\n\");\n-    return this;\n-  }\n-\n-  /**\n-   * A simple switch to emit the proper enum depending if its last causing it to be terminated\n-   * by a semi-colon ({@code ;}).\n-   */\n-  public JavaWriter emitEnumValue(String name, boolean isLast) throws IOException {\n-    return isLast ? emitLastEnumValue(name) : emitEnumValue(name);\n-  }\n-\n-  private JavaWriter emitLastEnumValue(String name) throws IOException {\n-    indent();\n-    out.write(name);\n-    out.write(\";\\n\");\n-    return this;\n-  }\n-\n-  /** Emit a list of enum values followed by a semi-colon ({@code ;}). */\n-  public JavaWriter emitEnumValues(Iterable<String> names) throws IOException {\n-    Iterator<String> iterator = names.iterator();\n-\n-    while (iterator.hasNext()) {\n-      String name = iterator.next();\n-      if (iterator.hasNext()) {\n-        emitEnumValue(name);\n-      } else {\n-        emitLastEnumValue(name);\n-      }\n+  @Override\n+  public String toString() {\n+    try {\n+      return write(new StringBuilder()).toString();\n+    } catch (IOException e) {\n+      throw new AssertionError();\n     }\n-\n-    return this;\n-  }\n-\n-  /** Equivalent to {@code annotation(annotation, emptyMap())}. */\n-  public JavaWriter emitAnnotation(String annotation) throws IOException {\n-    return emitAnnotation(annotation, Collections.<String, Object>emptyMap());\n-  }\n-\n-  /** Equivalent to {@code annotation(annotationType.getName(), emptyMap())}. */\n-  public JavaWriter emitAnnotation(Class<? extends Annotation> annotationType) throws IOException {\n-    return emitAnnotation(type(annotationType), Collections.<String, Object>emptyMap());\n-  }\n-\n-  /**\n-   * Annotates the next element with {@code annotationType} and a {@code value}.\n-   *\n-   * @param value an object used as the default (value) parameter of the annotation. The value will\n-   *     be encoded using Object.toString(); use {@link #stringLiteral} for String values. Object\n-   *     arrays are written one element per line.\n-   */\n-  public JavaWriter emitAnnotation(Class<? extends Annotation> annotationType, Object value)\n-      throws IOException {\n-    return emitAnnotation(type(annotationType), value);\n-  }\n-\n-  /**\n-   * Annotates the next element with {@code annotation} and a {@code value}.\n-   *\n-   * @param value an object used as the default (value) parameter of the annotation. The value will\n-   *     be encoded using Object.toString(); use {@link #stringLiteral} for String values. Object\n-   *     arrays are written one element per line.\n-   */\n-  public JavaWriter emitAnnotation(String annotation, Object value) throws IOException {\n-    indent();\n-    out.write(\"@\");\n-    emitCompressedType(annotation);\n-    out.write(\"(\");\n-    emitAnnotationValue(value);\n-    out.write(\")\");\n-    out.write(\"\\n\");\n-    return this;\n   }\n \n-  /** Equivalent to {@code annotation(annotationType.getName(), attributes)}. */\n-  public JavaWriter emitAnnotation(Class<? extends Annotation> annotationType,\n-      Map<String, ?> attributes) throws IOException {\n-    return emitAnnotation(type(annotationType), attributes);\n-  }\n+  static final class CompilationUnitContext implements Writable.Context {\n+    private final String packageName;\n+    private final ImmutableSortedSet<ClassName> visibleClasses;\n \n-  /**\n-   * Annotates the next element with {@code annotation} and {@code attributes}.\n-   *\n-   * @param attributes a map from annotation attribute names to their values. Values are encoded\n-   *     using Object.toString(); use {@link #stringLiteral} for String values. Object arrays are\n-   *     written one element per line.\n-   */\n-  public JavaWriter emitAnnotation(String annotation, Map<String, ?> attributes)\n-      throws IOException {\n-    indent();\n-    out.write(\"@\");\n-    emitCompressedType(annotation);\n-    switch (attributes.size()) {\n-      case 0:\n-        break;\n-      case 1:\n-        Entry<String, ?> onlyEntry = attributes.entrySet().iterator().next();\n-        out.write(\"(\");\n-        if (!\"value\".equals(onlyEntry.getKey())) {\n-          out.write(onlyEntry.getKey());\n-          out.write(\" = \");\n-        }\n-        emitAnnotationValue(onlyEntry.getValue());\n-        out.write(\")\");\n-        break;\n-      default:\n-        boolean split = attributes.size() > MAX_SINGLE_LINE_ATTRIBUTES\n-            || containsArray(attributes.values());\n-        out.write(\"(\");\n-        scopes.push(Scope.ANNOTATION_ATTRIBUTE);\n-        String separator = split ? \"\\n\" : \"\";\n-        for (Map.Entry<String, ?> entry : attributes.entrySet()) {\n-          out.write(separator);\n-          separator = split ? \",\\n\" : \", \";\n-          if (split) {\n-            indent();\n-          }\n-          out.write(entry.getKey());\n-          out.write(\" = \");\n-          Object value = entry.getValue();\n-          emitAnnotationValue(value);\n-        }\n-        popScope(Scope.ANNOTATION_ATTRIBUTE);\n-        if (split) {\n-          out.write(\"\\n\");\n-          indent();\n-        }\n-        out.write(\")\");\n-        break;\n+    CompilationUnitContext(String packageName, Set<ClassName> visibleClasses) {\n+      this.packageName = packageName;\n+      this.visibleClasses =\n+          ImmutableSortedSet.copyOf(Ordering.natural().reverse(), visibleClasses);\n     }\n-    out.write(\"\\n\");\n-    return this;\n-  }\n \n-  private boolean containsArray(Collection<?> values) {\n-    for (Object value : values) {\n-      if (value instanceof Object[]) {\n-        return true;\n-      }\n+    @Override\n+    public Context createSubcontext(Set<ClassName> newTypes) {\n+      return new CompilationUnitContext(packageName, Sets.union(visibleClasses, newTypes));\n     }\n-    return false;\n-  }\n \n-  /**\n-   * Writes a single annotation value. If the value is an array, each element in the array will be\n-   * written to its own line.\n-   */\n-  private JavaWriter emitAnnotationValue(Object value) throws IOException {\n-    if (value instanceof Object[]) {\n-      out.write(\"{\");\n-      boolean firstValue = true;\n-      scopes.push(Scope.ANNOTATION_ARRAY_VALUE);\n-      for (Object o : ((Object[]) value)) {\n-        if (firstValue) {\n-          firstValue = false;\n-          out.write(\"\\n\");\n-        } else {\n-          out.write(\",\\n\");\n+    @Override\n+    public String sourceReferenceForClassName(ClassName className) {\n+      if (isImported(className)) {\n+        return className.simpleName();\n+      }\n+      Optional<ClassName> enclosingClassName = className.enclosingClassName();\n+      while (enclosingClassName.isPresent()) {\n+        if (isImported(enclosingClassName.get())) {\n+          return enclosingClassName.get().simpleName()\n+              + className.canonicalName()\n+                  .substring(enclosingClassName.get().canonicalName().length());\n         }\n-        indent();\n-        out.write(o.toString());\n+        enclosingClassName = enclosingClassName.get().enclosingClassName();\n       }\n-      popScope(Scope.ANNOTATION_ARRAY_VALUE);\n-      out.write(\"\\n\");\n-      indent();\n-      out.write(\"}\");\n-    } else {\n-      out.write(value.toString());\n-    }\n-    return this;\n-  }\n-\n-  /**\n-   * @param pattern a code pattern like \"int i = %s\". Newlines will be further indented. Should not\n-   *     contain trailing semicolon.\n-   */\n-  public JavaWriter emitStatement(String pattern, Object... args) throws IOException {\n-    checkInMethod();\n-    String[] lines = String.format(pattern, args).split(\"\\n\", -1);\n-    indent();\n-    out.write(lines[0]);\n-    for (int i = 1; i < lines.length; i++) {\n-      out.write(\"\\n\");\n-      hangingIndent();\n-      out.write(lines[i]);\n-    }\n-    out.write(\";\\n\");\n-    return this;\n-  }\n-\n-  /**\n-   * @param controlFlow the control flow construct and its code, such as \"if (foo == 5)\". Shouldn't\n-   *     contain braces or newline characters.\n-   */\n-  public JavaWriter beginControlFlow(String controlFlow, Object... args) throws IOException {\n-    checkInMethod();\n-    indent();\n-    out.write(String.format(controlFlow, args));\n-    out.write(\" {\\n\");\n-    scopes.push(Scope.CONTROL_FLOW);\n-    return this;\n-  }\n-\n-  /**\n-   * @param controlFlow the control flow construct and its code, such as \"else if (foo == 10)\".\n-   *     Shouldn't contain braces or newline characters.\n-   */\n-  public JavaWriter nextControlFlow(String controlFlow, Object... args) throws IOException {\n-    popScope(Scope.CONTROL_FLOW);\n-    indent();\n-    scopes.push(Scope.CONTROL_FLOW);\n-    out.write(\"} \");\n-    out.write(String.format(controlFlow, args));\n-    out.write(\" {\\n\");\n-    return this;\n-  }\n-\n-  public JavaWriter endControlFlow() throws IOException {\n-    return endControlFlow(null);\n-  }\n-\n-  /**\n-   * @param controlFlow the optional control flow construct and its code, such as\n-   *     \"while(foo == 20)\". Only used for \"do/while\" control flows.\n-   */\n-  public JavaWriter endControlFlow(String controlFlow, Object... args) throws IOException {\n-    popScope(Scope.CONTROL_FLOW);\n-    indent();\n-    if (controlFlow != null) {\n-      out.write(\"} \");\n-      out.write(String.format(controlFlow, args));\n-      out.write(\";\\n\");\n-    } else {\n-      out.write(\"}\\n\");\n-    }\n-    return this;\n-  }\n-\n-  /** Completes the current method declaration. */\n-  public JavaWriter endMethod() throws IOException {\n-    Scope popped = scopes.pop();\n-    // support calling a constructor a \"method\" to support the legacy code\n-    if (popped == Scope.NON_ABSTRACT_METHOD || popped == Scope.CONSTRUCTOR) {\n-      indent();\n-      out.write(\"}\\n\");\n-    } else if (popped != Scope.ABSTRACT_METHOD) {\n-      throw new IllegalStateException();\n-    }\n-    return this;\n-  }\n-\n-  /** Completes the current constructor declaration. */\n-  public JavaWriter endConstructor() throws IOException {\n-    popScope(Scope.CONSTRUCTOR);\n-    indent();\n-    out.write(\"}\\n\");\n-    return this;\n-  }\n-\n-  /**\n-   * Returns the string literal representing {@code data}, including wrapping quotes.\n-   *\n-   * @deprecated use {@link StringLiteral} and its {@link StringLiteral#literal()} method instead.\n-   */\n-  @Deprecated\n-  public static String stringLiteral(String data) {\n-    return StringLiteral.forValue(data).literal();\n-  }\n-\n-  /** Build a string representation of a type and optionally its generic type arguments. */\n-  public static String type(Class<?> raw, String... parameters) {\n-    if (parameters.length == 0) {\n-      return raw.getCanonicalName();\n-    }\n-    if (raw.getTypeParameters().length != parameters.length) {\n-      throw new IllegalArgumentException();\n-    }\n-    StringBuilder result = new StringBuilder();\n-    result.append(raw.getCanonicalName());\n-    result.append(\"<\");\n-    result.append(parameters[0]);\n-    for (int i = 1; i < parameters.length; i++) {\n-      result.append(\", \");\n-      result.append(parameters[i]);\n-    }\n-    result.append(\">\");\n-    return result.toString();\n-  }\n-\n-  /** Build a string representation of the raw type for a (optionally generic) type. */\n-  public static String rawType(String type) {\n-    int lessThanIndex = type.indexOf('<');\n-    if (lessThanIndex != -1) {\n-      return type.substring(0, lessThanIndex);\n-    }\n-    return type;\n-  }\n-\n-  @Override public void close() throws IOException {\n-    out.close();\n-  }\n-\n-  /** Emits the modifiers to the writer. */\n-  private void emitModifiers(Set<Modifier> modifiers) throws IOException {\n-    if (modifiers.isEmpty()) {\n-      return;\n+      return className.canonicalName();\n     }\n-    // Use an EnumSet to ensure the proper ordering\n-    if (!(modifiers instanceof EnumSet)) {\n-      modifiers = EnumSet.copyOf(modifiers);\n-    }\n-    for (Modifier modifier : modifiers) {\n-      out.append(modifier.toString()).append(' ');\n-    }\n-  }\n \n-  private void indent() throws IOException {\n-    for (int i = 0, count = scopes.size(); i < count; i++) {\n-      out.write(indent);\n+    private boolean collidesWithVisibleClass(ClassName className) {\n+      return collidesWithVisibleClass(className.simpleName());\n     }\n-  }\n \n-  private void hangingIndent() throws IOException {\n-    for (int i = 0, count = scopes.size() + 2; i < count; i++) {\n-      out.write(indent);\n+    private boolean collidesWithVisibleClass(String simpleName) {\n+      return FluentIterable.from(visibleClasses)\n+          .transform(new Function<ClassName, String>() {\n+            @Override public String apply(ClassName input) {\n+              return input.simpleName();\n+            }\n+          })\n+          .contains(simpleName);\n     }\n-  }\n-\n-  private static final EnumSet<Scope> METHOD_SCOPES = EnumSet.of(\n-      Scope.NON_ABSTRACT_METHOD, Scope.CONSTRUCTOR, Scope.CONTROL_FLOW, Scope.INITIALIZER);\n \n-  private void checkInMethod() {\n-    if (!METHOD_SCOPES.contains(scopes.peekFirst())) {\n-      throw new IllegalArgumentException();\n+    private boolean isImported(ClassName className) {\n+      return (packageName.equals(className.packageName())\n+              && !className.enclosingClassName().isPresent()\n+              && !collidesWithVisibleClass(className)) // need to account for scope & hiding\n+          || visibleClasses.contains(className)\n+          || (className.packageName().equals(\"java.lang\")\n+              && className.enclosingSimpleNames().isEmpty());\n     }\n   }\n-\n-  private void popScope(Scope... expected) {\n-    if (!EnumSet.copyOf(Arrays.asList(expected)).contains(scopes.pop())) {\n-      throw new IllegalStateException();\n-    }\n-  }\n-\n-  private enum Scope {\n-    TYPE_DECLARATION,\n-    INTERFACE_DECLARATION,\n-    ABSTRACT_METHOD,\n-    NON_ABSTRACT_METHOD,\n-    CONSTRUCTOR,\n-    CONTROL_FLOW,\n-    ANNOTATION_ATTRIBUTE,\n-    ANNOTATION_ARRAY_VALUE,\n-    INITIALIZER\n-  }\n }\n"
    },
    {
        "commit_hash": "8a0fcc1f83c86369f70b600c2e34855176ca41d4",
        "previous_commit_hash": "5bcd82961ef990e45c51aa0e5cdf423c856d33f3",
        "diff_stats": {
            "additions": 17,
            "deletions": 2
        },
        "diff_content": "@@ -1,4 +1,19 @@\n-package dagger.internal.codegen.writer;\n+/*\n+ * Copyright (C) 2014 Google, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter;\n \n import com.google.common.base.Function;\n import com.google.common.base.Optional;\n@@ -14,7 +29,7 @@ import javax.lang.model.element.TypeElement;\n \n import static com.google.common.base.Preconditions.checkArgument;\n \n-public class MethodWriter extends Modifiable implements HasClassReferences, Writable {\n+public final class MethodWriter extends Modifiable implements HasClassReferences, Writable {\n   private final TypeName returnType;\n   private final String name;\n   private final Map<String, VariableWriter> parameterWriters;\n"
    },
    {
        "commit_hash": "8a0fcc1f83c86369f70b600c2e34855176ca41d4",
        "previous_commit_hash": "5bcd82961ef990e45c51aa0e5cdf423c856d33f3",
        "diff_stats": {
            "additions": 17,
            "deletions": 2
        },
        "diff_content": "@@ -1,8 +1,23 @@\n-package dagger.internal.codegen.writer;\n+/*\n+ * Copyright (C) 2014 Google, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter;\n \n import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n-import dagger.internal.codegen.writer.Writable.Context;\n+import com.squareup.javawriter.Writable.Context;\n import java.io.IOException;\n import java.lang.annotation.Annotation;\n import java.util.EnumSet;\n"
    },
    {
        "commit_hash": "8a0fcc1f83c86369f70b600c2e34855176ca41d4",
        "previous_commit_hash": "5bcd82961ef990e45c51aa0e5cdf423c856d33f3",
        "diff_stats": {
            "additions": 39,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright (C) 2014 Google, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter;\n+\n+import com.google.common.collect.ImmutableSet;\n+import java.io.IOException;\n+import java.util.Set;\n+\n+enum NullName implements TypeName {\n+  NULL;\n+\n+  @Override\n+  public Set<ClassName> referencedClasses() {\n+    return ImmutableSet.of();\n+  }\n+\n+  @Override\n+  public Appendable write(Appendable appendable, Context context) throws IOException {\n+    return appendable.append(\"null\");\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return \"null\";\n+  }\n+}\n"
    },
    {
        "commit_hash": "8a0fcc1f83c86369f70b600c2e34855176ca41d4",
        "previous_commit_hash": "5bcd82961ef990e45c51aa0e5cdf423c856d33f3",
        "diff_stats": {
            "additions": 17,
            "deletions": 2
        },
        "diff_content": "@@ -1,4 +1,19 @@\n-package dagger.internal.codegen.writer;\n+/*\n+ * Copyright (C) 2014 Google, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter;\n \n import com.google.common.base.Objects;\n import com.google.common.collect.ImmutableList;\n@@ -10,7 +25,7 @@ import java.util.Set;\n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Verify.verify;\n \n-public class ParameterizedTypeName implements TypeName {\n+public final class ParameterizedTypeName implements TypeName {\n   private final ClassName type;\n   private final ImmutableList<? extends TypeName> parameters;\n \n"
    },
    {
        "commit_hash": "8a0fcc1f83c86369f70b600c2e34855176ca41d4",
        "previous_commit_hash": "5bcd82961ef990e45c51aa0e5cdf423c856d33f3",
        "diff_stats": {
            "additions": 16,
            "deletions": 1
        },
        "diff_content": "@@ -1,4 +1,19 @@\n-package dagger.internal.codegen.writer;\n+/*\n+ * Copyright (C) 2014 Google, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter;\n \n import com.google.common.base.Ascii;\n import com.google.common.collect.ImmutableSet;\n"
    },
    {
        "commit_hash": "8a0fcc1f83c86369f70b600c2e34855176ca41d4",
        "previous_commit_hash": "5bcd82961ef990e45c51aa0e5cdf423c856d33f3",
        "diff_stats": {
            "additions": 16,
            "deletions": 1
        },
        "diff_content": "@@ -1,4 +1,19 @@\n-package dagger.internal.codegen.writer;\n+/*\n+ * Copyright (C) 2014 Google, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter;\n \n import com.google.common.base.Function;\n import com.google.common.base.Joiner;\n"
    },
    {
        "commit_hash": "8a0fcc1f83c86369f70b600c2e34855176ca41d4",
        "previous_commit_hash": "5bcd82961ef990e45c51aa0e5cdf423c856d33f3",
        "diff_stats": {
            "additions": 15,
            "deletions": 1
        },
        "diff_content": "@@ -1,4 +1,18 @@\n-// Copyright 2014 Square, Inc.\n+/*\n+ * Copyright (C) 2014 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n package com.squareup.javawriter;\n \n import java.util.Formatter;\n"
    },
    {
        "commit_hash": "8a0fcc1f83c86369f70b600c2e34855176ca41d4",
        "previous_commit_hash": "5bcd82961ef990e45c51aa0e5cdf423c856d33f3",
        "diff_stats": {
            "additions": 19,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,19 @@\n+/*\n+ * Copyright (C) 2014 Google, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter;\n+\n+public interface TypeName extends HasClassReferences, Writable {\n+}\n"
    },
    {
        "commit_hash": "8a0fcc1f83c86369f70b600c2e34855176ca41d4",
        "previous_commit_hash": "5bcd82961ef990e45c51aa0e5cdf423c856d33f3",
        "diff_stats": {
            "additions": 21,
            "deletions": 3
        },
        "diff_content": "@@ -1,4 +1,19 @@\n-package dagger.internal.codegen.writer;\n+/*\n+ * Copyright (C) 2014 Google, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter;\n \n import com.google.common.base.Function;\n import com.google.common.collect.FluentIterable;\n@@ -12,8 +27,8 @@ import javax.lang.model.type.TypeMirror;\n import javax.lang.model.type.WildcardType;\n import javax.lang.model.util.SimpleTypeVisitor6;\n \n-public class TypeNames {\n-  static Function<TypeMirror, TypeName> FOR_TYPE_MIRROR =\n+public final class TypeNames {\n+  static final Function<TypeMirror, TypeName> FOR_TYPE_MIRROR =\n       new Function<TypeMirror, TypeName>() {\n         @Override public TypeName apply(TypeMirror input) {\n           return forTypeMirror(input);\n@@ -81,4 +96,7 @@ public class TypeNames {\n       }\n     }, null);\n   }\n+\n+  private TypeNames() {\n+  }\n }\n"
    },
    {
        "commit_hash": "8a0fcc1f83c86369f70b600c2e34855176ca41d4",
        "previous_commit_hash": "5bcd82961ef990e45c51aa0e5cdf423c856d33f3",
        "diff_stats": {
            "additions": 17,
            "deletions": 2
        },
        "diff_content": "@@ -1,11 +1,26 @@\n-package dagger.internal.codegen.writer;\n+/*\n+ * Copyright (C) 2014 Google, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter;\n \n import com.google.common.base.Optional;\n import com.google.common.collect.ImmutableSet;\n import java.io.IOException;\n import java.util.Set;\n \n-public class TypeVariableName implements TypeName {\n+public final class TypeVariableName implements TypeName {\n   private final String name;\n   private final Optional<TypeName> extendsBound;\n   private final Optional<TypeName> superBound;\n"
    },
    {
        "commit_hash": "8a0fcc1f83c86369f70b600c2e34855176ca41d4",
        "previous_commit_hash": "5bcd82961ef990e45c51aa0e5cdf423c856d33f3",
        "diff_stats": {
            "additions": 16,
            "deletions": 1
        },
        "diff_content": "@@ -1,4 +1,19 @@\n-package dagger.internal.codegen.writer;\n+/*\n+ * Copyright (C) 2014 Google, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter;\n \n import com.google.common.base.Optional;\n import com.google.common.collect.Lists;\n"
    },
    {
        "commit_hash": "8a0fcc1f83c86369f70b600c2e34855176ca41d4",
        "previous_commit_hash": "5bcd82961ef990e45c51aa0e5cdf423c856d33f3",
        "diff_stats": {
            "additions": 16,
            "deletions": 1
        },
        "diff_content": "@@ -1,4 +1,19 @@\n-package dagger.internal.codegen.writer;\n+/*\n+ * Copyright (C) 2014 Google, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter;\n \n import java.io.IOException;\n import java.util.Set;\n"
    },
    {
        "commit_hash": "8a0fcc1f83c86369f70b600c2e34855176ca41d4",
        "previous_commit_hash": "5bcd82961ef990e45c51aa0e5cdf423c856d33f3",
        "diff_stats": {
            "additions": 39,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright (C) 2014 Google, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter;\n+\n+import com.google.common.collect.ImmutableSet;\n+import java.io.IOException;\n+import java.util.Set;\n+\n+public enum VoidName implements TypeName {\n+  VOID;\n+\n+  @Override\n+  public Set<ClassName> referencedClasses() {\n+    return ImmutableSet.of();\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return \"void\";\n+  }\n+\n+  @Override\n+  public Appendable write(Appendable appendable, Context context) throws IOException {\n+    return appendable.append(\"void\");\n+  }\n+}\n"
    },
    {
        "commit_hash": "8a0fcc1f83c86369f70b600c2e34855176ca41d4",
        "previous_commit_hash": "5bcd82961ef990e45c51aa0e5cdf423c856d33f3",
        "diff_stats": {
            "additions": 18,
            "deletions": 3
        },
        "diff_content": "@@ -1,4 +1,19 @@\n-package dagger.internal.codegen.writer;\n+/*\n+ * Copyright (C) 2014 Google, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter;\n \n import com.google.common.base.Optional;\n import com.google.common.collect.ImmutableSet;\n@@ -6,9 +21,9 @@ import java.io.IOException;\n import java.util.Set;\n import javax.lang.model.type.WildcardType;\n \n-import static dagger.internal.codegen.writer.TypeNames.FOR_TYPE_MIRROR;\n+import static com.squareup.javawriter.TypeNames.FOR_TYPE_MIRROR;\n \n-public class WildcardName implements TypeName {\n+public final class WildcardName implements TypeName {\n   private final Optional<TypeName> extendsBound;\n   private final Optional<TypeName> superBound;\n \n"
    },
    {
        "commit_hash": "8a0fcc1f83c86369f70b600c2e34855176ca41d4",
        "previous_commit_hash": "5bcd82961ef990e45c51aa0e5cdf423c856d33f3",
        "diff_stats": {
            "additions": 28,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,28 @@\n+/*\n+ * Copyright (C) 2014 Google, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter;\n+\n+import java.io.IOException;\n+import java.util.Set;\n+\n+interface Writable {\n+  interface Context {\n+    String sourceReferenceForClassName(ClassName className);\n+    Context createSubcontext(Set<ClassName> newTypes);\n+  }\n+\n+  Appendable write(Appendable appendable, Context context) throws IOException;\n+}\n"
    },
    {
        "commit_hash": "8a0fcc1f83c86369f70b600c2e34855176ca41d4",
        "previous_commit_hash": "5bcd82961ef990e45c51aa0e5cdf423c856d33f3",
        "diff_stats": {
            "additions": 20,
            "deletions": 4
        },
        "diff_content": "@@ -1,6 +1,21 @@\n-package dagger.internal.codegen.writer;\n+/*\n+ * Copyright (C) 2014 Google, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter;\n \n-import dagger.internal.codegen.writer.Writable.Context;\n+import com.squareup.javawriter.Writable.Context;\n import java.io.IOException;\n import java.util.Set;\n \n@@ -14,7 +29,7 @@ final class Writables {\n     };\n   }\n \n-  private static Context DEFAULT_CONTEXT = new Context() {\n+  private static final Context DEFAULT_CONTEXT = new Context() {\n     @Override\n     public String sourceReferenceForClassName(ClassName className) {\n       return className.canonicalName();\n@@ -36,5 +51,6 @@ final class Writables {\n     return builder.toString();\n   }\n \n-  private Writables() {}\n+  private Writables() {\n+  }\n }\n"
    },
    {
        "commit_hash": "8a0fcc1f83c86369f70b600c2e34855176ca41d4",
        "previous_commit_hash": "5bcd82961ef990e45c51aa0e5cdf423c856d33f3",
        "diff_stats": {
            "additions": 0,
            "deletions": 5
        },
        "diff_content": "@@ -1,5 +0,0 @@\n-// Copyright 2013 Square, Inc.\n-package com.example;\n-\n-public class Binding<T> {\n-}\n"
    },
    {
        "commit_hash": "8a0fcc1f83c86369f70b600c2e34855176ca41d4",
        "previous_commit_hash": "5bcd82961ef990e45c51aa0e5cdf423c856d33f3",
        "diff_stats": {
            "additions": 6,
            "deletions": 7
        },
        "diff_content": "@@ -13,13 +13,12 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package dagger.internal.codegen.writer;\n+package com.squareup.javawriter;\n \n-import dagger.internal.codegen.writer.ClassNameTest.OuterClass.InnerClass;\n+import com.squareup.javawriter.ClassNameTest.OuterClass.InnerClass;\n \n import com.google.common.collect.ImmutableList;\n import com.google.testing.compile.CompilationRule;\n-import dagger.internal.codegen.writer.ClassName;\n import java.util.Map;\n import javax.lang.model.element.TypeElement;\n import javax.lang.model.util.Elements;\n@@ -48,7 +47,7 @@ public class ClassNameTest {\n         .isEqualTo(ClassName.create(\"java.util\", ImmutableList.of(\"Map\"), \"Entry\"));\n     assert_().that(ClassName.bestGuessFromString(OuterClass.InnerClass.class.getCanonicalName()))\n         .isEqualTo(\n-            ClassName.create(\"dagger.internal.codegen.writer\",\n+            ClassName.create(\"com.squareup.javawriter\",\n                 ImmutableList.of(\"ClassNameTest\", \"OuterClass\"), \"InnerClass\"));\n   }\n \n@@ -89,7 +88,7 @@ public class ClassNameTest {\n     ClassName className = ClassName.fromTypeElement(element);\n     ClassName peerName = className.peerNamed(\"Foo\");\n     assert_().that(peerName.canonicalName())\n-        .isEqualTo(\"dagger.internal.codegen.writer.Foo\");\n+        .isEqualTo(\"com.squareup.javawriter.Foo\");\n   }\n \n   @Test public void peerNamed_nestedClass() {\n@@ -98,7 +97,7 @@ public class ClassNameTest {\n     ClassName className = ClassName.fromTypeElement(element);\n     ClassName peerName = className.peerNamed(\"Foo\");\n     assert_().that(peerName.canonicalName())\n-        .isEqualTo(\"dagger.internal.codegen.writer.ClassNameTest.Foo\");\n+        .isEqualTo(\"com.squareup.javawriter.ClassNameTest.Foo\");\n   }\n \n   @Test public void peerNamed_deeplyNestedClass() {\n@@ -107,6 +106,6 @@ public class ClassNameTest {\n     ClassName className = ClassName.fromTypeElement(element);\n     ClassName peerName = className.peerNamed(\"Foo\");\n     assert_().that(peerName.canonicalName())\n-        .isEqualTo(\"dagger.internal.codegen.writer.ClassNameTest.OuterClass.Foo\");\n+        .isEqualTo(\"com.squareup.javawriter.ClassNameTest.OuterClass.Foo\");\n   }\n }\n"
    },
    {
        "commit_hash": "8a0fcc1f83c86369f70b600c2e34855176ca41d4",
        "previous_commit_hash": "5bcd82961ef990e45c51aa0e5cdf423c856d33f3",
        "diff_stats": {
            "additions": 28,
            "deletions": 917
        },
        "diff_content": "@@ -1,922 +1,33 @@\n-// Copyright 2013 Square, Inc.\n+/*\n+ * Copyright (C) 2014 Google, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n package com.squareup.javawriter;\n \n-import com.example.Binding;\n-import java.io.IOException;\n-import java.io.StringWriter;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.EnumSet;\n-import java.util.Iterator;\n-import java.util.LinkedHashMap;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import javax.lang.model.element.Modifier;\n import org.junit.Test;\n-\n-import static javax.lang.model.element.Modifier.ABSTRACT;\n-import static javax.lang.model.element.Modifier.FINAL;\n-import static javax.lang.model.element.Modifier.PRIVATE;\n-import static javax.lang.model.element.Modifier.PUBLIC;\n-import static javax.lang.model.element.Modifier.STATIC;\n-import static org.fest.assertions.api.Assertions.assertThat;\n-import static org.fest.assertions.api.Assertions.failBecauseExceptionWasNotThrown;\n-\n-public final class JavaWriterTest {\n-  private final StringWriter stringWriter = new StringWriter();\n-  private final JavaWriter javaWriter = new JavaWriter(stringWriter);\n-\n-  @Test public void typeDeclaration() throws IOException {\n-    javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\", EnumSet.of(PUBLIC, FINAL));\n-    javaWriter.endType();\n-    assertCode(\"\"\n-        + \"package com.squareup;\\n\"\n-        + \"\\n\"\n-        + \"public final class Foo {\\n\"\n-        + \"}\\n\");\n-  }\n-\n-  @Test public void enumDeclaration() throws IOException {\n-    javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"enum\", EnumSet.of(PUBLIC));\n-    javaWriter.emitEnumValue(\"BAR\");\n-    javaWriter.emitEnumValue(\"BAZ\");\n-    javaWriter.endType();\n-    assertCode(\"\"\n-        + \"package com.squareup;\\n\"\n-        + \"\\n\"\n-        + \"public enum Foo {\\n\"\n-        + \"  BAR,\\n\"\n-        + \"  BAZ,\\n\"\n-        + \"}\\n\");\n-  }\n-\n-  @Test public void enumDeclarationWithMethod() throws IOException{\n-    javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"enum\", EnumSet.of(PUBLIC));\n-    javaWriter.emitEnumValues(Arrays.asList(\"BAR\", \"BAZ\"));\n-    javaWriter.beginMethod(\"void\", \"foo\", EnumSet.of(PUBLIC));\n-    javaWriter.endMethod();\n-    javaWriter.endType();\n-    assertCode(\"\"\n-        + \"package com.squareup;\\n\"\n-        + \"\\n\"\n-        + \"public enum Foo {\\n\"\n-        + \"  BAR,\\n\"\n-        + \"  BAZ;\\n\"\n-        + \"  public void foo() {\\n\"\n-        + \"  }\\n\"\n-        + \"}\\n\");\n-  }\n-\n-  @Test public void enumDeclarationWithAnnotationAndMethod() throws IOException{\n-    javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"enum\", EnumSet.of(PUBLIC));\n-    List<String> list = Arrays.asList(\"BAR\", \"BAZ\");\n-    int index = 0;\n-    for (Iterator<String> i = list.iterator(); i.hasNext(); ) {\n-      javaWriter.emitAnnotation(\"ProtoEnum\", index);\n-      javaWriter.emitEnumValue(i.next(), !i.hasNext());\n-      index++;\n-    }\n-    javaWriter.beginMethod(\"void\", \"foo\", EnumSet.of(PUBLIC));\n-    javaWriter.endMethod();\n-    javaWriter.endType();\n-    assertCode(\"\"\n-            + \"package com.squareup;\\n\"\n-            + \"\\n\"\n-            + \"public enum Foo {\\n\"\n-            + \"  @ProtoEnum(0)\\n\"\n-            + \"  BAR,\\n\"\n-            + \"  @ProtoEnum(1)\\n\"\n-            + \"  BAZ;\\n\"\n-            + \"  public void foo() {\\n\"\n-            + \"  }\\n\"\n-            + \"}\\n\");\n-  }\n-\n-  @Test public void fieldDeclaration() throws IOException {\n-    javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n-    javaWriter.emitField(\"java.lang.String\", \"string\", EnumSet.of(PRIVATE, STATIC));\n-    javaWriter.endType();\n-    assertCode(\"\"\n-        + \"package com.squareup;\\n\"\n-        + \"\\n\"\n-        + \"class Foo {\\n\"\n-        + \"  private static String string;\\n\"\n-        + \"}\\n\");\n-  }\n-\n-  @Test public void fieldDeclarationWithInitialValue() throws IOException {\n-    javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n-    javaWriter.emitField(\"java.lang.String\", \"string\", EnumSet.noneOf(Modifier.class),\n-        \"\\\"bar\\\" + \\\"baz\\\"\");\n-    javaWriter.endType();\n-    assertCode(\"\"\n-        + \"package com.squareup;\\n\"\n-        + \"\\n\"\n-        + \"class Foo {\\n\"\n-        + \"  String string = \\\"bar\\\" + \\\"baz\\\";\\n\"\n-        + \"}\\n\");\n-  }\n-\n-  @Test public void fieldDeclarationWithWrappingInitialValue() throws IOException {\n-    javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n-    javaWriter.emitField(\"java.lang.String\", \"string\", EnumSet.noneOf(Modifier.class),\n-        \"\\\"bar\\\"\\n+ \\\"baz\\\"\\n+ \\\"biz\\\"\");\n-    javaWriter.endType();\n-    assertCode(\"\"\n-        + \"package com.squareup;\\n\"\n-        + \"\\n\"\n-        + \"class Foo {\\n\"\n-        + \"  String string = \\\"bar\\\"\\n\"\n-        + \"      + \\\"baz\\\"\\n\"\n-        + \"      + \\\"biz\\\";\\n\"\n-        + \"}\\n\");\n-  }\n-\n-  // If the initializer begins with a newline, don't emit a space after the '='.\n-  @Test public void fieldDeclarationWithNewlineInitialValue() throws IOException {\n-    javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n-    javaWriter.emitField(\"java.lang.String\", \"string\", EnumSet.noneOf(Modifier.class),\n-        \"\\n\\\"bar\\\"\\n+ \\\"baz\\\"\\n+ \\\"biz\\\"\");\n-    javaWriter.endType();\n-    assertCode(\"\"\n-        + \"package com.squareup;\\n\"\n-        + \"\\n\"\n-        + \"class Foo {\\n\"\n-        + \"  String string =\\n\"\n-        + \"      \\\"bar\\\"\\n\"\n-        + \"      + \\\"baz\\\"\\n\"\n-        + \"      + \\\"biz\\\";\\n\"\n-        + \"}\\n\");\n-  }\n-\n-  @Test public void abstractMethodDeclaration() throws IOException {\n-    javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n-    javaWriter.beginMethod(\"java.lang.String\", \"foo\", EnumSet.of(ABSTRACT, PUBLIC),\n-        \"java.lang.Object\", \"object\", \"java.lang.String\", \"s\");\n-    javaWriter.endMethod();\n-    javaWriter.endType();\n-    assertCode(\"\"\n-        + \"package com.squareup;\\n\"\n-        + \"\\n\"\n-        + \"class Foo {\\n\"\n-        + \"  public abstract String foo(Object object, String s);\\n\"\n-        + \"}\\n\");\n-  }\n-\n-  @Test public void abstractMethodDeclarationWithThrows() throws IOException {\n-    javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n-    javaWriter.beginMethod(\"java.lang.String\", \"foo\", EnumSet.of(ABSTRACT, PUBLIC),\n-        Arrays.asList(\"java.lang.Object\", \"object\", \"java.lang.String\", \"s\"),\n-        Arrays.asList(\"java.io.IOException\"));\n-    javaWriter.endMethod();\n-    javaWriter.endType();\n-    assertCode(\"\"\n-        + \"package com.squareup;\\n\"\n-        + \"\\n\"\n-        + \"class Foo {\\n\"\n-        + \"  public abstract String foo(Object object, String s)\\n\"\n-        + \"      throws java.io.IOException;\\n\"\n-        + \"}\\n\");\n-  }\n-\n-  @Test public void nonAbstractMethodDeclaration() throws IOException {\n-    javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n-    javaWriter.beginMethod(\"int\", \"foo\", EnumSet.noneOf(Modifier.class), \"java.lang.String\", \"s\");\n-    javaWriter.endMethod();\n-    javaWriter.endType();\n-    assertCode(\"\"\n-        + \"package com.squareup;\\n\"\n-        + \"\\n\"\n-        + \"class Foo {\\n\"\n-        + \"  int foo(String s) {\\n\"\n-        + \"  }\\n\"\n-        + \"}\\n\");\n-  }\n-\n-  @Test public void nonAbstractMethodDeclarationWithThrows() throws IOException {\n-    javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n-    javaWriter.beginMethod(\"int\", \"foo\", EnumSet.noneOf(Modifier.class),\n-        Arrays.asList(\"java.lang.String\", \"s\"), Arrays.asList(\"java.io.IOException\"));\n-    javaWriter.endMethod();\n-    javaWriter.endType();\n-    assertCode(\"\"\n-        + \"package com.squareup;\\n\"\n-        + \"\\n\"\n-        + \"class Foo {\\n\"\n-        + \"  int foo(String s)\\n\"\n-        + \"      throws java.io.IOException {\\n\"\n-        + \"  }\\n\"\n-        + \"}\\n\");\n-  }\n-\n-  @Test public void interfaceMethodDeclaration() throws IOException {\n-    javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"interface\");\n-    javaWriter.beginMethod(\"java.lang.String\", \"foo\", EnumSet.noneOf(Modifier.class),\n-        \"java.lang.Object\", \"object\", \"java.lang.String\", \"s\");\n-    javaWriter.endMethod();\n-    javaWriter.endType();\n-    assertCode(\"\"\n-        + \"package com.squareup;\\n\"\n-        + \"\\n\"\n-        + \"interface Foo {\\n\"\n-        + \"  String foo(Object object, String s);\\n\"\n-        + \"}\\n\");\n-  }\n-\n-  @Test public void interfaceMethodDeclarationWithThrows() throws IOException {\n-    javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"interface\");\n-    javaWriter.beginMethod(\"java.lang.String\", \"foo\", EnumSet.noneOf(Modifier.class),\n-        Arrays.asList(\"java.lang.Object\", \"object\", \"java.lang.String\", \"s\"),\n-        Arrays.asList(\"java.io.IOException\"));\n-    javaWriter.endMethod();\n-    javaWriter.endType();\n-    assertCode(\"\"\n-        + \"package com.squareup;\\n\"\n-        + \"\\n\"\n-        + \"interface Foo {\\n\"\n-        + \"  String foo(Object object, String s)\\n\"\n-        + \"      throws java.io.IOException;\\n\"\n-        + \"}\\n\");\n-  }\n-\n-  @Test public void constructorDeclaration() throws IOException {\n-    javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n-    javaWriter.beginConstructor(EnumSet.of(PUBLIC), \"java.lang.String\", \"s\");\n-    javaWriter.endConstructor();\n-    javaWriter.endType();\n-    assertCode(\"\"\n-        + \"package com.squareup;\\n\"\n-        + \"\\n\"\n-        + \"class Foo {\\n\"\n-        + \"  public Foo(String s) {\\n\"\n-        + \"  }\\n\"\n-        + \"}\\n\");\n-  }\n-\n-  @Test public void simpleConstructor() throws IOException {\n-    javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n-    javaWriter.beginConstructor(EnumSet.of(PUBLIC), \"java.lang.String\", \"s\");\n-    javaWriter.emitStatement(\"if (%s == null) throw new NullPointerException()\", \"s\");\n-    javaWriter.endConstructor();\n-    javaWriter.endType();\n-    assertCode(\"\"\n-        + \"package com.squareup;\\n\"\n-        + \"\\n\"\n-        + \"class Foo {\\n\"\n-        + \"  public Foo(String s) {\\n\"\n-        + \"    if (s == null) throw new NullPointerException();\\n\"\n-        + \"  }\\n\"\n-        + \"}\\n\");\n-  }\n-\n-  @Test public void genericsConstructor() throws IOException {\n-      javaWriter.emitPackage(\"com.squareup\");\n-      javaWriter.beginType(\"com.squareup.Foo<T>\", \"class\");\n-      javaWriter.emitField(\"T\", \"fooType\", EnumSet.of(PRIVATE));\n-      javaWriter.beginConstructor(EnumSet.of(PUBLIC), \"T\", \"s\");\n-      javaWriter.emitStatement(\"if (%s == null) throw new NullPointerException()\", \"s\");\n-      javaWriter.endConstructor();\n-      javaWriter.beginMethod(\"T\", \"getFooType\", EnumSet.of(PUBLIC));\n-      javaWriter.emitStatement(\"return fooType\");\n-      javaWriter.endMethod();\n-      javaWriter.endType();\n-      assertCode(\"\"\n-          + \"package com.squareup;\\n\"\n-          + \"\\n\"\n-          + \"class Foo<T> {\\n\"\n-          + \"  private T fooType;\\n\"\n-          + \"  public Foo(T s) {\\n\"\n-          + \"    if (s == null) throw new NullPointerException();\\n\"\n-          + \"  }\\n\"\n-          + \"  public T getFooType() {\\n\"\n-          + \"    return fooType;\\n\"\n-          + \"  }\\n\"\n-          + \"}\\n\");\n-    }\n-\n-  @Test public void constructorDeclarationInNestedTypes() throws IOException {\n-    javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n-    javaWriter.beginConstructor(EnumSet.of(PUBLIC), \"java.lang.String\", \"s\");\n-    javaWriter.endConstructor();\n-    javaWriter.beginType(\"com.squareup.Bar\", \"class\");\n-    javaWriter.beginConstructor(EnumSet.noneOf(Modifier.class));\n-    javaWriter.endConstructor();\n-    javaWriter.endType();\n-    javaWriter.endType();\n-    assertCode(\"\"\n-        + \"package com.squareup;\\n\"\n-        + \"\\n\"\n-        + \"class Foo {\\n\"\n-        + \"  public Foo(String s) {\\n\"\n-        + \"  }\\n\"\n-        + \"  class Bar {\\n\"\n-        + \"    Bar() {\\n\"\n-        + \"    }\\n\"\n-        + \"  }\\n\"\n-        + \"}\\n\");\n-  }\n-\n-  @Test public void constructorDeclarationWithThrows() throws IOException {\n-    javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n-    javaWriter.beginConstructor(EnumSet.of(PUBLIC),\n-        Arrays.asList(\"java.lang.String\", \"s\"), Arrays.asList(\"java.io.IOException\"));\n-    javaWriter.endConstructor();\n-    javaWriter.endType();\n-    assertCode(\"\"\n-        + \"package com.squareup;\\n\"\n-        + \"\\n\"\n-        + \"class Foo {\\n\"\n-        + \"  public Foo(String s)\\n\"\n-        + \"      throws java.io.IOException {\\n\"\n-        + \"  }\\n\"\n-        + \"}\\n\");\n-  }\n-\n-  @Test public void statement() throws IOException {\n-    javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n-    javaWriter.beginMethod(\"int\", \"foo\", EnumSet.noneOf(Modifier.class), \"java.lang.String\", \"s\");\n-    javaWriter.emitStatement(\"int j = s.length() + %s\", 13);\n-    javaWriter.endMethod();\n-    javaWriter.endType();\n-    assertCode(\"\"\n-        + \"package com.squareup;\\n\"\n-        + \"\\n\"\n-        + \"class Foo {\\n\"\n-        + \"  int foo(String s) {\\n\"\n-        + \"    int j = s.length() + 13;\\n\"\n-        + \"  }\\n\"\n-        + \"}\\n\");\n-  }\n-\n-  @Test public void statementPrecededByComment() throws IOException {\n-    javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n-    javaWriter.beginMethod(\"int\", \"foo\", EnumSet.noneOf(Modifier.class), \"java.lang.String\", \"s\");\n-    javaWriter.emitSingleLineComment(\"foo\");\n-    javaWriter.emitStatement(\"int j = s.length() + %s\", 13);\n-    javaWriter.endMethod();\n-    javaWriter.endType();\n-    assertCode(\"\"\n-        + \"package com.squareup;\\n\"\n-        + \"\\n\"\n-        + \"class Foo {\\n\"\n-        + \"  int foo(String s) {\\n\"\n-        + \"    // foo\\n\"\n-        + \"    int j = s.length() + 13;\\n\"\n-        + \"  }\\n\"\n-        + \"}\\n\");\n-  }\n-\n-  @Test public void multiLineStatement() throws IOException {\n-    javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Triangle\", \"class\");\n-    javaWriter.beginMethod(\"double\", \"pythagorean\", EnumSet.noneOf(Modifier.class),\n-        \"int\", \"a\", \"int\", \"b\");\n-    javaWriter.emitStatement(\"int cSquared = a * a\\n+ b * b\");\n-    javaWriter.emitStatement(\"return Math.sqrt(cSquared)\");\n-    javaWriter.endMethod();\n-    javaWriter.endType();\n-    assertCode(\"\"\n-        + \"package com.squareup;\\n\"\n-        + \"\\n\"\n-        + \"class Triangle {\\n\"\n-        + \"  double pythagorean(int a, int b) {\\n\"\n-        + \"    int cSquared = a * a\\n\"\n-        + \"        + b * b;\\n\"\n-        + \"    return Math.sqrt(cSquared);\\n\"\n-        + \"  }\\n\"\n-        + \"}\\n\");\n-  }\n-\n-  @Test public void addImport() throws IOException {\n-    javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.emitImports(\"java.util.ArrayList\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\", EnumSet.of(PUBLIC, FINAL));\n-    javaWriter.emitField(\"java.util.ArrayList\", \"list\", EnumSet.noneOf(Modifier.class),\n-        \"new java.util.ArrayList()\");\n-    javaWriter.endType();\n-    assertCode(\"\"\n-        + \"package com.squareup;\\n\"\n-        + \"\\n\"\n-        + \"import java.util.ArrayList;\\n\"\n-        + \"public final class Foo {\\n\"\n-        + \"  ArrayList list = new java.util.ArrayList();\\n\"\n-        + \"}\\n\");\n-  }\n-\n-  @Test public void addImportAsClass() throws IOException {\n-    javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.emitImports(ArrayList.class);\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\", EnumSet.of(PUBLIC, FINAL));\n-    javaWriter.emitField(\"java.util.ArrayList\", \"list\", EnumSet.noneOf(Modifier.class),\n-        \"new java.util.ArrayList()\");\n-    javaWriter.endType();\n-    assertCode(\"\"\n-        + \"package com.squareup;\\n\"\n-        + \"\\n\"\n-        + \"import java.util.ArrayList;\\n\"\n-        + \"public final class Foo {\\n\"\n-        + \"  ArrayList list = new java.util.ArrayList();\\n\"\n-        + \"}\\n\");\n-  }\n-\n-  @Test public void addStaticImport() throws IOException {\n-    javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.emitStaticImports(\"java.lang.System.getProperty\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\", EnumSet.of(PUBLIC, FINAL));\n-    javaWriter.emitField(\"String\", \"bar\", EnumSet.noneOf(Modifier.class), \"getProperty(\\\"bar\\\")\");\n-    javaWriter.endType();\n-    assertCode(\"\"\n-        + \"package com.squareup;\\n\"\n-        + \"\\n\"\n-        + \"import static java.lang.System.getProperty;\\n\"\n-        + \"public final class Foo {\\n\"\n-        + \"  String bar = getProperty(\\\"bar\\\");\\n\"\n-        + \"}\\n\");\n-  }\n-\n-  @Test\n-  public void addNestedClassImportAsClass() throws IOException {\n-    javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.emitImports(NestedClass.class);\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\", EnumSet.of(PUBLIC, FINAL));\n-    javaWriter.emitField(\"com.squareup.javawriter.JavaWriterTest.NestedClass\", \"nestedClass\",\n-        EnumSet.noneOf(Modifier.class), \"new NestedClass()\");\n-    javaWriter.endType();\n-    assertCode(\"\"\n-        + \"package com.squareup;\\n\"\n-        + \"\\n\"\n-        + \"import com.squareup.javawriter.JavaWriterTest.NestedClass;\\n\"\n-        + \"public final class Foo {\\n\"\n-        + \"  NestedClass nestedClass = new NestedClass();\\n\"\n-        + \"}\\n\");\n-  }\n-\n-  public static class NestedClass {}\n-\n-  @Test public void addStaticWildcardImport() throws IOException {\n-    javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.emitStaticImports(\"java.lang.System.*\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\", EnumSet.of(PUBLIC, FINAL));\n-    javaWriter.emitField(\"String\", \"bar\", EnumSet.noneOf(Modifier.class), \"getProperty(\\\"bar\\\")\");\n-    javaWriter.endType();\n-    assertCode(\"\"\n-        + \"package com.squareup;\\n\"\n-        + \"\\n\"\n-        + \"import static java.lang.System.*;\\n\"\n-        + \"public final class Foo {\\n\"\n-        + \"  String bar = getProperty(\\\"bar\\\");\\n\"\n-        + \"}\\n\");\n-  }\n-\n-  @Test public void emptyImports() throws IOException {\n-    javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.emitImports(Collections.<String>emptyList());\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\", EnumSet.of(PUBLIC, FINAL));\n-    javaWriter.endType();\n-    assertCode(\"\"\n-        + \"package com.squareup;\\n\"\n-        + \"\\n\"\n-        + \"public final class Foo {\\n\"\n-        + \"}\\n\");\n-  }\n-\n-  @Test public void emptyStaticImports() throws IOException {\n-    javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.emitStaticImports(Collections.<String>emptyList());\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\", EnumSet.of(PUBLIC, FINAL));\n-    javaWriter.endType();\n-    assertCode(\"\"\n-        + \"package com.squareup;\\n\"\n-        + \"\\n\"\n-        + \"public final class Foo {\\n\"\n-        + \"}\\n\");\n-  }\n-\n-  @Test public void addImportFromSubpackage() throws IOException {\n-    javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\", EnumSet.of(PUBLIC, FINAL));\n-    javaWriter.emitField(\"com.squareup.bar.Baz\", \"baz\");\n-    javaWriter.endType();\n-    assertCode(\"\"\n-        + \"package com.squareup;\\n\"\n-        + \"\\n\"\n-        + \"public final class Foo {\\n\"\n-        + \"  com.squareup.bar.Baz baz;\\n\"\n-        + \"}\\n\");\n-  }\n-\n-  @Test public void ifControlFlow() throws IOException {\n-    javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n-    javaWriter.beginMethod(\"int\", \"foo\", EnumSet.noneOf(Modifier.class), \"java.lang.String\", \"s\");\n-    javaWriter.beginControlFlow(\"if (s.isEmpty())\");\n-    javaWriter.emitStatement(\"int j = s.length() + %s\", 13);\n-    javaWriter.endControlFlow();\n-    javaWriter.endMethod();\n-    javaWriter.endType();\n-    assertCode(\"\"\n-        + \"package com.squareup;\\n\"\n-        + \"\\n\"\n-        + \"class Foo {\\n\"\n-        + \"  int foo(String s) {\\n\"\n-        + \"    if (s.isEmpty()) {\\n\"\n-        + \"      int j = s.length() + 13;\\n\"\n-        + \"    }\\n\"\n-        + \"  }\\n\"\n-        + \"}\\n\");\n-  }\n-\n-  @Test public void doWhileControlFlow() throws IOException {\n-    javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n-    javaWriter.beginMethod(\"int\", \"foo\", EnumSet.noneOf(Modifier.class), \"java.lang.String\", \"s\");\n-    javaWriter.beginControlFlow(\"do\");\n-    javaWriter.emitStatement(\"int j = s.length() + %s\", 13);\n-    javaWriter.endControlFlow(\"while (s.isEmpty())\");\n-    javaWriter.endMethod();\n-    javaWriter.endType();\n-    assertCode(\"\"\n-        + \"package com.squareup;\\n\"\n-        + \"\\n\"\n-        + \"class Foo {\\n\"\n-        + \"  int foo(String s) {\\n\"\n-        + \"    do {\\n\"\n-        + \"      int j = s.length() + 13;\\n\"\n-        + \"    } while (s.isEmpty());\\n\"\n-        + \"  }\\n\"\n-        + \"}\\n\");\n-  }\n-\n-  @Test public void tryCatchFinallyControlFlow() throws IOException {\n-    javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n-    javaWriter.beginMethod(\"int\", \"foo\", EnumSet.noneOf(Modifier.class), \"java.lang.String\", \"s\");\n-    javaWriter.beginControlFlow(\"try\");\n-    javaWriter.emitStatement(\"int j = s.length() + %s\", 13);\n-    javaWriter.nextControlFlow(\"catch (RuntimeException e)\");\n-    javaWriter.emitStatement(\"e.printStackTrace()\");\n-    javaWriter.nextControlFlow(\"finally\");\n-    javaWriter.emitStatement(\"int k = %s\", 13);\n-    javaWriter.endControlFlow();\n-    javaWriter.endMethod();\n-    javaWriter.endType();\n-    assertCode(\"\"\n-        + \"package com.squareup;\\n\"\n-        + \"\\n\"\n-        + \"class Foo {\\n\"\n-        + \"  int foo(String s) {\\n\"\n-        + \"    try {\\n\"\n-        + \"      int j = s.length() + 13;\\n\"\n-        + \"    } catch (RuntimeException e) {\\n\"\n-        + \"      e.printStackTrace();\\n\"\n-        + \"    } finally {\\n\"\n-        + \"      int k = 13;\\n\"\n-        + \"    }\\n\"\n-        + \"  }\\n\"\n-        + \"}\\n\");\n-  }\n-\n-  @Test public void annotatedType() throws IOException {\n-    javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.emitImports(\"javax.inject.Singleton\");\n-    javaWriter.emitAnnotation(\"javax.inject.Singleton\");\n-    javaWriter.emitAnnotation(SuppressWarnings.class,\n-        StringLiteral.forValue(\"unchecked\"));\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n-    javaWriter.endType();\n-    assertCode(\"\"\n-        + \"package com.squareup;\\n\"\n-        + \"\\n\"\n-        + \"import javax.inject.Singleton;\\n\"\n-        + \"@Singleton\\n\"\n-        + \"@SuppressWarnings(\\\"unchecked\\\")\\n\"\n-        + \"class Foo {\\n\"\n-        + \"}\\n\");\n-  }\n-\n-  @Test public void annotatedMember() throws IOException {\n-    javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n-    javaWriter.emitAnnotation(Deprecated.class);\n-    javaWriter.emitField(\"java.lang.String\", \"s\");\n-    javaWriter.endType();\n-    assertCode(\"\"\n-        + \"package com.squareup;\\n\"\n-        + \"\\n\"\n-        + \"class Foo {\\n\"\n-        + \"  @Deprecated\\n\"\n-        + \"  String s;\\n\"\n-        + \"}\\n\");\n-  }\n-\n-  @Test public void annotatedWithSingleAttribute() throws IOException {\n-    Map<String, Object> attributes = new LinkedHashMap<String, Object>();\n-    attributes.put(\"overrides\", true);\n-\n-    javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.emitAnnotation(\"Module\", attributes);\n-    javaWriter.beginType(\"com.squareup.FooModule\", \"class\", EnumSet.noneOf(Modifier.class));\n-    javaWriter.endType();\n-    assertCode(\"\"\n-        + \"package com.squareup;\\n\"\n-        + \"\\n\"\n-        + \"@Module(overrides = true)\\n\"\n-        + \"class FooModule {\\n\"\n-        + \"}\\n\");\n-  }\n-\n-  @Test public void annotatedWithSingleValueAttribute() throws IOException {\n-    Map<String, Object> attributes = new LinkedHashMap<String, Object>();\n-    attributes.put(\"value\", StringLiteral.forValue(\"blah.Generator\"));\n-\n-    javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.emitAnnotation(\"Generated\", attributes);\n-    javaWriter.beginType(\"com.squareup.FooModule\", \"class\", EnumSet.noneOf(Modifier.class));\n-    javaWriter.endType();\n-    assertCode(\"\"\n-        + \"package com.squareup;\\n\"\n-        + \"\\n\"\n-        + \"@Generated(\\\"blah.Generator\\\")\\n\"\n-        + \"class FooModule {\\n\"\n-        + \"}\\n\");\n-  }\n-\n-  @Test public void annotatedWithTwoNonArrayAttributes() throws IOException {\n-    Map<String, Object> attributes = new LinkedHashMap<String, Object>();\n-    attributes.put(\"overrides\", true);\n-    attributes.put(\"foo\", \"bar\");\n-\n-    javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.emitAnnotation(\"Module\", attributes);\n-    javaWriter.beginType(\"com.squareup.FooModule\", \"class\", EnumSet.noneOf(Modifier.class));\n-    javaWriter.endType();\n-    assertCode(\"\"\n-        + \"package com.squareup;\\n\"\n-        + \"\\n\"\n-        + \"@Module(overrides = true, foo = bar)\\n\"\n-        + \"class FooModule {\\n\"\n-        + \"}\\n\");\n-  }\n-\n-  @Test public void annotatedWithThreeNonArrayAttributes() throws IOException {\n-    Map<String, Object> attributes = new LinkedHashMap<String, Object>();\n-    attributes.put(\"overrides\", true);\n-    attributes.put(\"foo\", \"bar\");\n-    attributes.put(\"bar\", \"baz\");\n-\n-    javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.emitAnnotation(\"Module\", attributes);\n-    javaWriter.beginType(\"com.squareup.FooModule\", \"class\", EnumSet.noneOf(Modifier.class));\n-    javaWriter.endType();\n-    assertCode(\"\"\n-        + \"package com.squareup;\\n\"\n-        + \"\\n\"\n-        + \"@Module(overrides = true, foo = bar, bar = baz)\\n\"\n-        + \"class FooModule {\\n\"\n-        + \"}\\n\");\n-  }\n-\n-  @Test public void annotatedWithAttributes() throws IOException {\n-    Map<String, Object> attributes = new LinkedHashMap<String, Object>();\n-    attributes.put(\"overrides\", true);\n-    attributes.put(\"entryPoints\", new Object[] { \"entryPointA\", \"entryPointB\", \"entryPointC\" });\n-    attributes.put(\"staticInjections\", \"com.squareup.Quux\");\n-\n-    javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.emitAnnotation(\"Module\", attributes);\n-    javaWriter.beginType(\"com.squareup.FooModule\", \"class\");\n-    javaWriter.endType();\n-    assertCode(\"\"\n-        + \"package com.squareup;\\n\"\n-        + \"\\n\"\n-        + \"@Module(\\n\"\n-        + \"  overrides = true,\\n\"\n-        + \"  entryPoints = {\\n\"\n-        + \"    entryPointA,\\n\"\n-        + \"    entryPointB,\\n\"\n-        + \"    entryPointC\\n\"\n-        + \"  },\\n\"\n-        + \"  staticInjections = com.squareup.Quux\\n\"\n-        + \")\\n\"\n-        + \"class FooModule {\\n\"\n-        + \"}\\n\");\n-  }\n-\n-  @Test public void parameterizedType() throws IOException {\n-    javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.emitImports(\"java.util.Map\", \"java.util.Date\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n-    javaWriter.emitField(\"java.util.Map<java.lang.String, java.util.Date>\", \"map\",\n-        EnumSet.noneOf(Modifier.class));\n-    javaWriter.endType();\n-    assertCode(\"\"\n-        + \"package com.squareup;\\n\"\n-        + \"\\n\"\n-        + \"import java.util.Date;\\n\"\n-        + \"import java.util.Map;\\n\"\n-        + \"class Foo {\\n\"\n-        + \"  Map<String, Date> map;\\n\"\n-        + \"}\\n\");\n-  }\n-\n-  @Test public void eolComment() throws IOException {\n-    javaWriter.emitSingleLineComment(\"foo\");\n-    assertCode(\"// foo\\n\");\n-  }\n-\n-  @Test public void javadoc() throws IOException {\n-    javaWriter.emitJavadoc(\"foo\");\n-    assertCode(\"\"\n-        + \"/**\\n\"\n-        + \" * foo\\n\"\n-        + \" */\\n\");\n-  }\n-\n-  @Test public void multilineJavadoc() throws IOException {\n-    javaWriter.emitJavadoc(\"0123456789 0123456789 0123456789 0123456789 0123456789 0123456789\\n\"\n-        + \"0123456789 0123456789 0123456789 0123456789\");\n-    assertCode(\"\"\n-        + \"/**\\n\"\n-        + \" * 0123456789 0123456789 0123456789 0123456789 0123456789 0123456789\\n\"\n-        + \" * 0123456789 0123456789 0123456789 0123456789\\n\"\n-        + \" */\\n\");\n-  }\n-\n-  @Test public void multilineJavadocDoesNotEmitTrailingSpaceForEmptyLines() throws IOException {\n-    javaWriter.emitJavadoc(\"Foo\\n\\nBar\");\n-    assertCode(\"\"\n-        + \"/**\\n\"\n-        + \" * Foo\\n\"\n-        + \" *\\n\"\n-        + \" * Bar\\n\"\n-        + \" */\\n\"\n-    );\n-  }\n-\n-  @Test public void testType() {\n-    assertThat(JavaWriter.type(String.class)).as(\"simple type\").isEqualTo(\"java.lang.String\");\n-    assertThat(JavaWriter.type(Set.class)).as(\"raw type\").isEqualTo(\"java.util.Set\");\n-    assertThat(JavaWriter.type(Set.class, \"?\")).as(\"wildcard type\").isEqualTo(\"java.util.Set<?>\");\n-    assertThat(JavaWriter.type(Map.class, JavaWriter.type(String.class), \"?\"))\n-        .as(\"mixed type and wildcard generic type parameters\")\n-        .isEqualTo(\"java.util.Map<java.lang.String, ?>\");\n-    try {\n-      JavaWriter.type(String.class, \"foo\");\n-      failBecauseExceptionWasNotThrown(IllegalArgumentException.class);\n-    } catch (Throwable e) {\n-      assertThat(e).as(\"parameterized non-generic\").isInstanceOf(IllegalArgumentException.class);\n-    }\n-    try {\n-      JavaWriter.type(Map.class, \"foo\");\n-      failBecauseExceptionWasNotThrown(IllegalArgumentException.class);\n-    } catch (Throwable e) {\n-      assertThat(e).as(\"too few type arguments\").isInstanceOf(IllegalArgumentException.class);\n-    }\n-    try {\n-      JavaWriter.type(Set.class, \"foo\", \"bar\");\n-      failBecauseExceptionWasNotThrown(IllegalArgumentException.class);\n-    } catch (Throwable e) {\n-      assertThat(e).as(\"too many type arguments\").isInstanceOf(IllegalArgumentException.class);\n-    }\n-  }\n-\n-  @Test public void testRawType() {\n-      assertThat(JavaWriter.rawType(JavaWriter.type(Set.class)))\n-          .as(\"raw type\").isEqualTo(\"java.util.Set\");\n-      assertThat(JavaWriter.rawType(JavaWriter.type(Set.class, \"?\")))\n-          .as(\"wildcard type\").isEqualTo(\"java.util.Set\");\n-      assertThat(JavaWriter.rawType(JavaWriter.type(Set.class, \"String\")))\n-          .as(\"parameterized type\").isEqualTo(\"java.util.Set\");\n-      assertThat(JavaWriter.rawType(JavaWriter.type(Map.class, \"String\", \"Integer\")))\n-          .as(\"parameterized type\").isEqualTo(\"java.util.Map\");\n-      assertThat(JavaWriter.rawType(\"java.util.Set<com.example.Binding<com.blah.Foo.Blah>>\"))\n-          .as(\"nested parameterized type\").isEqualTo(\"java.util.Set\");\n-  }\n-\n-  @Test public void compressType() throws IOException {\n-    javaWriter.emitPackage(\"com.blah\");\n-    javaWriter.emitImports(Set.class.getCanonicalName(), Binding.class.getCanonicalName());\n-    String actual =\n-        javaWriter.compressType(\"java.util.Set<com.example.Binding<com.blah.Foo.Blah>>\");\n-    assertThat(actual).isEqualTo(\"Set<Binding<Foo.Blah>>\");\n-  }\n-\n-  @Test public void compressDeeperType() throws IOException {\n-    javaWriter.emitPackage(\"com.blah\");\n-    javaWriter.emitImports(Binding.class.getCanonicalName());\n-    String actual = javaWriter.compressType(\"com.example.Binding<com.blah.foo.Foo.Blah>\");\n-    assertThat(actual).isEqualTo(\"Binding<com.blah.foo.Foo.Blah>\");\n-  }\n-\n-  @Test public void compressNestedType() throws IOException {\n-    javaWriter.emitPackage(\"com.blah\");\n-    String actual = javaWriter.compressType(\"com.blah.Enclosing.Nested\");\n-    assertThat(actual).isEqualTo(\"Enclosing.Nested\");\n-  }\n-\n-  @Test public void compressWildcardType() throws IOException {\n-    javaWriter.emitPackage(\"com.blah\");\n-    javaWriter.emitImports(Binding.class.getCanonicalName());\n-    String actual = javaWriter.compressType(\"com.example.Binding<? extends com.blah.Foo.Blah>\");\n-    assertThat(actual).isEqualTo(\"Binding<? extends Foo.Blah>\");\n-  }\n-\n-  @Test public void compressSimpleNameCollisionInSamePackage() throws IOException {\n-    javaWriter.emitPackage(\"denominator\");\n-    javaWriter.emitImports(\"javax.inject.Provider\", \"dagger.internal.Binding\");\n-    String actual = javaWriter.compressType(\"dagger.internal.Binding<denominator.Provider>\");\n-    assertThat(actual).isEqualTo(\"Binding<denominator.Provider>\");\n-  }\n-\n-  @Test public void compressJavaLangClass() throws IOException {\n-    javaWriter.emitPackage(\"com.blah\");\n-    String actual = javaWriter.compressType(\"java.lang.Class\");\n-    assertThat(actual).isEqualTo(\"Class\");\n-  }\n-\n-  @Test public void compressJavaLangSubPackageClass() throws IOException {\n-    javaWriter.emitPackage(\"com.blah\");\n-    String actual = javaWriter.compressType(\"java.lang.annotation.Annotation\");\n-    assertThat(actual).isEqualTo(\"java.lang.annotation.Annotation\");\n-  }\n-\n-  @Test public void compressVarargsType() throws IOException {\n-    javaWriter.emitPackage(\"com.blah\");\n-    javaWriter.emitImports(\"java.util.File\");\n-    String actual = javaWriter.compressType(\"java.util.File...\");\n-    assertThat(actual).isEqualTo(\"File...\");\n-  }\n-\n-  @Test public void compressArrayType() throws IOException {\n-    javaWriter.emitPackage(\"com.blah\");\n-    javaWriter.emitImports(\"java.util.File\");\n-    String actual1 = javaWriter.compressType(\"java.util.File[]\");\n-    assertThat(actual1).isEqualTo(\"File[]\");\n-    String actual2 = javaWriter.compressType(\"java.util.File[][][]\");\n-    assertThat(actual2).isEqualTo(\"File[][][]\");\n-  }\n-\n-  @Test public void configurableIndent() throws IOException {\n-    javaWriter.setIndent(\"    \");\n-    javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\");\n-    javaWriter.emitField(\"String\", \"bar\");\n-    javaWriter.endType();\n-    assertCode(\"\"\n-        + \"package com.squareup;\\n\"\n-        + \"\\n\"\n-        + \"class Foo {\\n\"\n-        + \"    String bar;\\n\"\n-        + \"}\\n\");\n-  }\n-\n-  @Test public void outOfOrderModifierSet() throws IOException {\n-    Set<Modifier> modifiers = new LinkedHashSet<Modifier>(Arrays.asList(FINAL, PUBLIC));\n-    javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\", modifiers);\n-    javaWriter.endType();\n-    assertCode(\"\"\n-        + \"package com.squareup;\\n\"\n-        + \"\\n\"\n-        + \"public final class Foo {\\n\"\n-        + \"}\\n\");\n-  }\n-\n-  @Test public void emptyNonEnumModifierSet() throws IOException {\n-    javaWriter.emitPackage(\"com.squareup\");\n-    javaWriter.beginType(\"com.squareup.Foo\", \"class\", new LinkedHashSet<Modifier>());\n-    javaWriter.endType();\n-    assertCode(\"\"\n-        + \"package com.squareup;\\n\"\n-        + \"\\n\"\n-        + \"class Foo {\\n\"\n-        + \"}\\n\");\n-  }\n-\n-  private void assertCode(String expected) {\n-    assertThat(stringWriter.toString()).isEqualTo(expected);\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+@RunWith(JUnit4.class)\n+public class JavaWriterTest {\n+  @Test public void referencedAndDeclaredSimpleName() {\n+    JavaWriter javaWriter = JavaWriter.inPackage(\"test\");\n+    ClassWriter topClass = javaWriter.addClass(\"Top\");\n+    topClass.addNestedClass(\"Middle\").addNestedClass(\"Bottom\");\n+    topClass.addField(ClassName.create(\"some.other.pkg\", \"Bottom\"), \"field\");\n+    assertThat(topClass.toString()).doesNotContain(\"import some.other.pkg.Bottom;\");\n   }\n }\n"
    },
    {
        "commit_hash": "8a0fcc1f83c86369f70b600c2e34855176ca41d4",
        "previous_commit_hash": "5bcd82961ef990e45c51aa0e5cdf423c856d33f3",
        "diff_stats": {
            "additions": 0,
            "deletions": 46
        },
        "diff_content": "@@ -1,46 +0,0 @@\n-// Copyright 2014 Square, Inc.\n-package com.squareup.javawriter;\n-\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.junit.runners.JUnit4;\n-\n-import static org.fest.assertions.api.Assertions.assertThat;\n-\n-@RunWith(JUnit4.class)\n-public final class StringLiteralTest {\n-  @Test public void stringLiteral() {\n-    assertThat(StringLiteral.forValue(\"\").toString()).isEqualTo(\"\\\"\\\"\");\n-    assertThat(StringLiteral.forValue(\"JavaWriter\").toString()).isEqualTo(\"\\\"JavaWriter\\\"\");\n-    assertThat(StringLiteral.forValue(\"\\\\\").toString()).isEqualTo(\"\\\"\\\\\\\\\\\"\");\n-    assertThat(StringLiteral.forValue(\"\\\"\").toString()).isEqualTo(\"\\\"\\\\\\\"\\\"\");\n-    assertThat(StringLiteral.forValue(\"\\b\").toString()).isEqualTo(\"\\\"\\\\b\\\"\");\n-    assertThat(StringLiteral.forValue(\"\\t\").toString()).isEqualTo(\"\\\"\\\\t\\\"\");\n-    assertThat(StringLiteral.forValue(\"\\n\").toString()).isEqualTo(\"\\\"\\\\n\\\"\");\n-    assertThat(StringLiteral.forValue(\"\\f\").toString()).isEqualTo(\"\\\"\\\\f\\\"\");\n-    assertThat(StringLiteral.forValue(\"\\r\").toString()).isEqualTo(\"\\\"\\\\r\\\"\");\n-\n-    // Control characters\n-    for (char i = 0x1; i <= 0x1f; i++) {\n-      checkCharEscape(i);\n-    }\n-    for (char i = 0x7f; i <= 0x9f; i++) {\n-      checkCharEscape(i);\n-    }\n-  }\n-\n-  private void checkCharEscape(char codePoint) {\n-    String test = \"\" + codePoint;\n-    String expected;\n-    switch (codePoint) {\n-      case 8: expected = \"\\\"\\\\b\\\"\"; break;\n-      case 9: expected = \"\\\"\\\\t\\\"\"; break;\n-      case 10: expected = \"\\\"\\\\n\\\"\"; break;\n-      case 12: expected = \"\\\"\\\\f\\\"\"; break;\n-      case 13: expected = \"\\\"\\\\r\\\"\"; break;\n-      default: expected = \"\\\"\\\\u\" + String.format(\"%04x\", (int) codePoint) + \"\\\"\";\n-    }\n-    assertThat(StringLiteral.forValue(test).toString()).isEqualTo(expected);\n-  }\n-\n-}\n"
    },
    {
        "commit_hash": "8a0fcc1f83c86369f70b600c2e34855176ca41d4",
        "previous_commit_hash": "5bcd82961ef990e45c51aa0e5cdf423c856d33f3",
        "diff_stats": {
            "additions": 16,
            "deletions": 1
        },
        "diff_content": "@@ -1,4 +1,19 @@\n-package dagger.internal.codegen.writer;\n+/*\n+ * Copyright (C) 2014 Google, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter;\n \n import com.google.testing.compile.CompilationRule;\n import java.nio.charset.Charset;\n"
    },
    {
        "commit_hash": "271af1039daf61f5cf846cabddbec726ee925e04",
        "previous_commit_hash": "d39761f9ec25ca5bf3b7bf15d34fa2b831fed9c1",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -77,4 +77,4 @@ License\n \n \n \n- [dl]: http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=com.squareup&a=javawriter&v=LATEST\n+ [dl]: https://search.maven.org/remote_content?g=com.squareup&a=javawriter&v=LATEST\n"
    },
    {
        "commit_hash": "271af1039daf61f5cf846cabddbec726ee925e04",
        "previous_commit_hash": "d39761f9ec25ca5bf3b7bf15d34fa2b831fed9c1",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -24,7 +24,7 @@ git checkout -t origin/gh-pages\n rm -rf *\n \n # Download the latest javadoc\n-curl -L \"http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=$GROUP_ID&a=$ARTIFACT_ID&v=LATEST&c=javadoc\" > javadoc.zip\n+curl -L \"https://search.maven.org/remote_content?g=$GROUP_ID&a=$ARTIFACT_ID&v=LATEST&c=javadoc\" > javadoc.zip\n unzip javadoc.zip\n rm javadoc.zip\n \n"
    },
    {
        "commit_hash": "274bb39dc18ec3bc42223f80061be6fa1bab0234",
        "previous_commit_hash": "ec00e06948bfb9d3df5dbbaa6ce61b33c70d6230",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javawriter</artifactId>\n-  <version>2.5.1-SNAPSHOT</version>\n+  <version>3.0.0-SNAPSHOT</version>\n \n   <name>JavaWriter</name>\n   <description>A utility class which aids in generating Java source files.</description>\n"
    },
    {
        "commit_hash": "183ef6744bfa30d96ae4c0cf9666507d5fc4c98a",
        "previous_commit_hash": "232ec3e965c2120b13a67319aab51e73a0e0ae1a",
        "diff_stats": {
            "additions": 12,
            "deletions": 0
        },
        "diff_content": "@@ -39,6 +39,18 @@ public final class WildcardName implements TypeName {\n         Optional.fromNullable(mirror.getSuperBound()).transform(FOR_TYPE_MIRROR));\n   }\n \n+  public static WildcardName create() {\n+    return new WildcardName(Optional.<TypeName>absent(), Optional.<TypeName>absent());\n+  }\n+\n+  public static WildcardName createWithUpperBound(TypeName upperBound) {\n+    return new WildcardName(Optional.of(upperBound), Optional.<TypeName>absent());\n+  }\n+\n+  public static WildcardName createWithLowerBound(TypeName lowerBound) {\n+    return new WildcardName(Optional.<TypeName>absent(), Optional.of(lowerBound));\n+  }\n+\n   @Override\n   public Set<ClassName> referencedClasses() {\n     ImmutableSet.Builder<ClassName> builder = new ImmutableSet.Builder<ClassName>();\n"
    },
    {
        "commit_hash": "b734b83719da16b10ed35a78162e93161e4614f1",
        "previous_commit_hash": "65542253247f648482c5239c59d2d3cded79bb4b",
        "diff_stats": {
            "additions": 6,
            "deletions": 0
        },
        "diff_content": "@@ -24,6 +24,7 @@ import javax.lang.model.type.NoType;\n import javax.lang.model.type.NullType;\n import javax.lang.model.type.PrimitiveType;\n import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.type.TypeVariable;\n import javax.lang.model.type.WildcardType;\n import javax.lang.model.util.SimpleTypeVisitor6;\n \n@@ -73,6 +74,11 @@ public final class TypeNames {\n         return PrimitiveName.forTypeMirror(t);\n       }\n \n+      @Override\n+      public TypeName visitTypeVariable(TypeVariable t, Void p) {\n+        return TypeVariableName.forTypeMirror(t);\n+      }\n+\n       @Override\n       public WildcardName visitWildcard(WildcardType t, Void p) {\n         return WildcardName.forTypeMirror(t);\n"
    },
    {
        "commit_hash": "b734b83719da16b10ed35a78162e93161e4614f1",
        "previous_commit_hash": "65542253247f648482c5239c59d2d3cded79bb4b",
        "diff_stats": {
            "additions": 66,
            "deletions": 24
        },
        "diff_content": "@@ -15,20 +15,53 @@\n  */\n package com.squareup.javawriter;\n \n-import com.google.common.base.Optional;\n+import com.google.common.base.Objects;\n+import com.google.common.base.Predicates;\n+import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n import java.io.IOException;\n+import java.util.Iterator;\n import java.util.Set;\n+import javax.lang.model.element.NestingKind;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.type.TypeVariable;\n+\n+import static com.squareup.javawriter.TypeNames.FOR_TYPE_MIRROR;\n \n public final class TypeVariableName implements TypeName {\n   private final String name;\n-  private final Optional<TypeName> extendsBound;\n-  private final Optional<TypeName> superBound;\n-  TypeVariableName(String name, Optional<TypeName> extendsBound,\n-      Optional<TypeName> superBound) {\n+  private final ImmutableList<TypeName> bounds;\n+\n+  TypeVariableName(String name, Iterable<TypeName> bounds) {\n     this.name = name;\n-    this.extendsBound = extendsBound;\n-    this.superBound = superBound;\n+    this.bounds = FluentIterable.from(bounds)\n+        .filter(Predicates.not(Predicates.<TypeName>equalTo(ClassName.fromClass(Object.class))))\n+        .toList();\n+  }\n+\n+  static TypeVariableName named(String name) {\n+    return new TypeVariableName(name, ImmutableList.<TypeName>of());\n+  }\n+\n+  static TypeVariableName forTypeMirror(TypeVariable mirror) {\n+    FluentIterable<TypeMirror> bounds =\n+        FluentIterable.from(ImmutableList.of(mirror.getUpperBound()));\n+    if (mirror.getUpperBound().getKind() == TypeKind.DECLARED) {\n+      TypeElement bound = (TypeElement) ((DeclaredType) mirror.getUpperBound()).asElement();\n+      if (bound.getNestingKind() == NestingKind.ANONYMOUS) {\n+        // This is (likely) an intersection type.\n+        bounds = FluentIterable\n+            .from(ImmutableList.of(bound.getSuperclass()))\n+            .append(bound.getInterfaces());\n+      }\n+    }\n+    return new TypeVariableName(\n+        mirror.asElement().getSimpleName().toString(),\n+        bounds.transform(FOR_TYPE_MIRROR));\n   }\n \n   public String name() {\n@@ -38,11 +71,8 @@ public final class TypeVariableName implements TypeName {\n   @Override\n   public Set<ClassName> referencedClasses() {\n     ImmutableSet.Builder<ClassName> builder = new ImmutableSet.Builder<ClassName>();\n-    if (extendsBound.isPresent()) {\n-      builder.addAll(extendsBound.get().referencedClasses());\n-    }\n-    if (superBound.isPresent()) {\n-      builder.addAll(superBound.get().referencedClasses());\n+    for (TypeName bound : bounds) {\n+      builder.addAll(bound.referencedClasses());\n     }\n     return builder.build();\n   }\n@@ -50,24 +80,36 @@ public final class TypeVariableName implements TypeName {\n   @Override\n   public Appendable write(Appendable appendable, Context context) throws IOException {\n     appendable.append(name);\n-    if (extendsBound.isPresent()) {\n-      appendable.append(' ');\n-      extendsBound.get().write(appendable, context);\n-    }\n-    if (superBound.isPresent()) {\n-      appendable.append(' ');\n-      superBound.get().write(appendable, context);\n+    Iterator<TypeName> boundsIterator = bounds.iterator();\n+    if (boundsIterator.hasNext()) {\n+      appendable.append(\" extends \");\n+      boundsIterator.next().write(appendable, context);\n+      while (boundsIterator.hasNext()) {\n+        appendable.append(\" & \");\n+        boundsIterator.next().write(appendable, context);\n+      }\n     }\n     return appendable;\n   }\n \n   @Override\n-  public String toString() {\n-    return Writables.writeToString(this);\n+  public boolean equals(Object obj) {\n+    if (obj instanceof TypeVariableName) {\n+      TypeVariableName that = (TypeVariableName) obj;\n+      return this.name.equals(that.name)\n+          && this.bounds.equals(that.bounds);\n+    } else {\n+      return false;\n+    }\n   }\n \n-  static TypeVariableName named(String name) {\n-    return new TypeVariableName(\n-        name, Optional.<TypeName>absent(), Optional.<TypeName>absent());\n+  @Override\n+  public int hashCode() {\n+    return Objects.hashCode(name, bounds);\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return Writables.writeToString(this);\n   }\n }\n"
    },
    {
        "commit_hash": "b734b83719da16b10ed35a78162e93161e4614f1",
        "previous_commit_hash": "65542253247f648482c5239c59d2d3cded79bb4b",
        "diff_stats": {
            "additions": 32,
            "deletions": 0
        },
        "diff_content": "@@ -15,10 +15,13 @@\n  */\n package com.squareup.javawriter;\n \n+import com.google.common.collect.ImmutableList;\n import com.google.testing.compile.CompilationRule;\n import java.nio.charset.Charset;\n+import java.util.List;\n import java.util.Set;\n import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.TypeParameterElement;\n import javax.lang.model.type.DeclaredType;\n import javax.lang.model.type.TypeKind;\n import javax.lang.model.type.TypeMirror;\n@@ -59,6 +62,35 @@ public class TypeNamesTest {\n         .isEqualTo(ParameterizedTypeName.create(Set.class, ClassName.fromClass(Object.class)));\n   }\n \n+  static class Parameterized<\n+      Simple,\n+      ExtendsClass extends Number,\n+      ExtendsInterface extends Runnable,\n+      ExtendsTypeVariable extends Simple,\n+      Intersection extends Number & Runnable> {}\n+\n+  @Test\n+  public void forTypeMirror_typeVariable() {\n+    List<? extends TypeParameterElement> typeVariables =\n+        getElement(Parameterized.class).getTypeParameters();\n+\n+    assert_().that(TypeNames.forTypeMirror(typeVariables.get(0).asType()))\n+        .isEqualTo(TypeVariableName.named(\"Simple\"));\n+    assert_().that(TypeNames.forTypeMirror(typeVariables.get(1).asType()))\n+        .isEqualTo(new TypeVariableName(\"ExtendsClass\", ImmutableList.<TypeName>of(\n+            ClassName.fromClass(Number.class))));\n+    assert_().that(TypeNames.forTypeMirror(typeVariables.get(2).asType()))\n+        .isEqualTo(new TypeVariableName(\"ExtendsInterface\", ImmutableList.<TypeName>of(\n+            ClassName.fromClass(Runnable.class))));\n+    assert_().that(TypeNames.forTypeMirror(typeVariables.get(3).asType()))\n+        .isEqualTo(new TypeVariableName(\"ExtendsTypeVariable\", ImmutableList.<TypeName>of(\n+            TypeVariableName.named(\"Simple\"))));\n+    assert_().that(TypeNames.forTypeMirror(typeVariables.get(4).asType()))\n+        .isEqualTo(new TypeVariableName(\"Intersection\", ImmutableList.<TypeName>of(\n+            ClassName.fromClass(Number.class),\n+            ClassName.fromClass(Runnable.class))));\n+  }\n+\n   @Test\n   public void forTypeMirror_primitive() {\n     assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.BOOLEAN)))\n"
    },
    {
        "commit_hash": "f431a38a1ce0bc789d48e9a4ee9bee11e5388ebb",
        "previous_commit_hash": "b734b83719da16b10ed35a78162e93161e4614f1",
        "diff_stats": {
            "additions": 13,
            "deletions": 5
        },
        "diff_content": "@@ -16,7 +16,6 @@\n package com.squareup.javawriter;\n \n import com.google.common.base.Function;\n-import com.google.common.base.Joiner;\n import com.google.common.collect.FluentIterable;\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n@@ -47,6 +46,10 @@ public final class ClassWriter extends TypeWriter {\n     return constructorWriter;\n   }\n \n+  public void addTypeVariable(TypeVariableName typeVariable) {\n+    this.typeVariables.add(typeVariable);\n+  }\n+\n   @Override\n   public Appendable write(Appendable appendable, Context context) throws IOException {\n     context = context.createSubcontext(FluentIterable.from(nestedTypeWriters)\n@@ -58,10 +61,15 @@ public final class ClassWriter extends TypeWriter {\n         .toSet());\n     writeAnnotations(appendable, context);\n     writeModifiers(appendable).append(\"class \").append(name.simpleName());\n-    if (!typeVariables.isEmpty()) {\n+    Iterator<TypeVariableName> typeVariablesIterator = typeVariables.iterator();\n+    if (typeVariablesIterator.hasNext()) {\n       appendable.append('<');\n-      Joiner.on(\", \").appendTo(appendable, typeVariables);\n-      appendable.append('>');\n+      typeVariablesIterator.next().write(appendable, context);\n+      while (typeVariablesIterator.hasNext()) {\n+        appendable.append(\", \");\n+        typeVariablesIterator.next().write(appendable, context);\n+      }\n+      appendable.append(\"> \");\n     }\n     if (supertype.isPresent()) {\n       appendable.append(\" extends \");\n@@ -115,7 +123,7 @@ public final class ClassWriter extends TypeWriter {\n     @SuppressWarnings(\"unchecked\")\n     Iterable<? extends HasClassReferences> concat =\n         Iterables.concat(nestedTypeWriters, fieldWriters.values(), constructorWriters,\n-            methodWriters, implementedTypes, supertype.asSet(), annotations);\n+            methodWriters, implementedTypes, supertype.asSet(), typeVariables, annotations);\n     return FluentIterable.from(concat)\n         .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {\n           @Override\n"
    },
    {
        "commit_hash": "f431a38a1ce0bc789d48e9a4ee9bee11e5388ebb",
        "previous_commit_hash": "b734b83719da16b10ed35a78162e93161e4614f1",
        "diff_stats": {
            "additions": 21,
            "deletions": 2
        },
        "diff_content": "@@ -19,9 +19,11 @@ import com.google.common.base.Function;\n import com.google.common.collect.FluentIterable;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import java.io.IOException;\n import java.util.Iterator;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import javax.lang.model.element.TypeElement;\n@@ -29,16 +31,22 @@ import javax.lang.model.element.TypeElement;\n import static com.google.common.base.Preconditions.checkArgument;\n \n public final class ConstructorWriter extends Modifiable implements Writable, HasClassReferences {\n+  private final List<TypeVariableName> typeVariables;\n   private final String name;\n   private final Map<String, VariableWriter> parameterWriters;\n   private final BlockWriter blockWriter;\n \n   ConstructorWriter(String name) {\n+    this.typeVariables = Lists.newArrayList();\n     this.name = name;\n     this.parameterWriters = Maps.newLinkedHashMap();\n     this.blockWriter = new BlockWriter();\n   }\n \n+  public void addTypeVariable(TypeVariableName typeVariable) {\n+    this.typeVariables.add(typeVariable);\n+  }\n+\n   public VariableWriter addParameter(Class<?> type, String name) {\n     return addParameter(ClassName.fromClass(type), name);\n   }\n@@ -71,7 +79,7 @@ public final class ConstructorWriter extends Modifiable implements Writable, Has\n   @Override\n   public Set<ClassName> referencedClasses() {\n     return FluentIterable.from(\n-        Iterables.concat(parameterWriters.values(), ImmutableList.of(blockWriter)))\n+        Iterables.concat(typeVariables, parameterWriters.values(), ImmutableList.of(blockWriter)))\n             .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {\n               @Override\n               public Set<ClassName> apply(HasClassReferences input) {\n@@ -83,7 +91,18 @@ public final class ConstructorWriter extends Modifiable implements Writable, Has\n \n   @Override\n   public Appendable write(Appendable appendable, Context context) throws IOException {\n-    writeModifiers(appendable).append(name).append('(');\n+    writeModifiers(appendable);\n+    Iterator<TypeVariableName> typeVariablesIterator = typeVariables.iterator();\n+    if (typeVariablesIterator.hasNext()) {\n+      appendable.append('<');\n+      typeVariablesIterator.next().write(appendable, context);\n+      while (typeVariablesIterator.hasNext()) {\n+        appendable.append(\", \");\n+        typeVariablesIterator.next().write(appendable, context);\n+      }\n+      appendable.append(\"> \");\n+    }\n+    appendable.append(name).append('(');\n     Iterator<VariableWriter> parameterWritersIterator = parameterWriters.values().iterator();\n     if (parameterWritersIterator.hasNext()) {\n       parameterWritersIterator.next().write(appendable, context);\n"
    },
    {
        "commit_hash": "f431a38a1ce0bc789d48e9a4ee9bee11e5388ebb",
        "previous_commit_hash": "b734b83719da16b10ed35a78162e93161e4614f1",
        "diff_stats": {
            "additions": 9,
            "deletions": 5
        },
        "diff_content": "@@ -16,7 +16,6 @@\n package com.squareup.javawriter;\n \n import com.google.common.base.Function;\n-import com.google.common.base.Joiner;\n import com.google.common.collect.FluentIterable;\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n@@ -47,10 +46,15 @@ public final class InterfaceWriter extends TypeWriter {\n         .toSet());\n     writeAnnotations(appendable, context);\n     writeModifiers(appendable).append(\"interface \").append(name.simpleName());\n-    if (!typeVariables.isEmpty()) {\n+    Iterator<TypeVariableName> typeVariablesIterator = typeVariables.iterator();\n+    if (typeVariablesIterator.hasNext()) {\n       appendable.append('<');\n-      Joiner.on(\", \").appendTo(appendable, typeVariables);\n-      appendable.append('>');\n+      typeVariablesIterator.next().write(appendable, context);\n+      while (typeVariablesIterator.hasNext()) {\n+        appendable.append(\", \");\n+        typeVariablesIterator.next().write(appendable, context);\n+      }\n+      appendable.append(\"> \");\n     }\n     if (supertype.isPresent()) {\n       appendable.append(\" extends \");\n@@ -83,7 +87,7 @@ public final class InterfaceWriter extends TypeWriter {\n     @SuppressWarnings(\"unchecked\")\n     Iterable<? extends HasClassReferences> concat =\n         Iterables.concat(nestedTypeWriters, methodWriters, implementedTypes, supertype.asSet(),\n-            annotations);\n+            typeVariables, annotations);\n     return FluentIterable.from(concat)\n         .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {\n           @Override\n"
    },
    {
        "commit_hash": "f431a38a1ce0bc789d48e9a4ee9bee11e5388ebb",
        "previous_commit_hash": "b734b83719da16b10ed35a78162e93161e4614f1",
        "diff_stats": {
            "additions": 29,
            "deletions": 9
        },
        "diff_content": "@@ -20,9 +20,11 @@ import com.google.common.base.Optional;\n import com.google.common.collect.FluentIterable;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import java.io.IOException;\n import java.util.Iterator;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import javax.lang.model.element.TypeElement;\n@@ -30,12 +32,14 @@ import javax.lang.model.element.TypeElement;\n import static com.google.common.base.Preconditions.checkArgument;\n \n public final class MethodWriter extends Modifiable implements HasClassReferences, Writable {\n+  private final List<TypeVariableName> typeVariables;\n   private final TypeName returnType;\n   private final String name;\n   private final Map<String, VariableWriter> parameterWriters;\n   private Optional<BlockWriter> body;\n \n   MethodWriter(TypeName returnType, String name) {\n+    this.typeVariables = Lists.newArrayList();\n     this.returnType = returnType;\n     this.name = name;\n     this.parameterWriters = Maps.newLinkedHashMap();\n@@ -46,6 +50,10 @@ public final class MethodWriter extends Modifiable implements HasClassReferences\n     return name;\n   }\n \n+  public void addTypeVariable(TypeVariableName typeVariable) {\n+    this.typeVariables.add(typeVariable);\n+  }\n+\n   public VariableWriter addParameter(Class<?> type, String name) {\n     return addParameter(ClassName.fromClass(type), name);\n   }\n@@ -79,6 +87,16 @@ public final class MethodWriter extends Modifiable implements HasClassReferences\n   public Appendable write(Appendable appendable, Context context) throws IOException {\n     writeAnnotations(appendable, context);\n     writeModifiers(appendable);\n+    Iterator<TypeVariableName> typeVariablesIterator = typeVariables.iterator();\n+    if (typeVariablesIterator.hasNext()) {\n+      appendable.append('<');\n+      typeVariablesIterator.next().write(appendable, context);\n+      while (typeVariablesIterator.hasNext()) {\n+        appendable.append(\", \");\n+        typeVariablesIterator.next().write(appendable, context);\n+      }\n+      appendable.append(\"> \");\n+    }\n     returnType.write(appendable, context);\n     appendable.append(' ').append(name).append('(');\n     Iterator<VariableWriter> parameterWritersIterator = parameterWriters.values().iterator();\n@@ -102,14 +120,16 @@ public final class MethodWriter extends Modifiable implements HasClassReferences\n \n   @Override\n   public Set<ClassName> referencedClasses() {\n-    return FluentIterable.from(\n-        Iterables.concat(ImmutableList.of(returnType), parameterWriters.values(), body.asSet()))\n-            .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {\n-              @Override\n-              public Set<ClassName> apply(HasClassReferences input) {\n-                return input.referencedClasses();\n-              }\n-            })\n-            .toSet();\n+    Iterable<? extends HasClassReferences> concat =\n+        Iterables.concat(typeVariables, ImmutableList.of(returnType), parameterWriters.values(),\n+            body.asSet());\n+    return FluentIterable.from(concat)\n+        .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {\n+          @Override\n+          public Set<ClassName> apply(HasClassReferences input) {\n+            return input.referencedClasses();\n+          }\n+        })\n+        .toSet();\n   }\n }\n"
    },
    {
        "commit_hash": "4654a8b2aca60d6c29ae74631b5a1604c2867d2e",
        "previous_commit_hash": "b24ebf2f5a3531ecbf21161af8fdecec59e8bfa3",
        "diff_stats": {
            "additions": 7,
            "deletions": 2
        },
        "diff_content": "@@ -152,14 +152,19 @@ public final class JavaWriter {\n       }\n     }\n \n-    appendable.append('\\n');\n+    if (importedClassIndex.isEmpty()) {\n+      appendable.append('\\n');\n+    }\n \n     CompilationUnitContext context =\n         new CompilationUnitContext(packageName, ImmutableSet.copyOf(importedClassIndex.values()));\n \n     // write types\n+    String sep = \"\";\n     for (TypeWriter typeWriter : typeWriters) {\n-      typeWriter.write(appendable, context.createSubcontext(typeNames)).append('\\n');\n+      appendable.append(sep);\n+      typeWriter.write(appendable, context.createSubcontext(typeNames));\n+      sep = \"\\n\";\n     }\n     return appendable;\n   }\n"
    },
    {
        "commit_hash": "4654a8b2aca60d6c29ae74631b5a1604c2867d2e",
        "previous_commit_hash": "b24ebf2f5a3531ecbf21161af8fdecec59e8bfa3",
        "diff_stats": {
            "additions": 46,
            "deletions": 0
        },
        "diff_content": "@@ -15,6 +15,7 @@\n  */\n package com.squareup.javawriter;\n \n+import java.util.concurrent.Executor;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n@@ -30,4 +31,49 @@ public class JavaWriterTest {\n     topClass.addField(ClassName.create(\"some.other.pkg\", \"Bottom\"), \"field\");\n     assertThat(topClass.toString()).doesNotContain(\"import some.other.pkg.Bottom;\");\n   }\n+\n+  @Test public void zeroImportsSingleNewline() {\n+    JavaWriter javaWriter = JavaWriter.inPackage(\"test\");\n+    javaWriter.addClass(\"Top\");\n+\n+    String expected = \"\"\n+        + \"package test;\\n\"\n+        + \"\\n\"\n+        + \"class Top {\";\n+\n+    assertThat(javaWriter.toString()).startsWith(expected);\n+  }\n+\n+  @Test public void newlineBetweenImports() {\n+    JavaWriter javaWriter = JavaWriter.inPackage(\"test\");\n+    ClassWriter topClass = javaWriter.addClass(\"Top\");\n+    topClass.addField(Executor.class, \"executor\");\n+\n+    String expected = \"\"\n+        + \"package test;\\n\"\n+        + \"\\n\"\n+        + \"import java.util.concurrent.Executor;\\n\"\n+        + \"\\n\"\n+        + \"class Top {\";\n+\n+    assertThat(javaWriter.toString()).startsWith(expected);\n+  }\n+\n+  @Test public void newlinesBetweenTypes() {\n+    JavaWriter javaWriter = JavaWriter.inPackage(\"test\");\n+    javaWriter.addClass(\"Top\");\n+    javaWriter.addClass(\"Middle\");\n+    javaWriter.addClass(\"Bottom\");\n+\n+    String expected = \"\"\n+        + \"package test;\\n\"\n+        + \"\\n\"\n+        + \"class Top {}\\n\"\n+        + \"\\n\"\n+        + \"class Middle {}\\n\"\n+        + \"\\n\"\n+        + \"class Bottom {}\\n\";\n+\n+    assertThat(javaWriter.toString()).isEqualTo(expected);\n+  }\n }\n"
    },
    {
        "commit_hash": "1bf20dd024be0c3e4d2aa9a3d5768e53ba93d71b",
        "previous_commit_hash": "b24ebf2f5a3531ecbf21161af8fdecec59e8bfa3",
        "diff_stats": {
            "additions": 7,
            "deletions": 0
        },
        "diff_content": "@@ -57,6 +57,13 @@ public final class AnnotationWriter implements Writable, HasClassReferences {\n           appendable.append(onlyEntry.getKey()).append(\" = \");\n         }\n         onlyEntry.getValue().write(appendable, context);\n+      } else {\n+        String sep = \"\";\n+        for (Entry<String, Writable> entry : memberMap.entrySet()) {\n+          appendable.append(sep).append(entry.getKey()).append(\" = \");\n+          entry.getValue().write(appendable, context);\n+          sep = \", \";\n+        }\n       }\n       appendable.append(')');\n     }\n"
    },
    {
        "commit_hash": "1bf20dd024be0c3e4d2aa9a3d5768e53ba93d71b",
        "previous_commit_hash": "b24ebf2f5a3531ecbf21161af8fdecec59e8bfa3",
        "diff_stats": {
            "additions": 68,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright (C) 2014 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter;\n+\n+import java.io.IOException;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+@RunWith(JUnit4.class)\n+public class AnnotationWriterTest {\n+  private final ClassName className = ClassName.bestGuessFromString(\"com.example.Thing\");\n+  private final AnnotationWriter writer = new AnnotationWriter(className);\n+\n+  @Test public void bare() throws IOException {\n+    String expected = \"@com.example.Thing\";\n+\n+    assertThat(Writables.writeToString(writer)).isEqualTo(expected);\n+  }\n+\n+  @Test public void value() throws IOException {\n+    String expected = \"@com.example.Thing(\\\"Hello, world!\\\")\";\n+\n+    writer.setValue(\"Hello, world!\");\n+\n+    assertThat(Writables.writeToString(writer)).isEqualTo(expected);\n+  }\n+\n+  @Test public void valueMember() throws IOException {\n+    String expected = \"@com.example.Thing(\\\"Hello, world!\\\")\";\n+\n+    writer.setMember(\"value\", \"Hello, world!\");\n+\n+    assertThat(Writables.writeToString(writer)).isEqualTo(expected);\n+  }\n+\n+  @Test public void singleNonValueParameter() throws IOException {\n+    String expected = \"@com.example.Thing(greeting = \\\"Hello, world!\\\")\";\n+\n+    writer.setMember(\"greeting\", \"Hello, world!\");\n+\n+    assertThat(Writables.writeToString(writer)).isEqualTo(expected);\n+  }\n+\n+  @Test public void multipleParameters() throws IOException {\n+    String expected = \"@com.example.Thing(name = \\\"Hello, world!\\\", value = 42)\";\n+\n+    writer.setMember(\"name\", \"Hello, world!\");\n+    writer.setMember(\"value\", 42);\n+\n+    assertThat(Writables.writeToString(writer)).isEqualTo(expected);\n+  }\n+}\n"
    },
    {
        "commit_hash": "79db4aa1ba39810120c51785de2cbb14e317be88",
        "previous_commit_hash": "dcd2c68d6b1d40f8c6f0307cc32c53dbc046284f",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -81,7 +81,7 @@ public final class Snippet implements HasClassReferences, Writable {\n \n     @SuppressWarnings(\"resource\") // intentionally don't close the formatter\n     Formatter formatter = new Formatter(appendable);\n-    formatter.format(format, formattedArgsBuilder.build().toArray(new Object[0]));\n+    formatter.format(format, formattedArgsBuilder.build().toArray());\n \n     return appendable;\n   }\n@@ -102,11 +102,11 @@ public final class Snippet implements HasClassReferences, Writable {\n     return new Snippet(format, types.build(), ImmutableList.copyOf(args));\n   }\n \n-  public static Snippet format(String format, Iterable<? extends Object> args) {\n+  public static Snippet format(String format, Iterable<?> args) {\n     return format(format, Iterables.toArray(args, Object.class));\n   }\n \n-  public static Snippet memberSelectSnippet(Iterable<? extends Object> selectors) {\n+  public static Snippet memberSelectSnippet(Iterable<?> selectors) {\n     return format(Joiner.on('.').join(Collections.nCopies(Iterables.size(selectors), \"%s\")),\n         selectors);\n   }\n"
    },
    {
        "commit_hash": "b0e92a07d0ca51f073ea47d2a3c9ec9b81500ddf",
        "previous_commit_hash": "dcd2c68d6b1d40f8c6f0307cc32c53dbc046284f",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -152,7 +152,7 @@ public final class JavaWriter {\n       }\n     }\n \n-    if (importedClassIndex.isEmpty()) {\n+    if (!importedClassIndex.isEmpty()) {\n       appendable.append('\\n');\n     }\n \n"
    },
    {
        "commit_hash": "f1385e935a66792a65cfd4ffd14e11485fa41659",
        "previous_commit_hash": "b0e92a07d0ca51f073ea47d2a3c9ec9b81500ddf",
        "diff_stats": {
            "additions": 5,
            "deletions": 1
        },
        "diff_content": "@@ -1,4 +1,8 @@\n language: java\n \n+jdk:\n+  - oraclejdk7\n+  - oraclejdk8\n+\n notifications:\n-  email: false\n\\ No newline at end of file\n+  email: false\n"
    },
    {
        "commit_hash": "f1385e935a66792a65cfd4ffd14e11485fa41659",
        "previous_commit_hash": "b0e92a07d0ca51f073ea47d2a3c9ec9b81500ddf",
        "diff_stats": {
            "additions": 62,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright (C) 2014 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter;\n+\n+import com.google.common.base.Function;\n+import com.google.common.collect.FluentIterable;\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+\n+final class IntersectionTypeName implements TypeName {\n+  private final List<TypeName> typeNames;\n+\n+  IntersectionTypeName(List<TypeName> typeNames) {\n+    this.typeNames = typeNames;\n+  }\n+\n+  @Override public Set<ClassName> referencedClasses() {\n+    return FluentIterable.from(typeNames)\n+        .transformAndConcat(new Function<TypeName, Iterable<ClassName>>() {\n+          @Override public Iterable<ClassName> apply(TypeName input) {\n+            return input.referencedClasses();\n+          }\n+        })\n+        .toSet();\n+  }\n+\n+  @Override public Appendable write(Appendable appendable, Context context) throws IOException {\n+    Iterator<TypeName> iterator = typeNames.iterator();\n+    if (iterator.hasNext()) {\n+      iterator.next().write(appendable, context);\n+      while (iterator.hasNext()) {\n+        appendable.append(\" & \");\n+        iterator.next().write(appendable, context);\n+      }\n+    }\n+    return appendable;\n+  }\n+\n+  @Override public int hashCode() {\n+    return typeNames.hashCode();\n+  }\n+\n+  @Override public boolean equals(Object obj) {\n+    return obj instanceof IntersectionTypeName\n+        && ((IntersectionTypeName) obj).typeNames.equals(typeNames);\n+  }\n+}\n"
    },
    {
        "commit_hash": "f1385e935a66792a65cfd4ffd14e11485fa41659",
        "previous_commit_hash": "b0e92a07d0ca51f073ea47d2a3c9ec9b81500ddf",
        "diff_stats": {
            "additions": 24,
            "deletions": 0
        },
        "diff_content": "@@ -17,6 +17,9 @@ package com.squareup.javawriter;\n \n import com.google.common.base.Function;\n import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.Lists;\n+import java.lang.reflect.Method;\n+import java.util.List;\n import javax.lang.model.element.TypeElement;\n import javax.lang.model.type.ArrayType;\n import javax.lang.model.type.DeclaredType;\n@@ -55,6 +58,27 @@ public final class TypeNames {\n         throw new IllegalArgumentException(e.toString());\n       }\n \n+      @Override\n+      public TypeName visitUnknown(TypeMirror t, Void p) {\n+        for (Class<?> implementedInterface : t.getClass().getInterfaces()) {\n+          if (\"javax.lang.model.type.IntersectionType\".equals(implementedInterface.getName())) {\n+            return visitIntersectionType(t);\n+          }\n+        }\n+        return super.visitUnknown(t, p);\n+      }\n+\n+      @SuppressWarnings(\"unchecked\") // Gross things in support of Java 8.\n+      private TypeName visitIntersectionType(TypeMirror t) {\n+        try {\n+          Method method = t.getClass().getMethod(\"getBounds\");\n+          List<? extends TypeMirror> bounds = (List<? extends TypeMirror>) method.invoke(t);\n+          return new IntersectionTypeName(Lists.transform(bounds, FOR_TYPE_MIRROR));\n+        } catch (Exception e) {\n+          throw new RuntimeException(e);\n+        }\n+      }\n+\n       @Override\n       public ArrayTypeName visitArray(ArrayType t, Void p) {\n         return new ArrayTypeName(t.getComponentType().accept(this, null));\n"
    },
    {
        "commit_hash": "f1385e935a66792a65cfd4ffd14e11485fa41659",
        "previous_commit_hash": "b0e92a07d0ca51f073ea47d2a3c9ec9b81500ddf",
        "diff_stats": {
            "additions": 22,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,22 @@\n+/*\n+ * Copyright (C) 2014 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter;\n+\n+final class TestUtil {\n+  static boolean isJava8() {\n+    return Double.parseDouble(System.getProperty(\"java.version\").substring(0, 3)) >= 1.8;\n+  }\n+}\n"
    },
    {
        "commit_hash": "f1385e935a66792a65cfd4ffd14e11485fa41659",
        "previous_commit_hash": "b0e92a07d0ca51f073ea47d2a3c9ec9b81500ddf",
        "diff_stats": {
            "additions": 22,
            "deletions": 0
        },
        "diff_content": "@@ -31,6 +31,8 @@ import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n \n import static com.google.common.truth.Truth.assert_;\n+import static com.squareup.javawriter.TestUtil.isJava8;\n+import static org.junit.Assume.assumeTrue;\n \n @RunWith(JUnit4.class)\n public class TypeNamesTest {\n@@ -85,12 +87,32 @@ public class TypeNamesTest {\n     assert_().that(TypeNames.forTypeMirror(typeVariables.get(3).asType()))\n         .isEqualTo(new TypeVariableName(\"ExtendsTypeVariable\", ImmutableList.<TypeName>of(\n             TypeVariableName.named(\"Simple\"))));\n+  }\n+\n+  @Test\n+  public void forTypeMirror_intersectionType() {\n+    assumeTrue(!isJava8());\n+\n+    List<? extends TypeParameterElement> typeVariables =\n+        getElement(Parameterized.class).getTypeParameters();\n     assert_().that(TypeNames.forTypeMirror(typeVariables.get(4).asType()))\n         .isEqualTo(new TypeVariableName(\"Intersection\", ImmutableList.<TypeName>of(\n             ClassName.fromClass(Number.class),\n             ClassName.fromClass(Runnable.class))));\n   }\n \n+  @Test\n+  public void forTypeMirror_intersectionTypeJava8() {\n+    assumeTrue(isJava8());\n+\n+    List<? extends TypeParameterElement> typeVariables =\n+        getElement(Parameterized.class).getTypeParameters();\n+    assert_().that(TypeNames.forTypeMirror(typeVariables.get(4).asType()))\n+        .isEqualTo(new TypeVariableName(\"Intersection\", ImmutableList.<TypeName>of(\n+            new IntersectionTypeName(ImmutableList.<TypeName>of(ClassName.fromClass(Number.class),\n+                ClassName.fromClass(Runnable.class))))));\n+  }\n+\n   @Test\n   public void forTypeMirror_primitive() {\n     assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.BOOLEAN)))\n"
    },
    {
        "commit_hash": "feef1fe2fd851d5a0caadad0db1264b99a30ff99",
        "previous_commit_hash": "75a9dad2e820a2ad9cfb0008a25f7c23f77b517e",
        "diff_stats": {
            "additions": 16,
            "deletions": 0
        },
        "diff_content": "@@ -16,6 +16,7 @@\n package com.squareup.javawriter;\n \n import com.google.common.base.Function;\n+import com.google.common.base.Optional;\n import com.google.common.collect.FluentIterable;\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n@@ -25,21 +26,36 @@ import java.util.Iterator;\n import java.util.List;\n import java.util.Set;\n import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n \n+import static com.squareup.javawriter.Writables.writeToString;\n import static javax.lang.model.element.Modifier.PRIVATE;\n import static javax.lang.model.element.Modifier.PROTECTED;\n import static javax.lang.model.element.Modifier.PUBLIC;\n \n public final class ClassWriter extends TypeWriter {\n+  private Optional<TypeName> supertype;\n   private final List<ConstructorWriter> constructorWriters;\n   private final List<TypeVariableName> typeVariables;\n \n   ClassWriter(ClassName className) {\n     super(className);\n+    this.supertype = Optional.absent();\n     this.constructorWriters = Lists.newArrayList();\n     this.typeVariables = Lists.newArrayList();\n   }\n \n+  public void setSupertype(TypeName typeName) {\n+    if (supertype.isPresent()) {\n+      throw new IllegalStateException(\"Supertype already set to \" + writeToString(supertype.get()));\n+    }\n+    supertype = Optional.of(typeName);\n+  }\n+\n+  public void setSupertype(TypeElement typeElement) {\n+    setSupertype(ClassName.fromTypeElement(typeElement));\n+  }\n+\n   public ConstructorWriter addConstructor() {\n     ConstructorWriter constructorWriter = new ConstructorWriter(name.simpleName());\n     constructorWriters.add(constructorWriter);\n"
    },
    {
        "commit_hash": "feef1fe2fd851d5a0caadad0db1264b99a30ff99",
        "previous_commit_hash": "75a9dad2e820a2ad9cfb0008a25f7c23f77b517e",
        "diff_stats": {
            "additions": 1,
            "deletions": 2
        },
        "diff_content": "@@ -126,8 +126,7 @@ public final class EnumWriter extends TypeWriter {\n     @SuppressWarnings(\"unchecked\")\n     Iterable<? extends HasClassReferences> concat =\n         Iterables.concat(nestedTypeWriters, constantWriters.values(), fieldWriters.values(),\n-            constructorWriters,\n-            methodWriters, implementedTypes, supertype.asSet(), annotations);\n+            constructorWriters, methodWriters, implementedTypes, annotations);\n     return FluentIterable.from(concat)\n         .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {\n           @Override\n"
    },
    {
        "commit_hash": "feef1fe2fd851d5a0caadad0db1264b99a30ff99",
        "previous_commit_hash": "75a9dad2e820a2ad9cfb0008a25f7c23f77b517e",
        "diff_stats": {
            "additions": 3,
            "deletions": 7
        },
        "diff_content": "@@ -56,13 +56,9 @@ public final class InterfaceWriter extends TypeWriter {\n       }\n       appendable.append(\"> \");\n     }\n-    if (supertype.isPresent()) {\n-      appendable.append(\" extends \");\n-      supertype.get().write(appendable, context);\n-    }\n     Iterator<TypeName> implementedTypesIterator = implementedTypes.iterator();\n     if (implementedTypesIterator.hasNext()) {\n-      appendable.append(\" implements \");\n+      appendable.append(\" extends \");\n       implementedTypesIterator.next().write(appendable, context);\n       while (implementedTypesIterator.hasNext()) {\n         appendable.append(\", \");\n@@ -86,8 +82,8 @@ public final class InterfaceWriter extends TypeWriter {\n   public Set<ClassName> referencedClasses() {\n     @SuppressWarnings(\"unchecked\")\n     Iterable<? extends HasClassReferences> concat =\n-        Iterables.concat(nestedTypeWriters, methodWriters, implementedTypes, supertype.asSet(),\n-            typeVariables, annotations);\n+        Iterables.concat(nestedTypeWriters, methodWriters, implementedTypes, typeVariables,\n+            annotations);\n     return FluentIterable.from(concat)\n         .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {\n           @Override\n"
    },
    {
        "commit_hash": "feef1fe2fd851d5a0caadad0db1264b99a30ff99",
        "previous_commit_hash": "75a9dad2e820a2ad9cfb0008a25f7c23f77b517e",
        "diff_stats": {
            "additions": 0,
            "deletions": 3
        },
        "diff_content": "@@ -15,7 +15,6 @@\n  */\n package com.squareup.javawriter;\n \n-import com.google.common.base.Optional;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import java.util.List;\n@@ -29,7 +28,6 @@ import javax.lang.model.type.TypeMirror;\n public abstract class TypeWriter /* ha ha */ extends Modifiable\n     implements Writable, HasTypeName, HasClassReferences {\n   final ClassName name;\n-  Optional<TypeName> supertype;\n   final List<TypeName> implementedTypes;\n   final List<MethodWriter> methodWriters;\n   final List<TypeWriter> nestedTypeWriters;\n@@ -37,7 +35,6 @@ public abstract class TypeWriter /* ha ha */ extends Modifiable\n \n   TypeWriter(ClassName name) {\n     this.name = name;\n-    this.supertype = Optional.absent();\n     this.implementedTypes = Lists.newArrayList();\n     this.methodWriters = Lists.newArrayList();\n     this.nestedTypeWriters = Lists.newArrayList();\n"
    },
    {
        "commit_hash": "c8126634a05d631d158a2841b655d3fa4992aa39",
        "previous_commit_hash": "75a9dad2e820a2ad9cfb0008a25f7c23f77b517e",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -48,7 +48,7 @@ public final class ConstructorWriter extends Modifiable implements Writable, Has\n   }\n \n   public VariableWriter addParameter(Class<?> type, String name) {\n-    return addParameter(ClassName.fromClass(type), name);\n+    return addParameter(TypeNames.forClass(type), name);\n   }\n \n   public VariableWriter addParameter(TypeElement type, String name) {\n"
    },
    {
        "commit_hash": "c8126634a05d631d158a2841b655d3fa4992aa39",
        "previous_commit_hash": "75a9dad2e820a2ad9cfb0008a25f7c23f77b517e",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -55,7 +55,7 @@ public final class MethodWriter extends Modifiable implements HasClassReferences\n   }\n \n   public VariableWriter addParameter(Class<?> type, String name) {\n-    return addParameter(ClassName.fromClass(type), name);\n+    return addParameter(TypeNames.forClass(type), name);\n   }\n \n   public VariableWriter addParameter(TypeElement type, String name) {\n"
    },
    {
        "commit_hash": "c8126634a05d631d158a2841b655d3fa4992aa39",
        "previous_commit_hash": "75a9dad2e820a2ad9cfb0008a25f7c23f77b517e",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -70,7 +70,7 @@ public abstract class TypeWriter /* ha ha */ extends Modifiable\n \n   public MethodWriter addMethod(Class<?> returnType, String name) {\n     MethodWriter methodWriter =\n-        new MethodWriter(ClassName.fromClass(returnType), name);\n+        new MethodWriter(TypeNames.forClass(returnType), name);\n     methodWriters.add(methodWriter);\n     return methodWriter;\n   }\n@@ -90,7 +90,7 @@ public abstract class TypeWriter /* ha ha */ extends Modifiable\n   }\n \n   public FieldWriter addField(Class<?> type, String name) {\n-    return addField(ClassName.fromClass(type), name);\n+    return addField(TypeNames.forClass(type), name);\n   }\n \n   public FieldWriter addField(TypeElement type, String name) {\n"
    },
    {
        "commit_hash": "5d80ff31bcc2bcc4d2abaf2e4c8583c1cc8644ed",
        "previous_commit_hash": "75a9dad2e820a2ad9cfb0008a25f7c23f77b517e",
        "diff_stats": {
            "additions": 6,
            "deletions": 0
        },
        "diff_content": "@@ -153,6 +153,12 @@ public final class ClassName implements TypeName, Comparable<ClassName> {\n \n   public static ClassName fromClass(Class<?> clazz) {\n     checkNotNull(clazz);\n+    checkArgument(!clazz.isPrimitive(),\n+        \"Primitive types cannot be represented as a ClassName. Use TypeNames.forClass instead.\");\n+    checkArgument(!void.class.equals(clazz),\n+        \"'void' type cannot be represented as a ClassName. Use TypeNames.forClass instead.\");\n+    checkArgument(!clazz.isArray(),\n+        \"Array types cannot be represented as a ClassName. Use TypeNames.forClass instead.\");\n     List<String> enclosingNames = new ArrayList<String>();\n     Class<?> current = clazz.getEnclosingClass();\n     while (current != null) {\n"
    },
    {
        "commit_hash": "5d80ff31bcc2bcc4d2abaf2e4c8583c1cc8644ed",
        "previous_commit_hash": "75a9dad2e820a2ad9cfb0008a25f7c23f77b517e",
        "diff_stats": {
            "additions": 18,
            "deletions": 0
        },
        "diff_content": "@@ -108,4 +108,22 @@ public class ClassNameTest {\n     assert_().that(peerName.canonicalName())\n         .isEqualTo(\"com.squareup.javawriter.ClassNameTest.OuterClass.Foo\");\n   }\n+\n+  @Test public void fromClassRejectionTypes() {\n+    try {\n+      ClassName.fromClass(int.class);\n+      fail();\n+    } catch (IllegalArgumentException ignored) {\n+    }\n+    try {\n+      ClassName.fromClass(void.class);\n+      fail();\n+    } catch (IllegalArgumentException ignored) {\n+    }\n+    try {\n+      ClassName.fromClass(Object[].class);\n+      fail();\n+    } catch (IllegalArgumentException ignored) {\n+    }\n+  }\n }\n"
    },
    {
        "commit_hash": "c81cbb15baa25e24ac7360b6a7d15976b8271b1b",
        "previous_commit_hash": "dc7714e71d267b911ecb2070b93f6b084062fc50",
        "diff_stats": {
            "additions": 27,
            "deletions": 0
        },
        "diff_content": "@@ -676,6 +676,15 @@ public class JavaWriter implements Closeable {\n     return this;\n   }\n \n+  /**\n+   * @param controlFlow the control flow construct and its code, such as \"if (foo == 5)\". Shouldn't\n+   *     contain braces or newline characters.\n+   */\n+  // NOTE: This method is for binary compatibility with previous versions.\n+  public JavaWriter beginControlFlow(String controlFlow) throws IOException {\n+    return beginControlFlow(controlFlow, new Object[0]);\n+  }\n+\n   /**\n    * @param controlFlow the control flow construct and its code, such as \"if (foo == 5)\". Shouldn't\n    *     contain braces or newline characters.\n@@ -689,6 +698,15 @@ public class JavaWriter implements Closeable {\n     return this;\n   }\n \n+  /**\n+   * @param controlFlow the control flow construct and its code, such as \"else if (foo == 10)\".\n+   *     Shouldn't contain braces or newline characters.\n+   */\n+  // NOTE: This method is for binary compatibility with previous versions.\n+  public JavaWriter nextControlFlow(String controlFlow) throws IOException {\n+    return nextControlFlow(controlFlow, new Object[0]);\n+  }\n+\n   /**\n    * @param controlFlow the control flow construct and its code, such as \"else if (foo == 10)\".\n    *     Shouldn't contain braces or newline characters.\n@@ -707,6 +725,15 @@ public class JavaWriter implements Closeable {\n     return endControlFlow(null);\n   }\n \n+  /**\n+   * @param controlFlow the optional control flow construct and its code, such as\n+   *     \"while(foo == 20)\". Only used for \"do/while\" control flows.\n+   */\n+  // NOTE: This method is for binary compatibility with previous versions.\n+  public JavaWriter endControlFlow(String controlFlow) throws IOException {\n+    return endControlFlow(controlFlow, new Object[0]);\n+  }\n+\n   /**\n    * @param controlFlow the optional control flow construct and its code, such as\n    *     \"while(foo == 20)\". Only used for \"do/while\" control flows.\n"
    },
    {
        "commit_hash": "4e958e1e8c11964b5c72e9f16ce03c959fdeeb56",
        "previous_commit_hash": "b34b67c7a239cd0f7dee0a939fd9776cbff5c4d9",
        "diff_stats": {
            "additions": 9,
            "deletions": 0
        },
        "diff_content": "@@ -1,6 +1,15 @@\n Change Log\n ==========\n \n+Version 2.5.1 *(2014-12-03)*\n+----------------------------\n+\n+ * New: `StringLiteral` type which encapsulates the behavior of `stringLiteral`.\n+ * Fix: Use canonical name when emitting a class import.\n+ * Fix: Apply type compression to varargs and array types.\n+ * Fix: Restore binary compatibility with pre-2.5 versions.\n+\n+\n Version 2.5.0 *(2014-04-18)*\n ----------------------------\n \n"
    },
    {
        "commit_hash": "4e958e1e8c11964b5c72e9f16ce03c959fdeeb56",
        "previous_commit_hash": "b34b67c7a239cd0f7dee0a939fd9776cbff5c4d9",
        "diff_stats": {
            "additions": 5,
            "deletions": 2
        },
        "diff_content": "@@ -47,14 +47,17 @@ Download\n --------\n \n Download [the latest .jar][dl] or depend via Maven:\n-\n ```xml\n <dependency>\n   <groupId>com.squareup</groupId>\n   <artifactId>javawriter</artifactId>\n-  <version>(insert latest version)</version>\n+  <version>2.5.1</version>\n </dependency>\n ```\n+or Gradle:\n+```groovy\n+compile 'com.squareup:javawriter:2.5.1'\n+```\n \n \n \n"
    },
    {
        "commit_hash": "ffe1e0d82c97e2be0524dcbb42b12ee4de74df54",
        "previous_commit_hash": "4e958e1e8c11964b5c72e9f16ce03c959fdeeb56",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javawriter</artifactId>\n-  <version>2.5.1-SNAPSHOT</version>\n+  <version>2.5.1</version>\n \n   <name>JavaWriter</name>\n   <description>A utility class which aids in generating Java source files.</description>\n"
    },
    {
        "commit_hash": "e5cc0839c88ecdb5b862fbb5b8a6f7dac9a40268",
        "previous_commit_hash": "ffe1e0d82c97e2be0524dcbb42b12ee4de74df54",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javawriter</artifactId>\n-  <version>2.5.1</version>\n+  <version>2.5.2-SNAPSHOT</version>\n \n   <name>JavaWriter</name>\n   <description>A utility class which aids in generating Java source files.</description>\n"
    },
    {
        "commit_hash": "c76913f26d4bddeb78a4431fec98bf56fff31918",
        "previous_commit_hash": "3c3d614f93a45fb48c2a434af3ef67688d7c6830",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -20,7 +20,7 @@\n   <properties>\n     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n \n-    <java.version>1.6</java.version>\n+    <java.version>1.7</java.version>\n     <junit.version>4.10</junit.version>\n     <guava.version>18.0</guava.version>\n     <truth.version>1.0-SNAPSHOT</truth.version>\n"
    },
    {
        "commit_hash": "c76913f26d4bddeb78a4431fec98bf56fff31918",
        "previous_commit_hash": "3c3d614f93a45fb48c2a434af3ef67688d7c6830",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -22,9 +22,9 @@ import com.google.common.base.Optional;\n import com.google.common.base.Splitter;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n import java.io.IOException;\n-import java.util.ArrayList;\n import java.util.Collections;\n import java.util.Iterator;\n import java.util.List;\n@@ -138,7 +138,7 @@ public final class ClassName implements TypeName, Comparable<ClassName> {\n     checkNotNull(element);\n     checkArgument(ACCEPTABLE_NESTING_KINDS.contains(element.getNestingKind()));\n     String simpleName = element.getSimpleName().toString();\n-    List<String> enclosingNames = new ArrayList<String>();\n+    List<String> enclosingNames = Lists.newArrayList();\n     Element current = element.getEnclosingElement();\n     while (current.getKind().isClass() || current.getKind().isInterface()) {\n       checkArgument(ACCEPTABLE_NESTING_KINDS.contains(element.getNestingKind()));\n@@ -159,7 +159,7 @@ public final class ClassName implements TypeName, Comparable<ClassName> {\n         \"'void' type cannot be represented as a ClassName. Use TypeNames.forClass instead.\");\n     checkArgument(!clazz.isArray(),\n         \"Array types cannot be represented as a ClassName. Use TypeNames.forClass instead.\");\n-    List<String> enclosingNames = new ArrayList<String>();\n+    List<String> enclosingNames = Lists.newArrayList();\n     Class<?> current = clazz.getEnclosingClass();\n     while (current != null) {\n       enclosingNames.add(current.getSimpleName());\n"
    },
    {
        "commit_hash": "c76913f26d4bddeb78a4431fec98bf56fff31918",
        "previous_commit_hash": "3c3d614f93a45fb48c2a434af3ef67688d7c6830",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -53,7 +53,7 @@ public final class WildcardName implements TypeName {\n \n   @Override\n   public Set<ClassName> referencedClasses() {\n-    ImmutableSet.Builder<ClassName> builder = new ImmutableSet.Builder<ClassName>();\n+    ImmutableSet.Builder<ClassName> builder = ImmutableSet.builder();\n     if (extendsBound.isPresent()) {\n       builder.addAll(extendsBound.get().referencedClasses());\n     }\n"
    },
    {
        "commit_hash": "d8fc3fa90c9f90da7e0af5a30e3ca74f433783bd",
        "previous_commit_hash": "3fc1be2e414a86b933676eea644b0ff80feb58bb",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -21,7 +21,7 @@\n     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n \n     <java.version>1.7</java.version>\n-    <junit.version>4.10</junit.version>\n+    <junit.version>4.12</junit.version>\n     <guava.version>18.0</guava.version>\n     <truth.version>1.0-SNAPSHOT</truth.version>\n     <compile-testing.version>1.0-SNAPSHOT</compile-testing.version>\n"
    },
    {
        "commit_hash": "c716d5c44e7ef7e0d55ab388740a6af9ca8edf79",
        "previous_commit_hash": "3fc1be2e414a86b933676eea644b0ff80feb58bb",
        "diff_stats": {
            "additions": 0,
            "deletions": 1
        },
        "diff_content": "@@ -89,7 +89,6 @@\n     <!-- See http://checkstyle.sf.net/config_coding.html -->\n     <!--module name=\"AvoidInlineConditionals\"/-->\n     <module name=\"CovariantEquals\"/>\n-    <module name=\"DoubleCheckedLocking\"/>\n     <module name=\"EmptyStatement\"/>\n     <!--<module name=\"EqualsAvoidNull\"/>-->\n     <module name=\"EqualsHashCode\"/>\n"
    },
    {
        "commit_hash": "c716d5c44e7ef7e0d55ab388740a6af9ca8edf79",
        "previous_commit_hash": "3fc1be2e414a86b933676eea644b0ff80feb58bb",
        "diff_stats": {
            "additions": 7,
            "deletions": 1
        },
        "diff_content": "@@ -75,6 +75,12 @@\n       <version>${junit.version}</version>\n       <scope>test</scope>\n     </dependency>\n+    <dependency>\n+      <groupId>com.google.jimfs</groupId>\n+      <artifactId>jimfs</artifactId>\n+      <version>1.0</version>\n+      <scope>test</scope>\n+    </dependency>\n   </dependencies>\n \n   <build>\n@@ -92,7 +98,7 @@\n       <plugin>\n         <groupId>org.apache.maven.plugins</groupId>\n         <artifactId>maven-checkstyle-plugin</artifactId>\n-        <version>2.9.1</version>\n+        <version>2.13</version>\n         <configuration>\n           <failsOnError>true</failsOnError>\n           <configLocation>checkstyle.xml</configLocation>\n"
    },
    {
        "commit_hash": "c716d5c44e7ef7e0d55ab388740a6af9ca8edf79",
        "previous_commit_hash": "3fc1be2e414a86b933676eea644b0ff80feb58bb",
        "diff_stats": {
            "additions": 6,
            "deletions": 0
        },
        "diff_content": "@@ -28,12 +28,18 @@ import java.util.Set;\n import javax.lang.model.element.Modifier;\n import javax.lang.model.element.TypeElement;\n \n+import static com.google.common.base.Preconditions.checkArgument;\n import static com.squareup.javawriter.Writables.writeToString;\n import static javax.lang.model.element.Modifier.PRIVATE;\n import static javax.lang.model.element.Modifier.PROTECTED;\n import static javax.lang.model.element.Modifier.PUBLIC;\n \n public final class ClassWriter extends TypeWriter {\n+  public static ClassWriter forClassName(ClassName name) {\n+    checkArgument(name.enclosingSimpleNames().isEmpty(), \"%s must be top-level type.\", name);\n+    return new ClassWriter(name);\n+  }\n+\n   private Optional<TypeName> supertype;\n   private final List<ConstructorWriter> constructorWriters;\n   private final List<TypeVariableName> typeVariables;\n"
    },
    {
        "commit_hash": "c716d5c44e7ef7e0d55ab388740a6af9ca8edf79",
        "previous_commit_hash": "3fc1be2e414a86b933676eea644b0ff80feb58bb",
        "diff_stats": {
            "additions": 6,
            "deletions": 0
        },
        "diff_content": "@@ -29,12 +29,18 @@ import java.util.Map;\n import java.util.Set;\n import javax.lang.model.element.Modifier;\n \n+import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n import static javax.lang.model.element.Modifier.PRIVATE;\n import static javax.lang.model.element.Modifier.PROTECTED;\n import static javax.lang.model.element.Modifier.PUBLIC;\n \n public final class EnumWriter extends TypeWriter {\n+  public static EnumWriter forClassName(ClassName name) {\n+    checkArgument(name.enclosingSimpleNames().isEmpty(), \"%s must be top-level type.\", name);\n+    return new EnumWriter(name);\n+  }\n+\n   private final Map<String, ConstantWriter> constantWriters = Maps.newLinkedHashMap();\n   private final List<ConstructorWriter> constructorWriters = Lists.newArrayList();\n \n"
    },
    {
        "commit_hash": "c716d5c44e7ef7e0d55ab388740a6af9ca8edf79",
        "previous_commit_hash": "3fc1be2e414a86b933676eea644b0ff80feb58bb",
        "diff_stats": {
            "additions": 7,
            "deletions": 0
        },
        "diff_content": "@@ -24,7 +24,14 @@ import java.util.Iterator;\n import java.util.List;\n import java.util.Set;\n \n+import static com.google.common.base.Preconditions.checkArgument;\n+\n public final class InterfaceWriter extends TypeWriter {\n+  public static InterfaceWriter forClassName(ClassName name) {\n+    checkArgument(name.enclosingSimpleNames().isEmpty(), \"%s must be top-level type.\", name);\n+    return new InterfaceWriter(name);\n+  }\n+\n   private final List<TypeVariableName> typeVariables;\n   InterfaceWriter(ClassName name) {\n     super(name);\n"
    },
    {
        "commit_hash": "c716d5c44e7ef7e0d55ab388740a6af9ca8edf79",
        "previous_commit_hash": "3fc1be2e414a86b933676eea644b0ff80feb58bb",
        "diff_stats": {
            "additions": 71,
            "deletions": 199
        },
        "diff_content": "@@ -15,246 +15,118 @@\n  */\n package com.squareup.javawriter;\n \n-import com.google.common.base.Function;\n-import com.google.common.base.Optional;\n-import com.google.common.collect.BiMap;\n-import com.google.common.collect.FluentIterable;\n-import com.google.common.collect.HashBiMap;\n import com.google.common.collect.ImmutableSet;\n-import com.google.common.collect.ImmutableSortedSet;\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n-import com.google.common.collect.Ordering;\n-import com.google.common.collect.Queues;\n-import com.google.common.collect.Sets;\n import com.google.common.io.Closer;\n-import com.squareup.javawriter.Writable.Context;\n+import java.io.File;\n+import java.io.FileWriter;\n import java.io.IOException;\n-import java.util.Deque;\n+import java.io.OutputStreamWriter;\n+import java.io.Writer;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n import java.util.List;\n-import java.util.Set;\n import javax.annotation.processing.Filer;\n import javax.lang.model.element.Element;\n-import javax.lang.model.element.PackageElement;\n import javax.tools.JavaFileObject;\n \n-import static com.google.common.base.Preconditions.checkNotNull;\n-import static java.util.Collections.unmodifiableList;\n+import static com.google.common.base.Preconditions.checkArgument;\n \n-/**\n- * Writes a single compilation unit.\n- */\n public final class JavaWriter {\n-  public static JavaWriter inPackage(String packageName) {\n-    return new JavaWriter(packageName);\n-  }\n-\n-  public static JavaWriter inPackage(Package enclosingPackage) {\n-    return new JavaWriter(enclosingPackage.getName());\n+  /** Create a new Java writer for writing multiple types to a single location. */\n+  public static JavaWriter create() {\n+    return new JavaWriter();\n   }\n \n-  public static JavaWriter inPackage(PackageElement packageElement) {\n-    return new JavaWriter(packageElement.getQualifiedName().toString());\n-  }\n-\n-  private final String packageName;\n-  // TODO(gak): disallow multiple types in a file?\n   private final List<TypeWriter> typeWriters;\n-  private final List<ClassName> explicitImports;\n-\n-  private JavaWriter(String packageName) {\n-    this.packageName = packageName;\n-    this.typeWriters = Lists.newArrayList();\n-    this.explicitImports = Lists.newArrayList();\n-  }\n \n-  public List<TypeWriter> getTypeWriters() {\n-    return unmodifiableList(typeWriters);\n+  private JavaWriter() {\n+    typeWriters = Lists.newArrayList();\n+    // TODO take in options! indent, what else?\n   }\n \n-  public JavaWriter addImport(Class<?> importedClass) {\n-    explicitImports.add(ClassName.fromClass(importedClass));\n+  public JavaWriter addTypeWriter(TypeWriter typeWriter) {\n+    typeWriters.add(typeWriter);\n     return this;\n   }\n \n-  public ClassWriter addClass(String simpleName) {\n-    checkNotNull(simpleName);\n-    ClassWriter classWriter = new ClassWriter(ClassName.create(packageName, simpleName));\n-    typeWriters.add(classWriter);\n-    return classWriter;\n-  }\n-\n-  public EnumWriter addEnum(String simpleName) {\n-    checkNotNull(simpleName);\n-    EnumWriter writer = new EnumWriter(ClassName.create(simpleName, simpleName));\n-    typeWriters.add(writer);\n-    return writer;\n-  }\n-\n-  public InterfaceWriter addInterface(String simpleName) {\n-    InterfaceWriter writer = new InterfaceWriter(ClassName.create(packageName, simpleName));\n-    typeWriters.add(writer);\n-    return writer;\n+  public JavaWriter addTypeWriters(Iterable<? extends TypeWriter> typeWriters) {\n+    Iterables.addAll(this.typeWriters, typeWriters);\n+    return this;\n   }\n \n-  public Appendable write(Appendable appendable) throws IOException {\n-    appendable.append(\"package \").append(packageName).append(';').append(\"\\n\\n\");\n-\n-    // write imports\n-    ImmutableSet<ClassName> classNames = FluentIterable.from(typeWriters)\n-        .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {\n-          @Override\n-          public Set<ClassName> apply(HasClassReferences input) {\n-            return input.referencedClasses();\n-          }\n-        })\n-        .toSet();\n+  public void writeTo(Path directory) throws IOException {\n+    checkArgument(Files.notExists(directory) || Files.isDirectory(directory),\n+        \"Path %s exists but is not a directory.\", directory);\n+    for (TypeWriter typeWriter : typeWriters) {\n+      ClassName typeName = typeWriter.name();\n+      String packageName = typeName.packageName();\n \n-    ImmutableSortedSet<ClassName> importCandidates = ImmutableSortedSet.<ClassName>naturalOrder()\n-        .addAll(explicitImports)\n-        .addAll(classNames)\n-        .build();\n-    ImmutableSet<ClassName> typeNames = FluentIterable.from(typeWriters)\n-        .transform(new Function<TypeWriter, ClassName>() {\n-          @Override public ClassName apply(TypeWriter input) {\n-            return input.name;\n-          }\n-        })\n-        .toSet();\n+      Path outputDirectory = directory;\n+      if (!packageName.isEmpty()) {\n+        for (String packageComponent : packageName.split(\"\\\\.\")) {\n+          outputDirectory = outputDirectory.resolve(packageComponent);\n+        }\n+        Files.createDirectories(outputDirectory);\n+      }\n \n-    ImmutableSet.Builder<String> declaredSimpleNamesBuilder = ImmutableSet.builder();\n-    Deque<TypeWriter> declaredTypes = Queues.newArrayDeque(typeWriters);\n-    while (!declaredTypes.isEmpty()) {\n-      TypeWriter currentType = declaredTypes.pop();\n-      declaredSimpleNamesBuilder.add(currentType.name().simpleName());\n-      declaredTypes.addAll(currentType.nestedTypeWriters);\n+      Path outputFile = outputDirectory.resolve(typeName.simpleName() + \".java\");\n+      try (Closer closer = Closer.create()) {\n+        Writer writer = new OutputStreamWriter(Files.newOutputStream(outputFile));\n+        typeWriter.writeTypeToAppendable(closer.register(writer));\n+      }\n     }\n+  }\n \n-    ImmutableSet<String> declaredSimpleNames = declaredSimpleNamesBuilder.build();\n+  public void writeTo(File directory) throws IOException {\n+    checkArgument(!directory.exists() || directory.isDirectory(),\n+        \"File %s exists but is not a directory.\", directory);\n+    for (TypeWriter typeWriter : typeWriters) {\n+      ClassName typeName = typeWriter.name();\n+      String packageName = typeName.packageName();\n \n-    BiMap<String, ClassName> importedClassIndex = HashBiMap.create();\n-    for (ClassName className : importCandidates) {\n-      if (!(className.packageName().equals(packageName)\n-              && !className.enclosingClassName().isPresent())\n-          && !(className.packageName().equals(\"java.lang\")\n-              && className.enclosingSimpleNames().isEmpty())\n-          && !typeNames.contains(className.topLevelClassName())) {\n-        Optional<ClassName> importCandidate = Optional.of(className);\n-        while (importCandidate.isPresent()\n-            && (importedClassIndex.containsKey(importCandidate.get().simpleName())\n-                || declaredSimpleNames.contains(importCandidate.get().simpleName()))) {\n-          importCandidate = importCandidate.get().enclosingClassName();\n+      File outputDir = directory;\n+      if (!packageName.isEmpty()) {\n+        for (String packageComponent : packageName.split(\"\\\\.\")) {\n+          outputDir = new File(outputDir, packageComponent);\n         }\n-        if (importCandidate.isPresent()) {\n-          appendable.append(\"import \").append(importCandidate.get().canonicalName()).append(\";\\n\");\n-          importedClassIndex.put(importCandidate.get().simpleName(), importCandidate.get());\n+        if (!outputDir.mkdirs()) {\n+          throw new IOException(\"Unable to create directory \" + outputDir);\n         }\n       }\n-    }\n-\n-    if (!importedClassIndex.isEmpty()) {\n-      appendable.append('\\n');\n-    }\n-\n-    CompilationUnitContext context =\n-        new CompilationUnitContext(packageName, ImmutableSet.copyOf(importedClassIndex.values()));\n \n-    // write types\n-    String sep = \"\";\n-    for (TypeWriter typeWriter : typeWriters) {\n-      appendable.append(sep);\n-      typeWriter.write(appendable, context.createSubcontext(typeNames));\n-      sep = \"\\n\";\n+      File outputFile = new File(outputDir, typeName.simpleName() + \".java\");\n+      try (Closer closer = Closer.create()) {\n+        typeWriter.writeTypeToAppendable(closer.register(new FileWriter(outputFile)));\n+      }\n     }\n-    return appendable;\n   }\n \n-  public void file(Filer filer, Iterable<? extends Element> originatingElements)\n-      throws IOException {\n-    file(filer, Iterables.getOnlyElement(typeWriters).name.canonicalName(), originatingElements);\n+  public void writeTo(Filer filer) throws IOException {\n+    writeTo(filer, ImmutableSet.<Element>of());\n   }\n \n-  public void file(Filer filer, CharSequence name,  Iterable<? extends Element> originatingElements)\n+  public void writeTo(Filer filer, Iterable<? extends Element> originatingElements)\n       throws IOException {\n-    JavaFileObject sourceFile = filer.createSourceFile(name,\n-        Iterables.toArray(originatingElements, Element.class));\n-    Closer closer = Closer.create();\n-    try {\n-      write(closer.register(sourceFile.openWriter()));\n-    } catch (Exception e) {\n+    // TODO tack originatingElements on TypeWriter? Losing a top-level-only writer for this sucks.\n+    for (TypeWriter typeWriter : typeWriters) {\n+      JavaFileObject sourceFile = filer.createSourceFile(typeWriter.name().canonicalName(),\n+          Iterables.toArray(originatingElements, Element.class));\n+      Writer closeable = sourceFile.openWriter();\n+      Closer closer = Closer.create();\n       try {\n-        sourceFile.delete();\n-      } catch (Exception e2) {\n-        // couldn't delete the file\n-      }\n-      throw closer.rethrow(e);\n-    } finally {\n-      closer.close();\n-    }\n-  }\n-\n-  @Override\n-  public String toString() {\n-    try {\n-      return write(new StringBuilder()).toString();\n-    } catch (IOException e) {\n-      throw new AssertionError();\n-    }\n-  }\n-\n-  static final class CompilationUnitContext implements Writable.Context {\n-    private final String packageName;\n-    private final ImmutableSortedSet<ClassName> visibleClasses;\n-\n-    CompilationUnitContext(String packageName, Set<ClassName> visibleClasses) {\n-      this.packageName = packageName;\n-      this.visibleClasses =\n-          ImmutableSortedSet.copyOf(Ordering.natural().reverse(), visibleClasses);\n-    }\n-\n-    @Override\n-    public Context createSubcontext(Set<ClassName> newTypes) {\n-      return new CompilationUnitContext(packageName, Sets.union(visibleClasses, newTypes));\n-    }\n-\n-    @Override\n-    public String sourceReferenceForClassName(ClassName className) {\n-      if (isImported(className)) {\n-        return className.simpleName();\n-      }\n-      Optional<ClassName> enclosingClassName = className.enclosingClassName();\n-      while (enclosingClassName.isPresent()) {\n-        if (isImported(enclosingClassName.get())) {\n-          return enclosingClassName.get().simpleName()\n-              + className.canonicalName()\n-                  .substring(enclosingClassName.get().canonicalName().length());\n+        typeWriter.writeTypeToAppendable(closer.register(closeable));\n+      } catch (Exception e) {\n+        try {\n+          sourceFile.delete();\n+        } catch (Exception e2) {\n+          // Couldn't delete the file.\n         }\n-        enclosingClassName = enclosingClassName.get().enclosingClassName();\n+        throw closer.rethrow(e);\n+      } finally {\n+        closer.close();\n       }\n-      return className.canonicalName();\n-    }\n-\n-    private boolean collidesWithVisibleClass(ClassName className) {\n-      return collidesWithVisibleClass(className.simpleName());\n-    }\n-\n-    private boolean collidesWithVisibleClass(String simpleName) {\n-      return FluentIterable.from(visibleClasses)\n-          .transform(new Function<ClassName, String>() {\n-            @Override public String apply(ClassName input) {\n-              return input.simpleName();\n-            }\n-          })\n-          .contains(simpleName);\n-    }\n-\n-    private boolean isImported(ClassName className) {\n-      return (packageName.equals(className.packageName())\n-              && !className.enclosingClassName().isPresent()\n-              && !collidesWithVisibleClass(className)) // need to account for scope & hiding\n-          || visibleClasses.contains(className)\n-          || (className.packageName().equals(\"java.lang\")\n-              && className.enclosingSimpleNames().isEmpty());\n     }\n   }\n }\n"
    },
    {
        "commit_hash": "c716d5c44e7ef7e0d55ab388740a6af9ca8edf79",
        "previous_commit_hash": "3fc1be2e414a86b933676eea644b0ff80feb58bb",
        "diff_stats": {
            "additions": 139,
            "deletions": 0
        },
        "diff_content": "@@ -15,10 +15,23 @@\n  */\n package com.squareup.javawriter;\n \n+import com.google.common.base.Function;\n+import com.google.common.base.Optional;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.ImmutableSortedSet;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n+import com.google.common.collect.Ordering;\n+import com.google.common.collect.Queues;\n+import com.google.common.collect.Sets;\n+import java.io.IOException;\n+import java.util.Deque;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n import javax.lang.model.element.TypeElement;\n import javax.lang.model.type.TypeMirror;\n \n@@ -78,6 +91,18 @@ public abstract class TypeWriter /* ha ha */ extends Modifiable\n     return innerClassWriter;\n   }\n \n+  public InterfaceWriter addNestedInterface(String name) {\n+    InterfaceWriter innerInterfaceWriter = new InterfaceWriter(this.name.nestedClassNamed(name));\n+    nestedTypeWriters.add(innerInterfaceWriter);\n+    return innerInterfaceWriter;\n+  }\n+\n+  public EnumWriter addNestedEnum(String name) {\n+    EnumWriter innerEnumWriter = new EnumWriter(this.name.nestedClassNamed(name));\n+    nestedTypeWriters.add(innerEnumWriter);\n+    return innerEnumWriter;\n+  }\n+\n   public void addImplementedType(TypeName typeReference) {\n     implementedTypes.add(typeReference);\n   }\n@@ -105,4 +130,118 @@ public abstract class TypeWriter /* ha ha */ extends Modifiable\n     fieldWriters.put(candidateName, fieldWriter);\n     return fieldWriter;\n   }\n+\n+  @Override public final String toString() {\n+    try {\n+      return writeTypeToAppendable(new StringBuilder()).toString();\n+    } catch (IOException e) {\n+      throw new AssertionError(e);\n+    }\n+  }\n+\n+  Appendable writeTypeToAppendable(Appendable appendable) throws IOException {\n+    String packageName = name().packageName();\n+    appendable.append(\"package \").append(packageName).append(\";\\n\\n\");\n+\n+    ImmutableSortedSet<ClassName> importCandidates = ImmutableSortedSet.<ClassName>naturalOrder()\n+        //.addAll(explicitImports) // TODO!\n+        .addAll(referencedClasses())\n+        .build();\n+\n+    ImmutableSet.Builder<String> declaredSimpleNamesBuilder = ImmutableSet.builder();\n+    Deque<TypeWriter> declaredTypes = Queues.newArrayDeque(ImmutableSet.of(this));\n+    while (!declaredTypes.isEmpty()) {\n+      TypeWriter currentType = declaredTypes.pop();\n+      declaredSimpleNamesBuilder.add(currentType.name().simpleName());\n+      declaredTypes.addAll(currentType.nestedTypeWriters);\n+    }\n+\n+    ImmutableSet<String> declaredSimpleNames = declaredSimpleNamesBuilder.build();\n+\n+    BiMap<String, ClassName> importedClassIndex = HashBiMap.create();\n+    for (ClassName className : importCandidates) {\n+      if (!(className.packageName().equals(packageName)\n+          && !className.enclosingClassName().isPresent())\n+          && !(className.packageName().equals(\"java.lang\")\n+          && className.enclosingSimpleNames().isEmpty())\n+          && !name().equals(className.topLevelClassName())) {\n+        Optional<ClassName> importCandidate = Optional.of(className);\n+        while (importCandidate.isPresent()\n+            && (importedClassIndex.containsKey(importCandidate.get().simpleName())\n+            || declaredSimpleNames.contains(importCandidate.get().simpleName()))) {\n+          importCandidate = importCandidate.get().enclosingClassName();\n+        }\n+        if (importCandidate.isPresent()) {\n+          appendable.append(\"import \").append(importCandidate.get().canonicalName()).append(\";\\n\");\n+          importedClassIndex.put(importCandidate.get().simpleName(), importCandidate.get());\n+        }\n+      }\n+    }\n+\n+    if (!importedClassIndex.isEmpty()) {\n+      appendable.append('\\n');\n+    }\n+\n+    CompilationUnitContext context =\n+        new CompilationUnitContext(packageName, ImmutableSet.copyOf(importedClassIndex.values()));\n+    write(appendable, context.createSubcontext(ImmutableSet.of(name())));\n+\n+    return appendable;\n+  }\n+\n+  static final class CompilationUnitContext implements Context {\n+    private final String packageName;\n+    private final ImmutableSortedSet<ClassName> visibleClasses;\n+\n+    CompilationUnitContext(String packageName, Set<ClassName> visibleClasses) {\n+      this.packageName = packageName;\n+      this.visibleClasses =\n+          ImmutableSortedSet.copyOf(Ordering.natural().reverse(), visibleClasses);\n+    }\n+\n+    @Override\n+    public Context createSubcontext(Set<ClassName> newTypes) {\n+      return new CompilationUnitContext(packageName, Sets.union(visibleClasses, newTypes));\n+    }\n+\n+    @Override\n+    public String sourceReferenceForClassName(ClassName className) {\n+      if (isImported(className)) {\n+        return className.simpleName();\n+      }\n+      Optional<ClassName> enclosingClassName = className.enclosingClassName();\n+      while (enclosingClassName.isPresent()) {\n+        if (isImported(enclosingClassName.get())) {\n+          return enclosingClassName.get().simpleName()\n+              + className.canonicalName()\n+                  .substring(enclosingClassName.get().canonicalName().length());\n+        }\n+        enclosingClassName = enclosingClassName.get().enclosingClassName();\n+      }\n+      return className.canonicalName();\n+    }\n+\n+    private boolean collidesWithVisibleClass(ClassName className) {\n+      return collidesWithVisibleClass(className.simpleName());\n+    }\n+\n+    private boolean collidesWithVisibleClass(String simpleName) {\n+      return FluentIterable.from(visibleClasses)\n+          .transform(new Function<ClassName, String>() {\n+            @Override public String apply(ClassName input) {\n+              return input.simpleName();\n+            }\n+          })\n+          .contains(simpleName);\n+    }\n+\n+    private boolean isImported(ClassName className) {\n+      return (packageName.equals(className.packageName())\n+              && !className.enclosingClassName().isPresent()\n+              && !collidesWithVisibleClass(className)) // need to account for scope & hiding\n+          || visibleClasses.contains(className)\n+          || (className.packageName().equals(\"java.lang\")\n+              && className.enclosingSimpleNames().isEmpty());\n+    }\n+  }\n }\n"
    },
    {
        "commit_hash": "c716d5c44e7ef7e0d55ab388740a6af9ca8edf79",
        "previous_commit_hash": "3fc1be2e414a86b933676eea644b0ff80feb58bb",
        "diff_stats": {
            "additions": 34,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright (C) 2014 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+@RunWith(JUnit4.class)\n+public final class ClassWriterTest {\n+  @Test public void onlyTopLevelClassNames() {\n+    ClassName name = ClassName.bestGuessFromString(\"test.Foo.Bar\");\n+    try {\n+      ClassWriter.forClassName(name);\n+    } catch (IllegalArgumentException e) {\n+      assertThat(e.getMessage()).isEqualTo(\"test.Foo.Bar must be top-level type.\");\n+    }\n+  }\n+}\n"
    },
    {
        "commit_hash": "c716d5c44e7ef7e0d55ab388740a6af9ca8edf79",
        "previous_commit_hash": "3fc1be2e414a86b933676eea644b0ff80feb58bb",
        "diff_stats": {
            "additions": 34,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright (C) 2014 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+@RunWith(JUnit4.class)\n+public final class EnumWriterTest {\n+  @Test public void onlyTopLevelClassNames() {\n+    ClassName name = ClassName.bestGuessFromString(\"test.Foo.Bar\");\n+    try {\n+      EnumWriter.forClassName(name);\n+    } catch (IllegalArgumentException e) {\n+      assertThat(e.getMessage()).isEqualTo(\"test.Foo.Bar must be top-level type.\");\n+    }\n+  }\n+}\n"
    },
    {
        "commit_hash": "c716d5c44e7ef7e0d55ab388740a6af9ca8edf79",
        "previous_commit_hash": "3fc1be2e414a86b933676eea644b0ff80feb58bb",
        "diff_stats": {
            "additions": 34,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright (C) 2014 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+@RunWith(JUnit4.class)\n+public final class InterfaceWriterTest {\n+  @Test public void onlyTopLevelClassNames() {\n+    ClassName name = ClassName.bestGuessFromString(\"test.Foo.Bar\");\n+    try {\n+      InterfaceWriter.forClassName(name);\n+    } catch (IllegalArgumentException e) {\n+      assertThat(e.getMessage()).isEqualTo(\"test.Foo.Bar must be top-level type.\");\n+    }\n+  }\n+}\n"
    },
    {
        "commit_hash": "c716d5c44e7ef7e0d55ab388740a6af9ca8edf79",
        "previous_commit_hash": "3fc1be2e414a86b933676eea644b0ff80feb58bb",
        "diff_stats": {
            "additions": 86,
            "deletions": 44
        },
        "diff_content": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (C) 2014 Google, Inc.\n+ * Copyright (C) 2014 Square, Inc.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -15,65 +15,107 @@\n  */\n package com.squareup.javawriter;\n \n-import java.util.concurrent.Executor;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import com.google.common.jimfs.Jimfs;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.FileSystem;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import org.junit.Rule;\n import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n \n import static com.google.common.truth.Truth.assertThat;\n \n @RunWith(JUnit4.class)\n-public class JavaWriterTest {\n-  @Test public void referencedAndDeclaredSimpleName() {\n-    JavaWriter javaWriter = JavaWriter.inPackage(\"test\");\n-    ClassWriter topClass = javaWriter.addClass(\"Top\");\n-    topClass.addNestedClass(\"Middle\").addNestedClass(\"Bottom\");\n-    topClass.addField(ClassName.create(\"some.other.pkg\", \"Bottom\"), \"field\");\n-    assertThat(topClass.toString()).doesNotContain(\"import some.other.pkg.Bottom;\");\n+public final class JavaWriterTest {\n+  private final JavaWriter javaWriter = JavaWriter.create();\n+\n+  // Used for testing java.io File behavior.\n+  @Rule public final TemporaryFolder tmp = new TemporaryFolder();\n+\n+  // Used for testing java.nio.file Path behavior.\n+  private final FileSystem fs = Jimfs.newFileSystem();\n+  private final Path fsRoot = Iterables.getOnlyElement(fs.getRootDirectories());\n+\n+  @Test public void pathNotDirectory() throws IOException {\n+    Path path = fs.getPath(\"/foo/bar\");\n+    Files.createDirectories(path.getParent());\n+    Files.createFile(path);\n+    try {\n+      javaWriter.writeTo(path);\n+    } catch (IllegalArgumentException e) {\n+      assertThat(e.getMessage()).isEqualTo(\"Path /foo/bar exists but is not a directory.\");\n+    }\n   }\n \n-  @Test public void zeroImportsSingleNewline() {\n-    JavaWriter javaWriter = JavaWriter.inPackage(\"test\");\n-    javaWriter.addClass(\"Top\");\n+  @Test public void fileNotDirectory() throws IOException {\n+    File file = new File(tmp.newFolder(\"foo\"), \"bar\");\n+    try {\n+      javaWriter.writeTo(file);\n+    } catch (IllegalArgumentException e) {\n+      assertThat(e.getMessage()).containsMatch(\"File .*?/foo/bar exists but is not a directory.\");\n+    }\n+  }\n \n-    String expected = \"\"\n-        + \"package test;\\n\"\n-        + \"\\n\"\n-        + \"class Top {\";\n+  @Test public void pathDefaultPackage() throws IOException {\n+    ClassName name = ClassName.create(\"\", \"Test\");\n+    ClassWriter test = ClassWriter.forClassName(name);\n+    javaWriter.addTypeWriter(test).writeTo(fsRoot);\n \n-    assertThat(javaWriter.toString()).startsWith(expected);\n+    Path testPath = fsRoot.resolve(\"Test.java\");\n+    assertThat(Files.exists(testPath)).isTrue();\n   }\n \n-  @Test public void newlineBetweenImports() {\n-    JavaWriter javaWriter = JavaWriter.inPackage(\"test\");\n-    ClassWriter topClass = javaWriter.addClass(\"Top\");\n-    topClass.addField(Executor.class, \"executor\");\n+  @Test public void fileDefaultPackage() throws IOException {\n+    ClassName name = ClassName.create(\"\", \"Test\");\n+    ClassWriter test = ClassWriter.forClassName(name);\n+    javaWriter.addTypeWriter(test).writeTo(tmp.getRoot());\n \n-    String expected = \"\"\n-        + \"package test;\\n\"\n-        + \"\\n\"\n-        + \"import java.util.concurrent.Executor;\\n\"\n-        + \"\\n\"\n-        + \"class Top {\";\n+    File testFile = new File(tmp.getRoot(), \"Test.java\");\n+    assertThat(testFile.exists()).isTrue();\n+  }\n+\n+  @Test public void pathNestedClasses() throws IOException {\n+    ClassName fooName = ClassName.create(\"foo\", \"Test\");\n+    ClassName barName = ClassName.create(\"foo.bar\", \"Test\");\n+    ClassName bazName = ClassName.create(\"foo.bar.baz\", \"Test\");\n+    ClassWriter foo = ClassWriter.forClassName(fooName);\n+    ClassWriter bar = ClassWriter.forClassName(barName);\n+    ClassWriter baz = ClassWriter.forClassName(bazName);\n+    javaWriter.addTypeWriters(ImmutableList.of(foo, bar, baz)).writeTo(fsRoot);\n \n-    assertThat(javaWriter.toString()).startsWith(expected);\n+    Path fooPath = fsRoot.resolve(fs.getPath(\"foo\", \"Test.java\"));\n+    Path barPath = fsRoot.resolve(fs.getPath(\"foo\", \"bar\", \"Test.java\"));\n+    Path bazPath = fsRoot.resolve(fs.getPath(\"foo\", \"bar\", \"baz\", \"Test.java\"));\n+    assertThat(Files.exists(fooPath)).isTrue();\n+    assertThat(Files.exists(barPath)).isTrue();\n+    assertThat(Files.exists(bazPath)).isTrue();\n   }\n \n-  @Test public void newlinesBetweenTypes() {\n-    JavaWriter javaWriter = JavaWriter.inPackage(\"test\");\n-    javaWriter.addClass(\"Top\");\n-    javaWriter.addClass(\"Middle\");\n-    javaWriter.addClass(\"Bottom\");\n-\n-    String expected = \"\"\n-        + \"package test;\\n\"\n-        + \"\\n\"\n-        + \"class Top {}\\n\"\n-        + \"\\n\"\n-        + \"class Middle {}\\n\"\n-        + \"\\n\"\n-        + \"class Bottom {}\\n\";\n-\n-    assertThat(javaWriter.toString()).isEqualTo(expected);\n+  @Test public void fileNestedClasses() throws IOException {\n+    ClassName fooName = ClassName.create(\"foo\", \"Test\");\n+    ClassName barName = ClassName.create(\"foo.bar\", \"Test\");\n+    ClassName bazName = ClassName.create(\"foo.bar.baz\", \"Test\");\n+    ClassWriter foo = ClassWriter.forClassName(fooName);\n+    ClassWriter bar = ClassWriter.forClassName(barName);\n+    ClassWriter baz = ClassWriter.forClassName(bazName);\n+    javaWriter.addTypeWriters(ImmutableList.of(foo, bar, baz)).writeTo(tmp.getRoot());\n+\n+    File fooDir = new File(tmp.getRoot(), \"foo\");\n+    File fooFile = new File(fooDir, \"Test.java\");\n+    File barDir = new File(fooDir, \"bar\");\n+    File barFile = new File(barDir, \"Test.java\");\n+    File bazDir = new File(barDir, \"baz\");\n+    File bazFile = new File(bazDir, \"Test.java\");\n+    assertThat(fooFile.exists()).isTrue();\n+    assertThat(barFile.exists()).isTrue();\n+    assertThat(bazFile.exists()).isTrue();\n   }\n+\n+  // TODO Filer-based tests\n }\n"
    },
    {
        "commit_hash": "c716d5c44e7ef7e0d55ab388740a6af9ca8edf79",
        "previous_commit_hash": "3fc1be2e414a86b933676eea644b0ff80feb58bb",
        "diff_stats": {
            "additions": 61,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright (C) 2014 Google, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter;\n+\n+import java.util.concurrent.Executor;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+@RunWith(JUnit4.class)\n+public class TypeWriterTest {\n+  @Test public void referencedAndDeclaredSimpleName() {\n+    ClassName name = ClassName.create(\"test\", \"Top\");\n+    ClassWriter topClass = ClassWriter.forClassName(name);\n+    topClass.addNestedClass(\"Middle\").addNestedClass(\"Bottom\");\n+    topClass.addField(ClassName.create(\"some.other.pkg\", \"Bottom\"), \"field\");\n+    assertThat(topClass.toString()).doesNotContain(\"import some.other.pkg.Bottom;\");\n+  }\n+\n+  @Test public void zeroImportsSingleNewline() {\n+    ClassName name = ClassName.create(\"test\", \"Top\");\n+    ClassWriter classWriter = ClassWriter.forClassName(name);\n+\n+    String expected = \"\"\n+        + \"package test;\\n\"\n+        + \"\\n\"\n+        + \"class Top {}\\n\";\n+    assertThat(classWriter.toString()).isEqualTo(expected);\n+  }\n+\n+  @Test public void newlineBetweenImports() {\n+    ClassName name = ClassName.create(\"test\", \"Top\");\n+    ClassWriter topClass = ClassWriter.forClassName(name);\n+    topClass.addField(Executor.class, \"executor\");\n+\n+    String expected = \"\"\n+        + \"package test;\\n\"\n+        + \"\\n\"\n+        + \"import java.util.concurrent.Executor;\\n\"\n+        + \"\\n\"\n+        + \"class Top {\\n\"\n+        + \"  Executor executor;\\n\"\n+        + \"}\\n\";\n+    assertThat(topClass.toString()).isEqualTo(expected);\n+  }\n+}\n"
    },
    {
        "commit_hash": "a3c879ba90acdf0f4d997eb8729011e50299a7c4",
        "previous_commit_hash": "75772dedc90d3c5f13078d6dcb0bc518ce96e8b0",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -146,7 +146,7 @@ public final class EnumWriter extends TypeWriter {\n       this.constructorSnippets = Lists.newArrayList();\n     }\n \n-    ConstantWriter addArgument(Snippet snippet) {\n+    public ConstantWriter addArgument(Snippet snippet) {\n       constructorSnippets.add(snippet);\n       return this;\n     }\n"
    },
    {
        "commit_hash": "db00b9570752eacde5c60e396386b304a9df7f4c",
        "previous_commit_hash": "14937cec86a93b7109f3bf14e6f75a851ceeab88",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -91,7 +91,7 @@ public final class JavaWriter {\n         for (String packageComponent : packageName.split(\"\\\\.\")) {\n           outputDir = new File(outputDir, packageComponent);\n         }\n-        if (!outputDir.mkdirs()) {\n+        if (!outputDir.exists() && !outputDir.mkdirs()) {\n           throw new IOException(\"Unable to create directory \" + outputDir);\n         }\n       }\n"
    },
    {
        "commit_hash": "db00b9570752eacde5c60e396386b304a9df7f4c",
        "previous_commit_hash": "14937cec86a93b7109f3bf14e6f75a851ceeab88",
        "diff_stats": {
            "additions": 27,
            "deletions": 0
        },
        "diff_content": "@@ -80,6 +80,33 @@ public final class JavaWriterTest {\n     assertThat(testFile.exists()).isTrue();\n   }\n \n+  @Test public void pathSamePackage() throws IOException {\n+    ClassName name1 = ClassName.create(\"example\", \"Test1\");\n+    ClassName name2 = ClassName.create(\"example\", \"Test2\");\n+    ClassWriter test1 = ClassWriter.forClassName(name1);\n+    ClassWriter test2 = ClassWriter.forClassName(name2);\n+    javaWriter.addTypeWriter(test1).addTypeWriter(test2).writeTo(fsRoot);\n+\n+    Path testPath1 = fsRoot.resolve(\"example/Test1.java\");\n+    assertThat(Files.exists(testPath1)).isTrue();\n+    Path testPath2 = fsRoot.resolve(\"example/Test2.java\");\n+    assertThat(Files.exists(testPath2)).isTrue();\n+  }\n+\n+  @Test public void fileSamePackage() throws IOException {\n+    ClassName name1 = ClassName.create(\"example\", \"Test1\");\n+    ClassName name2 = ClassName.create(\"example\", \"Test2\");\n+    ClassWriter test1 = ClassWriter.forClassName(name1);\n+    ClassWriter test2 = ClassWriter.forClassName(name2);\n+    javaWriter.addTypeWriter(test1).addTypeWriter(test2).writeTo(tmp.getRoot());\n+\n+    File examplePackage = new File(tmp.getRoot(), \"example\");\n+    File testFile1 = new File(examplePackage, \"Test1.java\");\n+    assertThat(testFile1.exists()).isTrue();\n+    File testFile2 = new File(examplePackage, \"Test2.java\");\n+    assertThat(testFile2.exists()).isTrue();\n+  }\n+\n   @Test public void pathNestedClasses() throws IOException {\n     ClassName fooName = ClassName.create(\"foo\", \"Test\");\n     ClassName barName = ClassName.create(\"foo.bar\", \"Test\");\n"
    },
    {
        "commit_hash": "29eb5420e0b34cf5edce535b33f70e7ccd02c51f",
        "previous_commit_hash": "14937cec86a93b7109f3bf14e6f75a851ceeab88",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -40,10 +40,10 @@ public final class TypeNames {\n       };\n \n   public static TypeName forClass(Class<?> clazz) {\n-    if (clazz.isPrimitive()) {\n-      return PrimitiveName.forClass(clazz);\n-    } else if (void.class.equals(clazz)) {\n+    if (void.class.equals(clazz)) {\n       return VoidName.VOID;\n+    } else if (clazz.isPrimitive()) {\n+      return PrimitiveName.forClass(clazz);\n     } else if (clazz.isArray()) {\n       return new ArrayTypeName(forClass(clazz.getComponentType()));\n     } else {\n"
    },
    {
        "commit_hash": "29eb5420e0b34cf5edce535b33f70e7ccd02c51f",
        "previous_commit_hash": "14937cec86a93b7109f3bf14e6f75a851ceeab88",
        "diff_stats": {
            "additions": 12,
            "deletions": 0
        },
        "diff_content": "@@ -139,12 +139,24 @@ public class TypeNamesTest {\n         .isEqualTo(new ArrayTypeName(ClassName.fromClass(Object.class)));\n   }\n \n+  @Test public void forClass_array() {\n+    assert_().that(TypeNames.forClass(Object[].class))\n+        .isEqualTo(new ArrayTypeName(ClassName.fromClass(Object.class)));\n+    assert_().that(TypeNames.forClass(int[].class))\n+        .isEqualTo(new ArrayTypeName(PrimitiveName.INT));\n+  }\n+\n   @Test\n   public void forTypeMirror_void() {\n     assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getNoType(TypeKind.VOID)))\n         .isEqualTo(VoidName.VOID);\n   }\n \n+  @Test public void forClass_void() {\n+    assert_().that(TypeNames.forClass(void.class)).isEqualTo(VoidName.VOID);\n+    assert_().that(TypeNames.forClass(Void.class)).isNotEqualTo(VoidName.VOID);\n+  }\n+\n   @Test\n   public void forTypeMirror_null() {\n     assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getNullType()))\n"
    },
    {
        "commit_hash": "74b96b2d60311ebea9919d610bd5e7fa5d2dc7c4",
        "previous_commit_hash": "14937cec86a93b7109f3bf14e6f75a851ceeab88",
        "diff_stats": {
            "additions": 11,
            "deletions": 1
        },
        "diff_content": "@@ -45,6 +45,7 @@ public abstract class TypeWriter /* ha ha */ extends Modifiable\n   final List<MethodWriter> methodWriters;\n   final List<TypeWriter> nestedTypeWriters;\n   final Map<String, FieldWriter> fieldWriters;\n+  final List<ClassName> explicitImports;\n \n   TypeWriter(ClassName name) {\n     this.name = name;\n@@ -52,6 +53,7 @@ public abstract class TypeWriter /* ha ha */ extends Modifiable\n     this.methodWriters = Lists.newArrayList();\n     this.nestedTypeWriters = Lists.newArrayList();\n     this.fieldWriters = Maps.newLinkedHashMap();\n+    this.explicitImports = Lists.newArrayList();\n   }\n \n   @Override\n@@ -59,6 +61,14 @@ public abstract class TypeWriter /* ha ha */ extends Modifiable\n     return name;\n   }\n \n+  public void addImport(Class<?> clazz) {\n+    addImport(ClassName.fromClass(clazz));\n+  }\n+\n+  public void addImport(ClassName className) {\n+    explicitImports.add(className);\n+  }\n+\n   public MethodWriter addMethod(TypeWriter returnType, String name) {\n     MethodWriter methodWriter = new MethodWriter(returnType.name, name);\n     methodWriters.add(methodWriter);\n@@ -144,7 +154,7 @@ public abstract class TypeWriter /* ha ha */ extends Modifiable\n     appendable.append(\"package \").append(packageName).append(\";\\n\\n\");\n \n     ImmutableSortedSet<ClassName> importCandidates = ImmutableSortedSet.<ClassName>naturalOrder()\n-        //.addAll(explicitImports) // TODO!\n+        .addAll(explicitImports)\n         .addAll(referencedClasses())\n         .build();\n \n"
    },
    {
        "commit_hash": "74b96b2d60311ebea9919d610bd5e7fa5d2dc7c4",
        "previous_commit_hash": "14937cec86a93b7109f3bf14e6f75a851ceeab88",
        "diff_stats": {
            "additions": 14,
            "deletions": 0
        },
        "diff_content": "@@ -58,4 +58,18 @@ public class TypeWriterTest {\n         + \"}\\n\";\n     assertThat(topClass.toString()).isEqualTo(expected);\n   }\n+\n+  @Test public void explicitImports() {\n+    ClassName name = ClassName.create(\"test\", \"Top\");\n+    ClassWriter topClass = ClassWriter.forClassName(name);\n+    topClass.addImport(ClassName.create(\"other\", \"Thing\"));\n+\n+    String expected = \"\"\n+        + \"package test;\\n\"\n+        + \"\\n\"\n+        + \"import other.Thing;\\n\"\n+        + \"\\n\"\n+        + \"class Top {}\\n\";\n+    assertThat(topClass.toString()).isEqualTo(expected);\n+  }\n }\n"
    },
    {
        "commit_hash": "834825ade7057f524eec37928489b8f76984b9f6",
        "previous_commit_hash": "14937cec86a93b7109f3bf14e6f75a851ceeab88",
        "diff_stats": {
            "additions": 3,
            "deletions": 20
        },
        "diff_content": "@@ -22,7 +22,6 @@ import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n import java.io.IOException;\n-import java.util.Iterator;\n import java.util.List;\n import java.util.Set;\n import javax.lang.model.element.Modifier;\n@@ -83,29 +82,13 @@ public final class ClassWriter extends TypeWriter {\n         .toSet());\n     writeAnnotations(appendable, context);\n     writeModifiers(appendable).append(\"class \").append(name.simpleName());\n-    Iterator<TypeVariableName> typeVariablesIterator = typeVariables.iterator();\n-    if (typeVariablesIterator.hasNext()) {\n-      appendable.append('<');\n-      typeVariablesIterator.next().write(appendable, context);\n-      while (typeVariablesIterator.hasNext()) {\n-        appendable.append(\", \");\n-        typeVariablesIterator.next().write(appendable, context);\n-      }\n-      appendable.append(\"> \");\n-    }\n+    Writables.Joiner.on(\", \").wrap(\"<\", \"> \").appendTo(appendable, context, typeVariables);\n     if (supertype.isPresent()) {\n       appendable.append(\" extends \");\n       supertype.get().write(appendable, context);\n     }\n-    Iterator<TypeName> implementedTypesIterator = implementedTypes.iterator();\n-    if (implementedTypesIterator.hasNext()) {\n-      appendable.append(\" implements \");\n-      implementedTypesIterator.next().write(appendable, context);\n-      while (implementedTypesIterator.hasNext()) {\n-        appendable.append(\", \");\n-        implementedTypesIterator.next().write(appendable, context);\n-      }\n-    }\n+    Writables.Joiner.on(\", \").prefix(\" implements \")\n+        .appendTo(appendable, context, implementedTypes);\n     appendable.append(\" {\");\n     if (!fieldWriters.isEmpty()) {\n       appendable.append('\\n');\n"
    },
    {
        "commit_hash": "834825ade7057f524eec37928489b8f76984b9f6",
        "previous_commit_hash": "14937cec86a93b7109f3bf14e6f75a851ceeab88",
        "diff_stats": {
            "additions": 2,
            "deletions": 19
        },
        "diff_content": "@@ -22,7 +22,6 @@ import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import java.io.IOException;\n-import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n@@ -92,25 +91,9 @@ public final class ConstructorWriter extends Modifiable implements Writable, Has\n   @Override\n   public Appendable write(Appendable appendable, Context context) throws IOException {\n     writeModifiers(appendable);\n-    Iterator<TypeVariableName> typeVariablesIterator = typeVariables.iterator();\n-    if (typeVariablesIterator.hasNext()) {\n-      appendable.append('<');\n-      typeVariablesIterator.next().write(appendable, context);\n-      while (typeVariablesIterator.hasNext()) {\n-        appendable.append(\", \");\n-        typeVariablesIterator.next().write(appendable, context);\n-      }\n-      appendable.append(\"> \");\n-    }\n+    Writables.Joiner.on(\", \").wrap(\"<\", \"> \").appendTo(appendable, context, typeVariables);\n     appendable.append(name).append('(');\n-    Iterator<VariableWriter> parameterWritersIterator = parameterWriters.values().iterator();\n-    if (parameterWritersIterator.hasNext()) {\n-      parameterWritersIterator.next().write(appendable, context);\n-    }\n-    while (parameterWritersIterator.hasNext()) {\n-      appendable.append(\", \");\n-      parameterWritersIterator.next().write(appendable, context);\n-    }\n+    Writables.Joiner.on(\", \").appendTo(appendable, context, parameterWriters.values());\n     appendable.append(\") {\");\n     blockWriter.write(new IndentingAppendable(appendable), context);\n     return appendable.append(\"}\\n\");\n"
    },
    {
        "commit_hash": "834825ade7057f524eec37928489b8f76984b9f6",
        "previous_commit_hash": "14937cec86a93b7109f3bf14e6f75a851ceeab88",
        "diff_stats": {
            "additions": 3,
            "deletions": 20
        },
        "diff_content": "@@ -23,7 +23,6 @@ import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n import java.io.IOException;\n-import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n@@ -71,15 +70,8 @@ public final class EnumWriter extends TypeWriter {\n         .toSet());\n     writeAnnotations(appendable, context);\n     writeModifiers(appendable).append(\"enum \").append(name.simpleName());\n-    Iterator<TypeName> implementedTypesIterator = implementedTypes.iterator();\n-    if (implementedTypesIterator.hasNext()) {\n-      appendable.append(\" implements \");\n-      implementedTypesIterator.next().write(appendable, context);\n-      while (implementedTypesIterator.hasNext()) {\n-        appendable.append(\", \");\n-        implementedTypesIterator.next().write(appendable, context);\n-      }\n-    }\n+    Writables.Joiner.on(\", \").prefix(\" implements \")\n+        .appendTo(appendable, context, implementedTypes);\n     appendable.append(\" {\");\n \n     checkState(!constantWriters.isEmpty(), \"Cannot write an enum with no constants.\");\n@@ -160,16 +152,7 @@ public final class EnumWriter extends TypeWriter {\n     @Override\n     public Appendable write(Appendable appendable, Context context) throws IOException {\n       appendable.append(name);\n-      Iterator<Snippet> snippetIterator = constructorSnippets.iterator();\n-      if (snippetIterator.hasNext()) {\n-        appendable.append('(');\n-        snippetIterator.next().write(appendable, context);\n-        while (snippetIterator.hasNext()) {\n-          appendable.append(\", \");\n-          snippetIterator.next().write(appendable, context);\n-        }\n-        appendable.append(')');\n-      }\n+      Writables.Joiner.on(\", \").wrap(\"(\", \")\").appendTo(appendable, context, constructorSnippets);\n       return appendable;\n     }\n \n"
    },
    {
        "commit_hash": "834825ade7057f524eec37928489b8f76984b9f6",
        "previous_commit_hash": "14937cec86a93b7109f3bf14e6f75a851ceeab88",
        "diff_stats": {
            "additions": 2,
            "deletions": 20
        },
        "diff_content": "@@ -20,7 +20,6 @@ import com.google.common.collect.FluentIterable;\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n import java.io.IOException;\n-import java.util.Iterator;\n import java.util.List;\n import java.util.Set;\n \n@@ -53,25 +52,8 @@ public final class InterfaceWriter extends TypeWriter {\n         .toSet());\n     writeAnnotations(appendable, context);\n     writeModifiers(appendable).append(\"interface \").append(name.simpleName());\n-    Iterator<TypeVariableName> typeVariablesIterator = typeVariables.iterator();\n-    if (typeVariablesIterator.hasNext()) {\n-      appendable.append('<');\n-      typeVariablesIterator.next().write(appendable, context);\n-      while (typeVariablesIterator.hasNext()) {\n-        appendable.append(\", \");\n-        typeVariablesIterator.next().write(appendable, context);\n-      }\n-      appendable.append(\"> \");\n-    }\n-    Iterator<TypeName> implementedTypesIterator = implementedTypes.iterator();\n-    if (implementedTypesIterator.hasNext()) {\n-      appendable.append(\" extends \");\n-      implementedTypesIterator.next().write(appendable, context);\n-      while (implementedTypesIterator.hasNext()) {\n-        appendable.append(\", \");\n-        implementedTypesIterator.next().write(appendable, context);\n-      }\n-    }\n+    Writables.Joiner.on(\", \").wrap(\"<\", \"> \").appendTo(appendable, context, typeVariables);\n+    Writables.Joiner.on(\", \").prefix(\" extends \").appendTo(appendable, context, implementedTypes);\n     appendable.append(\" {\");\n     for (MethodWriter methodWriter : methodWriters) {\n       appendable.append('\\n');\n"
    },
    {
        "commit_hash": "834825ade7057f524eec37928489b8f76984b9f6",
        "previous_commit_hash": "14937cec86a93b7109f3bf14e6f75a851ceeab88",
        "diff_stats": {
            "additions": 1,
            "deletions": 9
        },
        "diff_content": "@@ -18,7 +18,6 @@ package com.squareup.javawriter;\n import com.google.common.base.Function;\n import com.google.common.collect.FluentIterable;\n import java.io.IOException;\n-import java.util.Iterator;\n import java.util.List;\n import java.util.Set;\n \n@@ -40,14 +39,7 @@ final class IntersectionTypeName implements TypeName {\n   }\n \n   @Override public Appendable write(Appendable appendable, Context context) throws IOException {\n-    Iterator<TypeName> iterator = typeNames.iterator();\n-    if (iterator.hasNext()) {\n-      iterator.next().write(appendable, context);\n-      while (iterator.hasNext()) {\n-        appendable.append(\" & \");\n-        iterator.next().write(appendable, context);\n-      }\n-    }\n+    Writables.Joiner.on(\" & \").appendTo(appendable, context, typeNames);\n     return appendable;\n   }\n \n"
    },
    {
        "commit_hash": "834825ade7057f524eec37928489b8f76984b9f6",
        "previous_commit_hash": "14937cec86a93b7109f3bf14e6f75a851ceeab88",
        "diff_stats": {
            "additions": 2,
            "deletions": 19
        },
        "diff_content": "@@ -23,7 +23,6 @@ import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import java.io.IOException;\n-import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n@@ -87,26 +86,10 @@ public final class MethodWriter extends Modifiable implements HasClassReferences\n   public Appendable write(Appendable appendable, Context context) throws IOException {\n     writeAnnotations(appendable, context);\n     writeModifiers(appendable);\n-    Iterator<TypeVariableName> typeVariablesIterator = typeVariables.iterator();\n-    if (typeVariablesIterator.hasNext()) {\n-      appendable.append('<');\n-      typeVariablesIterator.next().write(appendable, context);\n-      while (typeVariablesIterator.hasNext()) {\n-        appendable.append(\", \");\n-        typeVariablesIterator.next().write(appendable, context);\n-      }\n-      appendable.append(\"> \");\n-    }\n+    Writables.Joiner.on(\", \").wrap(\"<\", \"> \").appendTo(appendable, context, typeVariables);\n     returnType.write(appendable, context);\n     appendable.append(' ').append(name).append('(');\n-    Iterator<VariableWriter> parameterWritersIterator = parameterWriters.values().iterator();\n-    if (parameterWritersIterator.hasNext()) {\n-      parameterWritersIterator.next().write(appendable, context);\n-    }\n-    while (parameterWritersIterator.hasNext()) {\n-      appendable.append(\", \");\n-      parameterWritersIterator.next().write(appendable, context);\n-    }\n+    Writables.Joiner.on(\", \").appendTo(appendable, context, parameterWriters.values());\n     appendable.append(\")\");\n     if (body.isPresent()) {\n       appendable.append(\" {\");\n"
    },
    {
        "commit_hash": "834825ade7057f524eec37928489b8f76984b9f6",
        "previous_commit_hash": "14937cec86a93b7109f3bf14e6f75a851ceeab88",
        "diff_stats": {
            "additions": 2,
            "deletions": 10
        },
        "diff_content": "@@ -19,7 +19,6 @@ import com.google.common.base.Objects;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n import java.io.IOException;\n-import java.util.Iterator;\n import java.util.Set;\n \n import static com.google.common.base.Preconditions.checkArgument;\n@@ -47,15 +46,8 @@ public final class ParameterizedTypeName implements TypeName {\n   @Override\n   public Appendable write(Appendable appendable, Context context) throws IOException {\n     appendable.append(context.sourceReferenceForClassName(type));\n-    Iterator<? extends TypeName> parameterIterator = parameters.iterator();\n-    verify(parameterIterator.hasNext(), type.toString());\n-    appendable.append('<');\n-    parameterIterator.next().write(appendable, context);\n-    while (parameterIterator.hasNext()) {\n-      appendable.append(\", \");\n-      parameterIterator.next().write(appendable, context);\n-    }\n-    appendable.append('>');\n+    verify(!parameters.isEmpty(), type.toString());\n+    Writables.Joiner.on(\", \").wrap(\"<\", \">\").appendTo(appendable, context, parameters);\n     return appendable;\n   }\n \n"
    },
    {
        "commit_hash": "834825ade7057f524eec37928489b8f76984b9f6",
        "previous_commit_hash": "14937cec86a93b7109f3bf14e6f75a851ceeab88",
        "diff_stats": {
            "additions": 1,
            "deletions": 10
        },
        "diff_content": "@@ -21,7 +21,6 @@ import com.google.common.collect.FluentIterable;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n import java.io.IOException;\n-import java.util.Iterator;\n import java.util.Set;\n import javax.lang.model.element.NestingKind;\n import javax.lang.model.element.TypeElement;\n@@ -80,15 +79,7 @@ public final class TypeVariableName implements TypeName {\n   @Override\n   public Appendable write(Appendable appendable, Context context) throws IOException {\n     appendable.append(name);\n-    Iterator<TypeName> boundsIterator = bounds.iterator();\n-    if (boundsIterator.hasNext()) {\n-      appendable.append(\" extends \");\n-      boundsIterator.next().write(appendable, context);\n-      while (boundsIterator.hasNext()) {\n-        appendable.append(\" & \");\n-        boundsIterator.next().write(appendable, context);\n-      }\n-    }\n+    Writables.Joiner.on(\" & \").prefix(\" extends \").appendTo(appendable, context, bounds);\n     return appendable;\n   }\n \n"
    },
    {
        "commit_hash": "834825ade7057f524eec37928489b8f76984b9f6",
        "previous_commit_hash": "14937cec86a93b7109f3bf14e6f75a851ceeab88",
        "diff_stats": {
            "additions": 77,
            "deletions": 0
        },
        "diff_content": "@@ -15,11 +15,88 @@\n  */\n package com.squareup.javawriter;\n \n+import com.google.common.collect.Iterators;\n import com.squareup.javawriter.Writable.Context;\n import java.io.IOException;\n+import java.util.Iterator;\n import java.util.Set;\n \n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n final class Writables {\n+\n+  static class Joiner {\n+    static Joiner on(String separator) {\n+      return new Joiner(separator);\n+    }\n+\n+    static Joiner on(char separator) {\n+      return on(String.valueOf(separator));\n+    }\n+\n+    private final String separator;\n+\n+    private Joiner(String separator) {\n+      this.separator = separator;\n+    }\n+\n+    protected Joiner(Joiner prototype) {\n+      this.separator = prototype.separator;\n+    }\n+\n+    final Appendable appendTo(Appendable appendable, Context context, Writable[] parts)\n+        throws IOException {\n+      return appendTo(appendable, context, Iterators.forArray(parts));\n+    }\n+\n+    final Appendable appendTo(Appendable appendable, Context context, Writable part1,\n+        Writable part2, Writable... parts) throws IOException {\n+      return appendTo(appendable, context,\n+          Iterators.concat(Iterators.forArray(part1, part2), Iterators.forArray(parts)));\n+    }\n+\n+    final Appendable appendTo(Appendable appendable, Context context,\n+        Iterable<? extends Writable> parts) throws IOException {\n+      return appendTo(appendable, context, parts.iterator());\n+    }\n+\n+    Appendable appendTo(Appendable appendable, Context context, Iterator<? extends Writable> parts)\n+        throws IOException {\n+      checkNotNull(appendable);\n+      checkNotNull(context);\n+      if (parts.hasNext()) {\n+        parts.next().write(appendable, context);\n+        while (parts.hasNext()) {\n+          appendable.append(separator);\n+          parts.next().write(appendable, context);\n+        }\n+      }\n+      return appendable;\n+    }\n+\n+    final Joiner prefix(String prefix) {\n+      return wrap(prefix, \"\");\n+    }\n+\n+    final Joiner wrap(final String prefix, final String suffix) {\n+      return new Joiner(this) {\n+        @Override\n+        Appendable appendTo(Appendable appendable, Context context,\n+            Iterator<? extends Writable> parts) throws IOException {\n+          boolean needsWrap = parts.hasNext();\n+          if (needsWrap) {\n+            appendable.append(prefix);\n+          }\n+          super.appendTo(appendable, context, parts);\n+          if (needsWrap) {\n+            appendable.append(suffix);\n+          }\n+          return appendable;\n+        }\n+      };\n+    }\n+  }\n+\n   static Writable toStringWritable(final Object object) {\n     return new Writable() {\n       @Override\n"
    },
    {
        "commit_hash": "002d2e7a6c7a21957d60f3aacba45dc18b61c317",
        "previous_commit_hash": "0572bbf2ebbac0958b871c56a7d4877db05d06ba",
        "diff_stats": {
            "additions": 12,
            "deletions": 1
        },
        "diff_content": "@@ -35,6 +35,7 @@ public final class MethodWriter extends Modifiable implements HasClassReferences\n   private final TypeName returnType;\n   private final String name;\n   private final Map<String, VariableWriter> parameterWriters;\n+  private final List<ClassName> throwsTypes;\n   private Optional<BlockWriter> body;\n \n   MethodWriter(TypeName returnType, String name) {\n@@ -42,6 +43,7 @@ public final class MethodWriter extends Modifiable implements HasClassReferences\n     this.returnType = returnType;\n     this.name = name;\n     this.parameterWriters = Maps.newLinkedHashMap();\n+    this.throwsTypes = Lists.newArrayList();\n     this.body = Optional.absent();\n   }\n \n@@ -72,6 +74,14 @@ public final class MethodWriter extends Modifiable implements HasClassReferences\n     return parameterWriter;\n   }\n \n+  public void addThrowsType(Class<?> clazz) {\n+    addThrowsType(ClassName.fromClass(clazz));\n+  }\n+\n+  public void addThrowsType(ClassName throwsType) {\n+    throwsTypes.add(throwsType);\n+  }\n+\n   public BlockWriter body() {\n     if (body.isPresent()) {\n       return body.get();\n@@ -91,6 +101,7 @@ public final class MethodWriter extends Modifiable implements HasClassReferences\n     appendable.append(' ').append(name).append('(');\n     Writables.Joiner.on(\", \").appendTo(appendable, context, parameterWriters.values());\n     appendable.append(\")\");\n+    Writables.Joiner.on(\", \").prefix(\" throws \").appendTo(appendable, context, throwsTypes);\n     if (body.isPresent()) {\n       appendable.append(\" {\");\n       body.get().write(new IndentingAppendable(appendable), context);\n@@ -105,7 +116,7 @@ public final class MethodWriter extends Modifiable implements HasClassReferences\n   public Set<ClassName> referencedClasses() {\n     Iterable<? extends HasClassReferences> concat =\n         Iterables.concat(typeVariables, ImmutableList.of(returnType), parameterWriters.values(),\n-            body.asSet());\n+            throwsTypes, body.asSet());\n     return FluentIterable.from(concat)\n         .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {\n           @Override\n"
    },
    {
        "commit_hash": "002d2e7a6c7a21957d60f3aacba45dc18b61c317",
        "previous_commit_hash": "0572bbf2ebbac0958b871c56a7d4877db05d06ba",
        "diff_stats": {
            "additions": 64,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,64 @@\n+/*\n+ * Copyright (C) 2014 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter;\n+\n+import com.google.common.base.Joiner;\n+import java.io.IOException;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+@RunWith(JUnit4.class)\n+public final class MethodWriterTest {\n+  @Test public void singleThrowsTypeName() {\n+    MethodWriter method = new MethodWriter(VoidName.VOID, \"test\");\n+    method.addThrowsType(ClassName.fromClass(IOException.class));\n+\n+    assertThat(Writables.writeToString(method)) //\n+        .isEqualTo(\"void test() throws java.io.IOException;\\n\");\n+  }\n+\n+  @Test public void singleThrowsClass() {\n+    MethodWriter method = new MethodWriter(VoidName.VOID, \"test\");\n+    method.addThrowsType(ClassName.fromClass(IOException.class));\n+\n+    assertThat(Writables.writeToString(method)) //\n+        .isEqualTo(\"void test() throws java.io.IOException;\\n\");\n+  }\n+\n+  @Test public void throwsWithBody() {\n+    MethodWriter method = new MethodWriter(PrimitiveName.INT, \"test\");\n+    method.addThrowsType(ClassName.fromClass(IOException.class));\n+    method.body().addSnippet(\"return 0;\");\n+\n+    assertThat(Writables.writeToString(method)).isEqualTo(Joiner.on('\\n').join(\n+        \"int test() throws java.io.IOException {  \",\n+        \"  return 0;\",\n+        \"}\\n\"\n+    ));\n+  }\n+\n+  @Test public void multipleThrows() {\n+    MethodWriter method = new MethodWriter(VoidName.VOID, \"test\");\n+    method.addThrowsType(IOException.class);\n+    method.addThrowsType(ClassName.create(\"example\", \"ExampleException\"));\n+\n+    assertThat(Writables.writeToString(method)) //\n+        .isEqualTo(\"void test() throws java.io.IOException, example.ExampleException;\\n\");\n+  }\n+}\n"
    },
    {
        "commit_hash": "ed4da020b6bd7b741c6f0ac3d9498fffba5a99fb",
        "previous_commit_hash": "0572bbf2ebbac0958b871c56a7d4877db05d06ba",
        "diff_stats": {
            "additions": 1,
            "deletions": 7
        },
        "diff_content": "@@ -73,13 +73,7 @@ public final class ClassWriter extends TypeWriter {\n \n   @Override\n   public Appendable write(Appendable appendable, Context context) throws IOException {\n-    context = context.createSubcontext(FluentIterable.from(nestedTypeWriters)\n-        .transform(new Function<TypeWriter, ClassName>() {\n-          @Override public ClassName apply(TypeWriter input) {\n-            return input.name;\n-          }\n-        })\n-        .toSet());\n+    context = createSubcontext(context);\n     writeAnnotations(appendable, context);\n     writeModifiers(appendable).append(\"class \").append(name.simpleName());\n     Writables.Joiner.on(\", \").wrap(\"<\", \"> \").appendTo(appendable, context, typeVariables);\n"
    },
    {
        "commit_hash": "ed4da020b6bd7b741c6f0ac3d9498fffba5a99fb",
        "previous_commit_hash": "0572bbf2ebbac0958b871c56a7d4877db05d06ba",
        "diff_stats": {
            "additions": 1,
            "deletions": 7
        },
        "diff_content": "@@ -61,13 +61,7 @@ public final class EnumWriter extends TypeWriter {\n \n   @Override\n   public Appendable write(Appendable appendable, Context context) throws IOException {\n-    context = context.createSubcontext(FluentIterable.from(nestedTypeWriters)\n-        .transform(new Function<TypeWriter, ClassName>() {\n-          @Override public ClassName apply(TypeWriter input) {\n-            return input.name;\n-          }\n-        })\n-        .toSet());\n+    context = createSubcontext(context);\n     writeAnnotations(appendable, context);\n     writeModifiers(appendable).append(\"enum \").append(name.simpleName());\n     Writables.Joiner.on(\", \").prefix(\" implements \")\n"
    },
    {
        "commit_hash": "ed4da020b6bd7b741c6f0ac3d9498fffba5a99fb",
        "previous_commit_hash": "0572bbf2ebbac0958b871c56a7d4877db05d06ba",
        "diff_stats": {
            "additions": 1,
            "deletions": 7
        },
        "diff_content": "@@ -43,13 +43,7 @@ public final class InterfaceWriter extends TypeWriter {\n \n   @Override\n   public Appendable write(Appendable appendable, Context context) throws IOException {\n-    context = context.createSubcontext(FluentIterable.from(nestedTypeWriters)\n-        .transform(new Function<TypeWriter, ClassName>() {\n-          @Override public ClassName apply(TypeWriter input) {\n-            return input.name;\n-          }\n-        })\n-        .toSet());\n+    context = createSubcontext(context);\n     writeAnnotations(appendable, context);\n     writeModifiers(appendable).append(\"interface \").append(name.simpleName());\n     Writables.Joiner.on(\", \").wrap(\"<\", \"> \").appendTo(appendable, context, typeVariables);\n"
    },
    {
        "commit_hash": "ed4da020b6bd7b741c6f0ac3d9498fffba5a99fb",
        "previous_commit_hash": "0572bbf2ebbac0958b871c56a7d4877db05d06ba",
        "diff_stats": {
            "additions": 10,
            "deletions": 0
        },
        "diff_content": "@@ -189,6 +189,16 @@ public abstract class TypeWriter /* ha ha */ extends Modifiable\n     return appendable;\n   }\n \n+  protected Context createSubcontext(Context context) {\n+    return context.createSubcontext(FluentIterable.from(nestedTypeWriters)\n+        .transform(new Function<TypeWriter, ClassName>() {\n+          @Override public ClassName apply(TypeWriter input) {\n+            return input.name();\n+          }\n+        })\n+        .toSet());\n+  }\n+\n   static final class CompilationUnitContext implements Context {\n     private final String packageName;\n     private final ImmutableSortedSet<ClassName> visibleClasses;\n"
    },
    {
        "commit_hash": "468ddf4fa00e62303e56c30746816c508ccce959",
        "previous_commit_hash": "0572bbf2ebbac0958b871c56a7d4877db05d06ba",
        "diff_stats": {
            "additions": 1,
            "deletions": 7
        },
        "diff_content": "@@ -15,7 +15,6 @@\n  */\n package com.squareup.javawriter;\n \n-import com.google.common.base.Function;\n import com.google.common.collect.FluentIterable;\n import com.google.common.collect.Lists;\n import java.io.IOException;\n@@ -55,12 +54,7 @@ public final class BlockWriter implements Writable, HasClassReferences {\n   @Override\n   public Set<ClassName> referencedClasses() {\n     return FluentIterable.from(snippets)\n-        .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {\n-          @Override\n-          public Set<ClassName> apply(HasClassReferences input) {\n-            return input.referencedClasses();\n-          }\n-        })\n+        .transformAndConcat(GET_REFERENCED_CLASSES)\n         .toSet();\n   }\n }\n"
    },
    {
        "commit_hash": "468ddf4fa00e62303e56c30746816c508ccce959",
        "previous_commit_hash": "0572bbf2ebbac0958b871c56a7d4877db05d06ba",
        "diff_stats": {
            "additions": 1,
            "deletions": 6
        },
        "diff_content": "@@ -130,12 +130,7 @@ public final class ClassWriter extends TypeWriter {\n         Iterables.concat(nestedTypeWriters, fieldWriters.values(), constructorWriters,\n             methodWriters, implementedTypes, supertype.asSet(), typeVariables, annotations);\n     return FluentIterable.from(concat)\n-        .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {\n-          @Override\n-          public Set<ClassName> apply(HasClassReferences input) {\n-            return input.referencedClasses();\n-          }\n-        })\n+        .transformAndConcat(GET_REFERENCED_CLASSES)\n         .toSet();\n   }\n }\n"
    },
    {
        "commit_hash": "468ddf4fa00e62303e56c30746816c508ccce959",
        "previous_commit_hash": "0572bbf2ebbac0958b871c56a7d4877db05d06ba",
        "diff_stats": {
            "additions": 1,
            "deletions": 7
        },
        "diff_content": "@@ -15,7 +15,6 @@\n  */\n package com.squareup.javawriter;\n \n-import com.google.common.base.Function;\n import com.google.common.collect.FluentIterable;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Iterables;\n@@ -79,12 +78,7 @@ public final class ConstructorWriter extends Modifiable implements Writable, Has\n   public Set<ClassName> referencedClasses() {\n     return FluentIterable.from(\n         Iterables.concat(typeVariables, parameterWriters.values(), ImmutableList.of(blockWriter)))\n-            .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {\n-              @Override\n-              public Set<ClassName> apply(HasClassReferences input) {\n-                return input.referencedClasses();\n-              }\n-            })\n+            .transformAndConcat(GET_REFERENCED_CLASSES)\n             .toSet();\n   }\n \n"
    },
    {
        "commit_hash": "468ddf4fa00e62303e56c30746816c508ccce959",
        "previous_commit_hash": "0572bbf2ebbac0958b871c56a7d4877db05d06ba",
        "diff_stats": {
            "additions": 2,
            "deletions": 12
        },
        "diff_content": "@@ -126,12 +126,7 @@ public final class EnumWriter extends TypeWriter {\n         Iterables.concat(nestedTypeWriters, constantWriters.values(), fieldWriters.values(),\n             constructorWriters, methodWriters, implementedTypes, annotations);\n     return FluentIterable.from(concat)\n-        .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {\n-          @Override\n-          public Set<ClassName> apply(HasClassReferences input) {\n-            return input.referencedClasses();\n-          }\n-        })\n+        .transformAndConcat(GET_REFERENCED_CLASSES)\n         .toSet();\n   }\n \n@@ -159,12 +154,7 @@ public final class EnumWriter extends TypeWriter {\n     @Override\n     public Set<ClassName> referencedClasses() {\n       return FluentIterable.from(constructorSnippets)\n-          .transformAndConcat(new Function<Snippet, Set<ClassName>>() {\n-            @Override\n-            public Set<ClassName> apply(Snippet input) {\n-              return input.referencedClasses();\n-            }\n-          })\n+          .transformAndConcat(GET_REFERENCED_CLASSES)\n           .toSet();\n     }\n   }\n"
    },
    {
        "commit_hash": "468ddf4fa00e62303e56c30746816c508ccce959",
        "previous_commit_hash": "0572bbf2ebbac0958b871c56a7d4877db05d06ba",
        "diff_stats": {
            "additions": 1,
            "deletions": 7
        },
        "diff_content": "@@ -15,7 +15,6 @@\n  */\n package com.squareup.javawriter;\n \n-import com.google.common.base.Function;\n import com.google.common.base.Optional;\n import com.google.common.collect.FluentIterable;\n import com.google.common.collect.ImmutableList;\n@@ -55,12 +54,7 @@ public final class FieldWriter extends VariableWriter {\n     Iterable<? extends HasClassReferences> concat =\n         Iterables.concat(ImmutableList.of(type()), initializer.asSet(), annotations);\n     return FluentIterable.from(concat)\n-        .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {\n-          @Override\n-          public Set<ClassName> apply(HasClassReferences input) {\n-            return input.referencedClasses();\n-          }\n-        })\n+        .transformAndConcat(GET_REFERENCED_CLASSES)\n         .toSet();\n   }\n }\n"
    },
    {
        "commit_hash": "468ddf4fa00e62303e56c30746816c508ccce959",
        "previous_commit_hash": "0572bbf2ebbac0958b871c56a7d4877db05d06ba",
        "diff_stats": {
            "additions": 9,
            "deletions": 0
        },
        "diff_content": "@@ -15,8 +15,17 @@\n  */\n package com.squareup.javawriter;\n \n+import com.google.common.base.Function;\n import java.util.Set;\n \n public interface HasClassReferences {\n+  Function<HasClassReferences, Set<ClassName>> GET_REFERENCED_CLASSES =\n+      new Function<HasClassReferences, Set<ClassName>>() {\n+        @Override\n+        public Set<ClassName> apply(HasClassReferences input) {\n+          return input.referencedClasses();\n+        }\n+      };\n+\n   Set<ClassName> referencedClasses();\n }\n"
    },
    {
        "commit_hash": "468ddf4fa00e62303e56c30746816c508ccce959",
        "previous_commit_hash": "0572bbf2ebbac0958b871c56a7d4877db05d06ba",
        "diff_stats": {
            "additions": 1,
            "deletions": 6
        },
        "diff_content": "@@ -74,12 +74,7 @@ public final class InterfaceWriter extends TypeWriter {\n         Iterables.concat(nestedTypeWriters, methodWriters, implementedTypes, typeVariables,\n             annotations);\n     return FluentIterable.from(concat)\n-        .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {\n-          @Override\n-          public Set<ClassName> apply(HasClassReferences input) {\n-            return input.referencedClasses();\n-          }\n-        })\n+        .transformAndConcat(GET_REFERENCED_CLASSES)\n         .toSet();\n   }\n }\n"
    },
    {
        "commit_hash": "468ddf4fa00e62303e56c30746816c508ccce959",
        "previous_commit_hash": "0572bbf2ebbac0958b871c56a7d4877db05d06ba",
        "diff_stats": {
            "additions": 1,
            "deletions": 6
        },
        "diff_content": "@@ -15,7 +15,6 @@\n  */\n package com.squareup.javawriter;\n \n-import com.google.common.base.Function;\n import com.google.common.collect.FluentIterable;\n import java.io.IOException;\n import java.util.List;\n@@ -30,11 +29,7 @@ final class IntersectionTypeName implements TypeName {\n \n   @Override public Set<ClassName> referencedClasses() {\n     return FluentIterable.from(typeNames)\n-        .transformAndConcat(new Function<TypeName, Iterable<ClassName>>() {\n-          @Override public Iterable<ClassName> apply(TypeName input) {\n-            return input.referencedClasses();\n-          }\n-        })\n+        .transformAndConcat(GET_REFERENCED_CLASSES)\n         .toSet();\n   }\n \n"
    },
    {
        "commit_hash": "468ddf4fa00e62303e56c30746816c508ccce959",
        "previous_commit_hash": "0572bbf2ebbac0958b871c56a7d4877db05d06ba",
        "diff_stats": {
            "additions": 1,
            "deletions": 7
        },
        "diff_content": "@@ -15,7 +15,6 @@\n  */\n package com.squareup.javawriter;\n \n-import com.google.common.base.Function;\n import com.google.common.base.Optional;\n import com.google.common.collect.FluentIterable;\n import com.google.common.collect.ImmutableList;\n@@ -107,12 +106,7 @@ public final class MethodWriter extends Modifiable implements HasClassReferences\n         Iterables.concat(typeVariables, ImmutableList.of(returnType), parameterWriters.values(),\n             body.asSet());\n     return FluentIterable.from(concat)\n-        .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {\n-          @Override\n-          public Set<ClassName> apply(HasClassReferences input) {\n-            return input.referencedClasses();\n-          }\n-        })\n+        .transformAndConcat(GET_REFERENCED_CLASSES)\n         .toSet();\n   }\n }\n"
    },
    {
        "commit_hash": "468ddf4fa00e62303e56c30746816c508ccce959",
        "previous_commit_hash": "0572bbf2ebbac0958b871c56a7d4877db05d06ba",
        "diff_stats": {
            "additions": 5,
            "deletions": 7
        },
        "diff_content": "@@ -16,8 +16,8 @@\n package com.squareup.javawriter;\n \n import com.google.common.base.Objects;\n+import com.google.common.collect.FluentIterable;\n import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableSet;\n import java.io.IOException;\n import java.util.Set;\n \n@@ -35,12 +35,10 @@ public final class ParameterizedTypeName implements TypeName {\n \n   @Override\n   public Set<ClassName> referencedClasses() {\n-    ImmutableSet.Builder<ClassName> builder = new ImmutableSet.Builder<ClassName>()\n-        .add(type);\n-    for (TypeName parameter : parameters) {\n-      builder.addAll(parameter.referencedClasses());\n-    }\n-    return builder.build();\n+    return FluentIterable.from(parameters)\n+        .transformAndConcat(GET_REFERENCED_CLASSES)\n+        .append(type)\n+        .toSet();\n   }\n \n   @Override\n"
    },
    {
        "commit_hash": "468ddf4fa00e62303e56c30746816c508ccce959",
        "previous_commit_hash": "0572bbf2ebbac0958b871c56a7d4877db05d06ba",
        "diff_stats": {
            "additions": 1,
            "deletions": 7
        },
        "diff_content": "@@ -15,7 +15,6 @@\n  */\n package com.squareup.javawriter;\n \n-import com.google.common.base.Function;\n import com.google.common.base.Joiner;\n import com.google.common.collect.FluentIterable;\n import com.google.common.collect.ImmutableList;\n@@ -59,12 +58,7 @@ public final class Snippet implements HasClassReferences, Writable {\n   @Override\n   public Set<ClassName> referencedClasses() {\n     return FluentIterable.from(types)\n-        .transformAndConcat(new Function<TypeName, Set<ClassName>>() {\n-          @Override\n-          public Set<ClassName> apply(TypeName input) {\n-            return input.referencedClasses();\n-          }\n-        })\n+        .transformAndConcat(GET_REFERENCED_CLASSES)\n         .toSet();\n   }\n \n"
    },
    {
        "commit_hash": "468ddf4fa00e62303e56c30746816c508ccce959",
        "previous_commit_hash": "0572bbf2ebbac0958b871c56a7d4877db05d06ba",
        "diff_stats": {
            "additions": 3,
            "deletions": 6
        },
        "diff_content": "@@ -19,7 +19,6 @@ import com.google.common.base.Objects;\n import com.google.common.base.Predicates;\n import com.google.common.collect.FluentIterable;\n import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableSet;\n import java.io.IOException;\n import java.util.Set;\n import javax.lang.model.element.NestingKind;\n@@ -69,11 +68,9 @@ public final class TypeVariableName implements TypeName {\n \n   @Override\n   public Set<ClassName> referencedClasses() {\n-    ImmutableSet.Builder<ClassName> builder = new ImmutableSet.Builder<ClassName>();\n-    for (TypeName bound : bounds) {\n-      builder.addAll(bound.referencedClasses());\n-    }\n-    return builder.build();\n+    return FluentIterable.from(bounds)\n+        .transformAndConcat(GET_REFERENCED_CLASSES)\n+        .toSet();\n   }\n \n   @Override\n"
    },
    {
        "commit_hash": "468ddf4fa00e62303e56c30746816c508ccce959",
        "previous_commit_hash": "0572bbf2ebbac0958b871c56a7d4877db05d06ba",
        "diff_stats": {
            "additions": 5,
            "deletions": 9
        },
        "diff_content": "@@ -16,7 +16,8 @@\n package com.squareup.javawriter;\n \n import com.google.common.base.Optional;\n-import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.Iterables;\n import java.io.IOException;\n import java.util.Set;\n import javax.lang.model.type.WildcardType;\n@@ -53,14 +54,9 @@ public final class WildcardName implements TypeName {\n \n   @Override\n   public Set<ClassName> referencedClasses() {\n-    ImmutableSet.Builder<ClassName> builder = ImmutableSet.builder();\n-    if (extendsBound.isPresent()) {\n-      builder.addAll(extendsBound.get().referencedClasses());\n-    }\n-    if (superBound.isPresent()) {\n-      builder.addAll(superBound.get().referencedClasses());\n-    }\n-    return builder.build();\n+    return FluentIterable.from(Iterables.concat(extendsBound.asSet(), superBound.asSet()))\n+        .transformAndConcat(GET_REFERENCED_CLASSES)\n+        .toSet();\n   }\n \n   @Override\n"
    },
    {
        "commit_hash": "fc6679c6ba09c8103b94344c01e3b973969d2930",
        "previous_commit_hash": "1741f8793d037e09e766cefe98166d7b010b32f6",
        "diff_stats": {
            "additions": 4,
            "deletions": 0
        },
        "diff_content": "@@ -50,4 +50,8 @@ final class ArrayTypeName implements TypeName {\n   public String toString() {\n     return Writables.writeToString(this);\n   }\n+\n+  public static ArrayTypeName create(TypeName componentType) {\n+    return new ArrayTypeName(componentType);\n+  }\n }\n"
    },
    {
        "commit_hash": "fc6679c6ba09c8103b94344c01e3b973969d2930",
        "previous_commit_hash": "1741f8793d037e09e766cefe98166d7b010b32f6",
        "diff_stats": {
            "additions": 7,
            "deletions": 0
        },
        "diff_content": "@@ -16,6 +16,9 @@\n package com.squareup.javawriter;\n \n import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Lists;\n+\n import java.io.IOException;\n import java.util.List;\n import java.util.Set;\n@@ -46,4 +49,8 @@ final class IntersectionTypeName implements TypeName {\n     return obj instanceof IntersectionTypeName\n         && ((IntersectionTypeName) obj).typeNames.equals(typeNames);\n   }\n+\n+  public static IntersectionTypeName create(TypeName bound1, TypeName bound2, TypeName... rest) {\n+    return new IntersectionTypeName(ImmutableList.copyOf(Lists.asList(bound1, bound2, rest)));\n+  }\n }\n"
    },
    {
        "commit_hash": "fc6679c6ba09c8103b94344c01e3b973969d2930",
        "previous_commit_hash": "1741f8793d037e09e766cefe98166d7b010b32f6",
        "diff_stats": {
            "additions": 5,
            "deletions": 1
        },
        "diff_content": "@@ -41,10 +41,14 @@ public final class TypeVariableName implements TypeName {\n         .toList();\n   }\n \n-  static TypeVariableName named(String name) {\n+  public static TypeVariableName create(String name) {\n     return new TypeVariableName(name, ImmutableList.<TypeName>of());\n   }\n \n+  public static TypeVariableName create(String name, TypeName... bounds) {\n+    return new TypeVariableName(name, ImmutableList.copyOf(bounds));\n+  }\n+\n   static TypeVariableName forTypeMirror(TypeVariable mirror) {\n     FluentIterable<TypeMirror> bounds =\n         FluentIterable.from(ImmutableList.of(mirror.getUpperBound()));\n"
    },
    {
        "commit_hash": "fc6679c6ba09c8103b94344c01e3b973969d2930",
        "previous_commit_hash": "1741f8793d037e09e766cefe98166d7b010b32f6",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -77,7 +77,7 @@ public class TypeNamesTest {\n         getElement(Parameterized.class).getTypeParameters();\n \n     assert_().that(TypeNames.forTypeMirror(typeVariables.get(0).asType()))\n-        .isEqualTo(TypeVariableName.named(\"Simple\"));\n+        .isEqualTo(TypeVariableName.create(\"Simple\"));\n     assert_().that(TypeNames.forTypeMirror(typeVariables.get(1).asType()))\n         .isEqualTo(new TypeVariableName(\"ExtendsClass\", ImmutableList.<TypeName>of(\n             ClassName.fromClass(Number.class))));\n@@ -86,7 +86,7 @@ public class TypeNamesTest {\n             ClassName.fromClass(Runnable.class))));\n     assert_().that(TypeNames.forTypeMirror(typeVariables.get(3).asType()))\n         .isEqualTo(new TypeVariableName(\"ExtendsTypeVariable\", ImmutableList.<TypeName>of(\n-            TypeVariableName.named(\"Simple\"))));\n+            TypeVariableName.create(\"Simple\"))));\n   }\n \n   @Test\n"
    },
    {
        "commit_hash": "e5ec435fe7b7b16f9c4384e9631cf7af92772f75",
        "previous_commit_hash": "1741f8793d037e09e766cefe98166d7b010b32f6",
        "diff_stats": {
            "additions": 1,
            "deletions": 5
        },
        "diff_content": "@@ -44,11 +44,7 @@ public final class BlockWriter implements Writable, HasClassReferences {\n \n   @Override\n   public Appendable write(Appendable appendable, Context context) throws IOException {\n-    for (Snippet snippet : snippets) {\n-      appendable.append('\\n');\n-      snippet.write(appendable, context);\n-    }\n-    return appendable.append('\\n');\n+    return Writables.Joiner.on('\\n').appendTo(appendable, context, snippets);\n   }\n \n   @Override\n"
    },
    {
        "commit_hash": "e5ec435fe7b7b16f9c4384e9631cf7af92772f75",
        "previous_commit_hash": "1741f8793d037e09e766cefe98166d7b010b32f6",
        "diff_stats": {
            "additions": 9,
            "deletions": 5
        },
        "diff_content": "@@ -32,13 +32,13 @@ public final class ConstructorWriter extends Modifiable implements Writable, Has\n   private final List<TypeVariableName> typeVariables;\n   private final String name;\n   private final Map<String, VariableWriter> parameterWriters;\n-  private final BlockWriter blockWriter;\n+  private final BlockWriter body;\n \n   ConstructorWriter(String name) {\n     this.typeVariables = Lists.newArrayList();\n     this.name = name;\n     this.parameterWriters = Maps.newLinkedHashMap();\n-    this.blockWriter = new BlockWriter();\n+    this.body = new BlockWriter();\n   }\n \n   public void addTypeVariable(TypeVariableName typeVariable) {\n@@ -64,7 +64,7 @@ public final class ConstructorWriter extends Modifiable implements Writable, Has\n   }\n \n   public BlockWriter body() {\n-    return blockWriter;\n+    return body;\n   }\n \n   private VariableWriter addParameter(ClassName type, String name) {\n@@ -77,7 +77,7 @@ public final class ConstructorWriter extends Modifiable implements Writable, Has\n   @Override\n   public Set<ClassName> referencedClasses() {\n     return FluentIterable.from(\n-        Iterables.concat(typeVariables, parameterWriters.values(), ImmutableList.of(blockWriter)))\n+        Iterables.concat(typeVariables, parameterWriters.values(), ImmutableList.of(body)))\n             .transformAndConcat(GET_REFERENCED_CLASSES)\n             .toSet();\n   }\n@@ -89,7 +89,11 @@ public final class ConstructorWriter extends Modifiable implements Writable, Has\n     appendable.append(name).append('(');\n     Writables.Joiner.on(\", \").appendTo(appendable, context, parameterWriters.values());\n     appendable.append(\") {\");\n-    blockWriter.write(new IndentingAppendable(appendable), context);\n+    if (!body.isEmpty()) {\n+      appendable.append('\\n');\n+      body.write(new IndentingAppendable(appendable), context);\n+      appendable.append('\\n');\n+    }\n     return appendable.append(\"}\\n\");\n   }\n }\n"
    },
    {
        "commit_hash": "e5ec435fe7b7b16f9c4384e9631cf7af92772f75",
        "previous_commit_hash": "1741f8793d037e09e766cefe98166d7b010b32f6",
        "diff_stats": {
            "additions": 7,
            "deletions": 4
        },
        "diff_content": "@@ -43,22 +43,25 @@ final class IndentingAppendable implements Appendable {\n     Iterator<CharSequence> lines = lines(csq, start, end);\n     while (lines.hasNext()) {\n       CharSequence line = lines.next();\n-      maybeIndent();\n-      delegate.append(line);\n+      if (line.length() > 1 || line.charAt(0) != '\\n') {\n+        maybeIndent();\n+      }\n       if (line.charAt(line.length() - 1) == '\\n') {\n         requiresIndent = true;\n       }\n+      delegate.append(line);\n     }\n     return this;\n   }\n \n   @Override\n   public Appendable append(char c) throws IOException {\n-    maybeIndent();\n-    delegate.append(c);\n     if (c == '\\n') {\n       requiresIndent = true;\n+    } else {\n+      maybeIndent();\n     }\n+    delegate.append(c);\n     return this;\n   }\n \n"
    },
    {
        "commit_hash": "e5ec435fe7b7b16f9c4384e9631cf7af92772f75",
        "previous_commit_hash": "1741f8793d037e09e766cefe98166d7b010b32f6",
        "diff_stats": {
            "additions": 14,
            "deletions": 16
        },
        "diff_content": "@@ -15,7 +15,6 @@\n  */\n package com.squareup.javawriter;\n \n-import com.google.common.base.Optional;\n import com.google.common.collect.FluentIterable;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Iterables;\n@@ -25,6 +24,7 @@ import java.io.IOException;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import javax.lang.model.element.Modifier;\n import javax.lang.model.element.TypeElement;\n \n import static com.google.common.base.Preconditions.checkArgument;\n@@ -35,7 +35,7 @@ public final class MethodWriter extends Modifiable implements HasClassReferences\n   private final String name;\n   private final Map<String, VariableWriter> parameterWriters;\n   private final List<ClassName> throwsTypes;\n-  private Optional<BlockWriter> body;\n+  private BlockWriter body;\n \n   MethodWriter(TypeName returnType, String name) {\n     this.typeVariables = Lists.newArrayList();\n@@ -43,7 +43,7 @@ public final class MethodWriter extends Modifiable implements HasClassReferences\n     this.name = name;\n     this.parameterWriters = Maps.newLinkedHashMap();\n     this.throwsTypes = Lists.newArrayList();\n-    this.body = Optional.absent();\n+    this.body = new BlockWriter();\n   }\n \n   public String name() {\n@@ -82,13 +82,7 @@ public final class MethodWriter extends Modifiable implements HasClassReferences\n   }\n \n   public BlockWriter body() {\n-    if (body.isPresent()) {\n-      return body.get();\n-    } else {\n-      BlockWriter blockWriter = new BlockWriter();\n-      body = Optional.of(blockWriter);\n-      return blockWriter;\n-    }\n+    return body;\n   }\n \n   @Override\n@@ -101,12 +95,16 @@ public final class MethodWriter extends Modifiable implements HasClassReferences\n     Writables.Joiner.on(\", \").appendTo(appendable, context, parameterWriters.values());\n     appendable.append(\")\");\n     Writables.Joiner.on(\", \").prefix(\" throws \").appendTo(appendable, context, throwsTypes);\n-    if (body.isPresent()) {\n+    if (modifiers.contains(Modifier.ABSTRACT)) {\n+      appendable.append(\";\\n\");\n+    } else {\n       appendable.append(\" {\");\n-      body.get().write(new IndentingAppendable(appendable), context);\n+      if (!body.isEmpty()) {\n+        appendable.append('\\n');\n+        body.write(new IndentingAppendable(appendable), context);\n+        appendable.append('\\n');\n+      }\n       appendable.append(\"}\\n\");\n-    } else {\n-      appendable.append(\";\\n\");\n     }\n     return appendable;\n   }\n@@ -114,8 +112,8 @@ public final class MethodWriter extends Modifiable implements HasClassReferences\n   @Override\n   public Set<ClassName> referencedClasses() {\n     Iterable<? extends HasClassReferences> concat =\n-        Iterables.concat(typeVariables, ImmutableList.of(returnType), parameterWriters.values(),\n-            throwsTypes, body.asSet());\n+        Iterables.concat(typeVariables, ImmutableList.of(returnType, body),\n+            parameterWriters.values(), throwsTypes);\n     return FluentIterable.from(concat)\n         .transformAndConcat(GET_REFERENCED_CLASSES)\n         .toSet();\n"
    },
    {
        "commit_hash": "e5ec435fe7b7b16f9c4384e9631cf7af92772f75",
        "previous_commit_hash": "1741f8793d037e09e766cefe98166d7b010b32f6",
        "diff_stats": {
            "additions": 44,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright (C) 2014 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter;\n+\n+import com.google.common.base.Joiner;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+@RunWith(JUnit4.class)\n+public final class ConstructorWriterTest {\n+  @Test public void empty() {\n+    ConstructorWriter test = new ConstructorWriter(\"Test\");\n+    String actual = Writables.writeToString(test);\n+    assertThat(actual).isEqualTo(\"Test() {}\\n\");\n+  }\n+\n+  @Test public void multilineBody() {\n+    ConstructorWriter test = new ConstructorWriter(\"Test\");\n+    test.body().addSnippet(\"String firstName;\\nString lastName;\");\n+    String actual = Writables.writeToString(test);\n+    assertThat(actual).isEqualTo(Joiner.on('\\n').join(\n+        \"Test() {\",\n+        \"  String firstName;\",\n+        \"  String lastName;\",\n+        \"}\\n\"\n+    ));\n+  }\n+}\n"
    },
    {
        "commit_hash": "e5ec435fe7b7b16f9c4384e9631cf7af92772f75",
        "previous_commit_hash": "1741f8793d037e09e766cefe98166d7b010b32f6",
        "diff_stats": {
            "additions": 74,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright (C) 2014 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter;\n+\n+import com.google.common.base.Joiner;\n+import java.io.IOException;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+@RunWith(JUnit4.class)\n+public final class IndentingAppendableTest {\n+  private final StringBuilder data = new StringBuilder();\n+  private final Appendable appendable = new IndentingAppendable(data);\n+\n+  @Test public void newlineCharacterNeverTriggerPendingIndent() throws IOException {\n+    appendable.append(\"Hello\\n\").append('\\n').append(\"World!\");\n+    assertThat(data.toString()).isEqualTo(Joiner.on('\\n').join(\n+        \"  Hello\",\n+        \"\",\n+        \"  World!\"\n+    ));\n+  }\n+\n+  @Test public void newlineStringNeverTriggerPendingIndent() throws IOException {\n+    appendable.append(\"Hello\\n\").append(\"\\n\").append(\"World!\");\n+    assertThat(data.toString()).isEqualTo(Joiner.on('\\n').join(\"  Hello\", \"\", \"  World!\"));\n+  }\n+\n+  @Test public void nestingAppendables() throws IOException {\n+    appendable.append(\"Hello\\n\");\n+    new IndentingAppendable(appendable).append(\"World\\n\");\n+    appendable.append(\"This Is\\n\");\n+    new IndentingAppendable(appendable).append(\"A Test\\n\");\n+\n+    assertThat(data.toString()).isEqualTo(Joiner.on('\\n').join(\n+        \"  Hello\",\n+        \"    World\",\n+        \"  This Is\",\n+        \"    A Test\",\n+        \"\"\n+    ));\n+  }\n+\n+  @Test public void nestingInsideContent() throws IOException {\n+    appendable.append(Joiner.on('\\n').join(\n+        \"def fib(num):\",\n+        \"  if num == 1 or num == 2:\",\n+        \"    return 1\",\n+        \"  return fib(num - 1) + fib(num - 2)\"\n+    ));\n+    assertThat(data.toString()).isEqualTo(Joiner.on('\\n').join(\n+        \"  def fib(num):\",\n+        \"    if num == 1 or num == 2:\",\n+        \"      return 1\",\n+        \"    return fib(num - 1) + fib(num - 2)\"\n+    ));\n+  }\n+}\n"
    },
    {
        "commit_hash": "e5ec435fe7b7b16f9c4384e9631cf7af92772f75",
        "previous_commit_hash": "1741f8793d037e09e766cefe98166d7b010b32f6",
        "diff_stats": {
            "additions": 22,
            "deletions": 4
        },
        "diff_content": "@@ -25,12 +25,30 @@ import static com.google.common.truth.Truth.assertThat;\n \n @RunWith(JUnit4.class)\n public final class MethodWriterTest {\n+  @Test public void empty() {\n+    MethodWriter test = new MethodWriter(VoidName.VOID, \"test\");\n+    String actual = Writables.writeToString(test);\n+    assertThat(actual).isEqualTo(\"void test() {}\\n\");\n+  }\n+\n+  @Test public void multilineBody() {\n+    MethodWriter test = new MethodWriter(VoidName.VOID, \"test\");\n+    test.body().addSnippet(\"String firstName;\\nString lastName;\");\n+    String actual = Writables.writeToString(test);\n+    assertThat(actual).isEqualTo(Joiner.on('\\n').join(\n+        \"void test() {\",\n+        \"  String firstName;\",\n+        \"  String lastName;\",\n+        \"}\\n\"\n+    ));\n+  }\n+\n   @Test public void singleThrowsTypeName() {\n     MethodWriter method = new MethodWriter(VoidName.VOID, \"test\");\n     method.addThrowsType(ClassName.fromClass(IOException.class));\n \n     assertThat(Writables.writeToString(method)) //\n-        .isEqualTo(\"void test() throws java.io.IOException;\\n\");\n+        .isEqualTo(\"void test() throws java.io.IOException {}\\n\");\n   }\n \n   @Test public void singleThrowsClass() {\n@@ -38,7 +56,7 @@ public final class MethodWriterTest {\n     method.addThrowsType(ClassName.fromClass(IOException.class));\n \n     assertThat(Writables.writeToString(method)) //\n-        .isEqualTo(\"void test() throws java.io.IOException;\\n\");\n+        .isEqualTo(\"void test() throws java.io.IOException {}\\n\");\n   }\n \n   @Test public void throwsWithBody() {\n@@ -47,7 +65,7 @@ public final class MethodWriterTest {\n     method.body().addSnippet(\"return 0;\");\n \n     assertThat(Writables.writeToString(method)).isEqualTo(Joiner.on('\\n').join(\n-        \"int test() throws java.io.IOException {  \",\n+        \"int test() throws java.io.IOException {\",\n         \"  return 0;\",\n         \"}\\n\"\n     ));\n@@ -59,6 +77,6 @@ public final class MethodWriterTest {\n     method.addThrowsType(ClassName.create(\"example\", \"ExampleException\"));\n \n     assertThat(Writables.writeToString(method)) //\n-        .isEqualTo(\"void test() throws java.io.IOException, example.ExampleException;\\n\");\n+        .isEqualTo(\"void test() throws java.io.IOException, example.ExampleException {}\\n\");\n   }\n }\n"
    },
    {
        "commit_hash": "5825acc5b77323c73819e31373f5da0f1d97525c",
        "previous_commit_hash": "35c756f3b1a4977be08c7c0ccb9ba485833ffc00",
        "diff_stats": {
            "additions": 2,
            "deletions": 4
        },
        "diff_content": "@@ -88,11 +88,9 @@ public final class ConstructorWriter extends Modifiable implements Writable, Has\n     Writables.Joiner.on(\", \").wrap(\"<\", \"> \").appendTo(appendable, context, typeVariables);\n     appendable.append(name).append('(');\n     Writables.Joiner.on(\", \").appendTo(appendable, context, parameterWriters.values());\n-    appendable.append(\") {\");\n+    appendable.append(\") {\\n\");\n     if (!body.isEmpty()) {\n-      appendable.append('\\n');\n-      body.write(new IndentingAppendable(appendable), context);\n-      appendable.append('\\n');\n+      body.write(new IndentingAppendable(appendable), context).append('\\n');\n     }\n     return appendable.append(\"}\\n\");\n   }\n"
    },
    {
        "commit_hash": "5825acc5b77323c73819e31373f5da0f1d97525c",
        "previous_commit_hash": "35c756f3b1a4977be08c7c0ccb9ba485833ffc00",
        "diff_stats": {
            "additions": 2,
            "deletions": 4
        },
        "diff_content": "@@ -98,11 +98,9 @@ public final class MethodWriter extends Modifiable implements HasClassReferences\n     if (modifiers.contains(Modifier.ABSTRACT)) {\n       appendable.append(\";\\n\");\n     } else {\n-      appendable.append(\" {\");\n+      appendable.append(\" {\\n\");\n       if (!body.isEmpty()) {\n-        appendable.append('\\n');\n-        body.write(new IndentingAppendable(appendable), context);\n-        appendable.append('\\n');\n+        body.write(new IndentingAppendable(appendable), context).append('\\n');\n       }\n       appendable.append(\"}\\n\");\n     }\n"
    },
    {
        "commit_hash": "5825acc5b77323c73819e31373f5da0f1d97525c",
        "previous_commit_hash": "35c756f3b1a4977be08c7c0ccb9ba485833ffc00",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -27,7 +27,7 @@ public final class ConstructorWriterTest {\n   @Test public void empty() {\n     ConstructorWriter test = new ConstructorWriter(\"Test\");\n     String actual = Writables.writeToString(test);\n-    assertThat(actual).isEqualTo(\"Test() {}\\n\");\n+    assertThat(actual).isEqualTo(\"Test() {\\n}\\n\");\n   }\n \n   @Test public void multilineBody() {\n"
    },
    {
        "commit_hash": "5825acc5b77323c73819e31373f5da0f1d97525c",
        "previous_commit_hash": "35c756f3b1a4977be08c7c0ccb9ba485833ffc00",
        "diff_stats": {
            "additions": 4,
            "deletions": 4
        },
        "diff_content": "@@ -28,7 +28,7 @@ public final class MethodWriterTest {\n   @Test public void empty() {\n     MethodWriter test = new MethodWriter(VoidName.VOID, \"test\");\n     String actual = Writables.writeToString(test);\n-    assertThat(actual).isEqualTo(\"void test() {}\\n\");\n+    assertThat(actual).isEqualTo(\"void test() {\\n}\\n\");\n   }\n \n   @Test public void multilineBody() {\n@@ -48,7 +48,7 @@ public final class MethodWriterTest {\n     method.addThrowsType(ClassName.fromClass(IOException.class));\n \n     assertThat(Writables.writeToString(method)) //\n-        .isEqualTo(\"void test() throws java.io.IOException {}\\n\");\n+        .isEqualTo(\"void test() throws java.io.IOException {\\n}\\n\");\n   }\n \n   @Test public void singleThrowsClass() {\n@@ -56,7 +56,7 @@ public final class MethodWriterTest {\n     method.addThrowsType(ClassName.fromClass(IOException.class));\n \n     assertThat(Writables.writeToString(method)) //\n-        .isEqualTo(\"void test() throws java.io.IOException {}\\n\");\n+        .isEqualTo(\"void test() throws java.io.IOException {\\n}\\n\");\n   }\n \n   @Test public void throwsWithBody() {\n@@ -77,6 +77,6 @@ public final class MethodWriterTest {\n     method.addThrowsType(ClassName.create(\"example\", \"ExampleException\"));\n \n     assertThat(Writables.writeToString(method)) //\n-        .isEqualTo(\"void test() throws java.io.IOException, example.ExampleException {}\\n\");\n+        .isEqualTo(\"void test() throws java.io.IOException, example.ExampleException {\\n}\\n\");\n   }\n }\n"
    },
    {
        "commit_hash": "9c563979a4667f31a9a89831d9acb568eee65c63",
        "previous_commit_hash": "50208351350e71529cfe576ce72e3f6690ece42f",
        "diff_stats": {
            "additions": 2,
            "deletions": 4
        },
        "diff_content": "@@ -60,10 +60,8 @@ public final class TypeNames {\n \n       @Override\n       public TypeName visitUnknown(TypeMirror t, Void p) {\n-        for (Class<?> implementedInterface : t.getClass().getInterfaces()) {\n-          if (\"javax.lang.model.type.IntersectionType\".equals(implementedInterface.getName())) {\n-            return visitIntersectionType(t);\n-          }\n+        if (\"INTERSECTION\".equals(t.getKind().name())) {\n+          return visitIntersectionType(t);\n         }\n         return super.visitUnknown(t, p);\n       }\n"
    },
    {
        "commit_hash": "9c563979a4667f31a9a89831d9acb568eee65c63",
        "previous_commit_hash": "50208351350e71529cfe576ce72e3f6690ece42f",
        "diff_stats": {
            "additions": 34,
            "deletions": 21
        },
        "diff_content": "@@ -16,9 +16,12 @@\n package com.squareup.javawriter;\n \n import com.google.common.base.Objects;\n+import com.google.common.base.Optional;\n import com.google.common.base.Predicates;\n import com.google.common.collect.FluentIterable;\n import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n import java.io.IOException;\n import java.util.Set;\n import javax.lang.model.element.NestingKind;\n@@ -32,28 +35,31 @@ import static com.squareup.javawriter.TypeNames.FOR_TYPE_MIRROR;\n \n public final class TypeVariableName implements TypeName {\n   private final String name;\n-  private final ImmutableList<TypeName> bounds;\n+  private final Optional<TypeName> upperBound;\n \n-  TypeVariableName(String name, Iterable<TypeName> bounds) {\n+  TypeVariableName(String name, Optional<TypeName> upperBound) {\n     this.name = name;\n-    this.bounds = FluentIterable.from(bounds)\n-        .filter(Predicates.not(Predicates.<TypeName>equalTo(ClassName.fromClass(Object.class))))\n-        .toList();\n+    this.upperBound = upperBound;\n   }\n \n   public static TypeVariableName create(String name) {\n-    return new TypeVariableName(name, ImmutableList.<TypeName>of());\n+    return new TypeVariableName(name, Optional.<TypeName>absent());\n   }\n \n-  public static TypeVariableName create(String name, TypeName... bounds) {\n-    return new TypeVariableName(name, ImmutableList.copyOf(bounds));\n+  public static TypeVariableName create(String name, TypeName upperBound) {\n+    return new TypeVariableName(name, Optional.of(upperBound));\n   }\n \n   static TypeVariableName forTypeMirror(TypeVariable mirror) {\n-    FluentIterable<TypeMirror> bounds =\n-        FluentIterable.from(ImmutableList.of(mirror.getUpperBound()));\n-    if (mirror.getUpperBound().getKind() == TypeKind.DECLARED) {\n-      TypeElement bound = (TypeElement) ((DeclaredType) mirror.getUpperBound()).asElement();\n+    String name = mirror.asElement().getSimpleName().toString();\n+\n+    TypeMirror upperBound = mirror.getUpperBound();\n+    FluentIterable<TypeMirror> bounds = FluentIterable.from(ImmutableList.of(upperBound));\n+    // Try to detect intersection types for Java 7 (Java 8+ has a new TypeKind for that)\n+    // Unfortunately, we can't put this logic into TypeNames.forTypeMirror() as this heuristic\n+    // only really works in the context of a TypeVariable's upper bound.\n+    if (upperBound.getKind() == TypeKind.DECLARED) {\n+      TypeElement bound = (TypeElement) ((DeclaredType) upperBound).asElement();\n       if (bound.getNestingKind() == NestingKind.ANONYMOUS) {\n         // This is (likely) an intersection type.\n         bounds = FluentIterable\n@@ -61,9 +67,15 @@ public final class TypeVariableName implements TypeName {\n             .append(bound.getInterfaces());\n       }\n     }\n-    return new TypeVariableName(\n-        mirror.asElement().getSimpleName().toString(),\n-        bounds.transform(FOR_TYPE_MIRROR));\n+    ImmutableList<TypeName> typeNames = bounds.transform(FOR_TYPE_MIRROR)\n+        .filter(Predicates.not(Predicates.<TypeName>equalTo(ClassName.fromClass(Object.class))))\n+        .toList();\n+    if (typeNames.size() == 1) {\n+      return new TypeVariableName(name, Optional.of(Iterables.getOnlyElement(typeNames)));\n+    } else if (!typeNames.isEmpty()) {\n+      return new TypeVariableName(name, Optional.<TypeName>of(new IntersectionTypeName(typeNames)));\n+    }\n+    return new TypeVariableName(name, Optional.<TypeName>absent());\n   }\n \n   public String name() {\n@@ -72,15 +84,16 @@ public final class TypeVariableName implements TypeName {\n \n   @Override\n   public Set<ClassName> referencedClasses() {\n-    return FluentIterable.from(bounds)\n-        .transformAndConcat(GET_REFERENCED_CLASSES)\n-        .toSet();\n+    return upperBound.transform(GET_REFERENCED_CLASSES).or(ImmutableSet.<ClassName>of());\n   }\n \n   @Override\n   public Appendable write(Appendable appendable, Context context) throws IOException {\n     appendable.append(name);\n-    Writables.Joiner.on(\" & \").prefix(\" extends \").appendTo(appendable, context, bounds);\n+    if (upperBound.isPresent()) {\n+      appendable.append(\" extends \");\n+      upperBound.get().write(appendable, context);\n+    }\n     return appendable;\n   }\n \n@@ -89,7 +102,7 @@ public final class TypeVariableName implements TypeName {\n     if (obj instanceof TypeVariableName) {\n       TypeVariableName that = (TypeVariableName) obj;\n       return this.name.equals(that.name)\n-          && this.bounds.equals(that.bounds);\n+          && this.upperBound.equals(that.upperBound);\n     } else {\n       return false;\n     }\n@@ -97,7 +110,7 @@ public final class TypeVariableName implements TypeName {\n \n   @Override\n   public int hashCode() {\n-    return Objects.hashCode(name, bounds);\n+    return Objects.hashCode(name, upperBound);\n   }\n \n   @Override\n"
    },
    {
        "commit_hash": "9c563979a4667f31a9a89831d9acb568eee65c63",
        "previous_commit_hash": "50208351350e71529cfe576ce72e3f6690ece42f",
        "diff_stats": {
            "additions": 0,
            "deletions": 22
        },
        "diff_content": "@@ -1,22 +0,0 @@\n-/*\n- * Copyright (C) 2014 Square, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.squareup.javawriter;\n-\n-final class TestUtil {\n-  static boolean isJava8() {\n-    return Double.parseDouble(System.getProperty(\"java.version\").substring(0, 3)) >= 1.8;\n-  }\n-}\n"
    },
    {
        "commit_hash": "9c563979a4667f31a9a89831d9acb568eee65c63",
        "previous_commit_hash": "50208351350e71529cfe576ce72e3f6690ece42f",
        "diff_stats": {
            "additions": 12,
            "deletions": 31
        },
        "diff_content": "@@ -15,8 +15,8 @@\n  */\n package com.squareup.javawriter;\n \n-import com.google.common.collect.ImmutableList;\n import com.google.testing.compile.CompilationRule;\n+import java.io.Serializable;\n import java.nio.charset.Charset;\n import java.util.List;\n import java.util.Set;\n@@ -31,8 +31,6 @@ import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n \n import static com.google.common.truth.Truth.assert_;\n-import static com.squareup.javawriter.TestUtil.isJava8;\n-import static org.junit.Assume.assumeTrue;\n \n @RunWith(JUnit4.class)\n public class TypeNamesTest {\n@@ -69,7 +67,8 @@ public class TypeNamesTest {\n       ExtendsClass extends Number,\n       ExtendsInterface extends Runnable,\n       ExtendsTypeVariable extends Simple,\n-      Intersection extends Number & Runnable> {}\n+      Intersection extends Number & Runnable,\n+      IntersectionOfInterfaces extends Runnable & Serializable> {}\n \n   @Test\n   public void forTypeMirror_typeVariable() {\n@@ -79,38 +78,20 @@ public class TypeNamesTest {\n     assert_().that(TypeNames.forTypeMirror(typeVariables.get(0).asType()))\n         .isEqualTo(TypeVariableName.create(\"Simple\"));\n     assert_().that(TypeNames.forTypeMirror(typeVariables.get(1).asType()))\n-        .isEqualTo(new TypeVariableName(\"ExtendsClass\", ImmutableList.<TypeName>of(\n-            ClassName.fromClass(Number.class))));\n+        .isEqualTo(TypeVariableName.create(\"ExtendsClass\", ClassName.fromClass(Number.class)));\n     assert_().that(TypeNames.forTypeMirror(typeVariables.get(2).asType()))\n-        .isEqualTo(new TypeVariableName(\"ExtendsInterface\", ImmutableList.<TypeName>of(\n-            ClassName.fromClass(Runnable.class))));\n+        .isEqualTo(TypeVariableName.create(\"ExtendsInterface\", ClassName.fromClass(Runnable.class)));\n     assert_().that(TypeNames.forTypeMirror(typeVariables.get(3).asType()))\n-        .isEqualTo(new TypeVariableName(\"ExtendsTypeVariable\", ImmutableList.<TypeName>of(\n-            TypeVariableName.create(\"Simple\"))));\n-  }\n-\n-  @Test\n-  public void forTypeMirror_intersectionType() {\n-    assumeTrue(!isJava8());\n-\n-    List<? extends TypeParameterElement> typeVariables =\n-        getElement(Parameterized.class).getTypeParameters();\n+        .isEqualTo(TypeVariableName.create(\"ExtendsTypeVariable\",\n+            TypeVariableName.create(\"Simple\")));\n     assert_().that(TypeNames.forTypeMirror(typeVariables.get(4).asType()))\n-        .isEqualTo(new TypeVariableName(\"Intersection\", ImmutableList.<TypeName>of(\n+        .isEqualTo(TypeVariableName.create(\"Intersection\", IntersectionTypeName.create(\n             ClassName.fromClass(Number.class),\n             ClassName.fromClass(Runnable.class))));\n-  }\n-\n-  @Test\n-  public void forTypeMirror_intersectionTypeJava8() {\n-    assumeTrue(isJava8());\n-\n-    List<? extends TypeParameterElement> typeVariables =\n-        getElement(Parameterized.class).getTypeParameters();\n-    assert_().that(TypeNames.forTypeMirror(typeVariables.get(4).asType()))\n-        .isEqualTo(new TypeVariableName(\"Intersection\", ImmutableList.<TypeName>of(\n-            new IntersectionTypeName(ImmutableList.<TypeName>of(ClassName.fromClass(Number.class),\n-                ClassName.fromClass(Runnable.class))))));\n+    assert_().that(TypeNames.forTypeMirror(typeVariables.get(5).asType()))\n+        .isEqualTo(TypeVariableName.create(\"IntersectionOfInterfaces\", IntersectionTypeName.create(\n+            ClassName.fromClass(Runnable.class),\n+            ClassName.fromClass(Serializable.class))));\n   }\n \n   @Test\n"
    },
    {
        "commit_hash": "38bc01fb3169b1af366441c55ba2760a41a26309",
        "previous_commit_hash": "c1965e5062022121ce956d238e0134670314b556",
        "diff_stats": {
            "additions": 5,
            "deletions": 12
        },
        "diff_content": "@@ -16,7 +16,6 @@\n package com.squareup.javawriter;\n \n import com.google.common.collect.FluentIterable;\n-import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n@@ -60,23 +59,17 @@ public final class EnumWriter extends TypeWriter {\n \n   @Override\n   public Appendable write(Appendable appendable, Context context) throws IOException {\n+    checkState(!constantWriters.isEmpty(), \"Cannot write an enum with no constants.\");\n+\n     context = createSubcontext(context);\n     writeAnnotations(appendable, context);\n     writeModifiers(appendable).append(\"enum \").append(name.simpleName());\n     Writables.Joiner.on(\", \").prefix(\" implements \")\n         .appendTo(appendable, context, implementedTypes);\n-    appendable.append(\" {\");\n+    appendable.append(\" {\\n\");\n \n-    checkState(!constantWriters.isEmpty(), \"Cannot write an enum with no constants.\");\n-    appendable.append('\\n');\n-    ImmutableList<ConstantWriter> constantWriterList =\n-        ImmutableList.copyOf(constantWriters.values());\n-    for (ConstantWriter constantWriter\n-        : constantWriterList.subList(0, constantWriterList.size() - 1)) {\n-      constantWriter.write(appendable, context);\n-      appendable.append(\",\\n\");\n-    }\n-    constantWriterList.get(constantWriterList.size() - 1).write(appendable, context);\n+    Writables.Joiner.on(\",\\n\")\n+        .appendTo(new IndentingAppendable(appendable), context, constantWriters.values());\n     appendable.append(\";\\n\");\n \n     if (!fieldWriters.isEmpty()) {\n"
    },
    {
        "commit_hash": "38bc01fb3169b1af366441c55ba2760a41a26309",
        "previous_commit_hash": "c1965e5062022121ce956d238e0134670314b556",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -114,7 +114,7 @@ final class Writables {\n \n     @Override\n     public Context createSubcontext(Set<ClassName> newTypes) {\n-      throw new UnsupportedOperationException();\n+      return this;\n     }\n   };\n \n"
    },
    {
        "commit_hash": "38bc01fb3169b1af366441c55ba2760a41a26309",
        "previous_commit_hash": "c1965e5062022121ce956d238e0134670314b556",
        "diff_stats": {
            "additions": 2,
            "deletions": 0
        },
        "diff_content": "@@ -20,6 +20,7 @@ import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n \n import static com.google.common.truth.Truth.assertThat;\n+import static org.junit.Assert.fail;\n \n @RunWith(JUnit4.class)\n public final class ClassWriterTest {\n@@ -27,6 +28,7 @@ public final class ClassWriterTest {\n     ClassName name = ClassName.bestGuessFromString(\"test.Foo.Bar\");\n     try {\n       ClassWriter.forClassName(name);\n+      fail();\n     } catch (IllegalArgumentException e) {\n       assertThat(e.getMessage()).isEqualTo(\"test.Foo.Bar must be top-level type.\");\n     }\n"
    },
    {
        "commit_hash": "38bc01fb3169b1af366441c55ba2760a41a26309",
        "previous_commit_hash": "c1965e5062022121ce956d238e0134670314b556",
        "diff_stats": {
            "additions": 25,
            "deletions": 0
        },
        "diff_content": "@@ -20,6 +20,7 @@ import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n \n import static com.google.common.truth.Truth.assertThat;\n+import static org.junit.Assert.fail;\n \n @RunWith(JUnit4.class)\n public final class EnumWriterTest {\n@@ -27,8 +28,32 @@ public final class EnumWriterTest {\n     ClassName name = ClassName.bestGuessFromString(\"test.Foo.Bar\");\n     try {\n       EnumWriter.forClassName(name);\n+      fail();\n     } catch (IllegalArgumentException e) {\n       assertThat(e.getMessage()).isEqualTo(\"test.Foo.Bar must be top-level type.\");\n     }\n   }\n+\n+  @Test public void constantsAreRequired() {\n+    EnumWriter enumWriter = EnumWriter.forClassName(ClassName.create(\"\", \"Test\"));\n+    try {\n+      Writables.writeToString(enumWriter);\n+      fail();\n+    } catch (IllegalStateException e) {\n+      assertThat(e.getMessage()).isEqualTo(\"Cannot write an enum with no constants.\");\n+    }\n+  }\n+\n+  @Test public void constantsAreIndented() {\n+    EnumWriter enumWriter = EnumWriter.forClassName(ClassName.create(\"\", \"Test\"));\n+    enumWriter.addConstant(\"HELLO\");\n+    enumWriter.addConstant(\"WORLD\");\n+\n+    String expected = \"\"\n+        + \"enum Test {\\n\"\n+        + \"  HELLO,\\n\"\n+        + \"  WORLD;\\n\"\n+        + \"}\\n\";\n+    assertThat(Writables.writeToString(enumWriter)).isEqualTo(expected);\n+  }\n }\n"
    },
    {
        "commit_hash": "38bc01fb3169b1af366441c55ba2760a41a26309",
        "previous_commit_hash": "c1965e5062022121ce956d238e0134670314b556",
        "diff_stats": {
            "additions": 2,
            "deletions": 0
        },
        "diff_content": "@@ -20,6 +20,7 @@ import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n \n import static com.google.common.truth.Truth.assertThat;\n+import static org.junit.Assert.fail;\n \n @RunWith(JUnit4.class)\n public final class InterfaceWriterTest {\n@@ -27,6 +28,7 @@ public final class InterfaceWriterTest {\n     ClassName name = ClassName.bestGuessFromString(\"test.Foo.Bar\");\n     try {\n       InterfaceWriter.forClassName(name);\n+      fail();\n     } catch (IllegalArgumentException e) {\n       assertThat(e.getMessage()).isEqualTo(\"test.Foo.Bar must be top-level type.\");\n     }\n"
    },
    {
        "commit_hash": "62ab3c441d626f420d35240d645e45b367c7e279",
        "previous_commit_hash": "c1965e5062022121ce956d238e0134670314b556",
        "diff_stats": {
            "additions": 6,
            "deletions": 2
        },
        "diff_content": "@@ -43,8 +43,12 @@ public abstract class Modifiable {\n   }\n \n   public AnnotationWriter annotate(Class<? extends Annotation> annotation) {\n-    AnnotationWriter annotationWriter = new AnnotationWriter(ClassName.fromClass(annotation));\n-    this.annotations.add(annotationWriter);\n+    return annotate(ClassName.fromClass(annotation));\n+  }\n+\n+  public AnnotationWriter annotate(ClassName className) {\n+    AnnotationWriter annotationWriter = new AnnotationWriter(className);\n+    annotations.add(annotationWriter);\n     return annotationWriter;\n   }\n \n"
    },
    {
        "commit_hash": "e7e2057f54723eedc57baa8a9ce6f12acab72eb7",
        "previous_commit_hash": "7f0a33214323e0bfd266a51cdc98a2ce8de774ff",
        "diff_stats": {
            "additions": 2,
            "deletions": 3
        },
        "diff_content": "@@ -118,10 +118,9 @@ public final class ClassWriter extends TypeWriter {\n \n   @Override\n   public Set<ClassName> referencedClasses() {\n-    @SuppressWarnings(\"unchecked\")\n     Iterable<? extends HasClassReferences> concat =\n-        Iterables.concat(nestedTypeWriters, fieldWriters.values(), constructorWriters,\n-            methodWriters, implementedTypes, supertype.asSet(), typeVariables, annotations);\n+        Iterables.concat(super.referencedClasses(), constructorWriters, supertype.asSet(),\n+            typeVariables);\n     return FluentIterable.from(concat)\n         .transformAndConcat(GET_REFERENCED_CLASSES)\n         .toSet();\n"
    },
    {
        "commit_hash": "e7e2057f54723eedc57baa8a9ce6f12acab72eb7",
        "previous_commit_hash": "7f0a33214323e0bfd266a51cdc98a2ce8de774ff",
        "diff_stats": {
            "additions": 5,
            "deletions": 3
        },
        "diff_content": "@@ -28,7 +28,7 @@ import javax.lang.model.element.TypeElement;\n \n import static com.google.common.base.Preconditions.checkArgument;\n \n-public final class ConstructorWriter extends Modifiable implements Writable, HasClassReferences {\n+public final class ConstructorWriter extends Modifiable implements Writable {\n   private final List<TypeVariableName> typeVariables;\n   private final String name;\n   private final Map<String, VariableWriter> parameterWriters;\n@@ -76,8 +76,10 @@ public final class ConstructorWriter extends Modifiable implements Writable, Has\n \n   @Override\n   public Set<ClassName> referencedClasses() {\n-    return FluentIterable.from(\n-        Iterables.concat(typeVariables, parameterWriters.values(), ImmutableList.of(body)))\n+    Iterable<? extends HasClassReferences> concat =\n+        Iterables.concat(super.referencedClasses(), typeVariables, parameterWriters.values(),\n+            ImmutableList.of(body));\n+    return FluentIterable.from(concat)\n             .transformAndConcat(GET_REFERENCED_CLASSES)\n             .toSet();\n   }\n"
    },
    {
        "commit_hash": "e7e2057f54723eedc57baa8a9ce6f12acab72eb7",
        "previous_commit_hash": "7f0a33214323e0bfd266a51cdc98a2ce8de774ff",
        "diff_stats": {
            "additions": 1,
            "deletions": 3
        },
        "diff_content": "@@ -107,10 +107,8 @@ public final class EnumWriter extends TypeWriter {\n \n   @Override\n   public Set<ClassName> referencedClasses() {\n-    @SuppressWarnings(\"unchecked\")\n     Iterable<? extends HasClassReferences> concat =\n-        Iterables.concat(nestedTypeWriters, constantWriters.values(), fieldWriters.values(),\n-            constructorWriters, methodWriters, implementedTypes, annotations);\n+        Iterables.concat(super.referencedClasses(), constantWriters.values(), constructorWriters);\n     return FluentIterable.from(concat)\n         .transformAndConcat(GET_REFERENCED_CLASSES)\n         .toSet();\n"
    },
    {
        "commit_hash": "e7e2057f54723eedc57baa8a9ce6f12acab72eb7",
        "previous_commit_hash": "7f0a33214323e0bfd266a51cdc98a2ce8de774ff",
        "diff_stats": {
            "additions": 1,
            "deletions": 2
        },
        "diff_content": "@@ -17,7 +17,6 @@ package com.squareup.javawriter;\n \n import com.google.common.base.Optional;\n import com.google.common.collect.FluentIterable;\n-import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Iterables;\n import java.io.IOException;\n import java.util.Set;\n@@ -52,7 +51,7 @@ public final class FieldWriter extends VariableWriter {\n   @Override\n   public Set<ClassName> referencedClasses() {\n     Iterable<? extends HasClassReferences> concat =\n-        Iterables.concat(ImmutableList.of(type()), initializer.asSet(), annotations);\n+        Iterables.concat(super.referencedClasses(), initializer.asSet());\n     return FluentIterable.from(concat)\n         .transformAndConcat(GET_REFERENCED_CLASSES)\n         .toSet();\n"
    },
    {
        "commit_hash": "e7e2057f54723eedc57baa8a9ce6f12acab72eb7",
        "previous_commit_hash": "7f0a33214323e0bfd266a51cdc98a2ce8de774ff",
        "diff_stats": {
            "additions": 2,
            "deletions": 3
        },
        "diff_content": "@@ -31,6 +31,7 @@ public final class InterfaceWriter extends TypeWriter {\n   }\n \n   private final List<TypeVariableName> typeVariables;\n+\n   InterfaceWriter(ClassName name) {\n     super(name);\n     this.typeVariables = Lists.newArrayList();\n@@ -62,10 +63,8 @@ public final class InterfaceWriter extends TypeWriter {\n \n   @Override\n   public Set<ClassName> referencedClasses() {\n-    @SuppressWarnings(\"unchecked\")\n     Iterable<? extends HasClassReferences> concat =\n-        Iterables.concat(nestedTypeWriters, methodWriters, implementedTypes, typeVariables,\n-            annotations);\n+        Iterables.concat(super.referencedClasses(), typeVariables);\n     return FluentIterable.from(concat)\n         .transformAndConcat(GET_REFERENCED_CLASSES)\n         .toSet();\n"
    },
    {
        "commit_hash": "e7e2057f54723eedc57baa8a9ce6f12acab72eb7",
        "previous_commit_hash": "7f0a33214323e0bfd266a51cdc98a2ce8de774ff",
        "diff_stats": {
            "additions": 4,
            "deletions": 3
        },
        "diff_content": "@@ -29,7 +29,7 @@ import javax.lang.model.element.TypeElement;\n \n import static com.google.common.base.Preconditions.checkArgument;\n \n-public final class MethodWriter extends Modifiable implements HasClassReferences, Writable {\n+public final class MethodWriter extends Modifiable implements Writable {\n   private final List<TypeVariableName> typeVariables;\n   private final TypeName returnType;\n   private final String name;\n@@ -109,9 +109,10 @@ public final class MethodWriter extends Modifiable implements HasClassReferences\n \n   @Override\n   public Set<ClassName> referencedClasses() {\n+    @SuppressWarnings(\"unchecked\")\n     Iterable<? extends HasClassReferences> concat =\n-        Iterables.concat(typeVariables, ImmutableList.of(returnType, body),\n-            parameterWriters.values(), throwsTypes);\n+        Iterables.concat(super.referencedClasses(), typeVariables,\n+            ImmutableList.of(returnType, body), parameterWriters.values(), throwsTypes);\n     return FluentIterable.from(concat)\n         .transformAndConcat(GET_REFERENCED_CLASSES)\n         .toSet();\n"
    },
    {
        "commit_hash": "e7e2057f54723eedc57baa8a9ce6f12acab72eb7",
        "previous_commit_hash": "7f0a33214323e0bfd266a51cdc98a2ce8de774ff",
        "diff_stats": {
            "additions": 8,
            "deletions": 1
        },
        "diff_content": "@@ -15,6 +15,7 @@\n  */\n package com.squareup.javawriter;\n \n+import com.google.common.collect.FluentIterable;\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n import com.squareup.javawriter.Writable.Context;\n@@ -25,7 +26,7 @@ import java.util.List;\n import java.util.Set;\n import javax.lang.model.element.Modifier;\n \n-public abstract class Modifiable {\n+public abstract class Modifiable implements HasClassReferences {\n   final Set<Modifier> modifiers;\n   final List<AnnotationWriter> annotations;\n \n@@ -65,4 +66,10 @@ public abstract class Modifiable {\n     }\n     return appendable;\n   }\n+\n+  @Override public Set<ClassName> referencedClasses() {\n+    return FluentIterable.from(annotations)\n+        .transformAndConcat(GET_REFERENCED_CLASSES)\n+        .toSet();\n+  }\n }\n"
    },
    {
        "commit_hash": "e7e2057f54723eedc57baa8a9ce6f12acab72eb7",
        "previous_commit_hash": "7f0a33214323e0bfd266a51cdc98a2ce8de774ff",
        "diff_stats": {
            "additions": 12,
            "deletions": 1
        },
        "diff_content": "@@ -22,6 +22,7 @@ import com.google.common.collect.FluentIterable;\n import com.google.common.collect.HashBiMap;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.ImmutableSortedSet;\n+import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Ordering;\n@@ -39,7 +40,7 @@ import javax.lang.model.type.TypeMirror;\n  * Only named types. Doesn't cover anonymous inner classes.\n  */\n public abstract class TypeWriter /* ha ha */ extends Modifiable\n-    implements Writable, HasTypeName, HasClassReferences {\n+    implements Writable, HasTypeName {\n   final ClassName name;\n   final List<TypeName> implementedTypes;\n   final List<MethodWriter> methodWriters;\n@@ -149,6 +150,16 @@ public abstract class TypeWriter /* ha ha */ extends Modifiable\n     }\n   }\n \n+  @Override public Set<ClassName> referencedClasses() {\n+    @SuppressWarnings(\"unchecked\")\n+    Iterable<? extends HasClassReferences> concat =\n+        Iterables.concat(super.referencedClasses(), implementedTypes, methodWriters,\n+            nestedTypeWriters, fieldWriters.values(), explicitImports);\n+    return FluentIterable.from(concat)\n+        .transformAndConcat(GET_REFERENCED_CLASSES)\n+        .toSet();\n+  }\n+\n   Appendable writeTypeToAppendable(Appendable appendable) throws IOException {\n     String packageName = name().packageName();\n     appendable.append(\"package \").append(packageName).append(\";\\n\\n\");\n"
    },
    {
        "commit_hash": "e7e2057f54723eedc57baa8a9ce6f12acab72eb7",
        "previous_commit_hash": "7f0a33214323e0bfd266a51cdc98a2ce8de774ff",
        "diff_stats": {
            "additions": 9,
            "deletions": 2
        },
        "diff_content": "@@ -15,12 +15,15 @@\n  */\n package com.squareup.javawriter;\n \n+import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n import java.io.IOException;\n import java.util.Set;\n \n import static com.google.common.base.Preconditions.checkNotNull;\n \n-public class VariableWriter extends Modifiable implements Writable, HasClassReferences {\n+public class VariableWriter extends Modifiable implements Writable {\n   private final TypeName type;\n   private final String name;\n \n@@ -46,6 +49,10 @@ public class VariableWriter extends Modifiable implements Writable, HasClassRefe\n \n   @Override\n   public Set<ClassName> referencedClasses() {\n-    return type.referencedClasses();\n+    Iterable<? extends HasClassReferences> concat =\n+        Iterables.concat(super.referencedClasses(), ImmutableSet.of(type));\n+    return FluentIterable.from(concat)\n+        .transformAndConcat(GET_REFERENCED_CLASSES)\n+        .toSet();\n   }\n }\n"
    },
    {
        "commit_hash": "251130c1dd29e561d410918f4644b3730f1cdfda",
        "previous_commit_hash": "aa28d0e347cd08c7135d735eae2236e69bacafcd",
        "diff_stats": {
            "additions": 90,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright (C) 2014 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Set;\n+\n+public final class AnonymousClassWriter extends TypeWriter {\n+  public static AnonymousClassWriter forClassName(ClassName name) {\n+    return new AnonymousClassWriter(name);\n+  }\n+\n+  private Optional<Snippet> arguments;\n+  private final List<TypeName> typeVariables;\n+\n+  AnonymousClassWriter(ClassName className) {\n+    super(className);\n+    arguments = Optional.absent();\n+    typeVariables = Lists.newArrayList();\n+  }\n+\n+  public void setConstructorArguments(Snippet parameters) {\n+    arguments = Optional.of(parameters);\n+  }\n+\n+  public void setConstructorArguments(String parameters, Object... args) {\n+    setConstructorArguments(Snippet.format(parameters, args));\n+  }\n+\n+  public void addTypeVariable(TypeName typeName) {\n+    typeVariables.add(typeName);\n+  }\n+\n+  @Override\n+  public Appendable write(Appendable appendable, Context context) throws IOException {\n+    context = createSubcontext(context);\n+    appendable.append(\"new \").append(name.simpleName());\n+    Writables.Joiner.on(\", \")\n+        .wrap(\"<\", \">\")\n+        .appendTo(appendable, context, typeVariables)\n+        .append('(');\n+    if (arguments.isPresent()) {\n+      arguments.get().write(appendable, context);\n+    }\n+    appendable.append(\") {\");\n+    if (!fieldWriters.isEmpty()) {\n+      appendable.append('\\n');\n+    }\n+    for (VariableWriter fieldWriter : fieldWriters.values()) {\n+      fieldWriter.write(new IndentingAppendable(appendable), context).append(\"\\n\");\n+    }\n+    for (MethodWriter methodWriter : methodWriters) {\n+      appendable.append('\\n');\n+      methodWriter.write(new IndentingAppendable(appendable), context);\n+    }\n+    for (TypeWriter nestedTypeWriter : nestedTypeWriters) {\n+      appendable.append('\\n');\n+      nestedTypeWriter.write(new IndentingAppendable(appendable), context);\n+    }\n+    appendable.append('}');\n+    return appendable;\n+  }\n+\n+  @Override\n+  public Set<ClassName> referencedClasses() {\n+    Iterable<? extends HasClassReferences> concat =\n+        Iterables.concat(super.referencedClasses(), arguments.asSet(), typeVariables);\n+    return FluentIterable.from(concat)\n+        .transformAndConcat(GET_REFERENCED_CLASSES)\n+        .toSet();\n+  }\n+}\n"
    },
    {
        "commit_hash": "251130c1dd29e561d410918f4644b3730f1cdfda",
        "previous_commit_hash": "aa28d0e347cd08c7135d735eae2236e69bacafcd",
        "diff_stats": {
            "additions": 4,
            "deletions": 4
        },
        "diff_content": "@@ -40,7 +40,7 @@ public final class ClassWriter extends TypeWriter {\n \n   private Optional<TypeName> supertype;\n   private final List<ConstructorWriter> constructorWriters;\n-  private final List<TypeVariableName> typeVariables;\n+  private final List<TypeName> typeVariables;\n \n   ClassWriter(ClassName className) {\n     super(className);\n@@ -66,8 +66,8 @@ public final class ClassWriter extends TypeWriter {\n     return constructorWriter;\n   }\n \n-  public void addTypeVariable(TypeVariableName typeVariable) {\n-    this.typeVariables.add(typeVariable);\n+  public void addTypeVariable(TypeName typeName) {\n+    typeVariables.add(typeName);\n   }\n \n   @Override\n@@ -75,7 +75,7 @@ public final class ClassWriter extends TypeWriter {\n     context = createSubcontext(context);\n     writeAnnotations(appendable, context);\n     writeModifiers(appendable).append(\"class \").append(name.simpleName());\n-    Writables.Joiner.on(\", \").wrap(\"<\", \"> \").appendTo(appendable, context, typeVariables);\n+    Writables.Joiner.on(\", \").wrap(\"<\", \">\").appendTo(appendable, context, typeVariables);\n     if (supertype.isPresent()) {\n       appendable.append(\" extends \");\n       supertype.get().write(appendable, context);\n"
    },
    {
        "commit_hash": "251130c1dd29e561d410918f4644b3730f1cdfda",
        "previous_commit_hash": "aa28d0e347cd08c7135d735eae2236e69bacafcd",
        "diff_stats": {
            "additions": 5,
            "deletions": 1
        },
        "diff_content": "@@ -47,12 +47,16 @@ public final class JavaWriter {\n   }\n \n   public JavaWriter addTypeWriter(TypeWriter typeWriter) {\n+    checkArgument(!(typeWriter instanceof AnonymousClassWriter),\n+        \"AnonymousClassWriters cannot be added to a JavaWriter\");\n     typeWriters.add(typeWriter);\n     return this;\n   }\n \n   public JavaWriter addTypeWriters(Iterable<? extends TypeWriter> typeWriters) {\n-    Iterables.addAll(this.typeWriters, typeWriters);\n+    for (TypeWriter typeWriter : typeWriters) {\n+      addTypeWriter(typeWriter);\n+    }\n     return this;\n   }\n \n"
    },
    {
        "commit_hash": "251130c1dd29e561d410918f4644b3730f1cdfda",
        "previous_commit_hash": "aa28d0e347cd08c7135d735eae2236e69bacafcd",
        "diff_stats": {
            "additions": 3,
            "deletions": 0
        },
        "diff_content": "@@ -86,6 +86,9 @@ public final class Snippet implements HasClassReferences, Writable {\n       if (arg instanceof Snippet) {\n         types.addAll(((Snippet) arg).types);\n       }\n+      if (arg instanceof HasClassReferences) {\n+        types.addAll(((HasClassReferences) arg).referencedClasses());\n+      }\n       if (arg instanceof TypeName) {\n         types.add((TypeName) arg);\n       }\n"
    },
    {
        "commit_hash": "251130c1dd29e561d410918f4644b3730f1cdfda",
        "previous_commit_hash": "aa28d0e347cd08c7135d735eae2236e69bacafcd",
        "diff_stats": {
            "additions": 164,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,164 @@\n+/*\n+ * Copyright (C) 2014 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static javax.lang.model.element.Modifier.PUBLIC;\n+\n+@RunWith(JUnit4.class) public class AnonymousClassWriterTest {\n+  private final ClassName className = ClassName.create(\"com.foo\", \"Bar\");\n+  private final ClassName threadName = ClassName.fromClass(Thread.class);\n+\n+  @Test public void definedAsField() throws IOException {\n+    ClassWriter classWriter = ClassWriter.forClassName(className);\n+    FieldWriter threadField = classWriter.addField(threadName, \"thread\");\n+\n+    AnonymousClassWriter threadWriter = AnonymousClassWriter.forClassName(threadName);\n+    MethodWriter threadStartMethod = threadWriter.addMethod(void.class, \"start\");\n+    threadStartMethod.annotate(Override.class);\n+    threadStartMethod.addModifiers(PUBLIC);\n+    threadStartMethod.body().addSnippet(\"System.out.println(\\\"Hello World!\\\");\");\n+\n+    threadField.setInitializer(\"%s\", threadWriter);\n+\n+    assertThat(classWriter.toString()).isEqualTo(\"\"\n+        + \"package com.foo;\\n\"\n+        + \"\\n\"\n+        + \"class Bar {\\n\"\n+        + \"  Thread thread = new Thread() {\\n\"\n+        + \"    @Override\\n\"\n+        + \"    public void start() {\\n\"\n+        + \"      System.out.println(\\\"Hello World!\\\");\\n\"\n+        + \"    }\\n\"\n+        + \"  };\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void withConstructorParameters() throws IOException {\n+    ClassWriter classWriter = ClassWriter.forClassName(className);\n+    classWriter.addField(threadName, \"thread\");\n+    ConstructorWriter constructorWriter = classWriter.addConstructor();\n+    constructorWriter.addParameter(Runnable.class, \"runnable\");\n+\n+    AnonymousClassWriter threadWriter = AnonymousClassWriter.forClassName(threadName);\n+    threadWriter.setConstructorArguments(\"runnable\");\n+    MethodWriter threadStartMethod = threadWriter.addMethod(void.class, \"start\");\n+    threadStartMethod.annotate(Override.class);\n+    threadStartMethod.addModifiers(PUBLIC);\n+    threadStartMethod.body().addSnippet(\"System.out.println(\\\"Hello World!\\\");\");\n+\n+    constructorWriter.body().addSnippet(\"thread = %s;\", threadWriter);\n+\n+    assertThat(classWriter.toString()).isEqualTo(\"\"\n+        + \"package com.foo;\\n\"\n+        + \"\\n\"\n+        + \"class Bar {\\n\"\n+        + \"  Thread thread;\\n\"\n+        + \"\\n\"\n+        + \"  Bar(Runnable runnable) {\\n\"\n+        + \"    thread = new Thread(runnable) {\\n\"\n+        + \"      @Override\\n\"\n+        + \"      public void start() {\\n\"\n+        + \"        System.out.println(\\\"Hello World!\\\");\\n\"\n+        + \"      }\\n\"\n+        + \"    };\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void withImports() throws IOException {\n+    ClassWriter classWriter = ClassWriter.forClassName(className);\n+    classWriter.addField(threadName, \"thread\");\n+    ConstructorWriter constructorWriter = classWriter.addConstructor();\n+\n+    AnonymousClassWriter threadWriter = AnonymousClassWriter.forClassName(threadName);\n+    FieldWriter threadListField = threadWriter.addField(\n+        ParameterizedTypeName.create(List.class, ClassName.fromClass(String.class)), \"list\");\n+    threadListField.setInitializer(\"%s.asList(\\\"Hello World\\\")\", ClassName.fromClass(Arrays.class));\n+    MethodWriter threadStartMethod = threadWriter.addMethod(void.class, \"start\");\n+    threadStartMethod.annotate(Override.class);\n+    threadStartMethod.addModifiers(PUBLIC);\n+    threadStartMethod.body().addSnippet(\"System.out.println(list.get(0));\");\n+\n+    constructorWriter.body().addSnippet(\"thread = %s;\", threadWriter);\n+\n+    assertThat(classWriter.toString()).isEqualTo(\"\"\n+        + \"package com.foo;\\n\"\n+        + \"\\n\"\n+        + \"import java.util.Arrays;\\n\"\n+        + \"import java.util.List;\\n\"\n+        + \"\\n\"\n+        + \"class Bar {\\n\"\n+        + \"  Thread thread;\\n\"\n+        + \"\\n\"\n+        + \"  Bar() {\\n\"\n+        + \"    thread = new Thread() {\\n\"\n+        + \"      List<String> list = Arrays.asList(\\\"Hello World\\\");\\n\"\n+        + \"\\n\"\n+        + \"      @Override\\n\"\n+        + \"      public void start() {\\n\"\n+        + \"        System.out.println(list.get(0));\\n\"\n+        + \"      }\\n\"\n+        + \"    };\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void withType() throws IOException {\n+    ClassWriter classWriter = ClassWriter.forClassName(className);\n+    FieldWriter listField =\n+        classWriter.addField(ParameterizedTypeName.create(List.class, WildcardName.create()),\n+            \"list\");\n+\n+    AnonymousClassWriter listWriter =\n+        AnonymousClassWriter.forClassName(ClassName.fromClass(ArrayList.class));\n+    listWriter.addTypeVariable(\n+        ParameterizedTypeName.create(Map.class, ClassName.fromClass(String.class),\n+            ClassName.fromClass(Integer.class)));\n+\n+    MethodWriter listSizeMethod = listWriter.addMethod(int.class, \"size\");\n+    listSizeMethod.annotate(Override.class);\n+    listSizeMethod.addModifiers(PUBLIC);\n+    listSizeMethod.body().addSnippet(\"return 1;\");\n+\n+    listField.setInitializer(\"%s\", listWriter);\n+\n+    assertThat(classWriter.toString()).isEqualTo(\"\"\n+        + \"package com.foo;\\n\"\n+        + \"\\n\"\n+        + \"import java.util.ArrayList;\\n\"\n+        + \"import java.util.List;\\n\"\n+        + \"import java.util.Map;\\n\"\n+        + \"\\n\"\n+        + \"class Bar {\\n\"\n+        + \"  List<?> list = new ArrayList<Map<String, Integer>>() {\\n\"\n+        + \"    @Override\\n\"\n+        + \"    public int size() {\\n\"\n+        + \"      return 1;\\n\"\n+        + \"    }\\n\"\n+        + \"  };\\n\"\n+        + \"}\\n\");\n+  }\n+}\n"
    },
    {
        "commit_hash": "251130c1dd29e561d410918f4644b3730f1cdfda",
        "previous_commit_hash": "aa28d0e347cd08c7135d735eae2236e69bacafcd",
        "diff_stats": {
            "additions": 12,
            "deletions": 0
        },
        "diff_content": "@@ -30,6 +30,7 @@ import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n \n import static com.google.common.truth.Truth.assertThat;\n+import static org.junit.Assert.fail;\n \n @RunWith(JUnit4.class)\n public final class JavaWriterTest {\n@@ -144,5 +145,16 @@ public final class JavaWriterTest {\n     assertThat(bazFile.exists()).isTrue();\n   }\n \n+  @Test public void failsAddingAnonymousClass() {\n+    try {\n+      ClassName fooName = ClassName.create(\"foo\", \"Test\");\n+      AnonymousClassWriter anonymousClassWriter = AnonymousClassWriter.forClassName(fooName);\n+      javaWriter.addTypeWriter(anonymousClassWriter);\n+      fail();\n+    } catch (IllegalArgumentException e) {\n+      assertThat(e.getMessage()).isEqualTo(\"AnonymousClassWriters cannot be added to a JavaWriter\");\n+    }\n+  }\n+\n   // TODO Filer-based tests\n }\n"
    },
    {
        "commit_hash": "37ce8223a0a676aa0d2a24b2b9a80ffd5385110f",
        "previous_commit_hash": "7737c5009d78b82b9ff2d2b5c3b3fad676a097a9",
        "diff_stats": {
            "additions": 0,
            "deletions": 90
        },
        "diff_content": "@@ -1,90 +0,0 @@\n-/*\n- * Copyright (C) 2014 Square, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.squareup.javawriter;\n-\n-import com.google.common.base.Optional;\n-import com.google.common.collect.FluentIterable;\n-import com.google.common.collect.Iterables;\n-import com.google.common.collect.Lists;\n-import java.io.IOException;\n-import java.util.List;\n-import java.util.Set;\n-\n-public final class AnonymousClassWriter extends TypeWriter {\n-  public static AnonymousClassWriter forClassName(ClassName name) {\n-    return new AnonymousClassWriter(name);\n-  }\n-\n-  private Optional<Snippet> arguments;\n-  private final List<TypeName> typeVariables;\n-\n-  AnonymousClassWriter(ClassName className) {\n-    super(className);\n-    arguments = Optional.absent();\n-    typeVariables = Lists.newArrayList();\n-  }\n-\n-  public void setConstructorArguments(Snippet parameters) {\n-    arguments = Optional.of(parameters);\n-  }\n-\n-  public void setConstructorArguments(String parameters, Object... args) {\n-    setConstructorArguments(Snippet.format(parameters, args));\n-  }\n-\n-  public void addTypeVariable(TypeName typeName) {\n-    typeVariables.add(typeName);\n-  }\n-\n-  @Override\n-  public Appendable write(Appendable appendable, Context context) throws IOException {\n-    context = createSubcontext(context);\n-    appendable.append(\"new \").append(name.simpleName());\n-    Writables.Joiner.on(\", \")\n-        .wrap(\"<\", \">\")\n-        .appendTo(appendable, context, typeVariables)\n-        .append('(');\n-    if (arguments.isPresent()) {\n-      arguments.get().write(appendable, context);\n-    }\n-    appendable.append(\") {\");\n-    if (!fieldWriters.isEmpty()) {\n-      appendable.append('\\n');\n-    }\n-    for (VariableWriter fieldWriter : fieldWriters.values()) {\n-      fieldWriter.write(new IndentingAppendable(appendable), context).append(\"\\n\");\n-    }\n-    for (MethodWriter methodWriter : methodWriters) {\n-      appendable.append('\\n');\n-      methodWriter.write(new IndentingAppendable(appendable), context);\n-    }\n-    for (TypeWriter nestedTypeWriter : nestedTypeWriters) {\n-      appendable.append('\\n');\n-      nestedTypeWriter.write(new IndentingAppendable(appendable), context);\n-    }\n-    appendable.append('}');\n-    return appendable;\n-  }\n-\n-  @Override\n-  public Set<ClassName> referencedClasses() {\n-    Iterable<? extends HasClassReferences> concat =\n-        Iterables.concat(super.referencedClasses(), arguments.asSet(), typeVariables);\n-    return FluentIterable.from(concat)\n-        .transformAndConcat(GET_REFERENCED_CLASSES)\n-        .toSet();\n-  }\n-}\n"
    },
    {
        "commit_hash": "37ce8223a0a676aa0d2a24b2b9a80ffd5385110f",
        "previous_commit_hash": "7737c5009d78b82b9ff2d2b5c3b3fad676a097a9",
        "diff_stats": {
            "additions": 4,
            "deletions": 4
        },
        "diff_content": "@@ -40,7 +40,7 @@ public final class ClassWriter extends TypeWriter {\n \n   private Optional<TypeName> supertype;\n   private final List<ConstructorWriter> constructorWriters;\n-  private final List<TypeName> typeVariables;\n+  private final List<TypeVariableName> typeVariables;\n \n   ClassWriter(ClassName className) {\n     super(className);\n@@ -66,8 +66,8 @@ public final class ClassWriter extends TypeWriter {\n     return constructorWriter;\n   }\n \n-  public void addTypeVariable(TypeName typeName) {\n-    typeVariables.add(typeName);\n+  public void addTypeVariable(TypeVariableName typeVariable) {\n+    this.typeVariables.add(typeVariable);\n   }\n \n   @Override\n@@ -75,7 +75,7 @@ public final class ClassWriter extends TypeWriter {\n     context = createSubcontext(context);\n     writeAnnotations(appendable, context);\n     writeModifiers(appendable).append(\"class \").append(name.simpleName());\n-    Writables.Joiner.on(\", \").wrap(\"<\", \">\").appendTo(appendable, context, typeVariables);\n+    Writables.Joiner.on(\", \").wrap(\"<\", \"> \").appendTo(appendable, context, typeVariables);\n     if (supertype.isPresent()) {\n       appendable.append(\" extends \");\n       supertype.get().write(appendable, context);\n"
    },
    {
        "commit_hash": "37ce8223a0a676aa0d2a24b2b9a80ffd5385110f",
        "previous_commit_hash": "7737c5009d78b82b9ff2d2b5c3b3fad676a097a9",
        "diff_stats": {
            "additions": 1,
            "deletions": 5
        },
        "diff_content": "@@ -47,16 +47,12 @@ public final class JavaWriter {\n   }\n \n   public JavaWriter addTypeWriter(TypeWriter typeWriter) {\n-    checkArgument(!(typeWriter instanceof AnonymousClassWriter),\n-        \"AnonymousClassWriters cannot be added to a JavaWriter\");\n     typeWriters.add(typeWriter);\n     return this;\n   }\n \n   public JavaWriter addTypeWriters(Iterable<? extends TypeWriter> typeWriters) {\n-    for (TypeWriter typeWriter : typeWriters) {\n-      addTypeWriter(typeWriter);\n-    }\n+    Iterables.addAll(this.typeWriters, typeWriters);\n     return this;\n   }\n \n"
    },
    {
        "commit_hash": "37ce8223a0a676aa0d2a24b2b9a80ffd5385110f",
        "previous_commit_hash": "7737c5009d78b82b9ff2d2b5c3b3fad676a097a9",
        "diff_stats": {
            "additions": 0,
            "deletions": 3
        },
        "diff_content": "@@ -86,9 +86,6 @@ public final class Snippet implements HasClassReferences, Writable {\n       if (arg instanceof Snippet) {\n         types.addAll(((Snippet) arg).types);\n       }\n-      if (arg instanceof HasClassReferences) {\n-        types.addAll(((HasClassReferences) arg).referencedClasses());\n-      }\n       if (arg instanceof TypeName) {\n         types.add((TypeName) arg);\n       }\n"
    },
    {
        "commit_hash": "37ce8223a0a676aa0d2a24b2b9a80ffd5385110f",
        "previous_commit_hash": "7737c5009d78b82b9ff2d2b5c3b3fad676a097a9",
        "diff_stats": {
            "additions": 0,
            "deletions": 164
        },
        "diff_content": "@@ -1,164 +0,0 @@\n-/*\n- * Copyright (C) 2014 Square, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.squareup.javawriter;\n-\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Map;\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.junit.runners.JUnit4;\n-\n-import static com.google.common.truth.Truth.assertThat;\n-import static javax.lang.model.element.Modifier.PUBLIC;\n-\n-@RunWith(JUnit4.class) public class AnonymousClassWriterTest {\n-  private final ClassName className = ClassName.create(\"com.foo\", \"Bar\");\n-  private final ClassName threadName = ClassName.fromClass(Thread.class);\n-\n-  @Test public void definedAsField() throws IOException {\n-    ClassWriter classWriter = ClassWriter.forClassName(className);\n-    FieldWriter threadField = classWriter.addField(threadName, \"thread\");\n-\n-    AnonymousClassWriter threadWriter = AnonymousClassWriter.forClassName(threadName);\n-    MethodWriter threadStartMethod = threadWriter.addMethod(void.class, \"start\");\n-    threadStartMethod.annotate(Override.class);\n-    threadStartMethod.addModifiers(PUBLIC);\n-    threadStartMethod.body().addSnippet(\"System.out.println(\\\"Hello World!\\\");\");\n-\n-    threadField.setInitializer(\"%s\", threadWriter);\n-\n-    assertThat(classWriter.toString()).isEqualTo(\"\"\n-        + \"package com.foo;\\n\"\n-        + \"\\n\"\n-        + \"class Bar {\\n\"\n-        + \"  Thread thread = new Thread() {\\n\"\n-        + \"    @Override\\n\"\n-        + \"    public void start() {\\n\"\n-        + \"      System.out.println(\\\"Hello World!\\\");\\n\"\n-        + \"    }\\n\"\n-        + \"  };\\n\"\n-        + \"}\\n\");\n-  }\n-\n-  @Test public void withConstructorParameters() throws IOException {\n-    ClassWriter classWriter = ClassWriter.forClassName(className);\n-    classWriter.addField(threadName, \"thread\");\n-    ConstructorWriter constructorWriter = classWriter.addConstructor();\n-    constructorWriter.addParameter(Runnable.class, \"runnable\");\n-\n-    AnonymousClassWriter threadWriter = AnonymousClassWriter.forClassName(threadName);\n-    threadWriter.setConstructorArguments(\"runnable\");\n-    MethodWriter threadStartMethod = threadWriter.addMethod(void.class, \"start\");\n-    threadStartMethod.annotate(Override.class);\n-    threadStartMethod.addModifiers(PUBLIC);\n-    threadStartMethod.body().addSnippet(\"System.out.println(\\\"Hello World!\\\");\");\n-\n-    constructorWriter.body().addSnippet(\"thread = %s;\", threadWriter);\n-\n-    assertThat(classWriter.toString()).isEqualTo(\"\"\n-        + \"package com.foo;\\n\"\n-        + \"\\n\"\n-        + \"class Bar {\\n\"\n-        + \"  Thread thread;\\n\"\n-        + \"\\n\"\n-        + \"  Bar(Runnable runnable) {\\n\"\n-        + \"    thread = new Thread(runnable) {\\n\"\n-        + \"      @Override\\n\"\n-        + \"      public void start() {\\n\"\n-        + \"        System.out.println(\\\"Hello World!\\\");\\n\"\n-        + \"      }\\n\"\n-        + \"    };\\n\"\n-        + \"  }\\n\"\n-        + \"}\\n\");\n-  }\n-\n-  @Test public void withImports() throws IOException {\n-    ClassWriter classWriter = ClassWriter.forClassName(className);\n-    classWriter.addField(threadName, \"thread\");\n-    ConstructorWriter constructorWriter = classWriter.addConstructor();\n-\n-    AnonymousClassWriter threadWriter = AnonymousClassWriter.forClassName(threadName);\n-    FieldWriter threadListField = threadWriter.addField(\n-        ParameterizedTypeName.create(List.class, ClassName.fromClass(String.class)), \"list\");\n-    threadListField.setInitializer(\"%s.asList(\\\"Hello World\\\")\", ClassName.fromClass(Arrays.class));\n-    MethodWriter threadStartMethod = threadWriter.addMethod(void.class, \"start\");\n-    threadStartMethod.annotate(Override.class);\n-    threadStartMethod.addModifiers(PUBLIC);\n-    threadStartMethod.body().addSnippet(\"System.out.println(list.get(0));\");\n-\n-    constructorWriter.body().addSnippet(\"thread = %s;\", threadWriter);\n-\n-    assertThat(classWriter.toString()).isEqualTo(\"\"\n-        + \"package com.foo;\\n\"\n-        + \"\\n\"\n-        + \"import java.util.Arrays;\\n\"\n-        + \"import java.util.List;\\n\"\n-        + \"\\n\"\n-        + \"class Bar {\\n\"\n-        + \"  Thread thread;\\n\"\n-        + \"\\n\"\n-        + \"  Bar() {\\n\"\n-        + \"    thread = new Thread() {\\n\"\n-        + \"      List<String> list = Arrays.asList(\\\"Hello World\\\");\\n\"\n-        + \"\\n\"\n-        + \"      @Override\\n\"\n-        + \"      public void start() {\\n\"\n-        + \"        System.out.println(list.get(0));\\n\"\n-        + \"      }\\n\"\n-        + \"    };\\n\"\n-        + \"  }\\n\"\n-        + \"}\\n\");\n-  }\n-\n-  @Test public void withType() throws IOException {\n-    ClassWriter classWriter = ClassWriter.forClassName(className);\n-    FieldWriter listField =\n-        classWriter.addField(ParameterizedTypeName.create(List.class, WildcardName.create()),\n-            \"list\");\n-\n-    AnonymousClassWriter listWriter =\n-        AnonymousClassWriter.forClassName(ClassName.fromClass(ArrayList.class));\n-    listWriter.addTypeVariable(\n-        ParameterizedTypeName.create(Map.class, ClassName.fromClass(String.class),\n-            ClassName.fromClass(Integer.class)));\n-\n-    MethodWriter listSizeMethod = listWriter.addMethod(int.class, \"size\");\n-    listSizeMethod.annotate(Override.class);\n-    listSizeMethod.addModifiers(PUBLIC);\n-    listSizeMethod.body().addSnippet(\"return 1;\");\n-\n-    listField.setInitializer(\"%s\", listWriter);\n-\n-    assertThat(classWriter.toString()).isEqualTo(\"\"\n-        + \"package com.foo;\\n\"\n-        + \"\\n\"\n-        + \"import java.util.ArrayList;\\n\"\n-        + \"import java.util.List;\\n\"\n-        + \"import java.util.Map;\\n\"\n-        + \"\\n\"\n-        + \"class Bar {\\n\"\n-        + \"  List<?> list = new ArrayList<Map<String, Integer>>() {\\n\"\n-        + \"    @Override\\n\"\n-        + \"    public int size() {\\n\"\n-        + \"      return 1;\\n\"\n-        + \"    }\\n\"\n-        + \"  };\\n\"\n-        + \"}\\n\");\n-  }\n-}\n"
    },
    {
        "commit_hash": "37ce8223a0a676aa0d2a24b2b9a80ffd5385110f",
        "previous_commit_hash": "7737c5009d78b82b9ff2d2b5c3b3fad676a097a9",
        "diff_stats": {
            "additions": 0,
            "deletions": 12
        },
        "diff_content": "@@ -30,7 +30,6 @@ import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n \n import static com.google.common.truth.Truth.assertThat;\n-import static org.junit.Assert.fail;\n \n @RunWith(JUnit4.class)\n public final class JavaWriterTest {\n@@ -145,16 +144,5 @@ public final class JavaWriterTest {\n     assertThat(bazFile.exists()).isTrue();\n   }\n \n-  @Test public void failsAddingAnonymousClass() {\n-    try {\n-      ClassName fooName = ClassName.create(\"foo\", \"Test\");\n-      AnonymousClassWriter anonymousClassWriter = AnonymousClassWriter.forClassName(fooName);\n-      javaWriter.addTypeWriter(anonymousClassWriter);\n-      fail();\n-    } catch (IllegalArgumentException e) {\n-      assertThat(e.getMessage()).isEqualTo(\"AnonymousClassWriters cannot be added to a JavaWriter\");\n-    }\n-  }\n-\n   // TODO Filer-based tests\n }\n"
    },
    {
        "commit_hash": "548dab4cb7c15c686b0a4063b3e51a7457fec8a3",
        "previous_commit_hash": "37ce8223a0a676aa0d2a24b2b9a80ffd5385110f",
        "diff_stats": {
            "additions": 140,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright (C) 2014 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeMirror;\n+\n+public final class AnonymousClassWriter implements Writable, HasClassReferences {\n+  public static AnonymousClassWriter forClassName(ClassName name) {\n+    return new AnonymousClassWriter(name);\n+  }\n+\n+  public static AnonymousClassWriter forParameterizedTypeName(ParameterizedTypeName name) {\n+    return new AnonymousClassWriter(name);\n+  }\n+\n+  private final TypeName supertypeOrImplementedInterface;\n+  private Optional<Snippet> constructorArguments;\n+  private final List<MethodWriter> methodWriters;\n+  private final Map<String, FieldWriter> fieldWriters;\n+  // TODO support nested types (currently, nested types must be fully-qualifiedly named)\n+\n+  AnonymousClassWriter(TypeName supertypeOrImplementedInterface) {\n+    this.supertypeOrImplementedInterface = supertypeOrImplementedInterface;\n+    this.constructorArguments = Optional.absent();\n+    this.methodWriters = Lists.newArrayList();\n+    this.fieldWriters = Maps.newLinkedHashMap();\n+  }\n+\n+  public void setConstructorArguments(Snippet parameters) {\n+    constructorArguments = Optional.of(parameters);\n+  }\n+\n+  public void setConstructorArguments(String parameters, Object... args) {\n+    setConstructorArguments(Snippet.format(parameters, args));\n+  }\n+\n+  public MethodWriter addMethod(TypeWriter returnType, String name) {\n+    MethodWriter methodWriter = new MethodWriter(returnType.name, name);\n+    methodWriters.add(methodWriter);\n+    return methodWriter;\n+  }\n+\n+  public MethodWriter addMethod(TypeMirror returnType, String name) {\n+    MethodWriter methodWriter =\n+        new MethodWriter(TypeNames.forTypeMirror(returnType), name);\n+    methodWriters.add(methodWriter);\n+    return methodWriter;\n+  }\n+\n+  public MethodWriter addMethod(TypeName returnType, String name) {\n+    MethodWriter methodWriter = new MethodWriter(returnType, name);\n+    methodWriters.add(methodWriter);\n+    return methodWriter;\n+  }\n+\n+  public MethodWriter addMethod(Class<?> returnType, String name) {\n+    MethodWriter methodWriter =\n+        new MethodWriter(TypeNames.forClass(returnType), name);\n+    methodWriters.add(methodWriter);\n+    return methodWriter;\n+  }\n+\n+  public FieldWriter addField(Class<?> type, String name) {\n+    return addField(TypeNames.forClass(type), name);\n+  }\n+\n+  public FieldWriter addField(TypeElement type, String name) {\n+    return addField(ClassName.fromTypeElement(type), name);\n+  }\n+\n+  public FieldWriter addField(TypeName type, String name) {\n+    String candidateName = name;\n+    int differentiator = 1;\n+    while (fieldWriters.containsKey(candidateName)) {\n+      candidateName = name + differentiator;\n+      differentiator++;\n+    }\n+    FieldWriter fieldWriter = new FieldWriter(type, candidateName);\n+    fieldWriters.put(candidateName, fieldWriter);\n+    return fieldWriter;\n+  }\n+\n+  @Override\n+  public Set<ClassName> referencedClasses() {\n+    @SuppressWarnings(\"unchecked\")\n+    Iterable<? extends HasClassReferences> concat =\n+        Iterables.concat(ImmutableList.of(supertypeOrImplementedInterface), methodWriters,\n+            fieldWriters.values());\n+    return FluentIterable.from(concat)\n+        .transformAndConcat(GET_REFERENCED_CLASSES)\n+        .toSet();\n+  }\n+\n+  @Override\n+  public Appendable write(Appendable appendable, Context context) throws IOException {\n+    appendable.append(\"new \");\n+    supertypeOrImplementedInterface.write(appendable, context);\n+    appendable.append('(');\n+    if (constructorArguments.isPresent()) {\n+      constructorArguments.get().write(appendable, context);\n+    }\n+    appendable.append(\") {\");\n+    if (!fieldWriters.isEmpty()) {\n+      appendable.append('\\n');\n+    }\n+    for (VariableWriter fieldWriter : fieldWriters.values()) {\n+      fieldWriter.write(new IndentingAppendable(appendable), context).append('\\n');\n+    }\n+    for (MethodWriter methodWriter : methodWriters) {\n+      appendable.append('\\n');\n+      methodWriter.write(new IndentingAppendable(appendable), context);\n+    }\n+    appendable.append('}');\n+    return appendable;\n+  }\n+}\n"
    },
    {
        "commit_hash": "548dab4cb7c15c686b0a4063b3e51a7457fec8a3",
        "previous_commit_hash": "37ce8223a0a676aa0d2a24b2b9a80ffd5385110f",
        "diff_stats": {
            "additions": 3,
            "deletions": 6
        },
        "diff_content": "@@ -83,14 +83,11 @@ public final class Snippet implements HasClassReferences, Writable {\n   public static Snippet format(String format, Object... args) {\n     ImmutableSet.Builder<TypeName> types = ImmutableSet.builder();\n     for (Object arg : args) {\n-      if (arg instanceof Snippet) {\n-        types.addAll(((Snippet) arg).types);\n-      }\n-      if (arg instanceof TypeName) {\n-        types.add((TypeName) arg);\n+      if (arg instanceof HasClassReferences) {\n+        types.addAll(((HasClassReferences) arg).referencedClasses());\n       }\n       if (arg instanceof HasTypeName) {\n-        types.add(((HasTypeName) arg).name());\n+        types.addAll(((HasTypeName) arg).name().referencedClasses());\n       }\n     }\n     return new Snippet(format, types.build(), ImmutableList.copyOf(args));\n"
    },
    {
        "commit_hash": "548dab4cb7c15c686b0a4063b3e51a7457fec8a3",
        "previous_commit_hash": "37ce8223a0a676aa0d2a24b2b9a80ffd5385110f",
        "diff_stats": {
            "additions": 163,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright (C) 2014 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static javax.lang.model.element.Modifier.PUBLIC;\n+\n+@RunWith(JUnit4.class) public class AnonymousClassWriterTest {\n+  private final ClassName className = ClassName.create(\"com.foo\", \"Bar\");\n+  private final ClassName threadName = ClassName.fromClass(Thread.class);\n+\n+  @Test public void definedAsField() throws IOException {\n+    ClassWriter classWriter = ClassWriter.forClassName(className);\n+    FieldWriter threadField = classWriter.addField(threadName, \"thread\");\n+\n+    AnonymousClassWriter threadWriter = AnonymousClassWriter.forClassName(threadName);\n+    MethodWriter threadStartMethod = threadWriter.addMethod(void.class, \"start\");\n+    threadStartMethod.annotate(Override.class);\n+    threadStartMethod.addModifiers(PUBLIC);\n+    threadStartMethod.body().addSnippet(\"System.out.println(\\\"Hello World!\\\");\");\n+\n+    threadField.setInitializer(\"%s\", threadWriter);\n+\n+    assertThat(classWriter.toString()).isEqualTo(\"\"\n+        + \"package com.foo;\\n\"\n+        + \"\\n\"\n+        + \"class Bar {\\n\"\n+        + \"  Thread thread = new Thread() {\\n\"\n+        + \"    @Override\\n\"\n+        + \"    public void start() {\\n\"\n+        + \"      System.out.println(\\\"Hello World!\\\");\\n\"\n+        + \"    }\\n\"\n+        + \"  };\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void withConstructorParameters() throws IOException {\n+    ClassWriter classWriter = ClassWriter.forClassName(className);\n+    classWriter.addField(threadName, \"thread\");\n+    ConstructorWriter constructorWriter = classWriter.addConstructor();\n+    constructorWriter.addParameter(Runnable.class, \"runnable\");\n+\n+    AnonymousClassWriter threadWriter = AnonymousClassWriter.forClassName(threadName);\n+    threadWriter.setConstructorArguments(\"runnable\");\n+    MethodWriter threadStartMethod = threadWriter.addMethod(void.class, \"start\");\n+    threadStartMethod.annotate(Override.class);\n+    threadStartMethod.addModifiers(PUBLIC);\n+    threadStartMethod.body().addSnippet(\"System.out.println(\\\"Hello World!\\\");\");\n+\n+    constructorWriter.body().addSnippet(\"thread = %s;\", threadWriter);\n+\n+    assertThat(classWriter.toString()).isEqualTo(\"\"\n+        + \"package com.foo;\\n\"\n+        + \"\\n\"\n+        + \"class Bar {\\n\"\n+        + \"  Thread thread;\\n\"\n+        + \"\\n\"\n+        + \"  Bar(Runnable runnable) {\\n\"\n+        + \"    thread = new Thread(runnable) {\\n\"\n+        + \"      @Override\\n\"\n+        + \"      public void start() {\\n\"\n+        + \"        System.out.println(\\\"Hello World!\\\");\\n\"\n+        + \"      }\\n\"\n+        + \"    };\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void withImports() throws IOException {\n+    ClassWriter classWriter = ClassWriter.forClassName(className);\n+    classWriter.addField(threadName, \"thread\");\n+    ConstructorWriter constructorWriter = classWriter.addConstructor();\n+\n+    AnonymousClassWriter threadWriter = AnonymousClassWriter.forClassName(threadName);\n+    FieldWriter threadListField = threadWriter.addField(\n+        ParameterizedTypeName.create(List.class, ClassName.fromClass(String.class)), \"list\");\n+    threadListField.setInitializer(\"%s.asList(\\\"Hello World\\\")\", ClassName.fromClass(Arrays.class));\n+    MethodWriter threadStartMethod = threadWriter.addMethod(void.class, \"start\");\n+    threadStartMethod.annotate(Override.class);\n+    threadStartMethod.addModifiers(PUBLIC);\n+    threadStartMethod.body().addSnippet(\"System.out.println(list.get(0));\");\n+\n+    constructorWriter.body().addSnippet(\"thread = %s;\", threadWriter);\n+\n+    assertThat(classWriter.toString()).isEqualTo(\"\"\n+        + \"package com.foo;\\n\"\n+        + \"\\n\"\n+        + \"import java.util.Arrays;\\n\"\n+        + \"import java.util.List;\\n\"\n+        + \"\\n\"\n+        + \"class Bar {\\n\"\n+        + \"  Thread thread;\\n\"\n+        + \"\\n\"\n+        + \"  Bar() {\\n\"\n+        + \"    thread = new Thread() {\\n\"\n+        + \"      List<String> list = Arrays.asList(\\\"Hello World\\\");\\n\"\n+        + \"\\n\"\n+        + \"      @Override\\n\"\n+        + \"      public void start() {\\n\"\n+        + \"        System.out.println(list.get(0));\\n\"\n+        + \"      }\\n\"\n+        + \"    };\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void withType() throws IOException {\n+    ClassWriter classWriter = ClassWriter.forClassName(className);\n+    FieldWriter listField =\n+        classWriter.addField(ParameterizedTypeName.create(List.class, WildcardName.create()),\n+            \"list\");\n+\n+    AnonymousClassWriter listWriter = AnonymousClassWriter.forParameterizedTypeName(\n+        ParameterizedTypeName.create(ArrayList.class,\n+            ParameterizedTypeName.create(Map.class, ClassName.fromClass(String.class),\n+                ClassName.fromClass(Integer.class))));\n+\n+    MethodWriter listSizeMethod = listWriter.addMethod(int.class, \"size\");\n+    listSizeMethod.annotate(Override.class);\n+    listSizeMethod.addModifiers(PUBLIC);\n+    listSizeMethod.body().addSnippet(\"return 1;\");\n+\n+    listField.setInitializer(\"%s\", listWriter);\n+\n+    assertThat(classWriter.toString()).isEqualTo(\"\"\n+        + \"package com.foo;\\n\"\n+        + \"\\n\"\n+        + \"import java.util.ArrayList;\\n\"\n+        + \"import java.util.List;\\n\"\n+        + \"import java.util.Map;\\n\"\n+        + \"\\n\"\n+        + \"class Bar {\\n\"\n+        + \"  List<?> list = new ArrayList<Map<String, Integer>>() {\\n\"\n+        + \"    @Override\\n\"\n+        + \"    public int size() {\\n\"\n+        + \"      return 1;\\n\"\n+        + \"    }\\n\"\n+        + \"  };\\n\"\n+        + \"}\\n\");\n+  }\n+}\n"
    },
    {
        "commit_hash": "6a3595c848017a41b854b301d3a25c4d6fb8a7f4",
        "previous_commit_hash": "61d1bac10c8664ef3b4218cea8b6c3bc226ca0a6",
        "diff_stats": {
            "additions": 12,
            "deletions": 49
        },
        "diff_content": "@@ -18,12 +18,7 @@ package com.squareup.javawriter;\n import com.google.common.base.Optional;\n import com.google.common.collect.FluentIterable;\n import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.Iterables;\n-import com.google.common.collect.Lists;\n-import com.google.common.collect.Maps;\n import java.io.IOException;\n-import java.util.List;\n-import java.util.Map;\n import java.util.Set;\n import javax.lang.model.element.TypeElement;\n import javax.lang.model.type.TypeMirror;\n@@ -39,15 +34,13 @@ public final class AnonymousClassWriter implements Writable, HasClassReferences\n \n   private final TypeName supertypeOrImplementedInterface;\n   private Optional<Snippet> constructorArguments;\n-  private final List<MethodWriter> methodWriters;\n-  private final Map<String, FieldWriter> fieldWriters;\n+  private final ClassBodyWriter body;\n   // TODO support nested types (currently, nested types must be fully-qualifiedly named)\n \n   AnonymousClassWriter(TypeName supertypeOrImplementedInterface) {\n     this.supertypeOrImplementedInterface = supertypeOrImplementedInterface;\n     this.constructorArguments = Optional.absent();\n-    this.methodWriters = Lists.newArrayList();\n-    this.fieldWriters = Maps.newLinkedHashMap();\n+    this.body = new ClassBodyWriter();\n   }\n \n   public void setConstructorArguments(Snippet parameters) {\n@@ -59,58 +52,36 @@ public final class AnonymousClassWriter implements Writable, HasClassReferences\n   }\n \n   public MethodWriter addMethod(TypeWriter returnType, String name) {\n-    MethodWriter methodWriter = new MethodWriter(returnType.name, name);\n-    methodWriters.add(methodWriter);\n-    return methodWriter;\n+    return body.addMethod(returnType, name);\n   }\n \n   public MethodWriter addMethod(TypeMirror returnType, String name) {\n-    MethodWriter methodWriter =\n-        new MethodWriter(TypeNames.forTypeMirror(returnType), name);\n-    methodWriters.add(methodWriter);\n-    return methodWriter;\n+    return body.addMethod(returnType, name);\n   }\n \n   public MethodWriter addMethod(TypeName returnType, String name) {\n-    MethodWriter methodWriter = new MethodWriter(returnType, name);\n-    methodWriters.add(methodWriter);\n-    return methodWriter;\n+    return body.addMethod(returnType, name);\n   }\n \n   public MethodWriter addMethod(Class<?> returnType, String name) {\n-    MethodWriter methodWriter =\n-        new MethodWriter(TypeNames.forClass(returnType), name);\n-    methodWriters.add(methodWriter);\n-    return methodWriter;\n+    return body.addMethod(returnType, name);\n   }\n \n   public FieldWriter addField(Class<?> type, String name) {\n-    return addField(TypeNames.forClass(type), name);\n+    return body.addField(type, name);\n   }\n \n   public FieldWriter addField(TypeElement type, String name) {\n-    return addField(ClassName.fromTypeElement(type), name);\n+    return body.addField(type, name);\n   }\n \n   public FieldWriter addField(TypeName type, String name) {\n-    String candidateName = name;\n-    int differentiator = 1;\n-    while (fieldWriters.containsKey(candidateName)) {\n-      candidateName = name + differentiator;\n-      differentiator++;\n-    }\n-    FieldWriter fieldWriter = new FieldWriter(type, candidateName);\n-    fieldWriters.put(candidateName, fieldWriter);\n-    return fieldWriter;\n+    return body.addField(type, name);\n   }\n \n   @Override\n   public Set<ClassName> referencedClasses() {\n-    @SuppressWarnings(\"unchecked\")\n-    Iterable<? extends HasClassReferences> concat =\n-        Iterables.concat(ImmutableList.of(supertypeOrImplementedInterface), methodWriters,\n-            fieldWriters.values());\n-    return FluentIterable.from(concat)\n+    return FluentIterable.from(ImmutableList.of(supertypeOrImplementedInterface, body))\n         .transformAndConcat(GET_REFERENCED_CLASSES)\n         .toSet();\n   }\n@@ -124,16 +95,8 @@ public final class AnonymousClassWriter implements Writable, HasClassReferences\n       constructorArguments.get().write(appendable, context);\n     }\n     appendable.append(\") {\");\n-    if (!fieldWriters.isEmpty()) {\n-      appendable.append('\\n');\n-    }\n-    for (VariableWriter fieldWriter : fieldWriters.values()) {\n-      fieldWriter.write(new IndentingAppendable(appendable), context).append('\\n');\n-    }\n-    for (MethodWriter methodWriter : methodWriters) {\n-      appendable.append('\\n');\n-      methodWriter.write(new IndentingAppendable(appendable), context);\n-    }\n+    body.writeFields(appendable, context);\n+    body.writeMethods(appendable, context);\n     appendable.append('}');\n     return appendable;\n   }\n"
    },
    {
        "commit_hash": "6a3595c848017a41b854b301d3a25c4d6fb8a7f4",
        "previous_commit_hash": "61d1bac10c8664ef3b4218cea8b6c3bc226ca0a6",
        "diff_stats": {
            "additions": 112,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright (C) 2014 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter;\n+\n+import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import com.squareup.javawriter.Writable.Context;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeMirror;\n+\n+public class ClassBodyWriter implements HasClassReferences {\n+  private final Map<String, FieldWriter> fieldWriters;\n+  private final List<MethodWriter> methodWriters;\n+\n+  ClassBodyWriter() {\n+    this.fieldWriters = Maps.newLinkedHashMap();\n+    this.methodWriters = Lists.newArrayList();\n+  }\n+\n+  public MethodWriter addMethod(TypeWriter returnType, String name) {\n+    MethodWriter methodWriter = new MethodWriter(returnType.name, name);\n+    methodWriters.add(methodWriter);\n+    return methodWriter;\n+  }\n+\n+  public MethodWriter addMethod(TypeMirror returnType, String name) {\n+    MethodWriter methodWriter =\n+        new MethodWriter(TypeNames.forTypeMirror(returnType), name);\n+    methodWriters.add(methodWriter);\n+    return methodWriter;\n+  }\n+\n+  public MethodWriter addMethod(TypeName returnType, String name) {\n+    MethodWriter methodWriter = new MethodWriter(returnType, name);\n+    methodWriters.add(methodWriter);\n+    return methodWriter;\n+  }\n+\n+  public MethodWriter addMethod(Class<?> returnType, String name) {\n+    MethodWriter methodWriter =\n+        new MethodWriter(TypeNames.forClass(returnType), name);\n+    methodWriters.add(methodWriter);\n+    return methodWriter;\n+  }\n+\n+  public FieldWriter addField(Class<?> type, String name) {\n+    return addField(TypeNames.forClass(type), name);\n+  }\n+\n+  public FieldWriter addField(TypeElement type, String name) {\n+    return addField(ClassName.fromTypeElement(type), name);\n+  }\n+\n+  public FieldWriter addField(TypeName type, String name) {\n+    String candidateName = name;\n+    int differentiator = 1;\n+    while (fieldWriters.containsKey(candidateName)) {\n+      candidateName = name + differentiator;\n+      differentiator++;\n+    }\n+    FieldWriter fieldWriter = new FieldWriter(type, candidateName);\n+    fieldWriters.put(candidateName, fieldWriter);\n+    return fieldWriter;\n+  }\n+\n+  @Override\n+  public Set<ClassName> referencedClasses() {\n+    @SuppressWarnings(\"unchecked\")\n+    Iterable<? extends HasClassReferences> concat =\n+        Iterables.concat(fieldWriters.values(), methodWriters);\n+    return FluentIterable.from(concat)\n+        .transformAndConcat(GET_REFERENCED_CLASSES)\n+        .toSet();\n+  }\n+\n+  public Appendable writeFields(Appendable appendable, Context context) throws IOException {\n+    if (!fieldWriters.isEmpty()) {\n+      appendable.append('\\n');\n+    }\n+    for (VariableWriter fieldWriter : fieldWriters.values()) {\n+      fieldWriter.write(new IndentingAppendable(appendable), context).append('\\n');\n+    }\n+    return appendable;\n+  }\n+\n+  public Appendable writeMethods(Appendable appendable, Context context) throws IOException {\n+    for (MethodWriter methodWriter : methodWriters) {\n+      appendable.append('\\n');\n+      methodWriter.write(new IndentingAppendable(appendable), context);\n+    }\n+    return appendable;\n+  }\n+}\n"
    },
    {
        "commit_hash": "6a3595c848017a41b854b301d3a25c4d6fb8a7f4",
        "previous_commit_hash": "61d1bac10c8664ef3b4218cea8b6c3bc226ca0a6",
        "diff_stats": {
            "additions": 2,
            "deletions": 10
        },
        "diff_content": "@@ -83,22 +83,14 @@ public final class ClassWriter extends TypeWriter {\n     Writables.Joiner.on(\", \").prefix(\" implements \")\n         .appendTo(appendable, context, implementedTypes);\n     appendable.append(\" {\");\n-    if (!fieldWriters.isEmpty()) {\n-      appendable.append('\\n');\n-    }\n-    for (VariableWriter fieldWriter : fieldWriters.values()) {\n-      fieldWriter.write(new IndentingAppendable(appendable), context).append(\"\\n\");\n-    }\n+    body.writeFields(appendable, context);\n     for (ConstructorWriter constructorWriter : constructorWriters) {\n       appendable.append('\\n');\n       if (!isDefaultConstructor(constructorWriter)) {\n         constructorWriter.write(new IndentingAppendable(appendable), context);\n       }\n     }\n-    for (MethodWriter methodWriter : methodWriters) {\n-      appendable.append('\\n');\n-      methodWriter.write(new IndentingAppendable(appendable), context);\n-    }\n+    body.writeMethods(appendable, context);\n     for (TypeWriter nestedTypeWriter : nestedTypeWriters) {\n       appendable.append('\\n');\n       nestedTypeWriter.write(new IndentingAppendable(appendable), context);\n"
    },
    {
        "commit_hash": "6a3595c848017a41b854b301d3a25c4d6fb8a7f4",
        "previous_commit_hash": "61d1bac10c8664ef3b4218cea8b6c3bc226ca0a6",
        "diff_stats": {
            "additions": 2,
            "deletions": 10
        },
        "diff_content": "@@ -72,22 +72,14 @@ public final class EnumWriter extends TypeWriter {\n         .appendTo(new IndentingAppendable(appendable), context, constantWriters.values());\n     appendable.append(\";\\n\");\n \n-    if (!fieldWriters.isEmpty()) {\n-      appendable.append('\\n');\n-    }\n-    for (VariableWriter fieldWriter : fieldWriters.values()) {\n-      fieldWriter.write(new IndentingAppendable(appendable), context).append(\"\\n\");\n-    }\n+    body.writeFields(appendable, context);\n     for (ConstructorWriter constructorWriter : constructorWriters) {\n       appendable.append('\\n');\n       if (!isDefaultConstructor(constructorWriter)) {\n         constructorWriter.write(new IndentingAppendable(appendable), context);\n       }\n     }\n-    for (MethodWriter methodWriter : methodWriters) {\n-      appendable.append('\\n');\n-      methodWriter.write(new IndentingAppendable(appendable), context);\n-    }\n+    body.writeMethods(appendable, context);\n     for (TypeWriter nestedTypeWriter : nestedTypeWriters) {\n       appendable.append('\\n');\n       nestedTypeWriter.write(new IndentingAppendable(appendable), context);\n"
    },
    {
        "commit_hash": "6a3595c848017a41b854b301d3a25c4d6fb8a7f4",
        "previous_commit_hash": "61d1bac10c8664ef3b4218cea8b6c3bc226ca0a6",
        "diff_stats": {
            "additions": 1,
            "deletions": 4
        },
        "diff_content": "@@ -49,10 +49,7 @@ public final class InterfaceWriter extends TypeWriter {\n     Writables.Joiner.on(\", \").wrap(\"<\", \"> \").appendTo(appendable, context, typeVariables);\n     Writables.Joiner.on(\", \").prefix(\" extends \").appendTo(appendable, context, implementedTypes);\n     appendable.append(\" {\");\n-    for (MethodWriter methodWriter : methodWriters) {\n-      appendable.append('\\n');\n-      methodWriter.write(new IndentingAppendable(appendable), context);\n-    }\n+    body.writeMethods(appendable, context);\n     for (TypeWriter nestedTypeWriter : nestedTypeWriters) {\n       appendable.append('\\n');\n       nestedTypeWriter.write(new IndentingAppendable(appendable), context);\n"
    },
    {
        "commit_hash": "6a3595c848017a41b854b301d3a25c4d6fb8a7f4",
        "previous_commit_hash": "61d1bac10c8664ef3b4218cea8b6c3bc226ca0a6",
        "diff_stats": {
            "additions": 11,
            "deletions": 33
        },
        "diff_content": "@@ -24,14 +24,12 @@ import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.ImmutableSortedSet;\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n-import com.google.common.collect.Maps;\n import com.google.common.collect.Ordering;\n import com.google.common.collect.Queues;\n import com.google.common.collect.Sets;\n import java.io.IOException;\n import java.util.Deque;\n import java.util.List;\n-import java.util.Map;\n import java.util.Set;\n import javax.lang.model.element.TypeElement;\n import javax.lang.model.type.TypeMirror;\n@@ -43,17 +41,15 @@ public abstract class TypeWriter /* ha ha */ extends Modifiable\n     implements Writable, HasTypeName {\n   final ClassName name;\n   final List<TypeName> implementedTypes;\n-  final List<MethodWriter> methodWriters;\n+  final ClassBodyWriter body;\n   final List<TypeWriter> nestedTypeWriters;\n-  final Map<String, FieldWriter> fieldWriters;\n   final List<ClassName> explicitImports;\n \n   TypeWriter(ClassName name) {\n     this.name = name;\n     this.implementedTypes = Lists.newArrayList();\n-    this.methodWriters = Lists.newArrayList();\n+    this.body = new ClassBodyWriter();\n     this.nestedTypeWriters = Lists.newArrayList();\n-    this.fieldWriters = Maps.newLinkedHashMap();\n     this.explicitImports = Lists.newArrayList();\n   }\n \n@@ -71,29 +67,19 @@ public abstract class TypeWriter /* ha ha */ extends Modifiable\n   }\n \n   public MethodWriter addMethod(TypeWriter returnType, String name) {\n-    MethodWriter methodWriter = new MethodWriter(returnType.name, name);\n-    methodWriters.add(methodWriter);\n-    return methodWriter;\n+    return body.addMethod(returnType, name);\n   }\n \n   public MethodWriter addMethod(TypeMirror returnType, String name) {\n-    MethodWriter methodWriter =\n-        new MethodWriter(TypeNames.forTypeMirror(returnType), name);\n-    methodWriters.add(methodWriter);\n-    return methodWriter;\n+    return body.addMethod(returnType, name);\n   }\n \n   public MethodWriter addMethod(TypeName returnType, String name) {\n-    MethodWriter methodWriter = new MethodWriter(returnType, name);\n-    methodWriters.add(methodWriter);\n-    return methodWriter;\n+    return body.addMethod(returnType, name);\n   }\n \n   public MethodWriter addMethod(Class<?> returnType, String name) {\n-    MethodWriter methodWriter =\n-        new MethodWriter(TypeNames.forClass(returnType), name);\n-    methodWriters.add(methodWriter);\n-    return methodWriter;\n+    return body.addMethod(returnType, name);\n   }\n \n   public ClassWriter addNestedClass(String name) {\n@@ -123,23 +109,15 @@ public abstract class TypeWriter /* ha ha */ extends Modifiable\n   }\n \n   public FieldWriter addField(Class<?> type, String name) {\n-    return addField(TypeNames.forClass(type), name);\n+    return body.addField(type, name);\n   }\n \n   public FieldWriter addField(TypeElement type, String name) {\n-    return addField(ClassName.fromTypeElement(type), name);\n+    return body.addField(type, name);\n   }\n \n   public FieldWriter addField(TypeName type, String name) {\n-    String candidateName = name;\n-    int differentiator = 1;\n-    while (fieldWriters.containsKey(candidateName)) {\n-      candidateName = name + differentiator;\n-      differentiator++;\n-    }\n-    FieldWriter fieldWriter = new FieldWriter(type, candidateName);\n-    fieldWriters.put(candidateName, fieldWriter);\n-    return fieldWriter;\n+    return body.addField(type, name);\n   }\n \n   @Override public final String toString() {\n@@ -153,8 +131,8 @@ public abstract class TypeWriter /* ha ha */ extends Modifiable\n   @Override public Set<ClassName> referencedClasses() {\n     @SuppressWarnings(\"unchecked\")\n     Iterable<? extends HasClassReferences> concat =\n-        Iterables.concat(super.referencedClasses(), implementedTypes, methodWriters,\n-            nestedTypeWriters, fieldWriters.values(), explicitImports);\n+        Iterables.concat(super.referencedClasses(), implementedTypes, ImmutableSet.of(body),\n+            nestedTypeWriters, explicitImports);\n     return FluentIterable.from(concat)\n         .transformAndConcat(GET_REFERENCED_CLASSES)\n         .toSet();\n"
    },
    {
        "commit_hash": "4ff9adfd7372bf1cbde7402a4cf7dc80983e2f3b",
        "previous_commit_hash": "6a3595c848017a41b854b301d3a25c4d6fb8a7f4",
        "diff_stats": {
            "additions": 2,
            "deletions": 4
        },
        "diff_content": "@@ -35,12 +35,11 @@ public final class AnonymousClassWriter implements Writable, HasClassReferences\n   private final TypeName supertypeOrImplementedInterface;\n   private Optional<Snippet> constructorArguments;\n   private final ClassBodyWriter body;\n-  // TODO support nested types (currently, nested types must be fully-qualifiedly named)\n \n   AnonymousClassWriter(TypeName supertypeOrImplementedInterface) {\n     this.supertypeOrImplementedInterface = supertypeOrImplementedInterface;\n     this.constructorArguments = Optional.absent();\n-    this.body = new ClassBodyWriter();\n+    this.body = ClassBodyWriter.forAnonymousType();\n   }\n \n   public void setConstructorArguments(Snippet parameters) {\n@@ -95,8 +94,7 @@ public final class AnonymousClassWriter implements Writable, HasClassReferences\n       constructorArguments.get().write(appendable, context);\n     }\n     appendable.append(\") {\");\n-    body.writeFields(appendable, context);\n-    body.writeMethods(appendable, context);\n+    body.write(appendable, context);\n     appendable.append('}');\n     return appendable;\n   }\n"
    },
    {
        "commit_hash": "4ff9adfd7372bf1cbde7402a4cf7dc80983e2f3b",
        "previous_commit_hash": "6a3595c848017a41b854b301d3a25c4d6fb8a7f4",
        "diff_stats": {
            "additions": 67,
            "deletions": 9
        },
        "diff_content": "@@ -15,11 +15,11 @@\n  */\n package com.squareup.javawriter;\n \n+import com.google.common.base.Optional;\n import com.google.common.collect.FluentIterable;\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n-import com.squareup.javawriter.Writable.Context;\n import java.io.IOException;\n import java.util.List;\n import java.util.Map;\n@@ -27,13 +27,37 @@ import java.util.Set;\n import javax.lang.model.element.TypeElement;\n import javax.lang.model.type.TypeMirror;\n \n-public class ClassBodyWriter implements HasClassReferences {\n+import static com.google.common.base.Preconditions.checkState;\n+\n+public final class ClassBodyWriter implements Writable, HasClassReferences {\n+\n+  static ClassBodyWriter forAnonymousType() {\n+    return new ClassBodyWriter(Optional.<ClassName>absent());\n+  }\n+\n+  static ClassBodyWriter forNamedType(ClassName name) {\n+    return new ClassBodyWriter(Optional.of(name));\n+  }\n+\n+  private final Optional<ClassName> name;\n   private final Map<String, FieldWriter> fieldWriters;\n+  private final List<ConstructorWriter> constructorWriters;\n   private final List<MethodWriter> methodWriters;\n+  final List<TypeWriter> nestedTypeWriters;\n \n-  ClassBodyWriter() {\n+  private ClassBodyWriter(Optional<ClassName> name) {\n+    this.name = name;\n     this.fieldWriters = Maps.newLinkedHashMap();\n+    this.constructorWriters = Lists.newArrayList();\n     this.methodWriters = Lists.newArrayList();\n+    this.nestedTypeWriters = Lists.newArrayList();\n+  }\n+\n+  public ConstructorWriter addConstructor() {\n+    checkState(name.isPresent(), \"Cannot add a constructor to an anonymous type\");\n+    ConstructorWriter constructorWriter = new ConstructorWriter(name.get().simpleName());\n+    constructorWriters.add(constructorWriter);\n+    return constructorWriter;\n   }\n \n   public MethodWriter addMethod(TypeWriter returnType, String name) {\n@@ -82,31 +106,65 @@ public class ClassBodyWriter implements HasClassReferences {\n     return fieldWriter;\n   }\n \n+  public ClassWriter addNestedClass(String name) {\n+    // TODO support nested types in anonymous types\n+    // (currently, nested types must be fully-qualifiedly named)\n+    checkState(this.name.isPresent(), \"Nested types not yet supported in anonymous types\");\n+    ClassWriter innerClassWriter = new ClassWriter(this.name.get().nestedClassNamed(name));\n+    nestedTypeWriters.add(innerClassWriter);\n+    return innerClassWriter;\n+  }\n+\n+  public InterfaceWriter addNestedInterface(String name) {\n+    // TODO support nested types in anonymous types\n+    // (currently, nested types must be fully-qualifiedly named)\n+    checkState(this.name.isPresent(), \"Nested types not yet supported in anonymous types\");\n+    InterfaceWriter innerInterfaceWriter =\n+        new InterfaceWriter(this.name.get().nestedClassNamed(name));\n+    nestedTypeWriters.add(innerInterfaceWriter);\n+    return innerInterfaceWriter;\n+  }\n+\n+  public EnumWriter addNestedEnum(String name) {\n+    // TODO support nested types in anonymous types\n+    // (currently, nested types must be fully-qualifiedly named)\n+    checkState(this.name.isPresent(), \"Nested types not yet supported in anonymous types\");\n+    EnumWriter innerEnumWriter = new EnumWriter(this.name.get().nestedClassNamed(name));\n+    nestedTypeWriters.add(innerEnumWriter);\n+    return innerEnumWriter;\n+  }\n+\n   @Override\n   public Set<ClassName> referencedClasses() {\n     @SuppressWarnings(\"unchecked\")\n     Iterable<? extends HasClassReferences> concat =\n-        Iterables.concat(fieldWriters.values(), methodWriters);\n+        Iterables.concat(fieldWriters.values(), constructorWriters, methodWriters,\n+            nestedTypeWriters);\n     return FluentIterable.from(concat)\n         .transformAndConcat(GET_REFERENCED_CLASSES)\n         .toSet();\n   }\n \n-  public Appendable writeFields(Appendable appendable, Context context) throws IOException {\n+  @Override\n+  public Appendable write(Appendable appendable, Context context) throws IOException {\n     if (!fieldWriters.isEmpty()) {\n       appendable.append('\\n');\n     }\n     for (VariableWriter fieldWriter : fieldWriters.values()) {\n       fieldWriter.write(new IndentingAppendable(appendable), context).append('\\n');\n     }\n-    return appendable;\n-  }\n-\n-  public Appendable writeMethods(Appendable appendable, Context context) throws IOException {\n+    for (ConstructorWriter constructorWriter : constructorWriters) {\n+      appendable.append('\\n');\n+      constructorWriter.write(new IndentingAppendable(appendable), context);\n+    }\n     for (MethodWriter methodWriter : methodWriters) {\n       appendable.append('\\n');\n       methodWriter.write(new IndentingAppendable(appendable), context);\n     }\n+    for (TypeWriter nestedTypeWriter : nestedTypeWriters) {\n+      appendable.append('\\n');\n+      nestedTypeWriter.write(new IndentingAppendable(appendable), context);\n+    }\n     return appendable;\n   }\n }\n"
    },
    {
        "commit_hash": "4ff9adfd7372bf1cbde7402a4cf7dc80983e2f3b",
        "previous_commit_hash": "6a3595c848017a41b854b301d3a25c4d6fb8a7f4",
        "diff_stats": {
            "additions": 3,
            "deletions": 33
        },
        "diff_content": "@@ -19,18 +19,13 @@ import com.google.common.base.Optional;\n import com.google.common.collect.FluentIterable;\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n-import com.google.common.collect.Sets;\n import java.io.IOException;\n import java.util.List;\n import java.util.Set;\n-import javax.lang.model.element.Modifier;\n import javax.lang.model.element.TypeElement;\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.squareup.javawriter.Writables.writeToString;\n-import static javax.lang.model.element.Modifier.PRIVATE;\n-import static javax.lang.model.element.Modifier.PROTECTED;\n-import static javax.lang.model.element.Modifier.PUBLIC;\n \n public final class ClassWriter extends TypeWriter {\n   public static ClassWriter forClassName(ClassName name) {\n@@ -39,13 +34,11 @@ public final class ClassWriter extends TypeWriter {\n   }\n \n   private Optional<TypeName> supertype;\n-  private final List<ConstructorWriter> constructorWriters;\n   private final List<TypeVariableName> typeVariables;\n \n   ClassWriter(ClassName className) {\n     super(className);\n     this.supertype = Optional.absent();\n-    this.constructorWriters = Lists.newArrayList();\n     this.typeVariables = Lists.newArrayList();\n   }\n \n@@ -61,9 +54,7 @@ public final class ClassWriter extends TypeWriter {\n   }\n \n   public ConstructorWriter addConstructor() {\n-    ConstructorWriter constructorWriter = new ConstructorWriter(name.simpleName());\n-    constructorWriters.add(constructorWriter);\n-    return constructorWriter;\n+    return body.addConstructor();\n   }\n \n   public void addTypeVariable(TypeVariableName typeVariable) {\n@@ -83,36 +74,15 @@ public final class ClassWriter extends TypeWriter {\n     Writables.Joiner.on(\", \").prefix(\" implements \")\n         .appendTo(appendable, context, implementedTypes);\n     appendable.append(\" {\");\n-    body.writeFields(appendable, context);\n-    for (ConstructorWriter constructorWriter : constructorWriters) {\n-      appendable.append('\\n');\n-      if (!isDefaultConstructor(constructorWriter)) {\n-        constructorWriter.write(new IndentingAppendable(appendable), context);\n-      }\n-    }\n-    body.writeMethods(appendable, context);\n-    for (TypeWriter nestedTypeWriter : nestedTypeWriters) {\n-      appendable.append('\\n');\n-      nestedTypeWriter.write(new IndentingAppendable(appendable), context);\n-    }\n+    body.write(appendable, context);\n     appendable.append(\"}\\n\");\n     return appendable;\n   }\n \n-  private static final Set<Modifier> VISIBILIY_MODIFIERS =\n-      Sets.immutableEnumSet(PUBLIC, PROTECTED, PRIVATE);\n-\n-  private boolean isDefaultConstructor(ConstructorWriter constructorWriter) {\n-    return Sets.intersection(VISIBILIY_MODIFIERS, modifiers)\n-        .equals(Sets.intersection(VISIBILIY_MODIFIERS, constructorWriter.modifiers))\n-        && constructorWriter.body().isEmpty();\n-  }\n-\n   @Override\n   public Set<ClassName> referencedClasses() {\n     Iterable<? extends HasClassReferences> concat =\n-        Iterables.concat(super.referencedClasses(), constructorWriters, supertype.asSet(),\n-            typeVariables);\n+        Iterables.concat(super.referencedClasses(), supertype.asSet(), typeVariables);\n     return FluentIterable.from(concat)\n         .transformAndConcat(GET_REFERENCED_CLASSES)\n         .toSet();\n"
    },
    {
        "commit_hash": "4ff9adfd7372bf1cbde7402a4cf7dc80983e2f3b",
        "previous_commit_hash": "6a3595c848017a41b854b301d3a25c4d6fb8a7f4",
        "diff_stats": {
            "additions": 3,
            "deletions": 31
        },
        "diff_content": "@@ -19,18 +19,13 @@ import com.google.common.collect.FluentIterable;\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n-import com.google.common.collect.Sets;\n import java.io.IOException;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n-import javax.lang.model.element.Modifier;\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n-import static javax.lang.model.element.Modifier.PRIVATE;\n-import static javax.lang.model.element.Modifier.PROTECTED;\n-import static javax.lang.model.element.Modifier.PUBLIC;\n \n public final class EnumWriter extends TypeWriter {\n   public static EnumWriter forClassName(ClassName name) {\n@@ -39,7 +34,6 @@ public final class EnumWriter extends TypeWriter {\n   }\n \n   private final Map<String, ConstantWriter> constantWriters = Maps.newLinkedHashMap();\n-  private final List<ConstructorWriter> constructorWriters = Lists.newArrayList();\n \n   EnumWriter(ClassName name) {\n     super(name);\n@@ -52,9 +46,7 @@ public final class EnumWriter extends TypeWriter {\n   }\n \n   public ConstructorWriter addConstructor() {\n-    ConstructorWriter constructorWriter = new ConstructorWriter(name.simpleName());\n-    constructorWriters.add(constructorWriter);\n-    return constructorWriter;\n+    return body.addConstructor();\n   }\n \n   @Override\n@@ -72,35 +64,15 @@ public final class EnumWriter extends TypeWriter {\n         .appendTo(new IndentingAppendable(appendable), context, constantWriters.values());\n     appendable.append(\";\\n\");\n \n-    body.writeFields(appendable, context);\n-    for (ConstructorWriter constructorWriter : constructorWriters) {\n-      appendable.append('\\n');\n-      if (!isDefaultConstructor(constructorWriter)) {\n-        constructorWriter.write(new IndentingAppendable(appendable), context);\n-      }\n-    }\n-    body.writeMethods(appendable, context);\n-    for (TypeWriter nestedTypeWriter : nestedTypeWriters) {\n-      appendable.append('\\n');\n-      nestedTypeWriter.write(new IndentingAppendable(appendable), context);\n-    }\n+    body.write(appendable, context);\n     appendable.append(\"}\\n\");\n     return appendable;\n   }\n \n-  private static final Set<Modifier> VISIBILIY_MODIFIERS =\n-      Sets.immutableEnumSet(PUBLIC, PROTECTED, PRIVATE);\n-\n-  private boolean isDefaultConstructor(ConstructorWriter constructorWriter) {\n-    return Sets.intersection(VISIBILIY_MODIFIERS, modifiers)\n-        .equals(Sets.intersection(VISIBILIY_MODIFIERS, constructorWriter.modifiers))\n-        && constructorWriter.body().isEmpty();\n-  }\n-\n   @Override\n   public Set<ClassName> referencedClasses() {\n     Iterable<? extends HasClassReferences> concat =\n-        Iterables.concat(super.referencedClasses(), constantWriters.values(), constructorWriters);\n+        Iterables.concat(super.referencedClasses(), constantWriters.values());\n     return FluentIterable.from(concat)\n         .transformAndConcat(GET_REFERENCED_CLASSES)\n         .toSet();\n"
    },
    {
        "commit_hash": "4ff9adfd7372bf1cbde7402a4cf7dc80983e2f3b",
        "previous_commit_hash": "6a3595c848017a41b854b301d3a25c4d6fb8a7f4",
        "diff_stats": {
            "additions": 1,
            "deletions": 5
        },
        "diff_content": "@@ -49,11 +49,7 @@ public final class InterfaceWriter extends TypeWriter {\n     Writables.Joiner.on(\", \").wrap(\"<\", \"> \").appendTo(appendable, context, typeVariables);\n     Writables.Joiner.on(\", \").prefix(\" extends \").appendTo(appendable, context, implementedTypes);\n     appendable.append(\" {\");\n-    body.writeMethods(appendable, context);\n-    for (TypeWriter nestedTypeWriter : nestedTypeWriters) {\n-      appendable.append('\\n');\n-      nestedTypeWriter.write(new IndentingAppendable(appendable), context);\n-    }\n+    body.write(appendable, context);\n     appendable.append(\"}\\n\");\n     return appendable;\n   }\n"
    },
    {
        "commit_hash": "4ff9adfd7372bf1cbde7402a4cf7dc80983e2f3b",
        "previous_commit_hash": "6a3595c848017a41b854b301d3a25c4d6fb8a7f4",
        "diff_stats": {
            "additions": 7,
            "deletions": 15
        },
        "diff_content": "@@ -42,14 +42,12 @@ public abstract class TypeWriter /* ha ha */ extends Modifiable\n   final ClassName name;\n   final List<TypeName> implementedTypes;\n   final ClassBodyWriter body;\n-  final List<TypeWriter> nestedTypeWriters;\n   final List<ClassName> explicitImports;\n \n   TypeWriter(ClassName name) {\n     this.name = name;\n     this.implementedTypes = Lists.newArrayList();\n-    this.body = new ClassBodyWriter();\n-    this.nestedTypeWriters = Lists.newArrayList();\n+    this.body = ClassBodyWriter.forNamedType(name);\n     this.explicitImports = Lists.newArrayList();\n   }\n \n@@ -83,21 +81,15 @@ public abstract class TypeWriter /* ha ha */ extends Modifiable\n   }\n \n   public ClassWriter addNestedClass(String name) {\n-    ClassWriter innerClassWriter = new ClassWriter(this.name.nestedClassNamed(name));\n-    nestedTypeWriters.add(innerClassWriter);\n-    return innerClassWriter;\n+    return body.addNestedClass(name);\n   }\n \n   public InterfaceWriter addNestedInterface(String name) {\n-    InterfaceWriter innerInterfaceWriter = new InterfaceWriter(this.name.nestedClassNamed(name));\n-    nestedTypeWriters.add(innerInterfaceWriter);\n-    return innerInterfaceWriter;\n+    return body.addNestedInterface(name);\n   }\n \n   public EnumWriter addNestedEnum(String name) {\n-    EnumWriter innerEnumWriter = new EnumWriter(this.name.nestedClassNamed(name));\n-    nestedTypeWriters.add(innerEnumWriter);\n-    return innerEnumWriter;\n+    return body.addNestedEnum(name);\n   }\n \n   public void addImplementedType(TypeName typeReference) {\n@@ -132,7 +124,7 @@ public abstract class TypeWriter /* ha ha */ extends Modifiable\n     @SuppressWarnings(\"unchecked\")\n     Iterable<? extends HasClassReferences> concat =\n         Iterables.concat(super.referencedClasses(), implementedTypes, ImmutableSet.of(body),\n-            nestedTypeWriters, explicitImports);\n+            explicitImports);\n     return FluentIterable.from(concat)\n         .transformAndConcat(GET_REFERENCED_CLASSES)\n         .toSet();\n@@ -152,7 +144,7 @@ public abstract class TypeWriter /* ha ha */ extends Modifiable\n     while (!declaredTypes.isEmpty()) {\n       TypeWriter currentType = declaredTypes.pop();\n       declaredSimpleNamesBuilder.add(currentType.name().simpleName());\n-      declaredTypes.addAll(currentType.nestedTypeWriters);\n+      declaredTypes.addAll(currentType.body.nestedTypeWriters);\n     }\n \n     ImmutableSet<String> declaredSimpleNames = declaredSimpleNamesBuilder.build();\n@@ -189,7 +181,7 @@ public abstract class TypeWriter /* ha ha */ extends Modifiable\n   }\n \n   protected Context createSubcontext(Context context) {\n-    return context.createSubcontext(FluentIterable.from(nestedTypeWriters)\n+    return context.createSubcontext(FluentIterable.from(body.nestedTypeWriters)\n         .transform(new Function<TypeWriter, ClassName>() {\n           @Override public ClassName apply(TypeWriter input) {\n             return input.name();\n"
    },
    {
        "commit_hash": "4ff9adfd7372bf1cbde7402a4cf7dc80983e2f3b",
        "previous_commit_hash": "6a3595c848017a41b854b301d3a25c4d6fb8a7f4",
        "diff_stats": {
            "additions": 34,
            "deletions": 3
        },
        "diff_content": "@@ -18,6 +18,7 @@ package com.squareup.javawriter;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n+import javax.lang.model.element.Modifier;\n \n import static com.google.common.truth.Truth.assertThat;\n import static org.junit.Assert.fail;\n@@ -35,7 +36,7 @@ public final class EnumWriterTest {\n   }\n \n   @Test public void constantsAreRequired() {\n-    EnumWriter enumWriter = EnumWriter.forClassName(ClassName.create(\"\", \"Test\"));\n+    EnumWriter enumWriter = EnumWriter.forClassName(ClassName.create(\"test\", \"Test\"));\n     try {\n       Writables.writeToString(enumWriter);\n       fail();\n@@ -45,15 +46,45 @@ public final class EnumWriterTest {\n   }\n \n   @Test public void constantsAreIndented() {\n-    EnumWriter enumWriter = EnumWriter.forClassName(ClassName.create(\"\", \"Test\"));\n+    EnumWriter enumWriter = EnumWriter.forClassName(ClassName.create(\"test\", \"Test\"));\n     enumWriter.addConstant(\"HELLO\");\n     enumWriter.addConstant(\"WORLD\");\n \n     String expected = \"\"\n+        + \"package test;\\n\"\n+        + \"\\n\"\n         + \"enum Test {\\n\"\n         + \"  HELLO,\\n\"\n         + \"  WORLD;\\n\"\n         + \"}\\n\";\n-    assertThat(Writables.writeToString(enumWriter)).isEqualTo(expected);\n+    assertThat(enumWriter.toString()).isEqualTo(expected);\n+  }\n+\n+  @Test public void constantsWithConstructorArguments() {\n+    EnumWriter enumWriter = EnumWriter.forClassName(ClassName.create(\"test\", \"Test\"));\n+    enumWriter.addConstant(\"HELLO\").addArgument(Snippet.format(\"\\\"Hello\\\"\"));\n+    enumWriter.addConstant(\"WORLD\").addArgument(Snippet.format(\"\\\"World!\\\"\"));\n+\n+    FieldWriter valueWriter = enumWriter.addField(String.class, \"value\");\n+    valueWriter.addModifiers(Modifier.PUBLIC, Modifier.FINAL);\n+\n+    ConstructorWriter constructorWriterWriter = enumWriter.addConstructor();\n+    constructorWriterWriter.addModifiers(Modifier.PRIVATE);\n+    constructorWriterWriter.addParameter(String.class, \"value\");\n+    constructorWriterWriter.body().addSnippet(\"this.value = value;\");\n+\n+    assertThat(enumWriter.toString()).isEqualTo(\"\"\n+        + \"package test;\\n\"\n+        + \"\\n\"\n+        + \"enum Test {\\n\"\n+        + \"  HELLO(\\\"Hello\\\"),\\n\"\n+        + \"  WORLD(\\\"World!\\\");\\n\"\n+        + \"\\n\"\n+        + \"  public final String value;\\n\"\n+        + \"\\n\"\n+        + \"  private Test(String value) {\\n\"\n+        + \"    this.value = value;\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n   }\n }\n"
    },
    {
        "commit_hash": "1c4d9fc23742b509de93ee71e005260f0ab69606",
        "previous_commit_hash": "4ff9adfd7372bf1cbde7402a4cf7dc80983e2f3b",
        "diff_stats": {
            "additions": 5,
            "deletions": 0
        },
        "diff_content": "@@ -53,6 +53,11 @@ public final class ClassBodyWriter implements Writable, HasClassReferences {\n     this.nestedTypeWriters = Lists.newArrayList();\n   }\n \n+  public boolean isEmpty() {\n+    return fieldWriters.isEmpty() && constructorWriters.isEmpty() && methodWriters.isEmpty()\n+        && nestedTypeWriters.isEmpty();\n+  }\n+\n   public ConstructorWriter addConstructor() {\n     checkState(name.isPresent(), \"Cannot add a constructor to an anonymous type\");\n     ConstructorWriter constructorWriter = new ConstructorWriter(name.get().simpleName());\n"
    },
    {
        "commit_hash": "1c4d9fc23742b509de93ee71e005260f0ab69606",
        "previous_commit_hash": "4ff9adfd7372bf1cbde7402a4cf7dc80983e2f3b",
        "diff_stats": {
            "additions": 39,
            "deletions": 1
        },
        "diff_content": "@@ -16,6 +16,7 @@\n package com.squareup.javawriter;\n \n import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n@@ -23,6 +24,8 @@ import java.io.IOException;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeMirror;\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n@@ -81,10 +84,12 @@ public final class EnumWriter extends TypeWriter {\n   public static final class ConstantWriter implements Writable, HasClassReferences {\n     private final String name;\n     private final List<Snippet> constructorSnippets;\n+    private final ClassBodyWriter body;\n \n     private ConstantWriter(String name) {\n       this.name = name;\n       this.constructorSnippets = Lists.newArrayList();\n+      this.body = ClassBodyWriter.forAnonymousType();\n     }\n \n     public ConstantWriter addArgument(Snippet snippet) {\n@@ -92,16 +97,49 @@ public final class EnumWriter extends TypeWriter {\n       return this;\n     }\n \n+    public MethodWriter addMethod(TypeWriter returnType, String name) {\n+      return body.addMethod(returnType, name);\n+    }\n+\n+    public MethodWriter addMethod(TypeMirror returnType, String name) {\n+      return body.addMethod(returnType, name);\n+    }\n+\n+    public MethodWriter addMethod(TypeName returnType, String name) {\n+      return body.addMethod(returnType, name);\n+    }\n+\n+    public MethodWriter addMethod(Class<?> returnType, String name) {\n+      return body.addMethod(returnType, name);\n+    }\n+\n+    public FieldWriter addField(Class<?> type, String name) {\n+      return body.addField(type, name);\n+    }\n+\n+    public FieldWriter addField(TypeElement type, String name) {\n+      return body.addField(type, name);\n+    }\n+\n+    public FieldWriter addField(TypeName type, String name) {\n+      return body.addField(type, name);\n+    }\n+\n     @Override\n     public Appendable write(Appendable appendable, Context context) throws IOException {\n       appendable.append(name);\n       Writables.Joiner.on(\", \").wrap(\"(\", \")\").appendTo(appendable, context, constructorSnippets);\n+      if (!body.isEmpty()) {\n+        appendable.append(\" {\");\n+        body.write(appendable, context);\n+        appendable.append('}');\n+      }\n       return appendable;\n     }\n \n     @Override\n     public Set<ClassName> referencedClasses() {\n-      return FluentIterable.from(constructorSnippets)\n+      return FluentIterable.from(Iterables.concat(constructorSnippets, ImmutableList.of(body)))\n           .transformAndConcat(GET_REFERENCED_CLASSES)\n           .toSet();\n     }\n"
    },
    {
        "commit_hash": "1c4d9fc23742b509de93ee71e005260f0ab69606",
        "previous_commit_hash": "4ff9adfd7372bf1cbde7402a4cf7dc80983e2f3b",
        "diff_stats": {
            "additions": 34,
            "deletions": 0
        },
        "diff_content": "@@ -87,4 +87,38 @@ public final class EnumWriterTest {\n         + \"  }\\n\"\n         + \"}\\n\");\n   }\n+\n+  @Test public void constantsWithClassBody() {\n+    EnumWriter enumWriter = EnumWriter.forClassName(ClassName.create(\"test\", \"Test\"));\n+\n+    EnumWriter.ConstantWriter helloWriter = enumWriter.addConstant(\"HELLO\");\n+    MethodWriter helloToStringWriter = helloWriter.addMethod(String.class, \"toString\");\n+    helloToStringWriter.annotate(Override.class);\n+    helloToStringWriter.addModifiers(Modifier.PUBLIC);\n+    helloToStringWriter.body().addSnippet(\"return \\\"Hello\\\";\");\n+\n+    EnumWriter.ConstantWriter worldWriter = enumWriter.addConstant(\"WORLD\");\n+    MethodWriter worldToStringWriter = worldWriter.addMethod(String.class, \"toString\");\n+    worldToStringWriter.annotate(Override.class);\n+    worldToStringWriter.addModifiers(Modifier.PUBLIC);\n+    worldToStringWriter.body().addSnippet(\"return \\\"World!\\\";\");\n+\n+    assertThat(enumWriter.toString()).isEqualTo(\"\"\n+        + \"package test;\\n\"\n+        + \"\\n\"\n+        + \"enum Test {\\n\"\n+        + \"  HELLO {\\n\"\n+        + \"    @Override\\n\"\n+        + \"    public String toString() {\\n\"\n+        + \"      return \\\"Hello\\\";\\n\"\n+        + \"    }\\n\"\n+        + \"  },\\n\"\n+        + \"  WORLD {\\n\"\n+        + \"    @Override\\n\"\n+        + \"    public String toString() {\\n\"\n+        + \"      return \\\"World!\\\";\\n\"\n+        + \"    }\\n\"\n+        + \"  };\\n\"\n+        + \"}\\n\");\n+  }\n }\n"
    },
    {
        "commit_hash": "77c1d729d8ae68ac5da04b4e97f28e8acdbd1dff",
        "previous_commit_hash": "1c4d9fc23742b509de93ee71e005260f0ab69606",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -29,7 +29,7 @@ import javax.lang.model.type.TypeMirror;\n \n import static com.google.common.base.Preconditions.checkState;\n \n-public final class ClassBodyWriter implements Writable, HasClassReferences {\n+final class ClassBodyWriter implements Writable, HasClassReferences {\n \n   static ClassBodyWriter forAnonymousType() {\n     return new ClassBodyWriter(Optional.<ClassName>absent());\n"
    },
    {
        "commit_hash": "3bef5b6c222415b15ee690c6ba227712d16a4c17",
        "previous_commit_hash": "22e515daa1fcc32b7f309d398ac2d8f3a9df5994",
        "diff_stats": {
            "additions": 45,
            "deletions": 3
        },
        "diff_content": "@@ -30,6 +30,7 @@ import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n \n import static com.google.common.truth.Truth.assertThat;\n+import static javax.tools.StandardLocation.SOURCE_OUTPUT;\n \n @RunWith(JUnit4.class)\n public final class JavaWriterTest {\n@@ -42,6 +43,10 @@ public final class JavaWriterTest {\n   private final FileSystem fs = Jimfs.newFileSystem();\n   private final Path fsRoot = Iterables.getOnlyElement(fs.getRootDirectories());\n \n+  // Used for testing annotation processor Filer behavior.\n+  private final TestFiler filer = new TestFiler(fs);\n+  private final Path filerRoot = filer.getLocationPath(SOURCE_OUTPUT);\n+\n   @Test public void pathNotDirectory() throws IOException {\n     Path path = fs.getPath(\"/foo/bar\");\n     Files.createDirectories(path.getParent());\n@@ -80,6 +85,15 @@ public final class JavaWriterTest {\n     assertThat(testFile.exists()).isTrue();\n   }\n \n+  @Test public void filerDefaultPackage() throws IOException {\n+    ClassName name = ClassName.create(\"\", \"Test\");\n+    ClassWriter test = ClassWriter.forClassName(name);\n+    javaWriter.addTypeWriter(test).writeTo(filer);\n+\n+    Path testPath = filerRoot.resolve(\"Test.java\");\n+    assertThat(Files.exists(testPath)).isTrue();\n+  }\n+\n   @Test public void pathSamePackage() throws IOException {\n     ClassName name1 = ClassName.create(\"example\", \"Test1\");\n     ClassName name2 = ClassName.create(\"example\", \"Test2\");\n@@ -87,9 +101,9 @@ public final class JavaWriterTest {\n     ClassWriter test2 = ClassWriter.forClassName(name2);\n     javaWriter.addTypeWriter(test1).addTypeWriter(test2).writeTo(fsRoot);\n \n-    Path testPath1 = fsRoot.resolve(\"example/Test1.java\");\n+    Path testPath1 = fsRoot.resolve(fs.getPath(\"example\", \"Test1.java\"));\n     assertThat(Files.exists(testPath1)).isTrue();\n-    Path testPath2 = fsRoot.resolve(\"example/Test2.java\");\n+    Path testPath2 = fsRoot.resolve(fs.getPath(\"example\", \"Test2.java\"));\n     assertThat(Files.exists(testPath2)).isTrue();\n   }\n \n@@ -107,6 +121,19 @@ public final class JavaWriterTest {\n     assertThat(testFile2.exists()).isTrue();\n   }\n \n+  @Test public void filerSamePackage() throws IOException {\n+    ClassName name1 = ClassName.create(\"example\", \"Test1\");\n+    ClassName name2 = ClassName.create(\"example\", \"Test2\");\n+    ClassWriter test1 = ClassWriter.forClassName(name1);\n+    ClassWriter test2 = ClassWriter.forClassName(name2);\n+    javaWriter.addTypeWriter(test1).addTypeWriter(test2).writeTo(filer);\n+\n+    Path testPath1 = filerRoot.resolve(fs.getPath(\"example\", \"Test1.java\"));\n+    assertThat(Files.exists(testPath1)).isTrue();\n+    Path testPath2 = filerRoot.resolve(fs.getPath(\"example\", \"Test2.java\"));\n+    assertThat(Files.exists(testPath2)).isTrue();\n+  }\n+\n   @Test public void pathNestedClasses() throws IOException {\n     ClassName fooName = ClassName.create(\"foo\", \"Test\");\n     ClassName barName = ClassName.create(\"foo.bar\", \"Test\");\n@@ -144,5 +171,20 @@ public final class JavaWriterTest {\n     assertThat(bazFile.exists()).isTrue();\n   }\n \n-  // TODO Filer-based tests\n+  @Test public void filerNestedClasses() throws IOException {\n+    ClassName fooName = ClassName.create(\"foo\", \"Test\");\n+    ClassName barName = ClassName.create(\"foo.bar\", \"Test\");\n+    ClassName bazName = ClassName.create(\"foo.bar.baz\", \"Test\");\n+    ClassWriter foo = ClassWriter.forClassName(fooName);\n+    ClassWriter bar = ClassWriter.forClassName(barName);\n+    ClassWriter baz = ClassWriter.forClassName(bazName);\n+    javaWriter.addTypeWriters(ImmutableList.of(foo, bar, baz)).writeTo(filer);\n+\n+    Path fooPath = filerRoot.resolve(fs.getPath(\"foo\", \"Test.java\"));\n+    Path barPath = filerRoot.resolve(fs.getPath(\"foo\", \"bar\", \"Test.java\"));\n+    Path bazPath = filerRoot.resolve(fs.getPath(\"foo\", \"bar\", \"baz\", \"Test.java\"));\n+    assertThat(Files.exists(fooPath)).isTrue();\n+    assertThat(Files.exists(barPath)).isTrue();\n+    assertThat(Files.exists(bazPath)).isTrue();\n+  }\n }\n"
    },
    {
        "commit_hash": "3bef5b6c222415b15ee690c6ba227712d16a4c17",
        "previous_commit_hash": "22e515daa1fcc32b7f309d398ac2d8f3a9df5994",
        "diff_stats": {
            "additions": 90,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright (C) 2014 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import com.sun.tools.javac.nio.JavacPathFileManager;\n+import com.sun.tools.javac.nio.PathFileManager;\n+import com.sun.tools.javac.util.Context;\n+import java.io.IOException;\n+import java.nio.file.FileSystem;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import javax.annotation.processing.Filer;\n+import javax.lang.model.element.Element;\n+import javax.tools.FileObject;\n+import javax.tools.JavaFileManager;\n+import javax.tools.JavaFileObject;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static javax.tools.StandardLocation.CLASS_OUTPUT;\n+import static javax.tools.StandardLocation.SOURCE_OUTPUT;\n+\n+final class TestFiler implements Filer {\n+  private final String separator;\n+  private final Path fileSystemRoot;\n+  private final PathFileManager fileManager;\n+\n+  public TestFiler(FileSystem fileSystem) {\n+    separator = fileSystem.getSeparator();\n+    fileSystemRoot = Iterables.get(fileSystem.getRootDirectories(), 0);\n+    fileManager = new JavacPathFileManager(new Context(), false, UTF_8);\n+    fileManager.setDefaultFileSystem(fileSystem);\n+  }\n+\n+  public Path getLocationPath(JavaFileManager.Location location) {\n+    Iterable<? extends Path> locationPaths = fileManager.getLocation(location);\n+    if (locationPaths == null || Iterables.isEmpty(locationPaths)) {\n+      Path locationPath = fileSystemRoot.resolve(location.getName());\n+      locationPaths = ImmutableList.of(locationPath);\n+      try {\n+        Files.createDirectories(locationPath);\n+        fileManager.setLocation(location, locationPaths);\n+      } catch (IOException e) {\n+        throw new RuntimeException(e);\n+      }\n+    }\n+    return Iterables.getOnlyElement(locationPaths);\n+  }\n+\n+  private JavaFileObject getJavaFileObject(String fqcn, JavaFileManager.Location location) {\n+    String javaPath = fqcn.replace(\".\", separator) + \".java\"; // Not robust, assumes well-formed.\n+    Path finalPath = getLocationPath(location).resolve(javaPath);\n+    return Iterables.getOnlyElement(fileManager.getJavaFileObjects(finalPath));\n+  }\n+\n+  @Override\n+  public JavaFileObject createSourceFile(CharSequence name, Element... originatingElements)\n+      throws IOException {\n+    return getJavaFileObject(name.toString(), SOURCE_OUTPUT);\n+  }\n+\n+  @Override public JavaFileObject createClassFile(CharSequence name, Element... originatingElements)\n+      throws IOException {\n+    return getJavaFileObject(name.toString(), CLASS_OUTPUT);\n+  }\n+\n+  @Override public FileObject createResource(JavaFileManager.Location location, CharSequence pkg,\n+      CharSequence relativeName, Element... originatingElements) throws IOException {\n+    return getJavaFileObject(pkg + \".\" + relativeName, location);\n+  }\n+\n+  @Override public FileObject getResource(JavaFileManager.Location location, CharSequence pkg,\n+      CharSequence relativeName) throws IOException {\n+    return getJavaFileObject(pkg + \".\" + relativeName, location);\n+  }\n+}\n"
    },
    {
        "commit_hash": "acb2d7f3a7d364ae97bf0c9c17c1c536882ebaa5",
        "previous_commit_hash": "3bef5b6c222415b15ee690c6ba227712d16a4c17",
        "diff_stats": {
            "additions": 3,
            "deletions": 1
        },
        "diff_content": "@@ -44,7 +44,9 @@\n     <module name=\"IllegalImport\"/>\n     <!-- defaults to sun.* packages -->\n     <module name=\"RedundantImport\"/>\n-    <module name=\"UnusedImports\"/>\n+    <module name=\"UnusedImports\">\n+      <property name=\"processJavadoc\" value=\"true\"/>\n+    </module>\n \n \n     <!-- Checks for Size Violations.                    -->\n"
    },
    {
        "commit_hash": "acb2d7f3a7d364ae97bf0c9c17c1c536882ebaa5",
        "previous_commit_hash": "3bef5b6c222415b15ee690c6ba227712d16a4c17",
        "diff_stats": {
            "additions": 6,
            "deletions": 0
        },
        "diff_content": "@@ -81,6 +81,12 @@\n       <version>1.0</version>\n       <scope>test</scope>\n     </dependency>\n+    <dependency>\n+      <groupId>org.mockito</groupId>\n+      <artifactId>mockito-core</artifactId>\n+      <version>1.10.16</version>\n+      <scope>test</scope>\n+    </dependency>\n   </dependencies>\n \n   <build>\n"
    },
    {
        "commit_hash": "acb2d7f3a7d364ae97bf0c9c17c1c536882ebaa5",
        "previous_commit_hash": "3bef5b6c222415b15ee690c6ba227712d16a4c17",
        "diff_stats": {
            "additions": 1,
            "deletions": 8
        },
        "diff_content": "@@ -15,7 +15,6 @@\n  */\n package com.squareup.javawriter;\n \n-import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n import com.google.common.io.Closer;\n@@ -104,15 +103,9 @@ public final class JavaWriter {\n   }\n \n   public void writeTo(Filer filer) throws IOException {\n-    writeTo(filer, ImmutableSet.<Element>of());\n-  }\n-\n-  public void writeTo(Filer filer, Iterable<? extends Element> originatingElements)\n-      throws IOException {\n-    // TODO tack originatingElements on TypeWriter? Losing a top-level-only writer for this sucks.\n     for (TypeWriter typeWriter : typeWriters) {\n       JavaFileObject sourceFile = filer.createSourceFile(typeWriter.name().canonicalName(),\n-          Iterables.toArray(originatingElements, Element.class));\n+          Iterables.toArray(typeWriter.originatingElements(), Element.class));\n       Writer closeable = sourceFile.openWriter();\n       Closer closer = Closer.create();\n       try {\n"
    },
    {
        "commit_hash": "acb2d7f3a7d364ae97bf0c9c17c1c536882ebaa5",
        "previous_commit_hash": "3bef5b6c222415b15ee690c6ba227712d16a4c17",
        "diff_stats": {
            "additions": 31,
            "deletions": 1
        },
        "diff_content": "@@ -31,6 +31,7 @@ import java.io.IOException;\n import java.util.Deque;\n import java.util.List;\n import java.util.Set;\n+import javax.lang.model.element.Element;\n import javax.lang.model.element.TypeElement;\n import javax.lang.model.type.TypeMirror;\n \n@@ -42,13 +43,33 @@ public abstract class TypeWriter /* ha ha */ extends Modifiable\n   final ClassName name;\n   final List<TypeName> implementedTypes;\n   final ClassBodyWriter body;\n-  final List<ClassName> explicitImports;\n+  private final List<ClassName> explicitImports;\n+  private final List<Element> originatingElements;\n \n   TypeWriter(ClassName name) {\n     this.name = name;\n     this.implementedTypes = Lists.newArrayList();\n     this.body = ClassBodyWriter.forNamedType(name);\n     this.explicitImports = Lists.newArrayList();\n+    this.originatingElements = Lists.newArrayList();\n+  }\n+\n+  /**\n+   * Add one or more originating elements for which this type is being generated.\n+   *\n+   * @see JavaWriter#writeTo\n+   */\n+  public void addOriginatingElement(Element first, Element... rest) {\n+    addOriginatingElement(Lists.asList(first, rest));\n+  }\n+\n+  /**\n+   * Add originating elements for which this type is being generated.\n+   *\n+   * @see JavaWriter#writeTo\n+   */\n+  public void addOriginatingElement(Iterable<? extends Element> elements) {\n+    Iterables.addAll(originatingElements, elements);\n   }\n \n   @Override\n@@ -130,6 +151,15 @@ public abstract class TypeWriter /* ha ha */ extends Modifiable\n         .toSet();\n   }\n \n+  Set<Element> originatingElements() {\n+    ImmutableSet.Builder<Element> elements = ImmutableSet.builder();\n+    elements.addAll(originatingElements);\n+    for (TypeWriter nestedTypeWriter : body.nestedTypeWriters) {\n+      elements.addAll(nestedTypeWriter.originatingElements());\n+    }\n+    return elements.build();\n+  }\n+\n   Appendable writeTypeToAppendable(Appendable appendable) throws IOException {\n     String packageName = name().packageName();\n     appendable.append(\"package \").append(packageName).append(\";\\n\\n\");\n"
    },
    {
        "commit_hash": "acb2d7f3a7d364ae97bf0c9c17c1c536882ebaa5",
        "previous_commit_hash": "3bef5b6c222415b15ee690c6ba227712d16a4c17",
        "diff_stats": {
            "additions": 29,
            "deletions": 9
        },
        "diff_content": "@@ -23,14 +23,15 @@ import java.io.IOException;\n import java.nio.file.FileSystem;\n import java.nio.file.Files;\n import java.nio.file.Path;\n+import javax.lang.model.element.Element;\n import org.junit.Rule;\n import org.junit.Test;\n import org.junit.rules.TemporaryFolder;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n+import org.mockito.Mockito;\n \n import static com.google.common.truth.Truth.assertThat;\n-import static javax.tools.StandardLocation.SOURCE_OUTPUT;\n \n @RunWith(JUnit4.class)\n public final class JavaWriterTest {\n@@ -44,8 +45,7 @@ public final class JavaWriterTest {\n   private final Path fsRoot = Iterables.getOnlyElement(fs.getRootDirectories());\n \n   // Used for testing annotation processor Filer behavior.\n-  private final TestFiler filer = new TestFiler(fs);\n-  private final Path filerRoot = filer.getLocationPath(SOURCE_OUTPUT);\n+  private final TestFiler filer = new TestFiler(fs, fsRoot);\n \n   @Test public void pathNotDirectory() throws IOException {\n     Path path = fs.getPath(\"/foo/bar\");\n@@ -90,7 +90,7 @@ public final class JavaWriterTest {\n     ClassWriter test = ClassWriter.forClassName(name);\n     javaWriter.addTypeWriter(test).writeTo(filer);\n \n-    Path testPath = filerRoot.resolve(\"Test.java\");\n+    Path testPath = fsRoot.resolve(\"Test.java\");\n     assertThat(Files.exists(testPath)).isTrue();\n   }\n \n@@ -128,9 +128,9 @@ public final class JavaWriterTest {\n     ClassWriter test2 = ClassWriter.forClassName(name2);\n     javaWriter.addTypeWriter(test1).addTypeWriter(test2).writeTo(filer);\n \n-    Path testPath1 = filerRoot.resolve(fs.getPath(\"example\", \"Test1.java\"));\n+    Path testPath1 = fsRoot.resolve(fs.getPath(\"example\", \"Test1.java\"));\n     assertThat(Files.exists(testPath1)).isTrue();\n-    Path testPath2 = filerRoot.resolve(fs.getPath(\"example\", \"Test2.java\"));\n+    Path testPath2 = fsRoot.resolve(fs.getPath(\"example\", \"Test2.java\"));\n     assertThat(Files.exists(testPath2)).isTrue();\n   }\n \n@@ -180,11 +180,31 @@ public final class JavaWriterTest {\n     ClassWriter baz = ClassWriter.forClassName(bazName);\n     javaWriter.addTypeWriters(ImmutableList.of(foo, bar, baz)).writeTo(filer);\n \n-    Path fooPath = filerRoot.resolve(fs.getPath(\"foo\", \"Test.java\"));\n-    Path barPath = filerRoot.resolve(fs.getPath(\"foo\", \"bar\", \"Test.java\"));\n-    Path bazPath = filerRoot.resolve(fs.getPath(\"foo\", \"bar\", \"baz\", \"Test.java\"));\n+    Path fooPath = fsRoot.resolve(fs.getPath(\"foo\", \"Test.java\"));\n+    Path barPath = fsRoot.resolve(fs.getPath(\"foo\", \"bar\", \"Test.java\"));\n+    Path bazPath = fsRoot.resolve(fs.getPath(\"foo\", \"bar\", \"baz\", \"Test.java\"));\n     assertThat(Files.exists(fooPath)).isTrue();\n     assertThat(Files.exists(barPath)).isTrue();\n     assertThat(Files.exists(bazPath)).isTrue();\n   }\n+\n+  @Test public void filerPassesOriginatingElements() throws IOException {\n+    ClassName name1 = ClassName.create(\"example\", \"Test1\");\n+    ClassWriter test1 = ClassWriter.forClassName(name1);\n+    Element element1_1 = Mockito.mock(Element.class);\n+    test1.addOriginatingElement(element1_1);\n+\n+    ClassName name2 = ClassName.create(\"example\", \"Test2\");\n+    ClassWriter test2 = ClassWriter.forClassName(name2);\n+    Element element2_1 = Mockito.mock(Element.class);\n+    Element element2_2 = Mockito.mock(Element.class);\n+    test2.addOriginatingElement(element2_1, element2_2);\n+\n+    javaWriter.addTypeWriter(test1).addTypeWriter(test2).writeTo(filer);\n+\n+    Path testPath1 = fsRoot.resolve(fs.getPath(\"example\", \"Test1.java\"));\n+    assertThat(filer.getOriginatingElements(testPath1)).containsExactly(element1_1);\n+    Path testPath2 = fsRoot.resolve(fs.getPath(\"example\", \"Test2.java\"));\n+    assertThat(filer.getOriginatingElements(testPath2)).containsExactly(element2_1, element2_2);\n+  }\n }\n"
    },
    {
        "commit_hash": "acb2d7f3a7d364ae97bf0c9c17c1c536882ebaa5",
        "previous_commit_hash": "3bef5b6c222415b15ee690c6ba227712d16a4c17",
        "diff_stats": {
            "additions": 17,
            "deletions": 29
        },
        "diff_content": "@@ -15,15 +15,17 @@\n  */\n package com.squareup.javawriter;\n \n-import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Iterables;\n+import com.google.common.collect.LinkedHashMultimap;\n+import com.google.common.collect.SetMultimap;\n import com.sun.tools.javac.nio.JavacPathFileManager;\n import com.sun.tools.javac.nio.PathFileManager;\n import com.sun.tools.javac.util.Context;\n import java.io.IOException;\n import java.nio.file.FileSystem;\n-import java.nio.file.Files;\n import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.Set;\n import javax.annotation.processing.Filer;\n import javax.lang.model.element.Element;\n import javax.tools.FileObject;\n@@ -31,60 +33,46 @@ import javax.tools.JavaFileManager;\n import javax.tools.JavaFileObject;\n \n import static java.nio.charset.StandardCharsets.UTF_8;\n-import static javax.tools.StandardLocation.CLASS_OUTPUT;\n-import static javax.tools.StandardLocation.SOURCE_OUTPUT;\n \n final class TestFiler implements Filer {\n   private final String separator;\n   private final Path fileSystemRoot;\n   private final PathFileManager fileManager;\n+  private final SetMultimap<Path, Element> originatingElementsMap;\n \n-  public TestFiler(FileSystem fileSystem) {\n+  public TestFiler(FileSystem fileSystem, Path fsRoot) {\n     separator = fileSystem.getSeparator();\n-    fileSystemRoot = Iterables.get(fileSystem.getRootDirectories(), 0);\n+    fileSystemRoot = fsRoot;\n     fileManager = new JavacPathFileManager(new Context(), false, UTF_8);\n     fileManager.setDefaultFileSystem(fileSystem);\n+    originatingElementsMap = LinkedHashMultimap.create();\n   }\n \n-  public Path getLocationPath(JavaFileManager.Location location) {\n-    Iterable<? extends Path> locationPaths = fileManager.getLocation(location);\n-    if (locationPaths == null || Iterables.isEmpty(locationPaths)) {\n-      Path locationPath = fileSystemRoot.resolve(location.getName());\n-      locationPaths = ImmutableList.of(locationPath);\n-      try {\n-        Files.createDirectories(locationPath);\n-        fileManager.setLocation(location, locationPaths);\n-      } catch (IOException e) {\n-        throw new RuntimeException(e);\n-      }\n-    }\n-    return Iterables.getOnlyElement(locationPaths);\n-  }\n-\n-  private JavaFileObject getJavaFileObject(String fqcn, JavaFileManager.Location location) {\n-    String javaPath = fqcn.replace(\".\", separator) + \".java\"; // Not robust, assumes well-formed.\n-    Path finalPath = getLocationPath(location).resolve(javaPath);\n-    return Iterables.getOnlyElement(fileManager.getJavaFileObjects(finalPath));\n+  public Set<Element> getOriginatingElements(Path path) {\n+    return originatingElementsMap.get(path);\n   }\n \n   @Override\n   public JavaFileObject createSourceFile(CharSequence name, Element... originatingElements)\n       throws IOException {\n-    return getJavaFileObject(name.toString(), SOURCE_OUTPUT);\n+    String relative = name.toString().replace(\".\", separator) + \".java\"; // Not robust, assumes well-formed.\n+    Path path = fileSystemRoot.resolve(relative);\n+    originatingElementsMap.putAll(path, Arrays.asList(originatingElements));\n+    return Iterables.getOnlyElement(fileManager.getJavaFileObjects(path));\n   }\n \n   @Override public JavaFileObject createClassFile(CharSequence name, Element... originatingElements)\n       throws IOException {\n-    return getJavaFileObject(name.toString(), CLASS_OUTPUT);\n+    throw new UnsupportedOperationException(\"Not implemented.\");\n   }\n \n   @Override public FileObject createResource(JavaFileManager.Location location, CharSequence pkg,\n       CharSequence relativeName, Element... originatingElements) throws IOException {\n-    return getJavaFileObject(pkg + \".\" + relativeName, location);\n+    throw new UnsupportedOperationException(\"Not implemented.\");\n   }\n \n   @Override public FileObject getResource(JavaFileManager.Location location, CharSequence pkg,\n       CharSequence relativeName) throws IOException {\n-    return getJavaFileObject(pkg + \".\" + relativeName, location);\n+    throw new UnsupportedOperationException(\"Not implemented.\");\n   }\n }\n"
    },
    {
        "commit_hash": "acb2d7f3a7d364ae97bf0c9c17c1c536882ebaa5",
        "previous_commit_hash": "3bef5b6c222415b15ee690c6ba227712d16a4c17",
        "diff_stats": {
            "additions": 23,
            "deletions": 0
        },
        "diff_content": "@@ -15,10 +15,13 @@\n  */\n package com.squareup.javawriter;\n \n+import com.google.common.collect.ImmutableList;\n import java.util.concurrent.Executor;\n+import javax.lang.model.element.Element;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n+import org.mockito.Mockito;\n \n import static com.google.common.truth.Truth.assertThat;\n \n@@ -72,4 +75,24 @@ public class TypeWriterTest {\n         + \"class Top {}\\n\";\n     assertThat(topClass.toString()).isEqualTo(expected);\n   }\n+\n+  @Test public void nestedTypesPropagateOriginatingElements() {\n+    ClassWriter outer = ClassWriter.forClassName(ClassName.create(\"test\", \"Outer\"));\n+    Element outerElement = Mockito.mock(Element.class);\n+    outer.addOriginatingElement(outerElement);\n+\n+    ClassWriter middle = outer.addNestedClass(\"Middle\");\n+    Element middleElement1 = Mockito.mock(Element.class);\n+    Element middleElement2 = Mockito.mock(Element.class);\n+    middle.addOriginatingElement(middleElement1, middleElement2);\n+\n+    ClassWriter inner = middle.addNestedClass(\"Inner\");\n+    Element innerElement1 = Mockito.mock(Element.class);\n+    Element innerElement2 = Mockito.mock(Element.class);\n+    Element innerElement3 = Mockito.mock(Element.class);\n+    inner.addOriginatingElement(ImmutableList.of(innerElement1, innerElement2, innerElement3));\n+\n+    assertThat(outer.originatingElements()).containsExactly(outerElement, middleElement1,\n+        middleElement2, innerElement1, innerElement2, innerElement3);\n+  }\n }\n"
    },
    {
        "commit_hash": "d2ce2872d26e7256b0af74189cacea7b75390b2f",
        "previous_commit_hash": "ddb04c3f9bb1fd2b2ba2a14542dbfb48a30f8844",
        "diff_stats": {
            "additions": 4,
            "deletions": 0
        },
        "diff_content": "@@ -50,6 +50,10 @@ public final class JavaWriter {\n     return this;\n   }\n \n+  public JavaWriter addTypeWriters(TypeWriter first, TypeWriter second, TypeWriter... rest) {\n+    return addTypeWriters(Lists.asList(first, second, rest));\n+  }\n+\n   public JavaWriter addTypeWriters(Iterable<? extends TypeWriter> typeWriters) {\n     Iterables.addAll(this.typeWriters, typeWriters);\n     return this;\n"
    },
    {
        "commit_hash": "d2ce2872d26e7256b0af74189cacea7b75390b2f",
        "previous_commit_hash": "ddb04c3f9bb1fd2b2ba2a14542dbfb48a30f8844",
        "diff_stats": {
            "additions": 6,
            "deletions": 2
        },
        "diff_content": "@@ -35,8 +35,12 @@ public abstract class Modifiable implements HasClassReferences {\n     this.annotations = Lists.newArrayList();\n   }\n \n-  public void addModifiers(Modifier first, Modifier... rest) {\n-    addModifiers(Lists.asList(first, rest));\n+  public void addModifier(Modifier modifier) {\n+    modifiers.add(modifier);\n+  }\n+\n+  public void addModifiers(Modifier first, Modifier second, Modifier... rest) {\n+    addModifiers(Lists.asList(first, second, rest));\n   }\n \n   public void addModifiers(Iterable<Modifier> modifiers) {\n"
    },
    {
        "commit_hash": "d2ce2872d26e7256b0af74189cacea7b75390b2f",
        "previous_commit_hash": "ddb04c3f9bb1fd2b2ba2a14542dbfb48a30f8844",
        "diff_stats": {
            "additions": 13,
            "deletions": 4
        },
        "diff_content": "@@ -55,12 +55,12 @@ public abstract class TypeWriter /* ha ha */ extends Modifiable\n   }\n \n   /**\n-   * Add one or more originating elements for which this type is being generated.\n+   * Add an originating element for which this type is being generated.\n    *\n    * @see JavaWriter#writeTo\n    */\n-  public void addOriginatingElement(Element first, Element... rest) {\n-    addOriginatingElement(Lists.asList(first, rest));\n+  public void addOriginatingElement(Element element) {\n+    originatingElements.add(element);\n   }\n \n   /**\n@@ -68,7 +68,16 @@ public abstract class TypeWriter /* ha ha */ extends Modifiable\n    *\n    * @see JavaWriter#writeTo\n    */\n-  public void addOriginatingElement(Iterable<? extends Element> elements) {\n+  public void addOriginatingElements(Element first, Element second, Element... rest) {\n+    addOriginatingElements(Lists.asList(first, second, rest));\n+  }\n+\n+  /**\n+   * Add originating elements for which this type is being generated.\n+   *\n+   * @see JavaWriter#writeTo\n+   */\n+  public void addOriginatingElements(Iterable<? extends Element> elements) {\n     Iterables.addAll(originatingElements, elements);\n   }\n \n"
    },
    {
        "commit_hash": "d2ce2872d26e7256b0af74189cacea7b75390b2f",
        "previous_commit_hash": "ddb04c3f9bb1fd2b2ba2a14542dbfb48a30f8844",
        "diff_stats": {
            "additions": 4,
            "deletions": 4
        },
        "diff_content": "@@ -38,7 +38,7 @@ import static javax.lang.model.element.Modifier.PUBLIC;\n     AnonymousClassWriter threadWriter = AnonymousClassWriter.forClassName(threadName);\n     MethodWriter threadStartMethod = threadWriter.addMethod(void.class, \"start\");\n     threadStartMethod.annotate(Override.class);\n-    threadStartMethod.addModifiers(PUBLIC);\n+    threadStartMethod.addModifier(PUBLIC);\n     threadStartMethod.body().addSnippet(\"System.out.println(\\\"Hello World!\\\");\");\n \n     threadField.setInitializer(\"%s\", threadWriter);\n@@ -66,7 +66,7 @@ import static javax.lang.model.element.Modifier.PUBLIC;\n     threadWriter.setConstructorArguments(\"runnable\");\n     MethodWriter threadStartMethod = threadWriter.addMethod(void.class, \"start\");\n     threadStartMethod.annotate(Override.class);\n-    threadStartMethod.addModifiers(PUBLIC);\n+    threadStartMethod.addModifier(PUBLIC);\n     threadStartMethod.body().addSnippet(\"System.out.println(\\\"Hello World!\\\");\");\n \n     constructorWriter.body().addSnippet(\"thread = %s;\", threadWriter);\n@@ -99,7 +99,7 @@ import static javax.lang.model.element.Modifier.PUBLIC;\n     threadListField.setInitializer(\"%s.asList(\\\"Hello World\\\")\", ClassName.fromClass(Arrays.class));\n     MethodWriter threadStartMethod = threadWriter.addMethod(void.class, \"start\");\n     threadStartMethod.annotate(Override.class);\n-    threadStartMethod.addModifiers(PUBLIC);\n+    threadStartMethod.addModifier(PUBLIC);\n     threadStartMethod.body().addSnippet(\"System.out.println(list.get(0));\");\n \n     constructorWriter.body().addSnippet(\"thread = %s;\", threadWriter);\n@@ -139,7 +139,7 @@ import static javax.lang.model.element.Modifier.PUBLIC;\n \n     MethodWriter listSizeMethod = listWriter.addMethod(int.class, \"size\");\n     listSizeMethod.annotate(Override.class);\n-    listSizeMethod.addModifiers(PUBLIC);\n+    listSizeMethod.addModifier(PUBLIC);\n     listSizeMethod.body().addSnippet(\"return 1;\");\n \n     listField.setInitializer(\"%s\", listWriter);\n"
    },
    {
        "commit_hash": "d2ce2872d26e7256b0af74189cacea7b75390b2f",
        "previous_commit_hash": "ddb04c3f9bb1fd2b2ba2a14542dbfb48a30f8844",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -69,7 +69,7 @@ public final class EnumWriterTest {\n     valueWriter.addModifiers(Modifier.PUBLIC, Modifier.FINAL);\n \n     ConstructorWriter constructorWriterWriter = enumWriter.addConstructor();\n-    constructorWriterWriter.addModifiers(Modifier.PRIVATE);\n+    constructorWriterWriter.addModifier(Modifier.PRIVATE);\n     constructorWriterWriter.addParameter(String.class, \"value\");\n     constructorWriterWriter.body().addSnippet(\"this.value = value;\");\n \n@@ -94,13 +94,13 @@ public final class EnumWriterTest {\n     EnumWriter.ConstantWriter helloWriter = enumWriter.addConstant(\"HELLO\");\n     MethodWriter helloToStringWriter = helloWriter.addMethod(String.class, \"toString\");\n     helloToStringWriter.annotate(Override.class);\n-    helloToStringWriter.addModifiers(Modifier.PUBLIC);\n+    helloToStringWriter.addModifier(Modifier.PUBLIC);\n     helloToStringWriter.body().addSnippet(\"return \\\"Hello\\\";\");\n \n     EnumWriter.ConstantWriter worldWriter = enumWriter.addConstant(\"WORLD\");\n     MethodWriter worldToStringWriter = worldWriter.addMethod(String.class, \"toString\");\n     worldToStringWriter.annotate(Override.class);\n-    worldToStringWriter.addModifiers(Modifier.PUBLIC);\n+    worldToStringWriter.addModifier(Modifier.PUBLIC);\n     worldToStringWriter.body().addSnippet(\"return \\\"World!\\\";\");\n \n     assertThat(enumWriter.toString()).isEqualTo(\"\"\n"
    },
    {
        "commit_hash": "d2ce2872d26e7256b0af74189cacea7b75390b2f",
        "previous_commit_hash": "ddb04c3f9bb1fd2b2ba2a14542dbfb48a30f8844",
        "diff_stats": {
            "additions": 8,
            "deletions": 9
        },
        "diff_content": "@@ -15,7 +15,6 @@\n  */\n package com.squareup.javawriter;\n \n-import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Iterables;\n import com.google.common.jimfs.Jimfs;\n import java.io.File;\n@@ -99,7 +98,7 @@ public final class JavaWriterTest {\n     ClassName name2 = ClassName.create(\"example\", \"Test2\");\n     ClassWriter test1 = ClassWriter.forClassName(name1);\n     ClassWriter test2 = ClassWriter.forClassName(name2);\n-    javaWriter.addTypeWriter(test1).addTypeWriter(test2).writeTo(fsRoot);\n+    javaWriter.addTypeWriters(test1, test2).writeTo(fsRoot);\n \n     Path testPath1 = fsRoot.resolve(fs.getPath(\"example\", \"Test1.java\"));\n     assertThat(Files.exists(testPath1)).isTrue();\n@@ -112,7 +111,7 @@ public final class JavaWriterTest {\n     ClassName name2 = ClassName.create(\"example\", \"Test2\");\n     ClassWriter test1 = ClassWriter.forClassName(name1);\n     ClassWriter test2 = ClassWriter.forClassName(name2);\n-    javaWriter.addTypeWriter(test1).addTypeWriter(test2).writeTo(tmp.getRoot());\n+    javaWriter.addTypeWriters(test1, test2).writeTo(tmp.getRoot());\n \n     File examplePackage = new File(tmp.getRoot(), \"example\");\n     File testFile1 = new File(examplePackage, \"Test1.java\");\n@@ -126,7 +125,7 @@ public final class JavaWriterTest {\n     ClassName name2 = ClassName.create(\"example\", \"Test2\");\n     ClassWriter test1 = ClassWriter.forClassName(name1);\n     ClassWriter test2 = ClassWriter.forClassName(name2);\n-    javaWriter.addTypeWriter(test1).addTypeWriter(test2).writeTo(filer);\n+    javaWriter.addTypeWriters(test1, test2).writeTo(filer);\n \n     Path testPath1 = fsRoot.resolve(fs.getPath(\"example\", \"Test1.java\"));\n     assertThat(Files.exists(testPath1)).isTrue();\n@@ -141,7 +140,7 @@ public final class JavaWriterTest {\n     ClassWriter foo = ClassWriter.forClassName(fooName);\n     ClassWriter bar = ClassWriter.forClassName(barName);\n     ClassWriter baz = ClassWriter.forClassName(bazName);\n-    javaWriter.addTypeWriters(ImmutableList.of(foo, bar, baz)).writeTo(fsRoot);\n+    javaWriter.addTypeWriters(foo, bar, baz).writeTo(fsRoot);\n \n     Path fooPath = fsRoot.resolve(fs.getPath(\"foo\", \"Test.java\"));\n     Path barPath = fsRoot.resolve(fs.getPath(\"foo\", \"bar\", \"Test.java\"));\n@@ -158,7 +157,7 @@ public final class JavaWriterTest {\n     ClassWriter foo = ClassWriter.forClassName(fooName);\n     ClassWriter bar = ClassWriter.forClassName(barName);\n     ClassWriter baz = ClassWriter.forClassName(bazName);\n-    javaWriter.addTypeWriters(ImmutableList.of(foo, bar, baz)).writeTo(tmp.getRoot());\n+    javaWriter.addTypeWriters(foo, bar, baz).writeTo(tmp.getRoot());\n \n     File fooDir = new File(tmp.getRoot(), \"foo\");\n     File fooFile = new File(fooDir, \"Test.java\");\n@@ -178,7 +177,7 @@ public final class JavaWriterTest {\n     ClassWriter foo = ClassWriter.forClassName(fooName);\n     ClassWriter bar = ClassWriter.forClassName(barName);\n     ClassWriter baz = ClassWriter.forClassName(bazName);\n-    javaWriter.addTypeWriters(ImmutableList.of(foo, bar, baz)).writeTo(filer);\n+    javaWriter.addTypeWriters(foo, bar, baz).writeTo(filer);\n \n     Path fooPath = fsRoot.resolve(fs.getPath(\"foo\", \"Test.java\"));\n     Path barPath = fsRoot.resolve(fs.getPath(\"foo\", \"bar\", \"Test.java\"));\n@@ -198,9 +197,9 @@ public final class JavaWriterTest {\n     ClassWriter test2 = ClassWriter.forClassName(name2);\n     Element element2_1 = Mockito.mock(Element.class);\n     Element element2_2 = Mockito.mock(Element.class);\n-    test2.addOriginatingElement(element2_1, element2_2);\n+    test2.addOriginatingElements(element2_1, element2_2);\n \n-    javaWriter.addTypeWriter(test1).addTypeWriter(test2).writeTo(filer);\n+    javaWriter.addTypeWriters(test1, test2).writeTo(filer);\n \n     Path testPath1 = fsRoot.resolve(fs.getPath(\"example\", \"Test1.java\"));\n     assertThat(filer.getOriginatingElements(testPath1)).containsExactly(element1_1);\n"
    },
    {
        "commit_hash": "d2ce2872d26e7256b0af74189cacea7b75390b2f",
        "previous_commit_hash": "ddb04c3f9bb1fd2b2ba2a14542dbfb48a30f8844",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -84,13 +84,13 @@ public class TypeWriterTest {\n     ClassWriter middle = outer.addNestedClass(\"Middle\");\n     Element middleElement1 = Mockito.mock(Element.class);\n     Element middleElement2 = Mockito.mock(Element.class);\n-    middle.addOriginatingElement(middleElement1, middleElement2);\n+    middle.addOriginatingElements(middleElement1, middleElement2);\n \n     ClassWriter inner = middle.addNestedClass(\"Inner\");\n     Element innerElement1 = Mockito.mock(Element.class);\n     Element innerElement2 = Mockito.mock(Element.class);\n     Element innerElement3 = Mockito.mock(Element.class);\n-    inner.addOriginatingElement(ImmutableList.of(innerElement1, innerElement2, innerElement3));\n+    inner.addOriginatingElements(ImmutableList.of(innerElement1, innerElement2, innerElement3));\n \n     assertThat(outer.originatingElements()).containsExactly(outerElement, middleElement1,\n         middleElement2, innerElement1, innerElement2, innerElement3);\n"
    },
    {
        "commit_hash": "e1f9e71a79b4d7dbc10de42b5a9f7f7f134141fb",
        "previous_commit_hash": "ddb04c3f9bb1fd2b2ba2a14542dbfb48a30f8844",
        "diff_stats": {
            "additions": 23,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,23 @@\n+#!/bin/bash\n+#\n+# Deploy a jar, source jar, and javadoc jar to Sonatype's snapshot repo.\n+#\n+# Adapted from https://coderwall.com/p/9b_lfq and\n+# http://benlimmer.com/2013/12/26/automatically-publish-javadoc-to-gh-pages-with-travis-ci/\n+\n+SLUG=\"square/javawriter\"\n+JDK=\"oraclejdk8\"\n+BRANCH=\"master\"\n+\n+if [ \"$TRAVIS_REPO_SLUG\" != \"$SLUG\" ]; then\n+  echo \"Skipping snapshot deployment: wrong repository. Expected '$SLUG' but was '$TRAVIS_REPO_SLUG'.\"\n+elif [ \"$TRAVIS_JDK_VERSION\" != \"$JDK\" ]; then\n+  echo \"Skipping snapshot deployment: wrong JDK. Expected '$JDK' but was '$TRAVIS_JDK_VERSION'.\"\n+elif [ \"$TRAVIS_PULL_REQUEST\" != \"false\" ]; then\n+  echo \"Skipping snapshot deployment: was pull request.\"\n+elif [ \"$TRAVIS_BRANCH\" != \"$BRANCH\" ]; then\n+  echo \"Skipping snapshot deployment: wrong branch. Expected '$BRANCH' but was '$TRAVIS_BRANCH'.\"\n+else\n+  echo \"Deploying snapshot...\"\n+  mvn clean source:jar javadoc:jar deploy --settings=\".buildscript/settings.xml\" -Dmaven.test.skip=true\n+fi\n"
    },
    {
        "commit_hash": "e1f9e71a79b4d7dbc10de42b5a9f7f7f134141fb",
        "previous_commit_hash": "ddb04c3f9bb1fd2b2ba2a14542dbfb48a30f8844",
        "diff_stats": {
            "additions": 9,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,9 @@\n+<settings>\n+  <servers>\n+    <server>\n+      <id>sonatype-nexus-snapshots</id>\n+      <username>${env.CI_DEPLOY_USERNAME}</username>\n+      <password>${env.CI_DEPLOY_PASSWORD}</password>\n+    </server>\n+  </servers>\n+</settings>\n"
    },
    {
        "commit_hash": "e1f9e71a79b4d7dbc10de42b5a9f7f7f134141fb",
        "previous_commit_hash": "ddb04c3f9bb1fd2b2ba2a14542dbfb48a30f8844",
        "diff_stats": {
            "additions": 14,
            "deletions": 0
        },
        "diff_content": "@@ -4,5 +4,19 @@ jdk:\n   - oraclejdk7\n   - oraclejdk8\n \n+after_success:\n+  - .buildscript/deploy_snapshot.sh\n+\n+env:\n+  global:\n+    - secure: \"nkVNCk8H2orIZOmow0t+Qub1lFQCYpJgNZf17zYI5x0JVqQNCqkcTYYDHqzwkvkmixXFCrfYZQuXy7x2qg9zjCX+vmhlmiMWwe8dNa34OLTseuuR2irS0C8nRGRYxKM7EGenRZSqbFVUksKRm2iWnHKxtmCzeDaS7MoMit2wdUo=\"\n+    - secure: \"j8+hPaZnyM+UlOBYOEA96fPbVWbN6bMQ28SGQnFMwxo2axHi9ww9Au1N7002HzHnxX8iyesdWFBigArnEL8zKEoXH9Bmur0sn3Ys4bu72C3ozscP4cjXfYSHj8aVLp1EIMdQPDF7MkCccx9l7ONdsW0ltmdiVUtDxzqkH+63WLU=\"\n+\n+branches:\n+  except:\n+    - gh-pages\n+\n notifications:\n   email: false\n+\n+sudo: false\n"
    },
    {
        "commit_hash": "e1f9e71a79b4d7dbc10de42b5a9f7f7f134141fb",
        "previous_commit_hash": "ddb04c3f9bb1fd2b2ba2a14542dbfb48a30f8844",
        "diff_stats": {
            "additions": 3,
            "deletions": 0
        },
        "diff_content": "@@ -59,6 +59,8 @@ or Gradle:\n compile 'com.squareup:javawriter:2.5.1'\n ```\n \n+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].\n+\n \n \n License\n@@ -81,3 +83,4 @@ License\n \n \n  [dl]: https://search.maven.org/remote_content?g=com.squareup&a=javawriter&v=LATEST\n+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/\n"
    },
    {
        "commit_hash": "34a98e01b9fb6839aa45040193c02c6a7ca18222",
        "previous_commit_hash": "670e4288a3062cec988a76e4e9ad51ff24026e15",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -155,7 +155,7 @@ final class ClassBodyWriter implements Writable, HasClassReferences {\n     if (!fieldWriters.isEmpty()) {\n       appendable.append('\\n');\n     }\n-    for (VariableWriter fieldWriter : fieldWriters.values()) {\n+    for (FieldWriter fieldWriter : fieldWriters.values()) {\n       fieldWriter.write(new IndentingAppendable(appendable), context).append('\\n');\n     }\n     for (ConstructorWriter constructorWriter : constructorWriters) {\n"
    },
    {
        "commit_hash": "34a98e01b9fb6839aa45040193c02c6a7ca18222",
        "previous_commit_hash": "670e4288a3062cec988a76e4e9ad51ff24026e15",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -64,7 +64,7 @@ public final class ClassWriter extends TypeWriter {\n   @Override\n   public Appendable write(Appendable appendable, Context context) throws IOException {\n     context = createSubcontext(context);\n-    writeAnnotations(appendable, context);\n+    writeAnnotations(appendable, context, '\\n');\n     writeModifiers(appendable).append(\"class \").append(name.simpleName());\n     Writables.Joiner.on(\", \").wrap(\"<\", \"> \").appendTo(appendable, context, typeVariables);\n     if (supertype.isPresent()) {\n"
    },
    {
        "commit_hash": "34a98e01b9fb6839aa45040193c02c6a7ca18222",
        "previous_commit_hash": "670e4288a3062cec988a76e4e9ad51ff24026e15",
        "diff_stats": {
            "additions": 8,
            "deletions": 8
        },
        "diff_content": "@@ -31,7 +31,7 @@ import static com.google.common.base.Preconditions.checkArgument;\n public final class ConstructorWriter extends Modifiable implements Writable {\n   private final List<TypeVariableName> typeVariables;\n   private final String name;\n-  private final Map<String, VariableWriter> parameterWriters;\n+  private final Map<String, ParameterWriter> parameterWriters;\n   private final BlockWriter body;\n \n   ConstructorWriter(String name) {\n@@ -45,20 +45,20 @@ public final class ConstructorWriter extends Modifiable implements Writable {\n     this.typeVariables.add(typeVariable);\n   }\n \n-  public VariableWriter addParameter(Class<?> type, String name) {\n+  public ParameterWriter addParameter(Class<?> type, String name) {\n     return addParameter(TypeNames.forClass(type), name);\n   }\n \n-  public VariableWriter addParameter(TypeElement type, String name) {\n+  public ParameterWriter addParameter(TypeElement type, String name) {\n     return addParameter(ClassName.fromTypeElement(type), name);\n   }\n \n-  public VariableWriter addParameter(TypeWriter type, String name) {\n+  public ParameterWriter addParameter(TypeWriter type, String name) {\n     return addParameter(type.name, name);\n   }\n \n-  public VariableWriter addParameter(TypeName type, String name) {\n-    VariableWriter parameterWriter = new VariableWriter(type, name);\n+  public ParameterWriter addParameter(TypeName type, String name) {\n+    ParameterWriter parameterWriter = new ParameterWriter(type, name);\n     parameterWriters.put(name, parameterWriter);\n     return parameterWriter;\n   }\n@@ -67,9 +67,9 @@ public final class ConstructorWriter extends Modifiable implements Writable {\n     return body;\n   }\n \n-  private VariableWriter addParameter(ClassName type, String name) {\n+  private ParameterWriter addParameter(ClassName type, String name) {\n     checkArgument(!parameterWriters.containsKey(name));\n-    VariableWriter parameterWriter = new VariableWriter(type, name);\n+    ParameterWriter parameterWriter = new ParameterWriter(type, name);\n     parameterWriters.put(name, parameterWriter);\n     return parameterWriter;\n   }\n"
    },
    {
        "commit_hash": "34a98e01b9fb6839aa45040193c02c6a7ca18222",
        "previous_commit_hash": "670e4288a3062cec988a76e4e9ad51ff24026e15",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -57,7 +57,7 @@ public final class EnumWriter extends TypeWriter {\n     checkState(!constantWriters.isEmpty(), \"Cannot write an enum with no constants.\");\n \n     context = createSubcontext(context);\n-    writeAnnotations(appendable, context);\n+    writeAnnotations(appendable, context, '\\n');\n     writeModifiers(appendable).append(\"enum \").append(name.simpleName());\n     Writables.Joiner.on(\", \").prefix(\" implements \")\n         .appendTo(appendable, context, implementedTypes);\n"
    },
    {
        "commit_hash": "34a98e01b9fb6839aa45040193c02c6a7ca18222",
        "previous_commit_hash": "670e4288a3062cec988a76e4e9ad51ff24026e15",
        "diff_stats": {
            "additions": 4,
            "deletions": 1
        },
        "diff_content": "@@ -39,7 +39,10 @@ public final class FieldWriter extends VariableWriter {\n \n   @Override\n   public Appendable write(Appendable appendable, Context context) throws IOException {\n-    super.write(appendable, context);\n+    writeAnnotations(appendable, context, '\\n');\n+    writeModifiers(appendable);\n+    type().write(appendable, context);\n+    appendable.append(' ').append(name());\n     if (initializer.isPresent()) {\n       appendable.append(\" = \");\n       initializer.get().write(appendable, context);\n"
    },
    {
        "commit_hash": "34a98e01b9fb6839aa45040193c02c6a7ca18222",
        "previous_commit_hash": "670e4288a3062cec988a76e4e9ad51ff24026e15",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -44,7 +44,7 @@ public final class InterfaceWriter extends TypeWriter {\n   @Override\n   public Appendable write(Appendable appendable, Context context) throws IOException {\n     context = createSubcontext(context);\n-    writeAnnotations(appendable, context);\n+    writeAnnotations(appendable, context, '\\n');\n     writeModifiers(appendable).append(\"interface \").append(name.simpleName());\n     Writables.Joiner.on(\", \").wrap(\"<\", \"> \").appendTo(appendable, context, typeVariables);\n     Writables.Joiner.on(\", \").prefix(\" extends \").appendTo(appendable, context, implementedTypes);\n"
    },
    {
        "commit_hash": "34a98e01b9fb6839aa45040193c02c6a7ca18222",
        "previous_commit_hash": "670e4288a3062cec988a76e4e9ad51ff24026e15",
        "diff_stats": {
            "additions": 7,
            "deletions": 7
        },
        "diff_content": "@@ -33,7 +33,7 @@ public final class MethodWriter extends Modifiable implements Writable {\n   private final List<TypeVariableName> typeVariables;\n   private final TypeName returnType;\n   private final String name;\n-  private final Map<String, VariableWriter> parameterWriters;\n+  private final Map<String, ParameterWriter> parameterWriters;\n   private final List<ClassName> throwsTypes;\n   private BlockWriter body;\n \n@@ -54,21 +54,21 @@ public final class MethodWriter extends Modifiable implements Writable {\n     this.typeVariables.add(typeVariable);\n   }\n \n-  public VariableWriter addParameter(Class<?> type, String name) {\n+  public ParameterWriter addParameter(Class<?> type, String name) {\n     return addParameter(TypeNames.forClass(type), name);\n   }\n \n-  public VariableWriter addParameter(TypeElement type, String name) {\n+  public ParameterWriter addParameter(TypeElement type, String name) {\n     return addParameter(ClassName.fromTypeElement(type), name);\n   }\n \n-  public VariableWriter addParameter(TypeWriter type, String name) {\n+  public ParameterWriter addParameter(TypeWriter type, String name) {\n     return addParameter(type.name, name);\n   }\n \n-  public VariableWriter addParameter(TypeName type, String name) {\n+  public ParameterWriter addParameter(TypeName type, String name) {\n     checkArgument(!parameterWriters.containsKey(name));\n-    VariableWriter parameterWriter = new VariableWriter(type, name);\n+    ParameterWriter parameterWriter = new ParameterWriter(type, name);\n     parameterWriters.put(name, parameterWriter);\n     return parameterWriter;\n   }\n@@ -87,7 +87,7 @@ public final class MethodWriter extends Modifiable implements Writable {\n \n   @Override\n   public Appendable write(Appendable appendable, Context context) throws IOException {\n-    writeAnnotations(appendable, context);\n+    writeAnnotations(appendable, context, '\\n');\n     writeModifiers(appendable);\n     Writables.Joiner.on(\", \").wrap(\"<\", \"> \").appendTo(appendable, context, typeVariables);\n     returnType.write(appendable, context);\n"
    },
    {
        "commit_hash": "34a98e01b9fb6839aa45040193c02c6a7ca18222",
        "previous_commit_hash": "670e4288a3062cec988a76e4e9ad51ff24026e15",
        "diff_stats": {
            "additions": 3,
            "deletions": 2
        },
        "diff_content": "@@ -64,9 +64,10 @@ public abstract class Modifiable implements HasClassReferences {\n     return appendable;\n   }\n \n-  Appendable writeAnnotations(Appendable appendable, Context context) throws IOException {\n+  Appendable writeAnnotations(Appendable appendable, Context context, char separator)\n+      throws IOException {\n     for (AnnotationWriter annotationWriter : annotations) {\n-      annotationWriter.write(appendable, context).append('\\n');\n+      annotationWriter.write(appendable, context).append(separator);\n     }\n     return appendable;\n   }\n"
    },
    {
        "commit_hash": "34a98e01b9fb6839aa45040193c02c6a7ca18222",
        "previous_commit_hash": "670e4288a3062cec988a76e4e9ad51ff24026e15",
        "diff_stats": {
            "additions": 32,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,32 @@\n+/*\n+ * Copyright (C) 2014 Google, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter;\n+\n+import java.io.IOException;\n+\n+public final class ParameterWriter extends VariableWriter {\n+  ParameterWriter(TypeName type, String name) {\n+    super(type, name);\n+  }\n+\n+  @Override\n+  public Appendable write(Appendable appendable, Context context) throws IOException {\n+    writeAnnotations(appendable, context, ' ');\n+    writeModifiers(appendable);\n+    type().write(appendable, context);\n+    return appendable.append(' ').append(name());\n+  }\n+}\n"
    },
    {
        "commit_hash": "34a98e01b9fb6839aa45040193c02c6a7ca18222",
        "previous_commit_hash": "670e4288a3062cec988a76e4e9ad51ff24026e15",
        "diff_stats": {
            "additions": 3,
            "deletions": 11
        },
        "diff_content": "@@ -16,14 +16,13 @@\n package com.squareup.javawriter;\n \n import com.google.common.collect.FluentIterable;\n-import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Iterables;\n-import java.io.IOException;\n import java.util.Set;\n \n import static com.google.common.base.Preconditions.checkNotNull;\n \n-public class VariableWriter extends Modifiable implements Writable {\n+public abstract class VariableWriter extends Modifiable implements Writable {\n   private final TypeName type;\n   private final String name;\n \n@@ -40,17 +39,10 @@ public class VariableWriter extends Modifiable implements Writable {\n     return name;\n   }\n \n-  @Override\n-  public Appendable write(Appendable appendable, Context context) throws IOException {\n-    writeModifiers(appendable);\n-    type.write(appendable, context);\n-    return appendable.append(' ').append(name);\n-  }\n-\n   @Override\n   public Set<ClassName> referencedClasses() {\n     Iterable<? extends HasClassReferences> concat =\n-        Iterables.concat(super.referencedClasses(), ImmutableSet.of(type));\n+        Iterables.concat(super.referencedClasses(), ImmutableList.of(type));\n     return FluentIterable.from(concat)\n         .transformAndConcat(GET_REFERENCED_CLASSES)\n         .toSet();\n"
    },
    {
        "commit_hash": "34a98e01b9fb6839aa45040193c02c6a7ca18222",
        "previous_commit_hash": "670e4288a3062cec988a76e4e9ad51ff24026e15",
        "diff_stats": {
            "additions": 48,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright (C) 2014 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+/**\n+ * ParameterWriter only differs from FieldWriter in the format of its annotations.\n+ */\n+@RunWith(JUnit4.class)\n+public final class ParameterWriterTest {\n+  @Test public void simple() {\n+    ClassName runnable = ClassName.fromClass(Runnable.class);\n+    ParameterWriter parameterWriter = new ParameterWriter(runnable, \"runnable\");\n+\n+    assertThat(Writables.writeToString(parameterWriter))\n+        .isEqualTo(\"java.lang.Runnable runnable\");\n+  }\n+\n+  @Test public void annotated() {\n+    ClassName notNull = ClassName.create(\"example\", \"NotNull\");\n+    ClassName redacted = ClassName.create(\"example\", \"Redacted\");\n+    ClassName runnable = ClassName.fromClass(Runnable.class);\n+    ParameterWriter parameterWriter = new ParameterWriter(runnable, \"runnable\");\n+    parameterWriter.annotate(notNull);\n+    parameterWriter.annotate(redacted);\n+\n+    assertThat(Writables.writeToString(parameterWriter))\n+        .isEqualTo(\"@example.NotNull @example.Redacted java.lang.Runnable runnable\");\n+  }\n+}\n"
    },
    {
        "commit_hash": "6084001459971c480e08fae7d1b05be4616c20f8",
        "previous_commit_hash": "422f4ef41a218ceb239a781e7d909ab58b4238f2",
        "diff_stats": {
            "additions": 4,
            "deletions": 0
        },
        "diff_content": "@@ -20,3 +20,7 @@ notifications:\n   email: false\n \n sudo: false\n+\n+cache:\n+  directories:\n+    - $HOME/.m2\n"
    },
    {
        "commit_hash": "d50ee868715be902cade9d56c658d1357f31331d",
        "previous_commit_hash": "fae2776a01e1ee283d873315ca735d91f4b14807",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -20,4 +20,5 @@ elif [ \"$TRAVIS_BRANCH\" != \"$BRANCH\" ]; then\n else\n   echo \"Deploying snapshot...\"\n   mvn clean source:jar javadoc:jar deploy --settings=\".buildscript/settings.xml\" -Dmaven.test.skip=true\n+  echo \"Snapshot deployed!\"\n fi\n"
    },
    {
        "commit_hash": "0e9f07e7520cb43fc9071650ac1f9a2d7673b27c",
        "previous_commit_hash": "d50ee868715be902cade9d56c658d1357f31331d",
        "diff_stats": {
            "additions": 2,
            "deletions": 0
        },
        "diff_content": "@@ -9,6 +9,8 @@ SLUG=\"square/javawriter\"\n JDK=\"oraclejdk8\"\n BRANCH=\"master\"\n \n+set -e\n+\n if [ \"$TRAVIS_REPO_SLUG\" != \"$SLUG\" ]; then\n   echo \"Skipping snapshot deployment: wrong repository. Expected '$SLUG' but was '$TRAVIS_REPO_SLUG'.\"\n elif [ \"$TRAVIS_JDK_VERSION\" != \"$JDK\" ]; then\n"
    },
    {
        "commit_hash": "a1a9eec91b5a9ca8da1f0c855624198946feeb53",
        "previous_commit_hash": "0e9f07e7520cb43fc9071650ac1f9a2d7673b27c",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -163,7 +163,7 @@ public final class ClassName implements TypeName, Comparable<ClassName> {\n     Class<?> current = clazz.getEnclosingClass();\n     while (current != null) {\n       enclosingNames.add(current.getSimpleName());\n-      current = clazz.getEnclosingClass();\n+      current = current.getEnclosingClass();\n     }\n     Collections.reverse(enclosingNames);\n     return create(clazz.getPackage().getName(), enclosingNames, clazz.getSimpleName());\n"
    },
    {
        "commit_hash": "a1a9eec91b5a9ca8da1f0c855624198946feeb53",
        "previous_commit_hash": "0e9f07e7520cb43fc9071650ac1f9a2d7673b27c",
        "diff_stats": {
            "additions": 7,
            "deletions": 0
        },
        "diff_content": "@@ -81,6 +81,13 @@ public class ClassNameTest {\n     assert_().that(ClassName.fromTypeElement(element).canonicalName())\n         .isEqualTo(\"java.lang.Object\");\n   }\n+  \n+  @Test public void classNameFromClass() {\n+    assert_().that(ClassName.fromClass(Object.class).canonicalName())\n+        .isEqualTo(\"java.lang.Object\");\n+    assert_().that(ClassName.fromClass(OuterClass.InnerClass.class).canonicalName())\n+        .isEqualTo(\"com.squareup.javawriter.ClassNameTest.OuterClass.InnerClass\");\n+  }\n \n   @Test public void peerNamed_topLevelClass() {\n     Elements elements = compilationRule.getElements();\n"
    },
    {
        "commit_hash": "d7b2189e9e91cad8f2fec9b5d5dd3b85ef6ce6b9",
        "previous_commit_hash": "12b3d2a3b4ddf036b5f2fced0d23b381909ee382",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -83,7 +83,7 @@\n     <module name=\"AvoidNestedBlocks\"/>\n     <!--module name=\"EmptyBlock\"/-->\n     <module name=\"LeftCurly\"/>\n-    <module name=\"NeedBraces\"/>\n+    <!--<module name=\"NeedBraces\"/>-->\n     <module name=\"RightCurly\"/>\n \n \n"
    },
    {
        "commit_hash": "d7b2189e9e91cad8f2fec9b5d5dd3b85ef6ce6b9",
        "previous_commit_hash": "12b3d2a3b4ddf036b5f2fced0d23b381909ee382",
        "diff_stats": {
            "additions": 168,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright (C) 2015 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter.builders;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSortedMap;\n+import com.squareup.javawriter.ClassName;\n+import com.squareup.javawriter.StringLiteral;\n+import com.squareup.javawriter.TypeName;\n+import com.squareup.javawriter.TypeNames;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+/**\n+ * Converts a {@link JavaFile} to a string suitable to both human- and javac-consumption. This\n+ * honors imports, indentation, and deferred variable names.\n+ */\n+class CodeWriter {\n+  private final String indent = \"  \";\n+  private final StringBuilder out;\n+  private final ImmutableMap<ClassName, String> importedTypes;\n+  private final LinkedHashSet<TypeName> emittedTypes = new LinkedHashSet<>();\n+  private final List<TypeName> visibleTypes = new ArrayList<>();\n+  private int indentLevel;\n+\n+  public CodeWriter(StringBuilder out, ImmutableMap<ClassName, String> importedTypes) {\n+    this.out = checkNotNull(out);\n+    this.importedTypes = checkNotNull(importedTypes);\n+  }\n+\n+  public CodeWriter indent() {\n+    indentLevel++;\n+    return this;\n+  }\n+\n+  public CodeWriter unindent() {\n+    checkState(indentLevel > 0);\n+    indentLevel--;\n+    return this;\n+  }\n+\n+  public CodeWriter pushVisibleType(TypeName typeName) {\n+    visibleTypes.add(typeName);\n+    return this;\n+  }\n+\n+  public CodeWriter popVisibleType(TypeName typeName) {\n+    checkState(visibleTypes.remove(typeName));\n+    return this;\n+  }\n+\n+  public CodeWriter emit(String format, Object... args) {\n+    return emit(new Snippet(format, args));\n+  }\n+\n+  public CodeWriter emit(Snippet snippet) {\n+    int a = 0;\n+    for (String part : snippet.formatParts) {\n+      switch (part) {\n+        case \"$L\":\n+          emitAndIndent(String.valueOf(snippet.args.get(a++)));\n+          break;\n+\n+        case \"$S\":\n+          String arg = String.valueOf(snippet.args.get(a++));\n+          emitAndIndent(StringLiteral.forValue(arg).literal());\n+          break;\n+\n+        case \"$T\":\n+          emitType(snippet.args.get(a++));\n+          break;\n+\n+        case \"$$\":\n+          emitAndIndent(\"$\");\n+          break;\n+\n+        default:\n+          emitAndIndent(part);\n+          break;\n+      }\n+    }\n+    return this;\n+  }\n+\n+  private void emitType(Object arg) {\n+    TypeName typeName = toTypeName(arg);\n+    emittedTypes.add(typeName);\n+\n+    String shortName = !visibleTypes.contains(typeName)\n+        ? importedTypes.get(typeName)\n+        : null;\n+\n+    emitAndIndent(shortName != null ? shortName : typeName.toString());\n+  }\n+\n+  /** Emits {@code s} with indentation as required. */\n+  private void emitAndIndent(String s) {\n+    boolean first = true;\n+    for (String line : s.split(\"\\n\", -1)) {\n+      if (!first) out.append('\\n');\n+      first = false;\n+      if (line.isEmpty()) continue; // Don't indent empty lines.\n+      emitIndentationIfNecessary();\n+      out.append(line);\n+    }\n+  }\n+\n+  private void emitIndentationIfNecessary() {\n+    // Only emit indentation immediately after a '\\n' character.\n+    if (out.length() <= 0 || out.charAt(out.length() - 1) != '\\n') return;\n+\n+    for (int j = 0; j < indentLevel; j++) {\n+      out.append(indent);\n+    }\n+  }\n+\n+  private TypeName toTypeName(Object arg) {\n+    if (arg instanceof TypeName) return (TypeName) arg;\n+    if (arg instanceof Class<?>) return TypeNames.forClass((Class<?>) arg);\n+    throw new IllegalArgumentException(\"Expected type but was \" + arg);\n+  }\n+\n+  /**\n+   * Returns the types that should have been imported for this code. If there were any simple name\n+   * collisions, that type's first use is imported.\n+   */\n+  ImmutableMap<ClassName, String> suggestedImports() {\n+    // Find the simple names that can be imported, and the classes that they target.\n+    Map<String, ClassName> simpleNameToType = new LinkedHashMap<>();\n+    for (TypeName typeName : emittedTypes) {\n+      if (!(typeName instanceof ClassName)) continue;\n+      ClassName className = (ClassName) typeName;\n+      if (simpleNameToType.containsKey(className.simpleName())) continue;\n+      simpleNameToType.put(className.simpleName(), className);\n+    }\n+\n+    // Invert the map.\n+    ImmutableSortedMap.Builder<ClassName, String> typeToSimpleName\n+        = ImmutableSortedMap.naturalOrder();\n+    for (Map.Entry<String, ClassName> entry : simpleNameToType.entrySet()) {\n+      typeToSimpleName.put(entry.getValue(), entry.getKey());\n+    }\n+\n+    // TODO(jwilson): omit imports from java.lang, unless their simple names is also present in the\n+    //     current class's package. (Yuck.)\n+\n+    return typeToSimpleName.build();\n+  }\n+}\n"
    },
    {
        "commit_hash": "d7b2189e9e91cad8f2fec9b5d5dd3b85ef6ce6b9",
        "previous_commit_hash": "12b3d2a3b4ddf036b5f2fced0d23b381909ee382",
        "diff_stats": {
            "additions": 58,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,58 @@\n+/*\n+ * Copyright (C) 2015 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter.builders;\n+\n+import com.squareup.javawriter.TypeName;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+/** A generated field declaration. */\n+public final class FieldSpec {\n+  public final TypeName type;\n+  public final Name name;\n+  public final Snippet initializer;\n+\n+  private FieldSpec(Builder builder) {\n+    this.type = checkNotNull(builder.type);\n+    this.name = checkNotNull(builder.name);\n+    this.initializer = checkNotNull(builder.initializer);\n+  }\n+\n+  public static final class Builder {\n+    private TypeName type;\n+    private Name name;\n+    private Snippet initializer;\n+\n+    public Builder type(TypeName type) {\n+      this.type = type;\n+      return this;\n+    }\n+\n+    public Builder name(Name name) {\n+      this.name = name;\n+      return this;\n+    }\n+\n+    public Builder initializer(String format, Object... args) {\n+      this.initializer = new Snippet(format, args);\n+      return this;\n+    }\n+\n+    public FieldSpec build() {\n+      return new FieldSpec(this);\n+    }\n+  }\n+}\n"
    },
    {
        "commit_hash": "d7b2189e9e91cad8f2fec9b5d5dd3b85ef6ce6b9",
        "previous_commit_hash": "12b3d2a3b4ddf036b5f2fced0d23b381909ee382",
        "diff_stats": {
            "additions": 70,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright (C) 2015 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter.builders;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.squareup.javawriter.ClassName;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+/** A Java file containing a single top level class. */\n+public final class JavaFile {\n+  public final TypeSpec typeSpec;\n+\n+  private JavaFile(Builder builder) {\n+    this.typeSpec = checkNotNull(builder.typeSpec);\n+  }\n+\n+  public String toString() {\n+    // First pass: emit the entire class, just to collect the types we'll need to import.\n+    ImmutableMap<ClassName, String> noImports = ImmutableMap.of();\n+    CodeWriter importsCollector = new CodeWriter(new StringBuilder(), noImports);\n+    emit(noImports, importsCollector);\n+    ImmutableMap<ClassName, String> suggestedImports = importsCollector.suggestedImports();\n+\n+    // Second pass: Write the code, taking advantage of the imports.\n+    StringBuilder result = new StringBuilder();\n+    CodeWriter codeWriter = new CodeWriter(result, suggestedImports);\n+    emit(suggestedImports, codeWriter);\n+    return result.toString();\n+  }\n+\n+  private void emit(ImmutableMap<ClassName, String> imports, CodeWriter codeWriter) {\n+    codeWriter.emit(\"package $L;\\n\", typeSpec.name.packageName());\n+    codeWriter.emit(\"\\n\");\n+    for (ClassName className : imports.keySet()) {\n+      codeWriter.emit(\"import $L;\\n\", className);\n+    }\n+    codeWriter.emit(\"\\n\");\n+    typeSpec.emit(codeWriter);\n+  }\n+\n+  public static final class Builder {\n+    private TypeSpec typeSpec;\n+\n+    public Builder classSpec(TypeSpec typeSpec) {\n+      checkArgument(!typeSpec.name.enclosingClassName().isPresent(),\n+          \"Cannot create a JavaFile for %s\", typeSpec.name);\n+      this.typeSpec = typeSpec;\n+      return this;\n+    }\n+\n+    public JavaFile build() {\n+      return new JavaFile(this);\n+    }\n+  }\n+}\n"
    },
    {
        "commit_hash": "d7b2189e9e91cad8f2fec9b5d5dd3b85ef6ce6b9",
        "previous_commit_hash": "12b3d2a3b4ddf036b5f2fced0d23b381909ee382",
        "diff_stats": {
            "additions": 121,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright (C) 2015 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter.builders;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.squareup.javawriter.ClassName;\n+import com.squareup.javawriter.TypeName;\n+import com.squareup.javawriter.VoidName;\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import javax.lang.model.element.Modifier;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+/** A generated method declaration. */\n+public final class MethodSpec {\n+  public final Name name;\n+  public final ImmutableList<ClassName> annotations;\n+  public final ImmutableList<ParameterSpec> parameters;\n+  public final ImmutableSet<Modifier> modifiers;\n+  public final TypeName returnType;\n+  public final ImmutableList<Snippet> snippets;\n+\n+  private MethodSpec(Builder builder) {\n+    this.name = checkNotNull(builder.name);\n+    this.annotations = ImmutableList.copyOf(builder.annotations);\n+    this.parameters = ImmutableList.copyOf(builder.parameters);\n+    this.modifiers = ImmutableSet.copyOf(builder.modifiers);\n+    this.returnType = builder.returnType;\n+    this.snippets = ImmutableList.copyOf(builder.snippets);\n+  }\n+\n+  void emit(CodeWriter codeWriter) {\n+    codeWriter.emit(\"$T $L(\", returnType, name); // TODO(jwilson): modifiers.\n+\n+    boolean firstParameter = true;\n+    for (ParameterSpec parameterSpec : parameters) {\n+      if (!firstParameter) codeWriter.emit(\", \");\n+      codeWriter.emit(\"$T $L\", parameterSpec.type, parameterSpec.name);\n+      firstParameter = false;\n+    }\n+    codeWriter.emit(\") {\\n\");\n+\n+    codeWriter.indent();\n+    for (Snippet snippet : snippets) {\n+      codeWriter.emit(snippet);\n+    }\n+    codeWriter.unindent();\n+\n+    codeWriter.emit(\"}\\n\");\n+  }\n+\n+  public static final class Builder {\n+    private Name name;\n+    private List<ClassName> annotations = new ArrayList<>();\n+    private List<ParameterSpec> parameters = new ArrayList<>();\n+    private List<Modifier> modifiers = new ArrayList<>();\n+    private TypeName returnType = VoidName.VOID;\n+    private List<Snippet> snippets = new ArrayList<>();\n+\n+    public Builder name(String name) {\n+      this.name = new Name(name);\n+      return this;\n+    }\n+\n+    public Builder name(Name name) {\n+      this.name = name;\n+      return this;\n+    }\n+\n+    public Builder addAnnotation(Class<? extends Annotation> annotation) {\n+      this.annotations.add(ClassName.fromClass(annotation));\n+      return this;\n+    }\n+\n+    public Builder addParameter(ParameterSpec parameterSpec) {\n+      this.parameters.add(parameterSpec);\n+      return this;\n+    }\n+\n+    public Builder addParameter(Class<?> type, String name) {\n+      this.parameters.add(new ParameterSpec.Builder().type(type).name(name).build());\n+      return this;\n+    }\n+\n+    public Builder addModifiers(Modifier... modifiers) {\n+      this.modifiers.addAll(Arrays.asList(modifiers));\n+      return this;\n+    }\n+\n+    public Builder returns(Class<?> returnType) {\n+      this.returnType = ClassName.fromClass(returnType);\n+      return this;\n+    }\n+\n+    public Builder addCode(String format, Object... args) {\n+      snippets.add(new Snippet(format, args));\n+      return this;\n+    }\n+\n+    public MethodSpec build() {\n+      return new MethodSpec(this);\n+    }\n+  }\n+}\n"
    },
    {
        "commit_hash": "d7b2189e9e91cad8f2fec9b5d5dd3b85ef6ce6b9",
        "previous_commit_hash": "12b3d2a3b4ddf036b5f2fced0d23b381909ee382",
        "diff_stats": {
            "additions": 36,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,36 @@\n+/*\n+ * Copyright (C) 2015 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter.builders;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+/**\n+ * A member name. If necessary, the seed name will be mangled to cope with keyword collision and\n+ * name collision. For example, given the seed name {@code public}, the generated code may use\n+ * {@code public_} or {@code public1}.\n+ */\n+public final class Name {\n+  public final String seed;\n+\n+  public Name(String seed) {\n+    this.seed = checkNotNull(seed);\n+  }\n+\n+  @Override public String toString() {\n+    // TODO(jwilson): implement deferred naming so that `new Name(\"public\")` yields \"public_\" etc.\n+    return seed;\n+  }\n+}\n"
    },
    {
        "commit_hash": "d7b2189e9e91cad8f2fec9b5d5dd3b85ef6ce6b9",
        "previous_commit_hash": "12b3d2a3b4ddf036b5f2fced0d23b381909ee382",
        "diff_stats": {
            "additions": 61,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright (C) 2015 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter.builders;\n+\n+import com.squareup.javawriter.TypeName;\n+import com.squareup.javawriter.TypeNames;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+/** A generated parameter declaration. */\n+public final class ParameterSpec {\n+  public final TypeName type;\n+  public final Name name;\n+\n+  private ParameterSpec(Builder builder) {\n+    this.type = checkNotNull(builder.type);\n+    this.name = checkNotNull(builder.name);\n+  }\n+\n+  public static final class Builder {\n+    private TypeName type;\n+    private Name name;\n+\n+    public Builder type(TypeName type) {\n+      this.type = type;\n+      return this;\n+    }\n+\n+    public Builder type(Class<?> type) {\n+      this.type = TypeNames.forClass(type);\n+      return this;\n+    }\n+\n+    public Builder name(String name) {\n+      this.name = new Name(name);\n+      return this;\n+    }\n+\n+    public Builder name(Name name) {\n+      this.name = name;\n+      return this;\n+    }\n+\n+    public ParameterSpec build() {\n+      return new ParameterSpec(this);\n+    }\n+  }\n+}\n"
    },
    {
        "commit_hash": "d7b2189e9e91cad8f2fec9b5d5dd3b85ef6ce6b9",
        "previous_commit_hash": "12b3d2a3b4ddf036b5f2fced0d23b381909ee382",
        "diff_stats": {
            "additions": 73,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright (C) 2015 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter.builders;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+/**\n+ * A deferred format string. Unlike {@link java.text.Format} which uses percent {@code %} to escape\n+ * placeholders, this uses {@code $}, and has its own set of permitted placeholders:\n+ *\n+ * <ul>\n+ *   <li>{@code $L} emits the <em>literal</em> value with no escaping.\n+ *   <li>{@code $S} escapes the value as a <em>string</em>, wraps it with double quotes, and emits\n+ *       that.\n+ *   <li>{@code $T} emits a <em>type</em> reference. Types will be imported if possible.\n+ *   <li>{@code $$} emits a dollar sign.\n+ * </ul>\n+ */\n+final class Snippet {\n+  /** A heterogeneous list containing string literals and value placeholders. */\n+  final ImmutableList<String> formatParts;\n+  final ImmutableList<Object> args;\n+\n+  public Snippet(String format, Object[] args) {\n+    ImmutableList.Builder<String> formatPartsBuilder = ImmutableList.builder();\n+    int expectedArgsLength = 0;\n+    for (int p = 0, nextP; p < format.length(); p = nextP) {\n+      if (format.charAt(p) != '$') {\n+        nextP = format.indexOf('$', p + 1);\n+        if (nextP == -1) nextP = format.length();\n+      } else {\n+        checkState(p + 1 < format.length(), \"dangling $ in format string %s\", format);\n+        switch (format.charAt(p + 1)) {\n+          case 'L':\n+          case 'S':\n+          case 'T':\n+            expectedArgsLength++;\n+            // Fall through.\n+          case '$':\n+            nextP = p + 2;\n+            break;\n+\n+          default:\n+            throw new IllegalArgumentException(\"invalid format string: \" + format);\n+        }\n+      }\n+\n+      formatPartsBuilder.add(format.substring(p, nextP));\n+    }\n+\n+    checkArgument(args.length == expectedArgsLength,\n+        \"expected %s args but was %s\", expectedArgsLength, args);\n+\n+    this.formatParts = formatPartsBuilder.build();\n+    this.args = ImmutableList.copyOf(args);\n+  }\n+}\n"
    },
    {
        "commit_hash": "d7b2189e9e91cad8f2fec9b5d5dd3b85ef6ce6b9",
        "previous_commit_hash": "12b3d2a3b4ddf036b5f2fced0d23b381909ee382",
        "diff_stats": {
            "additions": 80,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,80 @@\n+/*\n+ * Copyright (C) 2015 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter.builders;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.squareup.javawriter.ClassName;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+/** A generated class, interface, or enum declaration. */\n+public final class TypeSpec {\n+  public final Type type;\n+  public final ClassName name;\n+  public final ImmutableList<MethodSpec> methodSpecs;\n+\n+  private TypeSpec(Builder builder) {\n+    this.type = checkNotNull(builder.type);\n+    this.name = checkNotNull(builder.name);\n+    this.methodSpecs = ImmutableList.copyOf(builder.methodSpecs);\n+  }\n+\n+  void emit(CodeWriter codeWriter) {\n+    codeWriter.emit(\"class $L {\\n\", name.simpleName()); // TODO(jwilson): modifiers.\n+    codeWriter.indent();\n+\n+    boolean firstMethod = true;\n+    for (MethodSpec methodSpec : methodSpecs) {\n+      if (!firstMethod) codeWriter.emit(\"\\n\");\n+      methodSpec.emit(codeWriter);\n+      firstMethod = false;\n+    }\n+\n+    codeWriter.unindent();\n+    codeWriter.emit(\"}\\n\");\n+  }\n+\n+  public static enum Type {\n+    CLASS, INTERFACE, ENUM\n+  }\n+\n+  public static final class Builder {\n+    private Type type = Type.CLASS;\n+    private ClassName name;\n+    private List<MethodSpec> methodSpecs = new ArrayList<>();\n+\n+    public Builder type(Type type) {\n+      this.type = type;\n+      return this;\n+    }\n+\n+    public Builder name(ClassName name) {\n+      this.name = name;\n+      return this;\n+    }\n+\n+    public Builder addMethod(MethodSpec methodSpec) {\n+      methodSpecs.add(methodSpec);\n+      return this;\n+    }\n+\n+    public TypeSpec build() {\n+      return new TypeSpec(this);\n+    }\n+  }\n+}\n"
    },
    {
        "commit_hash": "d7b2189e9e91cad8f2fec9b5d5dd3b85ef6ce6b9",
        "previous_commit_hash": "12b3d2a3b4ddf036b5f2fced0d23b381909ee382",
        "diff_stats": {
            "additions": 58,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,58 @@\n+/*\n+ * Copyright (C) 2015 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter.builders;\n+\n+import com.squareup.javawriter.ClassName;\n+import javax.lang.model.element.Modifier;\n+import org.junit.Test;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+public class TypeSpecTest {\n+  @Test public void test() throws Exception {\n+    TypeSpec taco = new TypeSpec.Builder()\n+        .name(ClassName.create(\"com.squareup.tacos\", \"Taco\"))\n+        .addMethod(new MethodSpec.Builder()\n+            .name(\"toString\")\n+            .addAnnotation(Override.class)\n+            .addModifiers(Modifier.PUBLIC, Modifier.FINAL)\n+            .returns(String.class)\n+            .addCode(\"return $S;\\n\", \"taco\")\n+            .build())\n+        .build();\n+\n+    // TODO: fix modifiers\n+    // TODO: fix annotations\n+\n+    assertThat(toString(taco)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import java.lang.String;\\n\"\n+        + \"\\n\"\n+        + \"class Taco {\\n\"\n+        + \"  String toString() {\\n\"\n+        + \"    return \\\"taco\\\";\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  private String toString(TypeSpec typeSpec) {\n+    return new JavaFile.Builder()\n+        .classSpec(typeSpec)\n+        .build()\n+        .toString();\n+  }\n+}\n"
    },
    {
        "commit_hash": "25f6c0021ad9b67a0695cbd5d406fa57caca00aa",
        "previous_commit_hash": "12b3d2a3b4ddf036b5f2fced0d23b381909ee382",
        "diff_stats": {
            "additions": 9,
            "deletions": 0
        },
        "diff_content": "@@ -18,15 +18,24 @@ package com.squareup.javawriter;\n import java.io.IOException;\n \n public final class ParameterWriter extends VariableWriter {\n+  private boolean varargs;\n+\n   ParameterWriter(TypeName type, String name) {\n     super(type, name);\n   }\n \n+  public void setVarargs(boolean varargs) {\n+    this.varargs = varargs;\n+  }\n+\n   @Override\n   public Appendable write(Appendable appendable, Context context) throws IOException {\n     writeAnnotations(appendable, context, ' ');\n     writeModifiers(appendable);\n     type().write(appendable, context);\n+    if (varargs) {\n+      appendable.append(\"...\");\n+    }\n     return appendable.append(' ').append(name());\n   }\n }\n"
    },
    {
        "commit_hash": "25f6c0021ad9b67a0695cbd5d406fa57caca00aa",
        "previous_commit_hash": "12b3d2a3b4ddf036b5f2fced0d23b381909ee382",
        "diff_stats": {
            "additions": 10,
            "deletions": 1
        },
        "diff_content": "@@ -22,7 +22,7 @@ import org.junit.runners.JUnit4;\n import static com.google.common.truth.Truth.assertThat;\n \n /**\n- * ParameterWriter only differs from FieldWriter in the format of its annotations.\n+ * ParameterWriter differs from FieldWriter in the format of its annotations and varargs support.\n  */\n @RunWith(JUnit4.class)\n public final class ParameterWriterTest {\n@@ -45,4 +45,13 @@ public final class ParameterWriterTest {\n     assertThat(Writables.writeToString(parameterWriter))\n         .isEqualTo(\"@example.NotNull @example.Redacted java.lang.Runnable runnable\");\n   }\n+\n+  @Test public void varargs() {\n+    ClassName runnable = ClassName.fromClass(Runnable.class);\n+    ParameterWriter parameterWriter = new ParameterWriter(runnable, \"runnable\");\n+    parameterWriter.setVarargs(true);\n+\n+    assertThat(Writables.writeToString(parameterWriter))\n+        .isEqualTo(\"java.lang.Runnable... runnable\");\n+  }\n }\n"
    },
    {
        "commit_hash": "f9948bae9742e28a100b150ee7d12c75e1ce9eaf",
        "previous_commit_hash": "21a955d166aacbcaa2f969b12c54778cca9172ca",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -97,7 +97,7 @@\n     <!--module name=\"HiddenField\"/-->\n     <module name=\"IllegalInstantiation\"/>\n     <module name=\"InnerAssignment\"/>\n-    <module name=\"MagicNumber\"/>\n+    <!--<module name=\"MagicNumber\"/>-->\n     <module name=\"MissingSwitchDefault\"/>\n     <module name=\"RedundantThrows\"/>\n     <module name=\"SimplifyBooleanExpression\"/>\n"
    },
    {
        "commit_hash": "f9948bae9742e28a100b150ee7d12c75e1ce9eaf",
        "previous_commit_hash": "21a955d166aacbcaa2f969b12c54778cca9172ca",
        "diff_stats": {
            "additions": 8,
            "deletions": 0
        },
        "diff_content": "@@ -33,6 +33,14 @@ public final class ParameterizedTypeName implements TypeName {\n     this.parameters = ImmutableList.copyOf(parameters);\n   }\n \n+  public ClassName type() {\n+    return type;\n+  }\n+\n+  public ImmutableList<? extends TypeName> parameters() {\n+    return parameters;\n+  }\n+\n   @Override\n   public Set<ClassName> referencedClasses() {\n     return FluentIterable.from(parameters)\n"
    },
    {
        "commit_hash": "f9948bae9742e28a100b150ee7d12c75e1ce9eaf",
        "previous_commit_hash": "21a955d166aacbcaa2f969b12c54778cca9172ca",
        "diff_stats": {
            "additions": 8,
            "deletions": 0
        },
        "diff_content": "@@ -34,6 +34,14 @@ public final class WildcardName implements TypeName {\n     this.superBound = superBound;\n   }\n \n+  public TypeName extendsBound() {\n+    return extendsBound.orNull();\n+  }\n+\n+  public TypeName superBound() {\n+    return superBound.orNull();\n+  }\n+\n   static WildcardName forTypeMirror(WildcardType mirror) {\n     return new WildcardName(\n         Optional.fromNullable(mirror.getExtendsBound()).transform(FOR_TYPE_MIRROR),\n"
    },
    {
        "commit_hash": "f9948bae9742e28a100b150ee7d12c75e1ce9eaf",
        "previous_commit_hash": "21a955d166aacbcaa2f969b12c54778cca9172ca",
        "diff_stats": {
            "additions": 108,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright (C) 2015 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter.builders;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.ImmutableSortedMap;\n+import com.google.common.collect.Maps;\n+import com.squareup.javawriter.ClassName;\n+import java.lang.annotation.Annotation;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.SortedMap;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+\n+/** A generated annotation on a declaration. */\n+public final class AnnotationSpec {\n+  public final ClassName type;\n+  public final ImmutableSortedMap<String, Snippet> members;\n+\n+  private AnnotationSpec(Builder builder) {\n+    this.type = checkNotNull(builder.type);\n+    this.members = ImmutableSortedMap.copyOf(builder.members);\n+  }\n+\n+  void emit(CodeWriter codeWriter, boolean inline) {\n+    String separator = inline ? \"\" : \"\\n\";\n+    String suffix = inline ? \" \" : \"\\n\";\n+    if (members.isEmpty()) {\n+      // @Singleton\n+      codeWriter.emit(\"@$T$L\", type, suffix);\n+    } else if (members.keySet().equals(ImmutableSet.of(\"value\"))) {\n+      // @Named(\"foo\")\n+      codeWriter.emit(\"@$T(\");\n+      codeWriter.emit(getOnlyElement(members.values()));\n+      codeWriter.emit(\")$L\", suffix);\n+    } else {\n+      // Inline:\n+      //   @Column(name = \"updated_at\", nullable = false)\n+      //\n+      // Not inline:\n+      //   @Column(\n+      //       name = \"updated_at\",\n+      //       nullable = false\n+      //   )\n+      codeWriter.emit(\"@$T($L\", type, separator);\n+      codeWriter.indent();\n+      codeWriter.indent();\n+      for (Iterator<Map.Entry<String, Snippet>> i = members.entrySet().iterator(); i.hasNext();) {\n+        Map.Entry<String, Snippet> entry = i.next();\n+        codeWriter.emit(\"$L = \", entry.getKey());\n+        codeWriter.emit(entry.getValue());\n+        if (i.hasNext()) codeWriter.emit(\",\");\n+        codeWriter.emit(\"$L\", separator);\n+      }\n+      codeWriter.unindent();\n+      codeWriter.unindent();\n+      codeWriter.emit(\")$L\", suffix);\n+    }\n+  }\n+\n+  public static AnnotationSpec of(Class<? extends Annotation> annotation) {\n+    return new Builder().type(ClassName.fromClass(annotation)).build();\n+  }\n+\n+  @Override public boolean equals(Object o) {\n+    return o instanceof AnnotationSpec\n+        && ((AnnotationSpec) o).type.equals(type)\n+        && ((AnnotationSpec) o).members.equals(members);\n+  }\n+\n+  @Override public int hashCode() {\n+    return type.hashCode() + 37 * members.hashCode();\n+  }\n+\n+  public static final class Builder {\n+    private ClassName type;\n+    private final SortedMap<String, Snippet> members = Maps.newTreeMap();\n+\n+    public Builder type(ClassName type) {\n+      this.type = type;\n+      return this;\n+    }\n+\n+    public Builder addMember(String name, String format, Object... args) {\n+      members.put(name, new Snippet(format, args));\n+      return this;\n+    }\n+\n+    public AnnotationSpec build() {\n+      return new AnnotationSpec(this);\n+    }\n+  }\n+}\n"
    },
    {
        "commit_hash": "f9948bae9742e28a100b150ee7d12c75e1ce9eaf",
        "previous_commit_hash": "21a955d166aacbcaa2f969b12c54778cca9172ca",
        "diff_stats": {
            "additions": 81,
            "deletions": 7
        },
        "diff_content": "@@ -15,17 +15,24 @@\n  */\n package com.squareup.javawriter.builders;\n \n+import com.google.common.base.Ascii;\n+import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.ImmutableSortedMap;\n import com.squareup.javawriter.ClassName;\n+import com.squareup.javawriter.ParameterizedTypeName;\n import com.squareup.javawriter.StringLiteral;\n import com.squareup.javawriter.TypeName;\n import com.squareup.javawriter.TypeNames;\n+import com.squareup.javawriter.WildcardName;\n import java.util.ArrayList;\n+import java.util.EnumSet;\n import java.util.LinkedHashMap;\n import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n+import javax.lang.model.element.Modifier;\n \n import static com.google.common.base.Preconditions.checkNotNull;\n import static com.google.common.base.Preconditions.checkState;\n@@ -34,7 +41,7 @@ import static com.google.common.base.Preconditions.checkState;\n  * Converts a {@link JavaFile} to a string suitable to both human- and javac-consumption. This\n  * honors imports, indentation, and deferred variable names.\n  */\n-class CodeWriter {\n+final class CodeWriter {\n   private final String indent = \"  \";\n   private final StringBuilder out;\n   private final ImmutableMap<ClassName, String> importedTypes;\n@@ -68,6 +75,21 @@ class CodeWriter {\n     return this;\n   }\n \n+  public void emitAnnotations(ImmutableList<AnnotationSpec> annotations, boolean inline) {\n+    for (AnnotationSpec annotationSpec : annotations) {\n+      annotationSpec.emit(this, inline);\n+    }\n+  }\n+\n+  public void emitModifiers(ImmutableSet<Modifier> modifiers) {\n+    if (!modifiers.isEmpty()) {\n+      for (Modifier modifier : EnumSet.copyOf(modifiers)) {\n+        emitAndIndent(Ascii.toLowerCase(modifier.name()));\n+        emitAndIndent(\" \");\n+      }\n+    }\n+  }\n+\n   public CodeWriter emit(String format, Object... args) {\n     return emit(new Snippet(format, args));\n   }\n@@ -77,7 +99,11 @@ class CodeWriter {\n     for (String part : snippet.formatParts) {\n       switch (part) {\n         case \"$L\":\n-          emitAndIndent(String.valueOf(snippet.args.get(a++)));\n+          emitLiteral(snippet.args.get(a++));\n+          break;\n+\n+        case \"$N\":\n+          emitName(snippet.args.get(a++));\n           break;\n \n         case \"$S\":\n@@ -101,15 +127,49 @@ class CodeWriter {\n     return this;\n   }\n \n+  private void emitLiteral(Object o) {\n+    if (o instanceof TypeSpec) {\n+      TypeSpec typeSpec = (TypeSpec) o;\n+      typeSpec.emit(this);\n+    } else {\n+      emitAndIndent(String.valueOf(o));\n+    }\n+  }\n+\n   private void emitType(Object arg) {\n     TypeName typeName = toTypeName(arg);\n     emittedTypes.add(typeName);\n \n-    String shortName = !visibleTypes.contains(typeName)\n-        ? importedTypes.get(typeName)\n-        : null;\n-\n-    emitAndIndent(shortName != null ? shortName : typeName.toString());\n+    // TODO(jwilson): replace instanceof nonsense with polymorphism!\n+    if (typeName instanceof ParameterizedTypeName) {\n+      ParameterizedTypeName parameterizedTypeName = (ParameterizedTypeName) typeName;\n+      emitType(parameterizedTypeName.type());\n+      emitAndIndent(\"<\");\n+      boolean firstParameter = true;\n+      for (TypeName parameter : parameterizedTypeName.parameters()) {\n+        if (!firstParameter) emitAndIndent(\", \");\n+        emitType(parameter);\n+        firstParameter = false;\n+      }\n+      emitAndIndent(\">\");\n+    } else if (typeName instanceof WildcardName) {\n+      WildcardName wildcardName = (WildcardName) typeName;\n+      TypeName extendsBound = wildcardName.extendsBound();\n+      TypeName superBound = wildcardName.superBound();\n+      if (ClassName.fromClass(Object.class).equals(extendsBound)) {\n+        emit(\"?\");\n+      } else if (extendsBound != null) {\n+        emit(\"? extends $T\", extendsBound);\n+      } else if (superBound != null) {\n+        emit(\"? super $T\", superBound);\n+      }\n+      // TODO(jwilson): special case ? for List<?>.\n+    } else {\n+      String shortName = !visibleTypes.contains(typeName)\n+          ? importedTypes.get(typeName)\n+          : null;\n+      emitAndIndent(shortName != null ? shortName : typeName.toString());\n+    }\n   }\n \n   /** Emits {@code s} with indentation as required. */\n@@ -139,6 +199,20 @@ class CodeWriter {\n     throw new IllegalArgumentException(\"Expected type but was \" + arg);\n   }\n \n+  private void emitName(Object o) {\n+    emitAndIndent(toName(o));\n+  }\n+\n+  private String toName(Object o) {\n+    // TODO(jwilson): implement deferred naming so that `new Name(\"public\")` yields \"public_\" etc.\n+    if (o instanceof String) return (String) o;\n+    if (o instanceof Name) return ((Name) o).seed;\n+    if (o instanceof ParameterSpec) return ((ParameterSpec) o).name.seed;\n+    if (o instanceof FieldSpec) return ((FieldSpec) o).name.seed;\n+    if (o instanceof MethodSpec) return ((MethodSpec) o).name.seed;\n+    throw new IllegalArgumentException(\"Expected name but was \" + o);\n+  }\n+\n   /**\n    * Returns the types that should have been imported for this code. If there were any simple name\n    * collisions, that type's first use is imported.\n"
    },
    {
        "commit_hash": "f9948bae9742e28a100b150ee7d12c75e1ce9eaf",
        "previous_commit_hash": "21a955d166aacbcaa2f969b12c54778cca9172ca",
        "diff_stats": {
            "additions": 44,
            "deletions": 1
        },
        "diff_content": "@@ -15,27 +15,66 @@\n  */\n package com.squareup.javawriter.builders;\n \n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n import com.squareup.javawriter.TypeName;\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import javax.lang.model.element.Modifier;\n \n import static com.google.common.base.Preconditions.checkNotNull;\n \n /** A generated field declaration. */\n public final class FieldSpec {\n+  public final ImmutableList<AnnotationSpec> annotations;\n+  public final ImmutableSet<Modifier> modifiers;\n   public final TypeName type;\n   public final Name name;\n   public final Snippet initializer;\n \n   private FieldSpec(Builder builder) {\n+    this.annotations = ImmutableList.copyOf(builder.annotations);\n+    this.modifiers = ImmutableSet.copyOf(builder.modifiers);\n     this.type = checkNotNull(builder.type);\n     this.name = checkNotNull(builder.name);\n-    this.initializer = checkNotNull(builder.initializer);\n+    this.initializer = builder.initializer;\n+  }\n+\n+  void emit(CodeWriter codeWriter) {\n+    codeWriter.emitAnnotations(annotations, false);\n+    codeWriter.emitModifiers(modifiers);\n+    codeWriter.emit(\"$T $L\", type, name);\n+    if (initializer != null) {\n+      codeWriter.emit(\" = \");\n+      codeWriter.emit(initializer);\n+    }\n+    codeWriter.emit(\";\\n\");\n   }\n \n   public static final class Builder {\n+    private final List<AnnotationSpec> annotations = new ArrayList<>();\n+    private final List<Modifier> modifiers = new ArrayList<>();\n     private TypeName type;\n     private Name name;\n     private Snippet initializer;\n \n+    public Builder addAnnotation(AnnotationSpec annotationSpec) {\n+      this.annotations.add(annotationSpec);\n+      return this;\n+    }\n+\n+    public Builder addAnnotation(Class<? extends Annotation> annotation) {\n+      this.annotations.add(AnnotationSpec.of(annotation));\n+      return this;\n+    }\n+\n+    public Builder addModifiers(Modifier... modifiers) {\n+      Collections.addAll(this.modifiers, modifiers);\n+      return this;\n+    }\n+\n     public Builder type(TypeName type) {\n       this.type = type;\n       return this;\n@@ -46,6 +85,10 @@ public final class FieldSpec {\n       return this;\n     }\n \n+    public Builder name(String name) {\n+      return name(new Name(name));\n+    }\n+\n     public Builder initializer(String format, Object... args) {\n       this.initializer = new Snippet(format, args);\n       return this;\n"
    },
    {
        "commit_hash": "f9948bae9742e28a100b150ee7d12c75e1ce9eaf",
        "previous_commit_hash": "21a955d166aacbcaa2f969b12c54778cca9172ca",
        "diff_stats": {
            "additions": 42,
            "deletions": 28
        },
        "diff_content": "@@ -17,12 +17,12 @@ package com.squareup.javawriter.builders;\n \n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n-import com.squareup.javawriter.ClassName;\n import com.squareup.javawriter.TypeName;\n+import com.squareup.javawriter.TypeNames;\n import com.squareup.javawriter.VoidName;\n import java.lang.annotation.Annotation;\n import java.util.ArrayList;\n-import java.util.Arrays;\n+import java.util.Collections;\n import java.util.List;\n import javax.lang.model.element.Modifier;\n \n@@ -30,29 +30,31 @@ import static com.google.common.base.Preconditions.checkNotNull;\n \n /** A generated method declaration. */\n public final class MethodSpec {\n-  public final Name name;\n-  public final ImmutableList<ClassName> annotations;\n-  public final ImmutableList<ParameterSpec> parameters;\n+  public final ImmutableList<AnnotationSpec> annotations;\n   public final ImmutableSet<Modifier> modifiers;\n   public final TypeName returnType;\n+  public final Name name;\n+  public final ImmutableList<ParameterSpec> parameters;\n   public final ImmutableList<Snippet> snippets;\n \n   private MethodSpec(Builder builder) {\n-    this.name = checkNotNull(builder.name);\n     this.annotations = ImmutableList.copyOf(builder.annotations);\n-    this.parameters = ImmutableList.copyOf(builder.parameters);\n     this.modifiers = ImmutableSet.copyOf(builder.modifiers);\n     this.returnType = builder.returnType;\n+    this.name = checkNotNull(builder.name);\n+    this.parameters = ImmutableList.copyOf(builder.parameters);\n     this.snippets = ImmutableList.copyOf(builder.snippets);\n   }\n \n   void emit(CodeWriter codeWriter) {\n-    codeWriter.emit(\"$T $L(\", returnType, name); // TODO(jwilson): modifiers.\n+    codeWriter.emitAnnotations(annotations, false);\n+    codeWriter.emitModifiers(modifiers);\n+    codeWriter.emit(\"$T $L(\", returnType, name);\n \n     boolean firstParameter = true;\n     for (ParameterSpec parameterSpec : parameters) {\n       if (!firstParameter) codeWriter.emit(\", \");\n-      codeWriter.emit(\"$T $L\", parameterSpec.type, parameterSpec.name);\n+      parameterSpec.emit(codeWriter);\n       firstParameter = false;\n     }\n     codeWriter.emit(\") {\\n\");\n@@ -67,48 +69,60 @@ public final class MethodSpec {\n   }\n \n   public static final class Builder {\n-    private Name name;\n-    private List<ClassName> annotations = new ArrayList<>();\n-    private List<ParameterSpec> parameters = new ArrayList<>();\n-    private List<Modifier> modifiers = new ArrayList<>();\n+    private final List<AnnotationSpec> annotations = new ArrayList<>();\n+    private final List<Modifier> modifiers = new ArrayList<>();\n     private TypeName returnType = VoidName.VOID;\n-    private List<Snippet> snippets = new ArrayList<>();\n+    private Name name;\n+    private final List<ParameterSpec> parameters = new ArrayList<>();\n+    private final List<Snippet> snippets = new ArrayList<>();\n \n-    public Builder name(String name) {\n-      this.name = new Name(name);\n+    public Builder addAnnotation(AnnotationSpec annotationSpec) {\n+      this.annotations.add(annotationSpec);\n       return this;\n     }\n \n-    public Builder name(Name name) {\n-      this.name = name;\n+    public Builder addAnnotation(Class<? extends Annotation> annotation) {\n+      this.annotations.add(AnnotationSpec.of(annotation));\n       return this;\n     }\n \n-    public Builder addAnnotation(Class<? extends Annotation> annotation) {\n-      this.annotations.add(ClassName.fromClass(annotation));\n+    public Builder addModifiers(Modifier... modifiers) {\n+      Collections.addAll(this.modifiers, modifiers);\n       return this;\n     }\n \n-    public Builder addParameter(ParameterSpec parameterSpec) {\n-      this.parameters.add(parameterSpec);\n+    public Builder returns(Class<?> returnType) {\n+      return returns(TypeNames.forClass(returnType));\n+    }\n+\n+    public Builder returns(TypeName returnType) {\n+      this.returnType = returnType;\n       return this;\n     }\n \n-    public Builder addParameter(Class<?> type, String name) {\n-      this.parameters.add(new ParameterSpec.Builder().type(type).name(name).build());\n+    public Builder name(String name) {\n+      this.name = new Name(name);\n       return this;\n     }\n \n-    public Builder addModifiers(Modifier... modifiers) {\n-      this.modifiers.addAll(Arrays.asList(modifiers));\n+    public Builder name(Name name) {\n+      this.name = name;\n       return this;\n     }\n \n-    public Builder returns(Class<?> returnType) {\n-      this.returnType = ClassName.fromClass(returnType);\n+    public Builder addParameter(ParameterSpec parameterSpec) {\n+      this.parameters.add(parameterSpec);\n       return this;\n     }\n \n+    public Builder addParameter(Class<?> type, String name) {\n+      return addParameter(new ParameterSpec.Builder().type(type).name(name).build());\n+    }\n+\n+    public Builder addParameter(TypeName type, String name) {\n+      return addParameter(new ParameterSpec.Builder().type(type).name(name).build());\n+    }\n+\n     public Builder addCode(String format, Object... args) {\n       snippets.add(new Snippet(format, args));\n       return this;\n"
    },
    {
        "commit_hash": "f9948bae9742e28a100b150ee7d12c75e1ce9eaf",
        "previous_commit_hash": "21a955d166aacbcaa2f969b12c54778cca9172ca",
        "diff_stats": {
            "additions": 0,
            "deletions": 1
        },
        "diff_content": "@@ -30,7 +30,6 @@ public final class Name {\n   }\n \n   @Override public String toString() {\n-    // TODO(jwilson): implement deferred naming so that `new Name(\"public\")` yields \"public_\" etc.\n     return seed;\n   }\n }\n"
    },
    {
        "commit_hash": "f9948bae9742e28a100b150ee7d12c75e1ce9eaf",
        "previous_commit_hash": "21a955d166aacbcaa2f969b12c54778cca9172ca",
        "diff_stats": {
            "additions": 34,
            "deletions": 0
        },
        "diff_content": "@@ -15,25 +15,59 @@\n  */\n package com.squareup.javawriter.builders;\n \n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n import com.squareup.javawriter.TypeName;\n import com.squareup.javawriter.TypeNames;\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import javax.lang.model.element.Modifier;\n \n import static com.google.common.base.Preconditions.checkNotNull;\n \n /** A generated parameter declaration. */\n public final class ParameterSpec {\n+  public final ImmutableList<AnnotationSpec> annotations;\n+  public final ImmutableSet<Modifier> modifiers;\n   public final TypeName type;\n   public final Name name;\n \n   private ParameterSpec(Builder builder) {\n+    this.annotations = ImmutableList.copyOf(builder.annotations);\n+    this.modifiers = ImmutableSet.copyOf(builder.modifiers);\n     this.type = checkNotNull(builder.type);\n     this.name = checkNotNull(builder.name);\n   }\n \n+  void emit(CodeWriter codeWriter) {\n+    codeWriter.emitAnnotations(annotations, true);\n+    codeWriter.emitModifiers(modifiers);\n+    codeWriter.emit(\"$T $L\", type, name);\n+  }\n+\n   public static final class Builder {\n+    private final List<AnnotationSpec> annotations = new ArrayList<>();\n+    private final List<Modifier> modifiers = new ArrayList<>();\n     private TypeName type;\n     private Name name;\n \n+    public Builder addAnnotation(AnnotationSpec annotationSpec) {\n+      this.annotations.add(annotationSpec);\n+      return this;\n+    }\n+\n+    public Builder addAnnotation(Class<? extends Annotation> annotation) {\n+      this.annotations.add(AnnotationSpec.of(annotation));\n+      return this;\n+    }\n+\n+    public Builder addModifiers(Modifier... modifiers) {\n+      Collections.addAll(this.modifiers, modifiers);\n+      return this;\n+    }\n+\n     public Builder type(TypeName type) {\n       this.type = type;\n       return this;\n"
    },
    {
        "commit_hash": "f9948bae9742e28a100b150ee7d12c75e1ce9eaf",
        "previous_commit_hash": "21a955d166aacbcaa2f969b12c54778cca9172ca",
        "diff_stats": {
            "additions": 2,
            "deletions": 0
        },
        "diff_content": "@@ -26,6 +26,7 @@ import static com.google.common.base.Preconditions.checkState;\n  *\n  * <ul>\n  *   <li>{@code $L} emits the <em>literal</em> value with no escaping.\n+ *   <li>{@code $N} emits a <em>name</em>, using name collision avoidance where necessary.\n  *   <li>{@code $S} escapes the value as a <em>string</em>, wraps it with double quotes, and emits\n  *       that.\n  *   <li>{@code $T} emits a <em>type</em> reference. Types will be imported if possible.\n@@ -48,6 +49,7 @@ final class Snippet {\n         checkState(p + 1 < format.length(), \"dangling $ in format string %s\", format);\n         switch (format.charAt(p + 1)) {\n           case 'L':\n+          case 'N':\n           case 'S':\n           case 'T':\n             expectedArgsLength++;\n"
    },
    {
        "commit_hash": "f9948bae9742e28a100b150ee7d12c75e1ce9eaf",
        "previous_commit_hash": "21a955d166aacbcaa2f969b12c54778cca9172ca",
        "diff_stats": {
            "additions": 73,
            "deletions": 6
        },
        "diff_content": "@@ -16,37 +16,69 @@\n package com.squareup.javawriter.builders;\n \n import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n import com.squareup.javawriter.ClassName;\n+import com.squareup.javawriter.TypeName;\n+import java.lang.annotation.Annotation;\n import java.util.ArrayList;\n+import java.util.Collections;\n import java.util.List;\n+import javax.lang.model.element.Modifier;\n \n+import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkNotNull;\n \n /** A generated class, interface, or enum declaration. */\n public final class TypeSpec {\n+  public final ImmutableList<AnnotationSpec> annotations;\n+  public final ImmutableSet<Modifier> modifiers;\n   public final Type type;\n   public final ClassName name;\n+  public final TypeName supertype;\n+  public final Snippet anonymousTypeArguments;\n+  public final ImmutableList<FieldSpec> fieldSpecs;\n   public final ImmutableList<MethodSpec> methodSpecs;\n \n   private TypeSpec(Builder builder) {\n+    checkArgument(builder.name != null ^ builder.anonymousTypeArguments != null,\n+        \"types must have either a name or anonymous type arguments\");\n+    this.annotations = ImmutableList.copyOf(builder.annotations);\n+    this.modifiers = ImmutableSet.copyOf(builder.modifiers);\n     this.type = checkNotNull(builder.type);\n-    this.name = checkNotNull(builder.name);\n+    this.name = builder.name;\n+    this.supertype = builder.supertype;\n+    this.anonymousTypeArguments = builder.anonymousTypeArguments;\n+    this.fieldSpecs = ImmutableList.copyOf(builder.fieldSpecs);\n     this.methodSpecs = ImmutableList.copyOf(builder.methodSpecs);\n   }\n \n   void emit(CodeWriter codeWriter) {\n-    codeWriter.emit(\"class $L {\\n\", name.simpleName()); // TODO(jwilson): modifiers.\n+    if (anonymousTypeArguments != null) {\n+      codeWriter.emit(\"new $T(\", supertype);\n+      codeWriter.emit(anonymousTypeArguments);\n+      codeWriter.emit(\") {\\n\");\n+    } else {\n+      codeWriter.emitAnnotations(annotations, false);\n+      codeWriter.emitModifiers(modifiers);\n+      codeWriter.emit(\"class $L {\\n\", name.simpleName());\n+    }\n+\n     codeWriter.indent();\n \n-    boolean firstMethod = true;\n+    boolean firstMember = true;\n+    for (FieldSpec fieldSpec : fieldSpecs) {\n+      if (!firstMember) codeWriter.emit(\"\\n\");\n+      fieldSpec.emit(codeWriter);\n+      firstMember = false;\n+    }\n     for (MethodSpec methodSpec : methodSpecs) {\n-      if (!firstMethod) codeWriter.emit(\"\\n\");\n+      if (!firstMember) codeWriter.emit(\"\\n\");\n       methodSpec.emit(codeWriter);\n-      firstMethod = false;\n+      firstMember = false;\n     }\n \n     codeWriter.unindent();\n-    codeWriter.emit(\"}\\n\");\n+    codeWriter.emit(anonymousTypeArguments != null ? \"}\" : \"}\\n\");\n   }\n \n   public static enum Type {\n@@ -54,10 +86,30 @@ public final class TypeSpec {\n   }\n \n   public static final class Builder {\n+    private final List<AnnotationSpec> annotations = new ArrayList<>();\n+    private final List<Modifier> modifiers = new ArrayList<>();\n     private Type type = Type.CLASS;\n     private ClassName name;\n+    private TypeName supertype = ClassName.fromClass(Object.class);\n+    private Snippet anonymousTypeArguments;\n+    private List<FieldSpec> fieldSpecs = new ArrayList<>();\n     private List<MethodSpec> methodSpecs = new ArrayList<>();\n \n+    public Builder addAnnotation(AnnotationSpec annotationSpec) {\n+      this.annotations.add(annotationSpec);\n+      return this;\n+    }\n+\n+    public Builder addAnnotation(Class<? extends Annotation> annotation) {\n+      this.annotations.add(AnnotationSpec.of(annotation));\n+      return this;\n+    }\n+\n+    public Builder addModifiers(Modifier... modifiers) {\n+      Collections.addAll(this.modifiers, modifiers);\n+      return this;\n+    }\n+\n     public Builder type(Type type) {\n       this.type = type;\n       return this;\n@@ -68,11 +120,26 @@ public final class TypeSpec {\n       return this;\n     }\n \n+    public Builder supertype(TypeName supertype) {\n+      this.supertype = supertype;\n+      return this;\n+    }\n+\n+    public Builder anonymousTypeArguments(String format, Object... args) {\n+      this.anonymousTypeArguments = new Snippet(format, args);\n+      return this;\n+    }\n+\n     public Builder addMethod(MethodSpec methodSpec) {\n       methodSpecs.add(methodSpec);\n       return this;\n     }\n \n+    public Builder addField(FieldSpec fieldSpec) {\n+      fieldSpecs.add(fieldSpec);\n+      return this;\n+    }\n+\n     public TypeSpec build() {\n       return new TypeSpec(this);\n     }\n"
    },
    {
        "commit_hash": "f9948bae9742e28a100b150ee7d12c75e1ce9eaf",
        "previous_commit_hash": "21a955d166aacbcaa2f969b12c54778cca9172ca",
        "diff_stats": {
            "additions": 124,
            "deletions": 6
        },
        "diff_content": "@@ -15,14 +15,20 @@\n  */\n package com.squareup.javawriter.builders;\n \n+import com.google.common.collect.ImmutableList;\n import com.squareup.javawriter.ClassName;\n+import com.squareup.javawriter.ParameterizedTypeName;\n+import com.squareup.javawriter.WildcardName;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.List;\n import javax.lang.model.element.Modifier;\n import org.junit.Test;\n \n import static com.google.common.truth.Truth.assertThat;\n \n public class TypeSpecTest {\n-  @Test public void test() throws Exception {\n+  @Test public void basic() throws Exception {\n     TypeSpec taco = new TypeSpec.Builder()\n         .name(ClassName.create(\"com.squareup.tacos\", \"Taco\"))\n         .addMethod(new MethodSpec.Builder()\n@@ -33,22 +39,134 @@ public class TypeSpecTest {\n             .addCode(\"return $S;\\n\", \"taco\")\n             .build())\n         .build();\n-\n-    // TODO: fix modifiers\n-    // TODO: fix annotations\n-\n     assertThat(toString(taco)).isEqualTo(\"\"\n         + \"package com.squareup.tacos;\\n\"\n         + \"\\n\"\n+        + \"import java.lang.Override;\\n\"\n         + \"import java.lang.String;\\n\"\n         + \"\\n\"\n         + \"class Taco {\\n\"\n-        + \"  String toString() {\\n\"\n+        + \"  @Override\\n\"\n+        + \"  public final String toString() {\\n\"\n         + \"    return \\\"taco\\\";\\n\"\n         + \"  }\\n\"\n         + \"}\\n\");\n   }\n \n+  @Test public void interestingTypes() throws Exception {\n+    TypeSpec taco = new TypeSpec.Builder()\n+        .name(ClassName.create(\"com.squareup.tacos\", \"Taco\"))\n+        .addField(new FieldSpec.Builder()\n+            .type(ParameterizedTypeName.create(ClassName.fromClass(List.class),\n+                WildcardName.createWithUpperBound(ClassName.fromClass(Object.class))))\n+            .name(\"extendsObject\")\n+            .build())\n+        .addField(new FieldSpec.Builder()\n+            .type(ParameterizedTypeName.create(ClassName.fromClass(List.class),\n+                WildcardName.createWithUpperBound(ClassName.fromClass(Serializable.class))))\n+            .name(\"extendsSerializable\")\n+            .build())\n+        .addField(new FieldSpec.Builder()\n+            .type(ParameterizedTypeName.create(ClassName.fromClass(List.class),\n+                WildcardName.createWithLowerBound(ClassName.fromClass(String.class))))\n+            .name(\"superString\")\n+            .build())\n+        .build();\n+    assertThat(toString(taco)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import java.io.Serializable;\\n\"\n+        + \"import java.lang.String;\\n\"\n+        + \"import java.util.List;\\n\"\n+        + \"\\n\"\n+        + \"class Taco {\\n\"\n+        + \"  List<?> extendsObject;\\n\"\n+        + \"\\n\"\n+        + \"  List<? extends Serializable> extendsSerializable;\\n\"\n+        + \"\\n\"\n+        + \"  List<? super String> superString;\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void anonymousInnerClass() throws Exception {\n+    ClassName foo = ClassName.create(\"com.squareup.tacos\", \"Foo\");\n+    ClassName bar = ClassName.create(\"com.squareup.tacos\", \"Bar\");\n+    ClassName thingThang = ClassName.create(\n+        \"com.squareup.tacos\", ImmutableList.of(\"Thing\"), \"Thang\");\n+    ParameterizedTypeName thingThangOfFooBar\n+        = ParameterizedTypeName.create(thingThang, foo, bar);\n+    ClassName thung = ClassName.create(\"com.squareup.tacos\", \"Thung\");\n+    ClassName simpleThung = ClassName.create(\"com.squareup.tacos\", \"SimpleThung\");\n+    ParameterizedTypeName thungOfSuperBar\n+        = ParameterizedTypeName.create(thung, WildcardName.createWithLowerBound(bar));\n+    ParameterizedTypeName thungOfSuperFoo\n+        = ParameterizedTypeName.create(thung, WildcardName.createWithLowerBound(foo));\n+    ParameterizedTypeName simpleThungOfBar = ParameterizedTypeName.create(simpleThung, bar);\n+\n+    ParameterSpec thungParameter = new ParameterSpec.Builder()\n+        .addModifiers(Modifier.FINAL)\n+        .type(thungOfSuperFoo)\n+        .name(\"thung\")\n+        .build();\n+    TypeSpec aSimpleThung = new TypeSpec.Builder()\n+        .supertype(simpleThungOfBar)\n+        .anonymousTypeArguments(\"$N\", thungParameter)\n+        .addMethod(new MethodSpec.Builder()\n+            .addAnnotation(Override.class)\n+            .addModifiers(Modifier.PUBLIC)\n+            .name(\"doSomething\")\n+            .addParameter(bar, \"bar\")\n+            .addCode(\"/* code snippets */\\n\")\n+            .build())\n+        .build();\n+    TypeSpec aThingThang = new TypeSpec.Builder()\n+        .supertype(thingThangOfFooBar)\n+        .anonymousTypeArguments(\"\")\n+        .addMethod(new MethodSpec.Builder()\n+            .addAnnotation(Override.class)\n+            .addModifiers(Modifier.PUBLIC)\n+            .returns(thungOfSuperBar)\n+            .name(\"call\")\n+            .addParameter(thungParameter)\n+            .addCode(\"return $L;\\n\", aSimpleThung)\n+            .build())\n+        .build();\n+    TypeSpec taco = new TypeSpec.Builder()\n+        .name(ClassName.create(\"com.squareup.tacos\", \"Taco\"))\n+        .addField(new FieldSpec.Builder()\n+            .addModifiers(Modifier.STATIC, Modifier.FINAL)\n+            .type(thingThangOfFooBar)\n+            .name(\"NAME\")\n+            .initializer(\"$L\", aThingThang)\n+            .build())\n+        .build();\n+\n+    // TODO: import Thing, and change references from \"Thang\" to \"Thing.Thang\"\n+    assertThat(toString(taco)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import com.squareup.tacos.Bar;\\n\"\n+        + \"import com.squareup.tacos.Foo;\\n\"\n+        + \"import com.squareup.tacos.SimpleThung;\\n\"\n+        + \"import com.squareup.tacos.Thing.Thang;\\n\"\n+        + \"import com.squareup.tacos.Thung;\\n\"\n+        + \"import java.lang.Override;\\n\"\n+        + \"\\n\"\n+        + \"class Taco {\\n\"\n+        + \"  static final Thang<Foo, Bar> NAME = new Thang<Foo, Bar>() {\\n\"\n+        + \"    @Override\\n\"\n+        + \"    public Thung<? super Bar> call(final Thung<? super Foo> thung) {\\n\"\n+        + \"      return new SimpleThung<Bar>(thung) {\\n\"\n+        + \"        @Override\\n\"\n+        + \"        public void doSomething(Bar bar) {\\n\"\n+        + \"          /* code snippets */\\n\"\n+        + \"        }\\n\"\n+        + \"      };\\n\"\n+        + \"    }\\n\"\n+        + \"  };\\n\"\n+        + \"}\\n\");\n+  }\n+\n   private String toString(TypeSpec typeSpec) {\n     return new JavaFile.Builder()\n         .classSpec(typeSpec)\n"
    },
    {
        "commit_hash": "d88f2b669cd0588b4726f57c5b5b446aa1f7ff2e",
        "previous_commit_hash": "7005ef49cb72e659a6f58f6dd29e24b1a57fad9a",
        "diff_stats": {
            "additions": 11,
            "deletions": 7
        },
        "diff_content": "@@ -33,7 +33,7 @@ public final class AnnotationSpec {\n   public final ImmutableSortedMap<String, Snippet> members;\n \n   private AnnotationSpec(Builder builder) {\n-    this.type = checkNotNull(builder.type);\n+    this.type = checkNotNull(builder.type, \"type\");\n     this.members = ImmutableSortedMap.copyOf(builder.members);\n   }\n \n@@ -45,8 +45,10 @@ public final class AnnotationSpec {\n       codeWriter.emit(\"@$T$L\", type, suffix);\n     } else if (members.keySet().equals(ImmutableSet.of(\"value\"))) {\n       // @Named(\"foo\")\n-      codeWriter.emit(\"@$T(\");\n+      codeWriter.emit(\"@$T(\", type);\n+      codeWriter.indent(2);\n       codeWriter.emit(getOnlyElement(members.values()));\n+      codeWriter.unindent(2);\n       codeWriter.emit(\")$L\", suffix);\n     } else {\n       // Inline:\n@@ -58,8 +60,7 @@ public final class AnnotationSpec {\n       //       nullable = false\n       //   )\n       codeWriter.emit(\"@$T($L\", type, separator);\n-      codeWriter.indent();\n-      codeWriter.indent();\n+      codeWriter.indent(2);\n       for (Iterator<Map.Entry<String, Snippet>> i = members.entrySet().iterator(); i.hasNext();) {\n         Map.Entry<String, Snippet> entry = i.next();\n         codeWriter.emit(\"$L = \", entry.getKey());\n@@ -67,14 +68,17 @@ public final class AnnotationSpec {\n         if (i.hasNext()) codeWriter.emit(\",\");\n         codeWriter.emit(\"$L\", separator);\n       }\n-      codeWriter.unindent();\n-      codeWriter.unindent();\n+      codeWriter.unindent(2);\n       codeWriter.emit(\")$L\", suffix);\n     }\n   }\n \n   public static AnnotationSpec of(Class<? extends Annotation> annotation) {\n-    return new Builder().type(ClassName.fromClass(annotation)).build();\n+    return of(ClassName.fromClass(annotation));\n+  }\n+\n+  public static AnnotationSpec of(ClassName annotation) {\n+    return new Builder().type(annotation).build();\n   }\n \n   @Override public boolean equals(Object o) {\n"
    },
    {
        "commit_hash": "d88f2b669cd0588b4726f57c5b5b446aa1f7ff2e",
        "previous_commit_hash": "7005ef49cb72e659a6f58f6dd29e24b1a57fad9a",
        "diff_stats": {
            "additions": 24,
            "deletions": 6
        },
        "diff_content": "@@ -34,8 +34,8 @@ import java.util.List;\n import java.util.Map;\n import javax.lang.model.element.Modifier;\n \n+import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkNotNull;\n-import static com.google.common.base.Preconditions.checkState;\n \n /**\n  * Converts a {@link JavaFile} to a string suitable to both human- and javac-consumption. This\n@@ -55,13 +55,21 @@ final class CodeWriter {\n   }\n \n   public CodeWriter indent() {\n-    indentLevel++;\n+    return indent(1);\n+  }\n+\n+  public CodeWriter indent(int levels) {\n+    indentLevel += levels;\n     return this;\n   }\n \n   public CodeWriter unindent() {\n-    checkState(indentLevel > 0);\n-    indentLevel--;\n+    return unindent(1);\n+  }\n+\n+  public CodeWriter unindent(int levels) {\n+    checkArgument(indentLevel - levels >= 0);\n+    indentLevel -= levels;\n     return this;\n   }\n \n@@ -71,7 +79,7 @@ final class CodeWriter {\n   }\n \n   public CodeWriter popVisibleType(TypeName typeName) {\n-    checkState(visibleTypes.remove(typeName));\n+    checkArgument(visibleTypes.remove(typeName));\n     return this;\n   }\n \n@@ -81,15 +89,25 @@ final class CodeWriter {\n     }\n   }\n \n-  public void emitModifiers(ImmutableSet<Modifier> modifiers) {\n+  /**\n+   * Emits {@code modifiers} in the standard order. Modifiers in {@code implicitModifiers} will not\n+   * be emitted.\n+   */\n+  public void emitModifiers(\n+      ImmutableSet<Modifier> modifiers, ImmutableSet<Modifier> implicitModifiers) {\n     if (!modifiers.isEmpty()) {\n       for (Modifier modifier : EnumSet.copyOf(modifiers)) {\n+        if (implicitModifiers.contains(modifier)) continue;\n         emitAndIndent(Ascii.toLowerCase(modifier.name()));\n         emitAndIndent(\" \");\n       }\n     }\n   }\n \n+  public void emitModifiers(ImmutableSet<Modifier> modifiers) {\n+    emitModifiers(modifiers, ImmutableSet.<Modifier>of());\n+  }\n+\n   public CodeWriter emit(String format, Object... args) {\n     return emit(new Snippet(format, args));\n   }\n"
    },
    {
        "commit_hash": "d88f2b669cd0588b4726f57c5b5b446aa1f7ff2e",
        "previous_commit_hash": "7005ef49cb72e659a6f58f6dd29e24b1a57fad9a",
        "diff_stats": {
            "additions": 11,
            "deletions": 2
        },
        "diff_content": "@@ -18,6 +18,7 @@ package com.squareup.javawriter.builders;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n import com.squareup.javawriter.TypeName;\n+import com.squareup.javawriter.TypeNames;\n import java.lang.annotation.Annotation;\n import java.util.ArrayList;\n import java.util.Collections;\n@@ -42,9 +43,13 @@ public final class FieldSpec {\n     this.initializer = builder.initializer;\n   }\n \n-  void emit(CodeWriter codeWriter) {\n+  public boolean hasModifier(Modifier modifier) {\n+    return modifiers.contains(modifier);\n+  }\n+\n+  void emit(CodeWriter codeWriter, ImmutableSet<Modifier> implicitModifiers) {\n     codeWriter.emitAnnotations(annotations, false);\n-    codeWriter.emitModifiers(modifiers);\n+    codeWriter.emitModifiers(modifiers, implicitModifiers);\n     codeWriter.emit(\"$T $L\", type, name);\n     if (initializer != null) {\n       codeWriter.emit(\" = \");\n@@ -80,6 +85,10 @@ public final class FieldSpec {\n       return this;\n     }\n \n+    public Builder type(Class<?> type) {\n+      return type(TypeNames.forClass(type));\n+    }\n+\n     public Builder name(Name name) {\n       this.name = name;\n       return this;\n"
    },
    {
        "commit_hash": "d88f2b669cd0588b4726f57c5b5b446aa1f7ff2e",
        "previous_commit_hash": "7005ef49cb72e659a6f58f6dd29e24b1a57fad9a",
        "diff_stats": {
            "additions": 31,
            "deletions": 3
        },
        "diff_content": "@@ -17,6 +17,7 @@ package com.squareup.javawriter.builders;\n \n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n+import com.squareup.javawriter.ClassName;\n import com.squareup.javawriter.TypeName;\n import com.squareup.javawriter.TypeNames;\n import com.squareup.javawriter.VoidName;\n@@ -26,6 +27,7 @@ import java.util.Collections;\n import java.util.List;\n import javax.lang.model.element.Modifier;\n \n+import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkNotNull;\n \n /** A generated method declaration. */\n@@ -38,6 +40,11 @@ public final class MethodSpec {\n   public final ImmutableList<Snippet> snippets;\n \n   private MethodSpec(Builder builder) {\n+    checkArgument(builder.returnType != null ^ builder.name == Name.CONSTRUCTOR,\n+        \"unexpected return type %s for %s\", builder.returnType, builder.name);\n+    checkArgument(builder.snippets.isEmpty() || !builder.modifiers.contains(Modifier.ABSTRACT),\n+        \"abstract method %s cannot have code\", builder.name);\n+\n     this.annotations = ImmutableList.copyOf(builder.annotations);\n     this.modifiers = ImmutableSet.copyOf(builder.modifiers);\n     this.returnType = builder.returnType;\n@@ -46,10 +53,15 @@ public final class MethodSpec {\n     this.snippets = ImmutableList.copyOf(builder.snippets);\n   }\n \n-  void emit(CodeWriter codeWriter) {\n+  void emit(CodeWriter codeWriter, ClassName enclosing, ImmutableSet<Modifier> implicitModifiers) {\n     codeWriter.emitAnnotations(annotations, false);\n-    codeWriter.emitModifiers(modifiers);\n-    codeWriter.emit(\"$T $L(\", returnType, name);\n+    codeWriter.emitModifiers(modifiers, implicitModifiers);\n+\n+    if (name == Name.CONSTRUCTOR) {\n+      codeWriter.emit(\"$L(\", enclosing.simpleName());\n+    } else {\n+      codeWriter.emit(\"$T $L(\", returnType, name);\n+    }\n \n     boolean firstParameter = true;\n     for (ParameterSpec parameterSpec : parameters) {\n@@ -57,6 +69,12 @@ public final class MethodSpec {\n       parameterSpec.emit(codeWriter);\n       firstParameter = false;\n     }\n+\n+    if (hasModifier(Modifier.ABSTRACT)) {\n+      codeWriter.emit(\");\\n\");\n+      return;\n+    }\n+\n     codeWriter.emit(\") {\\n\");\n \n     codeWriter.indent();\n@@ -68,6 +86,10 @@ public final class MethodSpec {\n     codeWriter.emit(\"}\\n\");\n   }\n \n+  public boolean hasModifier(Modifier modifier) {\n+    return modifiers.contains(modifier);\n+  }\n+\n   public static final class Builder {\n     private final List<AnnotationSpec> annotations = new ArrayList<>();\n     private final List<Modifier> modifiers = new ArrayList<>();\n@@ -100,6 +122,12 @@ public final class MethodSpec {\n       return this;\n     }\n \n+    public Builder constructor() {\n+      returnType = null;\n+      name = Name.CONSTRUCTOR;\n+      return this;\n+    }\n+\n     public Builder name(String name) {\n       this.name = new Name(name);\n       return this;\n"
    },
    {
        "commit_hash": "d88f2b669cd0588b4726f57c5b5b446aa1f7ff2e",
        "previous_commit_hash": "7005ef49cb72e659a6f58f6dd29e24b1a57fad9a",
        "diff_stats": {
            "additions": 2,
            "deletions": 0
        },
        "diff_content": "@@ -23,6 +23,8 @@ import static com.google.common.base.Preconditions.checkNotNull;\n  * {@code public_} or {@code public1}.\n  */\n public final class Name {\n+  static final Name CONSTRUCTOR = new Name(\"<init>\");\n+\n   public final String seed;\n \n   public Name(String seed) {\n"
    },
    {
        "commit_hash": "d88f2b669cd0588b4726f57c5b5b446aa1f7ff2e",
        "previous_commit_hash": "7005ef49cb72e659a6f58f6dd29e24b1a57fad9a",
        "diff_stats": {
            "additions": 10,
            "deletions": 0
        },
        "diff_content": "@@ -17,6 +17,7 @@ package com.squareup.javawriter.builders;\n \n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n+import com.squareup.javawriter.ClassName;\n import com.squareup.javawriter.TypeName;\n import com.squareup.javawriter.TypeNames;\n import java.lang.annotation.Annotation;\n@@ -41,6 +42,10 @@ public final class ParameterSpec {\n     this.name = checkNotNull(builder.name);\n   }\n \n+  public boolean hasModifier(Modifier modifier) {\n+    return modifiers.contains(modifier);\n+  }\n+\n   void emit(CodeWriter codeWriter) {\n     codeWriter.emitAnnotations(annotations, true);\n     codeWriter.emitModifiers(modifiers);\n@@ -63,6 +68,11 @@ public final class ParameterSpec {\n       return this;\n     }\n \n+    public Builder addAnnotation(ClassName annotation) {\n+      this.annotations.add(AnnotationSpec.of(annotation));\n+      return this;\n+    }\n+\n     public Builder addModifiers(Modifier... modifiers) {\n       Collections.addAll(this.modifiers, modifiers);\n       return this;\n"
    },
    {
        "commit_hash": "d88f2b669cd0588b4726f57c5b5b446aa1f7ff2e",
        "previous_commit_hash": "7005ef49cb72e659a6f58f6dd29e24b1a57fad9a",
        "diff_stats": {
            "additions": 2,
            "deletions": 1
        },
        "diff_content": "@@ -16,6 +16,7 @@\n package com.squareup.javawriter.builders;\n \n import com.google.common.collect.ImmutableList;\n+import java.util.Arrays;\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n@@ -67,7 +68,7 @@ final class Snippet {\n     }\n \n     checkArgument(args.length == expectedArgsLength,\n-        \"expected %s args but was %s\", expectedArgsLength, args);\n+        \"expected %s args for %s but was %s\", expectedArgsLength, format, Arrays.toString(args));\n \n     this.formatParts = formatPartsBuilder.build();\n     this.args = ImmutableList.copyOf(args);\n"
    },
    {
        "commit_hash": "d88f2b669cd0588b4726f57c5b5b446aa1f7ff2e",
        "previous_commit_hash": "7005ef49cb72e659a6f58f6dd29e24b1a57fad9a",
        "diff_stats": {
            "additions": 43,
            "deletions": 6
        },
        "diff_content": "@@ -15,6 +15,7 @@\n  */\n package com.squareup.javawriter.builders;\n \n+import com.google.common.base.Ascii;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n import com.squareup.javawriter.ClassName;\n@@ -42,6 +43,25 @@ public final class TypeSpec {\n   private TypeSpec(Builder builder) {\n     checkArgument(builder.name != null ^ builder.anonymousTypeArguments != null,\n         \"types must have either a name or anonymous type arguments\");\n+    boolean isInterface = builder.type == Type.INTERFACE;\n+    boolean typeIsAbstract = builder.modifiers.contains(Modifier.ABSTRACT) || isInterface;\n+    for (MethodSpec methodSpec : builder.methodSpecs) {\n+      checkArgument(typeIsAbstract || !methodSpec.hasModifier(Modifier.ABSTRACT),\n+          \"non-abstract type %s cannot declare abstract method %s\", builder.name, methodSpec.name);\n+      checkArgument(!isInterface || methodSpec.hasModifier(Modifier.ABSTRACT),\n+          \"interface %s cannot declare non-abstract method %s\", builder.name, methodSpec.name);\n+      checkArgument(!isInterface || methodSpec.hasModifier(Modifier.PUBLIC),\n+          \"interface %s cannot declare non-public method %s\", builder.name, methodSpec.name);\n+    }\n+    for (FieldSpec fieldSpec : builder.fieldSpecs) {\n+      if (isInterface) {\n+        checkArgument(fieldSpec.hasModifier(Modifier.PUBLIC)\n+            && fieldSpec.hasModifier(Modifier.STATIC)\n+            && fieldSpec.hasModifier(Modifier.FINAL),\n+            \"interface %s field %s must be public static final\", builder.name, fieldSpec.name);\n+      }\n+    }\n+\n     this.annotations = ImmutableList.copyOf(builder.annotations);\n     this.modifiers = ImmutableSet.copyOf(builder.modifiers);\n     this.type = checkNotNull(builder.type);\n@@ -52,6 +72,10 @@ public final class TypeSpec {\n     this.methodSpecs = ImmutableList.copyOf(builder.methodSpecs);\n   }\n \n+  public boolean hasModifier(Modifier modifier) {\n+    return modifiers.contains(modifier);\n+  }\n+\n   void emit(CodeWriter codeWriter) {\n     if (anonymousTypeArguments != null) {\n       codeWriter.emit(\"new $T(\", supertype);\n@@ -60,29 +84,42 @@ public final class TypeSpec {\n     } else {\n       codeWriter.emitAnnotations(annotations, false);\n       codeWriter.emitModifiers(modifiers);\n-      codeWriter.emit(\"class $L {\\n\", name.simpleName());\n+      codeWriter.emit(\"$L $L {\\n\", Ascii.toLowerCase(type.name()), name.simpleName());\n     }\n \n     codeWriter.indent();\n-\n     boolean firstMember = true;\n     for (FieldSpec fieldSpec : fieldSpecs) {\n       if (!firstMember) codeWriter.emit(\"\\n\");\n-      fieldSpec.emit(codeWriter);\n+      fieldSpec.emit(codeWriter, type.implicitFieldModifiers);\n       firstMember = false;\n     }\n     for (MethodSpec methodSpec : methodSpecs) {\n       if (!firstMember) codeWriter.emit(\"\\n\");\n-      methodSpec.emit(codeWriter);\n+      methodSpec.emit(codeWriter, name, type.implicitMethodModifiers);\n       firstMember = false;\n     }\n-\n     codeWriter.unindent();\n+\n     codeWriter.emit(anonymousTypeArguments != null ? \"}\" : \"}\\n\");\n   }\n \n   public static enum Type {\n-    CLASS, INTERFACE, ENUM\n+    CLASS(ImmutableSet.<Modifier>of(), ImmutableSet.<Modifier>of()),\n+    INTERFACE(ImmutableSet.of(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL),\n+        ImmutableSet.of(Modifier.PUBLIC, Modifier.ABSTRACT)),\n+    ENUM(ImmutableSet.<Modifier>of(), ImmutableSet.<Modifier>of());\n+\n+    private ImmutableSet<Modifier> implicitFieldModifiers\n+        = ImmutableSet.of(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL);\n+    private ImmutableSet<Modifier> implicitMethodModifiers\n+        = ImmutableSet.of(Modifier.PUBLIC, Modifier.ABSTRACT);\n+\n+    private Type(ImmutableSet<Modifier> implicitFieldModifiers,\n+        ImmutableSet<Modifier> implicitMethodModifiers) {\n+      this.implicitFieldModifiers = implicitFieldModifiers;\n+      this.implicitMethodModifiers = implicitMethodModifiers;\n+    }\n   }\n \n   public static final class Builder {\n"
    },
    {
        "commit_hash": "d88f2b669cd0588b4726f57c5b5b446aa1f7ff2e",
        "previous_commit_hash": "7005ef49cb72e659a6f58f6dd29e24b1a57fad9a",
        "diff_stats": {
            "additions": 184,
            "deletions": 2
        },
        "diff_content": "@@ -20,7 +20,6 @@ import com.squareup.javawriter.ClassName;\n import com.squareup.javawriter.ParameterizedTypeName;\n import com.squareup.javawriter.WildcardName;\n import java.io.Serializable;\n-import java.util.ArrayList;\n import java.util.List;\n import javax.lang.model.element.Modifier;\n import org.junit.Test;\n@@ -134,7 +133,7 @@ public class TypeSpecTest {\n     TypeSpec taco = new TypeSpec.Builder()\n         .name(ClassName.create(\"com.squareup.tacos\", \"Taco\"))\n         .addField(new FieldSpec.Builder()\n-            .addModifiers(Modifier.STATIC, Modifier.FINAL)\n+            .addModifiers(Modifier.STATIC, Modifier.FINAL, Modifier.FINAL)\n             .type(thingThangOfFooBar)\n             .name(\"NAME\")\n             .initializer(\"$L\", aThingThang)\n@@ -167,6 +166,189 @@ public class TypeSpecTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void annotatedParameters() throws Exception {\n+    TypeSpec service = new TypeSpec.Builder()\n+        .name(ClassName.create(\"com.squareup.tacos\", \"Foo\"))\n+        .addMethod(new MethodSpec.Builder()\n+            .addModifiers(Modifier.PUBLIC)\n+            .constructor()\n+            .addParameter(new ParameterSpec.Builder()\n+                .type(long.class)\n+                .name(\"id\")\n+                .build())\n+            .addParameter(new ParameterSpec.Builder()\n+                .addAnnotation(ClassName.create(\"com.squareup.tacos\", \"Ping\"))\n+                .type(String.class)\n+                .name(\"one\")\n+                .build())\n+            .addParameter(new ParameterSpec.Builder()\n+                .addAnnotation(ClassName.create(\"com.squareup.tacos\", \"Ping\"))\n+                .type(String.class)\n+                .name(\"two\")\n+                .build())\n+            .addParameter(new ParameterSpec.Builder()\n+                .addAnnotation(new AnnotationSpec.Builder()\n+                    .type(ClassName.create(\"com.squareup.tacos\", \"Pong\"))\n+                    .addMember(\"value\", \"$S\", \"pong\")\n+                    .build())\n+                .type(String.class)\n+                .name(\"three\")\n+                .build())\n+            .addParameter(new ParameterSpec.Builder()\n+                .addAnnotation(ClassName.create(\"com.squareup.tacos\", \"Ping\"))\n+                .type(String.class)\n+                .name(\"four\")\n+                .build())\n+            .addCode(\"/* code snippets */\\n\")\n+            .build())\n+        .build();\n+\n+    assertThat(toString(service)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import com.squareup.tacos.Ping;\\n\"\n+        + \"import com.squareup.tacos.Pong;\\n\"\n+        + \"import java.lang.String;\\n\"\n+        + \"\\n\"\n+        + \"class Foo {\\n\"\n+        + \"  public Foo(long id, @Ping String one, @Ping String two, @Pong(\\\"pong\\\") String three, \"\n+        + \"@Ping String four) {\\n\"\n+        + \"    /* code snippets */\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void retrofitStyleInterface() throws Exception {\n+    ClassName observable = ClassName.create(\"com.squareup.tacos\", \"Observable\");\n+    ClassName fooBar = ClassName.create(\"com.squareup.tacos\", \"FooBar\");\n+    ClassName thing = ClassName.create(\"com.squareup.tacos\", \"Thing\");\n+    ClassName things = ClassName.create(\"com.squareup.tacos\", \"Things\");\n+    ClassName map = ClassName.create(\"java.util\", \"Map\");\n+    ClassName string = ClassName.create(\"java.lang\", \"String\");\n+    ClassName headers = ClassName.create(\"com.squareup.tacos\", \"Headers\");\n+    ClassName post = ClassName.create(\"com.squareup.tacos\", \"POST\");\n+    ClassName body = ClassName.create(\"com.squareup.tacos\", \"Body\");\n+    ClassName queryMap = ClassName.create(\"com.squareup.tacos\", \"QueryMap\");\n+    ClassName header = ClassName.create(\"com.squareup.tacos\", \"Header\");\n+    TypeSpec service = new TypeSpec.Builder()\n+        .name(ClassName.create(\"com.squareup.tacos\", \"Service\"))\n+        .type(TypeSpec.Type.INTERFACE)\n+        .addMethod(new MethodSpec.Builder()\n+            .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)\n+            .addAnnotation(new AnnotationSpec.Builder()\n+                .type(headers)\n+                .addMember(\"value\", \"{\\n$S,\\n$S\\n}\",\n+                    \"Accept: application/json\", \"User-Agent: foobar\")\n+                .build())\n+            .addAnnotation(new AnnotationSpec.Builder()\n+                .type(post)\n+                .addMember(\"value\", \"$S\", \"/foo/bar\")\n+                .build())\n+            .returns(ParameterizedTypeName.create(observable, fooBar))\n+            .name(\"fooBar\")\n+            .addParameter(new ParameterSpec.Builder()\n+                .addAnnotation(body)\n+                .type(ParameterizedTypeName.create(things, thing))\n+                .name(\"things\")\n+                .build())\n+            .addParameter(new ParameterSpec.Builder()\n+                .addAnnotation(new AnnotationSpec.Builder()\n+                    .type(queryMap)\n+                    .addMember(\"encodeValues\", \"false\")\n+                    .build())\n+                .type(ParameterizedTypeName.create(map, string, string))\n+                .name(\"query\")\n+                .build())\n+            .addParameter(new ParameterSpec.Builder()\n+                .addAnnotation(new AnnotationSpec.Builder()\n+                    .type(header)\n+                    .addMember(\"value\", \"$S\", \"Authorization\")\n+                    .build())\n+                .type(string)\n+                .name(\"authorization\")\n+                .build())\n+            .build())\n+        .build();\n+\n+    assertThat(toString(service)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import com.squareup.tacos.Body;\\n\"\n+        + \"import com.squareup.tacos.FooBar;\\n\"\n+        + \"import com.squareup.tacos.Header;\\n\"\n+        + \"import com.squareup.tacos.Headers;\\n\"\n+        + \"import com.squareup.tacos.Observable;\\n\"\n+        + \"import com.squareup.tacos.POST;\\n\"\n+        + \"import com.squareup.tacos.QueryMap;\\n\"\n+        + \"import com.squareup.tacos.Thing;\\n\"\n+        + \"import com.squareup.tacos.Things;\\n\"\n+        + \"import java.lang.String;\\n\"\n+        + \"import java.util.Map;\\n\"\n+        + \"\\n\"\n+        + \"interface Service {\\n\"\n+        + \"  @Headers({\\n\"\n+        + \"      \\\"Accept: application/json\\\",\\n\"\n+        + \"      \\\"User-Agent: foobar\\\"\\n\"\n+        + \"      })\\n\"\n+        + \"  @POST(\\\"/foo/bar\\\")\\n\"\n+        + \"  Observable<FooBar> fooBar(@Body Things<Thing> things, @QueryMap(encodeValues = false) \"\n+        + \"Map<String, String> query, @Header(\\\"Authorization\\\") String authorization);\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void annotatedField() throws Exception {\n+    TypeSpec taco = new TypeSpec.Builder()\n+        .name(ClassName.create(\"com.squareup.tacos\", \"Taco\"))\n+        .addField(new FieldSpec.Builder()\n+            .addAnnotation(new AnnotationSpec.Builder()\n+                .type(ClassName.create(\"com.squareup.tacos\", \"JsonAdapter\"))\n+                .addMember(\"value\", \"$T.class\", ClassName.create(\"com.squareup.tacos\", \"Foo\"))\n+                .build())\n+            .addModifiers(Modifier.PRIVATE, Modifier.FINAL)\n+            .type(String.class)\n+            .name(\"thing\")\n+            .build())\n+        .build();\n+    assertThat(toString(taco)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import com.squareup.tacos.Foo;\\n\"\n+        + \"import com.squareup.tacos.JsonAdapter;\\n\"\n+        + \"import java.lang.String;\\n\"\n+        + \"\\n\"\n+        + \"class Taco {\\n\"\n+        + \"  @JsonAdapter(Foo.class)\\n\"\n+        + \"  private final String thing;\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void annotatedClass() throws Exception {\n+    ClassName someType = ClassName.create(\"com.squareup.tacos\", \"SomeType\");\n+    TypeSpec taco = new TypeSpec.Builder()\n+        .addAnnotation(new AnnotationSpec.Builder()\n+            .type(ClassName.create(\"com.squareup.tacos\", \"Something\"))\n+            .addMember(\"hi\", \"$T.$N\", someType, \"FIELD\")\n+            .addMember(\"hey\", \"$L\", 12)\n+            .addMember(\"hello\", \"$S\", \"goodbye\")\n+            .build())\n+        .name(ClassName.create(\"com.squareup.tacos\", \"Foo\"))\n+        .addModifiers(Modifier.PUBLIC)\n+        .build();\n+    assertThat(toString(taco)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import com.squareup.tacos.SomeType;\\n\"\n+        + \"import com.squareup.tacos.Something;\\n\"\n+        + \"\\n\"\n+        + \"@Something(\\n\"\n+        + \"    hello = \\\"goodbye\\\",\\n\"\n+        + \"    hey = 12,\\n\"\n+        + \"    hi = SomeType.FIELD\\n\"\n+        + \")\\n\"\n+        + \"public class Foo {\\n\"\n+        + \"}\\n\");\n+  }\n+\n   private String toString(TypeSpec typeSpec) {\n     return new JavaFile.Builder()\n         .classSpec(typeSpec)\n"
    },
    {
        "commit_hash": "4963ae4f28c04a92c9699a4a734fe72e41282e0a",
        "previous_commit_hash": "ecfff1f288dd9874ca4863b05ce283946d601458",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -148,7 +148,7 @@ final class CodeWriter {\n   private void emitLiteral(Object o) {\n     if (o instanceof TypeSpec) {\n       TypeSpec typeSpec = (TypeSpec) o;\n-      typeSpec.emit(this);\n+      typeSpec.emit(this, null);\n     } else {\n       emitAndIndent(String.valueOf(o));\n     }\n"
    },
    {
        "commit_hash": "4963ae4f28c04a92c9699a4a734fe72e41282e0a",
        "previous_commit_hash": "ecfff1f288dd9874ca4863b05ce283946d601458",
        "diff_stats": {
            "additions": 6,
            "deletions": 4
        },
        "diff_content": "@@ -45,12 +45,14 @@ public final class JavaFile {\n \n   private void emit(ImmutableMap<ClassName, String> imports, CodeWriter codeWriter) {\n     codeWriter.emit(\"package $L;\\n\", typeSpec.name.packageName());\n-    codeWriter.emit(\"\\n\");\n-    for (ClassName className : imports.keySet()) {\n-      codeWriter.emit(\"import $L;\\n\", className);\n+    if (!imports.isEmpty()) {\n+      codeWriter.emit(\"\\n\");\n+      for (ClassName className : imports.keySet()) {\n+        codeWriter.emit(\"import $L;\\n\", className);\n+      }\n     }\n     codeWriter.emit(\"\\n\");\n-    typeSpec.emit(codeWriter);\n+    typeSpec.emit(codeWriter, null);\n   }\n \n   public static final class Builder {\n"
    },
    {
        "commit_hash": "4963ae4f28c04a92c9699a4a734fe72e41282e0a",
        "previous_commit_hash": "ecfff1f288dd9874ca4863b05ce283946d601458",
        "diff_stats": {
            "additions": 23,
            "deletions": 1
        },
        "diff_content": "@@ -37,6 +37,7 @@ public final class MethodSpec {\n   public final TypeName returnType;\n   public final Name name;\n   public final ImmutableList<ParameterSpec> parameters;\n+  public final ImmutableList<ClassName> exceptions;\n   public final ImmutableList<Snippet> snippets;\n \n   private MethodSpec(Builder builder) {\n@@ -50,6 +51,7 @@ public final class MethodSpec {\n     this.returnType = builder.returnType;\n     this.name = checkNotNull(builder.name);\n     this.parameters = ImmutableList.copyOf(builder.parameters);\n+    this.exceptions = ImmutableList.copyOf(builder.exceptions);\n     this.snippets = ImmutableList.copyOf(builder.snippets);\n   }\n \n@@ -75,7 +77,17 @@ public final class MethodSpec {\n       return;\n     }\n \n-    codeWriter.emit(\") {\\n\");\n+    codeWriter.emit(\")\");\n+    if (!exceptions.isEmpty()) {\n+      codeWriter.emit(\" throws\");\n+      boolean firstException = true;\n+      for (ClassName exception : exceptions) {\n+        if (!firstException) codeWriter.emit(\",\");\n+        codeWriter.emit(\" $T\", exception);\n+        firstException = false;\n+      }\n+    }\n+    codeWriter.emit(\" {\\n\");\n \n     codeWriter.indent();\n     for (Snippet snippet : snippets) {\n@@ -96,6 +108,7 @@ public final class MethodSpec {\n     private TypeName returnType = VoidName.VOID;\n     private Name name;\n     private final List<ParameterSpec> parameters = new ArrayList<>();\n+    private final List<ClassName> exceptions = new ArrayList<>();\n     private final List<Snippet> snippets = new ArrayList<>();\n \n     public Builder addAnnotation(AnnotationSpec annotationSpec) {\n@@ -151,6 +164,15 @@ public final class MethodSpec {\n       return addParameter(new ParameterSpec.Builder().type(type).name(name).build());\n     }\n \n+    public Builder addException(Class<? extends Throwable> exception) {\n+      return addException(ClassName.fromClass(exception));\n+    }\n+\n+    public Builder addException(ClassName exception) {\n+      this.exceptions.add(exception);\n+      return this;\n+    }\n+\n     public Builder addCode(String format, Object... args) {\n       snippets.add(new Snippet(format, args));\n       return this;\n"
    },
    {
        "commit_hash": "4963ae4f28c04a92c9699a4a734fe72e41282e0a",
        "previous_commit_hash": "ecfff1f288dd9874ca4863b05ce283946d601458",
        "diff_stats": {
            "additions": 54,
            "deletions": 5
        },
        "diff_content": "@@ -17,13 +17,17 @@ package com.squareup.javawriter.builders;\n \n import com.google.common.base.Ascii;\n import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n import com.google.common.collect.ImmutableSet;\n import com.squareup.javawriter.ClassName;\n import com.squareup.javawriter.TypeName;\n import java.lang.annotation.Annotation;\n import java.util.ArrayList;\n import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n import java.util.List;\n+import java.util.Map;\n import javax.lang.model.element.Modifier;\n \n import static com.google.common.base.Preconditions.checkArgument;\n@@ -37,6 +41,7 @@ public final class TypeSpec {\n   public final ClassName name;\n   public final TypeName supertype;\n   public final Snippet anonymousTypeArguments;\n+  public final ImmutableMap<String, TypeSpec> enumConstants;\n   public final ImmutableList<FieldSpec> fieldSpecs;\n   public final ImmutableList<MethodSpec> methodSpecs;\n \n@@ -45,6 +50,8 @@ public final class TypeSpec {\n         \"types must have either a name or anonymous type arguments\");\n     boolean isInterface = builder.type == Type.INTERFACE;\n     boolean typeIsAbstract = builder.modifiers.contains(Modifier.ABSTRACT) || isInterface;\n+    checkArgument(builder.type == Type.ENUM ^ builder.enumConstants.isEmpty(),\n+        \"unexpected enum constants %s for type %s\", builder.enumConstants, builder.type);\n     for (MethodSpec methodSpec : builder.methodSpecs) {\n       checkArgument(typeIsAbstract || !methodSpec.hasModifier(Modifier.ABSTRACT),\n           \"non-abstract type %s cannot declare abstract method %s\", builder.name, methodSpec.name);\n@@ -68,6 +75,7 @@ public final class TypeSpec {\n     this.name = builder.name;\n     this.supertype = builder.supertype;\n     this.anonymousTypeArguments = builder.anonymousTypeArguments;\n+    this.enumConstants = ImmutableMap.copyOf(builder.enumConstants);\n     this.fieldSpecs = ImmutableList.copyOf(builder.fieldSpecs);\n     this.methodSpecs = ImmutableList.copyOf(builder.methodSpecs);\n   }\n@@ -76,8 +84,19 @@ public final class TypeSpec {\n     return modifiers.contains(modifier);\n   }\n \n-  void emit(CodeWriter codeWriter) {\n-    if (anonymousTypeArguments != null) {\n+  void emit(CodeWriter codeWriter, String enumName) {\n+    if (enumName != null) {\n+      codeWriter.emit(\"$L\", enumName);\n+      if (!anonymousTypeArguments.formatParts.isEmpty()) {\n+        codeWriter.emit(\"(\");\n+        codeWriter.emit(anonymousTypeArguments);\n+        codeWriter.emit(\")\");\n+      }\n+      if (fieldSpecs.isEmpty() && methodSpecs.isEmpty()) {\n+        return; // Avoid unnecessary braces \"{}\".\n+      }\n+      codeWriter.emit(\" {\\n\");\n+    } else if (anonymousTypeArguments != null) {\n       codeWriter.emit(\"new $T(\", supertype);\n       codeWriter.emit(anonymousTypeArguments);\n       codeWriter.emit(\") {\\n\");\n@@ -89,6 +108,14 @@ public final class TypeSpec {\n \n     codeWriter.indent();\n     boolean firstMember = true;\n+    for (Iterator<Map.Entry<String, TypeSpec>> i = enumConstants.entrySet().iterator();\n+        i.hasNext();) {\n+      Map.Entry<String, TypeSpec> enumConstant = i.next();\n+      if (!firstMember) codeWriter.emit(\"\\n\");\n+      enumConstant.getValue().emit(codeWriter, enumConstant.getKey());\n+      firstMember = false;\n+      codeWriter.emit(\"$L\", i.hasNext() ? \",\\n\" : \";\\n\");\n+    }\n     for (FieldSpec fieldSpec : fieldSpecs) {\n       if (!firstMember) codeWriter.emit(\"\\n\");\n       fieldSpec.emit(codeWriter, type.implicitFieldModifiers);\n@@ -101,7 +128,11 @@ public final class TypeSpec {\n     }\n     codeWriter.unindent();\n \n-    codeWriter.emit(anonymousTypeArguments != null ? \"}\" : \"}\\n\");\n+    if (enumName != null || anonymousTypeArguments != null) {\n+      codeWriter.emit(\"}\");\n+    } else {\n+      codeWriter.emit(\"}\\n\");\n+    }\n   }\n \n   public static enum Type {\n@@ -129,6 +160,7 @@ public final class TypeSpec {\n     private ClassName name;\n     private TypeName supertype = ClassName.fromClass(Object.class);\n     private Snippet anonymousTypeArguments;\n+    private Map<String, TypeSpec> enumConstants = new LinkedHashMap<>();\n     private List<FieldSpec> fieldSpecs = new ArrayList<>();\n     private List<MethodSpec> methodSpecs = new ArrayList<>();\n \n@@ -162,13 +194,25 @@ public final class TypeSpec {\n       return this;\n     }\n \n+    public Builder anonymousTypeArguments() {\n+      return anonymousTypeArguments(\"\");\n+    }\n+\n     public Builder anonymousTypeArguments(String format, Object... args) {\n       this.anonymousTypeArguments = new Snippet(format, args);\n       return this;\n     }\n \n-    public Builder addMethod(MethodSpec methodSpec) {\n-      methodSpecs.add(methodSpec);\n+    public Builder addEnumConstant(String name) {\n+      return addEnumConstant(name, new Builder()\n+          .anonymousTypeArguments()\n+          .build());\n+    }\n+\n+    public Builder addEnumConstant(String name, TypeSpec typeSpec) {\n+      checkArgument(typeSpec.anonymousTypeArguments != null,\n+          \"enum constants must have anonymous type arguments\");\n+      enumConstants.put(name, typeSpec);\n       return this;\n     }\n \n@@ -177,6 +221,11 @@ public final class TypeSpec {\n       return this;\n     }\n \n+    public Builder addMethod(MethodSpec methodSpec) {\n+      methodSpecs.add(methodSpec);\n+      return this;\n+    }\n+\n     public TypeSpec build() {\n       return new TypeSpec(this);\n     }\n"
    },
    {
        "commit_hash": "4963ae4f28c04a92c9699a4a734fe72e41282e0a",
        "previous_commit_hash": "ecfff1f288dd9874ca4863b05ce283946d601458",
        "diff_stats": {
            "additions": 0,
            "deletions": 68
        },
        "diff_content": "@@ -1,68 +0,0 @@\n-/*\n- * Copyright (C) 2014 Square, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.squareup.javawriter;\n-\n-import java.io.IOException;\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.junit.runners.JUnit4;\n-\n-import static com.google.common.truth.Truth.assertThat;\n-\n-@RunWith(JUnit4.class)\n-public class AnnotationWriterTest {\n-  private final ClassName className = ClassName.bestGuessFromString(\"com.example.Thing\");\n-  private final AnnotationWriter writer = new AnnotationWriter(className);\n-\n-  @Test public void bare() throws IOException {\n-    String expected = \"@com.example.Thing\";\n-\n-    assertThat(Writables.writeToString(writer)).isEqualTo(expected);\n-  }\n-\n-  @Test public void value() throws IOException {\n-    String expected = \"@com.example.Thing(\\\"Hello, world!\\\")\";\n-\n-    writer.setValue(\"Hello, world!\");\n-\n-    assertThat(Writables.writeToString(writer)).isEqualTo(expected);\n-  }\n-\n-  @Test public void valueMember() throws IOException {\n-    String expected = \"@com.example.Thing(\\\"Hello, world!\\\")\";\n-\n-    writer.setMember(\"value\", \"Hello, world!\");\n-\n-    assertThat(Writables.writeToString(writer)).isEqualTo(expected);\n-  }\n-\n-  @Test public void singleNonValueParameter() throws IOException {\n-    String expected = \"@com.example.Thing(greeting = \\\"Hello, world!\\\")\";\n-\n-    writer.setMember(\"greeting\", \"Hello, world!\");\n-\n-    assertThat(Writables.writeToString(writer)).isEqualTo(expected);\n-  }\n-\n-  @Test public void multipleParameters() throws IOException {\n-    String expected = \"@com.example.Thing(name = \\\"Hello, world!\\\", value = 42)\";\n-\n-    writer.setMember(\"name\", \"Hello, world!\");\n-    writer.setMember(\"value\", 42);\n-\n-    assertThat(Writables.writeToString(writer)).isEqualTo(expected);\n-  }\n-}\n"
    },
    {
        "commit_hash": "4963ae4f28c04a92c9699a4a734fe72e41282e0a",
        "previous_commit_hash": "ecfff1f288dd9874ca4863b05ce283946d601458",
        "diff_stats": {
            "additions": 0,
            "deletions": 163
        },
        "diff_content": "@@ -1,163 +0,0 @@\n-/*\n- * Copyright (C) 2014 Square, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.squareup.javawriter;\n-\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Map;\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.junit.runners.JUnit4;\n-\n-import static com.google.common.truth.Truth.assertThat;\n-import static javax.lang.model.element.Modifier.PUBLIC;\n-\n-@RunWith(JUnit4.class) public class AnonymousClassWriterTest {\n-  private final ClassName className = ClassName.create(\"com.foo\", \"Bar\");\n-  private final ClassName threadName = ClassName.fromClass(Thread.class);\n-\n-  @Test public void definedAsField() throws IOException {\n-    ClassWriter classWriter = ClassWriter.forClassName(className);\n-    FieldWriter threadField = classWriter.addField(threadName, \"thread\");\n-\n-    AnonymousClassWriter threadWriter = AnonymousClassWriter.forClassName(threadName);\n-    MethodWriter threadStartMethod = threadWriter.addMethod(void.class, \"start\");\n-    threadStartMethod.annotate(Override.class);\n-    threadStartMethod.addModifier(PUBLIC);\n-    threadStartMethod.body().addSnippet(\"System.out.println(\\\"Hello World!\\\");\");\n-\n-    threadField.setInitializer(\"%s\", threadWriter);\n-\n-    assertThat(classWriter.toString()).isEqualTo(\"\"\n-        + \"package com.foo;\\n\"\n-        + \"\\n\"\n-        + \"class Bar {\\n\"\n-        + \"  Thread thread = new Thread() {\\n\"\n-        + \"    @Override\\n\"\n-        + \"    public void start() {\\n\"\n-        + \"      System.out.println(\\\"Hello World!\\\");\\n\"\n-        + \"    }\\n\"\n-        + \"  };\\n\"\n-        + \"}\\n\");\n-  }\n-\n-  @Test public void withConstructorParameters() throws IOException {\n-    ClassWriter classWriter = ClassWriter.forClassName(className);\n-    classWriter.addField(threadName, \"thread\");\n-    ConstructorWriter constructorWriter = classWriter.addConstructor();\n-    constructorWriter.addParameter(Runnable.class, \"runnable\");\n-\n-    AnonymousClassWriter threadWriter = AnonymousClassWriter.forClassName(threadName);\n-    threadWriter.setConstructorArguments(\"runnable\");\n-    MethodWriter threadStartMethod = threadWriter.addMethod(void.class, \"start\");\n-    threadStartMethod.annotate(Override.class);\n-    threadStartMethod.addModifier(PUBLIC);\n-    threadStartMethod.body().addSnippet(\"System.out.println(\\\"Hello World!\\\");\");\n-\n-    constructorWriter.body().addSnippet(\"thread = %s;\", threadWriter);\n-\n-    assertThat(classWriter.toString()).isEqualTo(\"\"\n-        + \"package com.foo;\\n\"\n-        + \"\\n\"\n-        + \"class Bar {\\n\"\n-        + \"  Thread thread;\\n\"\n-        + \"\\n\"\n-        + \"  Bar(Runnable runnable) {\\n\"\n-        + \"    thread = new Thread(runnable) {\\n\"\n-        + \"      @Override\\n\"\n-        + \"      public void start() {\\n\"\n-        + \"        System.out.println(\\\"Hello World!\\\");\\n\"\n-        + \"      }\\n\"\n-        + \"    };\\n\"\n-        + \"  }\\n\"\n-        + \"}\\n\");\n-  }\n-\n-  @Test public void withImports() throws IOException {\n-    ClassWriter classWriter = ClassWriter.forClassName(className);\n-    classWriter.addField(threadName, \"thread\");\n-    ConstructorWriter constructorWriter = classWriter.addConstructor();\n-\n-    AnonymousClassWriter threadWriter = AnonymousClassWriter.forClassName(threadName);\n-    FieldWriter threadListField = threadWriter.addField(\n-        ParameterizedTypeName.create(List.class, ClassName.fromClass(String.class)), \"list\");\n-    threadListField.setInitializer(\"%s.asList(\\\"Hello World\\\")\", ClassName.fromClass(Arrays.class));\n-    MethodWriter threadStartMethod = threadWriter.addMethod(void.class, \"start\");\n-    threadStartMethod.annotate(Override.class);\n-    threadStartMethod.addModifier(PUBLIC);\n-    threadStartMethod.body().addSnippet(\"System.out.println(list.get(0));\");\n-\n-    constructorWriter.body().addSnippet(\"thread = %s;\", threadWriter);\n-\n-    assertThat(classWriter.toString()).isEqualTo(\"\"\n-        + \"package com.foo;\\n\"\n-        + \"\\n\"\n-        + \"import java.util.Arrays;\\n\"\n-        + \"import java.util.List;\\n\"\n-        + \"\\n\"\n-        + \"class Bar {\\n\"\n-        + \"  Thread thread;\\n\"\n-        + \"\\n\"\n-        + \"  Bar() {\\n\"\n-        + \"    thread = new Thread() {\\n\"\n-        + \"      List<String> list = Arrays.asList(\\\"Hello World\\\");\\n\"\n-        + \"\\n\"\n-        + \"      @Override\\n\"\n-        + \"      public void start() {\\n\"\n-        + \"        System.out.println(list.get(0));\\n\"\n-        + \"      }\\n\"\n-        + \"    };\\n\"\n-        + \"  }\\n\"\n-        + \"}\\n\");\n-  }\n-\n-  @Test public void withType() throws IOException {\n-    ClassWriter classWriter = ClassWriter.forClassName(className);\n-    FieldWriter listField =\n-        classWriter.addField(ParameterizedTypeName.create(List.class, WildcardName.create()),\n-            \"list\");\n-\n-    AnonymousClassWriter listWriter = AnonymousClassWriter.forParameterizedTypeName(\n-        ParameterizedTypeName.create(ArrayList.class,\n-            ParameterizedTypeName.create(Map.class, ClassName.fromClass(String.class),\n-                ClassName.fromClass(Integer.class))));\n-\n-    MethodWriter listSizeMethod = listWriter.addMethod(int.class, \"size\");\n-    listSizeMethod.annotate(Override.class);\n-    listSizeMethod.addModifier(PUBLIC);\n-    listSizeMethod.body().addSnippet(\"return 1;\");\n-\n-    listField.setInitializer(\"%s\", listWriter);\n-\n-    assertThat(classWriter.toString()).isEqualTo(\"\"\n-        + \"package com.foo;\\n\"\n-        + \"\\n\"\n-        + \"import java.util.ArrayList;\\n\"\n-        + \"import java.util.List;\\n\"\n-        + \"import java.util.Map;\\n\"\n-        + \"\\n\"\n-        + \"class Bar {\\n\"\n-        + \"  List<?> list = new ArrayList<Map<String, Integer>>() {\\n\"\n-        + \"    @Override\\n\"\n-        + \"    public int size() {\\n\"\n-        + \"      return 1;\\n\"\n-        + \"    }\\n\"\n-        + \"  };\\n\"\n-        + \"}\\n\");\n-  }\n-}\n"
    },
    {
        "commit_hash": "4963ae4f28c04a92c9699a4a734fe72e41282e0a",
        "previous_commit_hash": "ecfff1f288dd9874ca4863b05ce283946d601458",
        "diff_stats": {
            "additions": 0,
            "deletions": 36
        },
        "diff_content": "@@ -1,36 +0,0 @@\n-/*\n- * Copyright (C) 2014 Square, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.squareup.javawriter;\n-\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.junit.runners.JUnit4;\n-\n-import static com.google.common.truth.Truth.assertThat;\n-import static org.junit.Assert.fail;\n-\n-@RunWith(JUnit4.class)\n-public final class ClassWriterTest {\n-  @Test public void onlyTopLevelClassNames() {\n-    ClassName name = ClassName.bestGuessFromString(\"test.Foo.Bar\");\n-    try {\n-      ClassWriter.forClassName(name);\n-      fail();\n-    } catch (IllegalArgumentException e) {\n-      assertThat(e.getMessage()).isEqualTo(\"test.Foo.Bar must be top-level type.\");\n-    }\n-  }\n-}\n"
    },
    {
        "commit_hash": "4963ae4f28c04a92c9699a4a734fe72e41282e0a",
        "previous_commit_hash": "ecfff1f288dd9874ca4863b05ce283946d601458",
        "diff_stats": {
            "additions": 0,
            "deletions": 44
        },
        "diff_content": "@@ -1,44 +0,0 @@\n-/*\n- * Copyright (C) 2014 Square, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.squareup.javawriter;\n-\n-import com.google.common.base.Joiner;\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.junit.runners.JUnit4;\n-\n-import static com.google.common.truth.Truth.assertThat;\n-\n-@RunWith(JUnit4.class)\n-public final class ConstructorWriterTest {\n-  @Test public void empty() {\n-    ConstructorWriter test = new ConstructorWriter(\"Test\");\n-    String actual = Writables.writeToString(test);\n-    assertThat(actual).isEqualTo(\"Test() {\\n}\\n\");\n-  }\n-\n-  @Test public void multilineBody() {\n-    ConstructorWriter test = new ConstructorWriter(\"Test\");\n-    test.body().addSnippet(\"String firstName;\\nString lastName;\");\n-    String actual = Writables.writeToString(test);\n-    assertThat(actual).isEqualTo(Joiner.on('\\n').join(\n-        \"Test() {\",\n-        \"  String firstName;\",\n-        \"  String lastName;\",\n-        \"}\\n\"\n-    ));\n-  }\n-}\n"
    },
    {
        "commit_hash": "4963ae4f28c04a92c9699a4a734fe72e41282e0a",
        "previous_commit_hash": "ecfff1f288dd9874ca4863b05ce283946d601458",
        "diff_stats": {
            "additions": 0,
            "deletions": 124
        },
        "diff_content": "@@ -1,124 +0,0 @@\n-/*\n- * Copyright (C) 2014 Square, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.squareup.javawriter;\n-\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.junit.runners.JUnit4;\n-import javax.lang.model.element.Modifier;\n-\n-import static com.google.common.truth.Truth.assertThat;\n-import static org.junit.Assert.fail;\n-\n-@RunWith(JUnit4.class)\n-public final class EnumWriterTest {\n-  @Test public void onlyTopLevelClassNames() {\n-    ClassName name = ClassName.bestGuessFromString(\"test.Foo.Bar\");\n-    try {\n-      EnumWriter.forClassName(name);\n-      fail();\n-    } catch (IllegalArgumentException e) {\n-      assertThat(e.getMessage()).isEqualTo(\"test.Foo.Bar must be top-level type.\");\n-    }\n-  }\n-\n-  @Test public void constantsAreRequired() {\n-    EnumWriter enumWriter = EnumWriter.forClassName(ClassName.create(\"test\", \"Test\"));\n-    try {\n-      Writables.writeToString(enumWriter);\n-      fail();\n-    } catch (IllegalStateException e) {\n-      assertThat(e.getMessage()).isEqualTo(\"Cannot write an enum with no constants.\");\n-    }\n-  }\n-\n-  @Test public void constantsAreIndented() {\n-    EnumWriter enumWriter = EnumWriter.forClassName(ClassName.create(\"test\", \"Test\"));\n-    enumWriter.addConstant(\"HELLO\");\n-    enumWriter.addConstant(\"WORLD\");\n-\n-    String expected = \"\"\n-        + \"package test;\\n\"\n-        + \"\\n\"\n-        + \"enum Test {\\n\"\n-        + \"  HELLO,\\n\"\n-        + \"  WORLD;\\n\"\n-        + \"}\\n\";\n-    assertThat(enumWriter.toString()).isEqualTo(expected);\n-  }\n-\n-  @Test public void constantsWithConstructorArguments() {\n-    EnumWriter enumWriter = EnumWriter.forClassName(ClassName.create(\"test\", \"Test\"));\n-    enumWriter.addConstant(\"HELLO\").addArgument(Snippet.format(\"\\\"Hello\\\"\"));\n-    enumWriter.addConstant(\"WORLD\").addArgument(Snippet.format(\"\\\"World!\\\"\"));\n-\n-    FieldWriter valueWriter = enumWriter.addField(String.class, \"value\");\n-    valueWriter.addModifiers(Modifier.PUBLIC, Modifier.FINAL);\n-\n-    ConstructorWriter constructorWriterWriter = enumWriter.addConstructor();\n-    constructorWriterWriter.addModifier(Modifier.PRIVATE);\n-    constructorWriterWriter.addParameter(String.class, \"value\");\n-    constructorWriterWriter.body().addSnippet(\"this.value = value;\");\n-\n-    assertThat(enumWriter.toString()).isEqualTo(\"\"\n-        + \"package test;\\n\"\n-        + \"\\n\"\n-        + \"enum Test {\\n\"\n-        + \"  HELLO(\\\"Hello\\\"),\\n\"\n-        + \"  WORLD(\\\"World!\\\");\\n\"\n-        + \"\\n\"\n-        + \"  public final String value;\\n\"\n-        + \"\\n\"\n-        + \"  private Test(String value) {\\n\"\n-        + \"    this.value = value;\\n\"\n-        + \"  }\\n\"\n-        + \"}\\n\");\n-  }\n-\n-  @Test public void constantsWithClassBody() {\n-    EnumWriter enumWriter = EnumWriter.forClassName(ClassName.create(\"test\", \"Test\"));\n-\n-    EnumWriter.ConstantWriter helloWriter = enumWriter.addConstant(\"HELLO\");\n-    MethodWriter helloToStringWriter = helloWriter.addMethod(String.class, \"toString\");\n-    helloToStringWriter.annotate(Override.class);\n-    helloToStringWriter.addModifier(Modifier.PUBLIC);\n-    helloToStringWriter.body().addSnippet(\"return \\\"Hello\\\";\");\n-\n-    EnumWriter.ConstantWriter worldWriter = enumWriter.addConstant(\"WORLD\");\n-    MethodWriter worldToStringWriter = worldWriter.addMethod(String.class, \"toString\");\n-    worldToStringWriter.annotate(Override.class);\n-    worldToStringWriter.addModifier(Modifier.PUBLIC);\n-    worldToStringWriter.body().addSnippet(\"return \\\"World!\\\";\");\n-\n-    assertThat(enumWriter.toString()).isEqualTo(\"\"\n-        + \"package test;\\n\"\n-        + \"\\n\"\n-        + \"enum Test {\\n\"\n-        + \"  HELLO {\\n\"\n-        + \"    @Override\\n\"\n-        + \"    public String toString() {\\n\"\n-        + \"      return \\\"Hello\\\";\\n\"\n-        + \"    }\\n\"\n-        + \"  },\\n\"\n-        + \"  WORLD {\\n\"\n-        + \"    @Override\\n\"\n-        + \"    public String toString() {\\n\"\n-        + \"      return \\\"World!\\\";\\n\"\n-        + \"    }\\n\"\n-        + \"  };\\n\"\n-        + \"}\\n\");\n-  }\n-}\n"
    },
    {
        "commit_hash": "4963ae4f28c04a92c9699a4a734fe72e41282e0a",
        "previous_commit_hash": "ecfff1f288dd9874ca4863b05ce283946d601458",
        "diff_stats": {
            "additions": 0,
            "deletions": 36
        },
        "diff_content": "@@ -1,36 +0,0 @@\n-/*\n- * Copyright (C) 2014 Square, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.squareup.javawriter;\n-\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.junit.runners.JUnit4;\n-\n-import static com.google.common.truth.Truth.assertThat;\n-import static org.junit.Assert.fail;\n-\n-@RunWith(JUnit4.class)\n-public final class InterfaceWriterTest {\n-  @Test public void onlyTopLevelClassNames() {\n-    ClassName name = ClassName.bestGuessFromString(\"test.Foo.Bar\");\n-    try {\n-      InterfaceWriter.forClassName(name);\n-      fail();\n-    } catch (IllegalArgumentException e) {\n-      assertThat(e.getMessage()).isEqualTo(\"test.Foo.Bar must be top-level type.\");\n-    }\n-  }\n-}\n"
    },
    {
        "commit_hash": "4963ae4f28c04a92c9699a4a734fe72e41282e0a",
        "previous_commit_hash": "ecfff1f288dd9874ca4863b05ce283946d601458",
        "diff_stats": {
            "additions": 0,
            "deletions": 82
        },
        "diff_content": "@@ -1,82 +0,0 @@\n-/*\n- * Copyright (C) 2014 Square, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.squareup.javawriter;\n-\n-import com.google.common.base.Joiner;\n-import java.io.IOException;\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.junit.runners.JUnit4;\n-\n-import static com.google.common.truth.Truth.assertThat;\n-\n-@RunWith(JUnit4.class)\n-public final class MethodWriterTest {\n-  @Test public void empty() {\n-    MethodWriter test = new MethodWriter(VoidName.VOID, \"test\");\n-    String actual = Writables.writeToString(test);\n-    assertThat(actual).isEqualTo(\"void test() {\\n}\\n\");\n-  }\n-\n-  @Test public void multilineBody() {\n-    MethodWriter test = new MethodWriter(VoidName.VOID, \"test\");\n-    test.body().addSnippet(\"String firstName;\\nString lastName;\");\n-    String actual = Writables.writeToString(test);\n-    assertThat(actual).isEqualTo(Joiner.on('\\n').join(\n-        \"void test() {\",\n-        \"  String firstName;\",\n-        \"  String lastName;\",\n-        \"}\\n\"\n-    ));\n-  }\n-\n-  @Test public void singleThrowsTypeName() {\n-    MethodWriter method = new MethodWriter(VoidName.VOID, \"test\");\n-    method.addThrowsType(ClassName.fromClass(IOException.class));\n-\n-    assertThat(Writables.writeToString(method)) //\n-        .isEqualTo(\"void test() throws java.io.IOException {\\n}\\n\");\n-  }\n-\n-  @Test public void singleThrowsClass() {\n-    MethodWriter method = new MethodWriter(VoidName.VOID, \"test\");\n-    method.addThrowsType(ClassName.fromClass(IOException.class));\n-\n-    assertThat(Writables.writeToString(method)) //\n-        .isEqualTo(\"void test() throws java.io.IOException {\\n}\\n\");\n-  }\n-\n-  @Test public void throwsWithBody() {\n-    MethodWriter method = new MethodWriter(PrimitiveName.INT, \"test\");\n-    method.addThrowsType(ClassName.fromClass(IOException.class));\n-    method.body().addSnippet(\"return 0;\");\n-\n-    assertThat(Writables.writeToString(method)).isEqualTo(Joiner.on('\\n').join(\n-        \"int test() throws java.io.IOException {\",\n-        \"  return 0;\",\n-        \"}\\n\"\n-    ));\n-  }\n-\n-  @Test public void multipleThrows() {\n-    MethodWriter method = new MethodWriter(VoidName.VOID, \"test\");\n-    method.addThrowsType(IOException.class);\n-    method.addThrowsType(ClassName.create(\"example\", \"ExampleException\"));\n-\n-    assertThat(Writables.writeToString(method)) //\n-        .isEqualTo(\"void test() throws java.io.IOException, example.ExampleException {\\n}\\n\");\n-  }\n-}\n"
    },
    {
        "commit_hash": "4963ae4f28c04a92c9699a4a734fe72e41282e0a",
        "previous_commit_hash": "ecfff1f288dd9874ca4863b05ce283946d601458",
        "diff_stats": {
            "additions": 0,
            "deletions": 48
        },
        "diff_content": "@@ -1,48 +0,0 @@\n-/*\n- * Copyright (C) 2014 Square, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.squareup.javawriter;\n-\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.junit.runners.JUnit4;\n-\n-import static com.google.common.truth.Truth.assertThat;\n-\n-/**\n- * ParameterWriter only differs from FieldWriter in the format of its annotations.\n- */\n-@RunWith(JUnit4.class)\n-public final class ParameterWriterTest {\n-  @Test public void simple() {\n-    ClassName runnable = ClassName.fromClass(Runnable.class);\n-    ParameterWriter parameterWriter = new ParameterWriter(runnable, \"runnable\");\n-\n-    assertThat(Writables.writeToString(parameterWriter))\n-        .isEqualTo(\"java.lang.Runnable runnable\");\n-  }\n-\n-  @Test public void annotated() {\n-    ClassName notNull = ClassName.create(\"example\", \"NotNull\");\n-    ClassName redacted = ClassName.create(\"example\", \"Redacted\");\n-    ClassName runnable = ClassName.fromClass(Runnable.class);\n-    ParameterWriter parameterWriter = new ParameterWriter(runnable, \"runnable\");\n-    parameterWriter.annotate(notNull);\n-    parameterWriter.annotate(redacted);\n-\n-    assertThat(Writables.writeToString(parameterWriter))\n-        .isEqualTo(\"@example.NotNull @example.Redacted java.lang.Runnable runnable\");\n-  }\n-}\n"
    },
    {
        "commit_hash": "4963ae4f28c04a92c9699a4a734fe72e41282e0a",
        "previous_commit_hash": "ecfff1f288dd9874ca4863b05ce283946d601458",
        "diff_stats": {
            "additions": 0,
            "deletions": 27
        },
        "diff_content": "@@ -35,33 +35,6 @@ public class TypeWriterTest {\n     assertThat(topClass.toString()).doesNotContain(\"import some.other.pkg.Bottom;\");\n   }\n \n-  @Test public void zeroImportsSingleNewline() {\n-    ClassName name = ClassName.create(\"test\", \"Top\");\n-    ClassWriter classWriter = ClassWriter.forClassName(name);\n-\n-    String expected = \"\"\n-        + \"package test;\\n\"\n-        + \"\\n\"\n-        + \"class Top {}\\n\";\n-    assertThat(classWriter.toString()).isEqualTo(expected);\n-  }\n-\n-  @Test public void newlineBetweenImports() {\n-    ClassName name = ClassName.create(\"test\", \"Top\");\n-    ClassWriter topClass = ClassWriter.forClassName(name);\n-    topClass.addField(Executor.class, \"executor\");\n-\n-    String expected = \"\"\n-        + \"package test;\\n\"\n-        + \"\\n\"\n-        + \"import java.util.concurrent.Executor;\\n\"\n-        + \"\\n\"\n-        + \"class Top {\\n\"\n-        + \"  Executor executor;\\n\"\n-        + \"}\\n\";\n-    assertThat(topClass.toString()).isEqualTo(expected);\n-  }\n-\n   @Test public void explicitImports() {\n     ClassName name = ClassName.create(\"test\", \"Top\");\n     ClassWriter topClass = ClassWriter.forClassName(name);\n"
    },
    {
        "commit_hash": "4963ae4f28c04a92c9699a4a734fe72e41282e0a",
        "previous_commit_hash": "ecfff1f288dd9874ca4863b05ce283946d601458",
        "diff_stats": {
            "additions": 106,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright (C) 2015 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter.builders;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.squareup.javawriter.ClassName;\n+import java.util.Date;\n+import org.junit.Test;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.junit.Assert.fail;\n+\n+public final class JavaFileTest {\n+  @Test public void cannotEmitNestedClass() throws Exception {\n+    TypeSpec tacoSupremo = new TypeSpec.Builder()\n+        .name(ClassName.create(\"com.squareup.tacos\", ImmutableList.of(\"Taco\"), \"Supremo\"))\n+        .build();\n+    try {\n+      new JavaFile.Builder().classSpec(tacoSupremo);\n+      fail();\n+    } catch (IllegalArgumentException expected) {\n+    }\n+  }\n+\n+  @Test public void noImports() throws Exception {\n+    String source = new JavaFile.Builder()\n+        .classSpec(new TypeSpec.Builder()\n+            .name(ClassName.create(\"com.squareup.tacos\", \"Taco\"))\n+            .build())\n+        .build()\n+        .toString();\n+    assertThat(source).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"class Taco {\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void singleImport() throws Exception {\n+    String source = new JavaFile.Builder()\n+        .classSpec(new TypeSpec.Builder()\n+            .name(ClassName.create(\"com.squareup.tacos\", \"Taco\"))\n+            .addField(new FieldSpec.Builder()\n+                .type(Date.class)\n+                .name(\"madeFreshDate\")\n+                .build())\n+            .build())\n+        .build()\n+        .toString();\n+    assertThat(source).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import java.util.Date;\\n\"\n+        + \"\\n\"\n+        + \"class Taco {\\n\"\n+        + \"  Date madeFreshDate;\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void conflictingImports() throws Exception {\n+    String source = new JavaFile.Builder()\n+        .classSpec(new TypeSpec.Builder()\n+            .name(ClassName.create(\"com.squareup.tacos\", \"Taco\"))\n+            .addField(new FieldSpec.Builder()\n+                .type(Date.class)\n+                .name(\"madeFreshDate\")\n+                .build())\n+            .addField(new FieldSpec.Builder()\n+                .type(java.sql.Date.class)\n+                .name(\"madeFreshDatabaseDate\")\n+                .build())\n+            .build())\n+        .build()\n+        .toString();\n+    assertThat(source).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import java.util.Date;\\n\"\n+        + \"\\n\"\n+        + \"class Taco {\\n\"\n+        + \"  Date madeFreshDate;\\n\"\n+        + \"\\n\"\n+        + \"  java.sql.Date madeFreshDatabaseDate;\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  private String toString(TypeSpec typeSpec) {\n+    return new JavaFile.Builder()\n+        .classSpec(typeSpec)\n+        .build()\n+        .toString();\n+  }\n+}\n"
    },
    {
        "commit_hash": "4963ae4f28c04a92c9699a4a734fe72e41282e0a",
        "previous_commit_hash": "ecfff1f288dd9874ca4863b05ce283946d601458",
        "diff_stats": {
            "additions": 149,
            "deletions": 1
        },
        "diff_content": "@@ -19,14 +19,16 @@ import com.google.common.collect.ImmutableList;\n import com.squareup.javawriter.ClassName;\n import com.squareup.javawriter.ParameterizedTypeName;\n import com.squareup.javawriter.WildcardName;\n+import java.io.IOException;\n import java.io.Serializable;\n import java.util.List;\n import javax.lang.model.element.Modifier;\n import org.junit.Test;\n \n import static com.google.common.truth.Truth.assertThat;\n+import static org.junit.Assert.fail;\n \n-public class TypeSpecTest {\n+public final class TypeSpecTest {\n   @Test public void basic() throws Exception {\n     TypeSpec taco = new TypeSpec.Builder()\n         .name(ClassName.create(\"com.squareup.tacos\", \"Taco\"))\n@@ -349,6 +351,152 @@ public class TypeSpecTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void enumWithSubclassing() throws Exception {\n+      TypeSpec roshambo = new TypeSpec.Builder()\n+        .type(TypeSpec.Type.ENUM)\n+        .name(ClassName.create(\"com.squareup.tacos\", \"Roshambo\"))\n+        .addModifiers(Modifier.PUBLIC)\n+        .addEnumConstant(\"ROCK\")\n+        .addEnumConstant(\"PAPER\", new TypeSpec.Builder()\n+            .anonymousTypeArguments(\"$S\", \"flat\")\n+            .addMethod(new MethodSpec.Builder()\n+                .addAnnotation(Override.class)\n+                .addModifiers(Modifier.PUBLIC)\n+                .returns(String.class)\n+                .name(\"toString\")\n+                .addCode(\"return $S;\\n\", \"paper airplane!\")\n+                .build())\n+            .build())\n+        .addEnumConstant(\"SCISSORS\", new TypeSpec.Builder()\n+            .anonymousTypeArguments(\"$S\", \"peace sign\")\n+            .build())\n+        .addField(new FieldSpec.Builder()\n+            .addModifiers(Modifier.PRIVATE, Modifier.FINAL)\n+            .type(String.class)\n+            .name(\"handPosition\")\n+            .build())\n+        .addMethod(new MethodSpec.Builder()\n+            .constructor()\n+            .addParameter(String.class, \"handPosition\")\n+            .addCode(\"this.handPosition = handPosition;\\n\")\n+            .build())\n+        .addMethod(new MethodSpec.Builder()\n+            .constructor()\n+            .addCode(\"this($S);\\n\", \"fist\")\n+            .build())\n+        .build();\n+    assertThat(toString(roshambo)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import java.lang.Override;\\n\"\n+        + \"import java.lang.String;\\n\"\n+        + \"\\n\"\n+        + \"public enum Roshambo {\\n\"\n+        + \"  ROCK,\\n\"\n+        + \"\\n\"\n+        + \"  PAPER(\\\"flat\\\") {\\n\"\n+        + \"    @Override\\n\"\n+        + \"    public String toString() {\\n\"\n+        + \"      return \\\"paper airplane!\\\";\\n\"\n+        + \"    }\\n\"\n+        + \"  },\\n\"\n+        + \"\\n\"\n+        + \"  SCISSORS(\\\"peace sign\\\");\\n\"\n+        + \"\\n\"\n+        + \"  private final String handPosition;\\n\"\n+        + \"\\n\"\n+        + \"  Roshambo(String handPosition) {\\n\"\n+        + \"    this.handPosition = handPosition;\\n\"\n+        + \"  }\\n\"\n+        + \"\\n\"\n+        + \"  Roshambo() {\\n\"\n+        + \"    this(\\\"fist\\\");\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void enumConstantsRequired() throws Exception {\n+    try {\n+      new TypeSpec.Builder()\n+        .type(TypeSpec.Type.ENUM)\n+        .name(ClassName.create(\"com.squareup.tacos\", \"Roshambo\"))\n+        .build();\n+      fail();\n+    } catch (IllegalArgumentException expected) {\n+    }\n+  }\n+\n+  @Test public void onlyEnumsMayHaveEnumConstants() throws Exception {\n+    try {\n+      new TypeSpec.Builder()\n+        .type(TypeSpec.Type.CLASS)\n+        .name(ClassName.create(\"com.squareup.tacos\", \"Roshambo\"))\n+        .addEnumConstant(\"ROCK\")\n+        .build();\n+      fail();\n+    } catch (IllegalArgumentException expected) {\n+    }\n+  }\n+\n+  @Test public void enumWithMembersButNoConstructorCall() throws Exception {\n+    TypeSpec roshambo = new TypeSpec.Builder()\n+        .type(TypeSpec.Type.ENUM)\n+        .name(ClassName.create(\"com.squareup.tacos\", \"Roshambo\"))\n+        .addEnumConstant(\"SPOCK\", new TypeSpec.Builder()\n+            .anonymousTypeArguments()\n+            .addMethod(new MethodSpec.Builder()\n+                .addAnnotation(Override.class)\n+                .addModifiers(Modifier.PUBLIC)\n+                .returns(String.class)\n+                .name(\"toString\")\n+                .addCode(\"return $S;\\n\", \"west side\")\n+                .build())\n+            .build())\n+        .build();\n+    assertThat(toString(roshambo)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import java.lang.Override;\\n\"\n+        + \"import java.lang.String;\\n\"\n+        + \"\\n\"\n+        + \"enum Roshambo {\\n\"\n+        + \"  SPOCK {\\n\"\n+        + \"    @Override\\n\"\n+        + \"    public String toString() {\\n\"\n+        + \"      return \\\"west side\\\";\\n\"\n+        + \"    }\\n\"\n+        + \"  };\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void methodThrows() throws Exception {\n+    TypeSpec taco = new TypeSpec.Builder()\n+        .name(ClassName.create(\"com.squareup.tacos\", \"Taco\"))\n+        .addMethod(new MethodSpec.Builder()\n+            .name(\"throwOne\")\n+            .addException(IOException.class)\n+            .build())\n+        .addMethod(new MethodSpec.Builder()\n+            .name(\"throwTwo\")\n+            .addException(IOException.class)\n+            .addException(ClassName.create(\"com.squareup.tacos\", \"SourCreamException\"))\n+            .build())\n+        .build();\n+    assertThat(toString(taco)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import com.squareup.tacos.SourCreamException;\\n\"\n+        + \"import java.io.IOException;\\n\"\n+        + \"\\n\"\n+        + \"class Taco {\\n\"\n+        + \"  void throwOne() throws IOException {\\n\"\n+        + \"  }\\n\"\n+        + \"\\n\"\n+        + \"  void throwTwo() throws IOException, SourCreamException {\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n   private String toString(TypeSpec typeSpec) {\n     return new JavaFile.Builder()\n         .classSpec(typeSpec)\n"
    },
    {
        "commit_hash": "e2e90c100cf77cd170e8e49b39e92d5b2219e709",
        "previous_commit_hash": "8d31c0a593f09484ff8914c7a7a004f828e0e377",
        "diff_stats": {
            "additions": 2,
            "deletions": 0
        },
        "diff_content": "@@ -48,6 +48,8 @@ import static javax.lang.model.element.NestingKind.TOP_LEVEL;\n  * @since 2.0\n  */\n public final class ClassName implements TypeName, Comparable<ClassName> {\n+  public static final ClassName OBJECT = ClassName.fromClass(Object.class);\n+\n   private String fullyQualifiedName = null;\n   private final String packageName;\n   /* From top to bottom.  E.g.: this field will contain [\"A\", \"B\"] for pgk.A.B.C */\n"
    },
    {
        "commit_hash": "e2e90c100cf77cd170e8e49b39e92d5b2219e709",
        "previous_commit_hash": "8d31c0a593f09484ff8914c7a7a004f828e0e377",
        "diff_stats": {
            "additions": 14,
            "deletions": 12
        },
        "diff_content": "@@ -16,11 +16,9 @@\n package com.squareup.javawriter;\n \n import com.google.common.base.Objects;\n-import com.google.common.base.Optional;\n import com.google.common.base.Predicates;\n import com.google.common.collect.FluentIterable;\n import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Iterables;\n import java.io.IOException;\n import java.util.Set;\n@@ -35,19 +33,23 @@ import static com.squareup.javawriter.TypeNames.FOR_TYPE_MIRROR;\n \n public final class TypeVariableName implements TypeName {\n   private final String name;\n-  private final Optional<TypeName> upperBound;\n+  private final TypeName upperBound;\n \n-  TypeVariableName(String name, Optional<TypeName> upperBound) {\n+  TypeVariableName(String name, TypeName upperBound) {\n     this.name = name;\n     this.upperBound = upperBound;\n   }\n \n+  public TypeName upperBound() {\n+    return upperBound;\n+  }\n+\n   public static TypeVariableName create(String name) {\n-    return new TypeVariableName(name, Optional.<TypeName>absent());\n+    return new TypeVariableName(name, ClassName.OBJECT);\n   }\n \n   public static TypeVariableName create(String name, TypeName upperBound) {\n-    return new TypeVariableName(name, Optional.of(upperBound));\n+    return new TypeVariableName(name, upperBound);\n   }\n \n   static TypeVariableName forTypeMirror(TypeVariable mirror) {\n@@ -71,11 +73,11 @@ public final class TypeVariableName implements TypeName {\n         .filter(Predicates.not(Predicates.<TypeName>equalTo(ClassName.fromClass(Object.class))))\n         .toList();\n     if (typeNames.size() == 1) {\n-      return new TypeVariableName(name, Optional.of(Iterables.getOnlyElement(typeNames)));\n+      return new TypeVariableName(name, Iterables.getOnlyElement(typeNames));\n     } else if (!typeNames.isEmpty()) {\n-      return new TypeVariableName(name, Optional.<TypeName>of(new IntersectionTypeName(typeNames)));\n+      return new TypeVariableName(name, new IntersectionTypeName(typeNames));\n     }\n-    return new TypeVariableName(name, Optional.<TypeName>absent());\n+    return new TypeVariableName(name, ClassName.OBJECT);\n   }\n \n   public String name() {\n@@ -84,15 +86,15 @@ public final class TypeVariableName implements TypeName {\n \n   @Override\n   public Set<ClassName> referencedClasses() {\n-    return upperBound.transform(GET_REFERENCED_CLASSES).or(ImmutableSet.<ClassName>of());\n+    return upperBound.referencedClasses();\n   }\n \n   @Override\n   public Appendable write(Appendable appendable, Context context) throws IOException {\n     appendable.append(name);\n-    if (upperBound.isPresent()) {\n+    if (!upperBound.equals(ClassName.OBJECT)) {\n       appendable.append(\" extends \");\n-      upperBound.get().write(appendable, context);\n+      upperBound.write(appendable, context);\n     }\n     return appendable;\n   }\n"
    },
    {
        "commit_hash": "e2e90c100cf77cd170e8e49b39e92d5b2219e709",
        "previous_commit_hash": "8d31c0a593f09484ff8914c7a7a004f828e0e377",
        "diff_stats": {
            "additions": 24,
            "deletions": 1
        },
        "diff_content": "@@ -25,6 +25,7 @@ import com.squareup.javawriter.ParameterizedTypeName;\n import com.squareup.javawriter.StringLiteral;\n import com.squareup.javawriter.TypeName;\n import com.squareup.javawriter.TypeNames;\n+import com.squareup.javawriter.TypeVariableName;\n import com.squareup.javawriter.WildcardName;\n import java.util.ArrayList;\n import java.util.EnumSet;\n@@ -108,6 +109,27 @@ final class CodeWriter {\n     emitModifiers(modifiers, ImmutableSet.<Modifier>of());\n   }\n \n+  /**\n+   * Emit type variables with their bounds. This should only be used when declaring type variables;\n+   * everywhere else bounds are omitted.\n+   */\n+  public void emitTypeVariables(ImmutableList<TypeVariableName> typeVariables) {\n+    if (typeVariables.isEmpty()) return;\n+\n+    emit(\"<\");\n+    boolean first = true;\n+    for (TypeVariableName typeVariable : typeVariables) {\n+      if (!first) emit(\", \");\n+      emit(\"$L\", typeVariable.name());\n+      TypeName upperBound = typeVariable.upperBound();\n+      if (!upperBound.equals(ClassName.OBJECT)) {\n+        emit(\" extends $T\", upperBound);\n+      }\n+      first = false;\n+    }\n+    emit(\">\");\n+  }\n+\n   public CodeWriter emit(String format, Object... args) {\n     return emit(new Snippet(format, args));\n   }\n@@ -181,7 +203,8 @@ final class CodeWriter {\n       } else if (superBound != null) {\n         emit(\"? super $T\", superBound);\n       }\n-      // TODO(jwilson): special case ? for List<?>.\n+    } else if (typeName instanceof TypeVariableName) {\n+      emit(\"$L\", ((TypeVariableName) typeName).name());\n     } else {\n       String shortName = !visibleTypes.contains(typeName)\n           ? importedTypes.get(typeName)\n"
    },
    {
        "commit_hash": "e2e90c100cf77cd170e8e49b39e92d5b2219e709",
        "previous_commit_hash": "8d31c0a593f09484ff8914c7a7a004f828e0e377",
        "diff_stats": {
            "additions": 14,
            "deletions": 0
        },
        "diff_content": "@@ -20,6 +20,7 @@ import com.google.common.collect.ImmutableSet;\n import com.squareup.javawriter.ClassName;\n import com.squareup.javawriter.TypeName;\n import com.squareup.javawriter.TypeNames;\n+import com.squareup.javawriter.TypeVariableName;\n import com.squareup.javawriter.VoidName;\n import java.lang.annotation.Annotation;\n import java.util.ArrayList;\n@@ -34,6 +35,7 @@ import static com.google.common.base.Preconditions.checkNotNull;\n public final class MethodSpec {\n   public final ImmutableList<AnnotationSpec> annotations;\n   public final ImmutableSet<Modifier> modifiers;\n+  public final ImmutableList<TypeVariableName> typeVariables;\n   public final TypeName returnType;\n   public final Name name;\n   public final ImmutableList<ParameterSpec> parameters;\n@@ -48,6 +50,7 @@ public final class MethodSpec {\n \n     this.annotations = ImmutableList.copyOf(builder.annotations);\n     this.modifiers = ImmutableSet.copyOf(builder.modifiers);\n+    this.typeVariables = ImmutableList.copyOf(builder.typeVariables);\n     this.returnType = builder.returnType;\n     this.name = checkNotNull(builder.name);\n     this.parameters = ImmutableList.copyOf(builder.parameters);\n@@ -59,6 +62,11 @@ public final class MethodSpec {\n     codeWriter.emitAnnotations(annotations, false);\n     codeWriter.emitModifiers(modifiers, implicitModifiers);\n \n+    if (!typeVariables.isEmpty()) {\n+      codeWriter.emitTypeVariables(typeVariables);\n+      codeWriter.emit(\" \");\n+    }\n+\n     if (name == Name.CONSTRUCTOR) {\n       codeWriter.emit(\"$L(\", enclosing.simpleName());\n     } else {\n@@ -105,6 +113,7 @@ public final class MethodSpec {\n   public static final class Builder {\n     private final List<AnnotationSpec> annotations = new ArrayList<>();\n     private final List<Modifier> modifiers = new ArrayList<>();\n+    private List<TypeVariableName> typeVariables = new ArrayList<>();\n     private TypeName returnType = VoidName.VOID;\n     private Name name;\n     private final List<ParameterSpec> parameters = new ArrayList<>();\n@@ -126,6 +135,11 @@ public final class MethodSpec {\n       return this;\n     }\n \n+    public Builder addTypeVariable(TypeVariableName typeVariable) {\n+      typeVariables.add(typeVariable);\n+      return this;\n+    }\n+\n     public Builder returns(Class<?> returnType) {\n       return returns(TypeNames.forClass(returnType));\n     }\n"
    },
    {
        "commit_hash": "e2e90c100cf77cd170e8e49b39e92d5b2219e709",
        "previous_commit_hash": "8d31c0a593f09484ff8914c7a7a004f828e0e377",
        "diff_stats": {
            "additions": 73,
            "deletions": 7
        },
        "diff_content": "@@ -21,6 +21,8 @@ import com.google.common.collect.ImmutableMap;\n import com.google.common.collect.ImmutableSet;\n import com.squareup.javawriter.ClassName;\n import com.squareup.javawriter.TypeName;\n+import com.squareup.javawriter.TypeNames;\n+import com.squareup.javawriter.TypeVariableName;\n import java.lang.annotation.Annotation;\n import java.util.ArrayList;\n import java.util.Collections;\n@@ -32,6 +34,7 @@ import javax.lang.model.element.Modifier;\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n \n /** A generated class, interface, or enum declaration. */\n public final class TypeSpec {\n@@ -39,7 +42,9 @@ public final class TypeSpec {\n   public final ImmutableSet<Modifier> modifiers;\n   public final Type type;\n   public final ClassName name;\n-  public final TypeName supertype;\n+  public final ImmutableList<TypeVariableName> typeVariables;\n+  public final TypeName superclass;\n+  public final ImmutableList<TypeName> superinterfaces;\n   public final Snippet anonymousTypeArguments;\n   public final ImmutableMap<String, TypeSpec> enumConstants;\n   public final ImmutableList<FieldSpec> fieldSpecs;\n@@ -68,12 +73,18 @@ public final class TypeSpec {\n             \"interface %s field %s must be public static final\", builder.name, fieldSpec.name);\n       }\n     }\n+    boolean superclassIsObject = builder.superclass.equals(ClassName.OBJECT);\n+    int interestingSupertypeCount = (superclassIsObject ? 0 : 1) + builder.superinterfaces.size();\n+    checkArgument(builder.anonymousTypeArguments == null || interestingSupertypeCount <= 1,\n+        \"anonymous type has too many supertypes\");\n \n     this.annotations = ImmutableList.copyOf(builder.annotations);\n     this.modifiers = ImmutableSet.copyOf(builder.modifiers);\n     this.type = checkNotNull(builder.type);\n     this.name = builder.name;\n-    this.supertype = builder.supertype;\n+    this.typeVariables = ImmutableList.copyOf(builder.typeVariables);\n+    this.superclass = builder.superclass;\n+    this.superinterfaces = ImmutableList.copyOf(builder.superinterfaces);\n     this.anonymousTypeArguments = builder.anonymousTypeArguments;\n     this.enumConstants = ImmutableMap.copyOf(builder.enumConstants);\n     this.fieldSpecs = ImmutableList.copyOf(builder.fieldSpecs);\n@@ -97,13 +108,48 @@ public final class TypeSpec {\n       }\n       codeWriter.emit(\" {\\n\");\n     } else if (anonymousTypeArguments != null) {\n-      codeWriter.emit(\"new $T(\", supertype);\n+      codeWriter.emit(\"new $T(\", getOnlyElement(superinterfaces, superclass));\n       codeWriter.emit(anonymousTypeArguments);\n       codeWriter.emit(\") {\\n\");\n     } else {\n       codeWriter.emitAnnotations(annotations, false);\n       codeWriter.emitModifiers(modifiers);\n-      codeWriter.emit(\"$L $L {\\n\", Ascii.toLowerCase(type.name()), name.simpleName());\n+      codeWriter.emit(\"$L $L\", Ascii.toLowerCase(type.name()), name.simpleName());\n+      codeWriter.emitTypeVariables(typeVariables);\n+\n+      List<TypeName> extendsTypes;\n+      List<TypeName> implementsTypes;\n+      if (type == Type.INTERFACE) {\n+        extendsTypes = superinterfaces;\n+        implementsTypes = ImmutableList.of();\n+      } else {\n+        extendsTypes = superclass.equals(ClassName.OBJECT)\n+            ? ImmutableList.<TypeName>of()\n+            : ImmutableList.of(superclass);\n+        implementsTypes = superinterfaces;\n+      }\n+\n+      if (!extendsTypes.isEmpty()) {\n+        codeWriter.emit(\" extends\");\n+        boolean firstType = true;\n+        for (TypeName type : extendsTypes) {\n+          if (!firstType) codeWriter.emit(\",\");\n+          codeWriter.emit(\" $T\", type);\n+          firstType = false;\n+        }\n+      }\n+\n+      if (!implementsTypes.isEmpty()) {\n+        codeWriter.emit(\" implements\");\n+        boolean firstType = true;\n+        for (TypeName type : implementsTypes) {\n+          if (!firstType) codeWriter.emit(\",\");\n+          codeWriter.emit(\" $T\", type);\n+          firstType = false;\n+        }\n+      }\n+\n+      codeWriter.emit(\" {\\n\");\n     }\n \n     codeWriter.indent();\n@@ -158,7 +204,9 @@ public final class TypeSpec {\n     private final List<Modifier> modifiers = new ArrayList<>();\n     private Type type = Type.CLASS;\n     private ClassName name;\n-    private TypeName supertype = ClassName.fromClass(Object.class);\n+    private List<TypeVariableName> typeVariables = new ArrayList<>();\n+    private TypeName superclass = ClassName.OBJECT;\n+    private List<TypeName> superinterfaces = new ArrayList<>();\n     private Snippet anonymousTypeArguments;\n     private Map<String, TypeSpec> enumConstants = new LinkedHashMap<>();\n     private List<FieldSpec> fieldSpecs = new ArrayList<>();\n@@ -189,8 +237,26 @@ public final class TypeSpec {\n       return this;\n     }\n \n-    public Builder supertype(TypeName supertype) {\n-      this.supertype = supertype;\n+    public Builder addTypeVariable(TypeVariableName typeVariable) {\n+      typeVariables.add(typeVariable);\n+      return this;\n+    }\n+\n+    public Builder superclass(Class<?> superclass) {\n+      return superclass(TypeNames.forClass(superclass));\n+    }\n+\n+    public Builder superclass(TypeName superclass) {\n+      this.superclass = superclass;\n+      return this;\n+    }\n+\n+    public Builder addSuperinterface(Class<?> superinterface) {\n+      return addSuperinterface(TypeNames.forClass(superinterface));\n+    }\n+\n+    public Builder addSuperinterface(TypeName superinterface) {\n+      this.superinterfaces.add(superinterface);\n       return this;\n     }\n \n"
    },
    {
        "commit_hash": "e2e90c100cf77cd170e8e49b39e92d5b2219e709",
        "previous_commit_hash": "8d31c0a593f09484ff8914c7a7a004f828e0e377",
        "diff_stats": {
            "additions": 138,
            "deletions": 2
        },
        "diff_content": "@@ -18,9 +18,11 @@ package com.squareup.javawriter.builders;\n import com.google.common.collect.ImmutableList;\n import com.squareup.javawriter.ClassName;\n import com.squareup.javawriter.ParameterizedTypeName;\n+import com.squareup.javawriter.TypeVariableName;\n import com.squareup.javawriter.WildcardName;\n import java.io.IOException;\n import java.io.Serializable;\n+import java.util.AbstractSet;\n import java.util.List;\n import javax.lang.model.element.Modifier;\n import org.junit.Test;\n@@ -110,7 +112,7 @@ public final class TypeSpecTest {\n         .name(\"thung\")\n         .build();\n     TypeSpec aSimpleThung = new TypeSpec.Builder()\n-        .supertype(simpleThungOfBar)\n+        .superclass(simpleThungOfBar)\n         .anonymousTypeArguments(\"$N\", thungParameter)\n         .addMethod(new MethodSpec.Builder()\n             .addAnnotation(Override.class)\n@@ -121,7 +123,7 @@ public final class TypeSpecTest {\n             .build())\n         .build();\n     TypeSpec aThingThang = new TypeSpec.Builder()\n-        .supertype(thingThangOfFooBar)\n+        .superclass(thingThangOfFooBar)\n         .anonymousTypeArguments(\"\")\n         .addMethod(new MethodSpec.Builder()\n             .addAnnotation(Override.class)\n@@ -497,6 +499,140 @@ public final class TypeSpecTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void typeVariables() throws Exception {\n+    TypeVariableName t = TypeVariableName.create(\"T\");\n+    TypeVariableName p = TypeVariableName.create(\"P\", ClassName.fromClass(Number.class));\n+    ClassName location = ClassName.create(\"com.squareup.tacos\", \"Location\");\n+    TypeSpec typeSpec = new TypeSpec.Builder()\n+        .name(location)\n+        .addTypeVariable(t)\n+        .addTypeVariable(p)\n+        .addSuperinterface(ParameterizedTypeName.create(ClassName.fromClass(Comparable.class), p))\n+        .addField(new FieldSpec.Builder()\n+            .type(t)\n+            .name(\"label\")\n+            .build())\n+        .addField(new FieldSpec.Builder()\n+            .type(p)\n+            .name(\"x\")\n+            .build())\n+        .addField(new FieldSpec.Builder()\n+            .type(p)\n+            .name(\"y\")\n+            .build())\n+        .addMethod(new MethodSpec.Builder()\n+            .addAnnotation(Override.class)\n+            .addModifiers(Modifier.PUBLIC)\n+            .returns(int.class)\n+            .name(\"compareTo\")\n+            .addParameter(p, \"p\")\n+            .addCode(\"return 0;\\n\")\n+            .build())\n+        .addMethod(new MethodSpec.Builder()\n+            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n+            .addTypeVariable(t)\n+            .addTypeVariable(p)\n+            .returns(ParameterizedTypeName.create(location, t, p))\n+            .name(\"of\")\n+            .addParameter(t, \"label\")\n+            .addParameter(p, \"x\")\n+            .addParameter(p, \"y\")\n+            .addCode(\"throw new $T($S);\\n\", UnsupportedOperationException.class, \"TODO\")\n+            .build())\n+        .build();\n+    assertThat(toString(typeSpec)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import com.squareup.tacos.Location;\\n\"\n+        + \"import java.lang.Comparable;\\n\"\n+        + \"import java.lang.Number;\\n\"\n+        + \"import java.lang.Override;\\n\"\n+        + \"import java.lang.UnsupportedOperationException;\\n\"\n+        + \"\\n\"\n+        + \"class Location<T, P extends Number> implements Comparable<P> {\\n\"\n+        + \"  T label;\\n\"\n+        + \"\\n\"\n+        + \"  P x;\\n\"\n+        + \"\\n\"\n+        + \"  P y;\\n\"\n+        + \"\\n\"\n+        + \"  @Override\\n\"\n+        + \"  public int compareTo(P p) {\\n\"\n+        + \"    return 0;\\n\"\n+        + \"  }\\n\"\n+        + \"\\n\"\n+        + \"  public static <T, P extends Number> Location<T, P> of(T label, P x, P y) {\\n\"\n+        + \"    throw new UnsupportedOperationException(\\\"TODO\\\");\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void classImplementsExtends() throws Exception {\n+    ClassName taco = ClassName.create(\"com.squareup.tacos\", \"Taco\");\n+    ClassName food = ClassName.create(\"com.squareup.taco\", \"Food\");\n+    TypeSpec typeSpec = new TypeSpec.Builder()\n+        .name(taco)\n+        .addModifiers(Modifier.ABSTRACT)\n+        .superclass(ParameterizedTypeName.create(AbstractSet.class, food))\n+        .addSuperinterface(Serializable.class)\n+        .addSuperinterface(ParameterizedTypeName.create(Comparable.class, taco))\n+        .build();\n+    assertThat(toString(typeSpec)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import com.squareup.taco.Food;\\n\"\n+        + \"import com.squareup.tacos.Taco;\\n\"\n+        + \"import java.io.Serializable;\\n\"\n+        + \"import java.lang.Comparable;\\n\"\n+        + \"import java.util.AbstractSet;\\n\"\n+        + \"\\n\"\n+        + \"abstract class Taco extends AbstractSet<Food> \"\n+        + \"implements Serializable, Comparable<Taco> {\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void enumImplements() throws Exception {\n+    ClassName food = ClassName.create(\"com.squareup.taco\", \"Food\");\n+    TypeSpec typeSpec = new TypeSpec.Builder()\n+        .type(TypeSpec.Type.ENUM)\n+        .name(food)\n+        .addSuperinterface(Serializable.class)\n+        .addSuperinterface(Cloneable.class)\n+        .addEnumConstant(\"LEAN_GROUND_BEEF\")\n+        .addEnumConstant(\"SHREDDED_CHEESE\")\n+        .build();\n+    assertThat(toString(typeSpec)).isEqualTo(\"\"\n+        + \"package com.squareup.taco;\\n\"\n+        + \"\\n\"\n+        + \"import java.io.Serializable;\\n\"\n+        + \"import java.lang.Cloneable;\\n\"\n+        + \"\\n\"\n+        + \"enum Food implements Serializable, Cloneable {\\n\"\n+        + \"  LEAN_GROUND_BEEF,\\n\"\n+        + \"\\n\"\n+        + \"  SHREDDED_CHEESE;\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void interfaceExtends() throws Exception {\n+    ClassName taco = ClassName.create(\"com.squareup.tacos\", \"Taco\");\n+    TypeSpec typeSpec = new TypeSpec.Builder()\n+        .type(TypeSpec.Type.INTERFACE)\n+        .name(taco)\n+        .addSuperinterface(Serializable.class)\n+        .addSuperinterface(ParameterizedTypeName.create(Comparable.class, taco))\n+        .build();\n+    assertThat(toString(typeSpec)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import com.squareup.tacos.Taco;\\n\"\n+        + \"import java.io.Serializable;\\n\"\n+        + \"import java.lang.Comparable;\\n\"\n+        + \"\\n\"\n+        + \"interface Taco extends Serializable, Comparable<Taco> {\\n\"\n+        + \"}\\n\");\n+  }\n+\n   private String toString(TypeSpec typeSpec) {\n     return new JavaFile.Builder()\n         .classSpec(typeSpec)\n"
    },
    {
        "commit_hash": "5b4f979a54b18b614efd264c2b71d6df38e666a2",
        "previous_commit_hash": "bd1db39b58e41fb8712e8604499c29db49f287d2",
        "diff_stats": {
            "additions": 8,
            "deletions": 0
        },
        "diff_content": "@@ -71,6 +71,14 @@ public final class ClassName implements TypeName, Comparable<ClassName> {\n     return enclosingSimpleNames;\n   }\n \n+  // TODO(jwilson): make this package-private once builders and type names are in the same package.\n+  public ImmutableList<String> simpleNames() {\n+    return new ImmutableList.Builder<String>()\n+        .addAll(enclosingSimpleNames)\n+        .add(simpleName)\n+        .build();\n+  }\n+\n   public Optional<ClassName> enclosingClassName() {\n     return enclosingSimpleNames.isEmpty()\n         ? Optional.<ClassName>absent()\n"
    },
    {
        "commit_hash": "5b4f979a54b18b614efd264c2b71d6df38e666a2",
        "previous_commit_hash": "bd1db39b58e41fb8712e8604499c29db49f287d2",
        "diff_stats": {
            "additions": 85,
            "deletions": 13
        },
        "diff_content": "@@ -16,16 +16,19 @@\n package com.squareup.javawriter.builders;\n \n import com.google.common.base.Ascii;\n+import com.google.common.base.Joiner;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableMap;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.ImmutableSortedMap;\n import com.squareup.javawriter.ClassName;\n import com.squareup.javawriter.ParameterizedTypeName;\n+import com.squareup.javawriter.PrimitiveName;\n import com.squareup.javawriter.StringLiteral;\n import com.squareup.javawriter.TypeName;\n import com.squareup.javawriter.TypeNames;\n import com.squareup.javawriter.TypeVariableName;\n+import com.squareup.javawriter.VoidName;\n import com.squareup.javawriter.WildcardName;\n import java.util.ArrayList;\n import java.util.EnumSet;\n@@ -33,10 +36,12 @@ import java.util.LinkedHashMap;\n import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n import javax.lang.model.element.Modifier;\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n \n /**\n  * Converts a {@link JavaFile} to a string suitable to both human- and javac-consumption. This\n@@ -45,11 +50,13 @@ import static com.google.common.base.Preconditions.checkNotNull;\n final class CodeWriter {\n   private final String indent = \"  \";\n   private final StringBuilder out;\n-  private final ImmutableMap<ClassName, String> importedTypes;\n-  private final LinkedHashSet<TypeName> emittedTypes = new LinkedHashSet<>();\n-  private final List<TypeName> visibleTypes = new ArrayList<>();\n   private int indentLevel;\n \n+  private String packageName;\n+  private final List<TypeSpec> typeSpecStack = new ArrayList<>();\n+  private final ImmutableMap<ClassName, String> importedTypes;\n+  private final Set<ClassName> importableTypes = new LinkedHashSet<>();\n+\n   public CodeWriter(StringBuilder out, ImmutableMap<ClassName, String> importedTypes) {\n     this.out = checkNotNull(out);\n     this.importedTypes = checkNotNull(importedTypes);\n@@ -74,13 +81,25 @@ final class CodeWriter {\n     return this;\n   }\n \n-  public CodeWriter pushVisibleType(TypeName typeName) {\n-    visibleTypes.add(typeName);\n+  public CodeWriter pushPackage(String packageName) {\n+    checkState(this.packageName == null);\n+    this.packageName = checkNotNull(packageName);\n     return this;\n   }\n \n-  public CodeWriter popVisibleType(TypeName typeName) {\n-    checkArgument(visibleTypes.remove(typeName));\n+  public CodeWriter popPackage() {\n+    checkState(this.packageName != null);\n+    this.packageName = null;\n+    return this;\n+  }\n+\n+  public CodeWriter pushType(TypeSpec type) {\n+    this.typeSpecStack.add(type);\n+    return this;\n+  }\n+\n+  public CodeWriter popType() {\n+    this.typeSpecStack.remove(typeSpecStack.size() - 1);\n     return this;\n   }\n \n@@ -178,7 +197,6 @@ final class CodeWriter {\n \n   private void emitType(Object arg) {\n     TypeName typeName = toTypeName(arg);\n-    emittedTypes.add(typeName);\n \n     // TODO(jwilson): replace instanceof nonsense with polymorphism!\n     if (typeName instanceof ParameterizedTypeName) {\n@@ -205,12 +223,66 @@ final class CodeWriter {\n       }\n     } else if (typeName instanceof TypeVariableName) {\n       emit(\"$L\", ((TypeVariableName) typeName).name());\n+    } else if (typeName instanceof ClassName) {\n+      emitAndIndent(lookupName((ClassName) typeName));\n+    } else if (typeName instanceof PrimitiveName) {\n+      emitAndIndent(typeName.toString());\n+    } else if (typeName instanceof VoidName) {\n+      emitAndIndent(typeName.toString());\n     } else {\n-      String shortName = !visibleTypes.contains(typeName)\n-          ? importedTypes.get(typeName)\n-          : null;\n-      emitAndIndent(shortName != null ? shortName : typeName.toString());\n+      throw new UnsupportedOperationException(\"unexpected type: \" + arg);\n+    }\n+  }\n+\n+  /**\n+   * Returns the best name to identify {@code className} with in the current context. This uses the\n+   * available imports and the current scope to find the shortest name available. It does not honor\n+   * names visible due to inheritance.\n+   */\n+  private String lookupName(ClassName className) {\n+    // Different package than current? Just look for an import.\n+    if (!className.packageName().equals(packageName)) {\n+      String importedName = importedTypes.get(className);\n+      if (importedName != null) {\n+        importableTypes.add(className);\n+        return importedName;\n+      }\n+\n+      // If the target class wasn't imported, perhaps its enclosing class was. Try that.\n+      ClassName enclosingClassName = className.enclosingClassName().orNull();\n+      if (enclosingClassName != null) {\n+        return lookupName(enclosingClassName) + \".\" + className.simpleName();\n+      }\n+\n+      // Fall back to the fully-qualified name. Mark the type as importable for a future pass.\n+      importableTypes.add(className);\n+      return className.toString();\n+    }\n+\n+    // Look for the longest common prefix, which we can omit.\n+    ImmutableList<String> classNames = className.simpleNames();\n+    int prefixLength = commonPrefixLength(classNames);\n+    if (prefixLength == classNames.size()) {\n+      return className.simpleName(); // Special case: a class referring to itself!\n+    }\n+\n+    return Joiner.on('.').join(classNames.subList(prefixLength, classNames.size()));\n+  }\n+\n+  /**\n+   * Returns the common prefix of {@code classNames} and the current nesting scope. For example,\n+   * suppose the current scope is {@code AbstractMap.SimpleEntry}. This will return 0 for {@code\n+   * List}, 1 for {@code AbstractMap}, 1 for {@code AbstractMap.SimpleImmutableEntry}, and 2 for\n+   * {@code AbstractMap.SimpleEntry} itself.\n+   */\n+  private int commonPrefixLength(ImmutableList<String> classNames) {\n+    int size = Math.min(classNames.size(), typeSpecStack.size());\n+    for (int i = 0; i < size; i++) {\n+      String a = classNames.get(i);\n+      String b = typeSpecStack.get(i).name;\n+      if (!a.equals(b)) return i;\n     }\n+    return size;\n   }\n \n   /** Emits {@code s} with indentation as required. */\n@@ -261,7 +333,7 @@ final class CodeWriter {\n   ImmutableMap<ClassName, String> suggestedImports() {\n     // Find the simple names that can be imported, and the classes that they target.\n     Map<String, ClassName> simpleNameToType = new LinkedHashMap<>();\n-    for (TypeName typeName : emittedTypes) {\n+    for (TypeName typeName : importableTypes) {\n       if (!(typeName instanceof ClassName)) continue;\n       ClassName className = (ClassName) typeName;\n       if (simpleNameToType.containsKey(className.simpleName())) continue;\n"
    },
    {
        "commit_hash": "5b4f979a54b18b614efd264c2b71d6df38e666a2",
        "previous_commit_hash": "bd1db39b58e41fb8712e8604499c29db49f287d2",
        "diff_stats": {
            "additions": 12,
            "deletions": 0
        },
        "diff_content": "@@ -58,6 +58,18 @@ public final class FieldSpec {\n     codeWriter.emit(\";\\n\");\n   }\n \n+  public static FieldSpec of(Class<?> type, String name, Modifier... modifiers) {\n+    return of(TypeNames.forClass(type), name, modifiers);\n+  }\n+\n+  public static FieldSpec of(TypeName type, String name, Modifier... modifiers) {\n+    return new Builder()\n+        .type(type)\n+        .name(name)\n+        .addModifiers(modifiers)\n+        .build();\n+  }\n+\n   public static final class Builder {\n     private final List<AnnotationSpec> annotations = new ArrayList<>();\n     private final List<Modifier> modifiers = new ArrayList<>();\n"
    },
    {
        "commit_hash": "5b4f979a54b18b614efd264c2b71d6df38e666a2",
        "previous_commit_hash": "bd1db39b58e41fb8712e8604499c29db49f287d2",
        "diff_stats": {
            "additions": 20,
            "deletions": 7
        },
        "diff_content": "@@ -18,14 +18,15 @@ package com.squareup.javawriter.builders;\n import com.google.common.collect.ImmutableMap;\n import com.squareup.javawriter.ClassName;\n \n-import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkNotNull;\n \n /** A Java file containing a single top level class. */\n public final class JavaFile {\n+  public final String packageName;\n   public final TypeSpec typeSpec;\n \n   private JavaFile(Builder builder) {\n+    this.packageName = builder.packageName;\n     this.typeSpec = checkNotNull(builder.typeSpec);\n   }\n \n@@ -44,23 +45,35 @@ public final class JavaFile {\n   }\n \n   private void emit(ImmutableMap<ClassName, String> imports, CodeWriter codeWriter) {\n-    codeWriter.emit(\"package $L;\\n\", typeSpec.name.packageName());\n-    if (!imports.isEmpty()) {\n+    codeWriter.pushPackage(packageName);\n+\n+    if (!packageName.isEmpty()) {\n+      codeWriter.emit(\"package $L;\\n\", packageName);\n       codeWriter.emit(\"\\n\");\n+    }\n+\n+    if (!imports.isEmpty()) {\n       for (ClassName className : imports.keySet()) {\n         codeWriter.emit(\"import $L;\\n\", className);\n       }\n+      codeWriter.emit(\"\\n\");\n     }\n-    codeWriter.emit(\"\\n\");\n+\n     typeSpec.emit(codeWriter, null);\n+\n+    codeWriter.popPackage();\n   }\n \n   public static final class Builder {\n+    private String packageName = \"\";\n     private TypeSpec typeSpec;\n \n-    public Builder classSpec(TypeSpec typeSpec) {\n-      checkArgument(!typeSpec.name.enclosingClassName().isPresent(),\n-          \"Cannot create a JavaFile for %s\", typeSpec.name);\n+    public Builder packageName(String packageName) {\n+      this.packageName = checkNotNull(packageName);\n+      return this;\n+    }\n+\n+    public Builder typeSpec(TypeSpec typeSpec) {\n       this.typeSpec = typeSpec;\n       return this;\n     }\n"
    },
    {
        "commit_hash": "5b4f979a54b18b614efd264c2b71d6df38e666a2",
        "previous_commit_hash": "bd1db39b58e41fb8712e8604499c29db49f287d2",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -58,7 +58,7 @@ public final class MethodSpec {\n     this.snippets = ImmutableList.copyOf(builder.snippets);\n   }\n \n-  void emit(CodeWriter codeWriter, ClassName enclosing, ImmutableSet<Modifier> implicitModifiers) {\n+  void emit(CodeWriter codeWriter, String enclosingName, ImmutableSet<Modifier> implicitModifiers) {\n     codeWriter.emitAnnotations(annotations, false);\n     codeWriter.emitModifiers(modifiers, implicitModifiers);\n \n@@ -68,7 +68,7 @@ public final class MethodSpec {\n     }\n \n     if (name == Name.CONSTRUCTOR) {\n-      codeWriter.emit(\"$L(\", enclosing.simpleName());\n+      codeWriter.emit(\"$L(\", enclosingName);\n     } else {\n       codeWriter.emit(\"$T $L(\", returnType, name);\n     }\n"
    },
    {
        "commit_hash": "5b4f979a54b18b614efd264c2b71d6df38e666a2",
        "previous_commit_hash": "bd1db39b58e41fb8712e8604499c29db49f287d2",
        "diff_stats": {
            "additions": 27,
            "deletions": 6
        },
        "diff_content": "@@ -41,7 +41,7 @@ public final class TypeSpec {\n   public final ImmutableList<AnnotationSpec> annotations;\n   public final ImmutableSet<Modifier> modifiers;\n   public final Type type;\n-  public final ClassName name;\n+  public final String name;\n   public final ImmutableList<TypeVariableName> typeVariables;\n   public final TypeName superclass;\n   public final ImmutableList<TypeName> superinterfaces;\n@@ -49,6 +49,7 @@ public final class TypeSpec {\n   public final ImmutableMap<String, TypeSpec> enumConstants;\n   public final ImmutableList<FieldSpec> fieldSpecs;\n   public final ImmutableList<MethodSpec> methodSpecs;\n+  public final ImmutableList<TypeSpec> typeSpecs;\n \n   private TypeSpec(Builder builder) {\n     checkArgument(builder.name != null ^ builder.anonymousTypeArguments != null,\n@@ -89,6 +90,7 @@ public final class TypeSpec {\n     this.enumConstants = ImmutableMap.copyOf(builder.enumConstants);\n     this.fieldSpecs = ImmutableList.copyOf(builder.fieldSpecs);\n     this.methodSpecs = ImmutableList.copyOf(builder.methodSpecs);\n+    this.typeSpecs = ImmutableList.copyOf(builder.typeSpecs);\n   }\n \n   public boolean hasModifier(Modifier modifier) {\n@@ -103,7 +105,7 @@ public final class TypeSpec {\n         codeWriter.emit(anonymousTypeArguments);\n         codeWriter.emit(\")\");\n       }\n-      if (fieldSpecs.isEmpty() && methodSpecs.isEmpty()) {\n+      if (fieldSpecs.isEmpty() && methodSpecs.isEmpty() && typeSpecs.isEmpty()) {\n         return; // Avoid unnecessary braces \"{}\".\n       }\n       codeWriter.emit(\" {\\n\");\n@@ -114,7 +116,7 @@ public final class TypeSpec {\n     } else {\n       codeWriter.emitAnnotations(annotations, false);\n       codeWriter.emitModifiers(modifiers);\n-      codeWriter.emit(\"$L $L\", Ascii.toLowerCase(type.name()), name.simpleName());\n+      codeWriter.emit(\"$L $L\", Ascii.toLowerCase(type.name()), name);\n       codeWriter.emitTypeVariables(typeVariables);\n \n       List<TypeName> extendsTypes;\n@@ -152,6 +154,7 @@ public final class TypeSpec {\n       codeWriter.emit(\" {\\n\");\n     }\n \n+    codeWriter.pushType(this);\n     codeWriter.indent();\n     boolean firstMember = true;\n     for (Iterator<Map.Entry<String, TypeSpec>> i = enumConstants.entrySet().iterator();\n@@ -160,7 +163,13 @@ public final class TypeSpec {\n       if (!firstMember) codeWriter.emit(\"\\n\");\n       enumConstant.getValue().emit(codeWriter, enumConstant.getKey());\n       firstMember = false;\n-      codeWriter.emit(\"$L\", i.hasNext() ? \",\\n\" : \";\\n\");\n+      if (i.hasNext()) {\n+        codeWriter.emit(\"$L\", \",\\n\");\n+      } else if (!fieldSpecs.isEmpty() || !methodSpecs.isEmpty() || !typeSpecs.isEmpty()) {\n+        codeWriter.emit(\"$L\", \";\\n\");\n+      } else {\n+        codeWriter.emit(\"$L\", \"\\n\");\n+      }\n     }\n     for (FieldSpec fieldSpec : fieldSpecs) {\n       if (!firstMember) codeWriter.emit(\"\\n\");\n@@ -172,7 +181,13 @@ public final class TypeSpec {\n       methodSpec.emit(codeWriter, name, type.implicitMethodModifiers);\n       firstMember = false;\n     }\n+    for (TypeSpec typeSpec : typeSpecs) {\n+      if (!firstMember) codeWriter.emit(\"\\n\");\n+      typeSpec.emit(codeWriter, null);\n+      firstMember = false;\n+    }\n     codeWriter.unindent();\n+    codeWriter.popType();\n \n     if (enumName != null || anonymousTypeArguments != null) {\n       codeWriter.emit(\"}\");\n@@ -203,7 +218,7 @@ public final class TypeSpec {\n     private final List<AnnotationSpec> annotations = new ArrayList<>();\n     private final List<Modifier> modifiers = new ArrayList<>();\n     private Type type = Type.CLASS;\n-    private ClassName name;\n+    private String name;\n     private List<TypeVariableName> typeVariables = new ArrayList<>();\n     private TypeName superclass = ClassName.OBJECT;\n     private List<TypeName> superinterfaces = new ArrayList<>();\n@@ -211,6 +226,7 @@ public final class TypeSpec {\n     private Map<String, TypeSpec> enumConstants = new LinkedHashMap<>();\n     private List<FieldSpec> fieldSpecs = new ArrayList<>();\n     private List<MethodSpec> methodSpecs = new ArrayList<>();\n+    private List<TypeSpec> typeSpecs = new ArrayList<>();\n \n     public Builder addAnnotation(AnnotationSpec annotationSpec) {\n       this.annotations.add(annotationSpec);\n@@ -232,7 +248,7 @@ public final class TypeSpec {\n       return this;\n     }\n \n-    public Builder name(ClassName name) {\n+    public Builder name(String name) {\n       this.name = name;\n       return this;\n     }\n@@ -292,6 +308,11 @@ public final class TypeSpec {\n       return this;\n     }\n \n+    public Builder addType(TypeSpec typeSpec) {\n+      typeSpecs.add(typeSpec);\n+      return this;\n+    }\n+\n     public TypeSpec build() {\n       return new TypeSpec(this);\n     }\n"
    },
    {
        "commit_hash": "5b4f979a54b18b614efd264c2b71d6df38e666a2",
        "previous_commit_hash": "bd1db39b58e41fb8712e8604499c29db49f287d2",
        "diff_stats": {
            "additions": 9,
            "deletions": 27
        },
        "diff_content": "@@ -15,30 +15,17 @@\n  */\n package com.squareup.javawriter.builders;\n \n-import com.google.common.collect.ImmutableList;\n-import com.squareup.javawriter.ClassName;\n import java.util.Date;\n import org.junit.Test;\n \n import static com.google.common.truth.Truth.assertThat;\n-import static org.junit.Assert.fail;\n \n public final class JavaFileTest {\n-  @Test public void cannotEmitNestedClass() throws Exception {\n-    TypeSpec tacoSupremo = new TypeSpec.Builder()\n-        .name(ClassName.create(\"com.squareup.tacos\", ImmutableList.of(\"Taco\"), \"Supremo\"))\n-        .build();\n-    try {\n-      new JavaFile.Builder().classSpec(tacoSupremo);\n-      fail();\n-    } catch (IllegalArgumentException expected) {\n-    }\n-  }\n-\n   @Test public void noImports() throws Exception {\n     String source = new JavaFile.Builder()\n-        .classSpec(new TypeSpec.Builder()\n-            .name(ClassName.create(\"com.squareup.tacos\", \"Taco\"))\n+        .packageName(\"com.squareup.tacos\")\n+        .typeSpec(new TypeSpec.Builder()\n+            .name(\"Taco\")\n             .build())\n         .build()\n         .toString();\n@@ -51,8 +38,9 @@ public final class JavaFileTest {\n \n   @Test public void singleImport() throws Exception {\n     String source = new JavaFile.Builder()\n-        .classSpec(new TypeSpec.Builder()\n-            .name(ClassName.create(\"com.squareup.tacos\", \"Taco\"))\n+        .packageName(\"com.squareup.tacos\")\n+        .typeSpec(new TypeSpec.Builder()\n+            .name(\"Taco\")\n             .addField(new FieldSpec.Builder()\n                 .type(Date.class)\n                 .name(\"madeFreshDate\")\n@@ -72,8 +60,9 @@ public final class JavaFileTest {\n \n   @Test public void conflictingImports() throws Exception {\n     String source = new JavaFile.Builder()\n-        .classSpec(new TypeSpec.Builder()\n-            .name(ClassName.create(\"com.squareup.tacos\", \"Taco\"))\n+        .packageName(\"com.squareup.tacos\")\n+        .typeSpec(new TypeSpec.Builder()\n+            .name(\"Taco\")\n             .addField(new FieldSpec.Builder()\n                 .type(Date.class)\n                 .name(\"madeFreshDate\")\n@@ -96,11 +85,4 @@ public final class JavaFileTest {\n         + \"  java.sql.Date madeFreshDatabaseDate;\\n\"\n         + \"}\\n\");\n   }\n-\n-  private String toString(TypeSpec typeSpec) {\n-    return new JavaFile.Builder()\n-        .classSpec(typeSpec)\n-        .build()\n-        .toString();\n-  }\n }\n"
    },
    {
        "commit_hash": "5b4f979a54b18b614efd264c2b71d6df38e666a2",
        "previous_commit_hash": "bd1db39b58e41fb8712e8604499c29db49f287d2",
        "diff_stats": {
            "additions": 132,
            "deletions": 76
        },
        "diff_content": "@@ -31,9 +31,11 @@ import static com.google.common.truth.Truth.assertThat;\n import static org.junit.Assert.fail;\n \n public final class TypeSpecTest {\n+  private final String tacosPackage = \"com.squareup.tacos\";\n+\n   @Test public void basic() throws Exception {\n     TypeSpec taco = new TypeSpec.Builder()\n-        .name(ClassName.create(\"com.squareup.tacos\", \"Taco\"))\n+        .name(\"Taco\")\n         .addMethod(new MethodSpec.Builder()\n             .name(\"toString\")\n             .addAnnotation(Override.class)\n@@ -58,7 +60,7 @@ public final class TypeSpecTest {\n \n   @Test public void interestingTypes() throws Exception {\n     TypeSpec taco = new TypeSpec.Builder()\n-        .name(ClassName.create(\"com.squareup.tacos\", \"Taco\"))\n+        .name(\"Taco\")\n         .addField(new FieldSpec.Builder()\n             .type(ParameterizedTypeName.create(ClassName.fromClass(List.class),\n                 WildcardName.createWithUpperBound(ClassName.fromClass(Object.class))))\n@@ -92,14 +94,14 @@ public final class TypeSpecTest {\n   }\n \n   @Test public void anonymousInnerClass() throws Exception {\n-    ClassName foo = ClassName.create(\"com.squareup.tacos\", \"Foo\");\n-    ClassName bar = ClassName.create(\"com.squareup.tacos\", \"Bar\");\n+    ClassName foo = ClassName.create(tacosPackage, \"Foo\");\n+    ClassName bar = ClassName.create(tacosPackage, \"Bar\");\n     ClassName thingThang = ClassName.create(\n-        \"com.squareup.tacos\", ImmutableList.of(\"Thing\"), \"Thang\");\n+        tacosPackage, ImmutableList.of(\"Thing\"), \"Thang\");\n     ParameterizedTypeName thingThangOfFooBar\n         = ParameterizedTypeName.create(thingThang, foo, bar);\n-    ClassName thung = ClassName.create(\"com.squareup.tacos\", \"Thung\");\n-    ClassName simpleThung = ClassName.create(\"com.squareup.tacos\", \"SimpleThung\");\n+    ClassName thung = ClassName.create(tacosPackage, \"Thung\");\n+    ClassName simpleThung = ClassName.create(tacosPackage, \"SimpleThung\");\n     ParameterizedTypeName thungOfSuperBar\n         = ParameterizedTypeName.create(thung, WildcardName.createWithLowerBound(bar));\n     ParameterizedTypeName thungOfSuperFoo\n@@ -135,7 +137,7 @@ public final class TypeSpecTest {\n             .build())\n         .build();\n     TypeSpec taco = new TypeSpec.Builder()\n-        .name(ClassName.create(\"com.squareup.tacos\", \"Taco\"))\n+        .name(\"Taco\")\n         .addField(new FieldSpec.Builder()\n             .addModifiers(Modifier.STATIC, Modifier.FINAL, Modifier.FINAL)\n             .type(thingThangOfFooBar)\n@@ -144,19 +146,13 @@ public final class TypeSpecTest {\n             .build())\n         .build();\n \n-    // TODO: import Thing, and change references from \"Thang\" to \"Thing.Thang\"\n     assertThat(toString(taco)).isEqualTo(\"\"\n         + \"package com.squareup.tacos;\\n\"\n         + \"\\n\"\n-        + \"import com.squareup.tacos.Bar;\\n\"\n-        + \"import com.squareup.tacos.Foo;\\n\"\n-        + \"import com.squareup.tacos.SimpleThung;\\n\"\n-        + \"import com.squareup.tacos.Thing.Thang;\\n\"\n-        + \"import com.squareup.tacos.Thung;\\n\"\n         + \"import java.lang.Override;\\n\"\n         + \"\\n\"\n         + \"class Taco {\\n\"\n-        + \"  static final Thang<Foo, Bar> NAME = new Thang<Foo, Bar>() {\\n\"\n+        + \"  static final Thing.Thang<Foo, Bar> NAME = new Thing.Thang<Foo, Bar>() {\\n\"\n         + \"    @Override\\n\"\n         + \"    public Thung<? super Bar> call(final Thung<? super Foo> thung) {\\n\"\n         + \"      return new SimpleThung<Bar>(thung) {\\n\"\n@@ -172,7 +168,7 @@ public final class TypeSpecTest {\n \n   @Test public void annotatedParameters() throws Exception {\n     TypeSpec service = new TypeSpec.Builder()\n-        .name(ClassName.create(\"com.squareup.tacos\", \"Foo\"))\n+        .name(\"Foo\")\n         .addMethod(new MethodSpec.Builder()\n             .addModifiers(Modifier.PUBLIC)\n             .constructor()\n@@ -181,25 +177,25 @@ public final class TypeSpecTest {\n                 .name(\"id\")\n                 .build())\n             .addParameter(new ParameterSpec.Builder()\n-                .addAnnotation(ClassName.create(\"com.squareup.tacos\", \"Ping\"))\n+                .addAnnotation(ClassName.create(tacosPackage, \"Ping\"))\n                 .type(String.class)\n                 .name(\"one\")\n                 .build())\n             .addParameter(new ParameterSpec.Builder()\n-                .addAnnotation(ClassName.create(\"com.squareup.tacos\", \"Ping\"))\n+                .addAnnotation(ClassName.create(tacosPackage, \"Ping\"))\n                 .type(String.class)\n                 .name(\"two\")\n                 .build())\n             .addParameter(new ParameterSpec.Builder()\n                 .addAnnotation(new AnnotationSpec.Builder()\n-                    .type(ClassName.create(\"com.squareup.tacos\", \"Pong\"))\n+                    .type(ClassName.create(tacosPackage, \"Pong\"))\n                     .addMember(\"value\", \"$S\", \"pong\")\n                     .build())\n                 .type(String.class)\n                 .name(\"three\")\n                 .build())\n             .addParameter(new ParameterSpec.Builder()\n-                .addAnnotation(ClassName.create(\"com.squareup.tacos\", \"Ping\"))\n+                .addAnnotation(ClassName.create(tacosPackage, \"Ping\"))\n                 .type(String.class)\n                 .name(\"four\")\n                 .build())\n@@ -210,8 +206,6 @@ public final class TypeSpecTest {\n     assertThat(toString(service)).isEqualTo(\"\"\n         + \"package com.squareup.tacos;\\n\"\n         + \"\\n\"\n-        + \"import com.squareup.tacos.Ping;\\n\"\n-        + \"import com.squareup.tacos.Pong;\\n\"\n         + \"import java.lang.String;\\n\"\n         + \"\\n\"\n         + \"class Foo {\\n\"\n@@ -223,19 +217,19 @@ public final class TypeSpecTest {\n   }\n \n   @Test public void retrofitStyleInterface() throws Exception {\n-    ClassName observable = ClassName.create(\"com.squareup.tacos\", \"Observable\");\n-    ClassName fooBar = ClassName.create(\"com.squareup.tacos\", \"FooBar\");\n-    ClassName thing = ClassName.create(\"com.squareup.tacos\", \"Thing\");\n-    ClassName things = ClassName.create(\"com.squareup.tacos\", \"Things\");\n+    ClassName observable = ClassName.create(tacosPackage, \"Observable\");\n+    ClassName fooBar = ClassName.create(tacosPackage, \"FooBar\");\n+    ClassName thing = ClassName.create(tacosPackage, \"Thing\");\n+    ClassName things = ClassName.create(tacosPackage, \"Things\");\n     ClassName map = ClassName.create(\"java.util\", \"Map\");\n     ClassName string = ClassName.create(\"java.lang\", \"String\");\n-    ClassName headers = ClassName.create(\"com.squareup.tacos\", \"Headers\");\n-    ClassName post = ClassName.create(\"com.squareup.tacos\", \"POST\");\n-    ClassName body = ClassName.create(\"com.squareup.tacos\", \"Body\");\n-    ClassName queryMap = ClassName.create(\"com.squareup.tacos\", \"QueryMap\");\n-    ClassName header = ClassName.create(\"com.squareup.tacos\", \"Header\");\n+    ClassName headers = ClassName.create(tacosPackage, \"Headers\");\n+    ClassName post = ClassName.create(tacosPackage, \"POST\");\n+    ClassName body = ClassName.create(tacosPackage, \"Body\");\n+    ClassName queryMap = ClassName.create(tacosPackage, \"QueryMap\");\n+    ClassName header = ClassName.create(tacosPackage, \"Header\");\n     TypeSpec service = new TypeSpec.Builder()\n-        .name(ClassName.create(\"com.squareup.tacos\", \"Service\"))\n+        .name(\"Service\")\n         .type(TypeSpec.Type.INTERFACE)\n         .addMethod(new MethodSpec.Builder()\n             .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)\n@@ -277,15 +271,6 @@ public final class TypeSpecTest {\n     assertThat(toString(service)).isEqualTo(\"\"\n         + \"package com.squareup.tacos;\\n\"\n         + \"\\n\"\n-        + \"import com.squareup.tacos.Body;\\n\"\n-        + \"import com.squareup.tacos.FooBar;\\n\"\n-        + \"import com.squareup.tacos.Header;\\n\"\n-        + \"import com.squareup.tacos.Headers;\\n\"\n-        + \"import com.squareup.tacos.Observable;\\n\"\n-        + \"import com.squareup.tacos.POST;\\n\"\n-        + \"import com.squareup.tacos.QueryMap;\\n\"\n-        + \"import com.squareup.tacos.Thing;\\n\"\n-        + \"import com.squareup.tacos.Things;\\n\"\n         + \"import java.lang.String;\\n\"\n         + \"import java.util.Map;\\n\"\n         + \"\\n\"\n@@ -302,11 +287,11 @@ public final class TypeSpecTest {\n \n   @Test public void annotatedField() throws Exception {\n     TypeSpec taco = new TypeSpec.Builder()\n-        .name(ClassName.create(\"com.squareup.tacos\", \"Taco\"))\n+        .name(\"Taco\")\n         .addField(new FieldSpec.Builder()\n             .addAnnotation(new AnnotationSpec.Builder()\n-                .type(ClassName.create(\"com.squareup.tacos\", \"JsonAdapter\"))\n-                .addMember(\"value\", \"$T.class\", ClassName.create(\"com.squareup.tacos\", \"Foo\"))\n+                .type(ClassName.create(tacosPackage, \"JsonAdapter\"))\n+                .addMember(\"value\", \"$T.class\", ClassName.create(tacosPackage, \"Foo\"))\n                 .build())\n             .addModifiers(Modifier.PRIVATE, Modifier.FINAL)\n             .type(String.class)\n@@ -316,8 +301,6 @@ public final class TypeSpecTest {\n     assertThat(toString(taco)).isEqualTo(\"\"\n         + \"package com.squareup.tacos;\\n\"\n         + \"\\n\"\n-        + \"import com.squareup.tacos.Foo;\\n\"\n-        + \"import com.squareup.tacos.JsonAdapter;\\n\"\n         + \"import java.lang.String;\\n\"\n         + \"\\n\"\n         + \"class Taco {\\n\"\n@@ -327,23 +310,20 @@ public final class TypeSpecTest {\n   }\n \n   @Test public void annotatedClass() throws Exception {\n-    ClassName someType = ClassName.create(\"com.squareup.tacos\", \"SomeType\");\n+    ClassName someType = ClassName.create(tacosPackage, \"SomeType\");\n     TypeSpec taco = new TypeSpec.Builder()\n         .addAnnotation(new AnnotationSpec.Builder()\n-            .type(ClassName.create(\"com.squareup.tacos\", \"Something\"))\n+            .type(ClassName.create(tacosPackage, \"Something\"))\n             .addMember(\"hi\", \"$T.$N\", someType, \"FIELD\")\n             .addMember(\"hey\", \"$L\", 12)\n             .addMember(\"hello\", \"$S\", \"goodbye\")\n             .build())\n-        .name(ClassName.create(\"com.squareup.tacos\", \"Foo\"))\n+        .name(\"Foo\")\n         .addModifiers(Modifier.PUBLIC)\n         .build();\n     assertThat(toString(taco)).isEqualTo(\"\"\n         + \"package com.squareup.tacos;\\n\"\n         + \"\\n\"\n-        + \"import com.squareup.tacos.SomeType;\\n\"\n-        + \"import com.squareup.tacos.Something;\\n\"\n-        + \"\\n\"\n         + \"@Something(\\n\"\n         + \"    hello = \\\"goodbye\\\",\\n\"\n         + \"    hey = 12,\\n\"\n@@ -356,7 +336,7 @@ public final class TypeSpecTest {\n   @Test public void enumWithSubclassing() throws Exception {\n       TypeSpec roshambo = new TypeSpec.Builder()\n         .type(TypeSpec.Type.ENUM)\n-        .name(ClassName.create(\"com.squareup.tacos\", \"Roshambo\"))\n+        .name(\"Roshambo\")\n         .addModifiers(Modifier.PUBLIC)\n         .addEnumConstant(\"ROCK\")\n         .addEnumConstant(\"PAPER\", new TypeSpec.Builder()\n@@ -421,7 +401,7 @@ public final class TypeSpecTest {\n     try {\n       new TypeSpec.Builder()\n         .type(TypeSpec.Type.ENUM)\n-        .name(ClassName.create(\"com.squareup.tacos\", \"Roshambo\"))\n+        .name(\"Roshambo\")\n         .build();\n       fail();\n     } catch (IllegalArgumentException expected) {\n@@ -432,7 +412,7 @@ public final class TypeSpecTest {\n     try {\n       new TypeSpec.Builder()\n         .type(TypeSpec.Type.CLASS)\n-        .name(ClassName.create(\"com.squareup.tacos\", \"Roshambo\"))\n+        .name(\"Roshambo\")\n         .addEnumConstant(\"ROCK\")\n         .build();\n       fail();\n@@ -443,7 +423,7 @@ public final class TypeSpecTest {\n   @Test public void enumWithMembersButNoConstructorCall() throws Exception {\n     TypeSpec roshambo = new TypeSpec.Builder()\n         .type(TypeSpec.Type.ENUM)\n-        .name(ClassName.create(\"com.squareup.tacos\", \"Roshambo\"))\n+        .name(\"Roshambo\")\n         .addEnumConstant(\"SPOCK\", new TypeSpec.Builder()\n             .anonymousTypeArguments()\n             .addMethod(new MethodSpec.Builder()\n@@ -467,13 +447,13 @@ public final class TypeSpecTest {\n         + \"    public String toString() {\\n\"\n         + \"      return \\\"west side\\\";\\n\"\n         + \"    }\\n\"\n-        + \"  };\\n\"\n+        + \"  }\\n\"\n         + \"}\\n\");\n   }\n \n   @Test public void methodThrows() throws Exception {\n     TypeSpec taco = new TypeSpec.Builder()\n-        .name(ClassName.create(\"com.squareup.tacos\", \"Taco\"))\n+        .name(\"Taco\")\n         .addMethod(new MethodSpec.Builder()\n             .name(\"throwOne\")\n             .addException(IOException.class)\n@@ -481,13 +461,12 @@ public final class TypeSpecTest {\n         .addMethod(new MethodSpec.Builder()\n             .name(\"throwTwo\")\n             .addException(IOException.class)\n-            .addException(ClassName.create(\"com.squareup.tacos\", \"SourCreamException\"))\n+            .addException(ClassName.create(tacosPackage, \"SourCreamException\"))\n             .build())\n         .build();\n     assertThat(toString(taco)).isEqualTo(\"\"\n         + \"package com.squareup.tacos;\\n\"\n         + \"\\n\"\n-        + \"import com.squareup.tacos.SourCreamException;\\n\"\n         + \"import java.io.IOException;\\n\"\n         + \"\\n\"\n         + \"class Taco {\\n\"\n@@ -502,9 +481,9 @@ public final class TypeSpecTest {\n   @Test public void typeVariables() throws Exception {\n     TypeVariableName t = TypeVariableName.create(\"T\");\n     TypeVariableName p = TypeVariableName.create(\"P\", ClassName.fromClass(Number.class));\n-    ClassName location = ClassName.create(\"com.squareup.tacos\", \"Location\");\n+    ClassName location = ClassName.create(tacosPackage, \"Location\");\n     TypeSpec typeSpec = new TypeSpec.Builder()\n-        .name(location)\n+        .name(\"Location\")\n         .addTypeVariable(t)\n         .addTypeVariable(p)\n         .addSuperinterface(ParameterizedTypeName.create(ClassName.fromClass(Comparable.class), p))\n@@ -543,7 +522,6 @@ public final class TypeSpecTest {\n     assertThat(toString(typeSpec)).isEqualTo(\"\"\n         + \"package com.squareup.tacos;\\n\"\n         + \"\\n\"\n-        + \"import com.squareup.tacos.Location;\\n\"\n         + \"import java.lang.Comparable;\\n\"\n         + \"import java.lang.Number;\\n\"\n         + \"import java.lang.Override;\\n\"\n@@ -568,10 +546,10 @@ public final class TypeSpecTest {\n   }\n \n   @Test public void classImplementsExtends() throws Exception {\n-    ClassName taco = ClassName.create(\"com.squareup.tacos\", \"Taco\");\n-    ClassName food = ClassName.create(\"com.squareup.taco\", \"Food\");\n+    ClassName taco = ClassName.create(tacosPackage, \"Taco\");\n+    ClassName food = ClassName.create(\"com.squareup.tacos\", \"Food\");\n     TypeSpec typeSpec = new TypeSpec.Builder()\n-        .name(taco)\n+        .name(\"Taco\")\n         .addModifiers(Modifier.ABSTRACT)\n         .superclass(ParameterizedTypeName.create(AbstractSet.class, food))\n         .addSuperinterface(Serializable.class)\n@@ -580,8 +558,6 @@ public final class TypeSpecTest {\n     assertThat(toString(typeSpec)).isEqualTo(\"\"\n         + \"package com.squareup.tacos;\\n\"\n         + \"\\n\"\n-        + \"import com.squareup.taco.Food;\\n\"\n-        + \"import com.squareup.tacos.Taco;\\n\"\n         + \"import java.io.Serializable;\\n\"\n         + \"import java.lang.Comparable;\\n\"\n         + \"import java.util.AbstractSet;\\n\"\n@@ -592,17 +568,16 @@ public final class TypeSpecTest {\n   }\n \n   @Test public void enumImplements() throws Exception {\n-    ClassName food = ClassName.create(\"com.squareup.taco\", \"Food\");\n     TypeSpec typeSpec = new TypeSpec.Builder()\n         .type(TypeSpec.Type.ENUM)\n-        .name(food)\n+        .name(\"Food\")\n         .addSuperinterface(Serializable.class)\n         .addSuperinterface(Cloneable.class)\n         .addEnumConstant(\"LEAN_GROUND_BEEF\")\n         .addEnumConstant(\"SHREDDED_CHEESE\")\n         .build();\n     assertThat(toString(typeSpec)).isEqualTo(\"\"\n-        + \"package com.squareup.taco;\\n\"\n+        + \"package com.squareup.tacos;\\n\"\n         + \"\\n\"\n         + \"import java.io.Serializable;\\n\"\n         + \"import java.lang.Cloneable;\\n\"\n@@ -610,22 +585,21 @@ public final class TypeSpecTest {\n         + \"enum Food implements Serializable, Cloneable {\\n\"\n         + \"  LEAN_GROUND_BEEF,\\n\"\n         + \"\\n\"\n-        + \"  SHREDDED_CHEESE;\\n\"\n+        + \"  SHREDDED_CHEESE\\n\"\n         + \"}\\n\");\n   }\n \n   @Test public void interfaceExtends() throws Exception {\n-    ClassName taco = ClassName.create(\"com.squareup.tacos\", \"Taco\");\n+    ClassName taco = ClassName.create(tacosPackage, \"Taco\");\n     TypeSpec typeSpec = new TypeSpec.Builder()\n         .type(TypeSpec.Type.INTERFACE)\n-        .name(taco)\n+        .name(\"Taco\")\n         .addSuperinterface(Serializable.class)\n         .addSuperinterface(ParameterizedTypeName.create(Comparable.class, taco))\n         .build();\n     assertThat(toString(typeSpec)).isEqualTo(\"\"\n         + \"package com.squareup.tacos;\\n\"\n         + \"\\n\"\n-        + \"import com.squareup.tacos.Taco;\\n\"\n         + \"import java.io.Serializable;\\n\"\n         + \"import java.lang.Comparable;\\n\"\n         + \"\\n\"\n@@ -633,9 +607,91 @@ public final class TypeSpecTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void nestedClasses() throws Exception {\n+    ClassName taco = ClassName.create(tacosPackage, ImmutableList.of(\"Combo\"), \"Taco\");\n+    ClassName topping = ClassName.create(\n+        tacosPackage, ImmutableList.of(\"Combo\", \"Taco\"), \"Topping\");\n+    ClassName chips = ClassName.create(tacosPackage, ImmutableList.of(\"Combo\"), \"Chips\");\n+    ClassName sauce = ClassName.create(tacosPackage, ImmutableList.of(\"Combo\"), \"Sauce\");\n+    TypeSpec typeSpec = new TypeSpec.Builder()\n+        .name(\"Combo\")\n+        .addField(FieldSpec.of(taco, \"taco\"))\n+        .addField(FieldSpec.of(chips, \"chips\"))\n+        .addType(new TypeSpec.Builder()\n+            .addModifiers(Modifier.STATIC)\n+            .name(taco.simpleName())\n+            .addField(FieldSpec.of(ParameterizedTypeName.create(List.class, topping), \"toppings\"))\n+            .addField(FieldSpec.of(sauce, \"sauce\"))\n+            .addType(new TypeSpec.Builder()\n+                .type(TypeSpec.Type.ENUM)\n+                .name(topping.simpleName())\n+                .addEnumConstant(\"SHREDDED_CHEESE\")\n+                .addEnumConstant(\"LEAN_GROUND_BEEF\")\n+                .build())\n+            .build())\n+        .addType(new TypeSpec.Builder()\n+            .addModifiers(Modifier.STATIC)\n+            .name(chips.simpleName())\n+            .addField(FieldSpec.of(topping, \"topping\"))\n+            .addField(FieldSpec.of(sauce, \"dippingSauce\"))\n+            .build())\n+        .addType(new TypeSpec.Builder()\n+            .type(TypeSpec.Type.ENUM)\n+            .name(sauce.simpleName())\n+            .addEnumConstant(\"SOUR_CREAM\")\n+            .addEnumConstant(\"SALSA\")\n+            .addEnumConstant(\"QUESO\")\n+            .addEnumConstant(\"MILD\")\n+            .addEnumConstant(\"FIRE\")\n+            .build())\n+        .build();\n+\n+    assertThat(toString(typeSpec)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import java.util.List;\\n\"\n+        + \"\\n\"\n+        + \"class Combo {\\n\"\n+        + \"  Taco taco;\\n\"\n+        + \"\\n\"\n+        + \"  Chips chips;\\n\"\n+        + \"\\n\"\n+        + \"  static class Taco {\\n\"\n+        + \"    List<Topping> toppings;\\n\"\n+        + \"\\n\"\n+        + \"    Sauce sauce;\\n\"\n+        + \"\\n\"\n+        + \"    enum Topping {\\n\"\n+        + \"      SHREDDED_CHEESE,\\n\"\n+        + \"\\n\"\n+        + \"      LEAN_GROUND_BEEF\\n\"\n+        + \"    }\\n\"\n+        + \"  }\\n\"\n+        + \"\\n\"\n+        + \"  static class Chips {\\n\"\n+        + \"    Taco.Topping topping;\\n\"\n+        + \"\\n\"\n+        + \"    Sauce dippingSauce;\\n\"\n+        + \"  }\\n\"\n+        + \"\\n\"\n+        + \"  enum Sauce {\\n\"\n+        + \"    SOUR_CREAM,\\n\"\n+        + \"\\n\"\n+        + \"    SALSA,\\n\"\n+        + \"\\n\"\n+        + \"    QUESO,\\n\"\n+        + \"\\n\"\n+        + \"    MILD,\\n\"\n+        + \"\\n\"\n+        + \"    FIRE\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n   private String toString(TypeSpec typeSpec) {\n     return new JavaFile.Builder()\n-        .classSpec(typeSpec)\n+        .packageName(tacosPackage)\n+        .typeSpec(typeSpec)\n         .build()\n         .toString();\n   }\n"
    },
    {
        "commit_hash": "8c0ca2307bc82ffc15dde0f0dd9eb105382fdb41",
        "previous_commit_hash": "d141cfb091f782eb18385c7c5d5e40326a6d883c",
        "diff_stats": {
            "additions": 0,
            "deletions": 77
        },
        "diff_content": "@@ -1,77 +0,0 @@\n-/*\n- * Copyright (C) 2014 Google, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.squareup.javawriter;\n-\n-import com.google.common.collect.ImmutableSet;\n-import com.google.common.collect.Iterables;\n-import com.google.common.collect.Maps;\n-import java.io.IOException;\n-import java.util.Map.Entry;\n-import java.util.Set;\n-import java.util.SortedMap;\n-\n-import static com.squareup.javawriter.Writables.toStringWritable;\n-\n-public final class AnnotationWriter implements Writable, HasClassReferences {\n-  private final ClassName annotationName;\n-  private final SortedMap<String, Writable> memberMap = Maps.newTreeMap();\n-\n-  AnnotationWriter(ClassName annotationName) {\n-    this.annotationName = annotationName;\n-  }\n-\n-  public void setValue(String value) {\n-    setMember(\"value\", value);\n-  }\n-\n-  public void setMember(String name, int value) {\n-    memberMap.put(name, toStringWritable(value));\n-  }\n-\n-  public void setMember(String name, String value) {\n-    memberMap.put(name, toStringWritable(StringLiteral.forValue(value)));\n-  }\n-\n-  @Override\n-  public Appendable write(Appendable appendable, Context context) throws IOException {\n-    appendable.append('@');\n-    annotationName.write(appendable, context);\n-    if (!memberMap.isEmpty()) {\n-      appendable.append('(');\n-      if (memberMap.size() == 1) {\n-        Entry<String, Writable> onlyEntry = Iterables.getOnlyElement(memberMap.entrySet());\n-        if (!onlyEntry.getKey().equals(\"value\")) {\n-          appendable.append(onlyEntry.getKey()).append(\" = \");\n-        }\n-        onlyEntry.getValue().write(appendable, context);\n-      } else {\n-        String sep = \"\";\n-        for (Entry<String, Writable> entry : memberMap.entrySet()) {\n-          appendable.append(sep).append(entry.getKey()).append(\" = \");\n-          entry.getValue().write(appendable, context);\n-          sep = \", \";\n-        }\n-      }\n-      appendable.append(')');\n-    }\n-    return appendable;\n-  }\n-\n-  @Override\n-  public Set<ClassName> referencedClasses() {\n-    return ImmutableSet.of(annotationName);\n-  }\n-}\n"
    },
    {
        "commit_hash": "8c0ca2307bc82ffc15dde0f0dd9eb105382fdb41",
        "previous_commit_hash": "d141cfb091f782eb18385c7c5d5e40326a6d883c",
        "diff_stats": {
            "additions": 0,
            "deletions": 101
        },
        "diff_content": "@@ -1,101 +0,0 @@\n-/*\n- * Copyright (C) 2014 Square, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.squareup.javawriter;\n-\n-import com.google.common.base.Optional;\n-import com.google.common.collect.FluentIterable;\n-import com.google.common.collect.ImmutableList;\n-import java.io.IOException;\n-import java.util.Set;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.type.TypeMirror;\n-\n-public final class AnonymousClassWriter implements Writable, HasClassReferences {\n-  public static AnonymousClassWriter forClassName(ClassName name) {\n-    return new AnonymousClassWriter(name);\n-  }\n-\n-  public static AnonymousClassWriter forParameterizedTypeName(ParameterizedTypeName name) {\n-    return new AnonymousClassWriter(name);\n-  }\n-\n-  private final TypeName supertypeOrImplementedInterface;\n-  private Optional<Snippet> constructorArguments;\n-  private final ClassBodyWriter body;\n-\n-  AnonymousClassWriter(TypeName supertypeOrImplementedInterface) {\n-    this.supertypeOrImplementedInterface = supertypeOrImplementedInterface;\n-    this.constructorArguments = Optional.absent();\n-    this.body = ClassBodyWriter.forAnonymousType();\n-  }\n-\n-  public void setConstructorArguments(Snippet parameters) {\n-    constructorArguments = Optional.of(parameters);\n-  }\n-\n-  public void setConstructorArguments(String parameters, Object... args) {\n-    setConstructorArguments(Snippet.format(parameters, args));\n-  }\n-\n-  public MethodWriter addMethod(TypeWriter returnType, String name) {\n-    return body.addMethod(returnType, name);\n-  }\n-\n-  public MethodWriter addMethod(TypeMirror returnType, String name) {\n-    return body.addMethod(returnType, name);\n-  }\n-\n-  public MethodWriter addMethod(TypeName returnType, String name) {\n-    return body.addMethod(returnType, name);\n-  }\n-\n-  public MethodWriter addMethod(Class<?> returnType, String name) {\n-    return body.addMethod(returnType, name);\n-  }\n-\n-  public FieldWriter addField(Class<?> type, String name) {\n-    return body.addField(type, name);\n-  }\n-\n-  public FieldWriter addField(TypeElement type, String name) {\n-    return body.addField(type, name);\n-  }\n-\n-  public FieldWriter addField(TypeName type, String name) {\n-    return body.addField(type, name);\n-  }\n-\n-  @Override\n-  public Set<ClassName> referencedClasses() {\n-    return FluentIterable.from(ImmutableList.of(supertypeOrImplementedInterface, body))\n-        .transformAndConcat(GET_REFERENCED_CLASSES)\n-        .toSet();\n-  }\n-\n-  @Override\n-  public Appendable write(Appendable appendable, Context context) throws IOException {\n-    appendable.append(\"new \");\n-    supertypeOrImplementedInterface.write(appendable, context);\n-    appendable.append('(');\n-    if (constructorArguments.isPresent()) {\n-      constructorArguments.get().write(appendable, context);\n-    }\n-    appendable.append(\") {\");\n-    body.write(appendable, context);\n-    appendable.append('}');\n-    return appendable;\n-  }\n-}\n"
    },
    {
        "commit_hash": "8c0ca2307bc82ffc15dde0f0dd9eb105382fdb41",
        "previous_commit_hash": "d141cfb091f782eb18385c7c5d5e40326a6d883c",
        "diff_stats": {
            "additions": 5,
            "deletions": 21
        },
        "diff_content": "@@ -15,42 +15,26 @@\n  */\n package com.squareup.javawriter;\n \n-import java.io.IOException;\n-import java.util.Set;\n-\n-final class ArrayTypeName implements TypeName {\n+public final class ArrayTypeName implements TypeName {\n   private final TypeName componentType;\n \n   ArrayTypeName(TypeName componentType) {\n     this.componentType = componentType;\n   }\n \n-  @Override\n-  public Set<ClassName> referencedClasses() {\n-    return componentType.referencedClasses();\n-  }\n-\n-  @Override\n-  public Appendable write(Appendable appendable, Context context) throws IOException {\n-    return componentType.write(appendable, context).append(\"[]\");\n+  public TypeName componentType() {\n+    return componentType;\n   }\n \n-  @Override\n-  public boolean equals(Object obj) {\n+  @Override public boolean equals(Object obj) {\n     return (obj instanceof ArrayTypeName)\n         & this.componentType.equals(((ArrayTypeName) obj).componentType);\n   }\n \n-  @Override\n-  public int hashCode() {\n+  @Override public int hashCode() {\n     return componentType.hashCode();\n   }\n \n-  @Override\n-  public String toString() {\n-    return Writables.writeToString(this);\n-  }\n-\n   public static ArrayTypeName create(TypeName componentType) {\n     return new ArrayTypeName(componentType);\n   }\n"
    },
    {
        "commit_hash": "8c0ca2307bc82ffc15dde0f0dd9eb105382fdb41",
        "previous_commit_hash": "d141cfb091f782eb18385c7c5d5e40326a6d883c",
        "diff_stats": {
            "additions": 0,
            "deletions": 56
        },
        "diff_content": "@@ -1,56 +0,0 @@\n-/*\n- * Copyright (C) 2014 Google, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.squareup.javawriter;\n-\n-import com.google.common.collect.FluentIterable;\n-import com.google.common.collect.Lists;\n-import java.io.IOException;\n-import java.util.List;\n-import java.util.Set;\n-\n-public final class BlockWriter implements Writable, HasClassReferences {\n-  private final List<Snippet> snippets;\n-\n-  BlockWriter() {\n-    this.snippets = Lists.newArrayList();\n-  }\n-\n-  public BlockWriter addSnippet(String snippet, Object... args) {\n-    snippets.add(Snippet.format(snippet, args));\n-    return this;\n-  }\n-\n-  public BlockWriter addSnippet(Snippet snippet) {\n-    snippets.add(snippet);\n-    return this;\n-  }\n-\n-  boolean isEmpty() {\n-    return snippets.isEmpty();\n-  }\n-\n-  @Override\n-  public Appendable write(Appendable appendable, Context context) throws IOException {\n-    return Writables.Joiner.on('\\n').appendTo(appendable, context, snippets);\n-  }\n-\n-  @Override\n-  public Set<ClassName> referencedClasses() {\n-    return FluentIterable.from(snippets)\n-        .transformAndConcat(GET_REFERENCED_CLASSES)\n-        .toSet();\n-  }\n-}\n"
    },
    {
        "commit_hash": "8c0ca2307bc82ffc15dde0f0dd9eb105382fdb41",
        "previous_commit_hash": "d141cfb091f782eb18385c7c5d5e40326a6d883c",
        "diff_stats": {
            "additions": 0,
            "deletions": 175
        },
        "diff_content": "@@ -1,175 +0,0 @@\n-/*\n- * Copyright (C) 2014 Square, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.squareup.javawriter;\n-\n-import com.google.common.base.Optional;\n-import com.google.common.collect.FluentIterable;\n-import com.google.common.collect.Iterables;\n-import com.google.common.collect.Lists;\n-import com.google.common.collect.Maps;\n-import java.io.IOException;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.type.TypeMirror;\n-\n-import static com.google.common.base.Preconditions.checkState;\n-\n-final class ClassBodyWriter implements Writable, HasClassReferences {\n-\n-  static ClassBodyWriter forAnonymousType() {\n-    return new ClassBodyWriter(Optional.<ClassName>absent());\n-  }\n-\n-  static ClassBodyWriter forNamedType(ClassName name) {\n-    return new ClassBodyWriter(Optional.of(name));\n-  }\n-\n-  private final Optional<ClassName> name;\n-  private final Map<String, FieldWriter> fieldWriters;\n-  private final List<ConstructorWriter> constructorWriters;\n-  private final List<MethodWriter> methodWriters;\n-  final List<TypeWriter> nestedTypeWriters;\n-\n-  private ClassBodyWriter(Optional<ClassName> name) {\n-    this.name = name;\n-    this.fieldWriters = Maps.newLinkedHashMap();\n-    this.constructorWriters = Lists.newArrayList();\n-    this.methodWriters = Lists.newArrayList();\n-    this.nestedTypeWriters = Lists.newArrayList();\n-  }\n-\n-  public boolean isEmpty() {\n-    return fieldWriters.isEmpty() && constructorWriters.isEmpty() && methodWriters.isEmpty()\n-        && nestedTypeWriters.isEmpty();\n-  }\n-\n-  public ConstructorWriter addConstructor() {\n-    checkState(name.isPresent(), \"Cannot add a constructor to an anonymous type\");\n-    ConstructorWriter constructorWriter = new ConstructorWriter(name.get().simpleName());\n-    constructorWriters.add(constructorWriter);\n-    return constructorWriter;\n-  }\n-\n-  public MethodWriter addMethod(TypeWriter returnType, String name) {\n-    MethodWriter methodWriter = new MethodWriter(returnType.name, name);\n-    methodWriters.add(methodWriter);\n-    return methodWriter;\n-  }\n-\n-  public MethodWriter addMethod(TypeMirror returnType, String name) {\n-    MethodWriter methodWriter =\n-        new MethodWriter(TypeNames.forTypeMirror(returnType), name);\n-    methodWriters.add(methodWriter);\n-    return methodWriter;\n-  }\n-\n-  public MethodWriter addMethod(TypeName returnType, String name) {\n-    MethodWriter methodWriter = new MethodWriter(returnType, name);\n-    methodWriters.add(methodWriter);\n-    return methodWriter;\n-  }\n-\n-  public MethodWriter addMethod(Class<?> returnType, String name) {\n-    MethodWriter methodWriter =\n-        new MethodWriter(TypeNames.forClass(returnType), name);\n-    methodWriters.add(methodWriter);\n-    return methodWriter;\n-  }\n-\n-  public FieldWriter addField(Class<?> type, String name) {\n-    return addField(TypeNames.forClass(type), name);\n-  }\n-\n-  public FieldWriter addField(TypeElement type, String name) {\n-    return addField(ClassName.fromTypeElement(type), name);\n-  }\n-\n-  public FieldWriter addField(TypeName type, String name) {\n-    String candidateName = name;\n-    int differentiator = 1;\n-    while (fieldWriters.containsKey(candidateName)) {\n-      candidateName = name + differentiator;\n-      differentiator++;\n-    }\n-    FieldWriter fieldWriter = new FieldWriter(type, candidateName);\n-    fieldWriters.put(candidateName, fieldWriter);\n-    return fieldWriter;\n-  }\n-\n-  public ClassWriter addNestedClass(String name) {\n-    // TODO support nested types in anonymous types\n-    // (currently, nested types must be fully-qualifiedly named)\n-    checkState(this.name.isPresent(), \"Nested types not yet supported in anonymous types\");\n-    ClassWriter innerClassWriter = new ClassWriter(this.name.get().nestedClassNamed(name));\n-    nestedTypeWriters.add(innerClassWriter);\n-    return innerClassWriter;\n-  }\n-\n-  public InterfaceWriter addNestedInterface(String name) {\n-    // TODO support nested types in anonymous types\n-    // (currently, nested types must be fully-qualifiedly named)\n-    checkState(this.name.isPresent(), \"Nested types not yet supported in anonymous types\");\n-    InterfaceWriter innerInterfaceWriter =\n-        new InterfaceWriter(this.name.get().nestedClassNamed(name));\n-    nestedTypeWriters.add(innerInterfaceWriter);\n-    return innerInterfaceWriter;\n-  }\n-\n-  public EnumWriter addNestedEnum(String name) {\n-    // TODO support nested types in anonymous types\n-    // (currently, nested types must be fully-qualifiedly named)\n-    checkState(this.name.isPresent(), \"Nested types not yet supported in anonymous types\");\n-    EnumWriter innerEnumWriter = new EnumWriter(this.name.get().nestedClassNamed(name));\n-    nestedTypeWriters.add(innerEnumWriter);\n-    return innerEnumWriter;\n-  }\n-\n-  @Override\n-  public Set<ClassName> referencedClasses() {\n-    @SuppressWarnings(\"unchecked\")\n-    Iterable<? extends HasClassReferences> concat =\n-        Iterables.concat(fieldWriters.values(), constructorWriters, methodWriters,\n-            nestedTypeWriters);\n-    return FluentIterable.from(concat)\n-        .transformAndConcat(GET_REFERENCED_CLASSES)\n-        .toSet();\n-  }\n-\n-  @Override\n-  public Appendable write(Appendable appendable, Context context) throws IOException {\n-    if (!fieldWriters.isEmpty()) {\n-      appendable.append('\\n');\n-    }\n-    for (FieldWriter fieldWriter : fieldWriters.values()) {\n-      fieldWriter.write(new IndentingAppendable(appendable), context).append('\\n');\n-    }\n-    for (ConstructorWriter constructorWriter : constructorWriters) {\n-      appendable.append('\\n');\n-      constructorWriter.write(new IndentingAppendable(appendable), context);\n-    }\n-    for (MethodWriter methodWriter : methodWriters) {\n-      appendable.append('\\n');\n-      methodWriter.write(new IndentingAppendable(appendable), context);\n-    }\n-    for (TypeWriter nestedTypeWriter : nestedTypeWriters) {\n-      appendable.append('\\n');\n-      nestedTypeWriter.write(new IndentingAppendable(appendable), context);\n-    }\n-    return appendable;\n-  }\n-}\n"
    },
    {
        "commit_hash": "8c0ca2307bc82ffc15dde0f0dd9eb105382fdb41",
        "previous_commit_hash": "d141cfb091f782eb18385c7c5d5e40326a6d883c",
        "diff_stats": {
            "additions": 5,
            "deletions": 22
        },
        "diff_content": "@@ -24,11 +24,9 @@ import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n-import java.io.IOException;\n import java.util.Collections;\n import java.util.Iterator;\n import java.util.List;\n-import java.util.Set;\n import javax.lang.model.SourceVersion;\n import javax.lang.model.element.Element;\n import javax.lang.model.element.ElementKind;\n@@ -93,7 +91,7 @@ public final class ClassName implements TypeName, Comparable<ClassName> {\n \n   public String canonicalName() {\n     if (fullyQualifiedName == null) {\n-      StringBuilder builder = new StringBuilder(packageName());\n+      StringBuilder builder = new StringBuilder(packageName);\n       if (builder.length() > 0) {\n         builder.append('.');\n       }\n@@ -235,19 +233,11 @@ public final class ClassName implements TypeName, Comparable<ClassName> {\n     return new ClassName(packageName, ImmutableList.<String>of(), simpleName);\n   }\n \n-  @Override\n-  public String toString() {\n+  @Override public String toString() {\n     return canonicalName();\n   }\n \n-  @Override\n-  public Appendable write(Appendable appendable, Context context) throws IOException {\n-    appendable.append(context.sourceReferenceForClassName(this));\n-    return appendable;\n-  }\n-\n-  @Override\n-  public boolean equals(Object obj) {\n+  @Override public boolean equals(Object obj) {\n     if (obj == this) {\n       return true;\n     } else if (obj instanceof ClassName) {\n@@ -260,18 +250,11 @@ public final class ClassName implements TypeName, Comparable<ClassName> {\n     }\n   }\n \n-  @Override\n-  public int hashCode() {\n+  @Override public int hashCode() {\n     return Objects.hashCode(packageName, enclosingSimpleNames, simpleName);\n   }\n \n-  @Override\n-  public int compareTo(ClassName o) {\n+  @Override public int compareTo(ClassName o) {\n     return canonicalName().compareTo(o.canonicalName());\n   }\n-\n-  @Override\n-  public Set<ClassName> referencedClasses() {\n-    return ImmutableSet.of(this);\n-  }\n }\n"
    },
    {
        "commit_hash": "8c0ca2307bc82ffc15dde0f0dd9eb105382fdb41",
        "previous_commit_hash": "d141cfb091f782eb18385c7c5d5e40326a6d883c",
        "diff_stats": {
            "additions": 0,
            "deletions": 90
        },
        "diff_content": "@@ -1,90 +0,0 @@\n-/*\n- * Copyright (C) 2014 Google, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.squareup.javawriter;\n-\n-import com.google.common.base.Optional;\n-import com.google.common.collect.FluentIterable;\n-import com.google.common.collect.Iterables;\n-import com.google.common.collect.Lists;\n-import java.io.IOException;\n-import java.util.List;\n-import java.util.Set;\n-import javax.lang.model.element.TypeElement;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static com.squareup.javawriter.Writables.writeToString;\n-\n-public final class ClassWriter extends TypeWriter {\n-  public static ClassWriter forClassName(ClassName name) {\n-    checkArgument(name.enclosingSimpleNames().isEmpty(), \"%s must be top-level type.\", name);\n-    return new ClassWriter(name);\n-  }\n-\n-  private Optional<TypeName> supertype;\n-  private final List<TypeVariableName> typeVariables;\n-\n-  ClassWriter(ClassName className) {\n-    super(className);\n-    this.supertype = Optional.absent();\n-    this.typeVariables = Lists.newArrayList();\n-  }\n-\n-  public void setSupertype(TypeName typeName) {\n-    if (supertype.isPresent()) {\n-      throw new IllegalStateException(\"Supertype already set to \" + writeToString(supertype.get()));\n-    }\n-    supertype = Optional.of(typeName);\n-  }\n-\n-  public void setSupertype(TypeElement typeElement) {\n-    setSupertype(ClassName.fromTypeElement(typeElement));\n-  }\n-\n-  public ConstructorWriter addConstructor() {\n-    return body.addConstructor();\n-  }\n-\n-  public void addTypeVariable(TypeVariableName typeVariable) {\n-    this.typeVariables.add(typeVariable);\n-  }\n-\n-  @Override\n-  public Appendable write(Appendable appendable, Context context) throws IOException {\n-    context = createSubcontext(context);\n-    writeAnnotations(appendable, context, '\\n');\n-    writeModifiers(appendable).append(\"class \").append(name.simpleName());\n-    Writables.Joiner.on(\", \").wrap(\"<\", \"> \").appendTo(appendable, context, typeVariables);\n-    if (supertype.isPresent()) {\n-      appendable.append(\" extends \");\n-      supertype.get().write(appendable, context);\n-    }\n-    Writables.Joiner.on(\", \").prefix(\" implements \")\n-        .appendTo(appendable, context, implementedTypes);\n-    appendable.append(\" {\");\n-    body.write(appendable, context);\n-    appendable.append(\"}\\n\");\n-    return appendable;\n-  }\n-\n-  @Override\n-  public Set<ClassName> referencedClasses() {\n-    Iterable<? extends HasClassReferences> concat =\n-        Iterables.concat(super.referencedClasses(), supertype.asSet(), typeVariables);\n-    return FluentIterable.from(concat)\n-        .transformAndConcat(GET_REFERENCED_CLASSES)\n-        .toSet();\n-  }\n-}\n"
    },
    {
        "commit_hash": "8c0ca2307bc82ffc15dde0f0dd9eb105382fdb41",
        "previous_commit_hash": "d141cfb091f782eb18385c7c5d5e40326a6d883c",
        "diff_stats": {
            "additions": 0,
            "deletions": 99
        },
        "diff_content": "@@ -1,99 +0,0 @@\n-/*\n- * Copyright (C) 2014 Google, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.squareup.javawriter;\n-\n-import com.google.common.collect.FluentIterable;\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.Iterables;\n-import com.google.common.collect.Lists;\n-import com.google.common.collect.Maps;\n-import java.io.IOException;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import javax.lang.model.element.TypeElement;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-\n-public final class ConstructorWriter extends Modifiable implements Writable {\n-  private final List<TypeVariableName> typeVariables;\n-  private final String name;\n-  private final Map<String, ParameterWriter> parameterWriters;\n-  private final BlockWriter body;\n-\n-  ConstructorWriter(String name) {\n-    this.typeVariables = Lists.newArrayList();\n-    this.name = name;\n-    this.parameterWriters = Maps.newLinkedHashMap();\n-    this.body = new BlockWriter();\n-  }\n-\n-  public void addTypeVariable(TypeVariableName typeVariable) {\n-    this.typeVariables.add(typeVariable);\n-  }\n-\n-  public ParameterWriter addParameter(Class<?> type, String name) {\n-    return addParameter(TypeNames.forClass(type), name);\n-  }\n-\n-  public ParameterWriter addParameter(TypeElement type, String name) {\n-    return addParameter(ClassName.fromTypeElement(type), name);\n-  }\n-\n-  public ParameterWriter addParameter(TypeWriter type, String name) {\n-    return addParameter(type.name, name);\n-  }\n-\n-  public ParameterWriter addParameter(TypeName type, String name) {\n-    ParameterWriter parameterWriter = new ParameterWriter(type, name);\n-    parameterWriters.put(name, parameterWriter);\n-    return parameterWriter;\n-  }\n-\n-  public BlockWriter body() {\n-    return body;\n-  }\n-\n-  private ParameterWriter addParameter(ClassName type, String name) {\n-    checkArgument(!parameterWriters.containsKey(name));\n-    ParameterWriter parameterWriter = new ParameterWriter(type, name);\n-    parameterWriters.put(name, parameterWriter);\n-    return parameterWriter;\n-  }\n-\n-  @Override\n-  public Set<ClassName> referencedClasses() {\n-    Iterable<? extends HasClassReferences> concat =\n-        Iterables.concat(super.referencedClasses(), typeVariables, parameterWriters.values(),\n-            ImmutableList.of(body));\n-    return FluentIterable.from(concat)\n-            .transformAndConcat(GET_REFERENCED_CLASSES)\n-            .toSet();\n-  }\n-\n-  @Override\n-  public Appendable write(Appendable appendable, Context context) throws IOException {\n-    writeModifiers(appendable);\n-    Writables.Joiner.on(\", \").wrap(\"<\", \"> \").appendTo(appendable, context, typeVariables);\n-    appendable.append(name).append('(');\n-    Writables.Joiner.on(\", \").appendTo(appendable, context, parameterWriters.values());\n-    appendable.append(\") {\\n\");\n-    if (!body.isEmpty()) {\n-      body.write(new IndentingAppendable(appendable), context).append('\\n');\n-    }\n-    return appendable.append(\"}\\n\");\n-  }\n-}\n"
    },
    {
        "commit_hash": "8c0ca2307bc82ffc15dde0f0dd9eb105382fdb41",
        "previous_commit_hash": "d141cfb091f782eb18385c7c5d5e40326a6d883c",
        "diff_stats": {
            "additions": 0,
            "deletions": 147
        },
        "diff_content": "@@ -1,147 +0,0 @@\n-/*\n- * Copyright (C) 2014 Google, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.squareup.javawriter;\n-\n-import com.google.common.collect.FluentIterable;\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.Iterables;\n-import com.google.common.collect.Lists;\n-import com.google.common.collect.Maps;\n-import java.io.IOException;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.type.TypeMirror;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static com.google.common.base.Preconditions.checkState;\n-\n-public final class EnumWriter extends TypeWriter {\n-  public static EnumWriter forClassName(ClassName name) {\n-    checkArgument(name.enclosingSimpleNames().isEmpty(), \"%s must be top-level type.\", name);\n-    return new EnumWriter(name);\n-  }\n-\n-  private final Map<String, ConstantWriter> constantWriters = Maps.newLinkedHashMap();\n-\n-  EnumWriter(ClassName name) {\n-    super(name);\n-  }\n-\n-  public ConstantWriter addConstant(String name) {\n-    ConstantWriter constantWriter = new ConstantWriter(name);\n-    constantWriters.put(name, constantWriter);\n-    return constantWriter;\n-  }\n-\n-  public ConstructorWriter addConstructor() {\n-    return body.addConstructor();\n-  }\n-\n-  @Override\n-  public Appendable write(Appendable appendable, Context context) throws IOException {\n-    checkState(!constantWriters.isEmpty(), \"Cannot write an enum with no constants.\");\n-\n-    context = createSubcontext(context);\n-    writeAnnotations(appendable, context, '\\n');\n-    writeModifiers(appendable).append(\"enum \").append(name.simpleName());\n-    Writables.Joiner.on(\", \").prefix(\" implements \")\n-        .appendTo(appendable, context, implementedTypes);\n-    appendable.append(\" {\\n\");\n-\n-    Writables.Joiner.on(\",\\n\")\n-        .appendTo(new IndentingAppendable(appendable), context, constantWriters.values());\n-    appendable.append(\";\\n\");\n-\n-    body.write(appendable, context);\n-    appendable.append(\"}\\n\");\n-    return appendable;\n-  }\n-\n-  @Override\n-  public Set<ClassName> referencedClasses() {\n-    Iterable<? extends HasClassReferences> concat =\n-        Iterables.concat(super.referencedClasses(), constantWriters.values());\n-    return FluentIterable.from(concat)\n-        .transformAndConcat(GET_REFERENCED_CLASSES)\n-        .toSet();\n-  }\n-\n-  public static final class ConstantWriter implements Writable, HasClassReferences {\n-    private final String name;\n-    private final List<Snippet> constructorSnippets;\n-    private final ClassBodyWriter body;\n-\n-    private ConstantWriter(String name) {\n-      this.name = name;\n-      this.constructorSnippets = Lists.newArrayList();\n-      this.body = ClassBodyWriter.forAnonymousType();\n-    }\n-\n-    public ConstantWriter addArgument(Snippet snippet) {\n-      constructorSnippets.add(snippet);\n-      return this;\n-    }\n-\n-    public MethodWriter addMethod(TypeWriter returnType, String name) {\n-      return body.addMethod(returnType, name);\n-    }\n-\n-    public MethodWriter addMethod(TypeMirror returnType, String name) {\n-      return body.addMethod(returnType, name);\n-    }\n-\n-    public MethodWriter addMethod(TypeName returnType, String name) {\n-      return body.addMethod(returnType, name);\n-    }\n-\n-    public MethodWriter addMethod(Class<?> returnType, String name) {\n-      return body.addMethod(returnType, name);\n-    }\n-\n-    public FieldWriter addField(Class<?> type, String name) {\n-      return body.addField(type, name);\n-    }\n-\n-    public FieldWriter addField(TypeElement type, String name) {\n-      return body.addField(type, name);\n-    }\n-\n-    public FieldWriter addField(TypeName type, String name) {\n-      return body.addField(type, name);\n-    }\n-\n-    @Override\n-    public Appendable write(Appendable appendable, Context context) throws IOException {\n-      appendable.append(name);\n-      Writables.Joiner.on(\", \").wrap(\"(\", \")\").appendTo(appendable, context, constructorSnippets);\n-      if (!body.isEmpty()) {\n-        appendable.append(\" {\");\n-        body.write(appendable, context);\n-        appendable.append('}');\n-      }\n-      return appendable;\n-    }\n-\n-    @Override\n-    public Set<ClassName> referencedClasses() {\n-      return FluentIterable.from(Iterables.concat(constructorSnippets, ImmutableList.of(body)))\n-          .transformAndConcat(GET_REFERENCED_CLASSES)\n-          .toSet();\n-    }\n-  }\n-}\n"
    },
    {
        "commit_hash": "8c0ca2307bc82ffc15dde0f0dd9eb105382fdb41",
        "previous_commit_hash": "d141cfb091f782eb18385c7c5d5e40326a6d883c",
        "diff_stats": {
            "additions": 0,
            "deletions": 62
        },
        "diff_content": "@@ -1,62 +0,0 @@\n-/*\n- * Copyright (C) 2014 Google, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.squareup.javawriter;\n-\n-import com.google.common.base.Optional;\n-import com.google.common.collect.FluentIterable;\n-import com.google.common.collect.Iterables;\n-import java.io.IOException;\n-import java.util.Set;\n-\n-public final class FieldWriter extends VariableWriter {\n-  private Optional<Snippet> initializer;\n-\n-  FieldWriter(TypeName type, String name) {\n-    super(type, name);\n-    this.initializer = Optional.absent();\n-  }\n-\n-  public void setInitializer(Snippet initializer) {\n-    this.initializer = Optional.of(initializer);\n-  }\n-\n-  public void setInitializer(String initializer, Object... args) {\n-    this.initializer = Optional.of(Snippet.format(initializer, args));\n-  }\n-\n-  @Override\n-  public Appendable write(Appendable appendable, Context context) throws IOException {\n-    writeAnnotations(appendable, context, '\\n');\n-    writeModifiers(appendable);\n-    type().write(appendable, context);\n-    appendable.append(' ').append(name());\n-    if (initializer.isPresent()) {\n-      appendable.append(\" = \");\n-      initializer.get().write(appendable, context);\n-    }\n-    appendable.append(';');\n-    return appendable;\n-  }\n-\n-  @Override\n-  public Set<ClassName> referencedClasses() {\n-    Iterable<? extends HasClassReferences> concat =\n-        Iterables.concat(super.referencedClasses(), initializer.asSet());\n-    return FluentIterable.from(concat)\n-        .transformAndConcat(GET_REFERENCED_CLASSES)\n-        .toSet();\n-  }\n-}\n"
    },
    {
        "commit_hash": "8c0ca2307bc82ffc15dde0f0dd9eb105382fdb41",
        "previous_commit_hash": "d141cfb091f782eb18385c7c5d5e40326a6d883c",
        "diff_stats": {
            "additions": 0,
            "deletions": 31
        },
        "diff_content": "@@ -1,31 +0,0 @@\n-/*\n- * Copyright (C) 2014 Google, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.squareup.javawriter;\n-\n-import com.google.common.base.Function;\n-import java.util.Set;\n-\n-public interface HasClassReferences {\n-  Function<HasClassReferences, Set<ClassName>> GET_REFERENCED_CLASSES =\n-      new Function<HasClassReferences, Set<ClassName>>() {\n-        @Override\n-        public Set<ClassName> apply(HasClassReferences input) {\n-          return input.referencedClasses();\n-        }\n-      };\n-\n-  Set<ClassName> referencedClasses();\n-}\n"
    },
    {
        "commit_hash": "8c0ca2307bc82ffc15dde0f0dd9eb105382fdb41",
        "previous_commit_hash": "d141cfb091f782eb18385c7c5d5e40326a6d883c",
        "diff_stats": {
            "additions": 0,
            "deletions": 20
        },
        "diff_content": "@@ -1,20 +0,0 @@\n-/*\n- * Copyright (C) 2014 Google, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.squareup.javawriter;\n-\n-interface HasTypeName {\n-  TypeName name();\n-}\n"
    },
    {
        "commit_hash": "8c0ca2307bc82ffc15dde0f0dd9eb105382fdb41",
        "previous_commit_hash": "d141cfb091f782eb18385c7c5d5e40326a6d883c",
        "diff_stats": {
            "additions": 0,
            "deletions": 95
        },
        "diff_content": "@@ -1,95 +0,0 @@\n-/*\n- * Copyright (C) 2014 Google, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.squareup.javawriter;\n-\n-import com.google.common.collect.AbstractIterator;\n-import java.io.IOException;\n-import java.util.Iterator;\n-\n-final class IndentingAppendable implements Appendable {\n-  private final String indentation;\n-  private final Appendable delegate;\n-  private boolean requiresIndent = true;\n-\n-  IndentingAppendable(Appendable delegate) {\n-    this(\"  \", delegate);\n-  }\n-\n-  IndentingAppendable(String indentation, Appendable delegate) {\n-    this.indentation = indentation;\n-    this.delegate = delegate;\n-  }\n-\n-  @Override\n-  public Appendable append(CharSequence csq) throws IOException {\n-    return append(csq, 0, csq.length());\n-  }\n-\n-  @Override\n-  public Appendable append(CharSequence csq, int start, int end) throws IOException {\n-    Iterator<CharSequence> lines = lines(csq, start, end);\n-    while (lines.hasNext()) {\n-      CharSequence line = lines.next();\n-      if (line.length() > 1 || line.charAt(0) != '\\n') {\n-        maybeIndent();\n-      }\n-      if (line.charAt(line.length() - 1) == '\\n') {\n-        requiresIndent = true;\n-      }\n-      delegate.append(line);\n-    }\n-    return this;\n-  }\n-\n-  @Override\n-  public Appendable append(char c) throws IOException {\n-    if (c == '\\n') {\n-      requiresIndent = true;\n-    } else {\n-      maybeIndent();\n-    }\n-    delegate.append(c);\n-    return this;\n-  }\n-\n-  void maybeIndent() throws IOException {\n-    if (requiresIndent) {\n-      delegate.append(indentation);\n-    }\n-    requiresIndent = false;\n-  }\n-\n-  private static Iterator<CharSequence> lines(\n-      final CharSequence csq, final int start, final int end) {\n-    return new AbstractIterator<CharSequence>() {\n-      int index = start;\n-\n-      @Override protected CharSequence computeNext() {\n-        int nextStart = index;\n-        while (index < end && csq.charAt(index) != '\\n') {\n-          index++;\n-        }\n-        if (index < end && csq.charAt(index) == '\\n') {\n-          index++;\n-        }\n-        int nextEnd = index;\n-        return nextStart >= end\n-            ? endOfData()\n-            : csq.subSequence(nextStart, nextEnd);\n-      }\n-    };\n-  }\n-}\n"
    },
    {
        "commit_hash": "8c0ca2307bc82ffc15dde0f0dd9eb105382fdb41",
        "previous_commit_hash": "d141cfb091f782eb18385c7c5d5e40326a6d883c",
        "diff_stats": {
            "additions": 0,
            "deletions": 65
        },
        "diff_content": "@@ -1,65 +0,0 @@\n-/*\n- * Copyright (C) 2014 Google, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.squareup.javawriter;\n-\n-import com.google.common.collect.FluentIterable;\n-import com.google.common.collect.Iterables;\n-import com.google.common.collect.Lists;\n-import java.io.IOException;\n-import java.util.List;\n-import java.util.Set;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-\n-public final class InterfaceWriter extends TypeWriter {\n-  public static InterfaceWriter forClassName(ClassName name) {\n-    checkArgument(name.enclosingSimpleNames().isEmpty(), \"%s must be top-level type.\", name);\n-    return new InterfaceWriter(name);\n-  }\n-\n-  private final List<TypeVariableName> typeVariables;\n-\n-  InterfaceWriter(ClassName name) {\n-    super(name);\n-    this.typeVariables = Lists.newArrayList();\n-  }\n-\n-  public void addTypeVariable(TypeVariableName typeVariable) {\n-    this.typeVariables.add(typeVariable);\n-  }\n-\n-  @Override\n-  public Appendable write(Appendable appendable, Context context) throws IOException {\n-    context = createSubcontext(context);\n-    writeAnnotations(appendable, context, '\\n');\n-    writeModifiers(appendable).append(\"interface \").append(name.simpleName());\n-    Writables.Joiner.on(\", \").wrap(\"<\", \"> \").appendTo(appendable, context, typeVariables);\n-    Writables.Joiner.on(\", \").prefix(\" extends \").appendTo(appendable, context, implementedTypes);\n-    appendable.append(\" {\");\n-    body.write(appendable, context);\n-    appendable.append(\"}\\n\");\n-    return appendable;\n-  }\n-\n-  @Override\n-  public Set<ClassName> referencedClasses() {\n-    Iterable<? extends HasClassReferences> concat =\n-        Iterables.concat(super.referencedClasses(), typeVariables);\n-    return FluentIterable.from(concat)\n-        .transformAndConcat(GET_REFERENCED_CLASSES)\n-        .toSet();\n-  }\n-}\n"
    },
    {
        "commit_hash": "8c0ca2307bc82ffc15dde0f0dd9eb105382fdb41",
        "previous_commit_hash": "d141cfb091f782eb18385c7c5d5e40326a6d883c",
        "diff_stats": {
            "additions": 5,
            "deletions": 16
        },
        "diff_content": "@@ -15,30 +15,19 @@\n  */\n package com.squareup.javawriter;\n \n-import com.google.common.collect.FluentIterable;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Lists;\n-\n-import java.io.IOException;\n import java.util.List;\n-import java.util.Set;\n \n-final class IntersectionTypeName implements TypeName {\n-  private final List<TypeName> typeNames;\n+public final class IntersectionTypeName implements TypeName {\n+  private final ImmutableList<TypeName> typeNames;\n \n   IntersectionTypeName(List<TypeName> typeNames) {\n-    this.typeNames = typeNames;\n-  }\n-\n-  @Override public Set<ClassName> referencedClasses() {\n-    return FluentIterable.from(typeNames)\n-        .transformAndConcat(GET_REFERENCED_CLASSES)\n-        .toSet();\n+    this.typeNames = ImmutableList.copyOf(typeNames);\n   }\n \n-  @Override public Appendable write(Appendable appendable, Context context) throws IOException {\n-    Writables.Joiner.on(\" & \").appendTo(appendable, context, typeNames);\n-    return appendable;\n+  public List<TypeName> typeNames() {\n+    return typeNames;\n   }\n \n   @Override public int hashCode() {\n"
    },
    {
        "commit_hash": "8c0ca2307bc82ffc15dde0f0dd9eb105382fdb41",
        "previous_commit_hash": "d141cfb091f782eb18385c7c5d5e40326a6d883c",
        "diff_stats": {
            "additions": 26,
            "deletions": 64
        },
        "diff_content": "@@ -16,15 +16,15 @@\n package com.squareup.javawriter;\n \n import com.google.common.collect.Iterables;\n-import com.google.common.collect.Lists;\n-import com.google.common.io.Closer;\n+import com.squareup.javawriter.builders.JavaFile;\n+import com.squareup.javawriter.builders.TypeSpec;\n import java.io.File;\n-import java.io.FileWriter;\n import java.io.IOException;\n import java.io.OutputStreamWriter;\n import java.io.Writer;\n import java.nio.file.Files;\n import java.nio.file.Path;\n+import java.util.ArrayList;\n import java.util.List;\n import javax.annotation.processing.Filer;\n import javax.lang.model.element.Element;\n@@ -33,38 +33,25 @@ import javax.tools.JavaFileObject;\n import static com.google.common.base.Preconditions.checkArgument;\n \n public final class JavaWriter {\n-  /** Create a new Java writer for writing multiple types to a single location. */\n-  public static JavaWriter create() {\n-    return new JavaWriter();\n-  }\n-\n-  private final List<TypeWriter> typeWriters;\n-\n-  private JavaWriter() {\n-    typeWriters = Lists.newArrayList();\n-    // TODO take in options! indent, what else?\n-  }\n+  private final List<JavaFile> javaFiles = new ArrayList<>();\n \n-  public JavaWriter addTypeWriter(TypeWriter typeWriter) {\n-    typeWriters.add(typeWriter);\n+  public JavaWriter add(JavaFile javaFile) {\n+    javaFiles.add(javaFile);\n     return this;\n   }\n \n-  public JavaWriter addTypeWriters(TypeWriter first, TypeWriter second, TypeWriter... rest) {\n-    return addTypeWriters(Lists.asList(first, second, rest));\n-  }\n-\n-  public JavaWriter addTypeWriters(Iterable<? extends TypeWriter> typeWriters) {\n-    Iterables.addAll(this.typeWriters, typeWriters);\n-    return this;\n+  public JavaWriter add(String packageName, TypeSpec type) {\n+    return add(new JavaFile.Builder()\n+        .packageName(packageName)\n+        .typeSpec(type)\n+        .build());\n   }\n \n   public void writeTo(Path directory) throws IOException {\n     checkArgument(Files.notExists(directory) || Files.isDirectory(directory),\n         \"Path %s exists but is not a directory.\", directory);\n-    for (TypeWriter typeWriter : typeWriters) {\n-      ClassName typeName = typeWriter.name();\n-      String packageName = typeName.packageName();\n+    for (JavaFile javaFile : javaFiles) {\n+      String packageName = javaFile.packageName;\n \n       Path outputDirectory = directory;\n       if (!packageName.isEmpty()) {\n@@ -74,55 +61,30 @@ public final class JavaWriter {\n         Files.createDirectories(outputDirectory);\n       }\n \n-      Path outputFile = outputDirectory.resolve(typeName.simpleName() + \".java\");\n-      try (Closer closer = Closer.create()) {\n-        Writer writer = new OutputStreamWriter(Files.newOutputStream(outputFile));\n-        typeWriter.writeTypeToAppendable(closer.register(writer));\n+      Path outputPath = outputDirectory.resolve(javaFile.typeSpec.name + \".java\");\n+      try (Writer writer = new OutputStreamWriter(Files.newOutputStream(outputPath))) {\n+        writer.write(javaFile.toString());\n       }\n     }\n   }\n \n   public void writeTo(File directory) throws IOException {\n-    checkArgument(!directory.exists() || directory.isDirectory(),\n-        \"File %s exists but is not a directory.\", directory);\n-    for (TypeWriter typeWriter : typeWriters) {\n-      ClassName typeName = typeWriter.name();\n-      String packageName = typeName.packageName();\n-\n-      File outputDir = directory;\n-      if (!packageName.isEmpty()) {\n-        for (String packageComponent : packageName.split(\"\\\\.\")) {\n-          outputDir = new File(outputDir, packageComponent);\n-        }\n-        if (!outputDir.exists() && !outputDir.mkdirs()) {\n-          throw new IOException(\"Unable to create directory \" + outputDir);\n-        }\n-      }\n-\n-      File outputFile = new File(outputDir, typeName.simpleName() + \".java\");\n-      try (Closer closer = Closer.create()) {\n-        typeWriter.writeTypeToAppendable(closer.register(new FileWriter(outputFile)));\n-      }\n-    }\n+    writeTo(directory.toPath());\n   }\n \n   public void writeTo(Filer filer) throws IOException {\n-    for (TypeWriter typeWriter : typeWriters) {\n-      JavaFileObject sourceFile = filer.createSourceFile(typeWriter.name().canonicalName(),\n-          Iterables.toArray(typeWriter.originatingElements(), Element.class));\n-      Writer closeable = sourceFile.openWriter();\n-      Closer closer = Closer.create();\n-      try {\n-        typeWriter.writeTypeToAppendable(closer.register(closeable));\n+    for (JavaFile javaFile : javaFiles) {\n+      JavaFileObject filerSourceFile = filer.createSourceFile(\n+          javaFile.packageName + \".\" + javaFile.typeSpec.name,\n+          Iterables.toArray(javaFile.typeSpec.originatingElements, Element.class));\n+      try (Writer writer = filerSourceFile.openWriter()) {\n+        writer.write(javaFile.toString());\n       } catch (Exception e) {\n         try {\n-          sourceFile.delete();\n-        } catch (Exception e2) {\n-          // Couldn't delete the file.\n+          filerSourceFile.delete();\n+        } catch (Exception ignored) {\n         }\n-        throw closer.rethrow(e);\n-      } finally {\n-        closer.close();\n+        throw e;\n       }\n     }\n   }\n"
    },
    {
        "commit_hash": "8c0ca2307bc82ffc15dde0f0dd9eb105382fdb41",
        "previous_commit_hash": "d141cfb091f782eb18385c7c5d5e40326a6d883c",
        "diff_stats": {
            "additions": 0,
            "deletions": 120
        },
        "diff_content": "@@ -1,120 +0,0 @@\n-/*\n- * Copyright (C) 2014 Google, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.squareup.javawriter;\n-\n-import com.google.common.collect.FluentIterable;\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.Iterables;\n-import com.google.common.collect.Lists;\n-import com.google.common.collect.Maps;\n-import java.io.IOException;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import javax.lang.model.element.Modifier;\n-import javax.lang.model.element.TypeElement;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-\n-public final class MethodWriter extends Modifiable implements Writable {\n-  private final List<TypeVariableName> typeVariables;\n-  private final TypeName returnType;\n-  private final String name;\n-  private final Map<String, ParameterWriter> parameterWriters;\n-  private final List<ClassName> throwsTypes;\n-  private BlockWriter body;\n-\n-  MethodWriter(TypeName returnType, String name) {\n-    this.typeVariables = Lists.newArrayList();\n-    this.returnType = returnType;\n-    this.name = name;\n-    this.parameterWriters = Maps.newLinkedHashMap();\n-    this.throwsTypes = Lists.newArrayList();\n-    this.body = new BlockWriter();\n-  }\n-\n-  public String name() {\n-    return name;\n-  }\n-\n-  public void addTypeVariable(TypeVariableName typeVariable) {\n-    this.typeVariables.add(typeVariable);\n-  }\n-\n-  public ParameterWriter addParameter(Class<?> type, String name) {\n-    return addParameter(TypeNames.forClass(type), name);\n-  }\n-\n-  public ParameterWriter addParameter(TypeElement type, String name) {\n-    return addParameter(ClassName.fromTypeElement(type), name);\n-  }\n-\n-  public ParameterWriter addParameter(TypeWriter type, String name) {\n-    return addParameter(type.name, name);\n-  }\n-\n-  public ParameterWriter addParameter(TypeName type, String name) {\n-    checkArgument(!parameterWriters.containsKey(name));\n-    ParameterWriter parameterWriter = new ParameterWriter(type, name);\n-    parameterWriters.put(name, parameterWriter);\n-    return parameterWriter;\n-  }\n-\n-  public void addThrowsType(Class<?> clazz) {\n-    addThrowsType(ClassName.fromClass(clazz));\n-  }\n-\n-  public void addThrowsType(ClassName throwsType) {\n-    throwsTypes.add(throwsType);\n-  }\n-\n-  public BlockWriter body() {\n-    return body;\n-  }\n-\n-  @Override\n-  public Appendable write(Appendable appendable, Context context) throws IOException {\n-    writeAnnotations(appendable, context, '\\n');\n-    writeModifiers(appendable);\n-    Writables.Joiner.on(\", \").wrap(\"<\", \"> \").appendTo(appendable, context, typeVariables);\n-    returnType.write(appendable, context);\n-    appendable.append(' ').append(name).append('(');\n-    Writables.Joiner.on(\", \").appendTo(appendable, context, parameterWriters.values());\n-    appendable.append(\")\");\n-    Writables.Joiner.on(\", \").prefix(\" throws \").appendTo(appendable, context, throwsTypes);\n-    if (modifiers.contains(Modifier.ABSTRACT)) {\n-      appendable.append(\";\\n\");\n-    } else {\n-      appendable.append(\" {\\n\");\n-      if (!body.isEmpty()) {\n-        body.write(new IndentingAppendable(appendable), context).append('\\n');\n-      }\n-      appendable.append(\"}\\n\");\n-    }\n-    return appendable;\n-  }\n-\n-  @Override\n-  public Set<ClassName> referencedClasses() {\n-    @SuppressWarnings(\"unchecked\")\n-    Iterable<? extends HasClassReferences> concat =\n-        Iterables.concat(super.referencedClasses(), typeVariables,\n-            ImmutableList.of(returnType, body), parameterWriters.values(), throwsTypes);\n-    return FluentIterable.from(concat)\n-        .transformAndConcat(GET_REFERENCED_CLASSES)\n-        .toSet();\n-  }\n-}\n"
    },
    {
        "commit_hash": "8c0ca2307bc82ffc15dde0f0dd9eb105382fdb41",
        "previous_commit_hash": "d141cfb091f782eb18385c7c5d5e40326a6d883c",
        "diff_stats": {
            "additions": 0,
            "deletions": 80
        },
        "diff_content": "@@ -1,80 +0,0 @@\n-/*\n- * Copyright (C) 2014 Google, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.squareup.javawriter;\n-\n-import com.google.common.collect.FluentIterable;\n-import com.google.common.collect.Iterables;\n-import com.google.common.collect.Lists;\n-import com.squareup.javawriter.Writable.Context;\n-import java.io.IOException;\n-import java.lang.annotation.Annotation;\n-import java.util.EnumSet;\n-import java.util.List;\n-import java.util.Set;\n-import javax.lang.model.element.Modifier;\n-\n-public abstract class Modifiable implements HasClassReferences {\n-  final Set<Modifier> modifiers;\n-  final List<AnnotationWriter> annotations;\n-\n-  Modifiable() {\n-    this.modifiers = EnumSet.noneOf(Modifier.class);\n-    this.annotations = Lists.newArrayList();\n-  }\n-\n-  public void addModifier(Modifier modifier) {\n-    modifiers.add(modifier);\n-  }\n-\n-  public void addModifiers(Modifier first, Modifier second, Modifier... rest) {\n-    addModifiers(Lists.asList(first, second, rest));\n-  }\n-\n-  public void addModifiers(Iterable<Modifier> modifiers) {\n-    Iterables.addAll(this.modifiers, modifiers);\n-  }\n-\n-  public AnnotationWriter annotate(Class<? extends Annotation> annotation) {\n-    return annotate(ClassName.fromClass(annotation));\n-  }\n-\n-  public AnnotationWriter annotate(ClassName className) {\n-    AnnotationWriter annotationWriter = new AnnotationWriter(className);\n-    annotations.add(annotationWriter);\n-    return annotationWriter;\n-  }\n-\n-  Appendable writeModifiers(Appendable appendable) throws IOException {\n-    for (Modifier modifier : modifiers) {\n-      appendable.append(modifier.toString()).append(' ');\n-    }\n-    return appendable;\n-  }\n-\n-  Appendable writeAnnotations(Appendable appendable, Context context, char separator)\n-      throws IOException {\n-    for (AnnotationWriter annotationWriter : annotations) {\n-      annotationWriter.write(appendable, context).append(separator);\n-    }\n-    return appendable;\n-  }\n-\n-  @Override public Set<ClassName> referencedClasses() {\n-    return FluentIterable.from(annotations)\n-        .transformAndConcat(GET_REFERENCED_CLASSES)\n-        .toSet();\n-  }\n-}\n"
    },
    {
        "commit_hash": "8c0ca2307bc82ffc15dde0f0dd9eb105382fdb41",
        "previous_commit_hash": "d141cfb091f782eb18385c7c5d5e40326a6d883c",
        "diff_stats": {
            "additions": 1,
            "deletions": 16
        },
        "diff_content": "@@ -15,25 +15,10 @@\n  */\n package com.squareup.javawriter;\n \n-import com.google.common.collect.ImmutableSet;\n-import java.io.IOException;\n-import java.util.Set;\n-\n enum NullName implements TypeName {\n   NULL;\n \n-  @Override\n-  public Set<ClassName> referencedClasses() {\n-    return ImmutableSet.of();\n-  }\n-\n-  @Override\n-  public Appendable write(Appendable appendable, Context context) throws IOException {\n-    return appendable.append(\"null\");\n-  }\n-\n-  @Override\n-  public String toString() {\n+  @Override public String toString() {\n     return \"null\";\n   }\n }\n"
    },
    {
        "commit_hash": "8c0ca2307bc82ffc15dde0f0dd9eb105382fdb41",
        "previous_commit_hash": "d141cfb091f782eb18385c7c5d5e40326a6d883c",
        "diff_stats": {
            "additions": 0,
            "deletions": 32
        },
        "diff_content": "@@ -1,32 +0,0 @@\n-/*\n- * Copyright (C) 2014 Google, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.squareup.javawriter;\n-\n-import java.io.IOException;\n-\n-public final class ParameterWriter extends VariableWriter {\n-  ParameterWriter(TypeName type, String name) {\n-    super(type, name);\n-  }\n-\n-  @Override\n-  public Appendable write(Appendable appendable, Context context) throws IOException {\n-    writeAnnotations(appendable, context, ' ');\n-    writeModifiers(appendable);\n-    type().write(appendable, context);\n-    return appendable.append(' ').append(name());\n-  }\n-}\n"
    },
    {
        "commit_hash": "8c0ca2307bc82ffc15dde0f0dd9eb105382fdb41",
        "previous_commit_hash": "d141cfb091f782eb18385c7c5d5e40326a6d883c",
        "diff_stats": {
            "additions": 2,
            "deletions": 29
        },
        "diff_content": "@@ -16,13 +16,9 @@\n package com.squareup.javawriter;\n \n import com.google.common.base.Objects;\n-import com.google.common.collect.FluentIterable;\n import com.google.common.collect.ImmutableList;\n-import java.io.IOException;\n-import java.util.Set;\n \n import static com.google.common.base.Preconditions.checkArgument;\n-import static com.google.common.base.Verify.verify;\n \n public final class ParameterizedTypeName implements TypeName {\n   private final ClassName type;\n@@ -41,24 +37,7 @@ public final class ParameterizedTypeName implements TypeName {\n     return parameters;\n   }\n \n-  @Override\n-  public Set<ClassName> referencedClasses() {\n-    return FluentIterable.from(parameters)\n-        .transformAndConcat(GET_REFERENCED_CLASSES)\n-        .append(type)\n-        .toSet();\n-  }\n-\n-  @Override\n-  public Appendable write(Appendable appendable, Context context) throws IOException {\n-    appendable.append(context.sourceReferenceForClassName(type));\n-    verify(!parameters.isEmpty(), type.toString());\n-    Writables.Joiner.on(\", \").wrap(\"<\", \">\").appendTo(appendable, context, parameters);\n-    return appendable;\n-  }\n-\n-  @Override\n-  public boolean equals(Object obj) {\n+  @Override public boolean equals(Object obj) {\n     if (obj instanceof ParameterizedTypeName) {\n       ParameterizedTypeName that = (ParameterizedTypeName) obj;\n       return this.type.equals(that.type)\n@@ -68,16 +47,10 @@ public final class ParameterizedTypeName implements TypeName {\n     }\n   }\n \n-  @Override\n-  public int hashCode() {\n+  @Override public int hashCode() {\n     return Objects.hashCode(type, parameters);\n   }\n \n-  @Override\n-  public String toString() {\n-    return Writables.writeToString(this);\n-  }\n-\n   public static ParameterizedTypeName create(ClassName className,\n       TypeName... parameters) {\n     return new ParameterizedTypeName(className, ImmutableList.copyOf(parameters));\n"
    },
    {
        "commit_hash": "8c0ca2307bc82ffc15dde0f0dd9eb105382fdb41",
        "previous_commit_hash": "d141cfb091f782eb18385c7c5d5e40326a6d883c",
        "diff_stats": {
            "additions": 1,
            "deletions": 15
        },
        "diff_content": "@@ -16,29 +16,15 @@\n package com.squareup.javawriter;\n \n import com.google.common.base.Ascii;\n-import com.google.common.collect.ImmutableSet;\n-import java.io.IOException;\n-import java.util.Set;\n import javax.lang.model.type.PrimitiveType;\n \n public enum PrimitiveName implements TypeName {\n   BOOLEAN, BYTE, SHORT, INT, LONG, CHAR, FLOAT, DOUBLE;\n \n-  @Override\n-  public Set<ClassName> referencedClasses() {\n-    return ImmutableSet.of();\n-  }\n-\n-  @Override\n-  public String toString() {\n+  @Override public String toString() {\n     return Ascii.toLowerCase(name());\n   }\n \n-  @Override\n-  public Appendable write(Appendable appendable, Context context) throws IOException {\n-    return appendable.append(toString());\n-  }\n-\n   static PrimitiveName forTypeMirror(PrimitiveType mirror) {\n     switch (mirror.getKind()) {\n       case BOOLEAN:\n"
    },
    {
        "commit_hash": "8c0ca2307bc82ffc15dde0f0dd9eb105382fdb41",
        "previous_commit_hash": "d141cfb091f782eb18385c7c5d5e40326a6d883c",
        "diff_stats": {
            "additions": 0,
            "deletions": 124
        },
        "diff_content": "@@ -1,124 +0,0 @@\n-/*\n- * Copyright (C) 2014 Google, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.squareup.javawriter;\n-\n-import com.google.common.base.Joiner;\n-import com.google.common.collect.FluentIterable;\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableSet;\n-import com.google.common.collect.Iterables;\n-import java.io.IOException;\n-import java.util.Collections;\n-import java.util.Formatter;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Set;\n-\n-public final class Snippet implements HasClassReferences, Writable {\n-  private final String format;\n-  private final ImmutableSet<TypeName> types;\n-  private final ImmutableList<Object> args;\n-\n-  private Snippet(String format, ImmutableSet<TypeName> types, ImmutableList<Object> args) {\n-    this.format = format;\n-    this.types = types;\n-    this.args = args;\n-  }\n-\n-  public String format() {\n-    return format;\n-  }\n-\n-  public ImmutableList<Object> args() {\n-    return args;\n-  }\n-\n-  public ImmutableSet<TypeName> types() {\n-    return types;\n-  }\n-\n-  @Override\n-  public String toString() {\n-    return Writables.writeToString(this);\n-  }\n-\n-  @Override\n-  public Set<ClassName> referencedClasses() {\n-    return FluentIterable.from(types)\n-        .transformAndConcat(GET_REFERENCED_CLASSES)\n-        .toSet();\n-  }\n-\n-  @Override\n-  public Appendable write(Appendable appendable, Context context) throws IOException {\n-    ImmutableList.Builder<Object> formattedArgsBuilder = ImmutableList.builder();\n-    for (Object arg : args) {\n-      if (arg instanceof Writable) {\n-        formattedArgsBuilder.add(((Writable) arg).write(new StringBuilder(), context).toString());\n-      } else {\n-        formattedArgsBuilder.add(arg);\n-      }\n-    }\n-\n-    @SuppressWarnings(\"resource\") // intentionally don't close the formatter\n-    Formatter formatter = new Formatter(appendable);\n-    formatter.format(format, formattedArgsBuilder.build().toArray());\n-\n-    return appendable;\n-  }\n-\n-  public static Snippet format(String format, Object... args) {\n-    ImmutableSet.Builder<TypeName> types = ImmutableSet.builder();\n-    for (Object arg : args) {\n-      if (arg instanceof HasClassReferences) {\n-        types.addAll(((HasClassReferences) arg).referencedClasses());\n-      }\n-      if (arg instanceof HasTypeName) {\n-        types.addAll(((HasTypeName) arg).name().referencedClasses());\n-      }\n-    }\n-    return new Snippet(format, types.build(), ImmutableList.copyOf(args));\n-  }\n-\n-  public static Snippet format(String format, Iterable<?> args) {\n-    return format(format, Iterables.toArray(args, Object.class));\n-  }\n-\n-  public static Snippet memberSelectSnippet(Iterable<?> selectors) {\n-    return format(Joiner.on('.').join(Collections.nCopies(Iterables.size(selectors), \"%s\")),\n-        selectors);\n-  }\n-\n-  public static Snippet makeParametersSnippet(List<Snippet> parameterSnippets) {\n-    Iterator<Snippet> iterator = parameterSnippets.iterator();\n-    StringBuilder stringBuilder = new StringBuilder();\n-    ImmutableSet.Builder<TypeName> typesBuilder = ImmutableSet.builder();\n-    ImmutableList.Builder<Object> argsBuilder = ImmutableList.builder();\n-    if (iterator.hasNext()) {\n-      Snippet firstSnippet = iterator.next();\n-      stringBuilder.append(firstSnippet.format());\n-      typesBuilder.addAll(firstSnippet.types());\n-      argsBuilder.addAll(firstSnippet.args());\n-    }\n-    while (iterator.hasNext()) {\n-      Snippet nextSnippet = iterator.next();\n-      stringBuilder.append(\", \").append(nextSnippet.format());\n-      typesBuilder.addAll(nextSnippet.types());\n-      argsBuilder.addAll(nextSnippet.args());\n-    }\n-    return new Snippet(stringBuilder.toString(), typesBuilder.build(), argsBuilder.build());\n-  }\n-}\n"
    },
    {
        "commit_hash": "8c0ca2307bc82ffc15dde0f0dd9eb105382fdb41",
        "previous_commit_hash": "d141cfb091f782eb18385c7c5d5e40326a6d883c",
        "diff_stats": {
            "additions": 2,
            "deletions": 4
        },
        "diff_content": "@@ -82,13 +82,11 @@ public final class StringLiteral {\n     return literal;\n   }\n \n-  @Override\n-  public String toString() {\n+  @Override public String toString() {\n     return literal;\n   }\n \n-  @Override\n-  public boolean equals(Object obj) {\n+  @Override public boolean equals(Object obj) {\n     if (obj == this) {\n       return true;\n     } else if (obj instanceof StringLiteral) {\n"
    },
    {
        "commit_hash": "8c0ca2307bc82ffc15dde0f0dd9eb105382fdb41",
        "previous_commit_hash": "d141cfb091f782eb18385c7c5d5e40326a6d883c",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -15,5 +15,5 @@\n  */\n package com.squareup.javawriter;\n \n-public interface TypeName extends HasClassReferences, Writable {\n+public interface TypeName {\n }\n"
    },
    {
        "commit_hash": "8c0ca2307bc82ffc15dde0f0dd9eb105382fdb41",
        "previous_commit_hash": "d141cfb091f782eb18385c7c5d5e40326a6d883c",
        "diff_stats": {
            "additions": 2,
            "deletions": 26
        },
        "diff_content": "@@ -20,8 +20,6 @@ import com.google.common.base.Predicates;\n import com.google.common.collect.FluentIterable;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Iterables;\n-import java.io.IOException;\n-import java.util.Set;\n import javax.lang.model.element.NestingKind;\n import javax.lang.model.element.TypeElement;\n import javax.lang.model.type.DeclaredType;\n@@ -84,23 +82,7 @@ public final class TypeVariableName implements TypeName {\n     return name;\n   }\n \n-  @Override\n-  public Set<ClassName> referencedClasses() {\n-    return upperBound.referencedClasses();\n-  }\n-\n-  @Override\n-  public Appendable write(Appendable appendable, Context context) throws IOException {\n-    appendable.append(name);\n-    if (!upperBound.equals(ClassName.OBJECT)) {\n-      appendable.append(\" extends \");\n-      upperBound.write(appendable, context);\n-    }\n-    return appendable;\n-  }\n-\n-  @Override\n-  public boolean equals(Object obj) {\n+  @Override public boolean equals(Object obj) {\n     if (obj instanceof TypeVariableName) {\n       TypeVariableName that = (TypeVariableName) obj;\n       return this.name.equals(that.name)\n@@ -110,13 +92,7 @@ public final class TypeVariableName implements TypeName {\n     }\n   }\n \n-  @Override\n-  public int hashCode() {\n+  @Override public int hashCode() {\n     return Objects.hashCode(name, upperBound);\n   }\n-\n-  @Override\n-  public String toString() {\n-    return Writables.writeToString(this);\n-  }\n }\n"
    },
    {
        "commit_hash": "8c0ca2307bc82ffc15dde0f0dd9eb105382fdb41",
        "previous_commit_hash": "d141cfb091f782eb18385c7c5d5e40326a6d883c",
        "diff_stats": {
            "additions": 0,
            "deletions": 287
        },
        "diff_content": "@@ -1,287 +0,0 @@\n-/*\n- * Copyright (C) 2014 Google, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.squareup.javawriter;\n-\n-import com.google.common.base.Function;\n-import com.google.common.base.Optional;\n-import com.google.common.collect.BiMap;\n-import com.google.common.collect.FluentIterable;\n-import com.google.common.collect.HashBiMap;\n-import com.google.common.collect.ImmutableSet;\n-import com.google.common.collect.ImmutableSortedSet;\n-import com.google.common.collect.Iterables;\n-import com.google.common.collect.Lists;\n-import com.google.common.collect.Ordering;\n-import com.google.common.collect.Queues;\n-import com.google.common.collect.Sets;\n-import java.io.IOException;\n-import java.util.Deque;\n-import java.util.List;\n-import java.util.Set;\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.type.TypeMirror;\n-\n-/**\n- * Only named types. Doesn't cover anonymous inner classes.\n- */\n-public abstract class TypeWriter /* ha ha */ extends Modifiable\n-    implements Writable, HasTypeName {\n-  final ClassName name;\n-  final List<TypeName> implementedTypes;\n-  final ClassBodyWriter body;\n-  private final List<ClassName> explicitImports;\n-  private final List<Element> originatingElements;\n-\n-  TypeWriter(ClassName name) {\n-    this.name = name;\n-    this.implementedTypes = Lists.newArrayList();\n-    this.body = ClassBodyWriter.forNamedType(name);\n-    this.explicitImports = Lists.newArrayList();\n-    this.originatingElements = Lists.newArrayList();\n-  }\n-\n-  /**\n-   * Add an originating element for which this type is being generated.\n-   *\n-   * @see JavaWriter#writeTo\n-   */\n-  public void addOriginatingElement(Element element) {\n-    originatingElements.add(element);\n-  }\n-\n-  /**\n-   * Add originating elements for which this type is being generated.\n-   *\n-   * @see JavaWriter#writeTo\n-   */\n-  public void addOriginatingElements(Element first, Element second, Element... rest) {\n-    addOriginatingElements(Lists.asList(first, second, rest));\n-  }\n-\n-  /**\n-   * Add originating elements for which this type is being generated.\n-   *\n-   * @see JavaWriter#writeTo\n-   */\n-  public void addOriginatingElements(Iterable<? extends Element> elements) {\n-    Iterables.addAll(originatingElements, elements);\n-  }\n-\n-  @Override\n-  public ClassName name() {\n-    return name;\n-  }\n-\n-  public void addImport(Class<?> clazz) {\n-    addImport(ClassName.fromClass(clazz));\n-  }\n-\n-  public void addImport(ClassName className) {\n-    explicitImports.add(className);\n-  }\n-\n-  public MethodWriter addMethod(TypeWriter returnType, String name) {\n-    return body.addMethod(returnType, name);\n-  }\n-\n-  public MethodWriter addMethod(TypeMirror returnType, String name) {\n-    return body.addMethod(returnType, name);\n-  }\n-\n-  public MethodWriter addMethod(TypeName returnType, String name) {\n-    return body.addMethod(returnType, name);\n-  }\n-\n-  public MethodWriter addMethod(Class<?> returnType, String name) {\n-    return body.addMethod(returnType, name);\n-  }\n-\n-  public ClassWriter addNestedClass(String name) {\n-    return body.addNestedClass(name);\n-  }\n-\n-  public InterfaceWriter addNestedInterface(String name) {\n-    return body.addNestedInterface(name);\n-  }\n-\n-  public EnumWriter addNestedEnum(String name) {\n-    return body.addNestedEnum(name);\n-  }\n-\n-  public void addImplementedType(TypeName typeReference) {\n-    implementedTypes.add(typeReference);\n-  }\n-\n-  public void addImplementedType(TypeElement typeElement) {\n-    implementedTypes.add(ClassName.fromTypeElement(typeElement));\n-  }\n-\n-  public FieldWriter addField(Class<?> type, String name) {\n-    return body.addField(type, name);\n-  }\n-\n-  public FieldWriter addField(TypeElement type, String name) {\n-    return body.addField(type, name);\n-  }\n-\n-  public FieldWriter addField(TypeName type, String name) {\n-    return body.addField(type, name);\n-  }\n-\n-  @Override public final String toString() {\n-    try {\n-      return writeTypeToAppendable(new StringBuilder()).toString();\n-    } catch (IOException e) {\n-      throw new AssertionError(e);\n-    }\n-  }\n-\n-  @Override public Set<ClassName> referencedClasses() {\n-    @SuppressWarnings(\"unchecked\")\n-    Iterable<? extends HasClassReferences> concat =\n-        Iterables.concat(super.referencedClasses(), implementedTypes, ImmutableSet.of(body),\n-            explicitImports);\n-    return FluentIterable.from(concat)\n-        .transformAndConcat(GET_REFERENCED_CLASSES)\n-        .toSet();\n-  }\n-\n-  Set<Element> originatingElements() {\n-    ImmutableSet.Builder<Element> elements = ImmutableSet.builder();\n-    elements.addAll(originatingElements);\n-    for (TypeWriter nestedTypeWriter : body.nestedTypeWriters) {\n-      elements.addAll(nestedTypeWriter.originatingElements());\n-    }\n-    return elements.build();\n-  }\n-\n-  Appendable writeTypeToAppendable(Appendable appendable) throws IOException {\n-    String packageName = name().packageName();\n-    appendable.append(\"package \").append(packageName).append(\";\\n\\n\");\n-\n-    ImmutableSortedSet<ClassName> importCandidates = ImmutableSortedSet.<ClassName>naturalOrder()\n-        .addAll(explicitImports)\n-        .addAll(referencedClasses())\n-        .build();\n-\n-    ImmutableSet.Builder<String> declaredSimpleNamesBuilder = ImmutableSet.builder();\n-    Deque<TypeWriter> declaredTypes = Queues.newArrayDeque(ImmutableSet.of(this));\n-    while (!declaredTypes.isEmpty()) {\n-      TypeWriter currentType = declaredTypes.pop();\n-      declaredSimpleNamesBuilder.add(currentType.name().simpleName());\n-      declaredTypes.addAll(currentType.body.nestedTypeWriters);\n-    }\n-\n-    ImmutableSet<String> declaredSimpleNames = declaredSimpleNamesBuilder.build();\n-\n-    BiMap<String, ClassName> importedClassIndex = HashBiMap.create();\n-    for (ClassName className : importCandidates) {\n-      if (!(className.packageName().equals(packageName)\n-          && !className.enclosingClassName().isPresent())\n-          && !(className.packageName().equals(\"java.lang\")\n-          && className.enclosingSimpleNames().isEmpty())\n-          && !name().equals(className.topLevelClassName())) {\n-        Optional<ClassName> importCandidate = Optional.of(className);\n-        while (importCandidate.isPresent()\n-            && (importedClassIndex.containsKey(importCandidate.get().simpleName())\n-            || declaredSimpleNames.contains(importCandidate.get().simpleName()))) {\n-          importCandidate = importCandidate.get().enclosingClassName();\n-        }\n-        if (importCandidate.isPresent()) {\n-          appendable.append(\"import \").append(importCandidate.get().canonicalName()).append(\";\\n\");\n-          importedClassIndex.put(importCandidate.get().simpleName(), importCandidate.get());\n-        }\n-      }\n-    }\n-\n-    if (!importedClassIndex.isEmpty()) {\n-      appendable.append('\\n');\n-    }\n-\n-    CompilationUnitContext context =\n-        new CompilationUnitContext(packageName, ImmutableSet.copyOf(importedClassIndex.values()));\n-    write(appendable, context.createSubcontext(ImmutableSet.of(name())));\n-\n-    return appendable;\n-  }\n-\n-  protected Context createSubcontext(Context context) {\n-    return context.createSubcontext(FluentIterable.from(body.nestedTypeWriters)\n-        .transform(new Function<TypeWriter, ClassName>() {\n-          @Override public ClassName apply(TypeWriter input) {\n-            return input.name();\n-          }\n-        })\n-        .toSet());\n-  }\n-\n-  static final class CompilationUnitContext implements Context {\n-    private final String packageName;\n-    private final ImmutableSortedSet<ClassName> visibleClasses;\n-\n-    CompilationUnitContext(String packageName, Set<ClassName> visibleClasses) {\n-      this.packageName = packageName;\n-      this.visibleClasses =\n-          ImmutableSortedSet.copyOf(Ordering.natural().reverse(), visibleClasses);\n-    }\n-\n-    @Override\n-    public Context createSubcontext(Set<ClassName> newTypes) {\n-      return new CompilationUnitContext(packageName, Sets.union(visibleClasses, newTypes));\n-    }\n-\n-    @Override\n-    public String sourceReferenceForClassName(ClassName className) {\n-      if (isImported(className)) {\n-        return className.simpleName();\n-      }\n-      Optional<ClassName> enclosingClassName = className.enclosingClassName();\n-      while (enclosingClassName.isPresent()) {\n-        if (isImported(enclosingClassName.get())) {\n-          return enclosingClassName.get().simpleName()\n-              + className.canonicalName()\n-                  .substring(enclosingClassName.get().canonicalName().length());\n-        }\n-        enclosingClassName = enclosingClassName.get().enclosingClassName();\n-      }\n-      return className.canonicalName();\n-    }\n-\n-    private boolean collidesWithVisibleClass(ClassName className) {\n-      return collidesWithVisibleClass(className.simpleName());\n-    }\n-\n-    private boolean collidesWithVisibleClass(String simpleName) {\n-      return FluentIterable.from(visibleClasses)\n-          .transform(new Function<ClassName, String>() {\n-            @Override public String apply(ClassName input) {\n-              return input.simpleName();\n-            }\n-          })\n-          .contains(simpleName);\n-    }\n-\n-    private boolean isImported(ClassName className) {\n-      return (packageName.equals(className.packageName())\n-              && !className.enclosingClassName().isPresent()\n-              && !collidesWithVisibleClass(className)) // need to account for scope & hiding\n-          || visibleClasses.contains(className)\n-          || (className.packageName().equals(\"java.lang\")\n-              && className.enclosingSimpleNames().isEmpty());\n-    }\n-  }\n-}\n"
    },
    {
        "commit_hash": "8c0ca2307bc82ffc15dde0f0dd9eb105382fdb41",
        "previous_commit_hash": "d141cfb091f782eb18385c7c5d5e40326a6d883c",
        "diff_stats": {
            "additions": 0,
            "deletions": 50
        },
        "diff_content": "@@ -1,50 +0,0 @@\n-/*\n- * Copyright (C) 2014 Google, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.squareup.javawriter;\n-\n-import com.google.common.collect.FluentIterable;\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.Iterables;\n-import java.util.Set;\n-\n-import static com.google.common.base.Preconditions.checkNotNull;\n-\n-public abstract class VariableWriter extends Modifiable implements Writable {\n-  private final TypeName type;\n-  private final String name;\n-\n-  VariableWriter(TypeName type, String name) {\n-    this.type = checkNotNull(type);\n-    this.name = checkNotNull(name);\n-  }\n-\n-  public TypeName type() {\n-    return type;\n-  }\n-\n-  public String name() {\n-    return name;\n-  }\n-\n-  @Override\n-  public Set<ClassName> referencedClasses() {\n-    Iterable<? extends HasClassReferences> concat =\n-        Iterables.concat(super.referencedClasses(), ImmutableList.of(type));\n-    return FluentIterable.from(concat)\n-        .transformAndConcat(GET_REFERENCED_CLASSES)\n-        .toSet();\n-  }\n-}\n"
    },
    {
        "commit_hash": "8c0ca2307bc82ffc15dde0f0dd9eb105382fdb41",
        "previous_commit_hash": "d141cfb091f782eb18385c7c5d5e40326a6d883c",
        "diff_stats": {
            "additions": 1,
            "deletions": 16
        },
        "diff_content": "@@ -15,25 +15,10 @@\n  */\n package com.squareup.javawriter;\n \n-import com.google.common.collect.ImmutableSet;\n-import java.io.IOException;\n-import java.util.Set;\n-\n public enum VoidName implements TypeName {\n   VOID;\n \n-  @Override\n-  public Set<ClassName> referencedClasses() {\n-    return ImmutableSet.of();\n-  }\n-\n-  @Override\n-  public String toString() {\n+  @Override public String toString() {\n     return \"void\";\n   }\n-\n-  @Override\n-  public Appendable write(Appendable appendable, Context context) throws IOException {\n-    return appendable.append(\"void\");\n-  }\n }\n"
    },
    {
        "commit_hash": "8c0ca2307bc82ffc15dde0f0dd9eb105382fdb41",
        "previous_commit_hash": "d141cfb091f782eb18385c7c5d5e40326a6d883c",
        "diff_stats": {
            "additions": 0,
            "deletions": 25
        },
        "diff_content": "@@ -16,10 +16,6 @@\n package com.squareup.javawriter;\n \n import com.google.common.base.Optional;\n-import com.google.common.collect.FluentIterable;\n-import com.google.common.collect.Iterables;\n-import java.io.IOException;\n-import java.util.Set;\n import javax.lang.model.type.WildcardType;\n \n import static com.squareup.javawriter.TypeNames.FOR_TYPE_MIRROR;\n@@ -59,25 +55,4 @@ public final class WildcardName implements TypeName {\n   public static WildcardName createWithLowerBound(TypeName lowerBound) {\n     return new WildcardName(Optional.<TypeName>absent(), Optional.of(lowerBound));\n   }\n-\n-  @Override\n-  public Set<ClassName> referencedClasses() {\n-    return FluentIterable.from(Iterables.concat(extendsBound.asSet(), superBound.asSet()))\n-        .transformAndConcat(GET_REFERENCED_CLASSES)\n-        .toSet();\n-  }\n-\n-  @Override\n-  public Appendable write(Appendable appendable, Context context) throws IOException {\n-    appendable.append('?');\n-    if (extendsBound.isPresent()) {\n-      appendable.append(\" extends \");\n-      extendsBound.get().write(appendable, context);\n-    }\n-    if (superBound.isPresent()) {\n-      appendable.append(\" super \");\n-      superBound.get().write(appendable, context);\n-    }\n-    return appendable;\n-  }\n }\n"
    },
    {
        "commit_hash": "8c0ca2307bc82ffc15dde0f0dd9eb105382fdb41",
        "previous_commit_hash": "d141cfb091f782eb18385c7c5d5e40326a6d883c",
        "diff_stats": {
            "additions": 0,
            "deletions": 28
        },
        "diff_content": "@@ -1,28 +0,0 @@\n-/*\n- * Copyright (C) 2014 Google, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.squareup.javawriter;\n-\n-import java.io.IOException;\n-import java.util.Set;\n-\n-interface Writable {\n-  interface Context {\n-    String sourceReferenceForClassName(ClassName className);\n-    Context createSubcontext(Set<ClassName> newTypes);\n-  }\n-\n-  Appendable write(Appendable appendable, Context context) throws IOException;\n-}\n"
    },
    {
        "commit_hash": "8c0ca2307bc82ffc15dde0f0dd9eb105382fdb41",
        "previous_commit_hash": "d141cfb091f782eb18385c7c5d5e40326a6d883c",
        "diff_stats": {
            "additions": 0,
            "deletions": 133
        },
        "diff_content": "@@ -1,133 +0,0 @@\n-/*\n- * Copyright (C) 2014 Google, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.squareup.javawriter;\n-\n-import com.google.common.collect.Iterators;\n-import com.squareup.javawriter.Writable.Context;\n-import java.io.IOException;\n-import java.util.Iterator;\n-import java.util.Set;\n-\n-import static com.google.common.base.Preconditions.checkNotNull;\n-\n-final class Writables {\n-\n-  static class Joiner {\n-    static Joiner on(String separator) {\n-      return new Joiner(separator);\n-    }\n-\n-    static Joiner on(char separator) {\n-      return on(String.valueOf(separator));\n-    }\n-\n-    private final String separator;\n-\n-    private Joiner(String separator) {\n-      this.separator = separator;\n-    }\n-\n-    protected Joiner(Joiner prototype) {\n-      this.separator = prototype.separator;\n-    }\n-\n-    final Appendable appendTo(Appendable appendable, Context context, Writable[] parts)\n-        throws IOException {\n-      return appendTo(appendable, context, Iterators.forArray(parts));\n-    }\n-\n-    final Appendable appendTo(Appendable appendable, Context context, Writable part1,\n-        Writable part2, Writable... parts) throws IOException {\n-      return appendTo(appendable, context,\n-          Iterators.concat(Iterators.forArray(part1, part2), Iterators.forArray(parts)));\n-    }\n-\n-    final Appendable appendTo(Appendable appendable, Context context,\n-        Iterable<? extends Writable> parts) throws IOException {\n-      return appendTo(appendable, context, parts.iterator());\n-    }\n-\n-    Appendable appendTo(Appendable appendable, Context context, Iterator<? extends Writable> parts)\n-        throws IOException {\n-      checkNotNull(appendable);\n-      checkNotNull(context);\n-      if (parts.hasNext()) {\n-        parts.next().write(appendable, context);\n-        while (parts.hasNext()) {\n-          appendable.append(separator);\n-          parts.next().write(appendable, context);\n-        }\n-      }\n-      return appendable;\n-    }\n-\n-    final Joiner prefix(String prefix) {\n-      return wrap(prefix, \"\");\n-    }\n-\n-    final Joiner wrap(final String prefix, final String suffix) {\n-      return new Joiner(this) {\n-        @Override\n-        Appendable appendTo(Appendable appendable, Context context,\n-            Iterator<? extends Writable> parts) throws IOException {\n-          boolean needsWrap = parts.hasNext();\n-          if (needsWrap) {\n-            appendable.append(prefix);\n-          }\n-          super.appendTo(appendable, context, parts);\n-          if (needsWrap) {\n-            appendable.append(suffix);\n-          }\n-          return appendable;\n-        }\n-      };\n-    }\n-  }\n-\n-  static Writable toStringWritable(final Object object) {\n-    return new Writable() {\n-      @Override\n-      public Appendable write(Appendable appendable, Context context) throws IOException {\n-        return appendable.append(object.toString());\n-      }\n-    };\n-  }\n-\n-  private static final Context DEFAULT_CONTEXT = new Context() {\n-    @Override\n-    public String sourceReferenceForClassName(ClassName className) {\n-      return className.canonicalName();\n-    }\n-\n-    @Override\n-    public Context createSubcontext(Set<ClassName> newTypes) {\n-      return this;\n-    }\n-  };\n-\n-  static String writeToString(Writable writable) {\n-    StringBuilder builder = new StringBuilder();\n-    try {\n-      writable.write(builder, DEFAULT_CONTEXT);\n-    } catch (IOException e) {\n-      throw new AssertionError(\"StringBuilder doesn't throw IOException\" + e);\n-    }\n-    return builder.toString();\n-  }\n-\n-  private Writables() {\n-  }\n-}\n"
    },
    {
        "commit_hash": "8c0ca2307bc82ffc15dde0f0dd9eb105382fdb41",
        "previous_commit_hash": "d141cfb091f782eb18385c7c5d5e40326a6d883c",
        "diff_stats": {
            "additions": 30,
            "deletions": 0
        },
        "diff_content": "@@ -21,7 +21,9 @@ import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableMap;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.ImmutableSortedMap;\n+import com.squareup.javawriter.ArrayTypeName;\n import com.squareup.javawriter.ClassName;\n+import com.squareup.javawriter.IntersectionTypeName;\n import com.squareup.javawriter.ParameterizedTypeName;\n import com.squareup.javawriter.PrimitiveName;\n import com.squareup.javawriter.StringLiteral;\n@@ -36,6 +38,7 @@ import java.util.LinkedHashMap;\n import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n+import java.util.Objects;\n import java.util.Set;\n import javax.lang.model.element.Modifier;\n \n@@ -229,6 +232,15 @@ final class CodeWriter {\n       emitAndIndent(typeName.toString());\n     } else if (typeName instanceof VoidName) {\n       emitAndIndent(typeName.toString());\n+    } else if (typeName instanceof ArrayTypeName) {\n+      emit(\"$T[]\", ((ArrayTypeName) typeName).componentType());\n+    } else if (typeName instanceof IntersectionTypeName) {\n+      boolean first = true;\n+      for (TypeName bound : ((IntersectionTypeName) typeName).typeNames()) {\n+        if (!first) emit(\" & \");\n+        emit(\"$T\", bound);\n+        first = false;\n+      }\n     } else {\n       throw new UnsupportedOperationException(\"unexpected type: \" + arg);\n     }\n@@ -242,6 +254,10 @@ final class CodeWriter {\n   private String lookupName(ClassName className) {\n     // Different package than current? Just look for an import.\n     if (!className.packageName().equals(packageName)) {\n+      if (conflictsWithLocalName(className)) {\n+        return className.toString(); // A local name conflicts? Use the fully-qualified name.\n+      }\n+\n       String importedName = importedTypes.get(className);\n       if (importedName != null) {\n         importableTypes.add(className);\n@@ -269,6 +285,20 @@ final class CodeWriter {\n     return Joiner.on('.').join(classNames.subList(prefixLength, classNames.size()));\n   }\n \n+  /**\n+   * Returns true if {@code className} conflicts with a visible class name in the current scope and\n+   * cannot be referred to by its short name.\n+   */\n+  private boolean conflictsWithLocalName(ClassName className) {\n+    for (TypeSpec typeSpec : typeSpecStack) {\n+      if (Objects.equals(typeSpec.name, className.simpleName())) return true;\n+      for (TypeSpec visibleChild : typeSpec.typeSpecs) {\n+        if (Objects.equals(visibleChild.name, className.simpleName())) return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n   /**\n    * Returns the common prefix of {@code classNames} and the current nesting scope. For example,\n    * suppose the current scope is {@code AbstractMap.SimpleEntry}. This will return 0 for {@code\n"
    },
    {
        "commit_hash": "8c0ca2307bc82ffc15dde0f0dd9eb105382fdb41",
        "previous_commit_hash": "d141cfb091f782eb18385c7c5d5e40326a6d883c",
        "diff_stats": {
            "additions": 21,
            "deletions": 6
        },
        "diff_content": "@@ -30,6 +30,7 @@ import java.util.Iterator;\n import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n+import javax.lang.model.element.Element;\n import javax.lang.model.element.Modifier;\n \n import static com.google.common.base.Preconditions.checkArgument;\n@@ -50,6 +51,7 @@ public final class TypeSpec {\n   public final ImmutableList<FieldSpec> fieldSpecs;\n   public final ImmutableList<MethodSpec> methodSpecs;\n   public final ImmutableList<TypeSpec> typeSpecs;\n+  public final ImmutableList<Element> originatingElements;\n \n   private TypeSpec(Builder builder) {\n     checkArgument(builder.name != null ^ builder.anonymousTypeArguments != null,\n@@ -91,6 +93,13 @@ public final class TypeSpec {\n     this.fieldSpecs = ImmutableList.copyOf(builder.fieldSpecs);\n     this.methodSpecs = ImmutableList.copyOf(builder.methodSpecs);\n     this.typeSpecs = ImmutableList.copyOf(builder.typeSpecs);\n+\n+    ImmutableList.Builder<Element> originatingElementsBuilder = ImmutableList.builder();\n+    originatingElementsBuilder.addAll(builder.originatingElements);\n+    for (TypeSpec typeSpec : builder.typeSpecs) {\n+      originatingElementsBuilder.addAll(typeSpec.originatingElements);\n+    }\n+    this.originatingElements = originatingElementsBuilder.build();\n   }\n \n   public boolean hasModifier(Modifier modifier) {\n@@ -219,14 +228,15 @@ public final class TypeSpec {\n     private final List<Modifier> modifiers = new ArrayList<>();\n     private Type type = Type.CLASS;\n     private String name;\n-    private List<TypeVariableName> typeVariables = new ArrayList<>();\n+    private final List<TypeVariableName> typeVariables = new ArrayList<>();\n     private TypeName superclass = ClassName.OBJECT;\n-    private List<TypeName> superinterfaces = new ArrayList<>();\n+    private final List<TypeName> superinterfaces = new ArrayList<>();\n     private Snippet anonymousTypeArguments;\n-    private Map<String, TypeSpec> enumConstants = new LinkedHashMap<>();\n-    private List<FieldSpec> fieldSpecs = new ArrayList<>();\n-    private List<MethodSpec> methodSpecs = new ArrayList<>();\n-    private List<TypeSpec> typeSpecs = new ArrayList<>();\n+    private final Map<String, TypeSpec> enumConstants = new LinkedHashMap<>();\n+    private final List<FieldSpec> fieldSpecs = new ArrayList<>();\n+    private final List<MethodSpec> methodSpecs = new ArrayList<>();\n+    private final List<TypeSpec> typeSpecs = new ArrayList<>();\n+    private final List<Element> originatingElements = new ArrayList<>();\n \n     public Builder addAnnotation(AnnotationSpec annotationSpec) {\n       this.annotations.add(annotationSpec);\n@@ -313,6 +323,11 @@ public final class TypeSpec {\n       return this;\n     }\n \n+    public Builder addOriginatingElement(Element originatingElement) {\n+      originatingElements.add(originatingElement);\n+      return this;\n+    }\n+\n     public TypeSpec build() {\n       return new TypeSpec(this);\n     }\n"
    },
    {
        "commit_hash": "8c0ca2307bc82ffc15dde0f0dd9eb105382fdb41",
        "previous_commit_hash": "d141cfb091f782eb18385c7c5d5e40326a6d883c",
        "diff_stats": {
            "additions": 3,
            "deletions": 6
        },
        "diff_content": "@@ -15,22 +15,19 @@\n  */\n package com.squareup.javawriter;\n \n-import com.squareup.javawriter.ClassNameTest.OuterClass.InnerClass;\n-\n import com.google.common.collect.ImmutableList;\n import com.google.testing.compile.CompilationRule;\n+import com.squareup.javawriter.ClassNameTest.OuterClass.InnerClass;\n import java.util.Map;\n import javax.lang.model.element.TypeElement;\n import javax.lang.model.util.Elements;\n import org.junit.Rule;\n import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.junit.runners.JUnit4;\n+\n import static com.google.common.truth.Truth.assert_;\n import static org.junit.Assert.fail;\n \n-@RunWith(JUnit4.class)\n-public class ClassNameTest {\n+public final class ClassNameTest {\n   @Rule public CompilationRule compilationRule = new CompilationRule();\n \n   @Test public void bestGuessForString_simpleClass() {\n"
    },
    {
        "commit_hash": "8c0ca2307bc82ffc15dde0f0dd9eb105382fdb41",
        "previous_commit_hash": "d141cfb091f782eb18385c7c5d5e40326a6d883c",
        "diff_stats": {
            "additions": 0,
            "deletions": 74
        },
        "diff_content": "@@ -1,74 +0,0 @@\n-/*\n- * Copyright (C) 2014 Square, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.squareup.javawriter;\n-\n-import com.google.common.base.Joiner;\n-import java.io.IOException;\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.junit.runners.JUnit4;\n-\n-import static com.google.common.truth.Truth.assertThat;\n-\n-@RunWith(JUnit4.class)\n-public final class IndentingAppendableTest {\n-  private final StringBuilder data = new StringBuilder();\n-  private final Appendable appendable = new IndentingAppendable(data);\n-\n-  @Test public void newlineCharacterNeverTriggerPendingIndent() throws IOException {\n-    appendable.append(\"Hello\\n\").append('\\n').append(\"World!\");\n-    assertThat(data.toString()).isEqualTo(Joiner.on('\\n').join(\n-        \"  Hello\",\n-        \"\",\n-        \"  World!\"\n-    ));\n-  }\n-\n-  @Test public void newlineStringNeverTriggerPendingIndent() throws IOException {\n-    appendable.append(\"Hello\\n\").append(\"\\n\").append(\"World!\");\n-    assertThat(data.toString()).isEqualTo(Joiner.on('\\n').join(\"  Hello\", \"\", \"  World!\"));\n-  }\n-\n-  @Test public void nestingAppendables() throws IOException {\n-    appendable.append(\"Hello\\n\");\n-    new IndentingAppendable(appendable).append(\"World\\n\");\n-    appendable.append(\"This Is\\n\");\n-    new IndentingAppendable(appendable).append(\"A Test\\n\");\n-\n-    assertThat(data.toString()).isEqualTo(Joiner.on('\\n').join(\n-        \"  Hello\",\n-        \"    World\",\n-        \"  This Is\",\n-        \"    A Test\",\n-        \"\"\n-    ));\n-  }\n-\n-  @Test public void nestingInsideContent() throws IOException {\n-    appendable.append(Joiner.on('\\n').join(\n-        \"def fib(num):\",\n-        \"  if num == 1 or num == 2:\",\n-        \"    return 1\",\n-        \"  return fib(num - 1) + fib(num - 2)\"\n-    ));\n-    assertThat(data.toString()).isEqualTo(Joiner.on('\\n').join(\n-        \"  def fib(num):\",\n-        \"    if num == 1 or num == 2:\",\n-        \"      return 1\",\n-        \"    return fib(num - 1) + fib(num - 2)\"\n-    ));\n-  }\n-}\n"
    },
    {
        "commit_hash": "8c0ca2307bc82ffc15dde0f0dd9eb105382fdb41",
        "previous_commit_hash": "d141cfb091f782eb18385c7c5d5e40326a6d883c",
        "diff_stats": {
            "additions": 62,
            "deletions": 56
        },
        "diff_content": "@@ -17,6 +17,7 @@ package com.squareup.javawriter;\n \n import com.google.common.collect.Iterables;\n import com.google.common.jimfs.Jimfs;\n+import com.squareup.javawriter.builders.TypeSpec;\n import java.io.File;\n import java.io.IOException;\n import java.nio.file.FileSystem;\n@@ -26,15 +27,12 @@ import javax.lang.model.element.Element;\n import org.junit.Rule;\n import org.junit.Test;\n import org.junit.rules.TemporaryFolder;\n-import org.junit.runner.RunWith;\n-import org.junit.runners.JUnit4;\n import org.mockito.Mockito;\n \n import static com.google.common.truth.Truth.assertThat;\n \n-@RunWith(JUnit4.class)\n public final class JavaWriterTest {\n-  private final JavaWriter javaWriter = JavaWriter.create();\n+  private final JavaWriter javaWriter = new JavaWriter();\n \n   // Used for testing java.io File behavior.\n   @Rule public final TemporaryFolder tmp = new TemporaryFolder();\n@@ -67,38 +65,43 @@ public final class JavaWriterTest {\n   }\n \n   @Test public void pathDefaultPackage() throws IOException {\n-    ClassName name = ClassName.create(\"\", \"Test\");\n-    ClassWriter test = ClassWriter.forClassName(name);\n-    javaWriter.addTypeWriter(test).writeTo(fsRoot);\n+    TypeSpec type = new TypeSpec.Builder()\n+        .name(\"Test\")\n+        .build();\n+    javaWriter.add(\"\", type).writeTo(fsRoot);\n \n     Path testPath = fsRoot.resolve(\"Test.java\");\n     assertThat(Files.exists(testPath)).isTrue();\n   }\n \n   @Test public void fileDefaultPackage() throws IOException {\n-    ClassName name = ClassName.create(\"\", \"Test\");\n-    ClassWriter test = ClassWriter.forClassName(name);\n-    javaWriter.addTypeWriter(test).writeTo(tmp.getRoot());\n+    TypeSpec type = new TypeSpec.Builder()\n+        .name(\"Test\")\n+        .build();\n+    javaWriter.add(\"\", type).writeTo(tmp.getRoot());\n \n     File testFile = new File(tmp.getRoot(), \"Test.java\");\n     assertThat(testFile.exists()).isTrue();\n   }\n \n   @Test public void filerDefaultPackage() throws IOException {\n-    ClassName name = ClassName.create(\"\", \"Test\");\n-    ClassWriter test = ClassWriter.forClassName(name);\n-    javaWriter.addTypeWriter(test).writeTo(filer);\n+    TypeSpec type = new TypeSpec.Builder()\n+        .name(\"Test\")\n+        .build();\n+    javaWriter.add(\"\", type).writeTo(filer);\n \n     Path testPath = fsRoot.resolve(\"Test.java\");\n     assertThat(Files.exists(testPath)).isTrue();\n   }\n \n   @Test public void pathSamePackage() throws IOException {\n-    ClassName name1 = ClassName.create(\"example\", \"Test1\");\n-    ClassName name2 = ClassName.create(\"example\", \"Test2\");\n-    ClassWriter test1 = ClassWriter.forClassName(name1);\n-    ClassWriter test2 = ClassWriter.forClassName(name2);\n-    javaWriter.addTypeWriters(test1, test2).writeTo(fsRoot);\n+    TypeSpec test1 = new TypeSpec.Builder()\n+        .name(\"Test1\")\n+        .build();\n+    TypeSpec test2 = new TypeSpec.Builder()\n+        .name(\"Test2\")\n+        .build();\n+    javaWriter.add(\"example\", test1).add(\"example\", test2).writeTo(fsRoot);\n \n     Path testPath1 = fsRoot.resolve(fs.getPath(\"example\", \"Test1.java\"));\n     assertThat(Files.exists(testPath1)).isTrue();\n@@ -107,11 +110,13 @@ public final class JavaWriterTest {\n   }\n \n   @Test public void fileSamePackage() throws IOException {\n-    ClassName name1 = ClassName.create(\"example\", \"Test1\");\n-    ClassName name2 = ClassName.create(\"example\", \"Test2\");\n-    ClassWriter test1 = ClassWriter.forClassName(name1);\n-    ClassWriter test2 = ClassWriter.forClassName(name2);\n-    javaWriter.addTypeWriters(test1, test2).writeTo(tmp.getRoot());\n+    TypeSpec test1 = new TypeSpec.Builder()\n+        .name(\"Test1\")\n+        .build();\n+    TypeSpec test2 = new TypeSpec.Builder()\n+        .name(\"Test2\")\n+        .build();\n+    javaWriter.add(\"example\", test1).add(\"example\", test2).writeTo(tmp.getRoot());\n \n     File examplePackage = new File(tmp.getRoot(), \"example\");\n     File testFile1 = new File(examplePackage, \"Test1.java\");\n@@ -121,11 +126,13 @@ public final class JavaWriterTest {\n   }\n \n   @Test public void filerSamePackage() throws IOException {\n-    ClassName name1 = ClassName.create(\"example\", \"Test1\");\n-    ClassName name2 = ClassName.create(\"example\", \"Test2\");\n-    ClassWriter test1 = ClassWriter.forClassName(name1);\n-    ClassWriter test2 = ClassWriter.forClassName(name2);\n-    javaWriter.addTypeWriters(test1, test2).writeTo(filer);\n+    TypeSpec test1 = new TypeSpec.Builder()\n+        .name(\"Test1\")\n+        .build();\n+    TypeSpec test2 = new TypeSpec.Builder()\n+        .name(\"Test2\")\n+        .build();\n+    javaWriter.add(\"example\", test1).add(\"example\", test2).writeTo(filer);\n \n     Path testPath1 = fsRoot.resolve(fs.getPath(\"example\", \"Test1.java\"));\n     assertThat(Files.exists(testPath1)).isTrue();\n@@ -134,13 +141,13 @@ public final class JavaWriterTest {\n   }\n \n   @Test public void pathNestedClasses() throws IOException {\n-    ClassName fooName = ClassName.create(\"foo\", \"Test\");\n-    ClassName barName = ClassName.create(\"foo.bar\", \"Test\");\n-    ClassName bazName = ClassName.create(\"foo.bar.baz\", \"Test\");\n-    ClassWriter foo = ClassWriter.forClassName(fooName);\n-    ClassWriter bar = ClassWriter.forClassName(barName);\n-    ClassWriter baz = ClassWriter.forClassName(bazName);\n-    javaWriter.addTypeWriters(foo, bar, baz).writeTo(fsRoot);\n+    TypeSpec test = new TypeSpec.Builder()\n+        .name(\"Test\")\n+        .build();\n+    javaWriter.add(\"foo\", test)\n+        .add(\"foo.bar\", test)\n+        .add(\"foo.bar.baz\", test)\n+        .writeTo(fsRoot);\n \n     Path fooPath = fsRoot.resolve(fs.getPath(\"foo\", \"Test.java\"));\n     Path barPath = fsRoot.resolve(fs.getPath(\"foo\", \"bar\", \"Test.java\"));\n@@ -151,13 +158,11 @@ public final class JavaWriterTest {\n   }\n \n   @Test public void fileNestedClasses() throws IOException {\n-    ClassName fooName = ClassName.create(\"foo\", \"Test\");\n-    ClassName barName = ClassName.create(\"foo.bar\", \"Test\");\n-    ClassName bazName = ClassName.create(\"foo.bar.baz\", \"Test\");\n-    ClassWriter foo = ClassWriter.forClassName(fooName);\n-    ClassWriter bar = ClassWriter.forClassName(barName);\n-    ClassWriter baz = ClassWriter.forClassName(bazName);\n-    javaWriter.addTypeWriters(foo, bar, baz).writeTo(tmp.getRoot());\n+    TypeSpec test = new TypeSpec.Builder().name(\"Test\").build();\n+    javaWriter.add(\"foo\", test)\n+        .add(\"foo.bar\", test)\n+        .add(\"foo.bar.baz\", test)\n+        .writeTo(tmp.getRoot());\n \n     File fooDir = new File(tmp.getRoot(), \"foo\");\n     File fooFile = new File(fooDir, \"Test.java\");\n@@ -171,13 +176,11 @@ public final class JavaWriterTest {\n   }\n \n   @Test public void filerNestedClasses() throws IOException {\n-    ClassName fooName = ClassName.create(\"foo\", \"Test\");\n-    ClassName barName = ClassName.create(\"foo.bar\", \"Test\");\n-    ClassName bazName = ClassName.create(\"foo.bar.baz\", \"Test\");\n-    ClassWriter foo = ClassWriter.forClassName(fooName);\n-    ClassWriter bar = ClassWriter.forClassName(barName);\n-    ClassWriter baz = ClassWriter.forClassName(bazName);\n-    javaWriter.addTypeWriters(foo, bar, baz).writeTo(filer);\n+    TypeSpec test = new TypeSpec.Builder().name(\"Test\").build();\n+    javaWriter.add(\"foo\", test)\n+        .add(\"foo.bar\", test)\n+        .add(\"foo.bar.baz\", test)\n+        .writeTo(filer);\n \n     Path fooPath = fsRoot.resolve(fs.getPath(\"foo\", \"Test.java\"));\n     Path barPath = fsRoot.resolve(fs.getPath(\"foo\", \"bar\", \"Test.java\"));\n@@ -188,18 +191,21 @@ public final class JavaWriterTest {\n   }\n \n   @Test public void filerPassesOriginatingElements() throws IOException {\n-    ClassName name1 = ClassName.create(\"example\", \"Test1\");\n-    ClassWriter test1 = ClassWriter.forClassName(name1);\n     Element element1_1 = Mockito.mock(Element.class);\n-    test1.addOriginatingElement(element1_1);\n+    TypeSpec test1 = new TypeSpec.Builder()\n+        .name(\"Test1\")\n+        .addOriginatingElement(element1_1)\n+        .build();\n \n-    ClassName name2 = ClassName.create(\"example\", \"Test2\");\n-    ClassWriter test2 = ClassWriter.forClassName(name2);\n     Element element2_1 = Mockito.mock(Element.class);\n     Element element2_2 = Mockito.mock(Element.class);\n-    test2.addOriginatingElements(element2_1, element2_2);\n+    TypeSpec test2 = new TypeSpec.Builder()\n+        .name(\"Test2\")\n+        .addOriginatingElement(element2_1)\n+        .addOriginatingElement(element2_2)\n+        .build();\n \n-    javaWriter.addTypeWriters(test1, test2).writeTo(filer);\n+    javaWriter.add(\"example\", test1).add(\"example\", test2).writeTo(filer);\n \n     Path testPath1 = fsRoot.resolve(fs.getPath(\"example\", \"Test1.java\"));\n     assertThat(filer.getOriginatingElements(testPath1)).containsExactly(element1_1);\n"
    },
    {
        "commit_hash": "8c0ca2307bc82ffc15dde0f0dd9eb105382fdb41",
        "previous_commit_hash": "d141cfb091f782eb18385c7c5d5e40326a6d883c",
        "diff_stats": {
            "additions": 1,
            "deletions": 4
        },
        "diff_content": "@@ -27,13 +27,10 @@ import javax.lang.model.type.TypeKind;\n import javax.lang.model.type.TypeMirror;\n import org.junit.Rule;\n import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.junit.runners.JUnit4;\n \n import static com.google.common.truth.Truth.assert_;\n \n-@RunWith(JUnit4.class)\n-public class TypeNamesTest {\n+public final class TypeNamesTest {\n   @Rule public final CompilationRule compilation = new CompilationRule();\n \n   private TypeElement getElement(Class<?> clazz) {\n"
    },
    {
        "commit_hash": "8c0ca2307bc82ffc15dde0f0dd9eb105382fdb41",
        "previous_commit_hash": "d141cfb091f782eb18385c7c5d5e40326a6d883c",
        "diff_stats": {
            "additions": 0,
            "deletions": 71
        },
        "diff_content": "@@ -1,71 +0,0 @@\n-/*\n- * Copyright (C) 2014 Google, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.squareup.javawriter;\n-\n-import com.google.common.collect.ImmutableList;\n-import java.util.concurrent.Executor;\n-import javax.lang.model.element.Element;\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.junit.runners.JUnit4;\n-import org.mockito.Mockito;\n-\n-import static com.google.common.truth.Truth.assertThat;\n-\n-@RunWith(JUnit4.class)\n-public class TypeWriterTest {\n-  @Test public void referencedAndDeclaredSimpleName() {\n-    ClassName name = ClassName.create(\"test\", \"Top\");\n-    ClassWriter topClass = ClassWriter.forClassName(name);\n-    topClass.addNestedClass(\"Middle\").addNestedClass(\"Bottom\");\n-    topClass.addField(ClassName.create(\"some.other.pkg\", \"Bottom\"), \"field\");\n-    assertThat(topClass.toString()).doesNotContain(\"import some.other.pkg.Bottom;\");\n-  }\n-\n-  @Test public void explicitImports() {\n-    ClassName name = ClassName.create(\"test\", \"Top\");\n-    ClassWriter topClass = ClassWriter.forClassName(name);\n-    topClass.addImport(ClassName.create(\"other\", \"Thing\"));\n-\n-    String expected = \"\"\n-        + \"package test;\\n\"\n-        + \"\\n\"\n-        + \"import other.Thing;\\n\"\n-        + \"\\n\"\n-        + \"class Top {}\\n\";\n-    assertThat(topClass.toString()).isEqualTo(expected);\n-  }\n-\n-  @Test public void nestedTypesPropagateOriginatingElements() {\n-    ClassWriter outer = ClassWriter.forClassName(ClassName.create(\"test\", \"Outer\"));\n-    Element outerElement = Mockito.mock(Element.class);\n-    outer.addOriginatingElement(outerElement);\n-\n-    ClassWriter middle = outer.addNestedClass(\"Middle\");\n-    Element middleElement1 = Mockito.mock(Element.class);\n-    Element middleElement2 = Mockito.mock(Element.class);\n-    middle.addOriginatingElements(middleElement1, middleElement2);\n-\n-    ClassWriter inner = middle.addNestedClass(\"Inner\");\n-    Element innerElement1 = Mockito.mock(Element.class);\n-    Element innerElement2 = Mockito.mock(Element.class);\n-    Element innerElement3 = Mockito.mock(Element.class);\n-    inner.addOriginatingElements(ImmutableList.of(innerElement1, innerElement2, innerElement3));\n-\n-    assertThat(outer.originatingElements()).containsExactly(outerElement, middleElement1,\n-        middleElement2, innerElement1, innerElement2, innerElement3);\n-  }\n-}\n"
    },
    {
        "commit_hash": "8c0ca2307bc82ffc15dde0f0dd9eb105382fdb41",
        "previous_commit_hash": "d141cfb091f782eb18385c7c5d5e40326a6d883c",
        "diff_stats": {
            "additions": 122,
            "deletions": 0
        },
        "diff_content": "@@ -17,21 +17,26 @@ package com.squareup.javawriter.builders;\n \n import com.google.common.collect.ImmutableList;\n import com.squareup.javawriter.ClassName;\n+import com.squareup.javawriter.IntersectionTypeName;\n import com.squareup.javawriter.ParameterizedTypeName;\n import com.squareup.javawriter.TypeVariableName;\n import com.squareup.javawriter.WildcardName;\n import java.io.IOException;\n import java.io.Serializable;\n import java.util.AbstractSet;\n+import java.util.Comparator;\n import java.util.List;\n+import javax.lang.model.element.Element;\n import javax.lang.model.element.Modifier;\n import org.junit.Test;\n+import org.mockito.Mockito;\n \n import static com.google.common.truth.Truth.assertThat;\n import static org.junit.Assert.fail;\n \n public final class TypeSpecTest {\n   private final String tacosPackage = \"com.squareup.tacos\";\n+  private static final String donutsPackage = \"com.squareup.donuts\";\n \n   @Test public void basic() throws Exception {\n     TypeSpec taco = new TypeSpec.Builder()\n@@ -688,6 +693,123 @@ public final class TypeSpecTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void referencedAndDeclaredSimpleNamesConflict() throws Exception {\n+    FieldSpec internalTop = FieldSpec.of(ClassName.create(tacosPackage, \"Top\"), \"internalTop\");\n+    FieldSpec internalBottom = FieldSpec.of(ClassName.create(\n+        tacosPackage, ImmutableList.of(\"Top\", \"Middle\"), \"Bottom\"), \"internalBottom\");\n+    FieldSpec externalTop = FieldSpec.of(\n+        ClassName.create(donutsPackage, \"Top\"), \"externalTop\");\n+    FieldSpec externalBottom = FieldSpec.of(\n+        ClassName.create(donutsPackage, \"Bottom\"), \"externalBottom\");\n+    TypeSpec top = new TypeSpec.Builder()\n+        .name(\"Top\")\n+        .addField(internalTop)\n+        .addField(internalBottom)\n+        .addField(externalTop)\n+        .addField(externalBottom)\n+        .addType(new TypeSpec.Builder()\n+            .name(\"Middle\")\n+            .addField(internalTop)\n+            .addField(internalBottom)\n+            .addField(externalTop)\n+            .addField(externalBottom)\n+            .addType(new TypeSpec.Builder()\n+                .name(\"Bottom\")\n+                .addField(internalTop)\n+                .addField(internalBottom)\n+                .addField(externalTop)\n+                .addField(externalBottom)\n+                .build())\n+            .build())\n+        .build();\n+    assertThat(toString(top)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import com.squareup.donuts.Bottom;\\n\"\n+        + \"\\n\"\n+        + \"class Top {\\n\"\n+        + \"  Top internalTop;\\n\"\n+        + \"\\n\"\n+        + \"  Middle.Bottom internalBottom;\\n\"\n+        + \"\\n\"\n+        + \"  com.squareup.donuts.Top externalTop;\\n\"\n+        + \"\\n\"\n+        + \"  Bottom externalBottom;\\n\"\n+        + \"\\n\"\n+        + \"  class Middle {\\n\"\n+        + \"    Top internalTop;\\n\"\n+        + \"\\n\"\n+        + \"    Bottom internalBottom;\\n\"\n+        + \"\\n\"\n+        + \"    com.squareup.donuts.Top externalTop;\\n\"\n+        + \"\\n\"\n+        + \"    com.squareup.donuts.Bottom externalBottom;\\n\"\n+        + \"\\n\"\n+        + \"    class Bottom {\\n\"\n+        + \"      Top internalTop;\\n\"\n+        + \"\\n\"\n+        + \"      Bottom internalBottom;\\n\"\n+        + \"\\n\"\n+        + \"      com.squareup.donuts.Top externalTop;\\n\"\n+        + \"\\n\"\n+        + \"      com.squareup.donuts.Bottom externalBottom;\\n\"\n+        + \"    }\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void originatingElementsIncludesThoseOfNestedTypes() {\n+    Element outerElement = Mockito.mock(Element.class);\n+    Element innerElement = Mockito.mock(Element.class);\n+    TypeSpec outer = new TypeSpec.Builder()\n+        .name(\"Outer\")\n+        .addOriginatingElement(outerElement)\n+        .addType(new TypeSpec.Builder()\n+            .name(\"Inner\")\n+            .addOriginatingElement(innerElement)\n+            .build())\n+        .build();\n+    assertThat(outer.originatingElements).containsExactly(outerElement, innerElement);\n+  }\n+\n+  @Test public void intersectionType() {\n+    TypeVariableName typeVariable = TypeVariableName.create(\"T\", IntersectionTypeName.create(\n+        ClassName.fromClass(Comparator.class), ClassName.fromClass(Serializable.class)));\n+    TypeSpec taco = new TypeSpec.Builder()\n+        .name(\"Taco\")\n+        .addMethod(new MethodSpec.Builder()\n+            .addTypeVariable(typeVariable)\n+            .returns(typeVariable)\n+            .name(\"getComparator\")\n+            .addCode(\"return null;\\n\")\n+            .build())\n+        .build();\n+    assertThat(toString(taco)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import java.io.Serializable;\\n\"\n+        + \"import java.util.Comparator;\\n\"\n+        + \"\\n\"\n+        + \"class Taco {\\n\"\n+        + \"  <T extends Comparator & Serializable> T getComparator() {\\n\"\n+        + \"    return null;\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void arrayType() {\n+    TypeSpec taco = new TypeSpec.Builder()\n+        .name(\"Taco\")\n+        .addField(FieldSpec.of(int[].class, \"ints\"))\n+        .build();\n+    assertThat(toString(taco)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"class Taco {\\n\"\n+        + \"  int[] ints;\\n\"\n+        + \"}\\n\");\n+  }\n+\n   private String toString(TypeSpec typeSpec) {\n     return new JavaFile.Builder()\n         .packageName(tacosPackage)\n"
    },
    {
        "commit_hash": "598b446b8cf567cb6308612357ef6b947d03971c",
        "previous_commit_hash": "cd75215134bb6032d8ff47d7792635cd228a7803",
        "diff_stats": {
            "additions": 0,
            "deletions": 1
        },
        "diff_content": "@@ -1,7 +1,6 @@\n language: java\n \n jdk:\n-  - oraclejdk7\n   - oraclejdk8\n \n after_success:\n"
    },
    {
        "commit_hash": "598b446b8cf567cb6308612357ef6b947d03971c",
        "previous_commit_hash": "cd75215134bb6032d8ff47d7792635cd228a7803",
        "diff_stats": {
            "additions": 11,
            "deletions": 16
        },
        "diff_content": "@@ -13,13 +13,12 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package com.squareup.javawriter.builders;\n+package com.squareup.javawriter;\n \n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.ImmutableSortedMap;\n import com.google.common.collect.Maps;\n-import com.squareup.javawriter.ClassName;\n-import java.lang.annotation.Annotation;\n+import java.lang.reflect.Type;\n import java.util.Iterator;\n import java.util.Map;\n import java.util.SortedMap;\n@@ -29,7 +28,7 @@ import static com.google.common.collect.Iterables.getOnlyElement;\n \n /** A generated annotation on a declaration. */\n public final class AnnotationSpec {\n-  public final ClassName type;\n+  public final Type type;\n   public final ImmutableSortedMap<String, Snippet> members;\n \n   private AnnotationSpec(Builder builder) {\n@@ -42,14 +41,14 @@ public final class AnnotationSpec {\n     String suffix = inline ? \" \" : \"\\n\";\n     if (members.isEmpty()) {\n       // @Singleton\n-      codeWriter.emit(\"@$T$L\", type, suffix);\n+      codeWriter.emit(\"@$T\" + suffix, type);\n     } else if (members.keySet().equals(ImmutableSet.of(\"value\"))) {\n       // @Named(\"foo\")\n       codeWriter.emit(\"@$T(\", type);\n       codeWriter.indent(2);\n       codeWriter.emit(getOnlyElement(members.values()));\n       codeWriter.unindent(2);\n-      codeWriter.emit(\")$L\", suffix);\n+      codeWriter.emit(\")\" + suffix);\n     } else {\n       // Inline:\n       //   @Column(name = \"updated_at\", nullable = false)\n@@ -59,25 +58,21 @@ public final class AnnotationSpec {\n       //       name = \"updated_at\",\n       //       nullable = false\n       //   )\n-      codeWriter.emit(\"@$T($L\", type, separator);\n+      codeWriter.emit(\"@$T(\" + separator, type);\n       codeWriter.indent(2);\n       for (Iterator<Map.Entry<String, Snippet>> i = members.entrySet().iterator(); i.hasNext();) {\n         Map.Entry<String, Snippet> entry = i.next();\n         codeWriter.emit(\"$L = \", entry.getKey());\n         codeWriter.emit(entry.getValue());\n         if (i.hasNext()) codeWriter.emit(\",\");\n-        codeWriter.emit(\"$L\", separator);\n+        codeWriter.emit(separator);\n       }\n       codeWriter.unindent(2);\n-      codeWriter.emit(\")$L\", suffix);\n+      codeWriter.emit(\")\" + suffix);\n     }\n   }\n \n-  public static AnnotationSpec of(Class<? extends Annotation> annotation) {\n-    return of(ClassName.fromClass(annotation));\n-  }\n-\n-  public static AnnotationSpec of(ClassName annotation) {\n+  public static AnnotationSpec of(Type annotation) {\n     return new Builder().type(annotation).build();\n   }\n \n@@ -92,10 +87,10 @@ public final class AnnotationSpec {\n   }\n \n   public static final class Builder {\n-    private ClassName type;\n+    private Type type;\n     private final SortedMap<String, Snippet> members = Maps.newTreeMap();\n \n-    public Builder type(ClassName type) {\n+    public Builder type(Type type) {\n       this.type = type;\n       return this;\n     }\n"
    },
    {
        "commit_hash": "598b446b8cf567cb6308612357ef6b947d03971c",
        "previous_commit_hash": "cd75215134bb6032d8ff47d7792635cd228a7803",
        "diff_stats": {
            "additions": 0,
            "deletions": 41
        },
        "diff_content": "@@ -1,41 +0,0 @@\n-/*\n- * Copyright (C) 2014 Google, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.squareup.javawriter;\n-\n-public final class ArrayTypeName implements TypeName {\n-  private final TypeName componentType;\n-\n-  ArrayTypeName(TypeName componentType) {\n-    this.componentType = componentType;\n-  }\n-\n-  public TypeName componentType() {\n-    return componentType;\n-  }\n-\n-  @Override public boolean equals(Object obj) {\n-    return (obj instanceof ArrayTypeName)\n-        & this.componentType.equals(((ArrayTypeName) obj).componentType);\n-  }\n-\n-  @Override public int hashCode() {\n-    return componentType.hashCode();\n-  }\n-\n-  public static ArrayTypeName create(TypeName componentType) {\n-    return new ArrayTypeName(componentType);\n-  }\n-}\n"
    },
    {
        "commit_hash": "598b446b8cf567cb6308612357ef6b947d03971c",
        "previous_commit_hash": "cd75215134bb6032d8ff47d7792635cd228a7803",
        "diff_stats": {
            "additions": 3,
            "deletions": 40
        },
        "diff_content": "@@ -24,8 +24,8 @@ import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n+import java.lang.reflect.Type;\n import java.util.Collections;\n-import java.util.Iterator;\n import java.util.List;\n import javax.lang.model.SourceVersion;\n import javax.lang.model.element.Element;\n@@ -45,7 +45,7 @@ import static javax.lang.model.element.NestingKind.TOP_LEVEL;\n  *\n  * @since 2.0\n  */\n-public final class ClassName implements TypeName, Comparable<ClassName> {\n+public final class ClassName implements Type, Comparable<ClassName> {\n   public static final ClassName OBJECT = ClassName.fromClass(Object.class);\n \n   private String fullyQualifiedName = null;\n@@ -69,8 +69,7 @@ public final class ClassName implements TypeName, Comparable<ClassName> {\n     return enclosingSimpleNames;\n   }\n \n-  // TODO(jwilson): make this package-private once builders and type names are in the same package.\n-  public ImmutableList<String> simpleNames() {\n+  ImmutableList<String> simpleNames() {\n     return new ImmutableList.Builder<String>()\n         .addAll(enclosingSimpleNames)\n         .add(simpleName)\n@@ -103,42 +102,6 @@ public final class ClassName implements TypeName, Comparable<ClassName> {\n     return fullyQualifiedName;\n   }\n \n-  public String classFileName() {\n-    StringBuilder builder = new StringBuilder();\n-    Joiner.on('$').appendTo(builder, enclosingSimpleNames());\n-    if (!enclosingSimpleNames().isEmpty()) {\n-      builder.append('$');\n-    }\n-    return builder.append(simpleName()).toString();\n-  }\n-\n-  public ClassName topLevelClassName() {\n-    Iterator<String> enclosingIterator = enclosingSimpleNames().iterator();\n-    return enclosingIterator.hasNext()\n-        ? new ClassName(packageName(), ImmutableList.<String>of(),\n-            enclosingIterator.next())\n-        : this;\n-  }\n-\n-  public ClassName nestedClassNamed(String memberClassName) {\n-    checkNotNull(memberClassName);\n-    checkArgument(SourceVersion.isIdentifier(memberClassName));\n-    checkArgument(Ascii.isUpperCase(memberClassName.charAt(0)));\n-    return new ClassName(packageName(),\n-        new ImmutableList.Builder<String>()\n-            .addAll(enclosingSimpleNames())\n-            .add(simpleName())\n-            .build(),\n-        memberClassName);\n-  }\n-\n-  public ClassName peerNamed(String peerClassName) {\n-    checkNotNull(peerClassName);\n-    checkArgument(SourceVersion.isIdentifier(peerClassName));\n-    checkArgument(Ascii.isUpperCase(peerClassName.charAt(0)));\n-    return new ClassName(packageName(), enclosingSimpleNames(), peerClassName);\n-  }\n-\n   private static final ImmutableSet<NestingKind> ACCEPTABLE_NESTING_KINDS =\n       Sets.immutableEnumSet(TOP_LEVEL, MEMBER);\n \n"
    },
    {
        "commit_hash": "598b446b8cf567cb6308612357ef6b947d03971c",
        "previous_commit_hash": "cd75215134bb6032d8ff47d7792635cd228a7803",
        "diff_stats": {
            "additions": 80,
            "deletions": 58
        },
        "diff_content": "@@ -13,7 +13,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package com.squareup.javawriter.builders;\n+package com.squareup.javawriter;\n \n import com.google.common.base.Ascii;\n import com.google.common.base.Joiner;\n@@ -21,17 +21,11 @@ import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableMap;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.ImmutableSortedMap;\n-import com.squareup.javawriter.ArrayTypeName;\n-import com.squareup.javawriter.ClassName;\n-import com.squareup.javawriter.IntersectionTypeName;\n-import com.squareup.javawriter.ParameterizedTypeName;\n-import com.squareup.javawriter.PrimitiveName;\n-import com.squareup.javawriter.StringLiteral;\n-import com.squareup.javawriter.TypeName;\n-import com.squareup.javawriter.TypeNames;\n-import com.squareup.javawriter.TypeVariableName;\n-import com.squareup.javawriter.VoidName;\n-import com.squareup.javawriter.WildcardName;\n+import java.lang.reflect.GenericArrayType;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+import java.lang.reflect.WildcardType;\n import java.util.ArrayList;\n import java.util.EnumSet;\n import java.util.LinkedHashMap;\n@@ -60,11 +54,19 @@ final class CodeWriter {\n   private final ImmutableMap<ClassName, String> importedTypes;\n   private final Set<ClassName> importableTypes = new LinkedHashSet<>();\n \n+  public CodeWriter(StringBuilder out) {\n+    this(out, ImmutableMap.<ClassName, String>of());\n+  }\n+\n   public CodeWriter(StringBuilder out, ImmutableMap<ClassName, String> importedTypes) {\n     this.out = checkNotNull(out);\n     this.importedTypes = checkNotNull(importedTypes);\n   }\n \n+  public ImmutableMap<ClassName, String> importedTypes() {\n+    return importedTypes;\n+  }\n+\n   public CodeWriter indent() {\n     return indent(1);\n   }\n@@ -135,19 +137,21 @@ final class CodeWriter {\n    * Emit type variables with their bounds. This should only be used when declaring type variables;\n    * everywhere else bounds are omitted.\n    */\n-  public void emitTypeVariables(ImmutableList<TypeVariableName> typeVariables) {\n+  public void emitTypeVariables(ImmutableList<TypeVariable<?>> typeVariables) {\n     if (typeVariables.isEmpty()) return;\n \n     emit(\"<\");\n-    boolean first = true;\n-    for (TypeVariableName typeVariable : typeVariables) {\n-      if (!first) emit(\", \");\n-      emit(\"$L\", typeVariable.name());\n-      TypeName upperBound = typeVariable.upperBound();\n-      if (!upperBound.equals(ClassName.OBJECT)) {\n-        emit(\" extends $T\", upperBound);\n+    boolean firstTypeVariable = true;\n+    for (TypeVariable<?> typeVariable : typeVariables) {\n+      if (!firstTypeVariable) emit(\", \");\n+      emit(\"$L\", typeVariable.getName());\n+      boolean firstBound = true;\n+      for (Type bound : typeVariable.getBounds()) {\n+        if (isObject(bound)) continue;\n+        emit(firstBound ? \" extends $T\" : \" & $T\", bound);\n+        firstBound = false;\n       }\n-      first = false;\n+      firstTypeVariable = false;\n     }\n     emit(\">\");\n   }\n@@ -198,52 +202,71 @@ final class CodeWriter {\n     }\n   }\n \n-  private void emitType(Object arg) {\n-    TypeName typeName = toTypeName(arg);\n+  private CodeWriter emitType(Object arg) {\n+    Type type = toType(arg);\n+\n+    if (type instanceof Class<?>) {\n+      Class<?> classType = (Class<?>) type;\n+      if (classType.isPrimitive()) {\n+        if (boolean.class == classType) return emit(\"boolean\");\n+        if (byte.class == classType) return emit(\"byte\");\n+        if (short.class == classType) return emit(\"short\");\n+        if (int.class == classType) return emit(\"int\");\n+        if (long.class == classType) return emit(\"long\");\n+        if (char.class == classType) return emit(\"char\");\n+        if (float.class == classType) return emit(\"float\");\n+        if (double.class == classType) return emit(\"double\");\n+        if (void.class == classType) return emit(\"void\");\n+      } else if (classType.isArray()) {\n+        return emit(\"$T[]\", classType.getComponentType());\n+      } else {\n+        return emitType(ClassName.fromClass(classType));\n+      }\n+    }\n \n-    // TODO(jwilson): replace instanceof nonsense with polymorphism!\n-    if (typeName instanceof ParameterizedTypeName) {\n-      ParameterizedTypeName parameterizedTypeName = (ParameterizedTypeName) typeName;\n-      emitType(parameterizedTypeName.type());\n+    if (type instanceof ParameterizedType) {\n+      ParameterizedType parameterizedType = (ParameterizedType) type;\n+      emitType(parameterizedType.getRawType());\n       emitAndIndent(\"<\");\n       boolean firstParameter = true;\n-      for (TypeName parameter : parameterizedTypeName.parameters()) {\n+      for (Type parameter : parameterizedType.getActualTypeArguments()) {\n         if (!firstParameter) emitAndIndent(\", \");\n         emitType(parameter);\n         firstParameter = false;\n       }\n       emitAndIndent(\">\");\n-    } else if (typeName instanceof WildcardName) {\n-      WildcardName wildcardName = (WildcardName) typeName;\n-      TypeName extendsBound = wildcardName.extendsBound();\n-      TypeName superBound = wildcardName.superBound();\n-      if (ClassName.fromClass(Object.class).equals(extendsBound)) {\n+    } else if (type instanceof WildcardType) {\n+      WildcardType wildcardName = (WildcardType) type;\n+      Type[] extendsBounds = wildcardName.getUpperBounds();\n+      Type[] superBounds = wildcardName.getLowerBounds();\n+      if (superBounds.length == 1) {\n+        emit(\"? super $T\", superBounds[0]);\n+      } else if (extendsBounds.length == 1 && !isObject(extendsBounds[0])) {\n+        emit(\"? extends $T\", extendsBounds[0]);\n+      } else {\n         emit(\"?\");\n-      } else if (extendsBound != null) {\n-        emit(\"? extends $T\", extendsBound);\n-      } else if (superBound != null) {\n-        emit(\"? super $T\", superBound);\n       }\n-    } else if (typeName instanceof TypeVariableName) {\n-      emit(\"$L\", ((TypeVariableName) typeName).name());\n-    } else if (typeName instanceof ClassName) {\n-      emitAndIndent(lookupName((ClassName) typeName));\n-    } else if (typeName instanceof PrimitiveName) {\n-      emitAndIndent(typeName.toString());\n-    } else if (typeName instanceof VoidName) {\n-      emitAndIndent(typeName.toString());\n-    } else if (typeName instanceof ArrayTypeName) {\n-      emit(\"$T[]\", ((ArrayTypeName) typeName).componentType());\n-    } else if (typeName instanceof IntersectionTypeName) {\n-      boolean first = true;\n-      for (TypeName bound : ((IntersectionTypeName) typeName).typeNames()) {\n-        if (!first) emit(\" & \");\n+    } else if (type instanceof TypeVariable<?>) {\n+      emit(\"$L\", ((TypeVariable) type).getName());\n+    } else if (type instanceof ClassName) {\n+      emitAndIndent(lookupName((ClassName) type));\n+    } else if (type instanceof GenericArrayType) {\n+      emit(\"$T[]\", ((GenericArrayType) type).getGenericComponentType());\n+    } else if (type instanceof IntersectionType) {\n+      boolean firstBound = true;\n+      for (Type bound : ((IntersectionType) type).getBounds()) {\n+        if (!firstBound) emit(\" & \");\n         emit(\"$T\", bound);\n-        first = false;\n+        firstBound = false;\n       }\n     } else {\n       throw new UnsupportedOperationException(\"unexpected type: \" + arg);\n     }\n+    return this;\n+  }\n+\n+  private boolean isObject(Type bound) {\n+    return bound == Object.class || bound.equals(ClassName.OBJECT);\n   }\n \n   /**\n@@ -336,9 +359,8 @@ final class CodeWriter {\n     }\n   }\n \n-  private TypeName toTypeName(Object arg) {\n-    if (arg instanceof TypeName) return (TypeName) arg;\n-    if (arg instanceof Class<?>) return TypeNames.forClass((Class<?>) arg);\n+  private Type toType(Object arg) {\n+    if (arg instanceof Type) return (Type) arg;\n     throw new IllegalArgumentException(\"Expected type but was \" + arg);\n   }\n \n@@ -363,9 +385,9 @@ final class CodeWriter {\n   ImmutableMap<ClassName, String> suggestedImports() {\n     // Find the simple names that can be imported, and the classes that they target.\n     Map<String, ClassName> simpleNameToType = new LinkedHashMap<>();\n-    for (TypeName typeName : importableTypes) {\n-      if (!(typeName instanceof ClassName)) continue;\n-      ClassName className = (ClassName) typeName;\n+    for (Type type : importableTypes) {\n+      if (!(type instanceof ClassName)) continue;\n+      ClassName className = (ClassName) type;\n       if (simpleNameToType.containsKey(className.simpleName())) continue;\n       simpleNameToType.put(className.simpleName(), className);\n     }\n"
    },
    {
        "commit_hash": "598b446b8cf567cb6308612357ef6b947d03971c",
        "previous_commit_hash": "cd75215134bb6032d8ff47d7792635cd228a7803",
        "diff_stats": {
            "additions": 7,
            "deletions": 17
        },
        "diff_content": "@@ -13,13 +13,11 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package com.squareup.javawriter.builders;\n+package com.squareup.javawriter;\n \n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n-import com.squareup.javawriter.TypeName;\n-import com.squareup.javawriter.TypeNames;\n-import java.lang.annotation.Annotation;\n+import java.lang.reflect.Type;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n@@ -31,7 +29,7 @@ import static com.google.common.base.Preconditions.checkNotNull;\n public final class FieldSpec {\n   public final ImmutableList<AnnotationSpec> annotations;\n   public final ImmutableSet<Modifier> modifiers;\n-  public final TypeName type;\n+  public final Type type;\n   public final Name name;\n   public final Snippet initializer;\n \n@@ -58,11 +56,7 @@ public final class FieldSpec {\n     codeWriter.emit(\";\\n\");\n   }\n \n-  public static FieldSpec of(Class<?> type, String name, Modifier... modifiers) {\n-    return of(TypeNames.forClass(type), name, modifiers);\n-  }\n-\n-  public static FieldSpec of(TypeName type, String name, Modifier... modifiers) {\n+  public static FieldSpec of(Type type, String name, Modifier... modifiers) {\n     return new Builder()\n         .type(type)\n         .name(name)\n@@ -73,7 +67,7 @@ public final class FieldSpec {\n   public static final class Builder {\n     private final List<AnnotationSpec> annotations = new ArrayList<>();\n     private final List<Modifier> modifiers = new ArrayList<>();\n-    private TypeName type;\n+    private Type type;\n     private Name name;\n     private Snippet initializer;\n \n@@ -82,7 +76,7 @@ public final class FieldSpec {\n       return this;\n     }\n \n-    public Builder addAnnotation(Class<? extends Annotation> annotation) {\n+    public Builder addAnnotation(Type annotation) {\n       this.annotations.add(AnnotationSpec.of(annotation));\n       return this;\n     }\n@@ -92,15 +86,11 @@ public final class FieldSpec {\n       return this;\n     }\n \n-    public Builder type(TypeName type) {\n+    public Builder type(Type type) {\n       this.type = type;\n       return this;\n     }\n \n-    public Builder type(Class<?> type) {\n-      return type(TypeNames.forClass(type));\n-    }\n-\n     public Builder name(Name name) {\n       this.name = name;\n       return this;\n"
    },
    {
        "commit_hash": "598b446b8cf567cb6308612357ef6b947d03971c",
        "previous_commit_hash": "cd75215134bb6032d8ff47d7792635cd228a7803",
        "diff_stats": {
            "additions": 4,
            "deletions": 1
        },
        "diff_content": "@@ -15,5 +15,8 @@\n  */\n package com.squareup.javawriter;\n \n-public interface TypeName {\n+import java.lang.reflect.Type;\n+\n+interface IntersectionType extends Type {\n+  Type[] getBounds();\n }\n"
    },
    {
        "commit_hash": "598b446b8cf567cb6308612357ef6b947d03971c",
        "previous_commit_hash": "cd75215134bb6032d8ff47d7792635cd228a7803",
        "diff_stats": {
            "additions": 0,
            "deletions": 45
        },
        "diff_content": "@@ -1,45 +0,0 @@\n-/*\n- * Copyright (C) 2014 Square, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.squareup.javawriter;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.Lists;\n-import java.util.List;\n-\n-public final class IntersectionTypeName implements TypeName {\n-  private final ImmutableList<TypeName> typeNames;\n-\n-  IntersectionTypeName(List<TypeName> typeNames) {\n-    this.typeNames = ImmutableList.copyOf(typeNames);\n-  }\n-\n-  public List<TypeName> typeNames() {\n-    return typeNames;\n-  }\n-\n-  @Override public int hashCode() {\n-    return typeNames.hashCode();\n-  }\n-\n-  @Override public boolean equals(Object obj) {\n-    return obj instanceof IntersectionTypeName\n-        && ((IntersectionTypeName) obj).typeNames.equals(typeNames);\n-  }\n-\n-  public static IntersectionTypeName create(TypeName bound1, TypeName bound2, TypeName... rest) {\n-    return new IntersectionTypeName(ImmutableList.copyOf(Lists.asList(bound1, bound2, rest)));\n-  }\n-}\n"
    },
    {
        "commit_hash": "598b446b8cf567cb6308612357ef6b947d03971c",
        "previous_commit_hash": "cd75215134bb6032d8ff47d7792635cd228a7803",
        "diff_stats": {
            "additions": 7,
            "deletions": 9
        },
        "diff_content": "@@ -13,10 +13,9 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package com.squareup.javawriter.builders;\n+package com.squareup.javawriter;\n \n import com.google.common.collect.ImmutableMap;\n-import com.squareup.javawriter.ClassName;\n \n import static com.google.common.base.Preconditions.checkNotNull;\n \n@@ -32,19 +31,18 @@ public final class JavaFile {\n \n   public String toString() {\n     // First pass: emit the entire class, just to collect the types we'll need to import.\n-    ImmutableMap<ClassName, String> noImports = ImmutableMap.of();\n-    CodeWriter importsCollector = new CodeWriter(new StringBuilder(), noImports);\n-    emit(noImports, importsCollector);\n+    CodeWriter importsCollector = new CodeWriter(new StringBuilder());\n+    emit(importsCollector);\n     ImmutableMap<ClassName, String> suggestedImports = importsCollector.suggestedImports();\n \n     // Second pass: Write the code, taking advantage of the imports.\n     StringBuilder result = new StringBuilder();\n     CodeWriter codeWriter = new CodeWriter(result, suggestedImports);\n-    emit(suggestedImports, codeWriter);\n+    emit(codeWriter);\n     return result.toString();\n   }\n \n-  private void emit(ImmutableMap<ClassName, String> imports, CodeWriter codeWriter) {\n+  private void emit(CodeWriter codeWriter) {\n     codeWriter.pushPackage(packageName);\n \n     if (!packageName.isEmpty()) {\n@@ -52,8 +50,8 @@ public final class JavaFile {\n       codeWriter.emit(\"\\n\");\n     }\n \n-    if (!imports.isEmpty()) {\n-      for (ClassName className : imports.keySet()) {\n+    if (!codeWriter.importedTypes().isEmpty()) {\n+      for (ClassName className : codeWriter.importedTypes().keySet()) {\n         codeWriter.emit(\"import $L;\\n\", className);\n       }\n       codeWriter.emit(\"\\n\");\n"
    },
    {
        "commit_hash": "598b446b8cf567cb6308612357ef6b947d03971c",
        "previous_commit_hash": "cd75215134bb6032d8ff47d7792635cd228a7803",
        "diff_stats": {
            "additions": 0,
            "deletions": 2
        },
        "diff_content": "@@ -16,8 +16,6 @@\n package com.squareup.javawriter;\n \n import com.google.common.collect.Iterables;\n-import com.squareup.javawriter.builders.JavaFile;\n-import com.squareup.javawriter.builders.TypeSpec;\n import java.io.File;\n import java.io.IOException;\n import java.io.OutputStreamWriter;\n"
    },
    {
        "commit_hash": "598b446b8cf567cb6308612357ef6b947d03971c",
        "previous_commit_hash": "cd75215134bb6032d8ff47d7792635cd228a7803",
        "diff_stats": {
            "additions": 15,
            "deletions": 31
        },
        "diff_content": "@@ -13,16 +13,12 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package com.squareup.javawriter.builders;\n+package com.squareup.javawriter;\n \n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n-import com.squareup.javawriter.ClassName;\n-import com.squareup.javawriter.TypeName;\n-import com.squareup.javawriter.TypeNames;\n-import com.squareup.javawriter.TypeVariableName;\n-import com.squareup.javawriter.VoidName;\n-import java.lang.annotation.Annotation;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n@@ -35,11 +31,11 @@ import static com.google.common.base.Preconditions.checkNotNull;\n public final class MethodSpec {\n   public final ImmutableList<AnnotationSpec> annotations;\n   public final ImmutableSet<Modifier> modifiers;\n-  public final ImmutableList<TypeVariableName> typeVariables;\n-  public final TypeName returnType;\n+  public final ImmutableList<TypeVariable<?>> typeVariables;\n+  public final Type returnType;\n   public final Name name;\n   public final ImmutableList<ParameterSpec> parameters;\n-  public final ImmutableList<ClassName> exceptions;\n+  public final ImmutableList<Type> exceptions;\n   public final ImmutableList<Snippet> snippets;\n \n   private MethodSpec(Builder builder) {\n@@ -89,7 +85,7 @@ public final class MethodSpec {\n     if (!exceptions.isEmpty()) {\n       codeWriter.emit(\" throws\");\n       boolean firstException = true;\n-      for (ClassName exception : exceptions) {\n+      for (Type exception : exceptions) {\n         if (!firstException) codeWriter.emit(\",\");\n         codeWriter.emit(\" $T\", exception);\n         firstException = false;\n@@ -113,11 +109,11 @@ public final class MethodSpec {\n   public static final class Builder {\n     private final List<AnnotationSpec> annotations = new ArrayList<>();\n     private final List<Modifier> modifiers = new ArrayList<>();\n-    private List<TypeVariableName> typeVariables = new ArrayList<>();\n-    private TypeName returnType = VoidName.VOID;\n+    private List<TypeVariable<?>> typeVariables = new ArrayList<>();\n+    private Type returnType = void.class;\n     private Name name;\n     private final List<ParameterSpec> parameters = new ArrayList<>();\n-    private final List<ClassName> exceptions = new ArrayList<>();\n+    private final List<Type> exceptions = new ArrayList<>();\n     private final List<Snippet> snippets = new ArrayList<>();\n \n     public Builder addAnnotation(AnnotationSpec annotationSpec) {\n@@ -125,7 +121,7 @@ public final class MethodSpec {\n       return this;\n     }\n \n-    public Builder addAnnotation(Class<? extends Annotation> annotation) {\n+    public Builder addAnnotation(Type annotation) {\n       this.annotations.add(AnnotationSpec.of(annotation));\n       return this;\n     }\n@@ -135,16 +131,12 @@ public final class MethodSpec {\n       return this;\n     }\n \n-    public Builder addTypeVariable(TypeVariableName typeVariable) {\n+    public Builder addTypeVariable(TypeVariable typeVariable) {\n       typeVariables.add(typeVariable);\n       return this;\n     }\n \n-    public Builder returns(Class<?> returnType) {\n-      return returns(TypeNames.forClass(returnType));\n-    }\n-\n-    public Builder returns(TypeName returnType) {\n+    public Builder returns(Type returnType) {\n       this.returnType = returnType;\n       return this;\n     }\n@@ -170,19 +162,11 @@ public final class MethodSpec {\n       return this;\n     }\n \n-    public Builder addParameter(Class<?> type, String name) {\n+    public Builder addParameter(Type type, String name) {\n       return addParameter(new ParameterSpec.Builder().type(type).name(name).build());\n     }\n \n-    public Builder addParameter(TypeName type, String name) {\n-      return addParameter(new ParameterSpec.Builder().type(type).name(name).build());\n-    }\n-\n-    public Builder addException(Class<? extends Throwable> exception) {\n-      return addException(ClassName.fromClass(exception));\n-    }\n-\n-    public Builder addException(ClassName exception) {\n+    public Builder addException(Type exception) {\n       this.exceptions.add(exception);\n       return this;\n     }\n"
    },
    {
        "commit_hash": "598b446b8cf567cb6308612357ef6b947d03971c",
        "previous_commit_hash": "cd75215134bb6032d8ff47d7792635cd228a7803",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -13,7 +13,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package com.squareup.javawriter.builders;\n+package com.squareup.javawriter;\n \n import static com.google.common.base.Preconditions.checkNotNull;\n \n"
    },
    {
        "commit_hash": "598b446b8cf567cb6308612357ef6b947d03971c",
        "previous_commit_hash": "cd75215134bb6032d8ff47d7792635cd228a7803",
        "diff_stats": {
            "additions": 0,
            "deletions": 24
        },
        "diff_content": "@@ -1,24 +0,0 @@\n-/*\n- * Copyright (C) 2014 Google, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.squareup.javawriter;\n-\n-enum NullName implements TypeName {\n-  NULL;\n-\n-  @Override public String toString() {\n-    return \"null\";\n-  }\n-}\n"
    },
    {
        "commit_hash": "598b446b8cf567cb6308612357ef6b947d03971c",
        "previous_commit_hash": "cd75215134bb6032d8ff47d7792635cd228a7803",
        "diff_stats": {
            "additions": 6,
            "deletions": 19
        },
        "diff_content": "@@ -13,14 +13,11 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package com.squareup.javawriter.builders;\n+package com.squareup.javawriter;\n \n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n-import com.squareup.javawriter.ClassName;\n-import com.squareup.javawriter.TypeName;\n-import com.squareup.javawriter.TypeNames;\n-import java.lang.annotation.Annotation;\n+import java.lang.reflect.Type;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n@@ -32,7 +29,7 @@ import static com.google.common.base.Preconditions.checkNotNull;\n public final class ParameterSpec {\n   public final ImmutableList<AnnotationSpec> annotations;\n   public final ImmutableSet<Modifier> modifiers;\n-  public final TypeName type;\n+  public final Type type;\n   public final Name name;\n \n   private ParameterSpec(Builder builder) {\n@@ -55,7 +52,7 @@ public final class ParameterSpec {\n   public static final class Builder {\n     private final List<AnnotationSpec> annotations = new ArrayList<>();\n     private final List<Modifier> modifiers = new ArrayList<>();\n-    private TypeName type;\n+    private Type type;\n     private Name name;\n \n     public Builder addAnnotation(AnnotationSpec annotationSpec) {\n@@ -63,12 +60,7 @@ public final class ParameterSpec {\n       return this;\n     }\n \n-    public Builder addAnnotation(Class<? extends Annotation> annotation) {\n-      this.annotations.add(AnnotationSpec.of(annotation));\n-      return this;\n-    }\n-\n-    public Builder addAnnotation(ClassName annotation) {\n+    public Builder addAnnotation(Type annotation) {\n       this.annotations.add(AnnotationSpec.of(annotation));\n       return this;\n     }\n@@ -78,16 +70,11 @@ public final class ParameterSpec {\n       return this;\n     }\n \n-    public Builder type(TypeName type) {\n+    public Builder type(Type type) {\n       this.type = type;\n       return this;\n     }\n \n-    public Builder type(Class<?> type) {\n-      this.type = TypeNames.forClass(type);\n-      return this;\n-    }\n-\n     public Builder name(String name) {\n       this.name = new Name(name);\n       return this;\n"
    },
    {
        "commit_hash": "598b446b8cf567cb6308612357ef6b947d03971c",
        "previous_commit_hash": "cd75215134bb6032d8ff47d7792635cd228a7803",
        "diff_stats": {
            "additions": 0,
            "deletions": 65
        },
        "diff_content": "@@ -1,65 +0,0 @@\n-/*\n- * Copyright (C) 2014 Google, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.squareup.javawriter;\n-\n-import com.google.common.base.Objects;\n-import com.google.common.collect.ImmutableList;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-\n-public final class ParameterizedTypeName implements TypeName {\n-  private final ClassName type;\n-  private final ImmutableList<? extends TypeName> parameters;\n-\n-  ParameterizedTypeName(ClassName type, Iterable<? extends TypeName> parameters) {\n-    this.type = type;\n-    this.parameters = ImmutableList.copyOf(parameters);\n-  }\n-\n-  public ClassName type() {\n-    return type;\n-  }\n-\n-  public ImmutableList<? extends TypeName> parameters() {\n-    return parameters;\n-  }\n-\n-  @Override public boolean equals(Object obj) {\n-    if (obj instanceof ParameterizedTypeName) {\n-      ParameterizedTypeName that = (ParameterizedTypeName) obj;\n-      return this.type.equals(that.type)\n-          && this.parameters.equals(that.parameters);\n-    } else {\n-      return false;\n-    }\n-  }\n-\n-  @Override public int hashCode() {\n-    return Objects.hashCode(type, parameters);\n-  }\n-\n-  public static ParameterizedTypeName create(ClassName className,\n-      TypeName... parameters) {\n-    return new ParameterizedTypeName(className, ImmutableList.copyOf(parameters));\n-  }\n-\n-  public static ParameterizedTypeName create(Class<?> parameterizedClass,\n-      TypeName... parameters) {\n-    checkArgument(parameterizedClass.getTypeParameters().length == parameters.length);\n-    return new ParameterizedTypeName(ClassName.fromClass(parameterizedClass),\n-        ImmutableList.copyOf(parameters));\n-  }\n-}\n"
    },
    {
        "commit_hash": "598b446b8cf567cb6308612357ef6b947d03971c",
        "previous_commit_hash": "cd75215134bb6032d8ff47d7792635cd228a7803",
        "diff_stats": {
            "additions": 0,
            "deletions": 78
        },
        "diff_content": "@@ -1,78 +0,0 @@\n-/*\n- * Copyright (C) 2014 Google, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.squareup.javawriter;\n-\n-import com.google.common.base.Ascii;\n-import javax.lang.model.type.PrimitiveType;\n-\n-public enum PrimitiveName implements TypeName {\n-  BOOLEAN, BYTE, SHORT, INT, LONG, CHAR, FLOAT, DOUBLE;\n-\n-  @Override public String toString() {\n-    return Ascii.toLowerCase(name());\n-  }\n-\n-  static PrimitiveName forTypeMirror(PrimitiveType mirror) {\n-    switch (mirror.getKind()) {\n-      case BOOLEAN:\n-        return BOOLEAN;\n-      case BYTE:\n-        return BYTE;\n-      case SHORT:\n-        return SHORT;\n-      case INT:\n-        return INT;\n-      case LONG:\n-        return LONG;\n-      case CHAR:\n-        return CHAR;\n-      case FLOAT:\n-        return FLOAT;\n-      case DOUBLE:\n-        return DOUBLE;\n-      default:\n-        throw new AssertionError();\n-    }\n-  }\n-\n-  static PrimitiveName forClass(Class<?> primitiveClass) {\n-    if (boolean.class.equals(primitiveClass)) {\n-      return BOOLEAN;\n-    }\n-    if (byte.class.equals(primitiveClass)) {\n-      return BYTE;\n-    }\n-    if (short.class.equals(primitiveClass)) {\n-      return SHORT;\n-    }\n-    if (int.class.equals(primitiveClass)) {\n-      return INT;\n-    }\n-    if (long.class.equals(primitiveClass)) {\n-      return LONG;\n-    }\n-    if (char.class.equals(primitiveClass)) {\n-      return CHAR;\n-    }\n-    if (float.class.equals(primitiveClass)) {\n-      return FLOAT;\n-    }\n-    if (double.class.equals(primitiveClass)) {\n-      return DOUBLE;\n-    }\n-    throw new IllegalArgumentException(primitiveClass + \" is not a primitive type\");\n-  }\n-}\n"
    },
    {
        "commit_hash": "598b446b8cf567cb6308612357ef6b947d03971c",
        "previous_commit_hash": "cd75215134bb6032d8ff47d7792635cd228a7803",
        "diff_stats": {
            "additions": 5,
            "deletions": 4
        },
        "diff_content": "@@ -13,12 +13,11 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package com.squareup.javawriter.builders;\n+package com.squareup.javawriter;\n \n import com.google.common.collect.ImmutableList;\n import java.util.Arrays;\n \n-import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n \n /**\n@@ -67,8 +66,10 @@ final class Snippet {\n       formatPartsBuilder.add(format.substring(p, nextP));\n     }\n \n-    checkArgument(args.length == expectedArgsLength,\n-        \"expected %s args for %s but was %s\", expectedArgsLength, format, Arrays.toString(args));\n+    if (args.length != expectedArgsLength) {\n+      throw new IllegalStateException(String.format(\"expected %s args for %s but was %s\",\n+          expectedArgsLength, format, Arrays.toString(args)));\n+    }\n \n     this.formatParts = formatPartsBuilder.build();\n     this.args = ImmutableList.copyOf(args);\n"
    },
    {
        "commit_hash": "598b446b8cf567cb6308612357ef6b947d03971c",
        "previous_commit_hash": "cd75215134bb6032d8ff47d7792635cd228a7803",
        "diff_stats": {
            "additions": 0,
            "deletions": 130
        },
        "diff_content": "@@ -1,130 +0,0 @@\n-/*\n- * Copyright (C) 2014 Google, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.squareup.javawriter;\n-\n-import com.google.common.base.Function;\n-import com.google.common.collect.FluentIterable;\n-import com.google.common.collect.Lists;\n-import java.lang.reflect.Method;\n-import java.util.List;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.type.ArrayType;\n-import javax.lang.model.type.DeclaredType;\n-import javax.lang.model.type.NoType;\n-import javax.lang.model.type.NullType;\n-import javax.lang.model.type.PrimitiveType;\n-import javax.lang.model.type.TypeMirror;\n-import javax.lang.model.type.TypeVariable;\n-import javax.lang.model.type.WildcardType;\n-import javax.lang.model.util.SimpleTypeVisitor6;\n-\n-public final class TypeNames {\n-  static final Function<TypeMirror, TypeName> FOR_TYPE_MIRROR =\n-      new Function<TypeMirror, TypeName>() {\n-        @Override public TypeName apply(TypeMirror input) {\n-          return forTypeMirror(input);\n-        }\n-      };\n-\n-  public static TypeName forClass(Class<?> clazz) {\n-    if (void.class.equals(clazz)) {\n-      return VoidName.VOID;\n-    } else if (clazz.isPrimitive()) {\n-      return PrimitiveName.forClass(clazz);\n-    } else if (clazz.isArray()) {\n-      return new ArrayTypeName(forClass(clazz.getComponentType()));\n-    } else {\n-      return ClassName.fromClass(clazz);\n-    }\n-  }\n-\n-  public static TypeName forTypeMirror(TypeMirror mirror) {\n-    return mirror.accept(new SimpleTypeVisitor6<TypeName, Void>() {\n-      @Override\n-      protected TypeName defaultAction(TypeMirror e, Void p) {\n-        throw new IllegalArgumentException(e.toString());\n-      }\n-\n-      @Override\n-      public TypeName visitUnknown(TypeMirror t, Void p) {\n-        if (\"INTERSECTION\".equals(t.getKind().name())) {\n-          return visitIntersectionType(t);\n-        }\n-        return super.visitUnknown(t, p);\n-      }\n-\n-      @SuppressWarnings(\"unchecked\") // Gross things in support of Java 8.\n-      private TypeName visitIntersectionType(TypeMirror t) {\n-        try {\n-          Method method = t.getClass().getMethod(\"getBounds\");\n-          List<? extends TypeMirror> bounds = (List<? extends TypeMirror>) method.invoke(t);\n-          return new IntersectionTypeName(Lists.transform(bounds, FOR_TYPE_MIRROR));\n-        } catch (Exception e) {\n-          throw new RuntimeException(e);\n-        }\n-      }\n-\n-      @Override\n-      public ArrayTypeName visitArray(ArrayType t, Void p) {\n-        return new ArrayTypeName(t.getComponentType().accept(this, null));\n-      }\n-\n-      @Override\n-      public TypeName visitDeclared(DeclaredType t, Void p) {\n-        return t.getTypeArguments().isEmpty()\n-            ? ClassName.fromTypeElement((TypeElement) t.asElement())\n-            : new ParameterizedTypeName(\n-                ClassName.fromTypeElement((TypeElement) t.asElement()),\n-                FluentIterable.from(t.getTypeArguments()).transform(FOR_TYPE_MIRROR));\n-      }\n-\n-      @Override\n-      public PrimitiveName visitPrimitive(PrimitiveType t, Void p) {\n-        return PrimitiveName.forTypeMirror(t);\n-      }\n-\n-      @Override\n-      public TypeName visitTypeVariable(TypeVariable t, Void p) {\n-        return TypeVariableName.forTypeMirror(t);\n-      }\n-\n-      @Override\n-      public WildcardName visitWildcard(WildcardType t, Void p) {\n-        return WildcardName.forTypeMirror(t);\n-      }\n-\n-      @Override\n-      public NullName visitNull(NullType t, Void p) {\n-        return NullName.NULL;\n-      }\n-\n-      @Override\n-      public TypeName visitNoType(NoType t, Void p) {\n-        switch (t.getKind()) {\n-          case VOID:\n-            return VoidName.VOID;\n-          case PACKAGE:\n-            throw new IllegalArgumentException();\n-          default:\n-            throw new IllegalStateException();\n-        }\n-      }\n-    }, null);\n-  }\n-\n-  private TypeNames() {\n-  }\n-}\n"
    },
    {
        "commit_hash": "598b446b8cf567cb6308612357ef6b947d03971c",
        "previous_commit_hash": "cd75215134bb6032d8ff47d7792635cd228a7803",
        "diff_stats": {
            "additions": 45,
            "deletions": 54
        },
        "diff_content": "@@ -13,17 +13,14 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package com.squareup.javawriter.builders;\n+package com.squareup.javawriter;\n \n import com.google.common.base.Ascii;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableMap;\n import com.google.common.collect.ImmutableSet;\n-import com.squareup.javawriter.ClassName;\n-import com.squareup.javawriter.TypeName;\n-import com.squareup.javawriter.TypeNames;\n-import com.squareup.javawriter.TypeVariableName;\n-import java.lang.annotation.Annotation;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.Iterator;\n@@ -41,11 +38,11 @@ import static com.google.common.collect.Iterables.getOnlyElement;\n public final class TypeSpec {\n   public final ImmutableList<AnnotationSpec> annotations;\n   public final ImmutableSet<Modifier> modifiers;\n-  public final Type type;\n+  public final DeclarationType declarationType;\n   public final String name;\n-  public final ImmutableList<TypeVariableName> typeVariables;\n-  public final TypeName superclass;\n-  public final ImmutableList<TypeName> superinterfaces;\n+  public final ImmutableList<TypeVariable<?>> typeVariables;\n+  public final Type superclass;\n+  public final ImmutableList<Type> superinterfaces;\n   public final Snippet anonymousTypeArguments;\n   public final ImmutableMap<String, TypeSpec> enumConstants;\n   public final ImmutableList<FieldSpec> fieldSpecs;\n@@ -56,10 +53,10 @@ public final class TypeSpec {\n   private TypeSpec(Builder builder) {\n     checkArgument(builder.name != null ^ builder.anonymousTypeArguments != null,\n         \"types must have either a name or anonymous type arguments\");\n-    boolean isInterface = builder.type == Type.INTERFACE;\n+    boolean isInterface = builder.declarationType == DeclarationType.INTERFACE;\n     boolean typeIsAbstract = builder.modifiers.contains(Modifier.ABSTRACT) || isInterface;\n-    checkArgument(builder.type == Type.ENUM ^ builder.enumConstants.isEmpty(),\n-        \"unexpected enum constants %s for type %s\", builder.enumConstants, builder.type);\n+    checkArgument(builder.declarationType == DeclarationType.ENUM ^ builder.enumConstants.isEmpty(),\n+        \"unexpected enum constants %s for type %s\", builder.enumConstants, builder.declarationType);\n     for (MethodSpec methodSpec : builder.methodSpecs) {\n       checkArgument(typeIsAbstract || !methodSpec.hasModifier(Modifier.ABSTRACT),\n           \"non-abstract type %s cannot declare abstract method %s\", builder.name, methodSpec.name);\n@@ -83,7 +80,7 @@ public final class TypeSpec {\n \n     this.annotations = ImmutableList.copyOf(builder.annotations);\n     this.modifiers = ImmutableSet.copyOf(builder.modifiers);\n-    this.type = checkNotNull(builder.type);\n+    this.declarationType = checkNotNull(builder.declarationType);\n     this.name = builder.name;\n     this.typeVariables = ImmutableList.copyOf(builder.typeVariables);\n     this.superclass = builder.superclass;\n@@ -125,17 +122,17 @@ public final class TypeSpec {\n     } else {\n       codeWriter.emitAnnotations(annotations, false);\n       codeWriter.emitModifiers(modifiers);\n-      codeWriter.emit(\"$L $L\", Ascii.toLowerCase(type.name()), name);\n+      codeWriter.emit(\"$L $L\", Ascii.toLowerCase(declarationType.name()), name);\n       codeWriter.emitTypeVariables(typeVariables);\n \n-      List<TypeName> extendsTypes;\n-      List<TypeName> implementsTypes;\n-      if (type == Type.INTERFACE) {\n+      List<Type> extendsTypes;\n+      List<Type> implementsTypes;\n+      if (declarationType == DeclarationType.INTERFACE) {\n         extendsTypes = superinterfaces;\n         implementsTypes = ImmutableList.of();\n       } else {\n         extendsTypes = superclass.equals(ClassName.OBJECT)\n-            ? ImmutableList.<TypeName>of()\n+            ? ImmutableList.<Type>of()\n             : ImmutableList.of(superclass);\n         implementsTypes = superinterfaces;\n       }\n@@ -143,7 +140,7 @@ public final class TypeSpec {\n       if (!extendsTypes.isEmpty()) {\n         codeWriter.emit(\" extends\");\n         boolean firstType = true;\n-        for (TypeName type : extendsTypes) {\n+        for (Type type : extendsTypes) {\n           if (!firstType) codeWriter.emit(\",\");\n           codeWriter.emit(\" $T\", type);\n           firstType = false;\n@@ -153,7 +150,7 @@ public final class TypeSpec {\n       if (!implementsTypes.isEmpty()) {\n         codeWriter.emit(\" implements\");\n         boolean firstType = true;\n-        for (TypeName type : implementsTypes) {\n+        for (Type type : implementsTypes) {\n           if (!firstType) codeWriter.emit(\",\");\n           codeWriter.emit(\" $T\", type);\n           firstType = false;\n@@ -173,21 +170,21 @@ public final class TypeSpec {\n       enumConstant.getValue().emit(codeWriter, enumConstant.getKey());\n       firstMember = false;\n       if (i.hasNext()) {\n-        codeWriter.emit(\"$L\", \",\\n\");\n+        codeWriter.emit(\",\\n\");\n       } else if (!fieldSpecs.isEmpty() || !methodSpecs.isEmpty() || !typeSpecs.isEmpty()) {\n-        codeWriter.emit(\"$L\", \";\\n\");\n+        codeWriter.emit(\";\\n\");\n       } else {\n-        codeWriter.emit(\"$L\", \"\\n\");\n+        codeWriter.emit(\"\\n\");\n       }\n     }\n     for (FieldSpec fieldSpec : fieldSpecs) {\n       if (!firstMember) codeWriter.emit(\"\\n\");\n-      fieldSpec.emit(codeWriter, type.implicitFieldModifiers);\n+      fieldSpec.emit(codeWriter, declarationType.implicitFieldModifiers);\n       firstMember = false;\n     }\n     for (MethodSpec methodSpec : methodSpecs) {\n       if (!firstMember) codeWriter.emit(\"\\n\");\n-      methodSpec.emit(codeWriter, name, type.implicitMethodModifiers);\n+      methodSpec.emit(codeWriter, name, declarationType.implicitMethodModifiers);\n       firstMember = false;\n     }\n     for (TypeSpec typeSpec : typeSpecs) {\n@@ -198,25 +195,22 @@ public final class TypeSpec {\n     codeWriter.unindent();\n     codeWriter.popType();\n \n-    if (enumName != null || anonymousTypeArguments != null) {\n-      codeWriter.emit(\"}\");\n-    } else {\n-      codeWriter.emit(\"}\\n\");\n+    codeWriter.emit(\"}\");\n+    if (enumName == null && anonymousTypeArguments == null) {\n+      codeWriter.emit(\"\\n\"); // If this type isn't also a value, include a trailing newline.\n     }\n   }\n \n-  public static enum Type {\n+  private enum DeclarationType {\n     CLASS(ImmutableSet.<Modifier>of(), ImmutableSet.<Modifier>of()),\n     INTERFACE(ImmutableSet.of(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL),\n         ImmutableSet.of(Modifier.PUBLIC, Modifier.ABSTRACT)),\n     ENUM(ImmutableSet.<Modifier>of(), ImmutableSet.<Modifier>of());\n \n-    private ImmutableSet<Modifier> implicitFieldModifiers\n-        = ImmutableSet.of(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL);\n-    private ImmutableSet<Modifier> implicitMethodModifiers\n-        = ImmutableSet.of(Modifier.PUBLIC, Modifier.ABSTRACT);\n+    private final ImmutableSet<Modifier> implicitFieldModifiers;\n+    private final ImmutableSet<Modifier> implicitMethodModifiers;\n \n-    private Type(ImmutableSet<Modifier> implicitFieldModifiers,\n+    private DeclarationType(ImmutableSet<Modifier> implicitFieldModifiers,\n         ImmutableSet<Modifier> implicitMethodModifiers) {\n       this.implicitFieldModifiers = implicitFieldModifiers;\n       this.implicitMethodModifiers = implicitMethodModifiers;\n@@ -226,11 +220,11 @@ public final class TypeSpec {\n   public static final class Builder {\n     private final List<AnnotationSpec> annotations = new ArrayList<>();\n     private final List<Modifier> modifiers = new ArrayList<>();\n-    private Type type = Type.CLASS;\n+    private DeclarationType declarationType = DeclarationType.CLASS;\n     private String name;\n-    private final List<TypeVariableName> typeVariables = new ArrayList<>();\n-    private TypeName superclass = ClassName.OBJECT;\n-    private final List<TypeName> superinterfaces = new ArrayList<>();\n+    private final List<TypeVariable<?>> typeVariables = new ArrayList<>();\n+    private Type superclass = ClassName.OBJECT;\n+    private final List<Type> superinterfaces = new ArrayList<>();\n     private Snippet anonymousTypeArguments;\n     private final Map<String, TypeSpec> enumConstants = new LinkedHashMap<>();\n     private final List<FieldSpec> fieldSpecs = new ArrayList<>();\n@@ -243,7 +237,7 @@ public final class TypeSpec {\n       return this;\n     }\n \n-    public Builder addAnnotation(Class<? extends Annotation> annotation) {\n+    public Builder addAnnotation(Type annotation) {\n       this.annotations.add(AnnotationSpec.of(annotation));\n       return this;\n     }\n@@ -253,8 +247,13 @@ public final class TypeSpec {\n       return this;\n     }\n \n-    public Builder type(Type type) {\n-      this.type = type;\n+    public Builder interfaceType() {\n+      this.declarationType = DeclarationType.INTERFACE;\n+      return this;\n+    }\n+\n+    public Builder enumType() {\n+      this.declarationType = DeclarationType.ENUM;\n       return this;\n     }\n \n@@ -263,25 +262,17 @@ public final class TypeSpec {\n       return this;\n     }\n \n-    public Builder addTypeVariable(TypeVariableName typeVariable) {\n+    public Builder addTypeVariable(TypeVariable<?> typeVariable) {\n       typeVariables.add(typeVariable);\n       return this;\n     }\n \n-    public Builder superclass(Class<?> superclass) {\n-      return superclass(TypeNames.forClass(superclass));\n-    }\n-\n-    public Builder superclass(TypeName superclass) {\n+    public Builder superclass(Type superclass) {\n       this.superclass = superclass;\n       return this;\n     }\n \n-    public Builder addSuperinterface(Class<?> superinterface) {\n-      return addSuperinterface(TypeNames.forClass(superinterface));\n-    }\n-\n-    public Builder addSuperinterface(TypeName superinterface) {\n+    public Builder addSuperinterface(Type superinterface) {\n       this.superinterfaces.add(superinterface);\n       return this;\n     }\n"
    },
    {
        "commit_hash": "598b446b8cf567cb6308612357ef6b947d03971c",
        "previous_commit_hash": "cd75215134bb6032d8ff47d7792635cd228a7803",
        "diff_stats": {
            "additions": 0,
            "deletions": 98
        },
        "diff_content": "@@ -1,98 +0,0 @@\n-/*\n- * Copyright (C) 2014 Google, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.squareup.javawriter;\n-\n-import com.google.common.base.Objects;\n-import com.google.common.base.Predicates;\n-import com.google.common.collect.FluentIterable;\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.Iterables;\n-import javax.lang.model.element.NestingKind;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.type.DeclaredType;\n-import javax.lang.model.type.TypeKind;\n-import javax.lang.model.type.TypeMirror;\n-import javax.lang.model.type.TypeVariable;\n-\n-import static com.squareup.javawriter.TypeNames.FOR_TYPE_MIRROR;\n-\n-public final class TypeVariableName implements TypeName {\n-  private final String name;\n-  private final TypeName upperBound;\n-\n-  TypeVariableName(String name, TypeName upperBound) {\n-    this.name = name;\n-    this.upperBound = upperBound;\n-  }\n-\n-  public TypeName upperBound() {\n-    return upperBound;\n-  }\n-\n-  public static TypeVariableName create(String name) {\n-    return new TypeVariableName(name, ClassName.OBJECT);\n-  }\n-\n-  public static TypeVariableName create(String name, TypeName upperBound) {\n-    return new TypeVariableName(name, upperBound);\n-  }\n-\n-  static TypeVariableName forTypeMirror(TypeVariable mirror) {\n-    String name = mirror.asElement().getSimpleName().toString();\n-\n-    TypeMirror upperBound = mirror.getUpperBound();\n-    FluentIterable<TypeMirror> bounds = FluentIterable.from(ImmutableList.of(upperBound));\n-    // Try to detect intersection types for Java 7 (Java 8+ has a new TypeKind for that)\n-    // Unfortunately, we can't put this logic into TypeNames.forTypeMirror() as this heuristic\n-    // only really works in the context of a TypeVariable's upper bound.\n-    if (upperBound.getKind() == TypeKind.DECLARED) {\n-      TypeElement bound = (TypeElement) ((DeclaredType) upperBound).asElement();\n-      if (bound.getNestingKind() == NestingKind.ANONYMOUS) {\n-        // This is (likely) an intersection type.\n-        bounds = FluentIterable\n-            .from(ImmutableList.of(bound.getSuperclass()))\n-            .append(bound.getInterfaces());\n-      }\n-    }\n-    ImmutableList<TypeName> typeNames = bounds.transform(FOR_TYPE_MIRROR)\n-        .filter(Predicates.not(Predicates.<TypeName>equalTo(ClassName.fromClass(Object.class))))\n-        .toList();\n-    if (typeNames.size() == 1) {\n-      return new TypeVariableName(name, Iterables.getOnlyElement(typeNames));\n-    } else if (!typeNames.isEmpty()) {\n-      return new TypeVariableName(name, new IntersectionTypeName(typeNames));\n-    }\n-    return new TypeVariableName(name, ClassName.OBJECT);\n-  }\n-\n-  public String name() {\n-    return name;\n-  }\n-\n-  @Override public boolean equals(Object obj) {\n-    if (obj instanceof TypeVariableName) {\n-      TypeVariableName that = (TypeVariableName) obj;\n-      return this.name.equals(that.name)\n-          && this.upperBound.equals(that.upperBound);\n-    } else {\n-      return false;\n-    }\n-  }\n-\n-  @Override public int hashCode() {\n-    return Objects.hashCode(name, upperBound);\n-  }\n-}\n"
    },
    {
        "commit_hash": "598b446b8cf567cb6308612357ef6b947d03971c",
        "previous_commit_hash": "cd75215134bb6032d8ff47d7792635cd228a7803",
        "diff_stats": {
            "additions": 351,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,351 @@\n+/**\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter;\n+\n+import com.google.common.base.Function;\n+import com.google.common.base.Objects;\n+import com.google.common.base.Predicates;\n+import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedType;\n+import java.lang.reflect.GenericArrayType;\n+import java.lang.reflect.GenericDeclaration;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+import java.lang.reflect.WildcardType;\n+import java.util.Arrays;\n+import javax.lang.model.element.NestingKind;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.ArrayType;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.NoType;\n+import javax.lang.model.type.NullType;\n+import javax.lang.model.type.PrimitiveType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.util.SimpleTypeVisitor6;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+/** Static methods for working with types. */\n+// Forked from a similar class in Gson.\n+public final class Types {\n+  private static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\n+\n+  private static final Function<TypeMirror, Type> FOR_TYPE_MIRROR =\n+      new Function<TypeMirror, Type>() {\n+        @Override public Type apply(TypeMirror input) {\n+          return get(input);\n+        }\n+      };\n+\n+  static final Type NULL = new Type() {\n+    @Override public String toString() {\n+      return \"null\";\n+    }\n+  };\n+\n+  private Types() {\n+  }\n+\n+  /**\n+   * Returns a new parameterized type, applying {@code typeArguments} to {@code rawType} and\n+   * with no enclosing owner type.\n+   */\n+  public static ParameterizedType parameterizedType(\n+      final Type rawType, final Type... typeArguments) {\n+    checkNotPrimitive(rawType);\n+    for (Type typeArgument : typeArguments) {\n+      checkNotPrimitive(typeArgument);\n+    }\n+\n+    return new ParameterizedType() {\n+      @Override public Type[] getActualTypeArguments() {\n+        return typeArguments.clone();\n+      }\n+      @Override public Type getRawType() {\n+        return rawType;\n+      }\n+      @Override public Type getOwnerType() {\n+        return null;\n+      }\n+      @Override public boolean equals(Object other) {\n+        return other instanceof ParameterizedType\n+            && ((ParameterizedType) other).getOwnerType() == null\n+            && rawType.equals(((ParameterizedType) other).getRawType())\n+            && Arrays.equals(typeArguments, ((ParameterizedType) other).getActualTypeArguments());\n+      }\n+      @Override public int hashCode() {\n+        return Arrays.hashCode(typeArguments) ^ rawType.hashCode();\n+      }\n+      @Override public String toString() {\n+        return typeToString(this);\n+      }\n+    };\n+  }\n+\n+  /**\n+   * Returns a new parameterized type, applying {@code typeArguments} to {@code rawType} and\n+   * with no enclosing owner type.\n+   */\n+  public static ParameterizedType parameterizedType(Type rawType, Iterable<Type> typeArguments) {\n+    return parameterizedType(rawType, Iterables.toArray(typeArguments, Type.class));\n+  }\n+\n+  /** Returns an array type whose elements are all instances of {@code componentType}. */\n+  public static GenericArrayType arrayOf(final Type componentType) {\n+    checkNotNull(componentType);\n+\n+    return new GenericArrayType() {\n+      @Override public Type getGenericComponentType() {\n+        return componentType;\n+      }\n+      @Override public boolean equals(Object o) {\n+        return o instanceof GenericArrayType\n+            && Objects.equal(componentType, ((GenericArrayType) o).getGenericComponentType());\n+      }\n+      @Override public int hashCode() {\n+        return componentType.hashCode();\n+      }\n+      @Override public String toString() {\n+        return typeToString(this);\n+      }\n+    };\n+  }\n+\n+  /**\n+   * Returns a type that represents an unknown type that extends {@code bound}. For example, if\n+   * {@code bound} is {@code CharSequence.class}, this returns {@code ? extends CharSequence}. If\n+   * {@code bound} is {@code Object.class}, this returns {@code ?}, which is shorthand for {@code\n+   * ? extends Object}.\n+   */\n+  public static WildcardType subtypeOf(Type bound) {\n+    checkNotPrimitive(bound);\n+    return wildcardType(new Type[] {bound}, EMPTY_TYPE_ARRAY);\n+  }\n+\n+  /**\n+   * Returns a type that represents an unknown supertype of {@code bound}. For example, if {@code\n+   * bound} is {@code String.class}, this returns {@code ? super String}.\n+   */\n+  public static WildcardType supertypeOf(Type bound) {\n+    checkNotPrimitive(bound);\n+    return wildcardType(new Type[] {Object.class}, new Type[] {bound});\n+  }\n+\n+  private static WildcardType wildcardType(final Type[] upperBounds, final Type[] lowerBounds) {\n+    return new WildcardType() {\n+      @Override public Type[] getUpperBounds() {\n+        return upperBounds.clone();\n+      }\n+      @Override public Type[] getLowerBounds() {\n+        return lowerBounds.clone();\n+      }\n+      @Override public boolean equals(Object o) {\n+        return o instanceof WildcardType\n+            && Arrays.equals(upperBounds, ((WildcardType) o).getUpperBounds())\n+            && Arrays.equals(lowerBounds, ((WildcardType) o).getLowerBounds());\n+      }\n+      @Override public int hashCode() {\n+        return Arrays.hashCode(lowerBounds) ^ Arrays.hashCode(upperBounds);\n+      }\n+      @Override public String toString() {\n+        return typeToString(this);\n+      }\n+    };\n+  }\n+\n+  public static TypeVariable<?> typeVariable(final String name, final Type... bounds) {\n+    checkNotNull(name);\n+    for (Type bound : bounds) {\n+      checkNotPrimitive(bound);\n+    }\n+\n+    return new TypeVariable<GenericDeclaration>() {\n+      @Override public Type[] getBounds() {\n+        return bounds.clone();\n+      }\n+      @Override public String getName() {\n+        return name;\n+      }\n+      @Override public GenericDeclaration getGenericDeclaration() {\n+        throw new UnsupportedOperationException();\n+      }\n+      @Override public boolean equals(Object o) {\n+        return o instanceof TypeVariable\n+            && name.equals(((TypeVariable<?>) o).getName());\n+      }\n+      @Override public int hashCode() {\n+        return name.hashCode();\n+      }\n+      @Override public String toString() {\n+        return typeToString(this);\n+      }\n+\n+      // Java 8 requires these methods. We have them to compile, but we don't exercise them.\n+      @Override public AnnotatedType[] getAnnotatedBounds() {\n+        throw new UnsupportedOperationException();\n+      }\n+      @Override public <T extends Annotation> T getAnnotation(Class<T> aClass) {\n+        throw new UnsupportedOperationException();\n+      }\n+      @Override public Annotation[] getAnnotations() {\n+        throw new UnsupportedOperationException();\n+      }\n+      @Override public Annotation[] getDeclaredAnnotations() {\n+        throw new UnsupportedOperationException();\n+      }\n+    };\n+  }\n+\n+  public static Type get(TypeMirror mirror) {\n+    return mirror.accept(new SimpleTypeVisitor6<Type, Void>() {\n+      @Override protected Type defaultAction(TypeMirror e, Void p) {\n+        throw new IllegalArgumentException(e.toString());\n+      }\n+\n+      @Override public GenericArrayType visitArray(ArrayType t, Void p) {\n+        return arrayOf(t.getComponentType().accept(this, null));\n+      }\n+\n+      @Override public Type visitDeclared(DeclaredType t, Void p) {\n+        return get(t);\n+      }\n+\n+      @Override public Class<?> visitPrimitive(PrimitiveType t, Void p) {\n+        return get(t);\n+      }\n+\n+      @Override public Type visitTypeVariable(javax.lang.model.type.TypeVariable t, Void p) {\n+        return get(t);\n+      }\n+\n+      @Override public Type visitIntersection(javax.lang.model.type.IntersectionType t, Void p) {\n+        return get(t);\n+      }\n+\n+      @Override public Type visitWildcard(javax.lang.model.type.WildcardType t, Void p) {\n+        return get(t);\n+      }\n+\n+      @Override public Type visitNull(NullType t, Void p) {\n+        return NULL;\n+      }\n+\n+      @Override public Type visitNoType(NoType t, Void p) {\n+        if (t.getKind() == TypeKind.VOID) return void.class;\n+        return super.visitUnknown(t, p);\n+      }\n+    }, null);\n+  }\n+\n+  private static Type get(DeclaredType t) {\n+    return t.getTypeArguments().isEmpty()\n+        ? ClassName.fromTypeElement((TypeElement) t.asElement())\n+        : parameterizedType(\n+            ClassName.fromTypeElement((TypeElement) t.asElement()),\n+            FluentIterable.from(t.getTypeArguments()).transform(FOR_TYPE_MIRROR));\n+  }\n+\n+  private static TypeVariable<?> get(javax.lang.model.type.TypeVariable mirror) {\n+    String name = mirror.asElement().getSimpleName().toString();\n+\n+    TypeMirror upperBound = mirror.getUpperBound();\n+    FluentIterable<TypeMirror> bounds = FluentIterable.from(ImmutableList.of(upperBound));\n+    // Try to detect intersection types for Java 7 (Java 8+ has a new TypeKind for that)\n+    // Unfortunately, we can't put this logic into Types.get() as this heuristic only really works\n+    // in the context of a TypeVariable's upper bound.\n+    if (upperBound.getKind() == TypeKind.DECLARED) {\n+      TypeElement bound = (TypeElement) ((DeclaredType) upperBound).asElement();\n+      if (bound.getNestingKind() == NestingKind.ANONYMOUS) {\n+        // This is (likely) an intersection type.\n+        bounds = FluentIterable\n+            .from(ImmutableList.of(bound.getSuperclass()))\n+            .append(bound.getInterfaces());\n+      }\n+    }\n+    Type[] types = bounds.transform(FOR_TYPE_MIRROR)\n+        .filter(Predicates.not(Predicates.<Type>equalTo(ClassName.OBJECT)))\n+        .toArray(Type.class);\n+    return typeVariable(name, types);\n+  }\n+\n+  private static Type get(javax.lang.model.type.WildcardType mirror) {\n+    Type extendsBound = get(mirror.getExtendsBound());\n+    Type superBound = get(mirror.getSuperBound());\n+    return superBound != null ? Types.supertypeOf(superBound) : Types.subtypeOf(extendsBound);\n+  }\n+\n+  private static Class<?> get(PrimitiveType mirror) {\n+    switch (mirror.getKind()) {\n+      case BOOLEAN:\n+        return boolean.class;\n+      case BYTE:\n+        return byte.class;\n+      case SHORT:\n+        return short.class;\n+      case INT:\n+        return int.class;\n+      case LONG:\n+        return long.class;\n+      case CHAR:\n+        return char.class;\n+      case FLOAT:\n+        return float.class;\n+      case DOUBLE:\n+        return double.class;\n+      default:\n+        throw new AssertionError();\n+    }\n+  }\n+\n+  private static Type get(javax.lang.model.type.IntersectionType mirror) {\n+    final Type[] bounds = FluentIterable.from(mirror.getBounds())\n+        .transform(FOR_TYPE_MIRROR)\n+        .filter(Predicates.not(Predicates.<Type>equalTo(ClassName.OBJECT)))\n+        .toArray(Type.class);\n+    return new IntersectionType() {\n+      @Override public Type[] getBounds() {\n+        return bounds;\n+      }\n+      @Override public int hashCode() {\n+        return Arrays.hashCode(bounds);\n+      }\n+      @Override public boolean equals(Object o) {\n+        return o instanceof IntersectionType\n+            && Arrays.equals(bounds, ((IntersectionType) o).getBounds());\n+      }\n+      @Override public String toString() {\n+        return typeToString(this);\n+      }\n+    };\n+  }\n+\n+  private static void checkNotPrimitive(Type type) {\n+    checkNotNull(type);\n+    checkArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());\n+  }\n+\n+  private static String typeToString(Type type) {\n+    StringBuilder result = new StringBuilder();\n+    new CodeWriter(result).emit(\"$T\", type);\n+    return result.toString();\n+  }\n+}\n"
    },
    {
        "commit_hash": "598b446b8cf567cb6308612357ef6b947d03971c",
        "previous_commit_hash": "cd75215134bb6032d8ff47d7792635cd228a7803",
        "diff_stats": {
            "additions": 0,
            "deletions": 24
        },
        "diff_content": "@@ -1,24 +0,0 @@\n-/*\n- * Copyright (C) 2014 Google, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.squareup.javawriter;\n-\n-public enum VoidName implements TypeName {\n-  VOID;\n-\n-  @Override public String toString() {\n-    return \"void\";\n-  }\n-}\n"
    },
    {
        "commit_hash": "598b446b8cf567cb6308612357ef6b947d03971c",
        "previous_commit_hash": "cd75215134bb6032d8ff47d7792635cd228a7803",
        "diff_stats": {
            "additions": 0,
            "deletions": 58
        },
        "diff_content": "@@ -1,58 +0,0 @@\n-/*\n- * Copyright (C) 2014 Google, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.squareup.javawriter;\n-\n-import com.google.common.base.Optional;\n-import javax.lang.model.type.WildcardType;\n-\n-import static com.squareup.javawriter.TypeNames.FOR_TYPE_MIRROR;\n-\n-public final class WildcardName implements TypeName {\n-  private final Optional<TypeName> extendsBound;\n-  private final Optional<TypeName> superBound;\n-\n-  WildcardName(Optional<TypeName> extendsBound,\n-      Optional<TypeName> superBound) {\n-    this.extendsBound = extendsBound;\n-    this.superBound = superBound;\n-  }\n-\n-  public TypeName extendsBound() {\n-    return extendsBound.orNull();\n-  }\n-\n-  public TypeName superBound() {\n-    return superBound.orNull();\n-  }\n-\n-  static WildcardName forTypeMirror(WildcardType mirror) {\n-    return new WildcardName(\n-        Optional.fromNullable(mirror.getExtendsBound()).transform(FOR_TYPE_MIRROR),\n-        Optional.fromNullable(mirror.getSuperBound()).transform(FOR_TYPE_MIRROR));\n-  }\n-\n-  public static WildcardName create() {\n-    return new WildcardName(Optional.<TypeName>absent(), Optional.<TypeName>absent());\n-  }\n-\n-  public static WildcardName createWithUpperBound(TypeName upperBound) {\n-    return new WildcardName(Optional.of(upperBound), Optional.<TypeName>absent());\n-  }\n-\n-  public static WildcardName createWithLowerBound(TypeName lowerBound) {\n-    return new WildcardName(Optional.<TypeName>absent(), Optional.of(lowerBound));\n-  }\n-}\n"
    },
    {
        "commit_hash": "598b446b8cf567cb6308612357ef6b947d03971c",
        "previous_commit_hash": "cd75215134bb6032d8ff47d7792635cd228a7803",
        "diff_stats": {
            "additions": 0,
            "deletions": 28
        },
        "diff_content": "@@ -17,7 +17,6 @@ package com.squareup.javawriter;\n \n import com.google.common.collect.ImmutableList;\n import com.google.testing.compile.CompilationRule;\n-import com.squareup.javawriter.ClassNameTest.OuterClass.InnerClass;\n import java.util.Map;\n import javax.lang.model.element.TypeElement;\n import javax.lang.model.util.Elements;\n@@ -86,33 +85,6 @@ public final class ClassNameTest {\n         .isEqualTo(\"com.squareup.javawriter.ClassNameTest.OuterClass.InnerClass\");\n   }\n \n-  @Test public void peerNamed_topLevelClass() {\n-    Elements elements = compilationRule.getElements();\n-    TypeElement element = elements.getTypeElement(ClassNameTest.class.getCanonicalName());\n-    ClassName className = ClassName.fromTypeElement(element);\n-    ClassName peerName = className.peerNamed(\"Foo\");\n-    assert_().that(peerName.canonicalName())\n-        .isEqualTo(\"com.squareup.javawriter.Foo\");\n-  }\n-\n-  @Test public void peerNamed_nestedClass() {\n-    Elements elements = compilationRule.getElements();\n-    TypeElement element = elements.getTypeElement(OuterClass.class.getCanonicalName());\n-    ClassName className = ClassName.fromTypeElement(element);\n-    ClassName peerName = className.peerNamed(\"Foo\");\n-    assert_().that(peerName.canonicalName())\n-        .isEqualTo(\"com.squareup.javawriter.ClassNameTest.Foo\");\n-  }\n-\n-  @Test public void peerNamed_deeplyNestedClass() {\n-    Elements elements = compilationRule.getElements();\n-    TypeElement element = elements.getTypeElement(InnerClass.class.getCanonicalName());\n-    ClassName className = ClassName.fromTypeElement(element);\n-    ClassName peerName = className.peerNamed(\"Foo\");\n-    assert_().that(peerName.canonicalName())\n-        .isEqualTo(\"com.squareup.javawriter.ClassNameTest.OuterClass.Foo\");\n-  }\n-\n   @Test public void fromClassRejectionTypes() {\n     try {\n       ClassName.fromClass(int.class);\n"
    },
    {
        "commit_hash": "598b446b8cf567cb6308612357ef6b947d03971c",
        "previous_commit_hash": "cd75215134bb6032d8ff47d7792635cd228a7803",
        "diff_stats": {
            "additions": 4,
            "deletions": 1
        },
        "diff_content": "@@ -13,8 +13,11 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package com.squareup.javawriter.builders;\n+package com.squareup.javawriter;\n \n+import com.squareup.javawriter.FieldSpec;\n+import com.squareup.javawriter.JavaFile;\n+import com.squareup.javawriter.TypeSpec;\n import java.util.Date;\n import org.junit.Test;\n \n"
    },
    {
        "commit_hash": "598b446b8cf567cb6308612357ef6b947d03971c",
        "previous_commit_hash": "cd75215134bb6032d8ff47d7792635cd228a7803",
        "diff_stats": {
            "additions": 0,
            "deletions": 1
        },
        "diff_content": "@@ -17,7 +17,6 @@ package com.squareup.javawriter;\n \n import com.google.common.collect.Iterables;\n import com.google.common.jimfs.Jimfs;\n-import com.squareup.javawriter.builders.TypeSpec;\n import java.io.File;\n import java.io.IOException;\n import java.nio.file.FileSystem;\n"
    },
    {
        "commit_hash": "598b446b8cf567cb6308612357ef6b947d03971c",
        "previous_commit_hash": "cd75215134bb6032d8ff47d7792635cd228a7803",
        "diff_stats": {
            "additions": 0,
            "deletions": 143
        },
        "diff_content": "@@ -1,143 +0,0 @@\n-/*\n- * Copyright (C) 2014 Google, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.squareup.javawriter;\n-\n-import com.google.testing.compile.CompilationRule;\n-import java.io.Serializable;\n-import java.nio.charset.Charset;\n-import java.util.List;\n-import java.util.Set;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.element.TypeParameterElement;\n-import javax.lang.model.type.DeclaredType;\n-import javax.lang.model.type.TypeKind;\n-import javax.lang.model.type.TypeMirror;\n-import org.junit.Rule;\n-import org.junit.Test;\n-\n-import static com.google.common.truth.Truth.assert_;\n-\n-public final class TypeNamesTest {\n-  @Rule public final CompilationRule compilation = new CompilationRule();\n-\n-  private TypeElement getElement(Class<?> clazz) {\n-    return compilation.getElements().getTypeElement(clazz.getCanonicalName());\n-  }\n-\n-  private TypeMirror getType(Class<?> clazz) {\n-    return getElement(clazz).asType();\n-  }\n-\n-  @Test\n-  public void forTypeMirror_basicTypes() {\n-    assert_().that(TypeNames.forTypeMirror(getType(Object.class)))\n-        .isEqualTo(ClassName.fromClass(Object.class));\n-    assert_().that(TypeNames.forTypeMirror(getType(Charset.class)))\n-        .isEqualTo(ClassName.fromClass(Charset.class));\n-    assert_().that(TypeNames.forTypeMirror(getType(TypeNamesTest.class)))\n-        .isEqualTo(ClassName.fromClass(TypeNamesTest.class));\n-  }\n-\n-  @Test\n-  public void forTypeMirror_parameterizedType() {\n-    DeclaredType setType =\n-        compilation.getTypes().getDeclaredType(getElement(Set.class), getType(Object.class));\n-    assert_().that(TypeNames.forTypeMirror(setType))\n-        .isEqualTo(ParameterizedTypeName.create(Set.class, ClassName.fromClass(Object.class)));\n-  }\n-\n-  static class Parameterized<\n-      Simple,\n-      ExtendsClass extends Number,\n-      ExtendsInterface extends Runnable,\n-      ExtendsTypeVariable extends Simple,\n-      Intersection extends Number & Runnable,\n-      IntersectionOfInterfaces extends Runnable & Serializable> {}\n-\n-  @Test\n-  public void forTypeMirror_typeVariable() {\n-    List<? extends TypeParameterElement> typeVariables =\n-        getElement(Parameterized.class).getTypeParameters();\n-\n-    assert_().that(TypeNames.forTypeMirror(typeVariables.get(0).asType()))\n-        .isEqualTo(TypeVariableName.create(\"Simple\"));\n-    assert_().that(TypeNames.forTypeMirror(typeVariables.get(1).asType()))\n-        .isEqualTo(TypeVariableName.create(\"ExtendsClass\", ClassName.fromClass(Number.class)));\n-    assert_().that(TypeNames.forTypeMirror(typeVariables.get(2).asType()))\n-        .isEqualTo(TypeVariableName.create(\"ExtendsInterface\", ClassName.fromClass(Runnable.class)));\n-    assert_().that(TypeNames.forTypeMirror(typeVariables.get(3).asType()))\n-        .isEqualTo(TypeVariableName.create(\"ExtendsTypeVariable\",\n-            TypeVariableName.create(\"Simple\")));\n-    assert_().that(TypeNames.forTypeMirror(typeVariables.get(4).asType()))\n-        .isEqualTo(TypeVariableName.create(\"Intersection\", IntersectionTypeName.create(\n-            ClassName.fromClass(Number.class),\n-            ClassName.fromClass(Runnable.class))));\n-    assert_().that(TypeNames.forTypeMirror(typeVariables.get(5).asType()))\n-        .isEqualTo(TypeVariableName.create(\"IntersectionOfInterfaces\", IntersectionTypeName.create(\n-            ClassName.fromClass(Runnable.class),\n-            ClassName.fromClass(Serializable.class))));\n-  }\n-\n-  @Test\n-  public void forTypeMirror_primitive() {\n-    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.BOOLEAN)))\n-        .isEqualTo(PrimitiveName.BOOLEAN);\n-    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.BYTE)))\n-        .isEqualTo(PrimitiveName.BYTE);\n-    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.SHORT)))\n-        .isEqualTo(PrimitiveName.SHORT);\n-    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.INT)))\n-        .isEqualTo(PrimitiveName.INT);\n-    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.LONG)))\n-        .isEqualTo(PrimitiveName.LONG);\n-    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.CHAR)))\n-        .isEqualTo(PrimitiveName.CHAR);\n-    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.FLOAT)))\n-        .isEqualTo(PrimitiveName.FLOAT);\n-    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.DOUBLE)))\n-        .isEqualTo(PrimitiveName.DOUBLE);\n-  }\n-\n-  @Test\n-  public void forTypeMirror_arrays() {\n-    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getArrayType(getType(Object.class))))\n-        .isEqualTo(new ArrayTypeName(ClassName.fromClass(Object.class)));\n-  }\n-\n-  @Test public void forClass_array() {\n-    assert_().that(TypeNames.forClass(Object[].class))\n-        .isEqualTo(new ArrayTypeName(ClassName.fromClass(Object.class)));\n-    assert_().that(TypeNames.forClass(int[].class))\n-        .isEqualTo(new ArrayTypeName(PrimitiveName.INT));\n-  }\n-\n-  @Test\n-  public void forTypeMirror_void() {\n-    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getNoType(TypeKind.VOID)))\n-        .isEqualTo(VoidName.VOID);\n-  }\n-\n-  @Test public void forClass_void() {\n-    assert_().that(TypeNames.forClass(void.class)).isEqualTo(VoidName.VOID);\n-    assert_().that(TypeNames.forClass(Void.class)).isNotEqualTo(VoidName.VOID);\n-  }\n-\n-  @Test\n-  public void forTypeMirror_null() {\n-    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getNullType()))\n-        .isEqualTo(NullName.NULL);\n-  }\n-}\n"
    },
    {
        "commit_hash": "598b446b8cf567cb6308612357ef6b947d03971c",
        "previous_commit_hash": "cd75215134bb6032d8ff47d7792635cd228a7803",
        "diff_stats": {
            "additions": 35,
            "deletions": 41
        },
        "diff_content": "@@ -13,16 +13,13 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package com.squareup.javawriter.builders;\n+package com.squareup.javawriter;\n \n import com.google.common.collect.ImmutableList;\n-import com.squareup.javawriter.ClassName;\n-import com.squareup.javawriter.IntersectionTypeName;\n-import com.squareup.javawriter.ParameterizedTypeName;\n-import com.squareup.javawriter.TypeVariableName;\n-import com.squareup.javawriter.WildcardName;\n import java.io.IOException;\n import java.io.Serializable;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.TypeVariable;\n import java.util.AbstractSet;\n import java.util.Comparator;\n import java.util.List;\n@@ -67,18 +64,17 @@ public final class TypeSpecTest {\n     TypeSpec taco = new TypeSpec.Builder()\n         .name(\"Taco\")\n         .addField(new FieldSpec.Builder()\n-            .type(ParameterizedTypeName.create(ClassName.fromClass(List.class),\n-                WildcardName.createWithUpperBound(ClassName.fromClass(Object.class))))\n+            .type(Types.parameterizedType(List.class, Types.subtypeOf(Object.class)))\n             .name(\"extendsObject\")\n             .build())\n         .addField(new FieldSpec.Builder()\n-            .type(ParameterizedTypeName.create(ClassName.fromClass(List.class),\n-                WildcardName.createWithUpperBound(ClassName.fromClass(Serializable.class))))\n+            .type(Types.parameterizedType(ClassName.fromClass(List.class),\n+                Types.subtypeOf(Serializable.class)))\n             .name(\"extendsSerializable\")\n             .build())\n         .addField(new FieldSpec.Builder()\n-            .type(ParameterizedTypeName.create(ClassName.fromClass(List.class),\n-                WildcardName.createWithLowerBound(ClassName.fromClass(String.class))))\n+            .type(Types.parameterizedType(ClassName.fromClass(List.class),\n+                Types.supertypeOf(String.class)))\n             .name(\"superString\")\n             .build())\n         .build();\n@@ -103,15 +99,15 @@ public final class TypeSpecTest {\n     ClassName bar = ClassName.create(tacosPackage, \"Bar\");\n     ClassName thingThang = ClassName.create(\n         tacosPackage, ImmutableList.of(\"Thing\"), \"Thang\");\n-    ParameterizedTypeName thingThangOfFooBar\n-        = ParameterizedTypeName.create(thingThang, foo, bar);\n+    ParameterizedType thingThangOfFooBar\n+        = Types.parameterizedType(thingThang, foo, bar);\n     ClassName thung = ClassName.create(tacosPackage, \"Thung\");\n     ClassName simpleThung = ClassName.create(tacosPackage, \"SimpleThung\");\n-    ParameterizedTypeName thungOfSuperBar\n-        = ParameterizedTypeName.create(thung, WildcardName.createWithLowerBound(bar));\n-    ParameterizedTypeName thungOfSuperFoo\n-        = ParameterizedTypeName.create(thung, WildcardName.createWithLowerBound(foo));\n-    ParameterizedTypeName simpleThungOfBar = ParameterizedTypeName.create(simpleThung, bar);\n+    ParameterizedType thungOfSuperBar\n+        = Types.parameterizedType(thung, Types.supertypeOf(bar));\n+    ParameterizedType thungOfSuperFoo\n+        = Types.parameterizedType(thung, Types.supertypeOf(foo));\n+    ParameterizedType simpleThungOfBar = Types.parameterizedType(simpleThung, bar);\n \n     ParameterSpec thungParameter = new ParameterSpec.Builder()\n         .addModifiers(Modifier.FINAL)\n@@ -235,7 +231,7 @@ public final class TypeSpecTest {\n     ClassName header = ClassName.create(tacosPackage, \"Header\");\n     TypeSpec service = new TypeSpec.Builder()\n         .name(\"Service\")\n-        .type(TypeSpec.Type.INTERFACE)\n+        .interfaceType()\n         .addMethod(new MethodSpec.Builder()\n             .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)\n             .addAnnotation(new AnnotationSpec.Builder()\n@@ -247,11 +243,11 @@ public final class TypeSpecTest {\n                 .type(post)\n                 .addMember(\"value\", \"$S\", \"/foo/bar\")\n                 .build())\n-            .returns(ParameterizedTypeName.create(observable, fooBar))\n+            .returns(Types.parameterizedType(observable, fooBar))\n             .name(\"fooBar\")\n             .addParameter(new ParameterSpec.Builder()\n                 .addAnnotation(body)\n-                .type(ParameterizedTypeName.create(things, thing))\n+                .type(Types.parameterizedType(things, thing))\n                 .name(\"things\")\n                 .build())\n             .addParameter(new ParameterSpec.Builder()\n@@ -259,7 +255,7 @@ public final class TypeSpecTest {\n                     .type(queryMap)\n                     .addMember(\"encodeValues\", \"false\")\n                     .build())\n-                .type(ParameterizedTypeName.create(map, string, string))\n+                .type(Types.parameterizedType(map, string, string))\n                 .name(\"query\")\n                 .build())\n             .addParameter(new ParameterSpec.Builder()\n@@ -340,7 +336,7 @@ public final class TypeSpecTest {\n \n   @Test public void enumWithSubclassing() throws Exception {\n       TypeSpec roshambo = new TypeSpec.Builder()\n-        .type(TypeSpec.Type.ENUM)\n+        .enumType()\n         .name(\"Roshambo\")\n         .addModifiers(Modifier.PUBLIC)\n         .addEnumConstant(\"ROCK\")\n@@ -405,7 +401,7 @@ public final class TypeSpecTest {\n   @Test public void enumConstantsRequired() throws Exception {\n     try {\n       new TypeSpec.Builder()\n-        .type(TypeSpec.Type.ENUM)\n+        .enumType()\n         .name(\"Roshambo\")\n         .build();\n       fail();\n@@ -416,7 +412,6 @@ public final class TypeSpecTest {\n   @Test public void onlyEnumsMayHaveEnumConstants() throws Exception {\n     try {\n       new TypeSpec.Builder()\n-        .type(TypeSpec.Type.CLASS)\n         .name(\"Roshambo\")\n         .addEnumConstant(\"ROCK\")\n         .build();\n@@ -427,7 +422,7 @@ public final class TypeSpecTest {\n \n   @Test public void enumWithMembersButNoConstructorCall() throws Exception {\n     TypeSpec roshambo = new TypeSpec.Builder()\n-        .type(TypeSpec.Type.ENUM)\n+        .enumType()\n         .name(\"Roshambo\")\n         .addEnumConstant(\"SPOCK\", new TypeSpec.Builder()\n             .anonymousTypeArguments()\n@@ -484,14 +479,14 @@ public final class TypeSpecTest {\n   }\n \n   @Test public void typeVariables() throws Exception {\n-    TypeVariableName t = TypeVariableName.create(\"T\");\n-    TypeVariableName p = TypeVariableName.create(\"P\", ClassName.fromClass(Number.class));\n+    TypeVariable<?> t = Types.typeVariable(\"T\");\n+    TypeVariable<?> p = Types.typeVariable(\"P\", Number.class);\n     ClassName location = ClassName.create(tacosPackage, \"Location\");\n     TypeSpec typeSpec = new TypeSpec.Builder()\n         .name(\"Location\")\n         .addTypeVariable(t)\n         .addTypeVariable(p)\n-        .addSuperinterface(ParameterizedTypeName.create(ClassName.fromClass(Comparable.class), p))\n+        .addSuperinterface(Types.parameterizedType(ClassName.fromClass(Comparable.class), p))\n         .addField(new FieldSpec.Builder()\n             .type(t)\n             .name(\"label\")\n@@ -516,7 +511,7 @@ public final class TypeSpecTest {\n             .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n             .addTypeVariable(t)\n             .addTypeVariable(p)\n-            .returns(ParameterizedTypeName.create(location, t, p))\n+            .returns(Types.parameterizedType(location, t, p))\n             .name(\"of\")\n             .addParameter(t, \"label\")\n             .addParameter(p, \"x\")\n@@ -556,9 +551,9 @@ public final class TypeSpecTest {\n     TypeSpec typeSpec = new TypeSpec.Builder()\n         .name(\"Taco\")\n         .addModifiers(Modifier.ABSTRACT)\n-        .superclass(ParameterizedTypeName.create(AbstractSet.class, food))\n+        .superclass(Types.parameterizedType(AbstractSet.class, food))\n         .addSuperinterface(Serializable.class)\n-        .addSuperinterface(ParameterizedTypeName.create(Comparable.class, taco))\n+        .addSuperinterface(Types.parameterizedType(Comparable.class, taco))\n         .build();\n     assertThat(toString(typeSpec)).isEqualTo(\"\"\n         + \"package com.squareup.tacos;\\n\"\n@@ -574,7 +569,7 @@ public final class TypeSpecTest {\n \n   @Test public void enumImplements() throws Exception {\n     TypeSpec typeSpec = new TypeSpec.Builder()\n-        .type(TypeSpec.Type.ENUM)\n+        .enumType()\n         .name(\"Food\")\n         .addSuperinterface(Serializable.class)\n         .addSuperinterface(Cloneable.class)\n@@ -597,10 +592,10 @@ public final class TypeSpecTest {\n   @Test public void interfaceExtends() throws Exception {\n     ClassName taco = ClassName.create(tacosPackage, \"Taco\");\n     TypeSpec typeSpec = new TypeSpec.Builder()\n-        .type(TypeSpec.Type.INTERFACE)\n+        .interfaceType()\n         .name(\"Taco\")\n         .addSuperinterface(Serializable.class)\n-        .addSuperinterface(ParameterizedTypeName.create(Comparable.class, taco))\n+        .addSuperinterface(Types.parameterizedType(Comparable.class, taco))\n         .build();\n     assertThat(toString(typeSpec)).isEqualTo(\"\"\n         + \"package com.squareup.tacos;\\n\"\n@@ -625,10 +620,10 @@ public final class TypeSpecTest {\n         .addType(new TypeSpec.Builder()\n             .addModifiers(Modifier.STATIC)\n             .name(taco.simpleName())\n-            .addField(FieldSpec.of(ParameterizedTypeName.create(List.class, topping), \"toppings\"))\n+            .addField(FieldSpec.of(Types.parameterizedType(List.class, topping), \"toppings\"))\n             .addField(FieldSpec.of(sauce, \"sauce\"))\n             .addType(new TypeSpec.Builder()\n-                .type(TypeSpec.Type.ENUM)\n+                .enumType()\n                 .name(topping.simpleName())\n                 .addEnumConstant(\"SHREDDED_CHEESE\")\n                 .addEnumConstant(\"LEAN_GROUND_BEEF\")\n@@ -641,7 +636,7 @@ public final class TypeSpecTest {\n             .addField(FieldSpec.of(sauce, \"dippingSauce\"))\n             .build())\n         .addType(new TypeSpec.Builder()\n-            .type(TypeSpec.Type.ENUM)\n+            .enumType()\n             .name(sauce.simpleName())\n             .addEnumConstant(\"SOUR_CREAM\")\n             .addEnumConstant(\"SALSA\")\n@@ -773,8 +768,7 @@ public final class TypeSpecTest {\n   }\n \n   @Test public void intersectionType() {\n-    TypeVariableName typeVariable = TypeVariableName.create(\"T\", IntersectionTypeName.create(\n-        ClassName.fromClass(Comparator.class), ClassName.fromClass(Serializable.class)));\n+    TypeVariable<?> typeVariable = Types.typeVariable(\"T\", Comparator.class, Serializable.class);\n     TypeSpec taco = new TypeSpec.Builder()\n         .name(\"Taco\")\n         .addMethod(new MethodSpec.Builder()\n"
    },
    {
        "commit_hash": "598b446b8cf567cb6308612357ef6b947d03971c",
        "previous_commit_hash": "cd75215134bb6032d8ff47d7792635cd228a7803",
        "diff_stats": {
            "additions": 176,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright (C) 2014 Google, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javawriter;\n+\n+import com.google.testing.compile.CompilationRule;\n+import java.io.Serializable;\n+import java.lang.reflect.GenericArrayType;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+import java.lang.reflect.WildcardType;\n+import java.nio.charset.Charset;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.TypeParameterElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import static com.google.common.truth.Truth.assert_;\n+\n+public final class TypesTest {\n+  @Rule public final CompilationRule compilation = new CompilationRule();\n+\n+  private TypeElement getElement(Class<?> clazz) {\n+    return compilation.getElements().getTypeElement(clazz.getCanonicalName());\n+  }\n+\n+  private TypeMirror getType(Class<?> clazz) {\n+    return getElement(clazz).asType();\n+  }\n+\n+  @Test public void getBasicTypeMirror() {\n+    assert_().that(Types.get(getType(Object.class)))\n+        .isEqualTo(ClassName.fromClass(Object.class));\n+    assert_().that(Types.get(getType(Charset.class)))\n+        .isEqualTo(ClassName.fromClass(Charset.class));\n+    assert_().that(Types.get(getType(TypesTest.class)))\n+        .isEqualTo(ClassName.fromClass(TypesTest.class));\n+  }\n+\n+  @Test public void getParameterizedTypeMirror() {\n+    DeclaredType setType =\n+        compilation.getTypes().getDeclaredType(getElement(Set.class), getType(Object.class));\n+    assert_().that(Types.get(setType))\n+        .isEqualTo(Types.parameterizedType(ClassName.fromClass(Set.class), ClassName.OBJECT));\n+  }\n+\n+  static class Parameterized<\n+      Simple,\n+      ExtendsClass extends Number,\n+      ExtendsInterface extends Runnable,\n+      ExtendsTypeVariable extends Simple,\n+      Intersection extends Number & Runnable,\n+      IntersectionOfInterfaces extends Runnable & Serializable> {}\n+\n+  @Test public void getTypeVariableTypeMirror() {\n+    List<? extends TypeParameterElement> typeVariables =\n+        getElement(Parameterized.class).getTypeParameters();\n+\n+    assert_().that(Types.get(typeVariables.get(0).asType()))\n+        .isEqualTo(Types.typeVariable(\"Simple\"));\n+    assert_().that(Types.get(typeVariables.get(1).asType()))\n+        .isEqualTo(Types.typeVariable(\"ExtendsClass\", Number.class));\n+    assert_().that(Types.get(typeVariables.get(2).asType()))\n+        .isEqualTo(Types.typeVariable(\"ExtendsInterface\", Runnable.class));\n+    assert_().that(Types.get(typeVariables.get(3).asType()))\n+        .isEqualTo(Types.typeVariable(\"ExtendsTypeVariable\", Types.typeVariable(\"Simple\")));\n+    assert_().that(Types.get(typeVariables.get(4).asType()))\n+        .isEqualTo(Types.typeVariable(\"Intersection\", Number.class, Runnable.class));\n+    assert_().that(Types.get(typeVariables.get(5).asType()))\n+        .isEqualTo(Types.typeVariable(\"IntersectionOfInterfaces\",\n+            Runnable.class, Serializable.class));\n+  }\n+\n+  @Test public void typeVariableBounds() {\n+    List<? extends TypeParameterElement> typeVariables =\n+        getElement(Parameterized.class).getTypeParameters();\n+    TypeVariable typeVariable = (TypeVariable) Types.get(typeVariables.get(4).asType());\n+    Type[] bounds = typeVariable.getBounds();\n+\n+    if (bounds.length == 1) {\n+      // Java 8.\n+      IntersectionType intersectionType = (IntersectionType) bounds[0];\n+      assert_().that(intersectionType.getBounds()).asList()\n+          .containsExactly(ClassName.fromClass(Number.class), ClassName.fromClass(Runnable.class));\n+      assert_().that(intersectionType.toString())\n+          .isEqualTo(\"java.lang.Number & java.lang.Runnable\");\n+    } else {\n+      // Java \u2264 7.\n+      assert_().that(bounds).asList()\n+          .containsExactly(ClassName.fromClass(Number.class), ClassName.fromClass(Runnable.class));\n+    }\n+  }\n+\n+  @Test public void getPrimitiveTypeMirror() {\n+    assert_().that(Types.get(compilation.getTypes().getPrimitiveType(TypeKind.BOOLEAN)))\n+        .isEqualTo(boolean.class);\n+    assert_().that(Types.get(compilation.getTypes().getPrimitiveType(TypeKind.BYTE)))\n+        .isEqualTo(byte.class);\n+    assert_().that(Types.get(compilation.getTypes().getPrimitiveType(TypeKind.SHORT)))\n+        .isEqualTo(short.class);\n+    assert_().that(Types.get(compilation.getTypes().getPrimitiveType(TypeKind.INT)))\n+        .isEqualTo(int.class);\n+    assert_().that(Types.get(compilation.getTypes().getPrimitiveType(TypeKind.LONG)))\n+        .isEqualTo(long.class);\n+    assert_().that(Types.get(compilation.getTypes().getPrimitiveType(TypeKind.CHAR)))\n+        .isEqualTo(char.class);\n+    assert_().that(Types.get(compilation.getTypes().getPrimitiveType(TypeKind.FLOAT)))\n+        .isEqualTo(float.class);\n+    assert_().that(Types.get(compilation.getTypes().getPrimitiveType(TypeKind.DOUBLE)))\n+        .isEqualTo(double.class);\n+  }\n+\n+  @Test public void getArrayTypeMirror() {\n+    assert_().that(Types.get(compilation.getTypes().getArrayType(getType(Object.class))))\n+        .isEqualTo(Types.arrayOf(ClassName.OBJECT));\n+  }\n+\n+  @Test public void getVoidTypeMirror() {\n+    assert_().that(Types.get(compilation.getTypes().getNoType(TypeKind.VOID)))\n+        .isEqualTo(void.class);\n+  }\n+\n+  @Test public void getNullTypeMirror() {\n+    assert_().that(Types.get(compilation.getTypes().getNullType()))\n+        .isEqualTo(Types.NULL);\n+  }\n+\n+  @Test public void parameterizedType() throws Exception {\n+    ParameterizedType type = Types.parameterizedType(Map.class, String.class, Long.class);\n+    assert_().that(type.toString()).isEqualTo(\"java.util.Map<java.lang.String, java.lang.Long>\");\n+  }\n+\n+  @Test public void arrayType() throws Exception {\n+    GenericArrayType type = Types.arrayOf(String.class);\n+    assert_().that(type.toString()).isEqualTo(\"java.lang.String[]\");\n+  }\n+\n+  @Test public void wildcardExtendsType() throws Exception {\n+    WildcardType type = Types.subtypeOf(CharSequence.class);\n+    assert_().that(type.toString()).isEqualTo(\"? extends java.lang.CharSequence\");\n+  }\n+\n+  @Test public void wildcardExtendsObject() throws Exception {\n+    WildcardType type = Types.subtypeOf(Object.class);\n+    assert_().that(type.toString()).isEqualTo(\"?\");\n+  }\n+\n+  @Test public void wildcardSuperType() throws Exception {\n+    WildcardType type = Types.supertypeOf(String.class);\n+    assert_().that(type.toString()).isEqualTo(\"? super java.lang.String\");\n+  }\n+\n+  @Test public void typeVariable() throws Exception {\n+    TypeVariable<?> type = Types.typeVariable(\"T\", CharSequence.class);\n+    assert_().that(type.toString()).isEqualTo(\"T\"); // (Bounds are only emitted in declaration.)\n+  }\n+}\n"
    },
    {
        "commit_hash": "a6a446c770a415b3e5289c46490c3ea9b1d0757f",
        "previous_commit_hash": "8fba60b13d591ea47f6e40f2f635e6b7bb798b43",
        "diff_stats": {
            "additions": 7,
            "deletions": 4
        },
        "diff_content": "@@ -73,7 +73,11 @@ public final class AnnotationSpec {\n   }\n \n   public static AnnotationSpec of(Type annotation) {\n-    return new Builder().type(annotation).build();\n+    return builder(annotation).build();\n+  }\n+\n+  public static Builder builder(Type type) {\n+    return new Builder(type);\n   }\n \n   @Override public boolean equals(Object o) {\n@@ -87,12 +91,11 @@ public final class AnnotationSpec {\n   }\n \n   public static final class Builder {\n-    private Type type;\n+    private final Type type;\n     private final SortedMap<String, Snippet> members = Maps.newTreeMap();\n \n-    public Builder type(Type type) {\n+    private Builder(Type type) {\n       this.type = type;\n-      return this;\n     }\n \n     public Builder addMember(String name, String format, Object... args) {\n"
    },
    {
        "commit_hash": "a6a446c770a415b3e5289c46490c3ea9b1d0757f",
        "previous_commit_hash": "8fba60b13d591ea47f6e40f2f635e6b7bb798b43",
        "diff_stats": {
            "additions": 17,
            "deletions": 14
        },
        "diff_content": "@@ -27,17 +27,17 @@ import static com.google.common.base.Preconditions.checkNotNull;\n \n /** A generated field declaration. */\n public final class FieldSpec {\n+  public final Name name;\n   public final ImmutableList<AnnotationSpec> annotations;\n   public final ImmutableSet<Modifier> modifiers;\n   public final Type type;\n-  public final Name name;\n   public final Snippet initializer;\n \n   private FieldSpec(Builder builder) {\n+    this.name = checkNotNull(builder.name);\n     this.annotations = ImmutableList.copyOf(builder.annotations);\n     this.modifiers = ImmutableSet.copyOf(builder.modifiers);\n     this.type = checkNotNull(builder.type);\n-    this.name = checkNotNull(builder.name);\n     this.initializer = builder.initializer;\n   }\n \n@@ -56,21 +56,33 @@ public final class FieldSpec {\n     codeWriter.emit(\";\\n\");\n   }\n \n+  public static Builder builder(String name) {\n+    return builder(new Name(name));\n+  }\n+\n+  public static Builder builder(Name name) {\n+    return new Builder(name);\n+  }\n+\n   public static FieldSpec of(Type type, String name, Modifier... modifiers) {\n-    return new Builder()\n+    return new Builder(new Name(name))\n         .type(type)\n-        .name(name)\n         .addModifiers(modifiers)\n         .build();\n   }\n \n   public static final class Builder {\n+    private final Name name;\n+\n     private final List<AnnotationSpec> annotations = new ArrayList<>();\n     private final List<Modifier> modifiers = new ArrayList<>();\n     private Type type;\n-    private Name name;\n     private Snippet initializer;\n \n+    private Builder(Name name) {\n+      this.name = name;\n+    }\n+\n     public Builder addAnnotation(AnnotationSpec annotationSpec) {\n       this.annotations.add(annotationSpec);\n       return this;\n@@ -91,15 +103,6 @@ public final class FieldSpec {\n       return this;\n     }\n \n-    public Builder name(Name name) {\n-      this.name = name;\n-      return this;\n-    }\n-\n-    public Builder name(String name) {\n-      return name(new Name(name));\n-    }\n-\n     public Builder initializer(String format, Object... args) {\n       this.initializer = new Snippet(format, args);\n       return this;\n"
    },
    {
        "commit_hash": "a6a446c770a415b3e5289c46490c3ea9b1d0757f",
        "previous_commit_hash": "8fba60b13d591ea47f6e40f2f635e6b7bb798b43",
        "diff_stats": {
            "additions": 26,
            "deletions": 24
        },
        "diff_content": "@@ -26,29 +26,28 @@ import javax.lang.model.element.Modifier;\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n \n-/** A generated method declaration. */\n+/** A generated constructor or method declaration. */\n public final class MethodSpec {\n+  public final Name name;\n   public final ImmutableList<AnnotationSpec> annotations;\n   public final ImmutableSet<Modifier> modifiers;\n   public final ImmutableList<TypeVariable<?>> typeVariables;\n   public final Type returnType;\n-  public final Name name;\n   public final ImmutableList<ParameterSpec> parameters;\n   public final ImmutableList<Type> exceptions;\n   public final ImmutableList<Snippet> snippets;\n \n   private MethodSpec(Builder builder) {\n-    checkArgument(builder.returnType != null ^ builder.name == Name.CONSTRUCTOR,\n-        \"unexpected return type %s for %s\", builder.returnType, builder.name);\n     checkArgument(builder.snippets.isEmpty() || !builder.modifiers.contains(Modifier.ABSTRACT),\n         \"abstract method %s cannot have code\", builder.name);\n \n+    this.name = checkNotNull(builder.name);\n     this.annotations = ImmutableList.copyOf(builder.annotations);\n     this.modifiers = ImmutableSet.copyOf(builder.modifiers);\n     this.typeVariables = ImmutableList.copyOf(builder.typeVariables);\n     this.returnType = builder.returnType;\n-    this.name = checkNotNull(builder.name);\n     this.parameters = ImmutableList.copyOf(builder.parameters);\n     this.exceptions = ImmutableList.copyOf(builder.exceptions);\n     this.snippets = ImmutableList.copyOf(builder.snippets);\n@@ -106,16 +105,34 @@ public final class MethodSpec {\n     return modifiers.contains(modifier);\n   }\n \n+  public static Builder methodBuilder(String name) {\n+    return methodBuilder(new Name(name));\n+  }\n+\n+  public static Builder methodBuilder(Name name) {\n+    return new Builder(name);\n+  }\n+\n+  public static Builder constructorBuilder() {\n+    return new Builder(Name.CONSTRUCTOR);\n+  }\n+\n   public static final class Builder {\n+    private final Name name;\n+\n     private final List<AnnotationSpec> annotations = new ArrayList<>();\n     private final List<Modifier> modifiers = new ArrayList<>();\n     private List<TypeVariable<?>> typeVariables = new ArrayList<>();\n-    private Type returnType = void.class;\n-    private Name name;\n+    private Type returnType;\n     private final List<ParameterSpec> parameters = new ArrayList<>();\n     private final List<Type> exceptions = new ArrayList<>();\n     private final List<Snippet> snippets = new ArrayList<>();\n \n+    private Builder(Name name) {\n+      this.name = name;\n+      this.returnType = name == Name.CONSTRUCTOR ? null : void.class;\n+    }\n+\n     public Builder addAnnotation(AnnotationSpec annotationSpec) {\n       this.annotations.add(annotationSpec);\n       return this;\n@@ -137,33 +154,18 @@ public final class MethodSpec {\n     }\n \n     public Builder returns(Type returnType) {\n+      checkState(name != Name.CONSTRUCTOR);\n       this.returnType = returnType;\n       return this;\n     }\n \n-    public Builder constructor() {\n-      returnType = null;\n-      name = Name.CONSTRUCTOR;\n-      return this;\n-    }\n-\n-    public Builder name(String name) {\n-      this.name = new Name(name);\n-      return this;\n-    }\n-\n-    public Builder name(Name name) {\n-      this.name = name;\n-      return this;\n-    }\n-\n     public Builder addParameter(ParameterSpec parameterSpec) {\n       this.parameters.add(parameterSpec);\n       return this;\n     }\n \n     public Builder addParameter(Type type, String name) {\n-      return addParameter(new ParameterSpec.Builder().type(type).name(name).build());\n+      return addParameter(ParameterSpec.builder(type, name).build());\n     }\n \n     public Builder addException(Type exception) {\n"
    },
    {
        "commit_hash": "a6a446c770a415b3e5289c46490c3ea9b1d0757f",
        "previous_commit_hash": "8fba60b13d591ea47f6e40f2f635e6b7bb798b43",
        "diff_stats": {
            "additions": 18,
            "deletions": 19
        },
        "diff_content": "@@ -27,16 +27,16 @@ import static com.google.common.base.Preconditions.checkNotNull;\n \n /** A generated parameter declaration. */\n public final class ParameterSpec {\n+  public final Name name;\n   public final ImmutableList<AnnotationSpec> annotations;\n   public final ImmutableSet<Modifier> modifiers;\n   public final Type type;\n-  public final Name name;\n \n   private ParameterSpec(Builder builder) {\n+    this.name = checkNotNull(builder.name);\n     this.annotations = ImmutableList.copyOf(builder.annotations);\n     this.modifiers = ImmutableSet.copyOf(builder.modifiers);\n     this.type = checkNotNull(builder.type);\n-    this.name = checkNotNull(builder.name);\n   }\n \n   public boolean hasModifier(Modifier modifier) {\n@@ -49,11 +49,25 @@ public final class ParameterSpec {\n     codeWriter.emit(\"$T $L\", type, name);\n   }\n \n+  public static Builder builder(Type type, String name) {\n+    return builder(type, new Name(name));\n+  }\n+\n+  public static Builder builder(Type type, Name name) {\n+    return new Builder(type, name);\n+  }\n+\n   public static final class Builder {\n+    private final Type type;\n+    private final Name name;\n+\n     private final List<AnnotationSpec> annotations = new ArrayList<>();\n     private final List<Modifier> modifiers = new ArrayList<>();\n-    private Type type;\n-    private Name name;\n+\n+    private Builder(Type type, Name name) {\n+      this.type = type;\n+      this.name = name;\n+    }\n \n     public Builder addAnnotation(AnnotationSpec annotationSpec) {\n       this.annotations.add(annotationSpec);\n@@ -70,21 +84,6 @@ public final class ParameterSpec {\n       return this;\n     }\n \n-    public Builder type(Type type) {\n-      this.type = type;\n-      return this;\n-    }\n-\n-    public Builder name(String name) {\n-      this.name = new Name(name);\n-      return this;\n-    }\n-\n-    public Builder name(Name name) {\n-      this.name = name;\n-      return this;\n-    }\n-\n     public ParameterSpec build() {\n       return new ParameterSpec(this);\n     }\n"
    },
    {
        "commit_hash": "a6a446c770a415b3e5289c46490c3ea9b1d0757f",
        "previous_commit_hash": "8fba60b13d591ea47f6e40f2f635e6b7bb798b43",
        "diff_stats": {
            "additions": 36,
            "deletions": 36
        },
        "diff_content": "@@ -32,18 +32,19 @@ import javax.lang.model.element.Modifier;\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n import static com.google.common.collect.Iterables.getOnlyElement;\n \n /** A generated class, interface, or enum declaration. */\n public final class TypeSpec {\n-  public final ImmutableList<AnnotationSpec> annotations;\n-  public final ImmutableSet<Modifier> modifiers;\n   public final DeclarationType declarationType;\n   public final String name;\n+  public final Snippet anonymousTypeArguments;\n+  public final ImmutableList<AnnotationSpec> annotations;\n+  public final ImmutableSet<Modifier> modifiers;\n   public final ImmutableList<TypeVariable<?>> typeVariables;\n   public final Type superclass;\n   public final ImmutableList<Type> superinterfaces;\n-  public final Snippet anonymousTypeArguments;\n   public final ImmutableMap<String, TypeSpec> enumConstants;\n   public final ImmutableList<FieldSpec> fieldSpecs;\n   public final ImmutableList<MethodSpec> methodSpecs;\n@@ -78,14 +79,14 @@ public final class TypeSpec {\n     checkArgument(builder.anonymousTypeArguments == null || interestingSupertypeCount <= 1,\n         \"anonymous type has too many supertypes\");\n \n-    this.annotations = ImmutableList.copyOf(builder.annotations);\n-    this.modifiers = ImmutableSet.copyOf(builder.modifiers);\n     this.declarationType = checkNotNull(builder.declarationType);\n     this.name = builder.name;\n+    this.anonymousTypeArguments = builder.anonymousTypeArguments;\n+    this.annotations = ImmutableList.copyOf(builder.annotations);\n+    this.modifiers = ImmutableSet.copyOf(builder.modifiers);\n     this.typeVariables = ImmutableList.copyOf(builder.typeVariables);\n     this.superclass = builder.superclass;\n     this.superinterfaces = ImmutableList.copyOf(builder.superinterfaces);\n-    this.anonymousTypeArguments = builder.anonymousTypeArguments;\n     this.enumConstants = ImmutableMap.copyOf(builder.enumConstants);\n     this.fieldSpecs = ImmutableList.copyOf(builder.fieldSpecs);\n     this.methodSpecs = ImmutableList.copyOf(builder.methodSpecs);\n@@ -103,6 +104,22 @@ public final class TypeSpec {\n     return modifiers.contains(modifier);\n   }\n \n+  public static Builder classBuilder(String name) {\n+    return new Builder(DeclarationType.CLASS, name, null);\n+  }\n+\n+  public static Builder interfaceBuilder(String name) {\n+    return new Builder(DeclarationType.INTERFACE, name, null);\n+  }\n+\n+  public static Builder enumBuilder(String name) {\n+    return new Builder(DeclarationType.ENUM, name, null);\n+  }\n+\n+  public static Builder anonymousClassBuilder(String typeArgumentsFormat, Object... args) {\n+    return new Builder(DeclarationType.CLASS, null, new Snippet(typeArgumentsFormat, args));\n+  }\n+\n   void emit(CodeWriter codeWriter, String enumName) {\n     if (enumName != null) {\n       codeWriter.emit(\"$L\", enumName);\n@@ -218,20 +235,28 @@ public final class TypeSpec {\n   }\n \n   public static final class Builder {\n+    private final DeclarationType declarationType;\n+    private final String name;\n+    private final Snippet anonymousTypeArguments;\n+\n     private final List<AnnotationSpec> annotations = new ArrayList<>();\n     private final List<Modifier> modifiers = new ArrayList<>();\n-    private DeclarationType declarationType = DeclarationType.CLASS;\n-    private String name;\n     private final List<TypeVariable<?>> typeVariables = new ArrayList<>();\n     private Type superclass = ClassName.OBJECT;\n     private final List<Type> superinterfaces = new ArrayList<>();\n-    private Snippet anonymousTypeArguments;\n     private final Map<String, TypeSpec> enumConstants = new LinkedHashMap<>();\n     private final List<FieldSpec> fieldSpecs = new ArrayList<>();\n     private final List<MethodSpec> methodSpecs = new ArrayList<>();\n     private final List<TypeSpec> typeSpecs = new ArrayList<>();\n     private final List<Element> originatingElements = new ArrayList<>();\n \n+    private Builder(DeclarationType declarationType, String name,\n+        Snippet anonymousTypeArguments) {\n+      this.declarationType = declarationType;\n+      this.name = name;\n+      this.anonymousTypeArguments = anonymousTypeArguments;\n+    }\n+\n     public Builder addAnnotation(AnnotationSpec annotationSpec) {\n       this.annotations.add(annotationSpec);\n       return this;\n@@ -247,21 +272,6 @@ public final class TypeSpec {\n       return this;\n     }\n \n-    public Builder interfaceType() {\n-      this.declarationType = DeclarationType.INTERFACE;\n-      return this;\n-    }\n-\n-    public Builder enumType() {\n-      this.declarationType = DeclarationType.ENUM;\n-      return this;\n-    }\n-\n-    public Builder name(String name) {\n-      this.name = name;\n-      return this;\n-    }\n-\n     public Builder addTypeVariable(TypeVariable<?> typeVariable) {\n       typeVariables.add(typeVariable);\n       return this;\n@@ -277,19 +287,9 @@ public final class TypeSpec {\n       return this;\n     }\n \n-    public Builder anonymousTypeArguments() {\n-      return anonymousTypeArguments(\"\");\n-    }\n-\n-    public Builder anonymousTypeArguments(String format, Object... args) {\n-      this.anonymousTypeArguments = new Snippet(format, args);\n-      return this;\n-    }\n-\n     public Builder addEnumConstant(String name) {\n-      return addEnumConstant(name, new Builder()\n-          .anonymousTypeArguments()\n-          .build());\n+      checkState(declarationType == DeclarationType.ENUM);\n+      return addEnumConstant(name, anonymousClassBuilder(\"\").build());\n     }\n \n     public Builder addEnumConstant(String name, TypeSpec typeSpec) {\n"
    },
    {
        "commit_hash": "a6a446c770a415b3e5289c46490c3ea9b1d0757f",
        "previous_commit_hash": "8fba60b13d591ea47f6e40f2f635e6b7bb798b43",
        "diff_stats": {
            "additions": 6,
            "deletions": 15
        },
        "diff_content": "@@ -15,9 +15,6 @@\n  */\n package com.squareup.javawriter;\n \n-import com.squareup.javawriter.FieldSpec;\n-import com.squareup.javawriter.JavaFile;\n-import com.squareup.javawriter.TypeSpec;\n import java.util.Date;\n import org.junit.Test;\n \n@@ -27,8 +24,7 @@ public final class JavaFileTest {\n   @Test public void noImports() throws Exception {\n     String source = new JavaFile.Builder()\n         .packageName(\"com.squareup.tacos\")\n-        .typeSpec(new TypeSpec.Builder()\n-            .name(\"Taco\")\n+        .typeSpec(TypeSpec.classBuilder(\"Taco\")\n             .build())\n         .build()\n         .toString();\n@@ -42,11 +38,9 @@ public final class JavaFileTest {\n   @Test public void singleImport() throws Exception {\n     String source = new JavaFile.Builder()\n         .packageName(\"com.squareup.tacos\")\n-        .typeSpec(new TypeSpec.Builder()\n-            .name(\"Taco\")\n-            .addField(new FieldSpec.Builder()\n+        .typeSpec(TypeSpec.classBuilder(\"Taco\")\n+            .addField(FieldSpec.builder(\"madeFreshDate\")\n                 .type(Date.class)\n-                .name(\"madeFreshDate\")\n                 .build())\n             .build())\n         .build()\n@@ -64,15 +58,12 @@ public final class JavaFileTest {\n   @Test public void conflictingImports() throws Exception {\n     String source = new JavaFile.Builder()\n         .packageName(\"com.squareup.tacos\")\n-        .typeSpec(new TypeSpec.Builder()\n-            .name(\"Taco\")\n-            .addField(new FieldSpec.Builder()\n+        .typeSpec(TypeSpec.classBuilder(\"Taco\")\n+            .addField(FieldSpec.builder(\"madeFreshDate\")\n                 .type(Date.class)\n-                .name(\"madeFreshDate\")\n                 .build())\n-            .addField(new FieldSpec.Builder()\n+            .addField(FieldSpec.builder(\"madeFreshDatabaseDate\")\n                 .type(java.sql.Date.class)\n-                .name(\"madeFreshDatabaseDate\")\n                 .build())\n             .build())\n         .build()\n"
    },
    {
        "commit_hash": "a6a446c770a415b3e5289c46490c3ea9b1d0757f",
        "previous_commit_hash": "8fba60b13d591ea47f6e40f2f635e6b7bb798b43",
        "diff_stats": {
            "additions": 14,
            "deletions": 36
        },
        "diff_content": "@@ -64,9 +64,7 @@ public final class JavaWriterTest {\n   }\n \n   @Test public void pathDefaultPackage() throws IOException {\n-    TypeSpec type = new TypeSpec.Builder()\n-        .name(\"Test\")\n-        .build();\n+    TypeSpec type = TypeSpec.classBuilder(\"Test\").build();\n     javaWriter.add(\"\", type).writeTo(fsRoot);\n \n     Path testPath = fsRoot.resolve(\"Test.java\");\n@@ -74,9 +72,7 @@ public final class JavaWriterTest {\n   }\n \n   @Test public void fileDefaultPackage() throws IOException {\n-    TypeSpec type = new TypeSpec.Builder()\n-        .name(\"Test\")\n-        .build();\n+    TypeSpec type = TypeSpec.classBuilder(\"Test\").build();\n     javaWriter.add(\"\", type).writeTo(tmp.getRoot());\n \n     File testFile = new File(tmp.getRoot(), \"Test.java\");\n@@ -84,9 +80,7 @@ public final class JavaWriterTest {\n   }\n \n   @Test public void filerDefaultPackage() throws IOException {\n-    TypeSpec type = new TypeSpec.Builder()\n-        .name(\"Test\")\n-        .build();\n+    TypeSpec type = TypeSpec.classBuilder(\"Test\").build();\n     javaWriter.add(\"\", type).writeTo(filer);\n \n     Path testPath = fsRoot.resolve(\"Test.java\");\n@@ -94,12 +88,8 @@ public final class JavaWriterTest {\n   }\n \n   @Test public void pathSamePackage() throws IOException {\n-    TypeSpec test1 = new TypeSpec.Builder()\n-        .name(\"Test1\")\n-        .build();\n-    TypeSpec test2 = new TypeSpec.Builder()\n-        .name(\"Test2\")\n-        .build();\n+    TypeSpec test1 = TypeSpec.classBuilder(\"Test1\").build();\n+    TypeSpec test2 = TypeSpec.classBuilder(\"Test2\").build();\n     javaWriter.add(\"example\", test1).add(\"example\", test2).writeTo(fsRoot);\n \n     Path testPath1 = fsRoot.resolve(fs.getPath(\"example\", \"Test1.java\"));\n@@ -109,12 +99,8 @@ public final class JavaWriterTest {\n   }\n \n   @Test public void fileSamePackage() throws IOException {\n-    TypeSpec test1 = new TypeSpec.Builder()\n-        .name(\"Test1\")\n-        .build();\n-    TypeSpec test2 = new TypeSpec.Builder()\n-        .name(\"Test2\")\n-        .build();\n+    TypeSpec test1 = TypeSpec.classBuilder(\"Test1\").build();\n+    TypeSpec test2 = TypeSpec.classBuilder(\"Test2\").build();\n     javaWriter.add(\"example\", test1).add(\"example\", test2).writeTo(tmp.getRoot());\n \n     File examplePackage = new File(tmp.getRoot(), \"example\");\n@@ -125,12 +111,8 @@ public final class JavaWriterTest {\n   }\n \n   @Test public void filerSamePackage() throws IOException {\n-    TypeSpec test1 = new TypeSpec.Builder()\n-        .name(\"Test1\")\n-        .build();\n-    TypeSpec test2 = new TypeSpec.Builder()\n-        .name(\"Test2\")\n-        .build();\n+    TypeSpec test1 = TypeSpec.classBuilder(\"Test1\").build();\n+    TypeSpec test2 = TypeSpec.classBuilder(\"Test2\").build();\n     javaWriter.add(\"example\", test1).add(\"example\", test2).writeTo(filer);\n \n     Path testPath1 = fsRoot.resolve(fs.getPath(\"example\", \"Test1.java\"));\n@@ -140,9 +122,7 @@ public final class JavaWriterTest {\n   }\n \n   @Test public void pathNestedClasses() throws IOException {\n-    TypeSpec test = new TypeSpec.Builder()\n-        .name(\"Test\")\n-        .build();\n+    TypeSpec test = TypeSpec.classBuilder(\"Test\").build();\n     javaWriter.add(\"foo\", test)\n         .add(\"foo.bar\", test)\n         .add(\"foo.bar.baz\", test)\n@@ -157,7 +137,7 @@ public final class JavaWriterTest {\n   }\n \n   @Test public void fileNestedClasses() throws IOException {\n-    TypeSpec test = new TypeSpec.Builder().name(\"Test\").build();\n+    TypeSpec test = TypeSpec.classBuilder(\"Test\").build();\n     javaWriter.add(\"foo\", test)\n         .add(\"foo.bar\", test)\n         .add(\"foo.bar.baz\", test)\n@@ -175,7 +155,7 @@ public final class JavaWriterTest {\n   }\n \n   @Test public void filerNestedClasses() throws IOException {\n-    TypeSpec test = new TypeSpec.Builder().name(\"Test\").build();\n+    TypeSpec test = TypeSpec.classBuilder(\"Test\").build();\n     javaWriter.add(\"foo\", test)\n         .add(\"foo.bar\", test)\n         .add(\"foo.bar.baz\", test)\n@@ -191,15 +171,13 @@ public final class JavaWriterTest {\n \n   @Test public void filerPassesOriginatingElements() throws IOException {\n     Element element1_1 = Mockito.mock(Element.class);\n-    TypeSpec test1 = new TypeSpec.Builder()\n-        .name(\"Test1\")\n+    TypeSpec test1 = TypeSpec.classBuilder(\"Test1\")\n         .addOriginatingElement(element1_1)\n         .build();\n \n     Element element2_1 = Mockito.mock(Element.class);\n     Element element2_2 = Mockito.mock(Element.class);\n-    TypeSpec test2 = new TypeSpec.Builder()\n-        .name(\"Test2\")\n+    TypeSpec test2 = TypeSpec.classBuilder(\"Test2\")\n         .addOriginatingElement(element2_1)\n         .addOriginatingElement(element2_2)\n         .build();\n"
    },
    {
        "commit_hash": "a6a446c770a415b3e5289c46490c3ea9b1d0757f",
        "previous_commit_hash": "8fba60b13d591ea47f6e40f2f635e6b7bb798b43",
        "diff_stats": {
            "additions": 78,
            "deletions": 165
        },
        "diff_content": "@@ -36,10 +36,8 @@ public final class TypeSpecTest {\n   private static final String donutsPackage = \"com.squareup.donuts\";\n \n   @Test public void basic() throws Exception {\n-    TypeSpec taco = new TypeSpec.Builder()\n-        .name(\"Taco\")\n-        .addMethod(new MethodSpec.Builder()\n-            .name(\"toString\")\n+    TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n+        .addMethod(MethodSpec.methodBuilder(\"toString\")\n             .addAnnotation(Override.class)\n             .addModifiers(Modifier.PUBLIC, Modifier.FINAL)\n             .returns(String.class)\n@@ -61,21 +59,17 @@ public final class TypeSpecTest {\n   }\n \n   @Test public void interestingTypes() throws Exception {\n-    TypeSpec taco = new TypeSpec.Builder()\n-        .name(\"Taco\")\n-        .addField(new FieldSpec.Builder()\n+    TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n+        .addField(FieldSpec.builder(\"extendsObject\")\n             .type(Types.parameterizedType(List.class, Types.subtypeOf(Object.class)))\n-            .name(\"extendsObject\")\n             .build())\n-        .addField(new FieldSpec.Builder()\n+        .addField(FieldSpec.builder(\"extendsSerializable\")\n             .type(Types.parameterizedType(ClassName.fromClass(List.class),\n                 Types.subtypeOf(Serializable.class)))\n-            .name(\"extendsSerializable\")\n             .build())\n-        .addField(new FieldSpec.Builder()\n+        .addField(FieldSpec.builder(\"superString\")\n             .type(Types.parameterizedType(ClassName.fromClass(List.class),\n                 Types.supertypeOf(String.class)))\n-            .name(\"superString\")\n             .build())\n         .build();\n     assertThat(toString(taco)).isEqualTo(\"\"\n@@ -109,40 +103,32 @@ public final class TypeSpecTest {\n         = Types.parameterizedType(thung, Types.supertypeOf(foo));\n     ParameterizedType simpleThungOfBar = Types.parameterizedType(simpleThung, bar);\n \n-    ParameterSpec thungParameter = new ParameterSpec.Builder()\n+    ParameterSpec thungParameter = ParameterSpec.builder(thungOfSuperFoo, \"thung\")\n         .addModifiers(Modifier.FINAL)\n-        .type(thungOfSuperFoo)\n-        .name(\"thung\")\n         .build();\n-    TypeSpec aSimpleThung = new TypeSpec.Builder()\n+    TypeSpec aSimpleThung = TypeSpec.anonymousClassBuilder(\"$N\", thungParameter)\n         .superclass(simpleThungOfBar)\n-        .anonymousTypeArguments(\"$N\", thungParameter)\n-        .addMethod(new MethodSpec.Builder()\n+        .addMethod(MethodSpec.methodBuilder(\"doSomething\")\n             .addAnnotation(Override.class)\n             .addModifiers(Modifier.PUBLIC)\n-            .name(\"doSomething\")\n             .addParameter(bar, \"bar\")\n             .addCode(\"/* code snippets */\\n\")\n             .build())\n         .build();\n-    TypeSpec aThingThang = new TypeSpec.Builder()\n+    TypeSpec aThingThang = TypeSpec.anonymousClassBuilder(\"\")\n         .superclass(thingThangOfFooBar)\n-        .anonymousTypeArguments(\"\")\n-        .addMethod(new MethodSpec.Builder()\n+        .addMethod(MethodSpec.methodBuilder(\"call\")\n             .addAnnotation(Override.class)\n             .addModifiers(Modifier.PUBLIC)\n             .returns(thungOfSuperBar)\n-            .name(\"call\")\n             .addParameter(thungParameter)\n             .addCode(\"return $L;\\n\", aSimpleThung)\n             .build())\n         .build();\n-    TypeSpec taco = new TypeSpec.Builder()\n-        .name(\"Taco\")\n-        .addField(new FieldSpec.Builder()\n+    TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n+        .addField(FieldSpec.builder(\"NAME\")\n             .addModifiers(Modifier.STATIC, Modifier.FINAL, Modifier.FINAL)\n             .type(thingThangOfFooBar)\n-            .name(\"NAME\")\n             .initializer(\"$L\", aThingThang)\n             .build())\n         .build();\n@@ -168,37 +154,24 @@ public final class TypeSpecTest {\n   }\n \n   @Test public void annotatedParameters() throws Exception {\n-    TypeSpec service = new TypeSpec.Builder()\n-        .name(\"Foo\")\n-        .addMethod(new MethodSpec.Builder()\n+    TypeSpec service = TypeSpec.classBuilder(\"Foo\")\n+        .addMethod(MethodSpec.constructorBuilder()\n             .addModifiers(Modifier.PUBLIC)\n-            .constructor()\n-            .addParameter(new ParameterSpec.Builder()\n-                .type(long.class)\n-                .name(\"id\")\n-                .build())\n-            .addParameter(new ParameterSpec.Builder()\n+            .addParameter(long.class, \"id\")\n+            .addParameter(ParameterSpec.builder(String.class, \"one\")\n                 .addAnnotation(ClassName.create(tacosPackage, \"Ping\"))\n-                .type(String.class)\n-                .name(\"one\")\n                 .build())\n-            .addParameter(new ParameterSpec.Builder()\n+            .addParameter(ParameterSpec.builder(String.class, \"two\")\n                 .addAnnotation(ClassName.create(tacosPackage, \"Ping\"))\n-                .type(String.class)\n-                .name(\"two\")\n                 .build())\n-            .addParameter(new ParameterSpec.Builder()\n-                .addAnnotation(new AnnotationSpec.Builder()\n-                    .type(ClassName.create(tacosPackage, \"Pong\"))\n-                    .addMember(\"value\", \"$S\", \"pong\")\n-                    .build())\n-                .type(String.class)\n-                .name(\"three\")\n+            .addParameter(ParameterSpec.builder(String.class, \"three\")\n+                .addAnnotation(\n+                    AnnotationSpec.builder(ClassName.create(tacosPackage, \"Pong\"))\n+                        .addMember(\"value\", \"$S\", \"pong\")\n+                        .build())\n                 .build())\n-            .addParameter(new ParameterSpec.Builder()\n+            .addParameter(ParameterSpec.builder(String.class, \"four\")\n                 .addAnnotation(ClassName.create(tacosPackage, \"Ping\"))\n-                .type(String.class)\n-                .name(\"four\")\n                 .build())\n             .addCode(\"/* code snippets */\\n\")\n             .build())\n@@ -229,42 +202,31 @@ public final class TypeSpecTest {\n     ClassName body = ClassName.create(tacosPackage, \"Body\");\n     ClassName queryMap = ClassName.create(tacosPackage, \"QueryMap\");\n     ClassName header = ClassName.create(tacosPackage, \"Header\");\n-    TypeSpec service = new TypeSpec.Builder()\n-        .name(\"Service\")\n-        .interfaceType()\n-        .addMethod(new MethodSpec.Builder()\n+    TypeSpec service = TypeSpec.interfaceBuilder(\"Service\")\n+        .addMethod(MethodSpec.methodBuilder(\"fooBar\")\n             .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)\n-            .addAnnotation(new AnnotationSpec.Builder()\n-                .type(headers)\n+            .addAnnotation(AnnotationSpec.builder(headers)\n                 .addMember(\"value\", \"{\\n$S,\\n$S\\n}\",\n                     \"Accept: application/json\", \"User-Agent: foobar\")\n                 .build())\n-            .addAnnotation(new AnnotationSpec.Builder()\n-                .type(post)\n+            .addAnnotation(AnnotationSpec.builder(post)\n                 .addMember(\"value\", \"$S\", \"/foo/bar\")\n                 .build())\n             .returns(Types.parameterizedType(observable, fooBar))\n-            .name(\"fooBar\")\n-            .addParameter(new ParameterSpec.Builder()\n+            .addParameter(ParameterSpec.builder(Types.parameterizedType(things, thing),\n+                \"things\")\n                 .addAnnotation(body)\n-                .type(Types.parameterizedType(things, thing))\n-                .name(\"things\")\n                 .build())\n-            .addParameter(new ParameterSpec.Builder()\n-                .addAnnotation(new AnnotationSpec.Builder()\n-                    .type(queryMap)\n+            .addParameter(ParameterSpec.builder(\n+                Types.parameterizedType(map, string, string), \"query\")\n+                .addAnnotation(AnnotationSpec.builder(queryMap)\n                     .addMember(\"encodeValues\", \"false\")\n                     .build())\n-                .type(Types.parameterizedType(map, string, string))\n-                .name(\"query\")\n                 .build())\n-            .addParameter(new ParameterSpec.Builder()\n-                .addAnnotation(new AnnotationSpec.Builder()\n-                    .type(header)\n+            .addParameter(ParameterSpec.builder(string, \"authorization\")\n+                .addAnnotation(AnnotationSpec.builder(header)\n                     .addMember(\"value\", \"$S\", \"Authorization\")\n                     .build())\n-                .type(string)\n-                .name(\"authorization\")\n                 .build())\n             .build())\n         .build();\n@@ -287,16 +249,13 @@ public final class TypeSpecTest {\n   }\n \n   @Test public void annotatedField() throws Exception {\n-    TypeSpec taco = new TypeSpec.Builder()\n-        .name(\"Taco\")\n-        .addField(new FieldSpec.Builder()\n-            .addAnnotation(new AnnotationSpec.Builder()\n-                .type(ClassName.create(tacosPackage, \"JsonAdapter\"))\n+    TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n+        .addField(FieldSpec.builder(\"thing\")\n+            .addAnnotation(AnnotationSpec.builder(ClassName.create(tacosPackage, \"JsonAdapter\"))\n                 .addMember(\"value\", \"$T.class\", ClassName.create(tacosPackage, \"Foo\"))\n                 .build())\n             .addModifiers(Modifier.PRIVATE, Modifier.FINAL)\n             .type(String.class)\n-            .name(\"thing\")\n             .build())\n         .build();\n     assertThat(toString(taco)).isEqualTo(\"\"\n@@ -312,14 +271,12 @@ public final class TypeSpecTest {\n \n   @Test public void annotatedClass() throws Exception {\n     ClassName someType = ClassName.create(tacosPackage, \"SomeType\");\n-    TypeSpec taco = new TypeSpec.Builder()\n-        .addAnnotation(new AnnotationSpec.Builder()\n-            .type(ClassName.create(tacosPackage, \"Something\"))\n+    TypeSpec taco = TypeSpec.classBuilder(\"Foo\")\n+        .addAnnotation(AnnotationSpec.builder(ClassName.create(tacosPackage, \"Something\"))\n             .addMember(\"hi\", \"$T.$N\", someType, \"FIELD\")\n             .addMember(\"hey\", \"$L\", 12)\n             .addMember(\"hello\", \"$S\", \"goodbye\")\n             .build())\n-        .name(\"Foo\")\n         .addModifiers(Modifier.PUBLIC)\n         .build();\n     assertThat(toString(taco)).isEqualTo(\"\"\n@@ -335,36 +292,28 @@ public final class TypeSpecTest {\n   }\n \n   @Test public void enumWithSubclassing() throws Exception {\n-      TypeSpec roshambo = new TypeSpec.Builder()\n-        .enumType()\n-        .name(\"Roshambo\")\n+      TypeSpec roshambo = TypeSpec.enumBuilder(\"Roshambo\")\n         .addModifiers(Modifier.PUBLIC)\n         .addEnumConstant(\"ROCK\")\n-        .addEnumConstant(\"PAPER\", new TypeSpec.Builder()\n-            .anonymousTypeArguments(\"$S\", \"flat\")\n-            .addMethod(new MethodSpec.Builder()\n+        .addEnumConstant(\"PAPER\", TypeSpec.anonymousClassBuilder(\"$S\", \"flat\")\n+            .addMethod(MethodSpec.methodBuilder(\"toString\")\n                 .addAnnotation(Override.class)\n                 .addModifiers(Modifier.PUBLIC)\n                 .returns(String.class)\n-                .name(\"toString\")\n                 .addCode(\"return $S;\\n\", \"paper airplane!\")\n                 .build())\n             .build())\n-        .addEnumConstant(\"SCISSORS\", new TypeSpec.Builder()\n-            .anonymousTypeArguments(\"$S\", \"peace sign\")\n+        .addEnumConstant(\"SCISSORS\", TypeSpec.anonymousClassBuilder(\"$S\", \"peace sign\")\n             .build())\n-        .addField(new FieldSpec.Builder()\n+        .addField(FieldSpec.builder(\"handPosition\")\n             .addModifiers(Modifier.PRIVATE, Modifier.FINAL)\n             .type(String.class)\n-            .name(\"handPosition\")\n             .build())\n-        .addMethod(new MethodSpec.Builder()\n-            .constructor()\n+        .addMethod(MethodSpec.constructorBuilder()\n             .addParameter(String.class, \"handPosition\")\n             .addCode(\"this.handPosition = handPosition;\\n\")\n             .build())\n-        .addMethod(new MethodSpec.Builder()\n-            .constructor()\n+        .addMethod(MethodSpec.constructorBuilder()\n             .addCode(\"this($S);\\n\", \"fist\")\n             .build())\n         .build();\n@@ -400,9 +349,7 @@ public final class TypeSpecTest {\n \n   @Test public void enumConstantsRequired() throws Exception {\n     try {\n-      new TypeSpec.Builder()\n-        .enumType()\n-        .name(\"Roshambo\")\n+      TypeSpec.enumBuilder(\"Roshambo\")\n         .build();\n       fail();\n     } catch (IllegalArgumentException expected) {\n@@ -411,26 +358,21 @@ public final class TypeSpecTest {\n \n   @Test public void onlyEnumsMayHaveEnumConstants() throws Exception {\n     try {\n-      new TypeSpec.Builder()\n-        .name(\"Roshambo\")\n+      TypeSpec.classBuilder(\"Roshambo\")\n         .addEnumConstant(\"ROCK\")\n         .build();\n       fail();\n-    } catch (IllegalArgumentException expected) {\n+    } catch (IllegalStateException expected) {\n     }\n   }\n \n   @Test public void enumWithMembersButNoConstructorCall() throws Exception {\n-    TypeSpec roshambo = new TypeSpec.Builder()\n-        .enumType()\n-        .name(\"Roshambo\")\n-        .addEnumConstant(\"SPOCK\", new TypeSpec.Builder()\n-            .anonymousTypeArguments()\n-            .addMethod(new MethodSpec.Builder()\n+    TypeSpec roshambo = TypeSpec.enumBuilder(\"Roshambo\")\n+        .addEnumConstant(\"SPOCK\", TypeSpec.anonymousClassBuilder(\"\")\n+            .addMethod(MethodSpec.methodBuilder(\"toString\")\n                 .addAnnotation(Override.class)\n                 .addModifiers(Modifier.PUBLIC)\n                 .returns(String.class)\n-                .name(\"toString\")\n                 .addCode(\"return $S;\\n\", \"west side\")\n                 .build())\n             .build())\n@@ -452,14 +394,11 @@ public final class TypeSpecTest {\n   }\n \n   @Test public void methodThrows() throws Exception {\n-    TypeSpec taco = new TypeSpec.Builder()\n-        .name(\"Taco\")\n-        .addMethod(new MethodSpec.Builder()\n-            .name(\"throwOne\")\n+    TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n+        .addMethod(MethodSpec.methodBuilder(\"throwOne\")\n             .addException(IOException.class)\n             .build())\n-        .addMethod(new MethodSpec.Builder()\n-            .name(\"throwTwo\")\n+        .addMethod(MethodSpec.methodBuilder(\"throwTwo\")\n             .addException(IOException.class)\n             .addException(ClassName.create(tacosPackage, \"SourCreamException\"))\n             .build())\n@@ -482,37 +421,31 @@ public final class TypeSpecTest {\n     TypeVariable<?> t = Types.typeVariable(\"T\");\n     TypeVariable<?> p = Types.typeVariable(\"P\", Number.class);\n     ClassName location = ClassName.create(tacosPackage, \"Location\");\n-    TypeSpec typeSpec = new TypeSpec.Builder()\n-        .name(\"Location\")\n+    TypeSpec typeSpec = TypeSpec.classBuilder(\"Location\")\n         .addTypeVariable(t)\n         .addTypeVariable(p)\n         .addSuperinterface(Types.parameterizedType(ClassName.fromClass(Comparable.class), p))\n-        .addField(new FieldSpec.Builder()\n+        .addField(FieldSpec.builder(\"label\")\n             .type(t)\n-            .name(\"label\")\n             .build())\n-        .addField(new FieldSpec.Builder()\n+        .addField(FieldSpec.builder(\"x\")\n             .type(p)\n-            .name(\"x\")\n             .build())\n-        .addField(new FieldSpec.Builder()\n+        .addField(FieldSpec.builder(\"y\")\n             .type(p)\n-            .name(\"y\")\n             .build())\n-        .addMethod(new MethodSpec.Builder()\n+        .addMethod(MethodSpec.methodBuilder(\"compareTo\")\n             .addAnnotation(Override.class)\n             .addModifiers(Modifier.PUBLIC)\n             .returns(int.class)\n-            .name(\"compareTo\")\n             .addParameter(p, \"p\")\n             .addCode(\"return 0;\\n\")\n             .build())\n-        .addMethod(new MethodSpec.Builder()\n+        .addMethod(MethodSpec.methodBuilder(\"of\")\n             .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n             .addTypeVariable(t)\n             .addTypeVariable(p)\n             .returns(Types.parameterizedType(location, t, p))\n-            .name(\"of\")\n             .addParameter(t, \"label\")\n             .addParameter(p, \"x\")\n             .addParameter(p, \"y\")\n@@ -548,8 +481,7 @@ public final class TypeSpecTest {\n   @Test public void classImplementsExtends() throws Exception {\n     ClassName taco = ClassName.create(tacosPackage, \"Taco\");\n     ClassName food = ClassName.create(\"com.squareup.tacos\", \"Food\");\n-    TypeSpec typeSpec = new TypeSpec.Builder()\n-        .name(\"Taco\")\n+    TypeSpec typeSpec = TypeSpec.classBuilder(\"Taco\")\n         .addModifiers(Modifier.ABSTRACT)\n         .superclass(Types.parameterizedType(AbstractSet.class, food))\n         .addSuperinterface(Serializable.class)\n@@ -568,9 +500,7 @@ public final class TypeSpecTest {\n   }\n \n   @Test public void enumImplements() throws Exception {\n-    TypeSpec typeSpec = new TypeSpec.Builder()\n-        .enumType()\n-        .name(\"Food\")\n+    TypeSpec typeSpec = TypeSpec.enumBuilder(\"Food\")\n         .addSuperinterface(Serializable.class)\n         .addSuperinterface(Cloneable.class)\n         .addEnumConstant(\"LEAN_GROUND_BEEF\")\n@@ -591,9 +521,7 @@ public final class TypeSpecTest {\n \n   @Test public void interfaceExtends() throws Exception {\n     ClassName taco = ClassName.create(tacosPackage, \"Taco\");\n-    TypeSpec typeSpec = new TypeSpec.Builder()\n-        .interfaceType()\n-        .name(\"Taco\")\n+    TypeSpec typeSpec = TypeSpec.interfaceBuilder(\"Taco\")\n         .addSuperinterface(Serializable.class)\n         .addSuperinterface(Types.parameterizedType(Comparable.class, taco))\n         .build();\n@@ -613,31 +541,24 @@ public final class TypeSpecTest {\n         tacosPackage, ImmutableList.of(\"Combo\", \"Taco\"), \"Topping\");\n     ClassName chips = ClassName.create(tacosPackage, ImmutableList.of(\"Combo\"), \"Chips\");\n     ClassName sauce = ClassName.create(tacosPackage, ImmutableList.of(\"Combo\"), \"Sauce\");\n-    TypeSpec typeSpec = new TypeSpec.Builder()\n-        .name(\"Combo\")\n+    TypeSpec typeSpec = TypeSpec.classBuilder(\"Combo\")\n         .addField(FieldSpec.of(taco, \"taco\"))\n         .addField(FieldSpec.of(chips, \"chips\"))\n-        .addType(new TypeSpec.Builder()\n+        .addType(TypeSpec.classBuilder(taco.simpleName())\n             .addModifiers(Modifier.STATIC)\n-            .name(taco.simpleName())\n             .addField(FieldSpec.of(Types.parameterizedType(List.class, topping), \"toppings\"))\n             .addField(FieldSpec.of(sauce, \"sauce\"))\n-            .addType(new TypeSpec.Builder()\n-                .enumType()\n-                .name(topping.simpleName())\n+            .addType(TypeSpec.enumBuilder(topping.simpleName())\n                 .addEnumConstant(\"SHREDDED_CHEESE\")\n                 .addEnumConstant(\"LEAN_GROUND_BEEF\")\n                 .build())\n             .build())\n-        .addType(new TypeSpec.Builder()\n+        .addType(TypeSpec.classBuilder(chips.simpleName())\n             .addModifiers(Modifier.STATIC)\n-            .name(chips.simpleName())\n             .addField(FieldSpec.of(topping, \"topping\"))\n             .addField(FieldSpec.of(sauce, \"dippingSauce\"))\n             .build())\n-        .addType(new TypeSpec.Builder()\n-            .enumType()\n-            .name(sauce.simpleName())\n+        .addType(TypeSpec.enumBuilder(sauce.simpleName())\n             .addEnumConstant(\"SOUR_CREAM\")\n             .addEnumConstant(\"SALSA\")\n             .addEnumConstant(\"QUESO\")\n@@ -696,20 +617,17 @@ public final class TypeSpecTest {\n         ClassName.create(donutsPackage, \"Top\"), \"externalTop\");\n     FieldSpec externalBottom = FieldSpec.of(\n         ClassName.create(donutsPackage, \"Bottom\"), \"externalBottom\");\n-    TypeSpec top = new TypeSpec.Builder()\n-        .name(\"Top\")\n+    TypeSpec top = TypeSpec.classBuilder(\"Top\")\n         .addField(internalTop)\n         .addField(internalBottom)\n         .addField(externalTop)\n         .addField(externalBottom)\n-        .addType(new TypeSpec.Builder()\n-            .name(\"Middle\")\n+        .addType(TypeSpec.classBuilder(\"Middle\")\n             .addField(internalTop)\n             .addField(internalBottom)\n             .addField(externalTop)\n             .addField(externalBottom)\n-            .addType(new TypeSpec.Builder()\n-                .name(\"Bottom\")\n+            .addType(TypeSpec.classBuilder(\"Bottom\")\n                 .addField(internalTop)\n                 .addField(internalBottom)\n                 .addField(externalTop)\n@@ -756,11 +674,9 @@ public final class TypeSpecTest {\n   @Test public void originatingElementsIncludesThoseOfNestedTypes() {\n     Element outerElement = Mockito.mock(Element.class);\n     Element innerElement = Mockito.mock(Element.class);\n-    TypeSpec outer = new TypeSpec.Builder()\n-        .name(\"Outer\")\n+    TypeSpec outer = TypeSpec.classBuilder(\"Outer\")\n         .addOriginatingElement(outerElement)\n-        .addType(new TypeSpec.Builder()\n-            .name(\"Inner\")\n+        .addType(TypeSpec.classBuilder(\"Inner\")\n             .addOriginatingElement(innerElement)\n             .build())\n         .build();\n@@ -769,12 +685,10 @@ public final class TypeSpecTest {\n \n   @Test public void intersectionType() {\n     TypeVariable<?> typeVariable = Types.typeVariable(\"T\", Comparator.class, Serializable.class);\n-    TypeSpec taco = new TypeSpec.Builder()\n-        .name(\"Taco\")\n-        .addMethod(new MethodSpec.Builder()\n+    TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n+        .addMethod(MethodSpec.methodBuilder(\"getComparator\")\n             .addTypeVariable(typeVariable)\n             .returns(typeVariable)\n-            .name(\"getComparator\")\n             .addCode(\"return null;\\n\")\n             .build())\n         .build();\n@@ -792,8 +706,7 @@ public final class TypeSpecTest {\n   }\n \n   @Test public void arrayType() {\n-    TypeSpec taco = new TypeSpec.Builder()\n-        .name(\"Taco\")\n+    TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n         .addField(FieldSpec.of(int[].class, \"ints\"))\n         .build();\n     assertThat(toString(taco)).isEqualTo(\"\"\n"
    },
    {
        "commit_hash": "51191c915067521b6d5b888c25324f378747a1a2",
        "previous_commit_hash": "dd567a4a06f943f5f6f74d211758e56e52a8498e",
        "diff_stats": {
            "additions": 46,
            "deletions": 9
        },
        "diff_content": "@@ -49,6 +49,7 @@ final class CodeWriter {\n   private final StringBuilder out;\n   private int indentLevel;\n \n+  private boolean javadoc = false;\n   private String packageName;\n   private final List<TypeSpec> typeSpecStack = new ArrayList<>();\n   private final ImmutableMap<ClassName, String> importedTypes;\n@@ -108,6 +109,21 @@ final class CodeWriter {\n     return this;\n   }\n \n+  public void emitJavadoc(ImmutableList<Snippet> javadocSnippets) {\n+    if (javadocSnippets.isEmpty()) return;\n+\n+    emit(\"/**\\n\");\n+    javadoc = true;\n+    try {\n+      for (Snippet snippet : javadocSnippets) {\n+        emit(snippet);\n+      }\n+    } finally {\n+      javadoc = false;\n+    }\n+    emit(\" */\\n\");\n+  }\n+\n   public void emitAnnotations(ImmutableList<AnnotationSpec> annotations, boolean inline) {\n     for (AnnotationSpec annotationSpec : annotations) {\n       annotationSpec.emit(this, inline);\n@@ -283,7 +299,7 @@ final class CodeWriter {\n \n       String importedName = importedTypes.get(className);\n       if (importedName != null) {\n-        importableTypes.add(className);\n+        if (!javadoc) importableTypes.add(className);\n         return importedName;\n       }\n \n@@ -294,7 +310,7 @@ final class CodeWriter {\n       }\n \n       // Fall back to the fully-qualified name. Mark the type as importable for a future pass.\n-      importableTypes.add(className);\n+      if (!javadoc) importableTypes.add(className);\n       return className.toString();\n     }\n \n@@ -338,27 +354,48 @@ final class CodeWriter {\n     return size;\n   }\n \n-  /** Emits {@code s} with indentation as required. */\n+  /**\n+   * Emits {@code s} with indentation as required. It's important that all code that writes to\n+   * {@link #out} does it through here, since we emit indentation lazily in order to avoid\n+   * unnecessary trailing whitespace.\n+   */\n   private void emitAndIndent(String s) {\n     boolean first = true;\n     for (String line : s.split(\"\\n\", -1)) {\n-      if (!first) out.append('\\n');\n+      // Emit a newline character. Make sure blank lines in Javadoc look good.\n+      if (!first) {\n+        if (javadoc && trailingNewline()) {\n+          emitIndentation();\n+          out.append(\" *\");\n+        }\n+        out.append('\\n');\n+      }\n+\n       first = false;\n       if (line.isEmpty()) continue; // Don't indent empty lines.\n-      emitIndentationIfNecessary();\n+\n+      // Emit indentation if necessary.\n+      if (trailingNewline()) {\n+        emitIndentation();\n+        if (javadoc) {\n+          out.append(\" * \");\n+        }\n+      }\n+\n       out.append(line);\n     }\n   }\n \n-  private void emitIndentationIfNecessary() {\n-    // Only emit indentation immediately after a '\\n' character.\n-    if (out.length() <= 0 || out.charAt(out.length() - 1) != '\\n') return;\n-\n+  private void emitIndentation() {\n     for (int j = 0; j < indentLevel; j++) {\n       out.append(indent);\n     }\n   }\n \n+  private boolean trailingNewline() {\n+    return out.length() > 0 && out.charAt(out.length() - 1) == '\\n';\n+  }\n+\n   private Type toType(Object arg) {\n     if (arg instanceof Type) return (Type) arg;\n     throw new IllegalArgumentException(\"Expected type but was \" + arg);\n"
    },
    {
        "commit_hash": "51191c915067521b6d5b888c25324f378747a1a2",
        "previous_commit_hash": "dd567a4a06f943f5f6f74d211758e56e52a8498e",
        "diff_stats": {
            "additions": 19,
            "deletions": 15
        },
        "diff_content": "@@ -27,17 +27,19 @@ import static com.google.common.base.Preconditions.checkNotNull;\n \n /** A generated field declaration. */\n public final class FieldSpec {\n+  public final Type type;\n   public final Name name;\n+  public final ImmutableList<Snippet> javadocSnippets;\n   public final ImmutableList<AnnotationSpec> annotations;\n   public final ImmutableSet<Modifier> modifiers;\n-  public final Type type;\n   public final Snippet initializer;\n \n   private FieldSpec(Builder builder) {\n+    this.type = checkNotNull(builder.type);\n     this.name = checkNotNull(builder.name);\n+    this.javadocSnippets = ImmutableList.copyOf(builder.javadocSnippets);\n     this.annotations = ImmutableList.copyOf(builder.annotations);\n     this.modifiers = ImmutableSet.copyOf(builder.modifiers);\n-    this.type = checkNotNull(builder.type);\n     this.initializer = builder.initializer;\n   }\n \n@@ -46,6 +48,7 @@ public final class FieldSpec {\n   }\n \n   void emit(CodeWriter codeWriter, ImmutableSet<Modifier> implicitModifiers) {\n+    codeWriter.emitJavadoc(javadocSnippets);\n     codeWriter.emitAnnotations(annotations, false);\n     codeWriter.emitModifiers(modifiers, implicitModifiers);\n     codeWriter.emit(\"$T $L\", type, name);\n@@ -56,33 +59,39 @@ public final class FieldSpec {\n     codeWriter.emit(\";\\n\");\n   }\n \n-  public static Builder builder(String name) {\n-    return builder(new Name(name));\n+  public static Builder builder(Type type, String name) {\n+    return builder(type, new Name(name));\n   }\n \n-  public static Builder builder(Name name) {\n-    return new Builder(name);\n+  public static Builder builder(Type type, Name name) {\n+    return new Builder(type, name);\n   }\n \n   public static FieldSpec of(Type type, String name, Modifier... modifiers) {\n-    return new Builder(new Name(name))\n-        .type(type)\n+    return builder(type, new Name(name))\n         .addModifiers(modifiers)\n         .build();\n   }\n \n   public static final class Builder {\n+    private final Type type;\n     private final Name name;\n \n+    private final List<Snippet> javadocSnippets = new ArrayList<>();\n     private final List<AnnotationSpec> annotations = new ArrayList<>();\n     private final List<Modifier> modifiers = new ArrayList<>();\n-    private Type type;\n     private Snippet initializer;\n \n-    private Builder(Name name) {\n+    private Builder(Type type, Name name) {\n+      this.type = type;\n       this.name = name;\n     }\n \n+    public Builder addJavadoc(String format, Object... args) {\n+      javadocSnippets.add(new Snippet(format, args));\n+      return this;\n+    }\n+\n     public Builder addAnnotation(AnnotationSpec annotationSpec) {\n       this.annotations.add(annotationSpec);\n       return this;\n@@ -98,11 +107,6 @@ public final class FieldSpec {\n       return this;\n     }\n \n-    public Builder type(Type type) {\n-      this.type = type;\n-      return this;\n-    }\n-\n     public Builder initializer(String format, Object... args) {\n       this.initializer = new Snippet(format, args);\n       return this;\n"
    },
    {
        "commit_hash": "51191c915067521b6d5b888c25324f378747a1a2",
        "previous_commit_hash": "dd567a4a06f943f5f6f74d211758e56e52a8498e",
        "diff_stats": {
            "additions": 9,
            "deletions": 0
        },
        "diff_content": "@@ -31,6 +31,7 @@ import static com.google.common.base.Preconditions.checkState;\n /** A generated constructor or method declaration. */\n public final class MethodSpec {\n   public final Name name;\n+  public final ImmutableList<Snippet> javadocSnippets;\n   public final ImmutableList<AnnotationSpec> annotations;\n   public final ImmutableSet<Modifier> modifiers;\n   public final ImmutableList<TypeVariable<?>> typeVariables;\n@@ -44,6 +45,7 @@ public final class MethodSpec {\n         \"abstract method %s cannot have code\", builder.name);\n \n     this.name = checkNotNull(builder.name);\n+    this.javadocSnippets = ImmutableList.copyOf(builder.javadocSnippets);\n     this.annotations = ImmutableList.copyOf(builder.annotations);\n     this.modifiers = ImmutableSet.copyOf(builder.modifiers);\n     this.typeVariables = ImmutableList.copyOf(builder.typeVariables);\n@@ -54,6 +56,7 @@ public final class MethodSpec {\n   }\n \n   void emit(CodeWriter codeWriter, String enclosingName, ImmutableSet<Modifier> implicitModifiers) {\n+    codeWriter.emitJavadoc(javadocSnippets);\n     codeWriter.emitAnnotations(annotations, false);\n     codeWriter.emitModifiers(modifiers, implicitModifiers);\n \n@@ -120,6 +123,7 @@ public final class MethodSpec {\n   public static final class Builder {\n     private final Name name;\n \n+    private final List<Snippet> javadocSnippets = new ArrayList<>();\n     private final List<AnnotationSpec> annotations = new ArrayList<>();\n     private final List<Modifier> modifiers = new ArrayList<>();\n     private List<TypeVariable<?>> typeVariables = new ArrayList<>();\n@@ -133,6 +137,11 @@ public final class MethodSpec {\n       this.returnType = name == Name.CONSTRUCTOR ? null : void.class;\n     }\n \n+    public Builder addJavadoc(String format, Object... args) {\n+      javadocSnippets.add(new Snippet(format, args));\n+      return this;\n+    }\n+\n     public Builder addAnnotation(AnnotationSpec annotationSpec) {\n       this.annotations.add(annotationSpec);\n       return this;\n"
    },
    {
        "commit_hash": "51191c915067521b6d5b888c25324f378747a1a2",
        "previous_commit_hash": "dd567a4a06f943f5f6f74d211758e56e52a8498e",
        "diff_stats": {
            "additions": 15,
            "deletions": 3
        },
        "diff_content": "@@ -40,6 +40,7 @@ public final class TypeSpec {\n   public final DeclarationType declarationType;\n   public final String name;\n   public final Snippet anonymousTypeArguments;\n+  public final ImmutableList<Snippet> javadocSnippets;\n   public final ImmutableList<AnnotationSpec> annotations;\n   public final ImmutableSet<Modifier> modifiers;\n   public final ImmutableList<TypeVariable<?>> typeVariables;\n@@ -82,6 +83,7 @@ public final class TypeSpec {\n     this.declarationType = checkNotNull(builder.declarationType);\n     this.name = builder.name;\n     this.anonymousTypeArguments = builder.anonymousTypeArguments;\n+    this.javadocSnippets = ImmutableList.copyOf(builder.javadocSnippets);\n     this.annotations = ImmutableList.copyOf(builder.annotations);\n     this.modifiers = ImmutableSet.copyOf(builder.modifiers);\n     this.typeVariables = ImmutableList.copyOf(builder.typeVariables);\n@@ -137,6 +139,7 @@ public final class TypeSpec {\n       codeWriter.emit(anonymousTypeArguments);\n       codeWriter.emit(\") {\\n\");\n     } else {\n+      codeWriter.emitJavadoc(javadocSnippets);\n       codeWriter.emitAnnotations(annotations, false);\n       codeWriter.emitModifiers(modifiers);\n       codeWriter.emit(\"$L $L\", Ascii.toLowerCase(declarationType.name()), name);\n@@ -239,6 +242,7 @@ public final class TypeSpec {\n     private final String name;\n     private final Snippet anonymousTypeArguments;\n \n+    private final List<Snippet> javadocSnippets = new ArrayList<>();\n     private final List<AnnotationSpec> annotations = new ArrayList<>();\n     private final List<Modifier> modifiers = new ArrayList<>();\n     private final List<TypeVariable<?>> typeVariables = new ArrayList<>();\n@@ -257,22 +261,30 @@ public final class TypeSpec {\n       this.anonymousTypeArguments = anonymousTypeArguments;\n     }\n \n+    public Builder addJavadoc(String format, Object... args) {\n+      checkState(anonymousTypeArguments == null);\n+      javadocSnippets.add(new Snippet(format, args));\n+      return this;\n+    }\n+\n     public Builder addAnnotation(AnnotationSpec annotationSpec) {\n+      checkState(anonymousTypeArguments == null);\n       this.annotations.add(annotationSpec);\n       return this;\n     }\n \n     public Builder addAnnotation(Type annotation) {\n-      this.annotations.add(AnnotationSpec.of(annotation));\n-      return this;\n+      return addAnnotation(AnnotationSpec.of(annotation));\n     }\n \n     public Builder addModifiers(Modifier... modifiers) {\n+      checkState(anonymousTypeArguments == null);\n       Collections.addAll(this.modifiers, modifiers);\n       return this;\n     }\n \n     public Builder addTypeVariable(TypeVariable<?> typeVariable) {\n+      checkState(anonymousTypeArguments == null);\n       typeVariables.add(typeVariable);\n       return this;\n     }\n@@ -288,11 +300,11 @@ public final class TypeSpec {\n     }\n \n     public Builder addEnumConstant(String name) {\n-      checkState(declarationType == DeclarationType.ENUM);\n       return addEnumConstant(name, anonymousClassBuilder(\"\").build());\n     }\n \n     public Builder addEnumConstant(String name, TypeSpec typeSpec) {\n+      checkState(declarationType == DeclarationType.ENUM);\n       checkArgument(typeSpec.anonymousTypeArguments != null,\n           \"enum constants must have anonymous type arguments\");\n       enumConstants.put(name, typeSpec);\n"
    },
    {
        "commit_hash": "51191c915067521b6d5b888c25324f378747a1a2",
        "previous_commit_hash": "dd567a4a06f943f5f6f74d211758e56e52a8498e",
        "diff_stats": {
            "additions": 3,
            "deletions": 9
        },
        "diff_content": "@@ -39,9 +39,7 @@ public final class JavaFileTest {\n     String source = new JavaFile.Builder()\n         .packageName(\"com.squareup.tacos\")\n         .typeSpec(TypeSpec.classBuilder(\"Taco\")\n-            .addField(FieldSpec.builder(\"madeFreshDate\")\n-                .type(Date.class)\n-                .build())\n+            .addField(FieldSpec.of(Date.class, \"madeFreshDate\"))\n             .build())\n         .build()\n         .toString();\n@@ -59,12 +57,8 @@ public final class JavaFileTest {\n     String source = new JavaFile.Builder()\n         .packageName(\"com.squareup.tacos\")\n         .typeSpec(TypeSpec.classBuilder(\"Taco\")\n-            .addField(FieldSpec.builder(\"madeFreshDate\")\n-                .type(Date.class)\n-                .build())\n-            .addField(FieldSpec.builder(\"madeFreshDatabaseDate\")\n-                .type(java.sql.Date.class)\n-                .build())\n+            .addField(FieldSpec.of(Date.class, \"madeFreshDate\"))\n+            .addField(FieldSpec.of(java.sql.Date.class, \"madeFreshDatabaseDate\"))\n             .build())\n         .build()\n         .toString();\n"
    },
    {
        "commit_hash": "51191c915067521b6d5b888c25324f378747a1a2",
        "previous_commit_hash": "dd567a4a06f943f5f6f74d211758e56e52a8498e",
        "diff_stats": {
            "additions": 58,
            "deletions": 26
        },
        "diff_content": "@@ -23,6 +23,8 @@ import java.lang.reflect.TypeVariable;\n import java.util.AbstractSet;\n import java.util.Comparator;\n import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n import javax.lang.model.element.Element;\n import javax.lang.model.element.Modifier;\n import org.junit.Test;\n@@ -59,18 +61,16 @@ public final class TypeSpecTest {\n   }\n \n   @Test public void interestingTypes() throws Exception {\n+    ParameterizedType listOfAny = Types.parameterizedType(\n+        List.class, Types.subtypeOf(Object.class));\n+    ParameterizedType listOfExtends = Types.parameterizedType(\n+        List.class, Types.subtypeOf(Serializable.class));\n+    ParameterizedType listOfSuper = Types.parameterizedType(\n+        List.class, Types.supertypeOf(String.class));\n     TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n-        .addField(FieldSpec.builder(\"extendsObject\")\n-            .type(Types.parameterizedType(List.class, Types.subtypeOf(Object.class)))\n-            .build())\n-        .addField(FieldSpec.builder(\"extendsSerializable\")\n-            .type(Types.parameterizedType(ClassName.fromClass(List.class),\n-                Types.subtypeOf(Serializable.class)))\n-            .build())\n-        .addField(FieldSpec.builder(\"superString\")\n-            .type(Types.parameterizedType(ClassName.fromClass(List.class),\n-                Types.supertypeOf(String.class)))\n-            .build())\n+        .addField(FieldSpec.of(listOfAny, \"extendsObject\"))\n+        .addField(FieldSpec.of(listOfExtends, \"extendsSerializable\"))\n+        .addField(FieldSpec.of(listOfSuper, \"superString\"))\n         .build();\n     assertThat(toString(taco)).isEqualTo(\"\"\n         + \"package com.squareup.tacos;\\n\"\n@@ -126,9 +126,8 @@ public final class TypeSpecTest {\n             .build())\n         .build();\n     TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n-        .addField(FieldSpec.builder(\"NAME\")\n+        .addField(FieldSpec.builder(thingThangOfFooBar, \"NAME\")\n             .addModifiers(Modifier.STATIC, Modifier.FINAL, Modifier.FINAL)\n-            .type(thingThangOfFooBar)\n             .initializer(\"$L\", aThingThang)\n             .build())\n         .build();\n@@ -250,12 +249,11 @@ public final class TypeSpecTest {\n \n   @Test public void annotatedField() throws Exception {\n     TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n-        .addField(FieldSpec.builder(\"thing\")\n+        .addField(FieldSpec.builder(String.class, \"thing\")\n             .addAnnotation(AnnotationSpec.builder(ClassName.create(tacosPackage, \"JsonAdapter\"))\n                 .addMember(\"value\", \"$T.class\", ClassName.create(tacosPackage, \"Foo\"))\n                 .build())\n             .addModifiers(Modifier.PRIVATE, Modifier.FINAL)\n-            .type(String.class)\n             .build())\n         .build();\n     assertThat(toString(taco)).isEqualTo(\"\"\n@@ -305,9 +303,8 @@ public final class TypeSpecTest {\n             .build())\n         .addEnumConstant(\"SCISSORS\", TypeSpec.anonymousClassBuilder(\"$S\", \"peace sign\")\n             .build())\n-        .addField(FieldSpec.builder(\"handPosition\")\n+        .addField(FieldSpec.builder(String.class, \"handPosition\")\n             .addModifiers(Modifier.PRIVATE, Modifier.FINAL)\n-            .type(String.class)\n             .build())\n         .addMethod(MethodSpec.constructorBuilder()\n             .addParameter(String.class, \"handPosition\")\n@@ -425,15 +422,9 @@ public final class TypeSpecTest {\n         .addTypeVariable(t)\n         .addTypeVariable(p)\n         .addSuperinterface(Types.parameterizedType(ClassName.fromClass(Comparable.class), p))\n-        .addField(FieldSpec.builder(\"label\")\n-            .type(t)\n-            .build())\n-        .addField(FieldSpec.builder(\"x\")\n-            .type(p)\n-            .build())\n-        .addField(FieldSpec.builder(\"y\")\n-            .type(p)\n-            .build())\n+        .addField(FieldSpec.of(t, \"label\"))\n+        .addField(FieldSpec.of(p, \"x\"))\n+        .addField(FieldSpec.of(p, \"y\"))\n         .addMethod(MethodSpec.methodBuilder(\"compareTo\")\n             .addAnnotation(Override.class)\n             .addModifiers(Modifier.PUBLIC)\n@@ -717,6 +708,47 @@ public final class TypeSpecTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void javadoc() {\n+    TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n+        .addJavadoc(\"A hard or soft tortilla, loosely folded and filled with whatever {@link \\n\")\n+        .addJavadoc(\"{@link $T random} tex-mex stuff we could find in the pantry.\\n\", Random.class)\n+        .addField(FieldSpec.builder(boolean.class, \"soft\")\n+            .addJavadoc(\"True for a soft flour tortilla; false for a crunchy corn tortilla.\\n\")\n+            .build())\n+        .addMethod(MethodSpec.methodBuilder(\"refold\")\n+            .addJavadoc(\"Folds the back of this taco to reduce sauce leakage.\\n\"\n+                + \"\\n\"\n+                + \"<p>For {@link $T#KOREAN}, the front may also be folded.\\n\", Locale.class)\n+            .addParameter(Locale.class, \"locale\")\n+            .build())\n+        .build();\n+    // Mentioning a type in Javadoc will not cause an import to be added (java.util.Random here),\n+    // but the short name will be used if it's already imported (java.util.Locale here).\n+    assertThat(toString(taco)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import java.util.Locale;\\n\"\n+        + \"\\n\"\n+        + \"/**\\n\"\n+        + \" * A hard or soft tortilla, loosely folded and filled with whatever {@link \\n\"\n+        + \" * {@link java.util.Random random} tex-mex stuff we could find in the pantry.\\n\"\n+        + \" */\\n\"\n+        + \"class Taco {\\n\"\n+        + \"  /**\\n\"\n+        + \"   * True for a soft flour tortilla; false for a crunchy corn tortilla.\\n\"\n+        + \"   */\\n\"\n+        + \"  boolean soft;\\n\"\n+        + \"\\n\"\n+        + \"  /**\\n\"\n+        + \"   * Folds the back of this taco to reduce sauce leakage.\\n\"\n+        + \"   *\\n\"\n+        + \"   * <p>For {@link Locale#KOREAN}, the front may also be folded.\\n\"\n+        + \"   */\\n\"\n+        + \"  void refold(Locale locale) {\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n   private String toString(TypeSpec typeSpec) {\n     return new JavaFile.Builder()\n         .packageName(tacosPackage)\n"
    },
    {
        "commit_hash": "d5dd1fdc509fe4bb87d5670e3f2e25f5cd15147f",
        "previous_commit_hash": "02b9a9f7e65cfaa7b4d3bd07f5b73ffff3c6d7a0",
        "diff_stats": {
            "additions": 2,
            "deletions": 0
        },
        "diff_content": "@@ -21,6 +21,8 @@ elif [ \"$TRAVIS_BRANCH\" != \"$BRANCH\" ]; then\n   echo \"Skipping snapshot deployment: wrong branch. Expected '$BRANCH' but was '$TRAVIS_BRANCH'.\"\n else\n   echo \"Deploying snapshot...\"\n+  # make sure we use the appropriate JDK (it might have been changed during the build)\n+  jdk_switcher use $JDK\n   mvn clean source:jar javadoc:jar deploy --settings=\".buildscript/settings.xml\" -Dmaven.test.skip=true\n   echo \"Snapshot deployed!\"\n fi\n"
    },
    {
        "commit_hash": "d5dd1fdc509fe4bb87d5670e3f2e25f5cd15147f",
        "previous_commit_hash": "02b9a9f7e65cfaa7b4d3bd07f5b73ffff3c6d7a0",
        "diff_stats": {
            "additions": 4,
            "deletions": 0
        },
        "diff_content": "@@ -3,6 +3,10 @@ language: java\n jdk:\n   - oraclejdk8\n \n+script:\n+  - mvn test -B\n+  - jdk_switcher use openjdk7 && mvn surefire:test -B\n+\n after_success:\n   - .buildscript/deploy_snapshot.sh\n \n"
    },
    {
        "commit_hash": "4b10b20e3d54151c28fd6b2d99629f9239d9a4c6",
        "previous_commit_hash": "02b9a9f7e65cfaa7b4d3bd07f5b73ffff3c6d7a0",
        "diff_stats": {
            "additions": 94,
            "deletions": 131
        },
        "diff_content": "@@ -18,15 +18,16 @@ package com.squareup.javawriter;\n import com.google.common.base.Ascii;\n import com.google.common.base.Joiner;\n import com.google.common.base.Objects;\n-import com.google.common.base.Optional;\n import com.google.common.base.Splitter;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n import java.lang.reflect.Type;\n+import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n+import java.util.Map;\n import javax.lang.model.SourceVersion;\n import javax.lang.model.element.Element;\n import javax.lang.model.element.ElementKind;\n@@ -39,90 +40,48 @@ import static com.google.common.base.Preconditions.checkNotNull;\n import static javax.lang.model.element.NestingKind.MEMBER;\n import static javax.lang.model.element.NestingKind.TOP_LEVEL;\n \n-/**\n- * Represents a fully-qualified class name for {@link NestingKind#TOP_LEVEL} and\n- * {@link NestingKind#MEMBER} classes.\n- *\n- * @since 2.0\n- */\n+/** A fully-qualified class name for top-level and member classes. */\n public final class ClassName implements Type, Comparable<ClassName> {\n-  public static final ClassName OBJECT = ClassName.fromClass(Object.class);\n-\n-  private String fullyQualifiedName = null;\n-  private final String packageName;\n-  /* From top to bottom.  E.g.: this field will contain [\"A\", \"B\"] for pgk.A.B.C */\n-  private final ImmutableList<String> enclosingSimpleNames;\n-  private final String simpleName;\n-\n-  private ClassName(String packageName, ImmutableList<String> enclosingSimpleNames,\n-      String simpleName) {\n-    this.packageName = packageName;\n-    this.enclosingSimpleNames = enclosingSimpleNames;\n-    this.simpleName = simpleName;\n+  public static final ClassName OBJECT = ClassName.get(Object.class);\n+\n+  /** From top to bottom. This will be [\"java.util\", \"Map\", \"Entry\"] for {@link Map.Entry}. */\n+  final ImmutableList<String> names;\n+  final String canonicalName;\n+\n+  private ClassName(List<String> names) {\n+    for (int i = 1; i < names.size(); i++) {\n+      checkArgument(SourceVersion.isName(names.get(i)));\n+    }\n+    this.names = ImmutableList.copyOf(names);\n+    this.canonicalName = Joiner.on(\".\").join(names.get(0).isEmpty()\n+        ? names.subList(1, names.size())\n+        : names);\n   }\n \n+  /** Returns the package name, like {@code \"java.util\"} for {@code Map.Entry}. */\n   public String packageName() {\n-    return packageName;\n+    return names.get(0);\n   }\n \n-  public ImmutableList<String> enclosingSimpleNames() {\n-    return enclosingSimpleNames;\n+  /**\n+   * Returns the enclosing class, like {@link Map} for {@code Map.Entry}. Returns null if this class\n+   * is not nested in another class.\n+   */\n+  public ClassName enclosingClassName() {\n+    if (names.size() == 2) return null;\n+    return new ClassName(names.subList(0, names.size() - 1));\n   }\n \n   ImmutableList<String> simpleNames() {\n-    return new ImmutableList.Builder<String>()\n-        .addAll(enclosingSimpleNames)\n-        .add(simpleName)\n-        .build();\n-  }\n-\n-  public Optional<ClassName> enclosingClassName() {\n-    return enclosingSimpleNames.isEmpty()\n-        ? Optional.<ClassName>absent()\n-        : Optional.of(new ClassName(packageName,\n-            enclosingSimpleNames.subList(0, enclosingSimpleNames.size() - 1),\n-            enclosingSimpleNames.get(enclosingSimpleNames.size() - 1)));\n+    return names.subList(1, names.size());\n   }\n \n+  /** Returns the simple name of this class, like {@code \"Entry\"} for {@link Map.Entry}. */\n   public String simpleName() {\n-    return simpleName;\n+    return names.get(names.size() - 1);\n   }\n \n-  public String canonicalName() {\n-    if (fullyQualifiedName == null) {\n-      StringBuilder builder = new StringBuilder(packageName);\n-      if (builder.length() > 0) {\n-        builder.append('.');\n-      }\n-      for (String enclosingSimpleName : enclosingSimpleNames()) {\n-        builder.append(enclosingSimpleName).append('.');\n-      }\n-      fullyQualifiedName = builder.append(simpleName()).toString();\n-    }\n-    return fullyQualifiedName;\n-  }\n-\n-  private static final ImmutableSet<NestingKind> ACCEPTABLE_NESTING_KINDS =\n-      Sets.immutableEnumSet(TOP_LEVEL, MEMBER);\n-\n-  public static ClassName fromTypeElement(TypeElement element) {\n-    checkNotNull(element);\n-    checkArgument(ACCEPTABLE_NESTING_KINDS.contains(element.getNestingKind()));\n-    String simpleName = element.getSimpleName().toString();\n-    List<String> enclosingNames = Lists.newArrayList();\n-    Element current = element.getEnclosingElement();\n-    while (current.getKind().isClass() || current.getKind().isInterface()) {\n-      checkArgument(ACCEPTABLE_NESTING_KINDS.contains(element.getNestingKind()));\n-      enclosingNames.add(current.getSimpleName().toString());\n-      current = current.getEnclosingElement();\n-    }\n-    PackageElement packageElement = getPackage(current);\n-    Collections.reverse(enclosingNames);\n-    return new ClassName(packageElement.getQualifiedName().toString(),\n-        ImmutableList.copyOf(enclosingNames), simpleName);\n-  }\n-\n-  public static ClassName fromClass(Class<?> clazz) {\n+  public static ClassName get(Class<?> clazz) {\n     checkNotNull(clazz);\n     checkArgument(!clazz.isPrimitive(),\n         \"Primitive types cannot be represented as a ClassName. Use TypeNames.forClass instead.\");\n@@ -130,94 +89,98 @@ public final class ClassName implements Type, Comparable<ClassName> {\n         \"'void' type cannot be represented as a ClassName. Use TypeNames.forClass instead.\");\n     checkArgument(!clazz.isArray(),\n         \"Array types cannot be represented as a ClassName. Use TypeNames.forClass instead.\");\n-    List<String> enclosingNames = Lists.newArrayList();\n-    Class<?> current = clazz.getEnclosingClass();\n-    while (current != null) {\n-      enclosingNames.add(current.getSimpleName());\n-      current = current.getEnclosingClass();\n-    }\n-    Collections.reverse(enclosingNames);\n-    return create(clazz.getPackage().getName(), enclosingNames, clazz.getSimpleName());\n-  }\n-\n-  private static PackageElement getPackage(Element type) {\n-    while (type.getKind() != ElementKind.PACKAGE) {\n-      type = type.getEnclosingElement();\n+    List<String> names = Lists.newArrayList();\n+    for (Class<?> c = clazz; c != null; c = c.getEnclosingClass()) {\n+      names.add(c.getSimpleName());\n     }\n-    return (PackageElement) type;\n+    names.add(clazz.getPackage().getName());\n+    Collections.reverse(names);\n+    return new ClassName(names);\n   }\n \n   /**\n    * Returns a new {@link ClassName} instance for the given fully-qualified class name string. This\n-   * method assumes that the input is ASCII and follows typical Java style (lower-case package\n-   * names, upper-camel-case class names) and may produce incorrect results or throw\n-   * {@link IllegalArgumentException} otherwise. For that reason, {@link #fromClass(Class)} and\n-   * {@link #fromClass(Class)} should be preferred as they can correctly create {@link ClassName}\n+   * method assumes that the input is ASCII and follows typical Java style (lowercase package\n+   * names, UpperCamelCase class names) and may produce incorrect results or throw\n+   * {@link IllegalArgumentException} otherwise. For that reason, {@link #get(Class)} and\n+   * {@link #get(Class)} should be preferred as they can correctly create {@link ClassName}\n    * instances without such restrictions.\n    */\n-  public static ClassName bestGuessFromString(String classNameString) {\n-    checkNotNull(classNameString);\n-    List<String> parts = Splitter.on('.').splitToList(classNameString);\n-    int firstClassPartIndex = -1;\n-    for (int i = 0; i < parts.size(); i++) {\n-      String part = parts.get(i);\n+  public static ClassName bestGuess(String classNameString) {\n+    String packageName = \"\";\n+    List<String> simpleNames = new ArrayList<>();\n+\n+    for (String part : Splitter.on('.').split(classNameString)) {\n       checkArgument(SourceVersion.isIdentifier(part));\n       char firstChar = part.charAt(0);\n       if (Ascii.isLowerCase(firstChar)) {\n-        // looks like a package part\n-        if (firstClassPartIndex >= 0) {\n-          throw new IllegalArgumentException(\"couldn't make a guess for \" + classNameString);\n-        }\n+        checkArgument(simpleNames.isEmpty(), \"couldn't make a guess for %s\", classNameString);\n+        if (!packageName.isEmpty()) packageName += \".\";\n+        packageName += part;\n       } else if (Ascii.isUpperCase(firstChar)) {\n-        // looks like a class part\n-        if (firstClassPartIndex < 0) {\n-          firstClassPartIndex = i;\n-        }\n+        simpleNames.add(part);\n       } else {\n-        throw new IllegalArgumentException(\"couldn't make a guess for \" + classNameString);\n+        checkArgument(false, \"couldn't make a guess for %s\", classNameString);\n       }\n     }\n-    int lastIndex = parts.size() - 1;\n-    return new ClassName(\n-        Joiner.on('.').join(parts.subList(0, firstClassPartIndex)),\n-        firstClassPartIndex == lastIndex\n-            ? ImmutableList.<String>of()\n-            : ImmutableList.copyOf(parts.subList(firstClassPartIndex, lastIndex)),\n-        parts.get(lastIndex));\n+    checkArgument(!simpleNames.isEmpty(), \"couldn't make a guess for %s\", classNameString);\n+    simpleNames.add(0, packageName);\n+    return new ClassName(simpleNames);\n   }\n \n-  public static ClassName create(\n-      String packageName, List<String> enclosingSimpleNames, String simpleName) {\n-    return new ClassName(packageName, ImmutableList.copyOf(enclosingSimpleNames),\n-        simpleName);\n+  /**\n+   * Returns a class name created from the given parts. For example, calling this with package name\n+   * {@code \"java.util\"} and simple names {@code \"Map\"}, {@code \"Entry\"} yields {@link Map.Entry}.\n+   */\n+  public static ClassName get(String packageName, String simpleName, String... simpleNames) {\n+    return new ClassName(new ImmutableList.Builder<String>()\n+        .add(packageName)\n+        .add(simpleName)\n+        .add(simpleNames)\n+        .build());\n   }\n \n-  public static ClassName create(String packageName, String simpleName) {\n-    return new ClassName(packageName, ImmutableList.<String>of(), simpleName);\n+  private static final ImmutableSet<NestingKind> ACCEPTABLE_NESTING_KINDS =\n+      Sets.immutableEnumSet(TOP_LEVEL, MEMBER);\n+\n+  /** Returns the class name for {@code element}. */\n+  public static ClassName get(TypeElement element) {\n+    checkNotNull(element);\n+    List<String> names = Lists.newArrayList();\n+    for (Element e = element; isClassOrInterface(e); e = e.getEnclosingElement()) {\n+      checkArgument(ACCEPTABLE_NESTING_KINDS.contains(element.getNestingKind()));\n+      names.add(e.getSimpleName().toString());\n+    }\n+    names.add(getPackage(element).getQualifiedName().toString());\n+    Collections.reverse(names);\n+    return new ClassName(names);\n   }\n \n-  @Override public String toString() {\n-    return canonicalName();\n+  private static boolean isClassOrInterface(Element e) {\n+    return e.getKind().isClass() || e.getKind().isInterface();\n   }\n \n-  @Override public boolean equals(Object obj) {\n-    if (obj == this) {\n-      return true;\n-    } else if (obj instanceof ClassName) {\n-      ClassName that = (ClassName) obj;\n-      return this.packageName.equals(that.packageName)\n-          && this.enclosingSimpleNames.equals(that.enclosingSimpleNames)\n-          && this.simpleName.equals(that.simpleName);\n-    } else {\n-      return false;\n+  private static PackageElement getPackage(Element type) {\n+    while (type.getKind() != ElementKind.PACKAGE) {\n+      type = type.getEnclosingElement();\n     }\n+    return (PackageElement) type;\n+  }\n+\n+  @Override public boolean equals(Object o) {\n+    return o instanceof ClassName\n+        && canonicalName.equals(((ClassName) o).canonicalName);\n   }\n \n   @Override public int hashCode() {\n-    return Objects.hashCode(packageName, enclosingSimpleNames, simpleName);\n+    return Objects.hashCode(canonicalName);\n   }\n \n   @Override public int compareTo(ClassName o) {\n-    return canonicalName().compareTo(o.canonicalName());\n+    return canonicalName.compareTo(o.canonicalName);\n+  }\n+\n+  @Override public String toString() {\n+    return canonicalName;\n   }\n }\n"
    },
    {
        "commit_hash": "4b10b20e3d54151c28fd6b2d99629f9239d9a4c6",
        "previous_commit_hash": "02b9a9f7e65cfaa7b4d3bd07f5b73ffff3c6d7a0",
        "diff_stats": {
            "additions": 48,
            "deletions": 8
        },
        "diff_content": "@@ -28,6 +28,7 @@ import java.lang.reflect.TypeVariable;\n import java.lang.reflect.WildcardType;\n import java.util.ArrayList;\n import java.util.EnumSet;\n+import java.util.Formatter;\n import java.util.LinkedHashMap;\n import java.util.LinkedHashSet;\n import java.util.List;\n@@ -190,7 +191,7 @@ final class CodeWriter {\n \n         case \"$S\":\n           String arg = String.valueOf(snippet.args.get(a++));\n-          emitAndIndent(StringLiteral.forValue(arg).literal());\n+          emitAndIndent(stringLiteral(arg));\n           break;\n \n         case \"$T\":\n@@ -236,7 +237,7 @@ final class CodeWriter {\n       } else if (classType.isArray()) {\n         return emit(\"$T[]\", classType.getComponentType());\n       } else {\n-        return emitType(ClassName.fromClass(classType));\n+        return emitType(ClassName.get(classType));\n       }\n     }\n \n@@ -304,7 +305,7 @@ final class CodeWriter {\n       }\n \n       // If the target class wasn't imported, perhaps its enclosing class was. Try that.\n-      ClassName enclosingClassName = className.enclosingClassName().orNull();\n+      ClassName enclosingClassName = className.enclosingClassName();\n       if (enclosingClassName != null) {\n         return lookupName(enclosingClassName) + \".\" + className.simpleName();\n       }\n@@ -406,12 +407,11 @@ final class CodeWriter {\n   }\n \n   private String toName(Object o) {\n-    // TODO(jwilson): implement deferred naming so that `new Name(\"public\")` yields \"public_\" etc.\n     if (o instanceof String) return (String) o;\n-    if (o instanceof Name) return ((Name) o).seed;\n-    if (o instanceof ParameterSpec) return ((ParameterSpec) o).name.seed;\n-    if (o instanceof FieldSpec) return ((FieldSpec) o).name.seed;\n-    if (o instanceof MethodSpec) return ((MethodSpec) o).name.seed;\n+    if (o instanceof ParameterSpec) return ((ParameterSpec) o).name;\n+    if (o instanceof FieldSpec) return ((FieldSpec) o).name;\n+    if (o instanceof MethodSpec) return ((MethodSpec) o).name;\n+    if (o instanceof TypeSpec) return ((TypeSpec) o).name;\n     throw new IllegalArgumentException(\"Expected name but was \" + o);\n   }\n \n@@ -441,4 +441,44 @@ final class CodeWriter {\n \n     return typeToSimpleName.build();\n   }\n+\n+  /** Returns the string literal representing {@code data}, including wrapping quotes. */\n+  static String stringLiteral(String value) {\n+    StringBuilder result = new StringBuilder();\n+    result.append('\"');\n+    for (int i = 0; i < value.length(); i++) {\n+      char c = value.charAt(i);\n+      switch (c) {\n+        case '\"':\n+          result.append(\"\\\\\\\"\");\n+          break;\n+        case '\\\\':\n+          result.append(\"\\\\\\\\\");\n+          break;\n+        case '\\b':\n+          result.append(\"\\\\b\");\n+          break;\n+        case '\\t':\n+          result.append(\"\\\\t\");\n+          break;\n+        case '\\n':\n+          result.append(\"\\\\n\");\n+          break;\n+        case '\\f':\n+          result.append(\"\\\\f\");\n+          break;\n+        case '\\r':\n+          result.append(\"\\\\r\");\n+          break;\n+        default:\n+          if (Character.isISOControl(c)) {\n+            new Formatter(result).format(\"\\\\u%04x\", (int) c);\n+          } else {\n+            result.append(c);\n+          }\n+      }\n+    }\n+    result.append('\"');\n+    return result.toString();\n+  }\n }\n"
    },
    {
        "commit_hash": "4b10b20e3d54151c28fd6b2d99629f9239d9a4c6",
        "previous_commit_hash": "02b9a9f7e65cfaa7b4d3bd07f5b73ffff3c6d7a0",
        "diff_stats": {
            "additions": 10,
            "deletions": 12
        },
        "diff_content": "@@ -21,14 +21,16 @@ import java.lang.reflect.Type;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n+import javax.lang.model.SourceVersion;\n import javax.lang.model.element.Modifier;\n \n+import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkNotNull;\n \n /** A generated field declaration. */\n public final class FieldSpec {\n   public final Type type;\n-  public final Name name;\n+  public final String name;\n   public final ImmutableList<Snippet> javadocSnippets;\n   public final ImmutableList<AnnotationSpec> annotations;\n   public final ImmutableSet<Modifier> modifiers;\n@@ -59,30 +61,26 @@ public final class FieldSpec {\n     codeWriter.emit(\";\\n\");\n   }\n \n-  public static Builder builder(Type type, String name) {\n-    return builder(type, new Name(name));\n-  }\n-\n-  public static Builder builder(Type type, Name name) {\n-    return new Builder(type, name);\n+  public static Builder builder(Type type, String name, Modifier... modifiers) {\n+    return new Builder(type, name)\n+        .addModifiers(modifiers);\n   }\n \n   public static FieldSpec of(Type type, String name, Modifier... modifiers) {\n-    return builder(type, new Name(name))\n-        .addModifiers(modifiers)\n-        .build();\n+    return builder(type, name, modifiers).build();\n   }\n \n   public static final class Builder {\n     private final Type type;\n-    private final Name name;\n+    private final String name;\n \n     private final List<Snippet> javadocSnippets = new ArrayList<>();\n     private final List<AnnotationSpec> annotations = new ArrayList<>();\n     private final List<Modifier> modifiers = new ArrayList<>();\n     private Snippet initializer;\n \n-    private Builder(Type type, Name name) {\n+    private Builder(Type type, String name) {\n+      checkArgument(SourceVersion.isName(name), \"not a valid name: %s\", name);\n       this.type = type;\n       this.name = name;\n     }\n"
    },
    {
        "commit_hash": "4b10b20e3d54151c28fd6b2d99629f9239d9a4c6",
        "previous_commit_hash": "02b9a9f7e65cfaa7b4d3bd07f5b73ffff3c6d7a0",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -30,6 +30,7 @@ import javax.tools.JavaFileObject;\n \n import static com.google.common.base.Preconditions.checkArgument;\n \n+/** Writes generated types to a filesystem using the standard directory structure. */\n public final class JavaWriter {\n   private final List<JavaFile> javaFiles = new ArrayList<>();\n \n"
    },
    {
        "commit_hash": "4b10b20e3d54151c28fd6b2d99629f9239d9a4c6",
        "previous_commit_hash": "02b9a9f7e65cfaa7b4d3bd07f5b73ffff3c6d7a0",
        "diff_stats": {
            "additions": 14,
            "deletions": 13
        },
        "diff_content": "@@ -22,6 +22,7 @@ import java.lang.reflect.TypeVariable;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n+import javax.lang.model.SourceVersion;\n import javax.lang.model.element.Modifier;\n \n import static com.google.common.base.Preconditions.checkArgument;\n@@ -30,7 +31,9 @@ import static com.google.common.base.Preconditions.checkState;\n \n /** A generated constructor or method declaration. */\n public final class MethodSpec {\n-  public final Name name;\n+  static final String CONSTRUCTOR = \"<init>\";\n+\n+  public final String name;\n   public final ImmutableList<Snippet> javadocSnippets;\n   public final ImmutableList<AnnotationSpec> annotations;\n   public final ImmutableSet<Modifier> modifiers;\n@@ -65,7 +68,7 @@ public final class MethodSpec {\n       codeWriter.emit(\" \");\n     }\n \n-    if (name == Name.CONSTRUCTOR) {\n+    if (name.equals(CONSTRUCTOR)) {\n       codeWriter.emit(\"$L(\", enclosingName);\n     } else {\n       codeWriter.emit(\"$T $L(\", returnType, name);\n@@ -109,19 +112,15 @@ public final class MethodSpec {\n   }\n \n   public static Builder methodBuilder(String name) {\n-    return methodBuilder(new Name(name));\n-  }\n-\n-  public static Builder methodBuilder(Name name) {\n     return new Builder(name);\n   }\n \n   public static Builder constructorBuilder() {\n-    return new Builder(Name.CONSTRUCTOR);\n+    return new Builder(CONSTRUCTOR);\n   }\n \n   public static final class Builder {\n-    private final Name name;\n+    private final String name;\n \n     private final List<Snippet> javadocSnippets = new ArrayList<>();\n     private final List<AnnotationSpec> annotations = new ArrayList<>();\n@@ -132,9 +131,11 @@ public final class MethodSpec {\n     private final List<Type> exceptions = new ArrayList<>();\n     private final List<Snippet> snippets = new ArrayList<>();\n \n-    private Builder(Name name) {\n+    private Builder(String name) {\n+      checkArgument(name.equals(CONSTRUCTOR) || SourceVersion.isName(name),\n+          \"not a valid name: %s\", name);\n       this.name = name;\n-      this.returnType = name == Name.CONSTRUCTOR ? null : void.class;\n+      this.returnType = name.equals(CONSTRUCTOR) ? null : void.class;\n     }\n \n     public Builder addJavadoc(String format, Object... args) {\n@@ -163,7 +164,7 @@ public final class MethodSpec {\n     }\n \n     public Builder returns(Type returnType) {\n-      checkState(name != Name.CONSTRUCTOR);\n+      checkState(!name.equals(CONSTRUCTOR));\n       this.returnType = returnType;\n       return this;\n     }\n@@ -173,8 +174,8 @@ public final class MethodSpec {\n       return this;\n     }\n \n-    public Builder addParameter(Type type, String name) {\n-      return addParameter(ParameterSpec.builder(type, name).build());\n+    public Builder addParameter(Type type, String name, Modifier... modifiers) {\n+      return addParameter(ParameterSpec.of(type, name, modifiers));\n     }\n \n     public Builder addException(Type exception) {\n"
    },
    {
        "commit_hash": "4b10b20e3d54151c28fd6b2d99629f9239d9a4c6",
        "previous_commit_hash": "02b9a9f7e65cfaa7b4d3bd07f5b73ffff3c6d7a0",
        "diff_stats": {
            "additions": 0,
            "deletions": 37
        },
        "diff_content": "@@ -1,37 +0,0 @@\n-/*\n- * Copyright (C) 2015 Square, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.squareup.javawriter;\n-\n-import static com.google.common.base.Preconditions.checkNotNull;\n-\n-/**\n- * A member name. If necessary, the seed name will be mangled to cope with keyword collision and\n- * name collision. For example, given the seed name {@code public}, the generated code may use\n- * {@code public_} or {@code public1}.\n- */\n-public final class Name {\n-  static final Name CONSTRUCTOR = new Name(\"<init>\");\n-\n-  public final String seed;\n-\n-  public Name(String seed) {\n-    this.seed = checkNotNull(seed);\n-  }\n-\n-  @Override public String toString() {\n-    return seed;\n-  }\n-}\n"
    },
    {
        "commit_hash": "4b10b20e3d54151c28fd6b2d99629f9239d9a4c6",
        "previous_commit_hash": "02b9a9f7e65cfaa7b4d3bd07f5b73ffff3c6d7a0",
        "diff_stats": {
            "additions": 11,
            "deletions": 7
        },
        "diff_content": "@@ -21,13 +21,15 @@ import java.lang.reflect.Type;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n+import javax.lang.model.SourceVersion;\n import javax.lang.model.element.Modifier;\n \n+import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkNotNull;\n \n /** A generated parameter declaration. */\n public final class ParameterSpec {\n-  public final Name name;\n+  public final String name;\n   public final ImmutableList<AnnotationSpec> annotations;\n   public final ImmutableSet<Modifier> modifiers;\n   public final Type type;\n@@ -49,22 +51,24 @@ public final class ParameterSpec {\n     codeWriter.emit(\"$T $L\", type, name);\n   }\n \n-  public static Builder builder(Type type, String name) {\n-    return builder(type, new Name(name));\n+  public static Builder builder(Type type, String name, Modifier... modifiers) {\n+    return new Builder(type, name)\n+        .addModifiers(modifiers);\n   }\n \n-  public static Builder builder(Type type, Name name) {\n-    return new Builder(type, name);\n+  public static ParameterSpec of(Type type, String name, Modifier... modifiers) {\n+    return builder(type, name, modifiers).build();\n   }\n \n   public static final class Builder {\n     private final Type type;\n-    private final Name name;\n+    private final String name;\n \n     private final List<AnnotationSpec> annotations = new ArrayList<>();\n     private final List<Modifier> modifiers = new ArrayList<>();\n \n-    private Builder(Type type, Name name) {\n+    private Builder(Type type, String name) {\n+      checkArgument(SourceVersion.isName(name), \"not a valid name: %s\", name);\n       this.type = type;\n       this.name = name;\n     }\n"
    },
    {
        "commit_hash": "4b10b20e3d54151c28fd6b2d99629f9239d9a4c6",
        "previous_commit_hash": "02b9a9f7e65cfaa7b4d3bd07f5b73ffff3c6d7a0",
        "diff_stats": {
            "additions": 0,
            "deletions": 103
        },
        "diff_content": "@@ -1,103 +0,0 @@\n-/*\n- * Copyright (C) 2014 Square, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.squareup.javawriter;\n-\n-import java.util.Formatter;\n-\n-/**\n- * Represents a string literal as found in Java source code.\n- */\n-public final class StringLiteral {\n-  /** Returns a new {@link StringLiteral} instance for the intended value of the literal. */\n-  public static StringLiteral forValue(String value) {\n-    return new StringLiteral(value, stringLiteral(value));\n-  }\n-\n-  /** Returns the string literal representing {@code data}, including wrapping quotes. */\n-  private static String stringLiteral(String value) {\n-    StringBuilder result = new StringBuilder();\n-    result.append('\"');\n-    for (int i = 0; i < value.length(); i++) {\n-      char c = value.charAt(i);\n-      switch (c) {\n-        case '\"':\n-          result.append(\"\\\\\\\"\");\n-          break;\n-        case '\\\\':\n-          result.append(\"\\\\\\\\\");\n-          break;\n-        case '\\b':\n-          result.append(\"\\\\b\");\n-          break;\n-        case '\\t':\n-          result.append(\"\\\\t\");\n-          break;\n-        case '\\n':\n-          result.append(\"\\\\n\");\n-          break;\n-        case '\\f':\n-          result.append(\"\\\\f\");\n-          break;\n-        case '\\r':\n-          result.append(\"\\\\r\");\n-          break;\n-        default:\n-          if (Character.isISOControl(c)) {\n-            new Formatter(result).format(\"\\\\u%04x\", (int) c);\n-          } else {\n-            result.append(c);\n-          }\n-      }\n-    }\n-    result.append('\"');\n-    return result.toString();\n-  }\n-\n-  private final String value;\n-  private final String literal;\n-\n-  private StringLiteral(String value, String literal) {\n-    this.value = value;\n-    this.literal = literal;\n-  }\n-\n-  public String value() {\n-    return value;\n-  }\n-\n-  public String literal() {\n-    return literal;\n-  }\n-\n-  @Override public String toString() {\n-    return literal;\n-  }\n-\n-  @Override public boolean equals(Object obj) {\n-    if (obj == this) {\n-      return true;\n-    } else if (obj instanceof StringLiteral) {\n-      return this.value.equals(((StringLiteral) obj).value);\n-    } else {\n-      return false;\n-    }\n-  }\n-\n-  @Override\n-  public int hashCode() {\n-    return value.hashCode();\n-  }\n-}\n"
    },
    {
        "commit_hash": "4b10b20e3d54151c28fd6b2d99629f9239d9a4c6",
        "previous_commit_hash": "02b9a9f7e65cfaa7b4d3bd07f5b73ffff3c6d7a0",
        "diff_stats": {
            "additions": 7,
            "deletions": 0
        },
        "diff_content": "@@ -27,6 +27,7 @@ import java.util.Iterator;\n import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n+import javax.lang.model.SourceVersion;\n import javax.lang.model.element.Element;\n import javax.lang.model.element.Modifier;\n \n@@ -256,6 +257,7 @@ public final class TypeSpec {\n \n     private Builder(DeclarationType declarationType, String name,\n         Snippet anonymousTypeArguments) {\n+      checkArgument(name == null || SourceVersion.isName(name), \"not a valid name: %s\", name);\n       this.declarationType = declarationType;\n       this.name = name;\n       this.anonymousTypeArguments = anonymousTypeArguments;\n@@ -307,6 +309,7 @@ public final class TypeSpec {\n       checkState(declarationType == DeclarationType.ENUM);\n       checkArgument(typeSpec.anonymousTypeArguments != null,\n           \"enum constants must have anonymous type arguments\");\n+      checkArgument(SourceVersion.isName(name), \"not a valid enum constant: %s\", name);\n       enumConstants.put(name, typeSpec);\n       return this;\n     }\n@@ -316,6 +319,10 @@ public final class TypeSpec {\n       return this;\n     }\n \n+    public Builder addField(Type type, String name, Modifier... modifiers) {\n+      return addField(FieldSpec.of(type, name, modifiers));\n+    }\n+\n     public Builder addMethod(MethodSpec methodSpec) {\n       methodSpecs.add(methodSpec);\n       return this;\n"
    },
    {
        "commit_hash": "4b10b20e3d54151c28fd6b2d99629f9239d9a4c6",
        "previous_commit_hash": "02b9a9f7e65cfaa7b4d3bd07f5b73ffff3c6d7a0",
        "diff_stats": {
            "additions": 2,
            "deletions": 3
        },
        "diff_content": "@@ -258,9 +258,8 @@ public final class Types {\n \n   private static Type get(DeclaredType t) {\n     return t.getTypeArguments().isEmpty()\n-        ? ClassName.fromTypeElement((TypeElement) t.asElement())\n-        : parameterizedType(\n-            ClassName.fromTypeElement((TypeElement) t.asElement()),\n+        ? ClassName.get((TypeElement) t.asElement())\n+        : parameterizedType(ClassName.get((TypeElement) t.asElement()),\n             FluentIterable.from(t.getTypeArguments()).transform(FOR_TYPE_MIRROR));\n   }\n \n"
    },
    {
        "commit_hash": "4b10b20e3d54151c28fd6b2d99629f9239d9a4c6",
        "previous_commit_hash": "02b9a9f7e65cfaa7b4d3bd07f5b73ffff3c6d7a0",
        "diff_stats": {
            "additions": 29,
            "deletions": 29
        },
        "diff_content": "@@ -15,7 +15,6 @@\n  */\n package com.squareup.javawriter;\n \n-import com.google.common.collect.ImmutableList;\n import com.google.testing.compile.CompilationRule;\n import java.util.Map;\n import javax.lang.model.element.TypeElement;\n@@ -23,15 +22,15 @@ import javax.lang.model.util.Elements;\n import org.junit.Rule;\n import org.junit.Test;\n \n-import static com.google.common.truth.Truth.assert_;\n+import static com.google.common.truth.Truth.assertThat;\n import static org.junit.Assert.fail;\n \n public final class ClassNameTest {\n   @Rule public CompilationRule compilationRule = new CompilationRule();\n \n   @Test public void bestGuessForString_simpleClass() {\n-    assert_().that(ClassName.bestGuessFromString(String.class.getName()))\n-        .isEqualTo(ClassName.create(\"java.lang\", \"String\"));\n+    assertThat(ClassName.bestGuess(String.class.getName()))\n+        .isEqualTo(ClassName.get(\"java.lang\", \"String\"));\n   }\n \n   static class OuterClass {\n@@ -39,65 +38,66 @@ public final class ClassNameTest {\n   }\n \n   @Test public void bestGuessForString_nestedClass() {\n-    assert_().that(ClassName.bestGuessFromString(Map.Entry.class.getCanonicalName()))\n-        .isEqualTo(ClassName.create(\"java.util\", ImmutableList.of(\"Map\"), \"Entry\"));\n-    assert_().that(ClassName.bestGuessFromString(OuterClass.InnerClass.class.getCanonicalName()))\n-        .isEqualTo(\n-            ClassName.create(\"com.squareup.javawriter\",\n-                ImmutableList.of(\"ClassNameTest\", \"OuterClass\"), \"InnerClass\"));\n+    assertThat(ClassName.bestGuess(Map.Entry.class.getCanonicalName()))\n+        .isEqualTo(ClassName.get(\"java.util\", \"Map\", \"Entry\"));\n+    assertThat(ClassName.bestGuess(OuterClass.InnerClass.class.getCanonicalName()))\n+        .isEqualTo(ClassName.get(\"com.squareup.javawriter\",\n+            \"ClassNameTest\", \"OuterClass\", \"InnerClass\"));\n   }\n \n   @Test public void bestGuessForString_defaultPackage() {\n-    assert_().that(ClassName.bestGuessFromString(\"SomeClass\"))\n-        .isEqualTo(ClassName.create(\"\", \"SomeClass\"));\n-    assert_().that(ClassName.bestGuessFromString(\"SomeClass.Nested\"))\n-        .isEqualTo(ClassName.create(\"\", ImmutableList.of(\"SomeClass\"), \"Nested\"));\n-    assert_().that(ClassName.bestGuessFromString(\"SomeClass.Nested.EvenMore\"))\n-        .isEqualTo(ClassName.create(\"\", ImmutableList.of(\"SomeClass\", \"Nested\"), \"EvenMore\"));\n+    assertThat(ClassName.bestGuess(\"SomeClass\"))\n+        .isEqualTo(ClassName.get(\"\", \"SomeClass\"));\n+    assertThat(ClassName.bestGuess(\"SomeClass.Nested\"))\n+        .isEqualTo(ClassName.get(\"\", \"SomeClass\", \"Nested\"));\n+    assertThat(ClassName.bestGuess(\"SomeClass.Nested.EvenMore\"))\n+        .isEqualTo(ClassName.get(\"\", \"SomeClass\", \"Nested\", \"EvenMore\"));\n   }\n \n   @Test public void bestGuessForString_confusingInput() {\n     try {\n-      ClassName.bestGuessFromString(\"com.test.$\");\n+      ClassName.bestGuess(\"com.test.$\");\n       fail();\n-    } catch (IllegalArgumentException expected) {}\n+    } catch (IllegalArgumentException expected) {\n+    }\n     try {\n-      ClassName.bestGuessFromString(\"com.test.LooksLikeAClass.pkg\");\n+      ClassName.bestGuess(\"com.test.LooksLikeAClass.pkg\");\n       fail();\n-    } catch (IllegalArgumentException expected) {}\n+    } catch (IllegalArgumentException expected) {\n+    }\n     try {\n-      ClassName.bestGuessFromString(\"!@#$gibberish%^&*\");\n+      ClassName.bestGuess(\"!@#$gibberish%^&*\");\n       fail();\n-    } catch (IllegalArgumentException expected) {}\n+    } catch (IllegalArgumentException expected) {\n+    }\n   }\n \n   @Test public void classNameFromTypeElement() {\n     Elements elements = compilationRule.getElements();\n     TypeElement element = elements.getTypeElement(Object.class.getCanonicalName());\n-    assert_().that(ClassName.fromTypeElement(element).canonicalName())\n-        .isEqualTo(\"java.lang.Object\");\n+    assertThat(ClassName.get(element).toString()).isEqualTo(\"java.lang.Object\");\n   }\n   \n   @Test public void classNameFromClass() {\n-    assert_().that(ClassName.fromClass(Object.class).canonicalName())\n+    assertThat(ClassName.get(Object.class).toString())\n         .isEqualTo(\"java.lang.Object\");\n-    assert_().that(ClassName.fromClass(OuterClass.InnerClass.class).canonicalName())\n+    assertThat(ClassName.get(OuterClass.InnerClass.class).toString())\n         .isEqualTo(\"com.squareup.javawriter.ClassNameTest.OuterClass.InnerClass\");\n   }\n \n   @Test public void fromClassRejectionTypes() {\n     try {\n-      ClassName.fromClass(int.class);\n+      ClassName.get(int.class);\n       fail();\n     } catch (IllegalArgumentException ignored) {\n     }\n     try {\n-      ClassName.fromClass(void.class);\n+      ClassName.get(void.class);\n       fail();\n     } catch (IllegalArgumentException ignored) {\n     }\n     try {\n-      ClassName.fromClass(Object[].class);\n+      ClassName.get(Object[].class);\n       fail();\n     } catch (IllegalArgumentException ignored) {\n     }\n"
    },
    {
        "commit_hash": "4b10b20e3d54151c28fd6b2d99629f9239d9a4c6",
        "previous_commit_hash": "02b9a9f7e65cfaa7b4d3bd07f5b73ffff3c6d7a0",
        "diff_stats": {
            "additions": 45,
            "deletions": 55
        },
        "diff_content": "@@ -15,7 +15,6 @@\n  */\n package com.squareup.javawriter;\n \n-import com.google.common.collect.ImmutableList;\n import java.io.IOException;\n import java.io.Serializable;\n import java.lang.reflect.ParameterizedType;\n@@ -89,23 +88,20 @@ public final class TypeSpecTest {\n   }\n \n   @Test public void anonymousInnerClass() throws Exception {\n-    ClassName foo = ClassName.create(tacosPackage, \"Foo\");\n-    ClassName bar = ClassName.create(tacosPackage, \"Bar\");\n-    ClassName thingThang = ClassName.create(\n-        tacosPackage, ImmutableList.of(\"Thing\"), \"Thang\");\n+    ClassName foo = ClassName.get(tacosPackage, \"Foo\");\n+    ClassName bar = ClassName.get(tacosPackage, \"Bar\");\n+    ClassName thingThang = ClassName.get(tacosPackage, \"Thing\", \"Thang\");\n     ParameterizedType thingThangOfFooBar\n         = Types.parameterizedType(thingThang, foo, bar);\n-    ClassName thung = ClassName.create(tacosPackage, \"Thung\");\n-    ClassName simpleThung = ClassName.create(tacosPackage, \"SimpleThung\");\n+    ClassName thung = ClassName.get(tacosPackage, \"Thung\");\n+    ClassName simpleThung = ClassName.get(tacosPackage, \"SimpleThung\");\n     ParameterizedType thungOfSuperBar\n         = Types.parameterizedType(thung, Types.supertypeOf(bar));\n     ParameterizedType thungOfSuperFoo\n         = Types.parameterizedType(thung, Types.supertypeOf(foo));\n     ParameterizedType simpleThungOfBar = Types.parameterizedType(simpleThung, bar);\n \n-    ParameterSpec thungParameter = ParameterSpec.builder(thungOfSuperFoo, \"thung\")\n-        .addModifiers(Modifier.FINAL)\n-        .build();\n+    ParameterSpec thungParameter = ParameterSpec.of(thungOfSuperFoo, \"thung\", Modifier.FINAL);\n     TypeSpec aSimpleThung = TypeSpec.anonymousClassBuilder(\"$N\", thungParameter)\n         .superclass(simpleThungOfBar)\n         .addMethod(MethodSpec.methodBuilder(\"doSomething\")\n@@ -158,19 +154,18 @@ public final class TypeSpecTest {\n             .addModifiers(Modifier.PUBLIC)\n             .addParameter(long.class, \"id\")\n             .addParameter(ParameterSpec.builder(String.class, \"one\")\n-                .addAnnotation(ClassName.create(tacosPackage, \"Ping\"))\n+                .addAnnotation(ClassName.get(tacosPackage, \"Ping\"))\n                 .build())\n             .addParameter(ParameterSpec.builder(String.class, \"two\")\n-                .addAnnotation(ClassName.create(tacosPackage, \"Ping\"))\n+                .addAnnotation(ClassName.get(tacosPackage, \"Ping\"))\n                 .build())\n             .addParameter(ParameterSpec.builder(String.class, \"three\")\n-                .addAnnotation(\n-                    AnnotationSpec.builder(ClassName.create(tacosPackage, \"Pong\"))\n-                        .addMember(\"value\", \"$S\", \"pong\")\n-                        .build())\n+                .addAnnotation(AnnotationSpec.builder(ClassName.get(tacosPackage, \"Pong\"))\n+                    .addMember(\"value\", \"$S\", \"pong\")\n+                    .build())\n                 .build())\n             .addParameter(ParameterSpec.builder(String.class, \"four\")\n-                .addAnnotation(ClassName.create(tacosPackage, \"Ping\"))\n+                .addAnnotation(ClassName.get(tacosPackage, \"Ping\"))\n                 .build())\n             .addCode(\"/* code snippets */\\n\")\n             .build())\n@@ -190,17 +185,17 @@ public final class TypeSpecTest {\n   }\n \n   @Test public void retrofitStyleInterface() throws Exception {\n-    ClassName observable = ClassName.create(tacosPackage, \"Observable\");\n-    ClassName fooBar = ClassName.create(tacosPackage, \"FooBar\");\n-    ClassName thing = ClassName.create(tacosPackage, \"Thing\");\n-    ClassName things = ClassName.create(tacosPackage, \"Things\");\n-    ClassName map = ClassName.create(\"java.util\", \"Map\");\n-    ClassName string = ClassName.create(\"java.lang\", \"String\");\n-    ClassName headers = ClassName.create(tacosPackage, \"Headers\");\n-    ClassName post = ClassName.create(tacosPackage, \"POST\");\n-    ClassName body = ClassName.create(tacosPackage, \"Body\");\n-    ClassName queryMap = ClassName.create(tacosPackage, \"QueryMap\");\n-    ClassName header = ClassName.create(tacosPackage, \"Header\");\n+    ClassName observable = ClassName.get(tacosPackage, \"Observable\");\n+    ClassName fooBar = ClassName.get(tacosPackage, \"FooBar\");\n+    ClassName thing = ClassName.get(tacosPackage, \"Thing\");\n+    ClassName things = ClassName.get(tacosPackage, \"Things\");\n+    ClassName map = ClassName.get(\"java.util\", \"Map\");\n+    ClassName string = ClassName.get(\"java.lang\", \"String\");\n+    ClassName headers = ClassName.get(tacosPackage, \"Headers\");\n+    ClassName post = ClassName.get(tacosPackage, \"POST\");\n+    ClassName body = ClassName.get(tacosPackage, \"Body\");\n+    ClassName queryMap = ClassName.get(tacosPackage, \"QueryMap\");\n+    ClassName header = ClassName.get(tacosPackage, \"Header\");\n     TypeSpec service = TypeSpec.interfaceBuilder(\"Service\")\n         .addMethod(MethodSpec.methodBuilder(\"fooBar\")\n             .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)\n@@ -212,8 +207,7 @@ public final class TypeSpecTest {\n                 .addMember(\"value\", \"$S\", \"/foo/bar\")\n                 .build())\n             .returns(Types.parameterizedType(observable, fooBar))\n-            .addParameter(ParameterSpec.builder(Types.parameterizedType(things, thing),\n-                \"things\")\n+            .addParameter(ParameterSpec.builder(Types.parameterizedType(things, thing), \"things\")\n                 .addAnnotation(body)\n                 .build())\n             .addParameter(ParameterSpec.builder(\n@@ -249,11 +243,10 @@ public final class TypeSpecTest {\n \n   @Test public void annotatedField() throws Exception {\n     TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n-        .addField(FieldSpec.builder(String.class, \"thing\")\n-            .addAnnotation(AnnotationSpec.builder(ClassName.create(tacosPackage, \"JsonAdapter\"))\n-                .addMember(\"value\", \"$T.class\", ClassName.create(tacosPackage, \"Foo\"))\n+        .addField(FieldSpec.builder(String.class, \"thing\", Modifier.PRIVATE, Modifier.FINAL)\n+            .addAnnotation(AnnotationSpec.builder(ClassName.get(tacosPackage, \"JsonAdapter\"))\n+                .addMember(\"value\", \"$T.class\", ClassName.get(tacosPackage, \"Foo\"))\n                 .build())\n-            .addModifiers(Modifier.PRIVATE, Modifier.FINAL)\n             .build())\n         .build();\n     assertThat(toString(taco)).isEqualTo(\"\"\n@@ -268,9 +261,9 @@ public final class TypeSpecTest {\n   }\n \n   @Test public void annotatedClass() throws Exception {\n-    ClassName someType = ClassName.create(tacosPackage, \"SomeType\");\n+    ClassName someType = ClassName.get(tacosPackage, \"SomeType\");\n     TypeSpec taco = TypeSpec.classBuilder(\"Foo\")\n-        .addAnnotation(AnnotationSpec.builder(ClassName.create(tacosPackage, \"Something\"))\n+        .addAnnotation(AnnotationSpec.builder(ClassName.get(tacosPackage, \"Something\"))\n             .addMember(\"hi\", \"$T.$N\", someType, \"FIELD\")\n             .addMember(\"hey\", \"$L\", 12)\n             .addMember(\"hello\", \"$S\", \"goodbye\")\n@@ -303,9 +296,7 @@ public final class TypeSpecTest {\n             .build())\n         .addEnumConstant(\"SCISSORS\", TypeSpec.anonymousClassBuilder(\"$S\", \"peace sign\")\n             .build())\n-        .addField(FieldSpec.builder(String.class, \"handPosition\")\n-            .addModifiers(Modifier.PRIVATE, Modifier.FINAL)\n-            .build())\n+        .addField(FieldSpec.of(String.class, \"handPosition\", Modifier.PRIVATE, Modifier.FINAL))\n         .addMethod(MethodSpec.constructorBuilder()\n             .addParameter(String.class, \"handPosition\")\n             .addCode(\"this.handPosition = handPosition;\\n\")\n@@ -397,7 +388,7 @@ public final class TypeSpecTest {\n             .build())\n         .addMethod(MethodSpec.methodBuilder(\"throwTwo\")\n             .addException(IOException.class)\n-            .addException(ClassName.create(tacosPackage, \"SourCreamException\"))\n+            .addException(ClassName.get(tacosPackage, \"SourCreamException\"))\n             .build())\n         .build();\n     assertThat(toString(taco)).isEqualTo(\"\"\n@@ -417,11 +408,11 @@ public final class TypeSpecTest {\n   @Test public void typeVariables() throws Exception {\n     TypeVariable<?> t = Types.typeVariable(\"T\");\n     TypeVariable<?> p = Types.typeVariable(\"P\", Number.class);\n-    ClassName location = ClassName.create(tacosPackage, \"Location\");\n+    ClassName location = ClassName.get(tacosPackage, \"Location\");\n     TypeSpec typeSpec = TypeSpec.classBuilder(\"Location\")\n         .addTypeVariable(t)\n         .addTypeVariable(p)\n-        .addSuperinterface(Types.parameterizedType(ClassName.fromClass(Comparable.class), p))\n+        .addSuperinterface(Types.parameterizedType(ClassName.get(Comparable.class), p))\n         .addField(FieldSpec.of(t, \"label\"))\n         .addField(FieldSpec.of(p, \"x\"))\n         .addField(FieldSpec.of(p, \"y\"))\n@@ -470,8 +461,8 @@ public final class TypeSpecTest {\n   }\n \n   @Test public void classImplementsExtends() throws Exception {\n-    ClassName taco = ClassName.create(tacosPackage, \"Taco\");\n-    ClassName food = ClassName.create(\"com.squareup.tacos\", \"Food\");\n+    ClassName taco = ClassName.get(tacosPackage, \"Taco\");\n+    ClassName food = ClassName.get(\"com.squareup.tacos\", \"Food\");\n     TypeSpec typeSpec = TypeSpec.classBuilder(\"Taco\")\n         .addModifiers(Modifier.ABSTRACT)\n         .superclass(Types.parameterizedType(AbstractSet.class, food))\n@@ -511,7 +502,7 @@ public final class TypeSpecTest {\n   }\n \n   @Test public void interfaceExtends() throws Exception {\n-    ClassName taco = ClassName.create(tacosPackage, \"Taco\");\n+    ClassName taco = ClassName.get(tacosPackage, \"Taco\");\n     TypeSpec typeSpec = TypeSpec.interfaceBuilder(\"Taco\")\n         .addSuperinterface(Serializable.class)\n         .addSuperinterface(Types.parameterizedType(Comparable.class, taco))\n@@ -527,11 +518,10 @@ public final class TypeSpecTest {\n   }\n \n   @Test public void nestedClasses() throws Exception {\n-    ClassName taco = ClassName.create(tacosPackage, ImmutableList.of(\"Combo\"), \"Taco\");\n-    ClassName topping = ClassName.create(\n-        tacosPackage, ImmutableList.of(\"Combo\", \"Taco\"), \"Topping\");\n-    ClassName chips = ClassName.create(tacosPackage, ImmutableList.of(\"Combo\"), \"Chips\");\n-    ClassName sauce = ClassName.create(tacosPackage, ImmutableList.of(\"Combo\"), \"Sauce\");\n+    ClassName taco = ClassName.get(tacosPackage, \"Combo\", \"Taco\");\n+    ClassName topping = ClassName.get(tacosPackage, \"Combo\", \"Taco\", \"Topping\");\n+    ClassName chips = ClassName.get(tacosPackage, \"Combo\", \"Chips\");\n+    ClassName sauce = ClassName.get(tacosPackage, \"Combo\", \"Sauce\");\n     TypeSpec typeSpec = TypeSpec.classBuilder(\"Combo\")\n         .addField(FieldSpec.of(taco, \"taco\"))\n         .addField(FieldSpec.of(chips, \"chips\"))\n@@ -601,13 +591,13 @@ public final class TypeSpecTest {\n   }\n \n   @Test public void referencedAndDeclaredSimpleNamesConflict() throws Exception {\n-    FieldSpec internalTop = FieldSpec.of(ClassName.create(tacosPackage, \"Top\"), \"internalTop\");\n-    FieldSpec internalBottom = FieldSpec.of(ClassName.create(\n-        tacosPackage, ImmutableList.of(\"Top\", \"Middle\"), \"Bottom\"), \"internalBottom\");\n+    FieldSpec internalTop = FieldSpec.of(ClassName.get(tacosPackage, \"Top\"), \"internalTop\");\n+    FieldSpec internalBottom = FieldSpec.of(ClassName.get(tacosPackage,\n+        \"Top\", \"Middle\", \"Bottom\"), \"internalBottom\");\n     FieldSpec externalTop = FieldSpec.of(\n-        ClassName.create(donutsPackage, \"Top\"), \"externalTop\");\n+        ClassName.get(donutsPackage, \"Top\"), \"externalTop\");\n     FieldSpec externalBottom = FieldSpec.of(\n-        ClassName.create(donutsPackage, \"Bottom\"), \"externalBottom\");\n+        ClassName.get(donutsPackage, \"Bottom\"), \"externalBottom\");\n     TypeSpec top = TypeSpec.classBuilder(\"Top\")\n         .addField(internalTop)\n         .addField(internalBottom)\n"
    },
    {
        "commit_hash": "4b10b20e3d54151c28fd6b2d99629f9239d9a4c6",
        "previous_commit_hash": "02b9a9f7e65cfaa7b4d3bd07f5b73ffff3c6d7a0",
        "diff_stats": {
            "additions": 6,
            "deletions": 6
        },
        "diff_content": "@@ -49,18 +49,18 @@ public final class TypesTest {\n \n   @Test public void getBasicTypeMirror() {\n     assert_().that(Types.get(getType(Object.class)))\n-        .isEqualTo(ClassName.fromClass(Object.class));\n+        .isEqualTo(ClassName.get(Object.class));\n     assert_().that(Types.get(getType(Charset.class)))\n-        .isEqualTo(ClassName.fromClass(Charset.class));\n+        .isEqualTo(ClassName.get(Charset.class));\n     assert_().that(Types.get(getType(TypesTest.class)))\n-        .isEqualTo(ClassName.fromClass(TypesTest.class));\n+        .isEqualTo(ClassName.get(TypesTest.class));\n   }\n \n   @Test public void getParameterizedTypeMirror() {\n     DeclaredType setType =\n         compilation.getTypes().getDeclaredType(getElement(Set.class), getType(Object.class));\n     assert_().that(Types.get(setType))\n-        .isEqualTo(Types.parameterizedType(ClassName.fromClass(Set.class), ClassName.OBJECT));\n+        .isEqualTo(Types.parameterizedType(ClassName.get(Set.class), ClassName.OBJECT));\n   }\n \n   static class Parameterized<\n@@ -100,13 +100,13 @@ public final class TypesTest {\n       // Java 8.\n       IntersectionType intersectionType = (IntersectionType) bounds[0];\n       assert_().that(intersectionType.getBounds()).asList()\n-          .containsExactly(ClassName.fromClass(Number.class), ClassName.fromClass(Runnable.class));\n+          .containsExactly(ClassName.get(Number.class), ClassName.get(Runnable.class));\n       assert_().that(intersectionType.toString())\n           .isEqualTo(\"java.lang.Number & java.lang.Runnable\");\n     } else {\n       // Java \u2264 7.\n       assert_().that(bounds).asList()\n-          .containsExactly(ClassName.fromClass(Number.class), ClassName.fromClass(Runnable.class));\n+          .containsExactly(ClassName.get(Number.class), ClassName.get(Runnable.class));\n     }\n   }\n \n"
    },
    {
        "commit_hash": "96e3851d21db1448805d2ade99648544bc0def4e",
        "previous_commit_hash": "147eb5afa2b22674a33c3f3c45cd9b866b4b0855",
        "diff_stats": {
            "additions": 54,
            "deletions": 20
        },
        "diff_content": "@@ -15,13 +15,19 @@\n  */\n package com.squareup.javawriter;\n \n+import com.google.common.base.Supplier;\n+import com.google.common.collect.ImmutableListMultimap;\n+import com.google.common.collect.ImmutableMultimap;\n import com.google.common.collect.ImmutableSet;\n-import com.google.common.collect.ImmutableSortedMap;\n-import com.google.common.collect.Maps;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Multimaps;\n import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.Iterator;\n+import java.util.List;\n import java.util.Map;\n-import java.util.SortedMap;\n+import java.util.TreeMap;\n \n import static com.google.common.base.Preconditions.checkNotNull;\n import static com.google.common.collect.Iterables.getOnlyElement;\n@@ -29,26 +35,24 @@ import static com.google.common.collect.Iterables.getOnlyElement;\n /** A generated annotation on a declaration. */\n public final class AnnotationSpec {\n   public final Type type;\n-  public final ImmutableSortedMap<String, Snippet> members;\n+  public final ImmutableMultimap<String, Snippet> members;\n \n   private AnnotationSpec(Builder builder) {\n     this.type = checkNotNull(builder.type, \"type\");\n-    this.members = ImmutableSortedMap.copyOf(builder.members);\n+    this.members = ImmutableListMultimap.copyOf(builder.members);\n   }\n \n   void emit(CodeWriter codeWriter, boolean inline) {\n-    String separator = inline ? \"\" : \"\\n\";\n-    String suffix = inline ? \" \" : \"\\n\";\n+    String whitespace = inline ? \"\" : \"\\n\";\n+    String memberSeparator = inline ? \", \" : \",\\n\";\n     if (members.isEmpty()) {\n       // @Singleton\n-      codeWriter.emit(\"@$T\" + suffix, type);\n+      codeWriter.emit(\"@$T\", type);\n     } else if (members.keySet().equals(ImmutableSet.of(\"value\"))) {\n       // @Named(\"foo\")\n       codeWriter.emit(\"@$T(\", type);\n-      codeWriter.indent(2);\n-      codeWriter.emit(getOnlyElement(members.values()));\n-      codeWriter.unindent(2);\n-      codeWriter.emit(\")\" + suffix);\n+      emitAnnotationValue(codeWriter, whitespace, memberSeparator, members.values());\n+      codeWriter.emit(\")\");\n     } else {\n       // Inline:\n       //   @Column(name = \"updated_at\", nullable = false)\n@@ -58,18 +62,39 @@ public final class AnnotationSpec {\n       //       name = \"updated_at\",\n       //       nullable = false\n       //   )\n-      codeWriter.emit(\"@$T(\" + separator, type);\n+      codeWriter.emit(\"@$T(\" + whitespace, type);\n       codeWriter.indent(2);\n-      for (Iterator<Map.Entry<String, Snippet>> i = members.entrySet().iterator(); i.hasNext();) {\n-        Map.Entry<String, Snippet> entry = i.next();\n+      for (Iterator<Map.Entry<String, Collection<Snippet>>> i\n+          = members.asMap().entrySet().iterator(); i.hasNext();) {\n+        Map.Entry<String, Collection<Snippet>> entry = i.next();\n         codeWriter.emit(\"$L = \", entry.getKey());\n-        codeWriter.emit(entry.getValue());\n-        if (i.hasNext()) codeWriter.emit(\",\");\n-        codeWriter.emit(separator);\n+        emitAnnotationValue(codeWriter, whitespace, memberSeparator, entry.getValue());\n+        if (i.hasNext()) codeWriter.emit(memberSeparator);\n       }\n       codeWriter.unindent(2);\n-      codeWriter.emit(\")\" + suffix);\n+      codeWriter.emit(whitespace + \")\");\n+    }\n+  }\n+\n+  private void emitAnnotationValue(\n+      CodeWriter codeWriter, String whitespace, String memberSeparator, Collection<Snippet> value) {\n+    if (value.size() == 1) {\n+      codeWriter.indent(2);\n+      codeWriter.emit(getOnlyElement(value));\n+      codeWriter.unindent(2);\n+      return;\n+    }\n+\n+    codeWriter.emit(\"{\" + whitespace);\n+    codeWriter.indent(2);\n+    boolean first = true;\n+    for (Snippet snippet : value) {\n+      if (!first) codeWriter.emit(memberSeparator);\n+      codeWriter.emit(snippet);\n+      first = false;\n     }\n+    codeWriter.unindent(2);\n+    codeWriter.emit(whitespace + \"}\");\n   }\n \n   public static AnnotationSpec of(Type annotation) {\n@@ -92,7 +117,8 @@ public final class AnnotationSpec {\n \n   public static final class Builder {\n     private final Type type;\n-    private final SortedMap<String, Snippet> members = Maps.newTreeMap();\n+    private final Multimap<String, Snippet> members = Multimaps.newListMultimap(\n+        new TreeMap<String, Collection<Snippet>>(), AnnotationSpec.<Snippet>listSupplier());\n \n     private Builder(Type type) {\n       this.type = type;\n@@ -107,4 +133,12 @@ public final class AnnotationSpec {\n       return new AnnotationSpec(this);\n     }\n   }\n+\n+  private static <T> Supplier<List<T>> listSupplier() {\n+    return new Supplier<List<T>>() {\n+      @Override public List<T> get() {\n+        return new ArrayList<>();\n+      }\n+    };\n+  }\n }\n"
    },
    {
        "commit_hash": "96e3851d21db1448805d2ade99648544bc0def4e",
        "previous_commit_hash": "147eb5afa2b22674a33c3f3c45cd9b866b4b0855",
        "diff_stats": {
            "additions": 4,
            "deletions": 0
        },
        "diff_content": "@@ -128,6 +128,7 @@ final class CodeWriter {\n   public void emitAnnotations(ImmutableList<AnnotationSpec> annotations, boolean inline) {\n     for (AnnotationSpec annotationSpec : annotations) {\n       annotationSpec.emit(this, inline);\n+      emit(inline ? \" \" : \"\\n\");\n     }\n   }\n \n@@ -214,6 +215,9 @@ final class CodeWriter {\n     if (o instanceof TypeSpec) {\n       TypeSpec typeSpec = (TypeSpec) o;\n       typeSpec.emit(this, null);\n+    } else if (o instanceof AnnotationSpec) {\n+      AnnotationSpec annotationSpec = (AnnotationSpec) o;\n+      annotationSpec.emit(this, true);\n     } else {\n       emitAndIndent(String.valueOf(o));\n     }\n"
    },
    {
        "commit_hash": "96e3851d21db1448805d2ade99648544bc0def4e",
        "previous_commit_hash": "147eb5afa2b22674a33c3f3c45cd9b866b4b0855",
        "diff_stats": {
            "additions": 35,
            "deletions": 3
        },
        "diff_content": "@@ -200,8 +200,8 @@ public final class TypeSpecTest {\n         .addMethod(MethodSpec.methodBuilder(\"fooBar\")\n             .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)\n             .addAnnotation(AnnotationSpec.builder(headers)\n-                .addMember(\"value\", \"{\\n$S,\\n$S\\n}\",\n-                    \"Accept: application/json\", \"User-Agent: foobar\")\n+                .addMember(\"value\", \"$S\", \"Accept: application/json\")\n+                .addMember(\"value\", \"$S\", \"User-Agent: foobar\")\n                 .build())\n             .addAnnotation(AnnotationSpec.builder(post)\n                 .addMember(\"value\", \"$S\", \"/foo/bar\")\n@@ -234,7 +234,7 @@ public final class TypeSpecTest {\n         + \"  @Headers({\\n\"\n         + \"      \\\"Accept: application/json\\\",\\n\"\n         + \"      \\\"User-Agent: foobar\\\"\\n\"\n-        + \"      })\\n\"\n+        + \"  })\\n\"\n         + \"  @POST(\\\"/foo/bar\\\")\\n\"\n         + \"  Observable<FooBar> fooBar(@Body Things<Thing> things, @QueryMap(encodeValues = false) \"\n         + \"Map<String, String> query, @Header(\\\"Authorization\\\") String authorization);\\n\"\n@@ -739,6 +739,38 @@ public final class TypeSpecTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void annotationsInAnnotations() throws Exception {\n+    ClassName beef = ClassName.get(tacosPackage, \"Beef\");\n+    ClassName chicken = ClassName.get(tacosPackage, \"Chicken\");\n+    ClassName option = ClassName.get(tacosPackage, \"Option\");\n+    ClassName mealDeal = ClassName.get(tacosPackage, \"MealDeal\");\n+    TypeSpec menu = TypeSpec.classBuilder(\"Menu\")\n+        .addAnnotation(AnnotationSpec.builder(mealDeal)\n+            .addMember(\"price\", \"$L\", 500)\n+            .addMember(\"options\", \"$L\", AnnotationSpec.builder(option)\n+                .addMember(\"name\", \"$S\", \"taco\")\n+                .addMember(\"meat\", \"$T.class\", beef)\n+                .build())\n+            .addMember(\"options\", \"$L\", AnnotationSpec.builder(option)\n+                .addMember(\"name\", \"$S\", \"quesadilla\")\n+                .addMember(\"meat\", \"$T.class\", chicken)\n+                .build())\n+            .build())\n+        .build();\n+    assertThat(toString(menu)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"@MealDeal(\\n\"\n+        + \"    options = {\\n\"\n+        + \"        @Option(meat = Beef.class, name = \\\"taco\\\"),\\n\"\n+        + \"        @Option(meat = Chicken.class, name = \\\"quesadilla\\\")\\n\"\n+        + \"    },\\n\"\n+        + \"    price = 500\\n\"\n+        + \")\\n\"\n+        + \"class Menu {\\n\"\n+        + \"}\\n\");\n+  }\n+\n   private String toString(TypeSpec typeSpec) {\n     return new JavaFile.Builder()\n         .packageName(tacosPackage)\n"
    },
    {
        "commit_hash": "9f83e8e5500f901c829cd1ddab54428571c1e714",
        "previous_commit_hash": "a6404cc059f3121bdbe57c36c0cd8522c89518dc",
        "diff_stats": {
            "additions": 21,
            "deletions": 21
        },
        "diff_content": "@@ -17,10 +17,10 @@ package com.squareup.javawriter;\n \n import com.google.common.base.Ascii;\n import com.google.common.base.Joiner;\n-import com.google.common.base.Objects;\n import com.google.common.base.Splitter;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n import java.lang.reflect.Type;\n@@ -78,7 +78,7 @@ public final class ClassName implements Type, Comparable<ClassName> {\n \n   /** Returns the simple name of this class, like {@code \"Entry\"} for {@link Map.Entry}. */\n   public String simpleName() {\n-    return names.get(names.size() - 1);\n+    return Iterables.getLast(names);\n   }\n \n   public static ClassName get(Class<?> clazz) {\n@@ -107,25 +107,25 @@ public final class ClassName implements Type, Comparable<ClassName> {\n    * instances without such restrictions.\n    */\n   public static ClassName bestGuess(String classNameString) {\n-    String packageName = \"\";\n-    List<String> simpleNames = new ArrayList<>();\n-\n-    for (String part : Splitter.on('.').split(classNameString)) {\n-      checkArgument(SourceVersion.isIdentifier(part));\n-      char firstChar = part.charAt(0);\n-      if (Ascii.isLowerCase(firstChar)) {\n-        checkArgument(simpleNames.isEmpty(), \"couldn't make a guess for %s\", classNameString);\n-        if (!packageName.isEmpty()) packageName += \".\";\n-        packageName += part;\n-      } else if (Ascii.isUpperCase(firstChar)) {\n-        simpleNames.add(part);\n-      } else {\n-        checkArgument(false, \"couldn't make a guess for %s\", classNameString);\n-      }\n+    List<String> names = new ArrayList<>();\n+\n+    // Add the package name, like \"java.util.concurrent\", or \"\" for no package.\n+    int p = 0;\n+    while (p < classNameString.length() && Ascii.isLowerCase(classNameString.charAt(p))) {\n+      p = classNameString.indexOf('.', p) + 1;\n+      checkArgument(p != 0, \"couldn't make a guess for %s\", classNameString);\n+    }\n+    names.add(p != 0 ? classNameString.substring(0, p - 1) : \"\");\n+\n+    // Add the class names, like \"Map\" and \"Entry\".\n+    for (String part : Splitter.on('.').split(classNameString.substring(p))) {\n+      checkArgument(!part.isEmpty() && Ascii.isUpperCase(part.charAt(0)),\n+          \"couldn't make a guess for %s\", classNameString);\n+      names.add(part);\n     }\n-    checkArgument(!simpleNames.isEmpty(), \"couldn't make a guess for %s\", classNameString);\n-    simpleNames.add(0, packageName);\n-    return new ClassName(simpleNames);\n+\n+    checkArgument(names.size() >= 2, \"couldn't make a guess for %s\", classNameString);\n+    return new ClassName(names);\n   }\n \n   /**\n@@ -173,7 +173,7 @@ public final class ClassName implements Type, Comparable<ClassName> {\n   }\n \n   @Override public int hashCode() {\n-    return Objects.hashCode(canonicalName);\n+    return canonicalName.hashCode();\n   }\n \n   @Override public int compareTo(ClassName o) {\n"
    },
    {
        "commit_hash": "9f83e8e5500f901c829cd1ddab54428571c1e714",
        "previous_commit_hash": "a6404cc059f3121bdbe57c36c0cd8522c89518dc",
        "diff_stats": {
            "additions": 32,
            "deletions": 30
        },
        "diff_content": "@@ -228,24 +228,19 @@ final class CodeWriter {\n \n     if (type instanceof Class<?>) {\n       Class<?> classType = (Class<?>) type;\n-      if (classType.isPrimitive()) {\n-        if (boolean.class == classType) return emit(\"boolean\");\n-        if (byte.class == classType) return emit(\"byte\");\n-        if (short.class == classType) return emit(\"short\");\n-        if (int.class == classType) return emit(\"int\");\n-        if (long.class == classType) return emit(\"long\");\n-        if (char.class == classType) return emit(\"char\");\n-        if (float.class == classType) return emit(\"float\");\n-        if (double.class == classType) return emit(\"double\");\n-        if (void.class == classType) return emit(\"void\");\n-      } else if (classType.isArray()) {\n-        return emit(\"$T[]\", classType.getComponentType());\n-      } else {\n-        return emitType(ClassName.get(classType));\n-      }\n-    }\n-\n-    if (type instanceof ParameterizedType) {\n+      if (classType == boolean.class) return emit(\"boolean\");\n+      if (classType == byte.class) return emit(\"byte\");\n+      if (classType == short.class) return emit(\"short\");\n+      if (classType == int.class) return emit(\"int\");\n+      if (classType == long.class) return emit(\"long\");\n+      if (classType == char.class) return emit(\"char\");\n+      if (classType == float.class) return emit(\"float\");\n+      if (classType == double.class) return emit(\"double\");\n+      if (classType == void.class) return emit(\"void\");\n+      if (classType.isArray()) return emit(\"$T[]\", classType.getComponentType());\n+      return emitType(ClassName.get(classType));\n+\n+    } else if (type instanceof ParameterizedType) {\n       ParameterizedType parameterizedType = (ParameterizedType) type;\n       emitType(parameterizedType.getRawType());\n       emitAndIndent(\"<\");\n@@ -256,23 +251,29 @@ final class CodeWriter {\n         firstParameter = false;\n       }\n       emitAndIndent(\">\");\n+      return this;\n+\n     } else if (type instanceof WildcardType) {\n       WildcardType wildcardName = (WildcardType) type;\n       Type[] extendsBounds = wildcardName.getUpperBounds();\n       Type[] superBounds = wildcardName.getLowerBounds();\n       if (superBounds.length == 1) {\n-        emit(\"? super $T\", superBounds[0]);\n-      } else if (extendsBounds.length == 1 && !isObject(extendsBounds[0])) {\n-        emit(\"? extends $T\", extendsBounds[0]);\n-      } else {\n-        emit(\"?\");\n+        return emit(\"? super $T\", superBounds[0]);\n       }\n+      checkArgument(extendsBounds.length == 1);\n+      return isObject(extendsBounds[0])\n+          ? emit(\"?\")\n+          : emit(\"? extends $T\", extendsBounds[0]);\n+\n     } else if (type instanceof TypeVariable<?>) {\n-      emit(\"$L\", ((TypeVariable) type).getName());\n+      return emitAndIndent(((TypeVariable) type).getName());\n+\n     } else if (type instanceof ClassName) {\n-      emitAndIndent(lookupName((ClassName) type));\n+      return emitAndIndent(lookupName((ClassName) type));\n+\n     } else if (type instanceof GenericArrayType) {\n-      emit(\"$T[]\", ((GenericArrayType) type).getGenericComponentType());\n+      return emit(\"$T[]\", ((GenericArrayType) type).getGenericComponentType());\n+\n     } else if (type instanceof IntersectionType) {\n       boolean firstBound = true;\n       for (Type bound : ((IntersectionType) type).getBounds()) {\n@@ -280,10 +281,10 @@ final class CodeWriter {\n         emit(\"$T\", bound);\n         firstBound = false;\n       }\n-    } else {\n-      throw new UnsupportedOperationException(\"unexpected type: \" + arg);\n+      return this;\n     }\n-    return this;\n+\n+    throw new UnsupportedOperationException(\"unexpected type: \" + arg);\n   }\n \n   private boolean isObject(Type bound) {\n@@ -364,7 +365,7 @@ final class CodeWriter {\n    * {@link #out} does it through here, since we emit indentation lazily in order to avoid\n    * unnecessary trailing whitespace.\n    */\n-  private void emitAndIndent(String s) {\n+  private CodeWriter emitAndIndent(String s) {\n     boolean first = true;\n     for (String line : s.split(\"\\n\", -1)) {\n       // Emit a newline character. Make sure blank lines in Javadoc look good.\n@@ -389,6 +390,7 @@ final class CodeWriter {\n \n       out.append(line);\n     }\n+    return this;\n   }\n \n   private void emitIndentation() {\n"
    },
    {
        "commit_hash": "9f83e8e5500f901c829cd1ddab54428571c1e714",
        "previous_commit_hash": "a6404cc059f3121bdbe57c36c0cd8522c89518dc",
        "diff_stats": {
            "additions": 16,
            "deletions": 11
        },
        "diff_content": "@@ -55,18 +55,23 @@ public final class ClassNameTest {\n   }\n \n   @Test public void bestGuessForString_confusingInput() {\n+    assertBestGuessThrows(\"\");\n+    assertBestGuessThrows(\".\");\n+    assertBestGuessThrows(\".Map\");\n+    assertBestGuessThrows(\"java\");\n+    assertBestGuessThrows(\"java.util\");\n+    assertBestGuessThrows(\"java.util.\");\n+    assertBestGuessThrows(\"java..util.Map.Entry\");\n+    assertBestGuessThrows(\"java.util..Map.Entry\");\n+    assertBestGuessThrows(\"java.util.Map..Entry\");\n+    assertBestGuessThrows(\"com.test.$\");\n+    assertBestGuessThrows(\"com.test.LooksLikeAClass.pkg\");\n+    assertBestGuessThrows(\"!@#$gibberish%^&*\");\n+  }\n+\n+  private void assertBestGuessThrows(String s) {\n     try {\n-      ClassName.bestGuess(\"com.test.$\");\n-      fail();\n-    } catch (IllegalArgumentException expected) {\n-    }\n-    try {\n-      ClassName.bestGuess(\"com.test.LooksLikeAClass.pkg\");\n-      fail();\n-    } catch (IllegalArgumentException expected) {\n-    }\n-    try {\n-      ClassName.bestGuess(\"!@#$gibberish%^&*\");\n+      ClassName.bestGuess(s);\n       fail();\n     } catch (IllegalArgumentException expected) {\n     }\n"
    },
    {
        "commit_hash": "3adcc4a1f0d20ee31e452c2242b2dbd0e16d5962",
        "previous_commit_hash": "a6404cc059f3121bdbe57c36c0cd8522c89518dc",
        "diff_stats": {
            "additions": 23,
            "deletions": 0
        },
        "diff_content": "@@ -16,6 +16,7 @@\n package com.squareup.javawriter;\n \n import java.util.Date;\n+import javax.lang.model.element.Modifier;\n import org.junit.Test;\n \n import static com.google.common.truth.Truth.assertThat;\n@@ -73,4 +74,26 @@ public final class JavaFileTest {\n         + \"  java.sql.Date madeFreshDatabaseDate;\\n\"\n         + \"}\\n\");\n   }\n+\n+  @Test public void defaultPackage() throws Exception {\n+    String source = new JavaFile.Builder()\n+        .typeSpec(TypeSpec.classBuilder(\"HelloWorld\")\n+            .addMethod(MethodSpec.methodBuilder(\"main\")\n+                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n+                .addParameter(String[].class, \"args\")\n+                .addCode(\"$T.out.println($S);\\n\", System.class, \"Hello World!\")\n+                .build())\n+            .build())\n+        .build()\n+        .toString();\n+    assertThat(source).isEqualTo(\"\"\n+        + \"import java.lang.String;\\n\"\n+        + \"import java.lang.System;\\n\"\n+        + \"\\n\"\n+        + \"class HelloWorld {\\n\"\n+        + \"  public static void main(String[] args) {\\n\"\n+        + \"    System.out.println(\\\"Hello World!\\\");\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n }\n"
    },
    {
        "commit_hash": "eefa91d8d0b6da39d6b11a071ba0c5546b1dfb34",
        "previous_commit_hash": "a6404cc059f3121bdbe57c36c0cd8522c89518dc",
        "diff_stats": {
            "additions": 3,
            "deletions": 6
        },
        "diff_content": "@@ -83,12 +83,9 @@ public final class ClassName implements Type, Comparable<ClassName> {\n \n   public static ClassName get(Class<?> clazz) {\n     checkNotNull(clazz);\n-    checkArgument(!clazz.isPrimitive(),\n-        \"Primitive types cannot be represented as a ClassName. Use TypeNames.forClass instead.\");\n-    checkArgument(!void.class.equals(clazz),\n-        \"'void' type cannot be represented as a ClassName. Use TypeNames.forClass instead.\");\n-    checkArgument(!clazz.isArray(),\n-        \"Array types cannot be represented as a ClassName. Use TypeNames.forClass instead.\");\n+    checkArgument(!clazz.isPrimitive(), \"Primitive types cannot be represented as a ClassName.\");\n+    checkArgument(!void.class.equals(clazz), \"'void' type cannot be represented as a ClassName.\");\n+    checkArgument(!clazz.isArray(), \"Array types cannot be represented as a ClassName.\");\n     List<String> names = Lists.newArrayList();\n     for (Class<?> c = clazz; c != null; c = c.getEnclosingClass()) {\n       names.add(c.getSimpleName());\n"
    },
    {
        "commit_hash": "eefa91d8d0b6da39d6b11a071ba0c5546b1dfb34",
        "previous_commit_hash": "a6404cc059f3121bdbe57c36c0cd8522c89518dc",
        "diff_stats": {
            "additions": 19,
            "deletions": 2
        },
        "diff_content": "@@ -21,6 +21,7 @@ import java.lang.reflect.Type;\n import java.lang.reflect.TypeVariable;\n import java.util.ArrayList;\n import java.util.Collections;\n+import java.util.Iterator;\n import java.util.List;\n import javax.lang.model.SourceVersion;\n import javax.lang.model.element.Modifier;\n@@ -28,6 +29,7 @@ import javax.lang.model.element.Modifier;\n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkNotNull;\n import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.collect.Iterables.getLast;\n \n /** A generated constructor or method declaration. */\n public final class MethodSpec {\n@@ -40,12 +42,15 @@ public final class MethodSpec {\n   public final ImmutableList<TypeVariable<?>> typeVariables;\n   public final Type returnType;\n   public final ImmutableList<ParameterSpec> parameters;\n+  public final boolean varargs;\n   public final ImmutableList<Type> exceptions;\n   public final ImmutableList<Snippet> snippets;\n \n   private MethodSpec(Builder builder) {\n     checkArgument(builder.snippets.isEmpty() || !builder.modifiers.contains(Modifier.ABSTRACT),\n         \"abstract method %s cannot have code\", builder.name);\n+    checkArgument(!builder.varargs || lastParameterIsArray(builder.parameters),\n+        \"last parameter of varargs method %s must be an array\", builder.name);\n \n     this.name = checkNotNull(builder.name);\n     this.javadocSnippets = ImmutableList.copyOf(builder.javadocSnippets);\n@@ -54,10 +59,15 @@ public final class MethodSpec {\n     this.typeVariables = ImmutableList.copyOf(builder.typeVariables);\n     this.returnType = builder.returnType;\n     this.parameters = ImmutableList.copyOf(builder.parameters);\n+    this.varargs = builder.varargs;\n     this.exceptions = ImmutableList.copyOf(builder.exceptions);\n     this.snippets = ImmutableList.copyOf(builder.snippets);\n   }\n \n+  private boolean lastParameterIsArray(List<ParameterSpec> parameters) {\n+    return !parameters.isEmpty() && Types.arrayComponent(getLast(parameters).type) != null;\n+  }\n+\n   void emit(CodeWriter codeWriter, String enclosingName, ImmutableSet<Modifier> implicitModifiers) {\n     codeWriter.emitJavadoc(javadocSnippets);\n     codeWriter.emitAnnotations(annotations, false);\n@@ -75,9 +85,10 @@ public final class MethodSpec {\n     }\n \n     boolean firstParameter = true;\n-    for (ParameterSpec parameterSpec : parameters) {\n+    for (Iterator<ParameterSpec> i = parameters.iterator(); i.hasNext();) {\n+      ParameterSpec parameter = i.next();\n       if (!firstParameter) codeWriter.emit(\", \");\n-      parameterSpec.emit(codeWriter);\n+      parameter.emit(codeWriter, !i.hasNext() && varargs);\n       firstParameter = false;\n     }\n \n@@ -130,6 +141,7 @@ public final class MethodSpec {\n     private final List<ParameterSpec> parameters = new ArrayList<>();\n     private final List<Type> exceptions = new ArrayList<>();\n     private final List<Snippet> snippets = new ArrayList<>();\n+    private boolean varargs;\n \n     private Builder(String name) {\n       checkArgument(name.equals(CONSTRUCTOR) || SourceVersion.isName(name),\n@@ -178,6 +190,11 @@ public final class MethodSpec {\n       return addParameter(ParameterSpec.of(type, name, modifiers));\n     }\n \n+    public Builder varargs() {\n+      this.varargs = true;\n+      return this;\n+    }\n+\n     public Builder addException(Type exception) {\n       this.exceptions.add(exception);\n       return this;\n"
    },
    {
        "commit_hash": "eefa91d8d0b6da39d6b11a071ba0c5546b1dfb34",
        "previous_commit_hash": "a6404cc059f3121bdbe57c36c0cd8522c89518dc",
        "diff_stats": {
            "additions": 6,
            "deletions": 2
        },
        "diff_content": "@@ -45,10 +45,14 @@ public final class ParameterSpec {\n     return modifiers.contains(modifier);\n   }\n \n-  void emit(CodeWriter codeWriter) {\n+  void emit(CodeWriter codeWriter, boolean varargs) {\n     codeWriter.emitAnnotations(annotations, true);\n     codeWriter.emitModifiers(modifiers);\n-    codeWriter.emit(\"$T $L\", type, name);\n+    if (varargs) {\n+      codeWriter.emit(\"$T... $L\", Types.arrayComponent(type), name);\n+    } else {\n+      codeWriter.emit(\"$T $L\", type, name);\n+    }\n   }\n \n   public static Builder builder(Type type, String name, Modifier... modifiers) {\n"
    },
    {
        "commit_hash": "eefa91d8d0b6da39d6b11a071ba0c5546b1dfb34",
        "previous_commit_hash": "a6404cc059f3121bdbe57c36c0cd8522c89518dc",
        "diff_stats": {
            "additions": 11,
            "deletions": 0
        },
        "diff_content": "@@ -347,4 +347,15 @@ public final class Types {\n     new CodeWriter(result).emit(\"$T\", type);\n     return result.toString();\n   }\n+\n+  /** Returns the array component of {@code type}, or null if {@code type} is not an array. */\n+  static Type arrayComponent(Type type) {\n+    if (type instanceof Class<?>) {\n+      return ((Class<?>) type).getComponentType();\n+    } else if (type instanceof GenericArrayType) {\n+      return ((GenericArrayType) type).getGenericComponentType();\n+    } else {\n+      return null;\n+    }\n+  }\n }\n"
    },
    {
        "commit_hash": "eefa91d8d0b6da39d6b11a071ba0c5546b1dfb34",
        "previous_commit_hash": "a6404cc059f3121bdbe57c36c0cd8522c89518dc",
        "diff_stats": {
            "additions": 20,
            "deletions": 1
        },
        "diff_content": "@@ -412,7 +412,7 @@ public final class TypeSpecTest {\n     TypeSpec typeSpec = TypeSpec.classBuilder(\"Location\")\n         .addTypeVariable(t)\n         .addTypeVariable(p)\n-        .addSuperinterface(Types.parameterizedType(ClassName.get(Comparable.class), p))\n+        .addSuperinterface(Types.parameterizedType(Comparable.class, p))\n         .addField(FieldSpec.of(t, \"label\"))\n         .addField(FieldSpec.of(p, \"x\"))\n         .addField(FieldSpec.of(p, \"y\"))\n@@ -771,6 +771,25 @@ public final class TypeSpecTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void varargs() throws Exception {\n+    TypeSpec taqueria = TypeSpec.classBuilder(\"Taqueria\")\n+        .addMethod(MethodSpec.methodBuilder(\"prepare\")\n+            .addParameter(int.class, \"workers\")\n+            .addParameter(Runnable[].class, \"jobs\")\n+            .varargs()\n+            .build())\n+        .build();\n+    assertThat(toString(taqueria)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import java.lang.Runnable;\\n\"\n+        + \"\\n\"\n+        + \"class Taqueria {\\n\"\n+        + \"  void prepare(int workers, Runnable... jobs) {\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n   private String toString(TypeSpec typeSpec) {\n     return new JavaFile.Builder()\n         .packageName(tacosPackage)\n"
    },
    {
        "commit_hash": "02bd3a1fbd479f76e9c8d712e92cf032ea74f9d0",
        "previous_commit_hash": "aa0e66296ed9f6864ef07b81502120eac9f4225d",
        "diff_stats": {
            "additions": 4,
            "deletions": 3
        },
        "diff_content": "@@ -21,6 +21,7 @@ import com.google.common.collect.ImmutableMultimap;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Multimap;\n import com.google.common.collect.Multimaps;\n+import java.io.IOException;\n import java.lang.reflect.Type;\n import java.util.ArrayList;\n import java.util.Collection;\n@@ -42,7 +43,7 @@ public final class AnnotationSpec {\n     this.members = ImmutableListMultimap.copyOf(builder.members);\n   }\n \n-  void emit(CodeWriter codeWriter, boolean inline) {\n+  void emit(CodeWriter codeWriter, boolean inline) throws IOException {\n     String whitespace = inline ? \"\" : \"\\n\";\n     String memberSeparator = inline ? \", \" : \",\\n\";\n     if (members.isEmpty()) {\n@@ -76,8 +77,8 @@ public final class AnnotationSpec {\n     }\n   }\n \n-  private void emitAnnotationValue(\n-      CodeWriter codeWriter, String whitespace, String memberSeparator, Collection<Snippet> value) {\n+  private void emitAnnotationValue(CodeWriter codeWriter, String whitespace, String memberSeparator,\n+      Collection<Snippet> value) throws IOException {\n     if (value.size() == 1) {\n       codeWriter.indent(2);\n       codeWriter.emit(getOnlyElement(value));\n"
    },
    {
        "commit_hash": "02bd3a1fbd479f76e9c8d712e92cf032ea74f9d0",
        "previous_commit_hash": "aa0e66296ed9f6864ef07b81502120eac9f4225d",
        "diff_stats": {
            "additions": 40,
            "deletions": 25
        },
        "diff_content": "@@ -21,6 +21,7 @@ import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableMap;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.ImmutableSortedMap;\n+import java.io.IOException;\n import java.lang.reflect.GenericArrayType;\n import java.lang.reflect.ParameterizedType;\n import java.lang.reflect.Type;\n@@ -47,20 +48,22 @@ import static com.google.common.base.Preconditions.checkState;\n  */\n final class CodeWriter {\n   private final String indent = \"  \";\n-  private final StringBuilder out;\n+  private final Appendable out;\n   private int indentLevel;\n \n   private boolean javadoc = false;\n+  private boolean comment = false;\n   private String packageName;\n   private final List<TypeSpec> typeSpecStack = new ArrayList<>();\n   private final ImmutableMap<ClassName, String> importedTypes;\n   private final Set<ClassName> importableTypes = new LinkedHashSet<>();\n+  private boolean trailingNewline;\n \n-  public CodeWriter(StringBuilder out) {\n+  public CodeWriter(Appendable out) {\n     this(out, ImmutableMap.<ClassName, String>of());\n   }\n \n-  public CodeWriter(StringBuilder out, ImmutableMap<ClassName, String> importedTypes) {\n+  public CodeWriter(Appendable out, ImmutableMap<ClassName, String> importedTypes) {\n     this.out = checkNotNull(out);\n     this.importedTypes = checkNotNull(importedTypes);\n   }\n@@ -110,7 +113,18 @@ final class CodeWriter {\n     return this;\n   }\n \n-  public void emitJavadoc(ImmutableList<Snippet> javadocSnippets) {\n+  public void emitComment(Snippet snippet) throws IOException {\n+    trailingNewline = true; // Force the '//' prefix for the comment.\n+    comment = true;\n+    try {\n+      emit(snippet);\n+      emit(\"\\n\");\n+    } finally {\n+      comment = false;\n+    }\n+  }\n+\n+  public void emitJavadoc(ImmutableList<Snippet> javadocSnippets) throws IOException {\n     if (javadocSnippets.isEmpty()) return;\n \n     emit(\"/**\\n\");\n@@ -125,7 +139,8 @@ final class CodeWriter {\n     emit(\" */\\n\");\n   }\n \n-  public void emitAnnotations(ImmutableList<AnnotationSpec> annotations, boolean inline) {\n+  public void emitAnnotations(ImmutableList<AnnotationSpec> annotations, boolean inline)\n+      throws IOException {\n     for (AnnotationSpec annotationSpec : annotations) {\n       annotationSpec.emit(this, inline);\n       emit(inline ? \" \" : \"\\n\");\n@@ -136,8 +151,8 @@ final class CodeWriter {\n    * Emits {@code modifiers} in the standard order. Modifiers in {@code implicitModifiers} will not\n    * be emitted.\n    */\n-  public void emitModifiers(\n-      ImmutableSet<Modifier> modifiers, ImmutableSet<Modifier> implicitModifiers) {\n+  public void emitModifiers(ImmutableSet<Modifier> modifiers,\n+      ImmutableSet<Modifier> implicitModifiers) throws IOException {\n     if (!modifiers.isEmpty()) {\n       for (Modifier modifier : EnumSet.copyOf(modifiers)) {\n         if (implicitModifiers.contains(modifier)) continue;\n@@ -147,7 +162,7 @@ final class CodeWriter {\n     }\n   }\n \n-  public void emitModifiers(ImmutableSet<Modifier> modifiers) {\n+  public void emitModifiers(ImmutableSet<Modifier> modifiers) throws IOException {\n     emitModifiers(modifiers, ImmutableSet.<Modifier>of());\n   }\n \n@@ -155,7 +170,7 @@ final class CodeWriter {\n    * Emit type variables with their bounds. This should only be used when declaring type variables;\n    * everywhere else bounds are omitted.\n    */\n-  public void emitTypeVariables(ImmutableList<TypeVariable<?>> typeVariables) {\n+  public void emitTypeVariables(ImmutableList<TypeVariable<?>> typeVariables) throws IOException {\n     if (typeVariables.isEmpty()) return;\n \n     emit(\"<\");\n@@ -174,11 +189,11 @@ final class CodeWriter {\n     emit(\">\");\n   }\n \n-  public CodeWriter emit(String format, Object... args) {\n+  public CodeWriter emit(String format, Object... args) throws IOException {\n     return emit(new Snippet(format, args));\n   }\n \n-  public CodeWriter emit(Snippet snippet) {\n+  public CodeWriter emit(Snippet snippet) throws IOException {\n     int a = 0;\n     for (String part : snippet.formatParts) {\n       switch (part) {\n@@ -211,7 +226,7 @@ final class CodeWriter {\n     return this;\n   }\n \n-  private void emitLiteral(Object o) {\n+  private void emitLiteral(Object o) throws IOException {\n     if (o instanceof TypeSpec) {\n       TypeSpec typeSpec = (TypeSpec) o;\n       typeSpec.emit(this, null);\n@@ -223,7 +238,7 @@ final class CodeWriter {\n     }\n   }\n \n-  private CodeWriter emitType(Object arg) {\n+  private CodeWriter emitType(Object arg) throws IOException {\n     Type type = toType(arg);\n \n     if (type instanceof Class<?>) {\n@@ -365,50 +380,50 @@ final class CodeWriter {\n    * {@link #out} does it through here, since we emit indentation lazily in order to avoid\n    * unnecessary trailing whitespace.\n    */\n-  private CodeWriter emitAndIndent(String s) {\n+  private CodeWriter emitAndIndent(String s) throws IOException {\n     boolean first = true;\n     for (String line : s.split(\"\\n\", -1)) {\n-      // Emit a newline character. Make sure blank lines in Javadoc look good.\n+      // Emit a newline character. Make sure blank lines in Javadoc & comments look good.\n       if (!first) {\n-        if (javadoc && trailingNewline()) {\n+        if ((javadoc || comment) && trailingNewline) {\n           emitIndentation();\n-          out.append(\" *\");\n+          out.append(javadoc ? \" *\" : \"//\");\n         }\n         out.append('\\n');\n+        trailingNewline = true;\n       }\n \n       first = false;\n       if (line.isEmpty()) continue; // Don't indent empty lines.\n \n-      // Emit indentation if necessary.\n-      if (trailingNewline()) {\n+      // Emit indentation and comment prefix if necessary.\n+      if (trailingNewline) {\n         emitIndentation();\n         if (javadoc) {\n           out.append(\" * \");\n+        } else if (comment) {\n+          out.append(\"// \");\n         }\n       }\n \n       out.append(line);\n+      trailingNewline = false;\n     }\n     return this;\n   }\n \n-  private void emitIndentation() {\n+  private void emitIndentation() throws IOException {\n     for (int j = 0; j < indentLevel; j++) {\n       out.append(indent);\n     }\n   }\n \n-  private boolean trailingNewline() {\n-    return out.length() > 0 && out.charAt(out.length() - 1) == '\\n';\n-  }\n-\n   private Type toType(Object arg) {\n     if (arg instanceof Type) return (Type) arg;\n     throw new IllegalArgumentException(\"Expected type but was \" + arg);\n   }\n \n-  private void emitName(Object o) {\n+  private void emitName(Object o) throws IOException {\n     emitAndIndent(toName(o));\n   }\n \n"
    },
    {
        "commit_hash": "02bd3a1fbd479f76e9c8d712e92cf032ea74f9d0",
        "previous_commit_hash": "aa0e66296ed9f6864ef07b81502120eac9f4225d",
        "diff_stats": {
            "additions": 2,
            "deletions": 1
        },
        "diff_content": "@@ -17,6 +17,7 @@ package com.squareup.javawriter;\n \n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n+import java.io.IOException;\n import java.lang.reflect.Type;\n import java.util.ArrayList;\n import java.util.Collections;\n@@ -49,7 +50,7 @@ public final class FieldSpec {\n     return modifiers.contains(modifier);\n   }\n \n-  void emit(CodeWriter codeWriter, ImmutableSet<Modifier> implicitModifiers) {\n+  void emit(CodeWriter codeWriter, ImmutableSet<Modifier> implicitModifiers) throws IOException {\n     codeWriter.emitJavadoc(javadocSnippets);\n     codeWriter.emitAnnotations(annotations, false);\n     codeWriter.emitModifiers(modifiers, implicitModifiers);\n"
    },
    {
        "commit_hash": "02bd3a1fbd479f76e9c8d712e92cf032ea74f9d0",
        "previous_commit_hash": "aa0e66296ed9f6864ef07b81502120eac9f4225d",
        "diff_stats": {
            "additions": 40,
            "deletions": 7
        },
        "diff_content": "@@ -16,35 +16,52 @@\n package com.squareup.javawriter;\n \n import com.google.common.collect.ImmutableMap;\n+import java.io.IOException;\n \n import static com.google.common.base.Preconditions.checkNotNull;\n \n /** A Java file containing a single top level class. */\n public final class JavaFile {\n+  private static final Appendable NULL_APPENDABLE = new Appendable() {\n+    @Override public Appendable append(CharSequence charSequence) {\n+      return this;\n+    }\n+    @Override public Appendable append(CharSequence charSequence, int start, int end) {\n+      return this;\n+    }\n+    @Override public Appendable append(char c) {\n+      return this;\n+    }\n+  };\n+\n+  public final Snippet fileComment;\n   public final String packageName;\n   public final TypeSpec typeSpec;\n \n   private JavaFile(Builder builder) {\n+    this.fileComment = builder.fileComment;\n     this.packageName = builder.packageName;\n     this.typeSpec = checkNotNull(builder.typeSpec);\n   }\n \n-  public String toString() {\n+  public void emit(Appendable out) throws IOException {\n     // First pass: emit the entire class, just to collect the types we'll need to import.\n-    CodeWriter importsCollector = new CodeWriter(new StringBuilder());\n+    CodeWriter importsCollector = new CodeWriter(NULL_APPENDABLE);\n     emit(importsCollector);\n     ImmutableMap<ClassName, String> suggestedImports = importsCollector.suggestedImports();\n \n-    // Second pass: Write the code, taking advantage of the imports.\n-    StringBuilder result = new StringBuilder();\n-    CodeWriter codeWriter = new CodeWriter(result, suggestedImports);\n+    // Second pass: write the code, taking advantage of the imports.\n+    CodeWriter codeWriter = new CodeWriter(out, suggestedImports);\n     emit(codeWriter);\n-    return result.toString();\n   }\n \n-  private void emit(CodeWriter codeWriter) {\n+  private void emit(CodeWriter codeWriter) throws IOException {\n     codeWriter.pushPackage(packageName);\n \n+    if (fileComment != null) {\n+      codeWriter.emitComment(fileComment);\n+    }\n+\n     if (!packageName.isEmpty()) {\n       codeWriter.emit(\"package $L;\\n\", packageName);\n       codeWriter.emit(\"\\n\");\n@@ -62,10 +79,26 @@ public final class JavaFile {\n     codeWriter.popPackage();\n   }\n \n+  public String toString() {\n+    try {\n+      StringBuilder result = new StringBuilder();\n+      emit(result);\n+      return result.toString();\n+    } catch (IOException e) {\n+      throw new AssertionError();\n+    }\n+  }\n+\n   public static final class Builder {\n+    private Snippet fileComment;\n     private String packageName = \"\";\n     private TypeSpec typeSpec;\n \n+    public Builder fileComment(String format, Object... args) {\n+      this.fileComment = new Snippet(format, args);\n+      return this;\n+    }\n+\n     public Builder packageName(String packageName) {\n       this.packageName = checkNotNull(packageName);\n       return this;\n"
    },
    {
        "commit_hash": "02bd3a1fbd479f76e9c8d712e92cf032ea74f9d0",
        "previous_commit_hash": "aa0e66296ed9f6864ef07b81502120eac9f4225d",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -62,7 +62,7 @@ public final class JavaWriter {\n \n       Path outputPath = outputDirectory.resolve(javaFile.typeSpec.name + \".java\");\n       try (Writer writer = new OutputStreamWriter(Files.newOutputStream(outputPath))) {\n-        writer.write(javaFile.toString());\n+        javaFile.emit(writer);\n       }\n     }\n   }\n@@ -77,7 +77,7 @@ public final class JavaWriter {\n           javaFile.packageName + \".\" + javaFile.typeSpec.name,\n           Iterables.toArray(javaFile.typeSpec.originatingElements, Element.class));\n       try (Writer writer = filerSourceFile.openWriter()) {\n-        writer.write(javaFile.toString());\n+        javaFile.emit(writer);\n       } catch (Exception e) {\n         try {\n           filerSourceFile.delete();\n"
    },
    {
        "commit_hash": "02bd3a1fbd479f76e9c8d712e92cf032ea74f9d0",
        "previous_commit_hash": "aa0e66296ed9f6864ef07b81502120eac9f4225d",
        "diff_stats": {
            "additions": 3,
            "deletions": 1
        },
        "diff_content": "@@ -17,6 +17,7 @@ package com.squareup.javawriter;\n \n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n+import java.io.IOException;\n import java.lang.reflect.Type;\n import java.lang.reflect.TypeVariable;\n import java.util.ArrayList;\n@@ -68,7 +69,8 @@ public final class MethodSpec {\n     return !parameters.isEmpty() && Types.arrayComponent(getLast(parameters).type) != null;\n   }\n \n-  void emit(CodeWriter codeWriter, String enclosingName, ImmutableSet<Modifier> implicitModifiers) {\n+  void emit(CodeWriter codeWriter, String enclosingName, ImmutableSet<Modifier> implicitModifiers)\n+      throws IOException {\n     codeWriter.emitJavadoc(javadocSnippets);\n     codeWriter.emitAnnotations(annotations, false);\n     codeWriter.emitModifiers(modifiers, implicitModifiers);\n"
    },
    {
        "commit_hash": "02bd3a1fbd479f76e9c8d712e92cf032ea74f9d0",
        "previous_commit_hash": "aa0e66296ed9f6864ef07b81502120eac9f4225d",
        "diff_stats": {
            "additions": 2,
            "deletions": 1
        },
        "diff_content": "@@ -17,6 +17,7 @@ package com.squareup.javawriter;\n \n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n+import java.io.IOException;\n import java.lang.reflect.Type;\n import java.util.ArrayList;\n import java.util.Collections;\n@@ -45,7 +46,7 @@ public final class ParameterSpec {\n     return modifiers.contains(modifier);\n   }\n \n-  void emit(CodeWriter codeWriter, boolean varargs) {\n+  void emit(CodeWriter codeWriter, boolean varargs) throws IOException {\n     codeWriter.emitAnnotations(annotations, true);\n     codeWriter.emitModifiers(modifiers);\n     if (varargs) {\n"
    },
    {
        "commit_hash": "02bd3a1fbd479f76e9c8d712e92cf032ea74f9d0",
        "previous_commit_hash": "aa0e66296ed9f6864ef07b81502120eac9f4225d",
        "diff_stats": {
            "additions": 2,
            "deletions": 1
        },
        "diff_content": "@@ -19,6 +19,7 @@ import com.google.common.base.Ascii;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableMap;\n import com.google.common.collect.ImmutableSet;\n+import java.io.IOException;\n import java.lang.reflect.Type;\n import java.lang.reflect.TypeVariable;\n import java.util.ArrayList;\n@@ -123,7 +124,7 @@ public final class TypeSpec {\n     return new Builder(DeclarationType.CLASS, null, new Snippet(typeArgumentsFormat, args));\n   }\n \n-  void emit(CodeWriter codeWriter, String enumName) {\n+  void emit(CodeWriter codeWriter, String enumName) throws IOException {\n     if (enumName != null) {\n       codeWriter.emit(\"$L\", enumName);\n       if (!anonymousTypeArguments.formatParts.isEmpty()) {\n"
    },
    {
        "commit_hash": "02bd3a1fbd479f76e9c8d712e92cf032ea74f9d0",
        "previous_commit_hash": "aa0e66296ed9f6864ef07b81502120eac9f4225d",
        "diff_stats": {
            "additions": 8,
            "deletions": 3
        },
        "diff_content": "@@ -21,6 +21,7 @@ import com.google.common.base.Predicates;\n import com.google.common.collect.FluentIterable;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Iterables;\n+import java.io.IOException;\n import java.lang.annotation.Annotation;\n import java.lang.reflect.AnnotatedType;\n import java.lang.reflect.GenericArrayType;\n@@ -343,9 +344,13 @@ public final class Types {\n   }\n \n   private static String typeToString(Type type) {\n-    StringBuilder result = new StringBuilder();\n-    new CodeWriter(result).emit(\"$T\", type);\n-    return result.toString();\n+    try {\n+      StringBuilder result = new StringBuilder();\n+      new CodeWriter(result).emit(\"$T\", type);\n+      return result.toString();\n+    } catch (IOException e) {\n+      throw new AssertionError();\n+    }\n   }\n \n   /** Returns the array component of {@code type}, or null if {@code type} is not an array. */\n"
    },
    {
        "commit_hash": "02bd3a1fbd479f76e9c8d712e92cf032ea74f9d0",
        "previous_commit_hash": "aa0e66296ed9f6864ef07b81502120eac9f4225d",
        "diff_stats": {
            "additions": 35,
            "deletions": 0
        },
        "diff_content": "@@ -96,4 +96,39 @@ public final class JavaFileTest {\n         + \"  }\\n\"\n         + \"}\\n\");\n   }\n+\n+  @Test public void topOfFileComment() throws Exception {\n+    String source = new JavaFile.Builder()\n+        .fileComment(\"Generated $L by JavaWriter. DO NOT EDIT!\", \"2015-01-13\")\n+        .packageName(\"com.squareup.tacos\")\n+        .typeSpec(TypeSpec.classBuilder(\"Taco\").build())\n+        .build()\n+        .toString();\n+    assertThat(source).isEqualTo(\"\"\n+        + \"// Generated 2015-01-13 by JavaWriter. DO NOT EDIT!\\n\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"class Taco {\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void emptyLinesInTopOfFileComment() throws Exception {\n+    String source = new JavaFile.Builder()\n+        .fileComment(\"\\nGENERATED FILE:\\n\\nDO NOT EDIT!\\n\")\n+        .packageName(\"com.squareup.tacos\")\n+        .typeSpec(TypeSpec.classBuilder(\"Taco\")\n+            .build())\n+        .build()\n+        .toString();\n+    assertThat(source).isEqualTo(\"\"\n+        + \"//\\n\"\n+        + \"// GENERATED FILE:\\n\"\n+        + \"//\\n\"\n+        + \"// DO NOT EDIT!\\n\"\n+        + \"//\\n\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"class Taco {\\n\"\n+        + \"}\\n\");\n+  }\n }\n"
    },
    {
        "commit_hash": "baffcdefe625de141450cacec1af0d9dd0e7c561",
        "previous_commit_hash": "33ce3e1ce4467ea8cc3a790709f742c1f9db0b41",
        "diff_stats": {
            "additions": 0,
            "deletions": 2
        },
        "diff_content": "@@ -21,8 +21,6 @@ elif [ \"$TRAVIS_BRANCH\" != \"$BRANCH\" ]; then\n   echo \"Skipping snapshot deployment: wrong branch. Expected '$BRANCH' but was '$TRAVIS_BRANCH'.\"\n else\n   echo \"Deploying snapshot...\"\n-  # make sure we use the appropriate JDK (it might have been changed during the build)\n-  jdk_switcher use $JDK\n   mvn clean source:jar javadoc:jar deploy --settings=\".buildscript/settings.xml\" -Dmaven.test.skip=true\n   echo \"Snapshot deployed!\"\n fi\n"
    },
    {
        "commit_hash": "baffcdefe625de141450cacec1af0d9dd0e7c561",
        "previous_commit_hash": "33ce3e1ce4467ea8cc3a790709f742c1f9db0b41",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -8,7 +8,7 @@ script:\n   - jdk_switcher use openjdk7 && mvn surefire:test -B\n \n after_success:\n-  - .buildscript/deploy_snapshot.sh\n+  - jdk_switcher use oraclejdk8 && .buildscript/deploy_snapshot.sh\n \n env:\n   global:\n"
    },
    {
        "commit_hash": "5bbf088af3c63a7017210d53b2b1908db79b8506",
        "previous_commit_hash": "baffcdefe625de141450cacec1af0d9dd0e7c561",
        "diff_stats": {
            "additions": 31,
            "deletions": 31
        },
        "diff_content": "@@ -34,7 +34,7 @@ import javax.lang.model.type.TypeMirror;\n import org.junit.Rule;\n import org.junit.Test;\n \n-import static com.google.common.truth.Truth.assert_;\n+import static com.google.common.truth.Truth.assertThat;\n \n public final class TypesTest {\n   @Rule public final CompilationRule compilation = new CompilationRule();\n@@ -48,18 +48,18 @@ public final class TypesTest {\n   }\n \n   @Test public void getBasicTypeMirror() {\n-    assert_().that(Types.get(getType(Object.class)))\n+    assertThat(Types.get(getType(Object.class)))\n         .isEqualTo(ClassName.get(Object.class));\n-    assert_().that(Types.get(getType(Charset.class)))\n+    assertThat(Types.get(getType(Charset.class)))\n         .isEqualTo(ClassName.get(Charset.class));\n-    assert_().that(Types.get(getType(TypesTest.class)))\n+    assertThat(Types.get(getType(TypesTest.class)))\n         .isEqualTo(ClassName.get(TypesTest.class));\n   }\n \n   @Test public void getParameterizedTypeMirror() {\n     DeclaredType setType =\n         compilation.getTypes().getDeclaredType(getElement(Set.class), getType(Object.class));\n-    assert_().that(Types.get(setType))\n+    assertThat(Types.get(setType))\n         .isEqualTo(Types.parameterizedType(ClassName.get(Set.class), ClassName.OBJECT));\n   }\n \n@@ -75,17 +75,17 @@ public final class TypesTest {\n     List<? extends TypeParameterElement> typeVariables =\n         getElement(Parameterized.class).getTypeParameters();\n \n-    assert_().that(Types.get(typeVariables.get(0).asType()))\n+    assertThat(Types.get(typeVariables.get(0).asType()))\n         .isEqualTo(Types.typeVariable(\"Simple\"));\n-    assert_().that(Types.get(typeVariables.get(1).asType()))\n+    assertThat(Types.get(typeVariables.get(1).asType()))\n         .isEqualTo(Types.typeVariable(\"ExtendsClass\", Number.class));\n-    assert_().that(Types.get(typeVariables.get(2).asType()))\n+    assertThat(Types.get(typeVariables.get(2).asType()))\n         .isEqualTo(Types.typeVariable(\"ExtendsInterface\", Runnable.class));\n-    assert_().that(Types.get(typeVariables.get(3).asType()))\n+    assertThat(Types.get(typeVariables.get(3).asType()))\n         .isEqualTo(Types.typeVariable(\"ExtendsTypeVariable\", Types.typeVariable(\"Simple\")));\n-    assert_().that(Types.get(typeVariables.get(4).asType()))\n+    assertThat(Types.get(typeVariables.get(4).asType()))\n         .isEqualTo(Types.typeVariable(\"Intersection\", Number.class, Runnable.class));\n-    assert_().that(Types.get(typeVariables.get(5).asType()))\n+    assertThat(Types.get(typeVariables.get(5).asType()))\n         .isEqualTo(Types.typeVariable(\"IntersectionOfInterfaces\",\n             Runnable.class, Serializable.class));\n   }\n@@ -99,78 +99,78 @@ public final class TypesTest {\n     if (bounds.length == 1) {\n       // Java 8.\n       IntersectionType intersectionType = (IntersectionType) bounds[0];\n-      assert_().that(intersectionType.getBounds()).asList()\n+      assertThat(intersectionType.getBounds()).asList()\n           .containsExactly(ClassName.get(Number.class), ClassName.get(Runnable.class));\n-      assert_().that(intersectionType.toString())\n+      assertThat(intersectionType.toString())\n           .isEqualTo(\"java.lang.Number & java.lang.Runnable\");\n     } else {\n       // Java \u2264 7.\n-      assert_().that(bounds).asList()\n+      assertThat(bounds).asList()\n           .containsExactly(ClassName.get(Number.class), ClassName.get(Runnable.class));\n     }\n   }\n \n   @Test public void getPrimitiveTypeMirror() {\n-    assert_().that(Types.get(compilation.getTypes().getPrimitiveType(TypeKind.BOOLEAN)))\n+    assertThat(Types.get(compilation.getTypes().getPrimitiveType(TypeKind.BOOLEAN)))\n         .isEqualTo(boolean.class);\n-    assert_().that(Types.get(compilation.getTypes().getPrimitiveType(TypeKind.BYTE)))\n+    assertThat(Types.get(compilation.getTypes().getPrimitiveType(TypeKind.BYTE)))\n         .isEqualTo(byte.class);\n-    assert_().that(Types.get(compilation.getTypes().getPrimitiveType(TypeKind.SHORT)))\n+    assertThat(Types.get(compilation.getTypes().getPrimitiveType(TypeKind.SHORT)))\n         .isEqualTo(short.class);\n-    assert_().that(Types.get(compilation.getTypes().getPrimitiveType(TypeKind.INT)))\n+    assertThat(Types.get(compilation.getTypes().getPrimitiveType(TypeKind.INT)))\n         .isEqualTo(int.class);\n-    assert_().that(Types.get(compilation.getTypes().getPrimitiveType(TypeKind.LONG)))\n+    assertThat(Types.get(compilation.getTypes().getPrimitiveType(TypeKind.LONG)))\n         .isEqualTo(long.class);\n-    assert_().that(Types.get(compilation.getTypes().getPrimitiveType(TypeKind.CHAR)))\n+    assertThat(Types.get(compilation.getTypes().getPrimitiveType(TypeKind.CHAR)))\n         .isEqualTo(char.class);\n-    assert_().that(Types.get(compilation.getTypes().getPrimitiveType(TypeKind.FLOAT)))\n+    assertThat(Types.get(compilation.getTypes().getPrimitiveType(TypeKind.FLOAT)))\n         .isEqualTo(float.class);\n-    assert_().that(Types.get(compilation.getTypes().getPrimitiveType(TypeKind.DOUBLE)))\n+    assertThat(Types.get(compilation.getTypes().getPrimitiveType(TypeKind.DOUBLE)))\n         .isEqualTo(double.class);\n   }\n \n   @Test public void getArrayTypeMirror() {\n-    assert_().that(Types.get(compilation.getTypes().getArrayType(getType(Object.class))))\n+    assertThat(Types.get(compilation.getTypes().getArrayType(getType(Object.class))))\n         .isEqualTo(Types.arrayOf(ClassName.OBJECT));\n   }\n \n   @Test public void getVoidTypeMirror() {\n-    assert_().that(Types.get(compilation.getTypes().getNoType(TypeKind.VOID)))\n+    assertThat(Types.get(compilation.getTypes().getNoType(TypeKind.VOID)))\n         .isEqualTo(void.class);\n   }\n \n   @Test public void getNullTypeMirror() {\n-    assert_().that(Types.get(compilation.getTypes().getNullType()))\n+    assertThat(Types.get(compilation.getTypes().getNullType()))\n         .isEqualTo(Types.NULL);\n   }\n \n   @Test public void parameterizedType() throws Exception {\n     ParameterizedType type = Types.parameterizedType(Map.class, String.class, Long.class);\n-    assert_().that(type.toString()).isEqualTo(\"java.util.Map<java.lang.String, java.lang.Long>\");\n+    assertThat(type.toString()).isEqualTo(\"java.util.Map<java.lang.String, java.lang.Long>\");\n   }\n \n   @Test public void arrayType() throws Exception {\n     GenericArrayType type = Types.arrayOf(String.class);\n-    assert_().that(type.toString()).isEqualTo(\"java.lang.String[]\");\n+    assertThat(type.toString()).isEqualTo(\"java.lang.String[]\");\n   }\n \n   @Test public void wildcardExtendsType() throws Exception {\n     WildcardType type = Types.subtypeOf(CharSequence.class);\n-    assert_().that(type.toString()).isEqualTo(\"? extends java.lang.CharSequence\");\n+    assertThat(type.toString()).isEqualTo(\"? extends java.lang.CharSequence\");\n   }\n \n   @Test public void wildcardExtendsObject() throws Exception {\n     WildcardType type = Types.subtypeOf(Object.class);\n-    assert_().that(type.toString()).isEqualTo(\"?\");\n+    assertThat(type.toString()).isEqualTo(\"?\");\n   }\n \n   @Test public void wildcardSuperType() throws Exception {\n     WildcardType type = Types.supertypeOf(String.class);\n-    assert_().that(type.toString()).isEqualTo(\"? super java.lang.String\");\n+    assertThat(type.toString()).isEqualTo(\"? super java.lang.String\");\n   }\n \n   @Test public void typeVariable() throws Exception {\n     TypeVariable<?> type = Types.typeVariable(\"T\", CharSequence.class);\n-    assert_().that(type.toString()).isEqualTo(\"T\"); // (Bounds are only emitted in declaration.)\n+    assertThat(type.toString()).isEqualTo(\"T\"); // (Bounds are only emitted in declaration.)\n   }\n }\n"
    },
    {
        "commit_hash": "111a082132124242073a6ed82b3e94a5950dbc84",
        "previous_commit_hash": "5bbf088af3c63a7017210d53b2b1908db79b8506",
        "diff_stats": {
            "additions": 8,
            "deletions": 9
        },
        "diff_content": "@@ -21,7 +21,6 @@ import com.google.common.base.Splitter;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Iterables;\n-import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n import java.lang.reflect.Type;\n import java.util.ArrayList;\n@@ -50,7 +49,7 @@ public final class ClassName implements Type, Comparable<ClassName> {\n \n   private ClassName(List<String> names) {\n     for (int i = 1; i < names.size(); i++) {\n-      checkArgument(SourceVersion.isName(names.get(i)));\n+      checkArgument(SourceVersion.isName(names.get(i)), \"part '%s' is keyword\", names.get(i));\n     }\n     this.names = ImmutableList.copyOf(names);\n     this.canonicalName = Joiner.on(\".\").join(names.get(0).isEmpty()\n@@ -82,11 +81,11 @@ public final class ClassName implements Type, Comparable<ClassName> {\n   }\n \n   public static ClassName get(Class<?> clazz) {\n-    checkNotNull(clazz);\n-    checkArgument(!clazz.isPrimitive(), \"Primitive types cannot be represented as a ClassName.\");\n-    checkArgument(!void.class.equals(clazz), \"'void' type cannot be represented as a ClassName.\");\n-    checkArgument(!clazz.isArray(), \"Array types cannot be represented as a ClassName.\");\n-    List<String> names = Lists.newArrayList();\n+    checkNotNull(clazz, \"clazz == null\");\n+    checkArgument(!clazz.isPrimitive(), \"primitive types cannot be represented as a ClassName\");\n+    checkArgument(!void.class.equals(clazz), \"'void' type cannot be represented as a ClassName\");\n+    checkArgument(!clazz.isArray(), \"array types cannot be represented as a ClassName\");\n+    List<String> names = new ArrayList<>();\n     for (Class<?> c = clazz; c != null; c = c.getEnclosingClass()) {\n       names.add(c.getSimpleName());\n     }\n@@ -142,8 +141,8 @@ public final class ClassName implements Type, Comparable<ClassName> {\n \n   /** Returns the class name for {@code element}. */\n   public static ClassName get(TypeElement element) {\n-    checkNotNull(element);\n-    List<String> names = Lists.newArrayList();\n+    checkNotNull(element, \"element == null\");\n+    List<String> names = new ArrayList<>();\n     for (Element e = element; isClassOrInterface(e); e = e.getEnclosingElement()) {\n       checkArgument(ACCEPTABLE_NESTING_KINDS.contains(element.getNestingKind()));\n       names.add(e.getSimpleName().toString());\n"
    },
    {
        "commit_hash": "111a082132124242073a6ed82b3e94a5950dbc84",
        "previous_commit_hash": "5bbf088af3c63a7017210d53b2b1908db79b8506",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -420,7 +420,7 @@ final class CodeWriter {\n \n   private Type toType(Object arg) {\n     if (arg instanceof Type) return (Type) arg;\n-    throw new IllegalArgumentException(\"Expected type but was \" + arg);\n+    throw new IllegalArgumentException(\"expected type but was \" + arg);\n   }\n \n   private void emitName(Object o) throws IOException {\n@@ -433,7 +433,7 @@ final class CodeWriter {\n     if (o instanceof FieldSpec) return ((FieldSpec) o).name;\n     if (o instanceof MethodSpec) return ((MethodSpec) o).name;\n     if (o instanceof TypeSpec) return ((TypeSpec) o).name;\n-    throw new IllegalArgumentException(\"Expected name but was \" + o);\n+    throw new IllegalArgumentException(\"expected name but was \" + o);\n   }\n \n   /**\n"
    },
    {
        "commit_hash": "111a082132124242073a6ed82b3e94a5950dbc84",
        "previous_commit_hash": "5bbf088af3c63a7017210d53b2b1908db79b8506",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -38,8 +38,8 @@ public final class FieldSpec {\n   public final Snippet initializer;\n \n   private FieldSpec(Builder builder) {\n-    this.type = checkNotNull(builder.type);\n-    this.name = checkNotNull(builder.name);\n+    this.type = checkNotNull(builder.type, \"type == null\");\n+    this.name = checkNotNull(builder.name, \"name == null\");\n     this.javadocSnippets = ImmutableList.copyOf(builder.javadocSnippets);\n     this.annotations = ImmutableList.copyOf(builder.annotations);\n     this.modifiers = ImmutableSet.copyOf(builder.modifiers);\n"
    },
    {
        "commit_hash": "111a082132124242073a6ed82b3e94a5950dbc84",
        "previous_commit_hash": "5bbf088af3c63a7017210d53b2b1908db79b8506",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -41,7 +41,7 @@ public final class JavaFile {\n   private JavaFile(Builder builder) {\n     this.fileComment = builder.fileComment;\n     this.packageName = builder.packageName;\n-    this.typeSpec = checkNotNull(builder.typeSpec);\n+    this.typeSpec = checkNotNull(builder.typeSpec, \"typeSpec == null\");\n   }\n \n   public void emit(Appendable out) throws IOException {\n"
    },
    {
        "commit_hash": "111a082132124242073a6ed82b3e94a5950dbc84",
        "previous_commit_hash": "5bbf088af3c63a7017210d53b2b1908db79b8506",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -48,7 +48,7 @@ public final class JavaWriter {\n \n   public void writeTo(Path directory) throws IOException {\n     checkArgument(Files.notExists(directory) || Files.isDirectory(directory),\n-        \"Path %s exists but is not a directory.\", directory);\n+        \"path %s exists but is not a directory.\", directory);\n     for (JavaFile javaFile : javaFiles) {\n       String packageName = javaFile.packageName;\n \n"
    },
    {
        "commit_hash": "111a082132124242073a6ed82b3e94a5950dbc84",
        "previous_commit_hash": "5bbf088af3c63a7017210d53b2b1908db79b8506",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -53,7 +53,7 @@ public final class MethodSpec {\n     checkArgument(!builder.varargs || lastParameterIsArray(builder.parameters),\n         \"last parameter of varargs method %s must be an array\", builder.name);\n \n-    this.name = checkNotNull(builder.name);\n+    this.name = checkNotNull(builder.name, \"name == null\");\n     this.javadocSnippets = ImmutableList.copyOf(builder.javadocSnippets);\n     this.annotations = ImmutableList.copyOf(builder.annotations);\n     this.modifiers = ImmutableSet.copyOf(builder.modifiers);\n@@ -178,7 +178,7 @@ public final class MethodSpec {\n     }\n \n     public Builder returns(Type returnType) {\n-      checkState(!name.equals(CONSTRUCTOR));\n+      checkState(!name.equals(CONSTRUCTOR), \"constructor cannot have return type.\");\n       this.returnType = returnType;\n       return this;\n     }\n"
    },
    {
        "commit_hash": "111a082132124242073a6ed82b3e94a5950dbc84",
        "previous_commit_hash": "5bbf088af3c63a7017210d53b2b1908db79b8506",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -36,10 +36,10 @@ public final class ParameterSpec {\n   public final Type type;\n \n   private ParameterSpec(Builder builder) {\n-    this.name = checkNotNull(builder.name);\n+    this.name = checkNotNull(builder.name, \"name == null\");\n     this.annotations = ImmutableList.copyOf(builder.annotations);\n     this.modifiers = ImmutableSet.copyOf(builder.modifiers);\n-    this.type = checkNotNull(builder.type);\n+    this.type = checkNotNull(builder.type, \"type == null\");\n   }\n \n   public boolean hasModifier(Modifier modifier) {\n"
    },
    {
        "commit_hash": "111a082132124242073a6ed82b3e94a5950dbc84",
        "previous_commit_hash": "5bbf088af3c63a7017210d53b2b1908db79b8506",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -82,7 +82,7 @@ public final class TypeSpec {\n     checkArgument(builder.anonymousTypeArguments == null || interestingSupertypeCount <= 1,\n         \"anonymous type has too many supertypes\");\n \n-    this.declarationType = checkNotNull(builder.declarationType);\n+    this.declarationType = checkNotNull(builder.declarationType, \"declarationType == null\");\n     this.name = builder.name;\n     this.anonymousTypeArguments = builder.anonymousTypeArguments;\n     this.javadocSnippets = ImmutableList.copyOf(builder.javadocSnippets);\n@@ -307,7 +307,7 @@ public final class TypeSpec {\n     }\n \n     public Builder addEnumConstant(String name, TypeSpec typeSpec) {\n-      checkState(declarationType == DeclarationType.ENUM);\n+      checkState(declarationType == DeclarationType.ENUM, \"type is not enum\");\n       checkArgument(typeSpec.anonymousTypeArguments != null,\n           \"enum constants must have anonymous type arguments\");\n       checkArgument(SourceVersion.isName(name), \"not a valid enum constant: %s\", name);\n"
    },
    {
        "commit_hash": "111a082132124242073a6ed82b3e94a5950dbc84",
        "previous_commit_hash": "5bbf088af3c63a7017210d53b2b1908db79b8506",
        "diff_stats": {
            "additions": 4,
            "deletions": 3
        },
        "diff_content": "@@ -112,7 +112,7 @@ public final class Types {\n \n   /** Returns an array type whose elements are all instances of {@code componentType}. */\n   public static GenericArrayType arrayOf(final Type componentType) {\n-    checkNotNull(componentType);\n+    checkNotNull(componentType, \"componentType == null\");\n \n     return new GenericArrayType() {\n       @Override public Type getGenericComponentType() {\n@@ -339,8 +339,9 @@ public final class Types {\n   }\n \n   private static void checkNotPrimitive(Type type) {\n-    checkNotNull(type);\n-    checkArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());\n+    checkNotNull(type, \"type cannot be primitive.\");\n+    checkArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive(),\n+        \"type cannot be primitive.\");\n   }\n \n   private static String typeToString(Type type) {\n"
    },
    {
        "commit_hash": "111a082132124242073a6ed82b3e94a5950dbc84",
        "previous_commit_hash": "5bbf088af3c63a7017210d53b2b1908db79b8506",
        "diff_stats": {
            "additions": 6,
            "deletions": 2
        },
        "diff_content": "@@ -29,6 +29,7 @@ import org.junit.rules.TemporaryFolder;\n import org.mockito.Mockito;\n \n import static com.google.common.truth.Truth.assertThat;\n+import static org.junit.Assert.fail;\n \n public final class JavaWriterTest {\n   private final JavaWriter javaWriter = new JavaWriter();\n@@ -49,17 +50,20 @@ public final class JavaWriterTest {\n     Files.createFile(path);\n     try {\n       javaWriter.writeTo(path);\n+      fail();\n     } catch (IllegalArgumentException e) {\n-      assertThat(e.getMessage()).isEqualTo(\"Path /foo/bar exists but is not a directory.\");\n+      assertThat(e.getMessage()).isEqualTo(\"path /foo/bar exists but is not a directory.\");\n     }\n   }\n \n   @Test public void fileNotDirectory() throws IOException {\n     File file = new File(tmp.newFolder(\"foo\"), \"bar\");\n+    file.createNewFile();\n     try {\n       javaWriter.writeTo(file);\n+      fail();\n     } catch (IllegalArgumentException e) {\n-      assertThat(e.getMessage()).containsMatch(\"File .*?/foo/bar exists but is not a directory.\");\n+      assertThat(e.getMessage()).containsMatch(\"path .*?/foo/bar exists but is not a directory.\");\n     }\n   }\n \n"
    },
    {
        "commit_hash": "1b7d009eaeef8d2d78d976493c80ebc59d34a01f",
        "previous_commit_hash": "b85a6bb9def99945c521b173c6c5b067cd85323e",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -5,7 +5,7 @@\n # Adapted from https://coderwall.com/p/9b_lfq and\n # http://benlimmer.com/2013/12/26/automatically-publish-javadoc-to-gh-pages-with-travis-ci/\n \n-SLUG=\"square/javawriter\"\n+SLUG=\"square/javapoet\"\n JDK=\"oraclejdk8\"\n BRANCH=\"master\"\n \n"
    },
    {
        "commit_hash": "1b7d009eaeef8d2d78d976493c80ebc59d34a01f",
        "previous_commit_hash": "b85a6bb9def99945c521b173c6c5b067cd85323e",
        "diff_stats": {
            "additions": 29,
            "deletions": 19
        },
        "diff_content": "@@ -1,7 +1,17 @@\n Change Log\n ==========\n \n-Version 2.5.1 *(2014-12-03)*\n+JavaPoet 1.0.0 *(unreleased)*\n+----------------------------\n+\n+ * Project name is now `javapoet`. We renamed the project so you could simultaneously\n+   use the old JavaWriter API and our new builder-based APIs in one project.\n+ * Package name is now `com.squareup.javapoet`.\n+ * Builders.\n+ * Automatic imports.\n+\n+\n+JavaWriter 2.5.1 *(2014-12-03)*\n ----------------------------\n \n  * New: `StringLiteral` type which encapsulates the behavior of `stringLiteral`.\n@@ -10,7 +20,7 @@ Version 2.5.1 *(2014-12-03)*\n  * Fix: Restore binary compatibility with pre-2.5 versions.\n \n \n-Version 2.5.0 *(2014-04-18)*\n+JavaWriter 2.5.0 *(2014-04-18)*\n ----------------------------\n \n  * New: Methods in interfaces will always have no body declaration.\n@@ -19,20 +29,20 @@ Version 2.5.0 *(2014-04-18)*\n  * Fix: Do not emit trailing whitespace after '=' at end-of-line.\n \n \n-Version 2.4.0 *(2014-01-10)*\n+JavaWriter 2.4.0 *(2014-01-10)*\n ----------------------------\n \n  * New: Properly indent hanging lines in field initializers.\n  * New: `emitEnumValue` variant which exposes a boolean of whether the current value is the last.\n \n \n-Version 2.3.1 *(2013-12-16)*\n+JavaWriter 2.3.1 *(2013-12-16)*\n ----------------------------\n \n  * Fix: Properly handle subpackages of `java.lang` in `compressType`.\n \n \n-Version 2.3.0 *(2013-11-24)*\n+JavaWriter 2.3.0 *(2013-11-24)*\n ----------------------------\n \n  * New: Configurable indent level via `setIndent`.\n@@ -42,83 +52,83 @@ Version 2.3.0 *(2013-11-24)*\n  * Previously-deprecated, `int`-based modifier methods have been removed.\n \n \n-Version 2.2.1 *(2013-10-23)*\n+JavaWriter 2.2.1 *(2013-10-23)*\n ----------------------------\n \n  * Fix: Do not emit trailing whitespace for empty Javadoc lines.\n \n \n-Version 2.2.0 *(2013-09-25)*\n+JavaWriter 2.2.0 *(2013-09-25)*\n ----------------------------\n \n  * `setCompressingTypes` controls whether types are emitted as fully-qualified or not.\n \n \n-Version 2.1.2 *(2013-08-23)*\n+JavaWriter 2.1.2 *(2013-08-23)*\n ----------------------------\n \n  * Attempt to keep annotations on a single line.\n \n \n-Version 2.1.1 *(2013-07-23)*\n+JavaWriter 2.1.1 *(2013-07-23)*\n ----------------------------\n \n  * Fix: `stringLiteral` now correctly handles escapes and control characters.\n \n \n-Version 2.1.0 *(2013-07-15)*\n+JavaWriter 2.1.0 *(2013-07-15)*\n ----------------------------\n \n  * New: All methods now take a `Set` of `Modifier`s rather than an `int`. The `int` methods are\n-   now deprecated for removal in version 3.0.\n+   now deprecated for removal in JavaPoet 1.0.\n  * Annotations with a single \"value\" attribute will now omit the key.\n \n \n-Version 2.0.1 *(2013-06-17)*\n+JavaWriter 2.0.1 *(2013-06-17)*\n ----------------------------\n \n  * Correct casing of `emitSingleLineComment`.\n \n \n-Version 2.0.0 *(2013-06-06)*\n+JavaWriter 2.0.0 *(2013-06-06)*\n ----------------------------\n \n  * Package name is now `com.squareup.javawriter`.\n  * Support declaring `throws` clause on methods.\n \n \n-Version 1.0.5 *(2013-05-08)*\n+JavaWriter 1.0.5 *(2013-05-08)*\n ----------------------------\n \n  * Fix: Fully qualify types whose simple name matches an import.\n \n \n-Version 1.0.4 *(2013-03-15)*\n+JavaWriter 1.0.4 *(2013-03-15)*\n ----------------------------\n \n  * Fix: Static import emit now properly supports method imports.\n \n \n-Version 1.0.3 *(2013-02-21)*\n+JavaWriter 1.0.3 *(2013-02-21)*\n -----------------------------\n \n  * Add support for emitting static imports.\n \n \n-Version 1.0.2 *(2013-02-11)*\n+JavaWriter 1.0.2 *(2013-02-11)*\n ----------------------------\n \n  * Add `type` API for helping build generic types.\n  * Minor performance improvements.\n \n \n-Version 1.0.1 *(2013-02-03)*\n+JavaWriter 1.0.1 *(2013-02-03)*\n ----------------------------\n \n  * Expose `compressType` API.\n \n \n-Version 1.0.0 *(2013-02-01)*\n+JavaWriter 1.0.0 *(2013-02-01)*\n ----------------------------\n \n Initial release.\n"
    },
    {
        "commit_hash": "1b7d009eaeef8d2d78d976493c80ebc59d34a01f",
        "previous_commit_hash": "b85a6bb9def99945c521b173c6c5b067cd85323e",
        "diff_stats": {
            "additions": 37,
            "deletions": 27
        },
        "diff_content": "@@ -1,7 +1,7 @@\n-Java Writer\n-===========\n+JavaPoet\n+========\n \n-`JavaWriter` is a utility class which aids in generating Java source files.\n+`JavaPoet` is a Java API for generating `.java` source files.\n \n Source file generation can useful when doing things such as annotation processing or interacting\n with metadata files (e.g., database schemas, protocol formats). By generating code, you eliminate\n@@ -13,30 +13,40 @@ Example\n -------\n \n ```java\n-writer.emitPackage(\"com.example\")\n-    .beginType(\"com.example.Person\", \"class\", EnumSet.of(PUBLIC, FINAL))\n-    .emitField(\"String\", \"firstName\", EnumSet.of(PRIVATE))\n-    .emitField(\"String\", \"lastName\", EnumSet.of(PRIVATE))\n-    .emitJavadoc(\"Returns the person's full name.\")\n-    .beginMethod(\"String\", \"getName\", EnumSet.of(PUBLIC))\n-    .emitStatement(\"return firstName + \\\" \\\" + lastName\")\n-    .endMethod()\n-    .endType();\n+TypeSpec raven = TypeSpec.classBuilder(\"Raven\")\n+    .addModifiers(Modifier.PUBLIC, Modifier.FINAL)\n+    .addMethod(MethodSpec.methodBuilder(\"main\")\n+        .addModifiers(Modifier.PUBLIC)\n+        .addCode(\"$T verses = new $T<>();\\n\",\n+            Types.parameterizedType(List.class, String.class),\n+            Types.parameterizedType(ArrayList.class, String.class))\n+        .addCode(\"verses.add($S);\\n\",\n+            \"Once upon a midnight dreary, while I pondered, weak and weary...\")\n+        .addCode(\"verses.add($S);\\n\",\n+            \"Over many a quaint and curious volume of forgotten lore\u2014\")\n+        .addCode(\"return verses;\\n\")\n+        .build())\n+    .build();\n+JavaFile ravenSourceFile = new JavaFile.Builder()\n+    .packageName(\"com.squareup.poe\")\n+    .typeSpec(raven)\n+    .build();\n ```\n \n Would produce the following source output:\n \n ```java\n-package com.example;\n-\n-public final class Person {\n-  private String firstName;\n-  private String lastName;\n-  /**\n-   * Returns the person's full name.\n-   */\n-  public String getName() {\n-    return firstName + \" \" + lastName;\n+package com.squareup.poe;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public final class Raven {\n+  public void main() {\n+    List<String> verses = new ArrayList<String><>();\n+    verses.add(\"Once upon a midnight dreary, while I pondered, weak and weary...\");\n+    verses.add(\"Over many a quaint and curious volume of forgotten lore\u2014\");\n+    return verses;\n   }\n }\n ```\n@@ -50,13 +60,13 @@ Download [the latest .jar][dl] or depend via Maven:\n ```xml\n <dependency>\n   <groupId>com.squareup</groupId>\n-  <artifactId>javawriter</artifactId>\n-  <version>2.5.1</version>\n+  <artifactId>javapoet</artifactId>\n+  <version>1.0.0</version>\n </dependency>\n ```\n or Gradle:\n ```groovy\n-compile 'com.squareup:javawriter:2.5.1'\n+compile 'com.squareup:javapoet:1.0.0'\n ```\n \n Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].\n@@ -66,7 +76,7 @@ Snapshots of the development version are available in [Sonatype's `snapshots` re\n License\n -------\n \n-    Copyright 2013 Square, Inc.\n+    Copyright 2015 Square, Inc.\n \n     Licensed under the Apache License, Version 2.0 (the \"License\");\n     you may not use this file except in compliance with the License.\n@@ -82,5 +92,5 @@ License\n \n \n \n- [dl]: https://search.maven.org/remote_content?g=com.squareup&a=javawriter&v=LATEST\n+ [dl]: https://search.maven.org/remote_content?g=com.squareup&a=javapoet&v=LATEST\n  [snap]: https://oss.sonatype.org/content/repositories/snapshots/\n"
    },
    {
        "commit_hash": "1b7d009eaeef8d2d78d976493c80ebc59d34a01f",
        "previous_commit_hash": "b85a6bb9def99945c521b173c6c5b067cd85323e",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -2,9 +2,9 @@\n \n set -ex\n \n-REPO=\"git@github.com:square/javawriter.git\"\n+REPO=\"git@github.com:square/javapoet.git\"\n GROUP_ID=\"com.squareup\"\n-ARTIFACT_ID=\"javawriter\"\n+ARTIFACT_ID=\"javapoet\"\n \n DIR=temp-clone\n \n"
    },
    {
        "commit_hash": "1b7d009eaeef8d2d78d976493c80ebc59d34a01f",
        "previous_commit_hash": "b85a6bb9def99945c521b173c6c5b067cd85323e",
        "diff_stats": {
            "additions": 9,
            "deletions": 9
        },
        "diff_content": "@@ -10,12 +10,12 @@\n   </parent>\n \n   <groupId>com.squareup</groupId>\n-  <artifactId>javawriter</artifactId>\n-  <version>3.0.0-SNAPSHOT</version>\n+  <artifactId>javapoet</artifactId>\n+  <version>1.0.0-SNAPSHOT</version>\n \n-  <name>JavaWriter</name>\n-  <description>A utility class which aids in generating Java source files.</description>\n-  <url>http://github.com/square/javawriter/</url>\n+  <name>JavaPoet</name>\n+  <description>Use beautiful Java code to generate beautiful Java code.</description>\n+  <url>http://github.com/square/javapoet/</url>\n \n   <properties>\n     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n@@ -28,15 +28,15 @@\n   </properties>\n \n   <scm>\n-    <url>http://github.com/square/javawriter/</url>\n-    <connection>scm:git:git://github.com/square/javawriter.git</connection>\n-    <developerConnection>scm:git:ssh://git@github.com/square/javawriter.git</developerConnection>\n+    <url>http://github.com/square/javapoet/</url>\n+    <connection>scm:git:git://github.com/square/javapoet.git</connection>\n+    <developerConnection>scm:git:ssh://git@github.com/square/javapoet.git</developerConnection>\n     <tag>HEAD</tag>\n   </scm>\n \n   <issueManagement>\n     <system>GitHub Issues</system>\n-    <url>http://github.com/square/javawriter/issues</url>\n+    <url>http://github.com/square/javapoet/issues</url>\n   </issueManagement>\n \n   <licenses>\n"
    },
    {
        "commit_hash": "3b302bd79ea75e22e21abf61d2366785d5d8d1c7",
        "previous_commit_hash": "29e2cdd0b69da1d212ab2b21e58f0885a0ec9235",
        "diff_stats": {
            "additions": 4,
            "deletions": 4
        },
        "diff_content": "@@ -17,14 +17,14 @@ TypeSpec raven = TypeSpec.classBuilder(\"Raven\")\n     .addModifiers(Modifier.PUBLIC, Modifier.FINAL)\n     .addMethod(MethodSpec.methodBuilder(\"main\")\n         .addModifiers(Modifier.PUBLIC)\n-        .addCode(\"$T verses = new $T<>();\\n\",\n+        .addCode(\"$T verses = new $T();\\n\",\n             Types.parameterizedType(List.class, String.class),\n             Types.parameterizedType(ArrayList.class, String.class))\n         .addCode(\"verses.add($S);\\n\",\n             \"Once upon a midnight dreary, while I pondered, weak and weary...\")\n         .addCode(\"verses.add($S);\\n\",\n             \"Over many a quaint and curious volume of forgotten lore\u2014\")\n-        .addCode(\"return verses;\\n\")\n+        .addCode(\"System.out.println(verses);\\n\")\n         .build())\n     .build();\n JavaFile ravenSourceFile = new JavaFile.Builder()\n@@ -43,10 +43,10 @@ import java.util.List;\n \n public final class Raven {\n   public void main() {\n-    List<String> verses = new ArrayList<String><>();\n+    List<String> verses = new ArrayList<String>();\n     verses.add(\"Once upon a midnight dreary, while I pondered, weak and weary...\");\n     verses.add(\"Over many a quaint and curious volume of forgotten lore\u2014\");\n-    return verses;\n+    System.out.println(verses);\n   }\n }\n ```\n"
    },
    {
        "commit_hash": "4f6c366c2d18f5e0d359f484ab5ca959b2784bf9",
        "previous_commit_hash": "29e2cdd0b69da1d212ab2b21e58f0885a0ec9235",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -13,7 +13,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package com.squareup.javawriter;\n+package com.squareup.javapoet;\n \n import com.google.common.base.Supplier;\n import com.google.common.collect.ImmutableListMultimap;\n"
    },
    {
        "commit_hash": "4f6c366c2d18f5e0d359f484ab5ca959b2784bf9",
        "previous_commit_hash": "29e2cdd0b69da1d212ab2b21e58f0885a0ec9235",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -13,7 +13,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package com.squareup.javawriter;\n+package com.squareup.javapoet;\n \n import com.google.common.base.Ascii;\n import com.google.common.base.Joiner;\n"
    },
    {
        "commit_hash": "4f6c366c2d18f5e0d359f484ab5ca959b2784bf9",
        "previous_commit_hash": "29e2cdd0b69da1d212ab2b21e58f0885a0ec9235",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -13,7 +13,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package com.squareup.javawriter;\n+package com.squareup.javapoet;\n \n import com.google.common.base.Ascii;\n import com.google.common.base.Joiner;\n"
    },
    {
        "commit_hash": "4f6c366c2d18f5e0d359f484ab5ca959b2784bf9",
        "previous_commit_hash": "29e2cdd0b69da1d212ab2b21e58f0885a0ec9235",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -13,7 +13,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package com.squareup.javawriter;\n+package com.squareup.javapoet;\n \n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n"
    },
    {
        "commit_hash": "4f6c366c2d18f5e0d359f484ab5ca959b2784bf9",
        "previous_commit_hash": "29e2cdd0b69da1d212ab2b21e58f0885a0ec9235",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -13,7 +13,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package com.squareup.javawriter;\n+package com.squareup.javapoet;\n \n import java.lang.reflect.Type;\n \n"
    },
    {
        "commit_hash": "4f6c366c2d18f5e0d359f484ab5ca959b2784bf9",
        "previous_commit_hash": "29e2cdd0b69da1d212ab2b21e58f0885a0ec9235",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -13,7 +13,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package com.squareup.javawriter;\n+package com.squareup.javapoet;\n \n import com.google.common.collect.ImmutableMap;\n import java.io.IOException;\n"
    },
    {
        "commit_hash": "4f6c366c2d18f5e0d359f484ab5ca959b2784bf9",
        "previous_commit_hash": "29e2cdd0b69da1d212ab2b21e58f0885a0ec9235",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -13,7 +13,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package com.squareup.javawriter;\n+package com.squareup.javapoet;\n \n import com.google.common.collect.Iterables;\n import java.io.File;\n"
    },
    {
        "commit_hash": "4f6c366c2d18f5e0d359f484ab5ca959b2784bf9",
        "previous_commit_hash": "29e2cdd0b69da1d212ab2b21e58f0885a0ec9235",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -13,7 +13,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package com.squareup.javawriter;\n+package com.squareup.javapoet;\n \n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n"
    },
    {
        "commit_hash": "4f6c366c2d18f5e0d359f484ab5ca959b2784bf9",
        "previous_commit_hash": "29e2cdd0b69da1d212ab2b21e58f0885a0ec9235",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -13,7 +13,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package com.squareup.javawriter;\n+package com.squareup.javapoet;\n \n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n"
    },
    {
        "commit_hash": "4f6c366c2d18f5e0d359f484ab5ca959b2784bf9",
        "previous_commit_hash": "29e2cdd0b69da1d212ab2b21e58f0885a0ec9235",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -13,7 +13,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package com.squareup.javawriter;\n+package com.squareup.javapoet;\n \n import com.google.common.collect.ImmutableList;\n import java.util.Arrays;\n"
    },
    {
        "commit_hash": "4f6c366c2d18f5e0d359f484ab5ca959b2784bf9",
        "previous_commit_hash": "29e2cdd0b69da1d212ab2b21e58f0885a0ec9235",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -13,7 +13,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package com.squareup.javawriter;\n+package com.squareup.javapoet;\n \n import com.google.common.base.Ascii;\n import com.google.common.collect.ImmutableList;\n"
    },
    {
        "commit_hash": "4f6c366c2d18f5e0d359f484ab5ca959b2784bf9",
        "previous_commit_hash": "29e2cdd0b69da1d212ab2b21e58f0885a0ec9235",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -13,7 +13,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package com.squareup.javawriter;\n+package com.squareup.javapoet;\n \n import com.google.common.base.Function;\n import com.google.common.base.Objects;\n"
    },
    {
        "commit_hash": "4f6c366c2d18f5e0d359f484ab5ca959b2784bf9",
        "previous_commit_hash": "29e2cdd0b69da1d212ab2b21e58f0885a0ec9235",
        "diff_stats": {
            "additions": 4,
            "deletions": 4
        },
        "diff_content": "@@ -13,7 +13,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package com.squareup.javawriter;\n+package com.squareup.javapoet;\n \n import com.google.testing.compile.CompilationRule;\n import java.util.Map;\n@@ -41,7 +41,7 @@ public final class ClassNameTest {\n     assertThat(ClassName.bestGuess(Map.Entry.class.getCanonicalName()))\n         .isEqualTo(ClassName.get(\"java.util\", \"Map\", \"Entry\"));\n     assertThat(ClassName.bestGuess(OuterClass.InnerClass.class.getCanonicalName()))\n-        .isEqualTo(ClassName.get(\"com.squareup.javawriter\",\n+        .isEqualTo(ClassName.get(\"com.squareup.javapoet\",\n             \"ClassNameTest\", \"OuterClass\", \"InnerClass\"));\n   }\n \n@@ -82,12 +82,12 @@ public final class ClassNameTest {\n     TypeElement element = elements.getTypeElement(Object.class.getCanonicalName());\n     assertThat(ClassName.get(element).toString()).isEqualTo(\"java.lang.Object\");\n   }\n-  \n+\n   @Test public void classNameFromClass() {\n     assertThat(ClassName.get(Object.class).toString())\n         .isEqualTo(\"java.lang.Object\");\n     assertThat(ClassName.get(OuterClass.InnerClass.class).toString())\n-        .isEqualTo(\"com.squareup.javawriter.ClassNameTest.OuterClass.InnerClass\");\n+        .isEqualTo(\"com.squareup.javapoet.ClassNameTest.OuterClass.InnerClass\");\n   }\n \n   @Test public void fromClassRejectionTypes() {\n"
    },
    {
        "commit_hash": "4f6c366c2d18f5e0d359f484ab5ca959b2784bf9",
        "previous_commit_hash": "29e2cdd0b69da1d212ab2b21e58f0885a0ec9235",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -13,7 +13,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package com.squareup.javawriter;\n+package com.squareup.javapoet;\n \n import java.util.Date;\n import javax.lang.model.element.Modifier;\n"
    },
    {
        "commit_hash": "4f6c366c2d18f5e0d359f484ab5ca959b2784bf9",
        "previous_commit_hash": "29e2cdd0b69da1d212ab2b21e58f0885a0ec9235",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -13,7 +13,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package com.squareup.javawriter;\n+package com.squareup.javapoet;\n \n import com.google.common.collect.Iterables;\n import com.google.common.jimfs.Jimfs;\n"
    },
    {
        "commit_hash": "4f6c366c2d18f5e0d359f484ab5ca959b2784bf9",
        "previous_commit_hash": "29e2cdd0b69da1d212ab2b21e58f0885a0ec9235",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -13,7 +13,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package com.squareup.javawriter;\n+package com.squareup.javapoet;\n \n import com.google.common.collect.Iterables;\n import com.google.common.collect.LinkedHashMultimap;\n"
    },
    {
        "commit_hash": "4f6c366c2d18f5e0d359f484ab5ca959b2784bf9",
        "previous_commit_hash": "29e2cdd0b69da1d212ab2b21e58f0885a0ec9235",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -13,7 +13,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package com.squareup.javawriter;\n+package com.squareup.javapoet;\n \n import java.io.IOException;\n import java.io.Serializable;\n"
    },
    {
        "commit_hash": "4f6c366c2d18f5e0d359f484ab5ca959b2784bf9",
        "previous_commit_hash": "29e2cdd0b69da1d212ab2b21e58f0885a0ec9235",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -13,7 +13,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package com.squareup.javawriter;\n+package com.squareup.javapoet;\n \n import com.google.testing.compile.CompilationRule;\n import java.io.Serializable;\n"
    },
    {
        "commit_hash": "5adcb3a5ad57d36bff59c4800b1fd0df14881a41",
        "previous_commit_hash": "dac757a11aeedf297575a7ba23fcde4c63e09cf6",
        "diff_stats": {
            "additions": 9,
            "deletions": 9
        },
        "diff_content": "@@ -36,7 +36,7 @@ import static com.google.common.collect.Iterables.getOnlyElement;\n /** A generated annotation on a declaration. */\n public final class AnnotationSpec {\n   public final Type type;\n-  public final ImmutableMultimap<String, Snippet> members;\n+  public final ImmutableMultimap<String, CodeBlock> members;\n \n   private AnnotationSpec(Builder builder) {\n     this.type = checkNotNull(builder.type, \"type\");\n@@ -65,9 +65,9 @@ public final class AnnotationSpec {\n       //   )\n       codeWriter.emit(\"@$T(\" + whitespace, type);\n       codeWriter.indent(2);\n-      for (Iterator<Map.Entry<String, Collection<Snippet>>> i\n+      for (Iterator<Map.Entry<String, Collection<CodeBlock>>> i\n           = members.asMap().entrySet().iterator(); i.hasNext();) {\n-        Map.Entry<String, Collection<Snippet>> entry = i.next();\n+        Map.Entry<String, Collection<CodeBlock>> entry = i.next();\n         codeWriter.emit(\"$L = \", entry.getKey());\n         emitAnnotationValue(codeWriter, whitespace, memberSeparator, entry.getValue());\n         if (i.hasNext()) codeWriter.emit(memberSeparator);\n@@ -78,7 +78,7 @@ public final class AnnotationSpec {\n   }\n \n   private void emitAnnotationValue(CodeWriter codeWriter, String whitespace, String memberSeparator,\n-      Collection<Snippet> value) throws IOException {\n+      Collection<CodeBlock> value) throws IOException {\n     if (value.size() == 1) {\n       codeWriter.indent(2);\n       codeWriter.emit(getOnlyElement(value));\n@@ -89,9 +89,9 @@ public final class AnnotationSpec {\n     codeWriter.emit(\"{\" + whitespace);\n     codeWriter.indent(2);\n     boolean first = true;\n-    for (Snippet snippet : value) {\n+    for (CodeBlock codeBlock : value) {\n       if (!first) codeWriter.emit(memberSeparator);\n-      codeWriter.emit(snippet);\n+      codeWriter.emit(codeBlock);\n       first = false;\n     }\n     codeWriter.unindent(2);\n@@ -118,15 +118,15 @@ public final class AnnotationSpec {\n \n   public static final class Builder {\n     private final Type type;\n-    private final Multimap<String, Snippet> members = Multimaps.newListMultimap(\n-        new TreeMap<String, Collection<Snippet>>(), AnnotationSpec.<Snippet>listSupplier());\n+    private final Multimap<String, CodeBlock> members = Multimaps.newListMultimap(\n+        new TreeMap<String, Collection<CodeBlock>>(), AnnotationSpec.<CodeBlock>listSupplier());\n \n     private Builder(Type type) {\n       this.type = type;\n     }\n \n     public Builder addMember(String name, String format, Object... args) {\n-      members.put(name, new Snippet(format, args));\n+      members.put(name, CodeBlock.of(format, args));\n       return this;\n     }\n \n"
    },
    {
        "commit_hash": "5adcb3a5ad57d36bff59c4800b1fd0df14881a41",
        "previous_commit_hash": "dac757a11aeedf297575a7ba23fcde4c63e09cf6",
        "diff_stats": {
            "additions": 157,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright (C) 2015 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javapoet;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+/**\n+ * A deferred format string. Unlike {@link java.text.Format} which uses percent {@code %} to escape\n+ * placeholders, this uses {@code $}, and has its own set of permitted placeholders:\n+ *\n+ * <ul>\n+ *   <li>{@code $L} emits the <em>literal</em> value with no escaping.\n+ *   <li>{@code $N} emits a <em>name</em>, using name collision avoidance where necessary.\n+ *   <li>{@code $S} escapes the value as a <em>string</em>, wraps it with double quotes, and emits\n+ *       that.\n+ *   <li>{@code $T} emits a <em>type</em> reference. Types will be imported if possible.\n+ *   <li>{@code $$} emits a dollar sign.\n+ *   <li>{@code $&gt;} increases the indentation level.\n+ *   <li>{@code $&lt;} decreases the indentation level.\n+ * </ul>\n+ */\n+public final class CodeBlock {\n+  /** A heterogeneous list containing string literals and value placeholders. */\n+  final ImmutableList<String> formatParts;\n+  final ImmutableList<Object> args;\n+\n+  private CodeBlock(Builder builder) {\n+    this.formatParts = builder.formatParts.build();\n+    this.args = builder.args.build();\n+  }\n+\n+  public static CodeBlock of(String format, Object... args) {\n+    return new Builder().add(format, args).build();\n+  }\n+\n+  public boolean isEmpty() {\n+    return formatParts.isEmpty();\n+  }\n+\n+  public static final class Builder {\n+    final ImmutableList.Builder<String> formatParts = ImmutableList.builder();\n+    final ImmutableList.Builder<Object> args = ImmutableList.builder();\n+\n+    public Builder add(String format, Object... args) {\n+      int expectedArgsLength = 0;\n+      for (int p = 0, nextP; p < format.length(); p = nextP) {\n+        if (format.charAt(p) != '$') {\n+          nextP = format.indexOf('$', p + 1);\n+          if (nextP == -1) nextP = format.length();\n+        } else {\n+          checkState(p + 1 < format.length(), \"dangling $ in format string %s\", format);\n+          switch (format.charAt(p + 1)) {\n+            case 'L':\n+            case 'N':\n+            case 'S':\n+            case 'T':\n+              expectedArgsLength++;\n+              // Fall through.\n+            case '$':\n+              nextP = p + 2;\n+              break;\n+\n+            default:\n+              throw new IllegalArgumentException(\"invalid format string: \" + format);\n+          }\n+        }\n+\n+        formatParts.add(format.substring(p, nextP));\n+      }\n+\n+      checkArgument(args.length == expectedArgsLength,\n+          \"expected %s args for %s but was %s\", expectedArgsLength, format, args.length);\n+\n+      this.args.add(args);\n+      return this;\n+    }\n+\n+    /**\n+     * @param controlFlow the control flow construct and its code, such as \"if (foo == 5)\".\n+     * Shouldn't contain braces or newline characters.\n+     */\n+    public Builder beginControlFlow(String controlFlow, Object... args) {\n+      add(controlFlow + \" {\\n\", args);\n+      indent();\n+      return this;\n+    }\n+\n+    /**\n+     * @param controlFlow the control flow construct and its code, such as \"else if (foo == 10)\".\n+     *     Shouldn't contain braces or newline characters.\n+     */\n+    public Builder nextControlFlow(String controlFlow, Object... args) {\n+      unindent();\n+      add(\"} \", args);\n+      add(controlFlow, args);\n+      add(\"{\\n\", args);\n+      indent();\n+      return this;\n+    }\n+\n+    public Builder endControlFlow() {\n+      unindent();\n+      add(\"}\\n\");\n+      return this;\n+    }\n+\n+    /**\n+     * @param controlFlow the optional control flow construct and its code, such as\n+     *     \"while(foo == 20)\". Only used for \"do/while\" control flows.\n+     */\n+    public Builder endControlFlow(String controlFlow, Object... args) {\n+      unindent();\n+      add(\"} \" + controlFlow + \";\\n\", args);\n+      return this;\n+    }\n+\n+    public Builder statement(String format, Object... args) {\n+      return add(format + \";\\n\", args);\n+    }\n+\n+    public Builder add(CodeBlock codeBlock) {\n+      formatParts.addAll(codeBlock.formatParts);\n+      args.addAll(codeBlock.args);\n+      return this;\n+    }\n+\n+    public Builder indent() {\n+      this.formatParts.add(\"$>\");\n+      return this;\n+    }\n+\n+    public Builder unindent() {\n+      this.formatParts.add(\"$<\");\n+      return this;\n+    }\n+\n+    public CodeBlock build() {\n+      return new CodeBlock(this);\n+    }\n+  }\n+}\n"
    },
    {
        "commit_hash": "5adcb3a5ad57d36bff59c4800b1fd0df14881a41",
        "previous_commit_hash": "dac757a11aeedf297575a7ba23fcde4c63e09cf6",
        "diff_stats": {
            "additions": 23,
            "deletions": 14
        },
        "diff_content": "@@ -113,26 +113,24 @@ final class CodeWriter {\n     return this;\n   }\n \n-  public void emitComment(Snippet snippet) throws IOException {\n+  public void emitComment(CodeBlock codeBlock) throws IOException {\n     trailingNewline = true; // Force the '//' prefix for the comment.\n     comment = true;\n     try {\n-      emit(snippet);\n+      emit(codeBlock);\n       emit(\"\\n\");\n     } finally {\n       comment = false;\n     }\n   }\n \n-  public void emitJavadoc(ImmutableList<Snippet> javadocSnippets) throws IOException {\n-    if (javadocSnippets.isEmpty()) return;\n+  public void emitJavadoc(CodeBlock javadocCodeBlock) throws IOException {\n+    if (javadocCodeBlock.isEmpty()) return;\n \n     emit(\"/**\\n\");\n     javadoc = true;\n     try {\n-      for (Snippet snippet : javadocSnippets) {\n-        emit(snippet);\n-      }\n+      emit(javadocCodeBlock);\n     } finally {\n       javadoc = false;\n     }\n@@ -190,34 +188,42 @@ final class CodeWriter {\n   }\n \n   public CodeWriter emit(String format, Object... args) throws IOException {\n-    return emit(new Snippet(format, args));\n+    return emit(CodeBlock.of(format, args));\n   }\n \n-  public CodeWriter emit(Snippet snippet) throws IOException {\n+  public CodeWriter emit(CodeBlock codeBlock) throws IOException {\n     int a = 0;\n-    for (String part : snippet.formatParts) {\n+    for (String part : codeBlock.formatParts) {\n       switch (part) {\n         case \"$L\":\n-          emitLiteral(snippet.args.get(a++));\n+          emitLiteral(codeBlock.args.get(a++));\n           break;\n \n         case \"$N\":\n-          emitName(snippet.args.get(a++));\n+          emitName(codeBlock.args.get(a++));\n           break;\n \n         case \"$S\":\n-          String arg = String.valueOf(snippet.args.get(a++));\n+          String arg = String.valueOf(codeBlock.args.get(a++));\n           emitAndIndent(stringLiteral(arg));\n           break;\n \n         case \"$T\":\n-          emitType(snippet.args.get(a++));\n+          emitType(codeBlock.args.get(a++));\n           break;\n \n         case \"$$\":\n           emitAndIndent(\"$\");\n           break;\n \n+        case \"$>\":\n+          indent();\n+          break;\n+\n+        case \"$<\":\n+          unindent();\n+          break;\n+\n         default:\n           emitAndIndent(part);\n           break;\n@@ -233,6 +239,9 @@ final class CodeWriter {\n     } else if (o instanceof AnnotationSpec) {\n       AnnotationSpec annotationSpec = (AnnotationSpec) o;\n       annotationSpec.emit(this, true);\n+    } else if (o instanceof CodeBlock) {\n+      CodeBlock codeBlock = (CodeBlock) o;\n+      emit(codeBlock);\n     } else {\n       emitAndIndent(String.valueOf(o));\n     }\n"
    },
    {
        "commit_hash": "5adcb3a5ad57d36bff59c4800b1fd0df14881a41",
        "previous_commit_hash": "dac757a11aeedf297575a7ba23fcde4c63e09cf6",
        "diff_stats": {
            "additions": 10,
            "deletions": 10
        },
        "diff_content": "@@ -32,18 +32,18 @@ import static com.google.common.base.Preconditions.checkNotNull;\n public final class FieldSpec {\n   public final Type type;\n   public final String name;\n-  public final ImmutableList<Snippet> javadocSnippets;\n+  public final CodeBlock javadoc;\n   public final ImmutableList<AnnotationSpec> annotations;\n   public final ImmutableSet<Modifier> modifiers;\n-  public final Snippet initializer;\n+  public final CodeBlock initializer;\n \n   private FieldSpec(Builder builder) {\n     this.type = checkNotNull(builder.type, \"type == null\");\n     this.name = checkNotNull(builder.name, \"name == null\");\n-    this.javadocSnippets = ImmutableList.copyOf(builder.javadocSnippets);\n+    this.javadoc = builder.javadoc.build();\n     this.annotations = ImmutableList.copyOf(builder.annotations);\n     this.modifiers = ImmutableSet.copyOf(builder.modifiers);\n-    this.initializer = builder.initializer;\n+    this.initializer = builder.initializer.build();\n   }\n \n   public boolean hasModifier(Modifier modifier) {\n@@ -51,11 +51,11 @@ public final class FieldSpec {\n   }\n \n   void emit(CodeWriter codeWriter, ImmutableSet<Modifier> implicitModifiers) throws IOException {\n-    codeWriter.emitJavadoc(javadocSnippets);\n+    codeWriter.emitJavadoc(javadoc);\n     codeWriter.emitAnnotations(annotations, false);\n     codeWriter.emitModifiers(modifiers, implicitModifiers);\n     codeWriter.emit(\"$T $L\", type, name);\n-    if (initializer != null) {\n+    if (!initializer.isEmpty()) {\n       codeWriter.emit(\" = \");\n       codeWriter.emit(initializer);\n     }\n@@ -75,10 +75,10 @@ public final class FieldSpec {\n     private final Type type;\n     private final String name;\n \n-    private final List<Snippet> javadocSnippets = new ArrayList<>();\n+    private final CodeBlock.Builder javadoc = new CodeBlock.Builder();\n     private final List<AnnotationSpec> annotations = new ArrayList<>();\n     private final List<Modifier> modifiers = new ArrayList<>();\n-    private Snippet initializer;\n+    private CodeBlock.Builder initializer = new CodeBlock.Builder();\n \n     private Builder(Type type, String name) {\n       checkArgument(SourceVersion.isName(name), \"not a valid name: %s\", name);\n@@ -87,7 +87,7 @@ public final class FieldSpec {\n     }\n \n     public Builder addJavadoc(String format, Object... args) {\n-      javadocSnippets.add(new Snippet(format, args));\n+      javadoc.add(format, args);\n       return this;\n     }\n \n@@ -107,7 +107,7 @@ public final class FieldSpec {\n     }\n \n     public Builder initializer(String format, Object... args) {\n-      this.initializer = new Snippet(format, args);\n+      this.initializer.add(format, args);\n       return this;\n     }\n \n"
    },
    {
        "commit_hash": "5adcb3a5ad57d36bff59c4800b1fd0df14881a41",
        "previous_commit_hash": "dac757a11aeedf297575a7ba23fcde4c63e09cf6",
        "diff_stats": {
            "additions": 5,
            "deletions": 5
        },
        "diff_content": "@@ -34,12 +34,12 @@ public final class JavaFile {\n     }\n   };\n \n-  public final Snippet fileComment;\n+  public final CodeBlock fileComment;\n   public final String packageName;\n   public final TypeSpec typeSpec;\n \n   private JavaFile(Builder builder) {\n-    this.fileComment = builder.fileComment;\n+    this.fileComment = builder.fileComment.build();\n     this.packageName = builder.packageName;\n     this.typeSpec = checkNotNull(builder.typeSpec, \"typeSpec == null\");\n   }\n@@ -58,7 +58,7 @@ public final class JavaFile {\n   private void emit(CodeWriter codeWriter) throws IOException {\n     codeWriter.pushPackage(packageName);\n \n-    if (fileComment != null) {\n+    if (!fileComment.isEmpty()) {\n       codeWriter.emitComment(fileComment);\n     }\n \n@@ -90,12 +90,12 @@ public final class JavaFile {\n   }\n \n   public static final class Builder {\n-    private Snippet fileComment;\n+    private CodeBlock.Builder fileComment = new CodeBlock.Builder();\n     private String packageName = \"\";\n     private TypeSpec typeSpec;\n \n     public Builder fileComment(String format, Object... args) {\n-      this.fileComment = new Snippet(format, args);\n+      this.fileComment.add(format, args);\n       return this;\n     }\n \n"
    },
    {
        "commit_hash": "5adcb3a5ad57d36bff59c4800b1fd0df14881a41",
        "previous_commit_hash": "dac757a11aeedf297575a7ba23fcde4c63e09cf6",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -31,15 +31,15 @@ import javax.tools.JavaFileObject;\n import static com.google.common.base.Preconditions.checkArgument;\n \n /** Writes generated types to a filesystem using the standard directory structure. */\n-public final class JavaWriter {\n+public final class JavaPoet {\n   private final List<JavaFile> javaFiles = new ArrayList<>();\n \n-  public JavaWriter add(JavaFile javaFile) {\n+  public JavaPoet add(JavaFile javaFile) {\n     javaFiles.add(javaFile);\n     return this;\n   }\n \n-  public JavaWriter add(String packageName, TypeSpec type) {\n+  public JavaPoet add(String packageName, TypeSpec type) {\n     return add(new JavaFile.Builder()\n         .packageName(packageName)\n         .typeSpec(type)\n"
    },
    {
        "commit_hash": "5adcb3a5ad57d36bff59c4800b1fd0df14881a41",
        "previous_commit_hash": "dac757a11aeedf297575a7ba23fcde4c63e09cf6",
        "diff_stats": {
            "additions": 17,
            "deletions": 13
        },
        "diff_content": "@@ -37,7 +37,7 @@ public final class MethodSpec {\n   static final String CONSTRUCTOR = \"<init>\";\n \n   public final String name;\n-  public final ImmutableList<Snippet> javadocSnippets;\n+  public final CodeBlock javadoc;\n   public final ImmutableList<AnnotationSpec> annotations;\n   public final ImmutableSet<Modifier> modifiers;\n   public final ImmutableList<TypeVariable<?>> typeVariables;\n@@ -45,16 +45,17 @@ public final class MethodSpec {\n   public final ImmutableList<ParameterSpec> parameters;\n   public final boolean varargs;\n   public final ImmutableList<Type> exceptions;\n-  public final ImmutableList<Snippet> snippets;\n+  public final CodeBlock code;\n \n   private MethodSpec(Builder builder) {\n-    checkArgument(builder.snippets.isEmpty() || !builder.modifiers.contains(Modifier.ABSTRACT),\n+    CodeBlock code = builder.code.build();\n+    checkArgument(code.isEmpty() || !builder.modifiers.contains(Modifier.ABSTRACT),\n         \"abstract method %s cannot have code\", builder.name);\n     checkArgument(!builder.varargs || lastParameterIsArray(builder.parameters),\n         \"last parameter of varargs method %s must be an array\", builder.name);\n \n     this.name = checkNotNull(builder.name, \"name == null\");\n-    this.javadocSnippets = ImmutableList.copyOf(builder.javadocSnippets);\n+    this.javadoc = builder.javadoc.build();\n     this.annotations = ImmutableList.copyOf(builder.annotations);\n     this.modifiers = ImmutableSet.copyOf(builder.modifiers);\n     this.typeVariables = ImmutableList.copyOf(builder.typeVariables);\n@@ -62,7 +63,7 @@ public final class MethodSpec {\n     this.parameters = ImmutableList.copyOf(builder.parameters);\n     this.varargs = builder.varargs;\n     this.exceptions = ImmutableList.copyOf(builder.exceptions);\n-    this.snippets = ImmutableList.copyOf(builder.snippets);\n+    this.code = code;\n   }\n \n   private boolean lastParameterIsArray(List<ParameterSpec> parameters) {\n@@ -71,7 +72,7 @@ public final class MethodSpec {\n \n   void emit(CodeWriter codeWriter, String enclosingName, ImmutableSet<Modifier> implicitModifiers)\n       throws IOException {\n-    codeWriter.emitJavadoc(javadocSnippets);\n+    codeWriter.emitJavadoc(javadoc);\n     codeWriter.emitAnnotations(annotations, false);\n     codeWriter.emitModifiers(modifiers, implicitModifiers);\n \n@@ -112,9 +113,7 @@ public final class MethodSpec {\n     codeWriter.emit(\" {\\n\");\n \n     codeWriter.indent();\n-    for (Snippet snippet : snippets) {\n-      codeWriter.emit(snippet);\n-    }\n+    codeWriter.emit(code);\n     codeWriter.unindent();\n \n     codeWriter.emit(\"}\\n\");\n@@ -135,14 +134,14 @@ public final class MethodSpec {\n   public static final class Builder {\n     private final String name;\n \n-    private final List<Snippet> javadocSnippets = new ArrayList<>();\n+    private final CodeBlock.Builder javadoc = new CodeBlock.Builder();\n     private final List<AnnotationSpec> annotations = new ArrayList<>();\n     private final List<Modifier> modifiers = new ArrayList<>();\n     private List<TypeVariable<?>> typeVariables = new ArrayList<>();\n     private Type returnType;\n     private final List<ParameterSpec> parameters = new ArrayList<>();\n     private final List<Type> exceptions = new ArrayList<>();\n-    private final List<Snippet> snippets = new ArrayList<>();\n+    private final CodeBlock.Builder code = new CodeBlock.Builder();\n     private boolean varargs;\n \n     private Builder(String name) {\n@@ -153,7 +152,7 @@ public final class MethodSpec {\n     }\n \n     public Builder addJavadoc(String format, Object... args) {\n-      javadocSnippets.add(new Snippet(format, args));\n+      javadoc.add(format, args);\n       return this;\n     }\n \n@@ -203,7 +202,12 @@ public final class MethodSpec {\n     }\n \n     public Builder addCode(String format, Object... args) {\n-      snippets.add(new Snippet(format, args));\n+      code.add(format, args);\n+      return this;\n+    }\n+\n+    public Builder addCode(CodeBlock codeBlock) {\n+      code.add(codeBlock);\n       return this;\n     }\n \n"
    },
    {
        "commit_hash": "5adcb3a5ad57d36bff59c4800b1fd0df14881a41",
        "previous_commit_hash": "dac757a11aeedf297575a7ba23fcde4c63e09cf6",
        "diff_stats": {
            "additions": 0,
            "deletions": 77
        },
        "diff_content": "@@ -1,77 +0,0 @@\n-/*\n- * Copyright (C) 2015 Square, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.squareup.javapoet;\n-\n-import com.google.common.collect.ImmutableList;\n-import java.util.Arrays;\n-\n-import static com.google.common.base.Preconditions.checkState;\n-\n-/**\n- * A deferred format string. Unlike {@link java.text.Format} which uses percent {@code %} to escape\n- * placeholders, this uses {@code $}, and has its own set of permitted placeholders:\n- *\n- * <ul>\n- *   <li>{@code $L} emits the <em>literal</em> value with no escaping.\n- *   <li>{@code $N} emits a <em>name</em>, using name collision avoidance where necessary.\n- *   <li>{@code $S} escapes the value as a <em>string</em>, wraps it with double quotes, and emits\n- *       that.\n- *   <li>{@code $T} emits a <em>type</em> reference. Types will be imported if possible.\n- *   <li>{@code $$} emits a dollar sign.\n- * </ul>\n- */\n-final class Snippet {\n-  /** A heterogeneous list containing string literals and value placeholders. */\n-  final ImmutableList<String> formatParts;\n-  final ImmutableList<Object> args;\n-\n-  public Snippet(String format, Object[] args) {\n-    ImmutableList.Builder<String> formatPartsBuilder = ImmutableList.builder();\n-    int expectedArgsLength = 0;\n-    for (int p = 0, nextP; p < format.length(); p = nextP) {\n-      if (format.charAt(p) != '$') {\n-        nextP = format.indexOf('$', p + 1);\n-        if (nextP == -1) nextP = format.length();\n-      } else {\n-        checkState(p + 1 < format.length(), \"dangling $ in format string %s\", format);\n-        switch (format.charAt(p + 1)) {\n-          case 'L':\n-          case 'N':\n-          case 'S':\n-          case 'T':\n-            expectedArgsLength++;\n-            // Fall through.\n-          case '$':\n-            nextP = p + 2;\n-            break;\n-\n-          default:\n-            throw new IllegalArgumentException(\"invalid format string: \" + format);\n-        }\n-      }\n-\n-      formatPartsBuilder.add(format.substring(p, nextP));\n-    }\n-\n-    if (args.length != expectedArgsLength) {\n-      throw new IllegalStateException(String.format(\"expected %s args for %s but was %s\",\n-          expectedArgsLength, format, Arrays.toString(args)));\n-    }\n-\n-    this.formatParts = formatPartsBuilder.build();\n-    this.args = ImmutableList.copyOf(args);\n-  }\n-}\n"
    },
    {
        "commit_hash": "5adcb3a5ad57d36bff59c4800b1fd0df14881a41",
        "previous_commit_hash": "dac757a11aeedf297575a7ba23fcde4c63e09cf6",
        "diff_stats": {
            "additions": 9,
            "deletions": 9
        },
        "diff_content": "@@ -41,8 +41,8 @@ import static com.google.common.collect.Iterables.getOnlyElement;\n public final class TypeSpec {\n   public final DeclarationType declarationType;\n   public final String name;\n-  public final Snippet anonymousTypeArguments;\n-  public final ImmutableList<Snippet> javadocSnippets;\n+  public final CodeBlock anonymousTypeArguments;\n+  public final CodeBlock javadoc;\n   public final ImmutableList<AnnotationSpec> annotations;\n   public final ImmutableSet<Modifier> modifiers;\n   public final ImmutableList<TypeVariable<?>> typeVariables;\n@@ -85,7 +85,7 @@ public final class TypeSpec {\n     this.declarationType = checkNotNull(builder.declarationType, \"declarationType == null\");\n     this.name = builder.name;\n     this.anonymousTypeArguments = builder.anonymousTypeArguments;\n-    this.javadocSnippets = ImmutableList.copyOf(builder.javadocSnippets);\n+    this.javadoc = builder.javadoc.build();\n     this.annotations = ImmutableList.copyOf(builder.annotations);\n     this.modifiers = ImmutableSet.copyOf(builder.modifiers);\n     this.typeVariables = ImmutableList.copyOf(builder.typeVariables);\n@@ -121,7 +121,7 @@ public final class TypeSpec {\n   }\n \n   public static Builder anonymousClassBuilder(String typeArgumentsFormat, Object... args) {\n-    return new Builder(DeclarationType.CLASS, null, new Snippet(typeArgumentsFormat, args));\n+    return new Builder(DeclarationType.CLASS, null, CodeBlock.of(typeArgumentsFormat, args));\n   }\n \n   void emit(CodeWriter codeWriter, String enumName) throws IOException {\n@@ -141,7 +141,7 @@ public final class TypeSpec {\n       codeWriter.emit(anonymousTypeArguments);\n       codeWriter.emit(\") {\\n\");\n     } else {\n-      codeWriter.emitJavadoc(javadocSnippets);\n+      codeWriter.emitJavadoc(javadoc);\n       codeWriter.emitAnnotations(annotations, false);\n       codeWriter.emitModifiers(modifiers);\n       codeWriter.emit(\"$L $L\", Ascii.toLowerCase(declarationType.name()), name);\n@@ -242,9 +242,9 @@ public final class TypeSpec {\n   public static final class Builder {\n     private final DeclarationType declarationType;\n     private final String name;\n-    private final Snippet anonymousTypeArguments;\n+    private final CodeBlock anonymousTypeArguments;\n \n-    private final List<Snippet> javadocSnippets = new ArrayList<>();\n+    private final CodeBlock.Builder javadoc = new CodeBlock.Builder();\n     private final List<AnnotationSpec> annotations = new ArrayList<>();\n     private final List<Modifier> modifiers = new ArrayList<>();\n     private final List<TypeVariable<?>> typeVariables = new ArrayList<>();\n@@ -257,7 +257,7 @@ public final class TypeSpec {\n     private final List<Element> originatingElements = new ArrayList<>();\n \n     private Builder(DeclarationType declarationType, String name,\n-        Snippet anonymousTypeArguments) {\n+        CodeBlock anonymousTypeArguments) {\n       checkArgument(name == null || SourceVersion.isName(name), \"not a valid name: %s\", name);\n       this.declarationType = declarationType;\n       this.name = name;\n@@ -266,7 +266,7 @@ public final class TypeSpec {\n \n     public Builder addJavadoc(String format, Object... args) {\n       checkState(anonymousTypeArguments == null);\n-      javadocSnippets.add(new Snippet(format, args));\n+      javadoc.add(format, args);\n       return this;\n     }\n \n"
    },
    {
        "commit_hash": "5adcb3a5ad57d36bff59c4800b1fd0df14881a41",
        "previous_commit_hash": "dac757a11aeedf297575a7ba23fcde4c63e09cf6",
        "diff_stats": {
            "additions": 14,
            "deletions": 14
        },
        "diff_content": "@@ -31,8 +31,8 @@ import org.mockito.Mockito;\n import static com.google.common.truth.Truth.assertThat;\n import static org.junit.Assert.fail;\n \n-public final class JavaWriterTest {\n-  private final JavaWriter javaWriter = new JavaWriter();\n+public final class JavaPoetTest {\n+  private final JavaPoet javaPoet = new JavaPoet();\n \n   // Used for testing java.io File behavior.\n   @Rule public final TemporaryFolder tmp = new TemporaryFolder();\n@@ -49,7 +49,7 @@ public final class JavaWriterTest {\n     Files.createDirectories(path.getParent());\n     Files.createFile(path);\n     try {\n-      javaWriter.writeTo(path);\n+      javaPoet.writeTo(path);\n       fail();\n     } catch (IllegalArgumentException e) {\n       assertThat(e.getMessage()).isEqualTo(\"path /foo/bar exists but is not a directory.\");\n@@ -60,7 +60,7 @@ public final class JavaWriterTest {\n     File file = new File(tmp.newFolder(\"foo\"), \"bar\");\n     file.createNewFile();\n     try {\n-      javaWriter.writeTo(file);\n+      javaPoet.writeTo(file);\n       fail();\n     } catch (IllegalArgumentException e) {\n       assertThat(e.getMessage()).containsMatch(\"path .*?/foo/bar exists but is not a directory.\");\n@@ -69,7 +69,7 @@ public final class JavaWriterTest {\n \n   @Test public void pathDefaultPackage() throws IOException {\n     TypeSpec type = TypeSpec.classBuilder(\"Test\").build();\n-    javaWriter.add(\"\", type).writeTo(fsRoot);\n+    javaPoet.add(\"\", type).writeTo(fsRoot);\n \n     Path testPath = fsRoot.resolve(\"Test.java\");\n     assertThat(Files.exists(testPath)).isTrue();\n@@ -77,7 +77,7 @@ public final class JavaWriterTest {\n \n   @Test public void fileDefaultPackage() throws IOException {\n     TypeSpec type = TypeSpec.classBuilder(\"Test\").build();\n-    javaWriter.add(\"\", type).writeTo(tmp.getRoot());\n+    javaPoet.add(\"\", type).writeTo(tmp.getRoot());\n \n     File testFile = new File(tmp.getRoot(), \"Test.java\");\n     assertThat(testFile.exists()).isTrue();\n@@ -85,7 +85,7 @@ public final class JavaWriterTest {\n \n   @Test public void filerDefaultPackage() throws IOException {\n     TypeSpec type = TypeSpec.classBuilder(\"Test\").build();\n-    javaWriter.add(\"\", type).writeTo(filer);\n+    javaPoet.add(\"\", type).writeTo(filer);\n \n     Path testPath = fsRoot.resolve(\"Test.java\");\n     assertThat(Files.exists(testPath)).isTrue();\n@@ -94,7 +94,7 @@ public final class JavaWriterTest {\n   @Test public void pathSamePackage() throws IOException {\n     TypeSpec test1 = TypeSpec.classBuilder(\"Test1\").build();\n     TypeSpec test2 = TypeSpec.classBuilder(\"Test2\").build();\n-    javaWriter.add(\"example\", test1).add(\"example\", test2).writeTo(fsRoot);\n+    javaPoet.add(\"example\", test1).add(\"example\", test2).writeTo(fsRoot);\n \n     Path testPath1 = fsRoot.resolve(fs.getPath(\"example\", \"Test1.java\"));\n     assertThat(Files.exists(testPath1)).isTrue();\n@@ -105,7 +105,7 @@ public final class JavaWriterTest {\n   @Test public void fileSamePackage() throws IOException {\n     TypeSpec test1 = TypeSpec.classBuilder(\"Test1\").build();\n     TypeSpec test2 = TypeSpec.classBuilder(\"Test2\").build();\n-    javaWriter.add(\"example\", test1).add(\"example\", test2).writeTo(tmp.getRoot());\n+    javaPoet.add(\"example\", test1).add(\"example\", test2).writeTo(tmp.getRoot());\n \n     File examplePackage = new File(tmp.getRoot(), \"example\");\n     File testFile1 = new File(examplePackage, \"Test1.java\");\n@@ -117,7 +117,7 @@ public final class JavaWriterTest {\n   @Test public void filerSamePackage() throws IOException {\n     TypeSpec test1 = TypeSpec.classBuilder(\"Test1\").build();\n     TypeSpec test2 = TypeSpec.classBuilder(\"Test2\").build();\n-    javaWriter.add(\"example\", test1).add(\"example\", test2).writeTo(filer);\n+    javaPoet.add(\"example\", test1).add(\"example\", test2).writeTo(filer);\n \n     Path testPath1 = fsRoot.resolve(fs.getPath(\"example\", \"Test1.java\"));\n     assertThat(Files.exists(testPath1)).isTrue();\n@@ -127,7 +127,7 @@ public final class JavaWriterTest {\n \n   @Test public void pathNestedClasses() throws IOException {\n     TypeSpec test = TypeSpec.classBuilder(\"Test\").build();\n-    javaWriter.add(\"foo\", test)\n+    javaPoet.add(\"foo\", test)\n         .add(\"foo.bar\", test)\n         .add(\"foo.bar.baz\", test)\n         .writeTo(fsRoot);\n@@ -142,7 +142,7 @@ public final class JavaWriterTest {\n \n   @Test public void fileNestedClasses() throws IOException {\n     TypeSpec test = TypeSpec.classBuilder(\"Test\").build();\n-    javaWriter.add(\"foo\", test)\n+    javaPoet.add(\"foo\", test)\n         .add(\"foo.bar\", test)\n         .add(\"foo.bar.baz\", test)\n         .writeTo(tmp.getRoot());\n@@ -160,7 +160,7 @@ public final class JavaWriterTest {\n \n   @Test public void filerNestedClasses() throws IOException {\n     TypeSpec test = TypeSpec.classBuilder(\"Test\").build();\n-    javaWriter.add(\"foo\", test)\n+    javaPoet.add(\"foo\", test)\n         .add(\"foo.bar\", test)\n         .add(\"foo.bar.baz\", test)\n         .writeTo(filer);\n@@ -186,7 +186,7 @@ public final class JavaWriterTest {\n         .addOriginatingElement(element2_2)\n         .build();\n \n-    javaWriter.add(\"example\", test1).add(\"example\", test2).writeTo(filer);\n+    javaPoet.add(\"example\", test1).add(\"example\", test2).writeTo(filer);\n \n     Path testPath1 = fsRoot.resolve(fs.getPath(\"example\", \"Test1.java\"));\n     assertThat(filer.getOriginatingElements(testPath1)).containsExactly(element1_1);\n"
    },
    {
        "commit_hash": "5adcb3a5ad57d36bff59c4800b1fd0df14881a41",
        "previous_commit_hash": "dac757a11aeedf297575a7ba23fcde4c63e09cf6",
        "diff_stats": {
            "additions": 97,
            "deletions": 0
        },
        "diff_content": "@@ -790,6 +790,103 @@ public final class TypeSpecTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void codeBlocks() throws Exception {\n+    CodeBlock ifBlock = new CodeBlock.Builder()\n+        .beginControlFlow(\"if (!a.equals(b))\")\n+        .statement(\"return i\")\n+        .endControlFlow()\n+        .build();\n+    CodeBlock methodBody = new CodeBlock.Builder()\n+        .statement(\"$T size = $T.min(listA.size(), listB.size())\", int.class, Math.class)\n+        .beginControlFlow(\"for ($T i = 0; i < size; i++)\", int.class)\n+        .statement(\"$T $N = $N.get(i)\", String.class, \"a\", \"listA\")\n+        .statement(\"$T $N = $N.get(i)\", String.class, \"b\", \"listB\")\n+        .add(\"$L\", ifBlock)\n+        .endControlFlow()\n+        .statement(\"return size\")\n+        .build();\n+    TypeSpec util = TypeSpec.classBuilder(\"Util\")\n+        .addMethod(MethodSpec.methodBuilder(\"commonPrefixLength\")\n+            .returns(int.class)\n+            .addParameter(Types.parameterizedType(List.class, String.class), \"listA\")\n+            .addParameter(Types.parameterizedType(List.class, String.class), \"listB\")\n+            .addCode(methodBody)\n+            .build())\n+        .build();\n+    assertThat(toString(util)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import java.lang.Math;\\n\"\n+        + \"import java.lang.String;\\n\"\n+        + \"import java.util.List;\\n\"\n+        + \"\\n\"\n+        + \"class Util {\\n\"\n+        + \"  int commonPrefixLength(List<String> listA, List<String> listB) {\\n\"\n+        + \"    int size = Math.min(listA.size(), listB.size());\\n\"\n+        + \"    for (int i = 0; i < size; i++) {\\n\"\n+        + \"      String a = listA.get(i);\\n\"\n+        + \"      String b = listB.get(i);\\n\"\n+        + \"      if (!a.equals(b)) {\\n\"\n+        + \"        return i;\\n\"\n+        + \"      }\\n\"\n+        + \"    }\\n\"\n+        + \"    return size;\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void elseIf() throws Exception {\n+    TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n+        .addMethod(MethodSpec.methodBuilder(\"choices\")\n+            .addCode(new CodeBlock.Builder()\n+                .beginControlFlow(\"if (5 < 4) \")\n+                .statement(\"$T.out.println($S)\", System.class, \"wat\")\n+                .nextControlFlow(\"else if (5 < 6)\")\n+                .statement(\"$T.out.println($S)\", System.class, \"hello\")\n+                .endControlFlow()\n+                .build())\n+            .build())\n+        .build();\n+    assertThat(toString(taco)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import java.lang.System;\\n\"\n+        + \"\\n\"\n+        + \"class Taco {\\n\"\n+        + \"  void choices() {\\n\"\n+        + \"    if (5 < 4)  {\\n\"\n+        + \"      System.out.println(\\\"wat\\\");\\n\"\n+        + \"    } else if (5 < 6){\\n\"\n+        + \"      System.out.println(\\\"hello\\\");\\n\"\n+        + \"    }\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void doWhile() throws Exception {\n+    TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n+        .addMethod(MethodSpec.methodBuilder(\"loopForever\")\n+            .addCode(new CodeBlock.Builder()\n+                .beginControlFlow(\"do\")\n+                .statement(\"$T.out.println($S)\", System.class, \"hello\")\n+                .endControlFlow(\"while (5 < 6)\")\n+                .build())\n+            .build())\n+        .build();\n+    assertThat(toString(taco)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import java.lang.System;\\n\"\n+        + \"\\n\"\n+        + \"class Taco {\\n\"\n+        + \"  void loopForever() {\\n\"\n+        + \"    do {\\n\"\n+        + \"      System.out.println(\\\"hello\\\");\\n\"\n+        + \"    } while (5 < 6);\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n   private String toString(TypeSpec typeSpec) {\n     return new JavaFile.Builder()\n         .packageName(tacosPackage)\n"
    },
    {
        "commit_hash": "0773de9a0298cbac46ae754b09c843370d956ed4",
        "previous_commit_hash": "dac757a11aeedf297575a7ba23fcde4c63e09cf6",
        "diff_stats": {
            "additions": 1,
            "deletions": 9
        },
        "diff_content": "@@ -243,15 +243,7 @@ final class CodeWriter {\n \n     if (type instanceof Class<?>) {\n       Class<?> classType = (Class<?>) type;\n-      if (classType == boolean.class) return emit(\"boolean\");\n-      if (classType == byte.class) return emit(\"byte\");\n-      if (classType == short.class) return emit(\"short\");\n-      if (classType == int.class) return emit(\"int\");\n-      if (classType == long.class) return emit(\"long\");\n-      if (classType == char.class) return emit(\"char\");\n-      if (classType == float.class) return emit(\"float\");\n-      if (classType == double.class) return emit(\"double\");\n-      if (classType == void.class) return emit(\"void\");\n+      if (classType.isPrimitive()) return emit(classType.getName());\n       if (classType.isArray()) return emit(\"$T[]\", classType.getComponentType());\n       return emitType(ClassName.get(classType));\n \n"
    },
    {
        "commit_hash": "1d0a114c8e33133e138bb5b2d2bfdc75497deb7c",
        "previous_commit_hash": "e5e163f5b46f6f0348af6560c7960d720b33cfe8",
        "diff_stats": {
            "additions": 16,
            "deletions": 6
        },
        "diff_content": "@@ -21,15 +21,23 @@ import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n \n /**\n- * A deferred format string. Unlike {@link java.text.Format} which uses percent {@code %} to escape\n- * placeholders, this uses {@code $}, and has its own set of permitted placeholders:\n+ * A fragment of a .java file, potentially containing declarations, statements, and documentation.\n+ * Code blocks are not necessarily well-formed Java code, and are not validated. This class assumes\n+ * javac will check correctness later!\n+ *\n+ * <p>Code blocks support placeholders like {@link java.text.Format}. Where {@link String#format}\n+ * uses percent {@code %} to reference target values, this class uses dollar sign {@code $} and has\n+ * its own set of permitted placeholders:\n  *\n  * <ul>\n- *   <li>{@code $L} emits the <em>literal</em> value with no escaping.\n- *   <li>{@code $N} emits a <em>name</em>, using name collision avoidance where necessary.\n+ *   <li>{@code $L} emits a <em>literal</em> value with no escaping. Arguments for literals may be\n+ *       strings, primitives, {@linkplain TypeSpec type declarations}, {@linkplain AnnotationSpec\n+ *       annotations} and even other code blocks.\n+ *   <li>{@code $N} emits a <em>name</em>, using name collision avoidance where necessary. Arguments\n+ *       for names may be strings, {@linkplain ParameterSpec parameters}, {@linkplain FieldSpec\n+ *       fields}, {@linkplain MethodSpec methods}, and {@linkplain TypeSpec types}.\n  *   <li>{@code $S} escapes the value as a <em>string</em>, wraps it with double quotes, and emits\n- *       that.\n- *   <li>{@code $T} emits a <em>type</em> reference. Types will be imported if possible.\n+ *       that. For example, {@code 6\" sandwich} is emitted {@code \"6\\\" sandwich\"}.\n  *   <li>{@code $$} emits a dollar sign.\n  *   <li>{@code $&gt;} increases the indentation level.\n  *   <li>{@code $&lt;} decreases the indentation level.\n@@ -73,6 +81,8 @@ public final class CodeBlock {\n               expectedArgsLength++;\n               // Fall through.\n             case '$':\n+            case '>':\n+            case '<':\n               nextP = p + 2;\n               break;\n \n"
    },
    {
        "commit_hash": "1d0a114c8e33133e138bb5b2d2bfdc75497deb7c",
        "previous_commit_hash": "e5e163f5b46f6f0348af6560c7960d720b33cfe8",
        "diff_stats": {
            "additions": 20,
            "deletions": 0
        },
        "diff_content": "@@ -887,6 +887,26 @@ public final class TypeSpecTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void inlineIndent() throws Exception {\n+    TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n+        .addMethod(MethodSpec.methodBuilder(\"inlineIndent\")\n+            .addCode(\"if (3 < 4) {\\n$>$T.out.println($S);\\n$<}\\n\", System.class, \"hello\")\n+            .build())\n+        .build();\n+    assertThat(toString(taco)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import java.lang.System;\\n\"\n+        + \"\\n\"\n+        + \"class Taco {\\n\"\n+        + \"  void inlineIndent() {\\n\"\n+        + \"    if (3 < 4) {\\n\"\n+        + \"      System.out.println(\\\"hello\\\");\\n\"\n+        + \"    }\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n   private String toString(TypeSpec typeSpec) {\n     return new JavaFile.Builder()\n         .packageName(tacosPackage)\n"
    },
    {
        "commit_hash": "0d8505d392ea6867e3b6a39bd21f34fc12d514d5",
        "previous_commit_hash": "7d7c0c65e1fabb6b5b4e6ef70a31261ba7a8fbdb",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -71,7 +71,7 @@ public final class ClassName implements Type, Comparable<ClassName> {\n     return new ClassName(names.subList(0, names.size() - 1));\n   }\n \n-  ImmutableList<String> simpleNames() {\n+  public ImmutableList<String> simpleNames() {\n     return names.subList(1, names.size());\n   }\n \n"
    },
    {
        "commit_hash": "cc215daa81578264b5e4d14940c87375bae0a4df",
        "previous_commit_hash": "0b8051a14a01abdc1a2fc55a720ab1b2d5cbb207",
        "diff_stats": {
            "additions": 6,
            "deletions": 2
        },
        "diff_content": "@@ -34,10 +34,14 @@ import static com.google.common.base.Preconditions.checkState;\n  *       strings, primitives, {@linkplain TypeSpec type declarations}, {@linkplain AnnotationSpec\n  *       annotations} and even other code blocks.\n  *   <li>{@code $N} emits a <em>name</em>, using name collision avoidance where necessary. Arguments\n- *       for names may be strings, {@linkplain ParameterSpec parameters}, {@linkplain FieldSpec\n- *       fields}, {@linkplain MethodSpec methods}, and {@linkplain TypeSpec types}.\n+ *       for names may be strings (actually any {@linkplain CharSequence character sequence}),\n+ *       {@linkplain ParameterSpec parameters}, {@linkplain FieldSpec fields}, {@linkplain\n+ *       MethodSpec methods}, and {@linkplain TypeSpec types}.\n  *   <li>{@code $S} escapes the value as a <em>string</em>, wraps it with double quotes, and emits\n  *       that. For example, {@code 6\" sandwich} is emitted {@code \"6\\\" sandwich\"}.\n+ *   <li>{@code T} emits a <em>type</em> reference. Types will be imported if possible. Arguments\n+ *       for types may be {@linkplain Class classes}, {@linkplain javax.lang.model.type.TypeMirror\n+,*       type mirrors}, and {@linkplain javax.lang.model.element.Element elements}.\n  *   <li>{@code $$} emits a dollar sign.\n  *   <li>{@code $&gt;} increases the indentation level.\n  *   <li>{@code $&lt;} decreases the indentation level.\n"
    },
    {
        "commit_hash": "cc215daa81578264b5e4d14940c87375bae0a4df",
        "previous_commit_hash": "0b8051a14a01abdc1a2fc55a720ab1b2d5cbb207",
        "diff_stats": {
            "additions": 5,
            "deletions": 1
        },
        "diff_content": "@@ -36,7 +36,9 @@ import java.util.List;\n import java.util.Map;\n import java.util.Objects;\n import java.util.Set;\n+import javax.lang.model.element.Element;\n import javax.lang.model.element.Modifier;\n+import javax.lang.model.type.TypeMirror;\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkNotNull;\n@@ -421,6 +423,8 @@ final class CodeWriter {\n \n   private Type toType(Object arg) {\n     if (arg instanceof Type) return (Type) arg;\n+    if (arg instanceof TypeMirror) return Types.get((TypeMirror) arg);\n+    if (arg instanceof Element) return Types.get(((Element) arg).asType());\n     throw new IllegalArgumentException(\"expected type but was \" + arg);\n   }\n \n@@ -429,7 +433,7 @@ final class CodeWriter {\n   }\n \n   private String toName(Object o) {\n-    if (o instanceof String) return (String) o;\n+    if (o instanceof CharSequence) return ((CharSequence) o).toString();\n     if (o instanceof ParameterSpec) return ((ParameterSpec) o).name;\n     if (o instanceof FieldSpec) return ((FieldSpec) o).name;\n     if (o instanceof MethodSpec) return ((MethodSpec) o).name;\n"
    },
    {
        "commit_hash": "dc9a067f0935465bbe901b62e2021e9d3e7ef0d9",
        "previous_commit_hash": "7fa20efd00e944bae5a61db19ad068733cefa71c",
        "diff_stats": {
            "additions": 12,
            "deletions": 0
        },
        "diff_content": "@@ -71,6 +71,18 @@ public final class ClassName implements Type, Comparable<ClassName> {\n     return new ClassName(names.subList(0, names.size() - 1));\n   }\n \n+  /**\n+   * Returns a new {@link ClassName} instance for the specified {@code name} as nested inside this\n+   * class.\n+   */\n+  public ClassName nestedClassNamed(String name) {\n+    checkNotNull(name, \"name == null\");\n+    return new ClassName(new ImmutableList.Builder<String>()\n+        .addAll(names)\n+        .add(name)\n+        .build());\n+  }\n+\n   public ImmutableList<String> simpleNames() {\n     return names.subList(1, names.size());\n   }\n"
    },
    {
        "commit_hash": "dc9a067f0935465bbe901b62e2021e9d3e7ef0d9",
        "previous_commit_hash": "7fa20efd00e944bae5a61db19ad068733cefa71c",
        "diff_stats": {
            "additions": 8,
            "deletions": 0
        },
        "diff_content": "@@ -77,6 +77,14 @@ public final class ClassNameTest {\n     }\n   }\n \n+  @Test public void createNestedClass() {\n+    ClassName foo = ClassName.get(\"com.example\", \"Foo\");\n+    ClassName bar = foo.nestedClassNamed(\"Bar\");\n+    assertThat(bar).isEqualTo(ClassName.get(\"com.example\", \"Foo\", \"Bar\"));\n+    ClassName baz = bar.nestedClassNamed(\"Baz\");\n+    assertThat(baz).isEqualTo(ClassName.get(\"com.example\", \"Foo\", \"Bar\", \"Baz\"));\n+  }\n+\n   @Test public void classNameFromTypeElement() {\n     Elements elements = compilationRule.getElements();\n     TypeElement element = elements.getTypeElement(Object.class.getCanonicalName());\n"
    },
    {
        "commit_hash": "0f0f80c0eb67ec2d71e6b01d9801480298eaed57",
        "previous_commit_hash": "1c01bb794df37d2ef65d6f57463b02a88572dc12",
        "diff_stats": {
            "additions": 1,
            "deletions": 5
        },
        "diff_content": "@@ -98,10 +98,6 @@ public final class AnnotationSpec {\n     codeWriter.emit(whitespace + \"}\");\n   }\n \n-  public static AnnotationSpec of(Type annotation) {\n-    return builder(annotation).build();\n-  }\n-\n   public static Builder builder(Type type) {\n     return new Builder(type);\n   }\n@@ -126,7 +122,7 @@ public final class AnnotationSpec {\n     }\n \n     public Builder addMember(String name, String format, Object... args) {\n-      members.put(name, CodeBlock.of(format, args));\n+      members.put(name, CodeBlock.builder().add(format, args).build());\n       return this;\n     }\n \n"
    },
    {
        "commit_hash": "0f0f80c0eb67ec2d71e6b01d9801480298eaed57",
        "previous_commit_hash": "1c01bb794df37d2ef65d6f57463b02a88572dc12",
        "diff_stats": {
            "additions": 13,
            "deletions": 1
        },
        "diff_content": "@@ -75,7 +75,7 @@ public final class ClassName implements Type, Comparable<ClassName> {\n    * Returns a new {@link ClassName} instance for the specified {@code name} as nested inside this\n    * class.\n    */\n-  public ClassName nestedClassNamed(String name) {\n+  public ClassName nestedClass(String name) {\n     checkNotNull(name, \"name == null\");\n     return new ClassName(new ImmutableList.Builder<String>()\n         .addAll(names)\n@@ -87,6 +87,18 @@ public final class ClassName implements Type, Comparable<ClassName> {\n     return names.subList(1, names.size());\n   }\n \n+  /**\n+   * Returns a class that shares the same enclosing package or class. If this class is enclosed by\n+   * another class, this is equivalent to {@code enclosingClassName().nestedClass(name)}. Otherwise\n+   * it is equivalent to {@code get(packageName(), name)}.\n+   */\n+  public ClassName peerClass(String name) {\n+    return new ClassName(new ImmutableList.Builder<String>()\n+        .addAll(names.subList(0, names.size() - 1))\n+        .add(name)\n+        .build());\n+  }\n+\n   /** Returns the simple name of this class, like {@code \"Entry\"} for {@link Map.Entry}. */\n   public String simpleName() {\n     return Iterables.getLast(names);\n"
    },
    {
        "commit_hash": "0f0f80c0eb67ec2d71e6b01d9801480298eaed57",
        "previous_commit_hash": "1c01bb794df37d2ef65d6f57463b02a88572dc12",
        "diff_stats": {
            "additions": 8,
            "deletions": 5
        },
        "diff_content": "@@ -57,18 +57,21 @@ public final class CodeBlock {\n     this.args = builder.args.build();\n   }\n \n-  public static CodeBlock of(String format, Object... args) {\n-    return new Builder().add(format, args).build();\n-  }\n-\n   public boolean isEmpty() {\n     return formatParts.isEmpty();\n   }\n \n+  public static Builder builder() {\n+    return new Builder();\n+  }\n+\n   public static final class Builder {\n     final ImmutableList.Builder<String> formatParts = ImmutableList.builder();\n     final ImmutableList.Builder<Object> args = ImmutableList.builder();\n \n+    private Builder() {\n+    }\n+\n     public Builder add(String format, Object... args) {\n       int expectedArgsLength = 0;\n       for (int p = 0, nextP; p < format.length(); p = nextP) {\n@@ -144,7 +147,7 @@ public final class CodeBlock {\n       return this;\n     }\n \n-    public Builder statement(String format, Object... args) {\n+    public Builder addStatement(String format, Object... args) {\n       return add(format + \";\\n\", args);\n     }\n \n"
    },
    {
        "commit_hash": "0f0f80c0eb67ec2d71e6b01d9801480298eaed57",
        "previous_commit_hash": "1c01bb794df37d2ef65d6f57463b02a88572dc12",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -190,7 +190,7 @@ final class CodeWriter {\n   }\n \n   public CodeWriter emit(String format, Object... args) throws IOException {\n-    return emit(CodeBlock.of(format, args));\n+    return emit(CodeBlock.builder().add(format, args).build());\n   }\n \n   public CodeWriter emit(CodeBlock codeBlock) throws IOException {\n"
    },
    {
        "commit_hash": "0f0f80c0eb67ec2d71e6b01d9801480298eaed57",
        "previous_commit_hash": "1c01bb794df37d2ef65d6f57463b02a88572dc12",
        "diff_stats": {
            "additions": 3,
            "deletions": 7
        },
        "diff_content": "@@ -67,18 +67,14 @@ public final class FieldSpec {\n         .addModifiers(modifiers);\n   }\n \n-  public static FieldSpec of(Type type, String name, Modifier... modifiers) {\n-    return builder(type, name, modifiers).build();\n-  }\n-\n   public static final class Builder {\n     private final Type type;\n     private final String name;\n \n-    private final CodeBlock.Builder javadoc = new CodeBlock.Builder();\n+    private final CodeBlock.Builder javadoc = CodeBlock.builder();\n     private final List<AnnotationSpec> annotations = new ArrayList<>();\n     private final List<Modifier> modifiers = new ArrayList<>();\n-    private CodeBlock.Builder initializer = new CodeBlock.Builder();\n+    private CodeBlock.Builder initializer = CodeBlock.builder();\n \n     private Builder(Type type, String name) {\n       checkArgument(SourceVersion.isName(name), \"not a valid name: %s\", name);\n@@ -97,7 +93,7 @@ public final class FieldSpec {\n     }\n \n     public Builder addAnnotation(Type annotation) {\n-      this.annotations.add(AnnotationSpec.of(annotation));\n+      this.annotations.add(AnnotationSpec.builder(annotation).build());\n       return this;\n     }\n \n"
    },
    {
        "commit_hash": "0f0f80c0eb67ec2d71e6b01d9801480298eaed57",
        "previous_commit_hash": "1c01bb794df37d2ef65d6f57463b02a88572dc12",
        "diff_stats": {
            "additions": 12,
            "deletions": 13
        },
        "diff_content": "@@ -89,23 +89,22 @@ public final class JavaFile {\n     }\n   }\n \n-  public static final class Builder {\n-    private CodeBlock.Builder fileComment = new CodeBlock.Builder();\n-    private String packageName = \"\";\n-    private TypeSpec typeSpec;\n+  public static Builder builder(String packageName, TypeSpec typeSpec) {\n+    return new Builder(packageName, typeSpec);\n+  }\n \n-    public Builder fileComment(String format, Object... args) {\n-      this.fileComment.add(format, args);\n-      return this;\n-    }\n+  public static final class Builder {\n+    private final String packageName;\n+    private final TypeSpec typeSpec;\n+    private CodeBlock.Builder fileComment = CodeBlock.builder();\n \n-    public Builder packageName(String packageName) {\n-      this.packageName = checkNotNull(packageName);\n-      return this;\n+    private Builder(String packageName, TypeSpec typeSpec) {\n+      this.packageName = checkNotNull(packageName, \"packageName == null\");\n+      this.typeSpec = checkNotNull(typeSpec, \"typeSpec == null\");\n     }\n \n-    public Builder typeSpec(TypeSpec typeSpec) {\n-      this.typeSpec = typeSpec;\n+    public Builder addFileComment(String format, Object... args) {\n+      this.fileComment.add(format, args);\n       return this;\n     }\n \n"
    },
    {
        "commit_hash": "0f0f80c0eb67ec2d71e6b01d9801480298eaed57",
        "previous_commit_hash": "1c01bb794df37d2ef65d6f57463b02a88572dc12",
        "diff_stats": {
            "additions": 1,
            "deletions": 4
        },
        "diff_content": "@@ -40,10 +40,7 @@ public final class JavaPoet {\n   }\n \n   public JavaPoet add(String packageName, TypeSpec type) {\n-    return add(new JavaFile.Builder()\n-        .packageName(packageName)\n-        .typeSpec(type)\n-        .build());\n+    return add(JavaFile.builder(packageName, type).build());\n   }\n \n   public void writeTo(Path directory) throws IOException {\n"
    },
    {
        "commit_hash": "0f0f80c0eb67ec2d71e6b01d9801480298eaed57",
        "previous_commit_hash": "1c01bb794df37d2ef65d6f57463b02a88572dc12",
        "diff_stats": {
            "additions": 41,
            "deletions": 4
        },
        "diff_content": "@@ -134,14 +134,14 @@ public final class MethodSpec {\n   public static final class Builder {\n     private final String name;\n \n-    private final CodeBlock.Builder javadoc = new CodeBlock.Builder();\n+    private final CodeBlock.Builder javadoc = CodeBlock.builder();\n     private final List<AnnotationSpec> annotations = new ArrayList<>();\n     private final List<Modifier> modifiers = new ArrayList<>();\n     private List<TypeVariable<?>> typeVariables = new ArrayList<>();\n     private Type returnType;\n     private final List<ParameterSpec> parameters = new ArrayList<>();\n     private final List<Type> exceptions = new ArrayList<>();\n-    private final CodeBlock.Builder code = new CodeBlock.Builder();\n+    private final CodeBlock.Builder code = CodeBlock.builder();\n     private boolean varargs;\n \n     private Builder(String name) {\n@@ -162,7 +162,7 @@ public final class MethodSpec {\n     }\n \n     public Builder addAnnotation(Type annotation) {\n-      this.annotations.add(AnnotationSpec.of(annotation));\n+      this.annotations.add(AnnotationSpec.builder(annotation).build());\n       return this;\n     }\n \n@@ -188,7 +188,7 @@ public final class MethodSpec {\n     }\n \n     public Builder addParameter(Type type, String name, Modifier... modifiers) {\n-      return addParameter(ParameterSpec.of(type, name, modifiers));\n+      return addParameter(ParameterSpec.builder(type, name, modifiers).build());\n     }\n \n     public Builder varargs() {\n@@ -211,6 +211,43 @@ public final class MethodSpec {\n       return this;\n     }\n \n+    /**\n+     * @param controlFlow the control flow construct and its code, such as \"if (foo == 5)\".\n+     * Shouldn't contain braces or newline characters.\n+     */\n+    public Builder beginControlFlow(String controlFlow, Object... args) {\n+      code.beginControlFlow(controlFlow, args);\n+      return this;\n+    }\n+\n+    /**\n+     * @param controlFlow the control flow construct and its code, such as \"else if (foo == 10)\".\n+     *     Shouldn't contain braces or newline characters.\n+     */\n+    public Builder nextControlFlow(String controlFlow, Object... args) {\n+      code.nextControlFlow(controlFlow, args);\n+      return this;\n+    }\n+\n+    public Builder endControlFlow() {\n+      code.endControlFlow();\n+      return this;\n+    }\n+\n+    /**\n+     * @param controlFlow the optional control flow construct and its code, such as\n+     *     \"while(foo == 20)\". Only used for \"do/while\" control flows.\n+     */\n+    public Builder endControlFlow(String controlFlow, Object... args) {\n+      code.endControlFlow(controlFlow, args);\n+      return this;\n+    }\n+\n+    public Builder addStatement(String format, Object... args) {\n+      code.addStatement(format, args);\n+      return this;\n+    }\n+\n     public MethodSpec build() {\n       return new MethodSpec(this);\n     }\n"
    },
    {
        "commit_hash": "0f0f80c0eb67ec2d71e6b01d9801480298eaed57",
        "previous_commit_hash": "1c01bb794df37d2ef65d6f57463b02a88572dc12",
        "diff_stats": {
            "additions": 1,
            "deletions": 5
        },
        "diff_content": "@@ -61,10 +61,6 @@ public final class ParameterSpec {\n         .addModifiers(modifiers);\n   }\n \n-  public static ParameterSpec of(Type type, String name, Modifier... modifiers) {\n-    return builder(type, name, modifiers).build();\n-  }\n-\n   public static final class Builder {\n     private final Type type;\n     private final String name;\n@@ -84,7 +80,7 @@ public final class ParameterSpec {\n     }\n \n     public Builder addAnnotation(Type annotation) {\n-      this.annotations.add(AnnotationSpec.of(annotation));\n+      this.annotations.add(AnnotationSpec.builder(annotation).build());\n       return this;\n     }\n \n"
    },
    {
        "commit_hash": "0f0f80c0eb67ec2d71e6b01d9801480298eaed57",
        "previous_commit_hash": "1c01bb794df37d2ef65d6f57463b02a88572dc12",
        "diff_stats": {
            "additions": 6,
            "deletions": 4
        },
        "diff_content": "@@ -121,7 +121,9 @@ public final class TypeSpec {\n   }\n \n   public static Builder anonymousClassBuilder(String typeArgumentsFormat, Object... args) {\n-    return new Builder(DeclarationType.CLASS, null, CodeBlock.of(typeArgumentsFormat, args));\n+    return new Builder(DeclarationType.CLASS, null, CodeBlock.builder()\n+        .add(typeArgumentsFormat, args)\n+        .build());\n   }\n \n   void emit(CodeWriter codeWriter, String enumName) throws IOException {\n@@ -244,7 +246,7 @@ public final class TypeSpec {\n     private final String name;\n     private final CodeBlock anonymousTypeArguments;\n \n-    private final CodeBlock.Builder javadoc = new CodeBlock.Builder();\n+    private final CodeBlock.Builder javadoc = CodeBlock.builder();\n     private final List<AnnotationSpec> annotations = new ArrayList<>();\n     private final List<Modifier> modifiers = new ArrayList<>();\n     private final List<TypeVariable<?>> typeVariables = new ArrayList<>();\n@@ -277,7 +279,7 @@ public final class TypeSpec {\n     }\n \n     public Builder addAnnotation(Type annotation) {\n-      return addAnnotation(AnnotationSpec.of(annotation));\n+      return addAnnotation(AnnotationSpec.builder(annotation).build());\n     }\n \n     public Builder addModifiers(Modifier... modifiers) {\n@@ -321,7 +323,7 @@ public final class TypeSpec {\n     }\n \n     public Builder addField(Type type, String name, Modifier... modifiers) {\n-      return addField(FieldSpec.of(type, name, modifiers));\n+      return addField(FieldSpec.builder(type, name, modifiers).build());\n     }\n \n     public Builder addMethod(MethodSpec methodSpec) {\n"
    },
    {
        "commit_hash": "0f0f80c0eb67ec2d71e6b01d9801480298eaed57",
        "previous_commit_hash": "1c01bb794df37d2ef65d6f57463b02a88572dc12",
        "diff_stats": {
            "additions": 11,
            "deletions": 2
        },
        "diff_content": "@@ -79,9 +79,9 @@ public final class ClassNameTest {\n \n   @Test public void createNestedClass() {\n     ClassName foo = ClassName.get(\"com.example\", \"Foo\");\n-    ClassName bar = foo.nestedClassNamed(\"Bar\");\n+    ClassName bar = foo.nestedClass(\"Bar\");\n     assertThat(bar).isEqualTo(ClassName.get(\"com.example\", \"Foo\", \"Bar\"));\n-    ClassName baz = bar.nestedClassNamed(\"Baz\");\n+    ClassName baz = bar.nestedClass(\"Baz\");\n     assertThat(baz).isEqualTo(ClassName.get(\"com.example\", \"Foo\", \"Bar\", \"Baz\"));\n   }\n \n@@ -98,6 +98,15 @@ public final class ClassNameTest {\n         .isEqualTo(\"com.squareup.javapoet.ClassNameTest.OuterClass.InnerClass\");\n   }\n \n+  @Test public void peerClass() {\n+    assertThat(ClassName.get(Double.class).peerClass(\"Short\"))\n+        .isEqualTo(ClassName.get(Short.class));\n+    assertThat(ClassName.get(\"\", \"Double\").peerClass(\"Short\"))\n+        .isEqualTo(ClassName.get(\"\", \"Short\"));\n+    assertThat(ClassName.get(\"a.b\", \"Combo\", \"Taco\").peerClass(\"Burrito\"))\n+        .isEqualTo(ClassName.get(\"a.b\", \"Combo\", \"Burrito\"));\n+  }\n+\n   @Test public void fromClassRejectionTypes() {\n     try {\n       ClassName.get(int.class);\n"
    },
    {
        "commit_hash": "0f0f80c0eb67ec2d71e6b01d9801480298eaed57",
        "previous_commit_hash": "1c01bb794df37d2ef65d6f57463b02a88572dc12",
        "diff_stats": {
            "additions": 17,
            "deletions": 24
        },
        "diff_content": "@@ -23,10 +23,8 @@ import static com.google.common.truth.Truth.assertThat;\n \n public final class JavaFileTest {\n   @Test public void noImports() throws Exception {\n-    String source = new JavaFile.Builder()\n-        .packageName(\"com.squareup.tacos\")\n-        .typeSpec(TypeSpec.classBuilder(\"Taco\")\n-            .build())\n+    String source = JavaFile.builder(\"com.squareup.tacos\",\n+        TypeSpec.classBuilder(\"Taco\").build())\n         .build()\n         .toString();\n     assertThat(source).isEqualTo(\"\"\n@@ -37,10 +35,9 @@ public final class JavaFileTest {\n   }\n \n   @Test public void singleImport() throws Exception {\n-    String source = new JavaFile.Builder()\n-        .packageName(\"com.squareup.tacos\")\n-        .typeSpec(TypeSpec.classBuilder(\"Taco\")\n-            .addField(FieldSpec.of(Date.class, \"madeFreshDate\"))\n+    String source = JavaFile.builder(\"com.squareup.tacos\",\n+        TypeSpec.classBuilder(\"Taco\")\n+            .addField(Date.class, \"madeFreshDate\")\n             .build())\n         .build()\n         .toString();\n@@ -55,11 +52,10 @@ public final class JavaFileTest {\n   }\n \n   @Test public void conflictingImports() throws Exception {\n-    String source = new JavaFile.Builder()\n-        .packageName(\"com.squareup.tacos\")\n-        .typeSpec(TypeSpec.classBuilder(\"Taco\")\n-            .addField(FieldSpec.of(Date.class, \"madeFreshDate\"))\n-            .addField(FieldSpec.of(java.sql.Date.class, \"madeFreshDatabaseDate\"))\n+    String source = JavaFile.builder(\"com.squareup.tacos\",\n+        TypeSpec.classBuilder(\"Taco\")\n+            .addField(Date.class, \"madeFreshDate\")\n+            .addField(java.sql.Date.class, \"madeFreshDatabaseDate\")\n             .build())\n         .build()\n         .toString();\n@@ -76,8 +72,8 @@ public final class JavaFileTest {\n   }\n \n   @Test public void defaultPackage() throws Exception {\n-    String source = new JavaFile.Builder()\n-        .typeSpec(TypeSpec.classBuilder(\"HelloWorld\")\n+    String source = JavaFile.builder(\"\",\n+        TypeSpec.classBuilder(\"HelloWorld\")\n             .addMethod(MethodSpec.methodBuilder(\"main\")\n                 .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n                 .addParameter(String[].class, \"args\")\n@@ -98,10 +94,9 @@ public final class JavaFileTest {\n   }\n \n   @Test public void topOfFileComment() throws Exception {\n-    String source = new JavaFile.Builder()\n-        .fileComment(\"Generated $L by JavaWriter. DO NOT EDIT!\", \"2015-01-13\")\n-        .packageName(\"com.squareup.tacos\")\n-        .typeSpec(TypeSpec.classBuilder(\"Taco\").build())\n+    String source = JavaFile.builder(\"com.squareup.tacos\",\n+        TypeSpec.classBuilder(\"Taco\").build())\n+        .addFileComment(\"Generated $L by JavaWriter. DO NOT EDIT!\", \"2015-01-13\")\n         .build()\n         .toString();\n     assertThat(source).isEqualTo(\"\"\n@@ -113,11 +108,9 @@ public final class JavaFileTest {\n   }\n \n   @Test public void emptyLinesInTopOfFileComment() throws Exception {\n-    String source = new JavaFile.Builder()\n-        .fileComment(\"\\nGENERATED FILE:\\n\\nDO NOT EDIT!\\n\")\n-        .packageName(\"com.squareup.tacos\")\n-        .typeSpec(TypeSpec.classBuilder(\"Taco\")\n-            .build())\n+    String source = JavaFile.builder(\"com.squareup.tacos\",\n+        TypeSpec.classBuilder(\"Taco\").build())\n+        .addFileComment(\"\\nGENERATED FILE:\\n\\nDO NOT EDIT!\\n\")\n         .build()\n         .toString();\n     assertThat(source).isEqualTo(\"\"\n"
    },
    {
        "commit_hash": "0f0f80c0eb67ec2d71e6b01d9801480298eaed57",
        "previous_commit_hash": "1c01bb794df37d2ef65d6f57463b02a88572dc12",
        "diff_stats": {
            "additions": 42,
            "deletions": 47
        },
        "diff_content": "@@ -67,9 +67,9 @@ public final class TypeSpecTest {\n     ParameterizedType listOfSuper = Types.parameterizedType(\n         List.class, Types.supertypeOf(String.class));\n     TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n-        .addField(FieldSpec.of(listOfAny, \"extendsObject\"))\n-        .addField(FieldSpec.of(listOfExtends, \"extendsSerializable\"))\n-        .addField(FieldSpec.of(listOfSuper, \"superString\"))\n+        .addField(listOfAny, \"extendsObject\")\n+        .addField(listOfExtends, \"extendsSerializable\")\n+        .addField(listOfSuper, \"superString\")\n         .build();\n     assertThat(toString(taco)).isEqualTo(\"\"\n         + \"package com.squareup.tacos;\\n\"\n@@ -101,7 +101,9 @@ public final class TypeSpecTest {\n         = Types.parameterizedType(thung, Types.supertypeOf(foo));\n     ParameterizedType simpleThungOfBar = Types.parameterizedType(simpleThung, bar);\n \n-    ParameterSpec thungParameter = ParameterSpec.of(thungOfSuperFoo, \"thung\", Modifier.FINAL);\n+    ParameterSpec thungParameter = ParameterSpec.builder(thungOfSuperFoo, \"thung\")\n+        .addModifiers(Modifier.FINAL)\n+        .build();\n     TypeSpec aSimpleThung = TypeSpec.anonymousClassBuilder(\"$N\", thungParameter)\n         .superclass(simpleThungOfBar)\n         .addMethod(MethodSpec.methodBuilder(\"doSomething\")\n@@ -283,7 +285,7 @@ public final class TypeSpecTest {\n   }\n \n   @Test public void enumWithSubclassing() throws Exception {\n-      TypeSpec roshambo = TypeSpec.enumBuilder(\"Roshambo\")\n+    TypeSpec roshambo = TypeSpec.enumBuilder(\"Roshambo\")\n         .addModifiers(Modifier.PUBLIC)\n         .addEnumConstant(\"ROCK\")\n         .addEnumConstant(\"PAPER\", TypeSpec.anonymousClassBuilder(\"$S\", \"flat\")\n@@ -296,7 +298,7 @@ public final class TypeSpecTest {\n             .build())\n         .addEnumConstant(\"SCISSORS\", TypeSpec.anonymousClassBuilder(\"$S\", \"peace sign\")\n             .build())\n-        .addField(FieldSpec.of(String.class, \"handPosition\", Modifier.PRIVATE, Modifier.FINAL))\n+        .addField(String.class, \"handPosition\", Modifier.PRIVATE, Modifier.FINAL)\n         .addMethod(MethodSpec.constructorBuilder()\n             .addParameter(String.class, \"handPosition\")\n             .addCode(\"this.handPosition = handPosition;\\n\")\n@@ -413,9 +415,9 @@ public final class TypeSpecTest {\n         .addTypeVariable(t)\n         .addTypeVariable(p)\n         .addSuperinterface(Types.parameterizedType(Comparable.class, p))\n-        .addField(FieldSpec.of(t, \"label\"))\n-        .addField(FieldSpec.of(p, \"x\"))\n-        .addField(FieldSpec.of(p, \"y\"))\n+        .addField(t, \"label\")\n+        .addField(p, \"x\")\n+        .addField(p, \"y\")\n         .addMethod(MethodSpec.methodBuilder(\"compareTo\")\n             .addAnnotation(Override.class)\n             .addModifiers(Modifier.PUBLIC)\n@@ -523,12 +525,12 @@ public final class TypeSpecTest {\n     ClassName chips = ClassName.get(tacosPackage, \"Combo\", \"Chips\");\n     ClassName sauce = ClassName.get(tacosPackage, \"Combo\", \"Sauce\");\n     TypeSpec typeSpec = TypeSpec.classBuilder(\"Combo\")\n-        .addField(FieldSpec.of(taco, \"taco\"))\n-        .addField(FieldSpec.of(chips, \"chips\"))\n+        .addField(taco, \"taco\")\n+        .addField(chips, \"chips\")\n         .addType(TypeSpec.classBuilder(taco.simpleName())\n             .addModifiers(Modifier.STATIC)\n-            .addField(FieldSpec.of(Types.parameterizedType(List.class, topping), \"toppings\"))\n-            .addField(FieldSpec.of(sauce, \"sauce\"))\n+            .addField(Types.parameterizedType(List.class, topping), \"toppings\")\n+            .addField(sauce, \"sauce\")\n             .addType(TypeSpec.enumBuilder(topping.simpleName())\n                 .addEnumConstant(\"SHREDDED_CHEESE\")\n                 .addEnumConstant(\"LEAN_GROUND_BEEF\")\n@@ -536,8 +538,8 @@ public final class TypeSpecTest {\n             .build())\n         .addType(TypeSpec.classBuilder(chips.simpleName())\n             .addModifiers(Modifier.STATIC)\n-            .addField(FieldSpec.of(topping, \"topping\"))\n-            .addField(FieldSpec.of(sauce, \"dippingSauce\"))\n+            .addField(topping, \"topping\")\n+            .addField(sauce, \"dippingSauce\")\n             .build())\n         .addType(TypeSpec.enumBuilder(sauce.simpleName())\n             .addEnumConstant(\"SOUR_CREAM\")\n@@ -591,13 +593,14 @@ public final class TypeSpecTest {\n   }\n \n   @Test public void referencedAndDeclaredSimpleNamesConflict() throws Exception {\n-    FieldSpec internalTop = FieldSpec.of(ClassName.get(tacosPackage, \"Top\"), \"internalTop\");\n-    FieldSpec internalBottom = FieldSpec.of(ClassName.get(tacosPackage,\n-        \"Top\", \"Middle\", \"Bottom\"), \"internalBottom\");\n-    FieldSpec externalTop = FieldSpec.of(\n-        ClassName.get(donutsPackage, \"Top\"), \"externalTop\");\n-    FieldSpec externalBottom = FieldSpec.of(\n-        ClassName.get(donutsPackage, \"Bottom\"), \"externalBottom\");\n+    FieldSpec internalTop = FieldSpec.builder(\n+        ClassName.get(tacosPackage, \"Top\"), \"internalTop\").build();\n+    FieldSpec internalBottom = FieldSpec.builder(\n+        ClassName.get(tacosPackage, \"Top\", \"Middle\", \"Bottom\"), \"internalBottom\").build();\n+    FieldSpec externalTop = FieldSpec.builder(\n+        ClassName.get(donutsPackage, \"Top\"), \"externalTop\").build();\n+    FieldSpec externalBottom = FieldSpec.builder(\n+        ClassName.get(donutsPackage, \"Bottom\"), \"externalBottom\").build();\n     TypeSpec top = TypeSpec.classBuilder(\"Top\")\n         .addField(internalTop)\n         .addField(internalBottom)\n@@ -688,7 +691,7 @@ public final class TypeSpecTest {\n \n   @Test public void arrayType() {\n     TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n-        .addField(FieldSpec.of(int[].class, \"ints\"))\n+        .addField(int[].class, \"ints\")\n         .build();\n     assertThat(toString(taco)).isEqualTo(\"\"\n         + \"package com.squareup.tacos;\\n\"\n@@ -791,19 +794,19 @@ public final class TypeSpecTest {\n   }\n \n   @Test public void codeBlocks() throws Exception {\n-    CodeBlock ifBlock = new CodeBlock.Builder()\n+    CodeBlock ifBlock = CodeBlock.builder()\n         .beginControlFlow(\"if (!a.equals(b))\")\n-        .statement(\"return i\")\n+        .addStatement(\"return i\")\n         .endControlFlow()\n         .build();\n-    CodeBlock methodBody = new CodeBlock.Builder()\n-        .statement(\"$T size = $T.min(listA.size(), listB.size())\", int.class, Math.class)\n+    CodeBlock methodBody = CodeBlock.builder()\n+        .addStatement(\"$T size = $T.min(listA.size(), listB.size())\", int.class, Math.class)\n         .beginControlFlow(\"for ($T i = 0; i < size; i++)\", int.class)\n-        .statement(\"$T $N = $N.get(i)\", String.class, \"a\", \"listA\")\n-        .statement(\"$T $N = $N.get(i)\", String.class, \"b\", \"listB\")\n+        .addStatement(\"$T $N = $N.get(i)\", String.class, \"a\", \"listA\")\n+        .addStatement(\"$T $N = $N.get(i)\", String.class, \"b\", \"listB\")\n         .add(\"$L\", ifBlock)\n         .endControlFlow()\n-        .statement(\"return size\")\n+        .addStatement(\"return size\")\n         .build();\n     TypeSpec util = TypeSpec.classBuilder(\"Util\")\n         .addMethod(MethodSpec.methodBuilder(\"commonPrefixLength\")\n@@ -838,13 +841,11 @@ public final class TypeSpecTest {\n   @Test public void elseIf() throws Exception {\n     TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n         .addMethod(MethodSpec.methodBuilder(\"choices\")\n-            .addCode(new CodeBlock.Builder()\n-                .beginControlFlow(\"if (5 < 4) \")\n-                .statement(\"$T.out.println($S)\", System.class, \"wat\")\n-                .nextControlFlow(\"else if (5 < 6)\")\n-                .statement(\"$T.out.println($S)\", System.class, \"hello\")\n-                .endControlFlow()\n-                .build())\n+            .beginControlFlow(\"if (5 < 4) \")\n+            .addStatement(\"$T.out.println($S)\", System.class, \"wat\")\n+            .nextControlFlow(\"else if (5 < 6)\")\n+            .addStatement(\"$T.out.println($S)\", System.class, \"hello\")\n+            .endControlFlow()\n             .build())\n         .build();\n     assertThat(toString(taco)).isEqualTo(\"\"\n@@ -866,11 +867,9 @@ public final class TypeSpecTest {\n   @Test public void doWhile() throws Exception {\n     TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n         .addMethod(MethodSpec.methodBuilder(\"loopForever\")\n-            .addCode(new CodeBlock.Builder()\n-                .beginControlFlow(\"do\")\n-                .statement(\"$T.out.println($S)\", System.class, \"hello\")\n-                .endControlFlow(\"while (5 < 6)\")\n-                .build())\n+            .beginControlFlow(\"do\")\n+            .addStatement(\"$T.out.println($S)\", System.class, \"hello\")\n+            .endControlFlow(\"while (5 < 6)\")\n             .build())\n         .build();\n     assertThat(toString(taco)).isEqualTo(\"\"\n@@ -908,10 +907,6 @@ public final class TypeSpecTest {\n   }\n \n   private String toString(TypeSpec typeSpec) {\n-    return new JavaFile.Builder()\n-        .packageName(tacosPackage)\n-        .typeSpec(typeSpec)\n-        .build()\n-        .toString();\n+    return JavaFile.builder(tacosPackage, typeSpec).build().toString();\n   }\n }\n"
    },
    {
        "commit_hash": "57498ca08dd135c2add70a651e535421cfa2b47c",
        "previous_commit_hash": "e5b66b056874dd6a1cc1e4fa77cf4e8d09cb71e3",
        "diff_stats": {
            "additions": 2,
            "deletions": 1
        },
        "diff_content": "@@ -39,7 +39,7 @@ public final class AnnotationSpec {\n   public final ImmutableMultimap<String, CodeBlock> members;\n \n   private AnnotationSpec(Builder builder) {\n-    this.type = checkNotNull(builder.type, \"type\");\n+    this.type = builder.type;\n     this.members = ImmutableListMultimap.copyOf(builder.members);\n   }\n \n@@ -99,6 +99,7 @@ public final class AnnotationSpec {\n   }\n \n   public static Builder builder(Type type) {\n+    checkNotNull(type, \"type == null\");\n     return new Builder(type);\n   }\n \n"
    },
    {
        "commit_hash": "57498ca08dd135c2add70a651e535421cfa2b47c",
        "previous_commit_hash": "e5b66b056874dd6a1cc1e4fa77cf4e8d09cb71e3",
        "diff_stats": {
            "additions": 8,
            "deletions": 9
        },
        "diff_content": "@@ -151,14 +151,13 @@ final class CodeWriter {\n    * Emits {@code modifiers} in the standard order. Modifiers in {@code implicitModifiers} will not\n    * be emitted.\n    */\n-  public void emitModifiers(ImmutableSet<Modifier> modifiers,\n-      ImmutableSet<Modifier> implicitModifiers) throws IOException {\n-    if (!modifiers.isEmpty()) {\n-      for (Modifier modifier : EnumSet.copyOf(modifiers)) {\n-        if (implicitModifiers.contains(modifier)) continue;\n-        emitAndIndent(Ascii.toLowerCase(modifier.name()));\n-        emitAndIndent(\" \");\n-      }\n+  public void emitModifiers(Set<Modifier> modifiers, Set<Modifier> implicitModifiers)\n+      throws IOException {\n+    if (modifiers.isEmpty()) return;\n+    for (Modifier modifier : EnumSet.copyOf(modifiers)) {\n+      if (implicitModifiers.contains(modifier)) continue;\n+      emitAndIndent(Ascii.toLowerCase(modifier.name()));\n+      emitAndIndent(\" \");\n     }\n   }\n \n@@ -237,7 +236,7 @@ final class CodeWriter {\n   private void emitLiteral(Object o) throws IOException {\n     if (o instanceof TypeSpec) {\n       TypeSpec typeSpec = (TypeSpec) o;\n-      typeSpec.emit(this, null);\n+      typeSpec.emit(this, null, ImmutableSet.<Modifier>of());\n     } else if (o instanceof AnnotationSpec) {\n       AnnotationSpec annotationSpec = (AnnotationSpec) o;\n       annotationSpec.emit(this, true);\n"
    },
    {
        "commit_hash": "57498ca08dd135c2add70a651e535421cfa2b47c",
        "previous_commit_hash": "e5b66b056874dd6a1cc1e4fa77cf4e8d09cb71e3",
        "diff_stats": {
            "additions": 4,
            "deletions": 2
        },
        "diff_content": "@@ -22,6 +22,7 @@ import java.lang.reflect.Type;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n+import java.util.Set;\n import javax.lang.model.SourceVersion;\n import javax.lang.model.element.Modifier;\n \n@@ -50,7 +51,7 @@ public final class FieldSpec {\n     return modifiers.contains(modifier);\n   }\n \n-  void emit(CodeWriter codeWriter, ImmutableSet<Modifier> implicitModifiers) throws IOException {\n+  void emit(CodeWriter codeWriter, Set<Modifier> implicitModifiers) throws IOException {\n     codeWriter.emitJavadoc(javadoc);\n     codeWriter.emitAnnotations(annotations, false);\n     codeWriter.emitModifiers(modifiers, implicitModifiers);\n@@ -63,6 +64,8 @@ public final class FieldSpec {\n   }\n \n   public static Builder builder(Type type, String name, Modifier... modifiers) {\n+    checkNotNull(type, \"type == null\");\n+    checkArgument(SourceVersion.isName(name), \"not a valid name: %s\", name);\n     return new Builder(type, name)\n         .addModifiers(modifiers);\n   }\n@@ -77,7 +80,6 @@ public final class FieldSpec {\n     private CodeBlock.Builder initializer = CodeBlock.builder();\n \n     private Builder(Type type, String name) {\n-      checkArgument(SourceVersion.isName(name), \"not a valid name: %s\", name);\n       this.type = type;\n       this.name = name;\n     }\n"
    },
    {
        "commit_hash": "57498ca08dd135c2add70a651e535421cfa2b47c",
        "previous_commit_hash": "e5b66b056874dd6a1cc1e4fa77cf4e8d09cb71e3",
        "diff_stats": {
            "additions": 8,
            "deletions": 4
        },
        "diff_content": "@@ -16,7 +16,9 @@\n package com.squareup.javapoet;\n \n import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n import java.io.IOException;\n+import javax.lang.model.element.Modifier;\n \n import static com.google.common.base.Preconditions.checkNotNull;\n \n@@ -41,7 +43,7 @@ public final class JavaFile {\n   private JavaFile(Builder builder) {\n     this.fileComment = builder.fileComment.build();\n     this.packageName = builder.packageName;\n-    this.typeSpec = checkNotNull(builder.typeSpec, \"typeSpec == null\");\n+    this.typeSpec = builder.typeSpec;\n   }\n \n   public void emit(Appendable out) throws IOException {\n@@ -74,7 +76,7 @@ public final class JavaFile {\n       codeWriter.emit(\"\\n\");\n     }\n \n-    typeSpec.emit(codeWriter, null);\n+    typeSpec.emit(codeWriter, null, ImmutableSet.<Modifier>of());\n \n     codeWriter.popPackage();\n   }\n@@ -90,6 +92,8 @@ public final class JavaFile {\n   }\n \n   public static Builder builder(String packageName, TypeSpec typeSpec) {\n+    checkNotNull(packageName, \"packageName == null\");\n+    checkNotNull(typeSpec, \"typeSpec == null\");\n     return new Builder(packageName, typeSpec);\n   }\n \n@@ -99,8 +103,8 @@ public final class JavaFile {\n     private CodeBlock.Builder fileComment = CodeBlock.builder();\n \n     private Builder(String packageName, TypeSpec typeSpec) {\n-      this.packageName = checkNotNull(packageName, \"packageName == null\");\n-      this.typeSpec = checkNotNull(typeSpec, \"typeSpec == null\");\n+      this.packageName = packageName;\n+      this.typeSpec = typeSpec;\n     }\n \n     public Builder addFileComment(String format, Object... args) {\n"
    },
    {
        "commit_hash": "57498ca08dd135c2add70a651e535421cfa2b47c",
        "previous_commit_hash": "e5b66b056874dd6a1cc1e4fa77cf4e8d09cb71e3",
        "diff_stats": {
            "additions": 2,
            "deletions": 1
        },
        "diff_content": "@@ -24,6 +24,7 @@ import java.util.ArrayList;\n import java.util.Collections;\n import java.util.Iterator;\n import java.util.List;\n+import java.util.Set;\n import javax.lang.model.SourceVersion;\n import javax.lang.model.element.Modifier;\n \n@@ -70,7 +71,7 @@ public final class MethodSpec {\n     return !parameters.isEmpty() && Types.arrayComponent(getLast(parameters).type) != null;\n   }\n \n-  void emit(CodeWriter codeWriter, String enclosingName, ImmutableSet<Modifier> implicitModifiers)\n+  void emit(CodeWriter codeWriter, String enclosingName, Set<Modifier> implicitModifiers)\n       throws IOException {\n     codeWriter.emitJavadoc(javadoc);\n     codeWriter.emitAnnotations(annotations, false);\n"
    },
    {
        "commit_hash": "57498ca08dd135c2add70a651e535421cfa2b47c",
        "previous_commit_hash": "e5b66b056874dd6a1cc1e4fa77cf4e8d09cb71e3",
        "diff_stats": {
            "additions": 2,
            "deletions": 1
        },
        "diff_content": "@@ -57,6 +57,8 @@ public final class ParameterSpec {\n   }\n \n   public static Builder builder(Type type, String name, Modifier... modifiers) {\n+    checkNotNull(type, \"type == null\");\n+    checkArgument(SourceVersion.isName(name), \"not a valid name: %s\", name);\n     return new Builder(type, name)\n         .addModifiers(modifiers);\n   }\n@@ -69,7 +71,6 @@ public final class ParameterSpec {\n     private final List<Modifier> modifiers = new ArrayList<>();\n \n     private Builder(Type type, String name) {\n-      checkArgument(SourceVersion.isName(name), \"not a valid name: %s\", name);\n       this.type = type;\n       this.name = name;\n     }\n"
    },
    {
        "commit_hash": "57498ca08dd135c2add70a651e535421cfa2b47c",
        "previous_commit_hash": "e5b66b056874dd6a1cc1e4fa77cf4e8d09cb71e3",
        "diff_stats": {
            "additions": 71,
            "deletions": 52
        },
        "diff_content": "@@ -19,6 +19,7 @@ import com.google.common.base.Ascii;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableMap;\n import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Sets;\n import java.io.IOException;\n import java.lang.reflect.Type;\n import java.lang.reflect.TypeVariable;\n@@ -28,6 +29,7 @@ import java.util.Iterator;\n import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n import javax.lang.model.SourceVersion;\n import javax.lang.model.element.Element;\n import javax.lang.model.element.Modifier;\n@@ -39,7 +41,7 @@ import static com.google.common.collect.Iterables.getOnlyElement;\n \n /** A generated class, interface, or enum declaration. */\n public final class TypeSpec {\n-  public final DeclarationType declarationType;\n+  public final Kind kind;\n   public final String name;\n   public final CodeBlock anonymousTypeArguments;\n   public final CodeBlock javadoc;\n@@ -55,34 +57,7 @@ public final class TypeSpec {\n   public final ImmutableList<Element> originatingElements;\n \n   private TypeSpec(Builder builder) {\n-    checkArgument(builder.name != null ^ builder.anonymousTypeArguments != null,\n-        \"types must have either a name or anonymous type arguments\");\n-    boolean isInterface = builder.declarationType == DeclarationType.INTERFACE;\n-    boolean typeIsAbstract = builder.modifiers.contains(Modifier.ABSTRACT) || isInterface;\n-    checkArgument(builder.declarationType == DeclarationType.ENUM ^ builder.enumConstants.isEmpty(),\n-        \"unexpected enum constants %s for type %s\", builder.enumConstants, builder.declarationType);\n-    for (MethodSpec methodSpec : builder.methodSpecs) {\n-      checkArgument(typeIsAbstract || !methodSpec.hasModifier(Modifier.ABSTRACT),\n-          \"non-abstract type %s cannot declare abstract method %s\", builder.name, methodSpec.name);\n-      checkArgument(!isInterface || methodSpec.hasModifier(Modifier.ABSTRACT),\n-          \"interface %s cannot declare non-abstract method %s\", builder.name, methodSpec.name);\n-      checkArgument(!isInterface || methodSpec.hasModifier(Modifier.PUBLIC),\n-          \"interface %s cannot declare non-public method %s\", builder.name, methodSpec.name);\n-    }\n-    for (FieldSpec fieldSpec : builder.fieldSpecs) {\n-      if (isInterface) {\n-        checkArgument(fieldSpec.hasModifier(Modifier.PUBLIC)\n-            && fieldSpec.hasModifier(Modifier.STATIC)\n-            && fieldSpec.hasModifier(Modifier.FINAL),\n-            \"interface %s field %s must be public static final\", builder.name, fieldSpec.name);\n-      }\n-    }\n-    boolean superclassIsObject = builder.superclass.equals(ClassName.OBJECT);\n-    int interestingSupertypeCount = (superclassIsObject ? 0 : 1) + builder.superinterfaces.size();\n-    checkArgument(builder.anonymousTypeArguments == null || interestingSupertypeCount <= 1,\n-        \"anonymous type has too many supertypes\");\n-\n-    this.declarationType = checkNotNull(builder.declarationType, \"declarationType == null\");\n+    this.kind = builder.kind;\n     this.name = builder.name;\n     this.anonymousTypeArguments = builder.anonymousTypeArguments;\n     this.javadoc = builder.javadoc.build();\n@@ -109,24 +84,25 @@ public final class TypeSpec {\n   }\n \n   public static Builder classBuilder(String name) {\n-    return new Builder(DeclarationType.CLASS, name, null);\n+    return new Builder(Kind.CLASS, checkNotNull(name), null);\n   }\n \n   public static Builder interfaceBuilder(String name) {\n-    return new Builder(DeclarationType.INTERFACE, name, null);\n+    return new Builder(Kind.INTERFACE, checkNotNull(name), null);\n   }\n \n   public static Builder enumBuilder(String name) {\n-    return new Builder(DeclarationType.ENUM, name, null);\n+    return new Builder(Kind.ENUM, checkNotNull(name), null);\n   }\n \n   public static Builder anonymousClassBuilder(String typeArgumentsFormat, Object... args) {\n-    return new Builder(DeclarationType.CLASS, null, CodeBlock.builder()\n+    return new Builder(Kind.CLASS, null, CodeBlock.builder()\n         .add(typeArgumentsFormat, args)\n         .build());\n   }\n \n-  void emit(CodeWriter codeWriter, String enumName) throws IOException {\n+  void emit(CodeWriter codeWriter, String enumName, Set<Modifier> implicitModifiers)\n+      throws IOException {\n     if (enumName != null) {\n       codeWriter.emit(\"$L\", enumName);\n       if (!anonymousTypeArguments.formatParts.isEmpty()) {\n@@ -145,13 +121,13 @@ public final class TypeSpec {\n     } else {\n       codeWriter.emitJavadoc(javadoc);\n       codeWriter.emitAnnotations(annotations, false);\n-      codeWriter.emitModifiers(modifiers);\n-      codeWriter.emit(\"$L $L\", Ascii.toLowerCase(declarationType.name()), name);\n+      codeWriter.emitModifiers(modifiers, Sets.union(implicitModifiers, kind.asMemberModifiers));\n+      codeWriter.emit(\"$L $L\", Ascii.toLowerCase(kind.name()), name);\n       codeWriter.emitTypeVariables(typeVariables);\n \n       List<Type> extendsTypes;\n       List<Type> implementsTypes;\n-      if (declarationType == DeclarationType.INTERFACE) {\n+      if (kind == Kind.INTERFACE) {\n         extendsTypes = superinterfaces;\n         implementsTypes = ImmutableList.of();\n       } else {\n@@ -191,7 +167,7 @@ public final class TypeSpec {\n         i.hasNext();) {\n       Map.Entry<String, TypeSpec> enumConstant = i.next();\n       if (!firstMember) codeWriter.emit(\"\\n\");\n-      enumConstant.getValue().emit(codeWriter, enumConstant.getKey());\n+      enumConstant.getValue().emit(codeWriter, enumConstant.getKey(), ImmutableSet.<Modifier>of());\n       firstMember = false;\n       if (i.hasNext()) {\n         codeWriter.emit(\",\\n\");\n@@ -203,17 +179,17 @@ public final class TypeSpec {\n     }\n     for (FieldSpec fieldSpec : fieldSpecs) {\n       if (!firstMember) codeWriter.emit(\"\\n\");\n-      fieldSpec.emit(codeWriter, declarationType.implicitFieldModifiers);\n+      fieldSpec.emit(codeWriter, kind.implicitFieldModifiers);\n       firstMember = false;\n     }\n     for (MethodSpec methodSpec : methodSpecs) {\n       if (!firstMember) codeWriter.emit(\"\\n\");\n-      methodSpec.emit(codeWriter, name, declarationType.implicitMethodModifiers);\n+      methodSpec.emit(codeWriter, name, kind.implicitMethodModifiers);\n       firstMember = false;\n     }\n     for (TypeSpec typeSpec : typeSpecs) {\n       if (!firstMember) codeWriter.emit(\"\\n\");\n-      typeSpec.emit(codeWriter, null);\n+      typeSpec.emit(codeWriter, null, kind.implicitTypeModifiers);\n       firstMember = false;\n     }\n     codeWriter.unindent();\n@@ -225,24 +201,43 @@ public final class TypeSpec {\n     }\n   }\n \n-  private enum DeclarationType {\n-    CLASS(ImmutableSet.<Modifier>of(), ImmutableSet.<Modifier>of()),\n-    INTERFACE(ImmutableSet.of(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL),\n-        ImmutableSet.of(Modifier.PUBLIC, Modifier.ABSTRACT)),\n-    ENUM(ImmutableSet.<Modifier>of(), ImmutableSet.<Modifier>of());\n+  private enum Kind {\n+    CLASS(\n+        ImmutableSet.<Modifier>of(),\n+        ImmutableSet.<Modifier>of(),\n+        ImmutableSet.<Modifier>of(),\n+        ImmutableSet.<Modifier>of()),\n+\n+    INTERFACE(\n+        ImmutableSet.of(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL),\n+        ImmutableSet.of(Modifier.PUBLIC, Modifier.ABSTRACT),\n+        ImmutableSet.of(Modifier.PUBLIC, Modifier.STATIC),\n+        ImmutableSet.of(Modifier.STATIC)),\n+\n+    ENUM(\n+        ImmutableSet.<Modifier>of(),\n+        ImmutableSet.<Modifier>of(),\n+        ImmutableSet.<Modifier>of(),\n+        ImmutableSet.of(Modifier.STATIC));\n \n     private final ImmutableSet<Modifier> implicitFieldModifiers;\n     private final ImmutableSet<Modifier> implicitMethodModifiers;\n+    private final ImmutableSet<Modifier> implicitTypeModifiers;\n+    private final ImmutableSet<Modifier> asMemberModifiers;\n \n-    private DeclarationType(ImmutableSet<Modifier> implicitFieldModifiers,\n-        ImmutableSet<Modifier> implicitMethodModifiers) {\n+    private Kind(ImmutableSet<Modifier> implicitFieldModifiers,\n+        ImmutableSet<Modifier> implicitMethodModifiers,\n+        ImmutableSet<Modifier> implicitTypeModifiers,\n+        ImmutableSet<Modifier> asMemberModifiers) {\n       this.implicitFieldModifiers = implicitFieldModifiers;\n       this.implicitMethodModifiers = implicitMethodModifiers;\n+      this.implicitTypeModifiers = implicitTypeModifiers;\n+      this.asMemberModifiers = asMemberModifiers;\n     }\n   }\n \n   public static final class Builder {\n-    private final DeclarationType declarationType;\n+    private final Kind kind;\n     private final String name;\n     private final CodeBlock anonymousTypeArguments;\n \n@@ -258,10 +253,10 @@ public final class TypeSpec {\n     private final List<TypeSpec> typeSpecs = new ArrayList<>();\n     private final List<Element> originatingElements = new ArrayList<>();\n \n-    private Builder(DeclarationType declarationType, String name,\n+    private Builder(Kind kind, String name,\n         CodeBlock anonymousTypeArguments) {\n       checkArgument(name == null || SourceVersion.isName(name), \"not a valid name: %s\", name);\n-      this.declarationType = declarationType;\n+      this.kind = kind;\n       this.name = name;\n       this.anonymousTypeArguments = anonymousTypeArguments;\n     }\n@@ -309,7 +304,7 @@ public final class TypeSpec {\n     }\n \n     public Builder addEnumConstant(String name, TypeSpec typeSpec) {\n-      checkState(declarationType == DeclarationType.ENUM, \"type is not enum\");\n+      checkState(kind == Kind.ENUM, \"%s is not enum\", this.name);\n       checkArgument(typeSpec.anonymousTypeArguments != null,\n           \"enum constants must have anonymous type arguments\");\n       checkArgument(SourceVersion.isName(name), \"not a valid enum constant: %s\", name);\n@@ -318,6 +313,9 @@ public final class TypeSpec {\n     }\n \n     public Builder addField(FieldSpec fieldSpec) {\n+      checkArgument(fieldSpec.modifiers.containsAll(kind.implicitFieldModifiers),\n+          \"%s %s.%s requires modifiers %s\", kind, name, fieldSpec.name,\n+          kind.implicitFieldModifiers);\n       fieldSpecs.add(fieldSpec);\n       return this;\n     }\n@@ -327,11 +325,17 @@ public final class TypeSpec {\n     }\n \n     public Builder addMethod(MethodSpec methodSpec) {\n+      checkArgument(methodSpec.modifiers.containsAll(kind.implicitMethodModifiers),\n+          \"%s %s.%s requires modifiers %s\", kind, name, methodSpec.name,\n+          kind.implicitMethodModifiers);\n       methodSpecs.add(methodSpec);\n       return this;\n     }\n \n     public Builder addType(TypeSpec typeSpec) {\n+      checkArgument(typeSpec.modifiers.containsAll(kind.implicitTypeModifiers),\n+          \"%s %s.%s requires modifiers %s\", kind, name, typeSpec.name,\n+          kind.implicitFieldModifiers);\n       typeSpecs.add(typeSpec);\n       return this;\n     }\n@@ -342,6 +346,21 @@ public final class TypeSpec {\n     }\n \n     public TypeSpec build() {\n+      boolean isInterface = kind == Kind.INTERFACE;\n+      boolean isAbstract = modifiers.contains(Modifier.ABSTRACT) || isInterface;\n+      checkArgument(kind != Kind.ENUM || !enumConstants.isEmpty(),\n+          \"at least one enum constant is required for %s\", name);\n+\n+      for (MethodSpec methodSpec : methodSpecs) {\n+        checkArgument(isAbstract || !methodSpec.hasModifier(Modifier.ABSTRACT),\n+            \"non-abstract type %s cannot declare abstract method %s\", name, methodSpec.name);\n+      }\n+\n+      boolean superclassIsObject = superclass.equals(ClassName.OBJECT);\n+      int interestingSupertypeCount = (superclassIsObject ? 0 : 1) + superinterfaces.size();\n+      checkArgument(anonymousTypeArguments == null || interestingSupertypeCount <= 1,\n+          \"anonymous type has too many supertypes\");\n+\n       return new TypeSpec(this);\n     }\n   }\n"
    },
    {
        "commit_hash": "57498ca08dd135c2add70a651e535421cfa2b47c",
        "previous_commit_hash": "e5b66b056874dd6a1cc1e4fa77cf4e8d09cb71e3",
        "diff_stats": {
            "additions": 57,
            "deletions": 0
        },
        "diff_content": "@@ -906,6 +906,63 @@ public final class TypeSpecTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void defaultModifiersForInterfaceMembers() throws Exception {\n+    TypeSpec taco = TypeSpec.interfaceBuilder(\"Taco\")\n+        .addField(FieldSpec.builder(String.class, \"SHELL\")\n+            .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)\n+            .initializer(\"$S\", \"crunchy corn\")\n+            .build())\n+        .addMethod(MethodSpec.methodBuilder(\"fold\")\n+            .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)\n+            .build())\n+        .addType(TypeSpec.classBuilder(\"Topping\")\n+            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n+            .build())\n+        .build();\n+    assertThat(toString(taco)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import java.lang.String;\\n\"\n+        + \"\\n\"\n+        + \"interface Taco {\\n\"\n+        + \"  String SHELL = \\\"crunchy corn\\\";\\n\"\n+        + \"\\n\"\n+        + \"  void fold();\\n\"\n+        + \"\\n\"\n+        + \"  class Topping {\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void defaultModifiersForMemberInterfacesAndEnums() throws Exception {\n+    TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n+        .addType(TypeSpec.classBuilder(\"Meat\")\n+            .addModifiers(Modifier.STATIC)\n+            .build())\n+        .addType(TypeSpec.interfaceBuilder(\"Tortilla\")\n+            .addModifiers(Modifier.STATIC)\n+            .build())\n+        .addType(TypeSpec.enumBuilder(\"Topping\")\n+            .addModifiers(Modifier.STATIC)\n+            .addEnumConstant(\"SALSA\")\n+            .build())\n+        .build();\n+    assertThat(toString(taco)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"class Taco {\\n\"\n+        + \"  static class Meat {\\n\"\n+        + \"  }\\n\"\n+        + \"\\n\"\n+        + \"  interface Tortilla {\\n\"\n+        + \"  }\\n\"\n+        + \"\\n\"\n+        + \"  enum Topping {\\n\"\n+        + \"    SALSA\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n   private String toString(TypeSpec typeSpec) {\n     return JavaFile.builder(tacosPackage, typeSpec).build().toString();\n   }\n"
    },
    {
        "commit_hash": "eb43c6762ae919a45f37f0757912ddc6e7265063",
        "previous_commit_hash": "b5d43c840dbf92537abf0f2d0665e44259e5e470",
        "diff_stats": {
            "additions": 5,
            "deletions": 1
        },
        "diff_content": "@@ -82,7 +82,7 @@ public final class MethodSpec {\n       codeWriter.emit(\" \");\n     }\n \n-    if (name.equals(CONSTRUCTOR)) {\n+    if (isConstructor()) {\n       codeWriter.emit(\"$L(\", enclosingName);\n     } else {\n       codeWriter.emit(\"$T $L(\", returnType, name);\n@@ -124,6 +124,10 @@ public final class MethodSpec {\n     return modifiers.contains(modifier);\n   }\n \n+  public boolean isConstructor() {\n+    return name.equals(CONSTRUCTOR);\n+  }\n+\n   public static Builder methodBuilder(String name) {\n     return new Builder(name);\n   }\n"
    },
    {
        "commit_hash": "eb43c6762ae919a45f37f0757912ddc6e7265063",
        "previous_commit_hash": "b5d43c840dbf92537abf0f2d0665e44259e5e470",
        "diff_stats": {
            "additions": 25,
            "deletions": 0
        },
        "diff_content": "@@ -177,21 +177,46 @@ public final class TypeSpec {\n         codeWriter.emit(\"\\n\");\n       }\n     }\n+\n+    // Static fields.\n+    for (FieldSpec fieldSpec : fieldSpecs) {\n+      if (!fieldSpec.hasModifier(Modifier.STATIC)) continue;\n+      if (!firstMember) codeWriter.emit(\"\\n\");\n+      fieldSpec.emit(codeWriter, kind.implicitFieldModifiers);\n+      firstMember = false;\n+    }\n+\n+    // Non-static fields.\n     for (FieldSpec fieldSpec : fieldSpecs) {\n+      if (fieldSpec.hasModifier(Modifier.STATIC)) continue;\n       if (!firstMember) codeWriter.emit(\"\\n\");\n       fieldSpec.emit(codeWriter, kind.implicitFieldModifiers);\n       firstMember = false;\n     }\n+\n+    // Constructors.\n+    for (MethodSpec methodSpec : methodSpecs) {\n+      if (!methodSpec.isConstructor()) continue;\n+      if (!firstMember) codeWriter.emit(\"\\n\");\n+      methodSpec.emit(codeWriter, name, kind.implicitMethodModifiers);\n+      firstMember = false;\n+    }\n+\n+    // Methods (static and non-static).\n     for (MethodSpec methodSpec : methodSpecs) {\n+      if (methodSpec.isConstructor()) continue;\n       if (!firstMember) codeWriter.emit(\"\\n\");\n       methodSpec.emit(codeWriter, name, kind.implicitMethodModifiers);\n       firstMember = false;\n     }\n+\n+    // Types.\n     for (TypeSpec typeSpec : typeSpecs) {\n       if (!firstMember) codeWriter.emit(\"\\n\");\n       typeSpec.emit(codeWriter, null, kind.implicitTypeModifiers);\n       firstMember = false;\n     }\n+\n     codeWriter.unindent();\n     codeWriter.popType();\n \n"
    },
    {
        "commit_hash": "eb43c6762ae919a45f37f0757912ddc6e7265063",
        "previous_commit_hash": "b5d43c840dbf92537abf0f2d0665e44259e5e470",
        "diff_stats": {
            "additions": 57,
            "deletions": 0
        },
        "diff_content": "@@ -963,6 +963,63 @@ public final class TypeSpecTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void membersOrdering() throws Exception {\n+    // Hand out names in reverse-alphabetical order to defend against unexpected sorting.\n+    TypeSpec taco = TypeSpec.classBuilder(\"Members\")\n+        .addType(TypeSpec.classBuilder(\"Z\").build())\n+        .addType(TypeSpec.classBuilder(\"Y\").build())\n+        .addField(String.class, \"X\", Modifier.STATIC)\n+        .addField(String.class, \"W\")\n+        .addField(String.class, \"V\", Modifier.STATIC)\n+        .addField(String.class, \"U\")\n+        .addMethod(MethodSpec.methodBuilder(\"T\").addModifiers(Modifier.STATIC).build())\n+        .addMethod(MethodSpec.methodBuilder(\"S\").build())\n+        .addMethod(MethodSpec.methodBuilder(\"R\").addModifiers(Modifier.STATIC).build())\n+        .addMethod(MethodSpec.methodBuilder(\"Q\").build())\n+        .addMethod(MethodSpec.constructorBuilder().addParameter(int.class, \"p\").build())\n+        .addMethod(MethodSpec.constructorBuilder().addParameter(long.class, \"o\").build())\n+        .build();\n+    // Static fields, instance fields, constructors, methods, classes.\n+    assertThat(toString(taco)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import java.lang.String;\\n\"\n+        + \"\\n\"\n+        + \"class Members {\\n\"\n+        + \"  static String X;\\n\"\n+        + \"\\n\"\n+        + \"  static String V;\\n\"\n+        + \"\\n\"\n+        + \"  String W;\\n\"\n+        + \"\\n\"\n+        + \"  String U;\\n\"\n+        + \"\\n\"\n+        + \"  Members(int p) {\\n\"\n+        + \"  }\\n\"\n+        + \"\\n\"\n+        + \"  Members(long o) {\\n\"\n+        + \"  }\\n\"\n+        + \"\\n\"\n+        + \"  static void T() {\\n\"\n+        + \"  }\\n\"\n+        + \"\\n\"\n+        + \"  void S() {\\n\"\n+        + \"  }\\n\"\n+        + \"\\n\"\n+        + \"  static void R() {\\n\"\n+        + \"  }\\n\"\n+        + \"\\n\"\n+        + \"  void Q() {\\n\"\n+        + \"  }\\n\"\n+        + \"\\n\"\n+        + \"  class Z {\\n\"\n+        + \"  }\\n\"\n+        + \"\\n\"\n+        + \"  class Y {\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n   private String toString(TypeSpec typeSpec) {\n     return JavaFile.builder(tacosPackage, typeSpec).build().toString();\n   }\n"
    },
    {
        "commit_hash": "58713e4d5e2e2da01440068a6e67d7401124f05b",
        "previous_commit_hash": "ecd44b34a345a672b150b73d796fbd2b321d7260",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -92,5 +92,18 @@ License\n \n \n \n+JavaWriter\n+==========\n+\n+JavaPoet is the successor to [JavaWriter][javawriter]. New projects should prefer JavaPoet because\n+it has a stronger code model: it understands types and can manage imports automatically. JavaPoet is\n+also better suited to composition: rather than streaming the contents of a `.java` file\n+top-to-bottom in a single pass, a file can be assembled as a tree of declarations.\n+\n+JavaWriter continues to be available in [GitHub][javawriter] and [Maven Central][javawriter_maven].\n+\n+\n  [dl]: https://search.maven.org/remote_content?g=com.squareup&a=javapoet&v=LATEST\n  [snap]: https://oss.sonatype.org/content/repositories/snapshots/\n+ [javawriter]: https://github.com/square/javapoet/tree/javawriter_2\n+ [javawriter_maven]: http://search.maven.org/#artifactdetails%7Ccom.squareup%7Cjavawriter%7C2.5.1%7Cjar\n"
    },
    {
        "commit_hash": "d9ec76d957b6e012f4103b1b25ba16dbf12b6f80",
        "previous_commit_hash": "58713e4d5e2e2da01440068a6e67d7401124f05b",
        "diff_stats": {
            "additions": 310,
            "deletions": 26
        },
        "diff_content": "@@ -8,49 +8,331 @@ with metadata files (e.g., database schemas, protocol formats). By generating co\n the need to write boilerplate while also keeping a single source of truth for the metadata.\n \n \n+### Example\n \n-Example\n--------\n+Here's a (boring) `HelloWorld` class:\n+\n+```\n+package com.example.helloworld;\n+\n+public final class HelloWorld {\n+  public static void main(String[] args) {\n+    System.out.println(\"Hello, JavaPoet!\");\n+  }\n+}\n+```\n \n-```java\n-TypeSpec raven = TypeSpec.classBuilder(\"Raven\")\n+And this is the (exciting) code to generate it with JavaPoet:\n+\n+```\n+MethodSpec main = MethodSpec.methodBuilder(\"main\")\n+    .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n+    .returns(void.class)\n+    .addParameter(String[].class, \"args\")\n+    .addStatement(\"$T.out.println($S)\", System.class, \"Hello, JavaPoet!\")\n+    .build();\n+\n+TypeSpec helloWorld = TypeSpec.classBuilder(\"HelloWorld\")\n     .addModifiers(Modifier.PUBLIC, Modifier.FINAL)\n-    .addMethod(MethodSpec.methodBuilder(\"main\")\n-        .addModifiers(Modifier.PUBLIC)\n-        .addCode(\"$T verses = new $T();\\n\",\n-            Types.parameterizedType(List.class, String.class),\n-            Types.parameterizedType(ArrayList.class, String.class))\n-        .addCode(\"verses.add($S);\\n\",\n-            \"Once upon a midnight dreary, while I pondered, weak and weary...\")\n-        .addCode(\"verses.add($S);\\n\",\n-            \"Over many a quaint and curious volume of forgotten lore\u2014\")\n-        .addCode(\"System.out.println(verses);\\n\")\n-        .build())\n+    .addMethod(main)\n+    .build();\n+\n+JavaFile javaFile = JavaFile.builder(\"com.example.helloworld\", helloWorld)\n+    .build();\n+\n+javaFile.emit(System.out);\n+```\n+\n+To declare the main method, we've created a `MethodSpec` \"main\" configured with modifiers, return\n+type, parameters and code statements. We add the main method to a `HelloWorld` class, and then add\n+that to a `HelloWorld.java` file.\n+\n+In this case we write the file to `System.out`, but we could also get it as a string\n+(`JavaFile.toString()`) or write it to the file system (`JavaPoet.writeTo()`).\n+\n+### Code & Control Flow\n+\n+Most of JavaPoet's API uses plain old immutable Java objects. There's also builders, method chaining\n+and varargs to make the API friendly. JavaPoet offers models for classes & interfaces (`TypeSpec`),\n+fields (`FieldSpec`), methods & constructors (`MethodSpec`), parameters (`ParameterSpec`) and\n+annotations (`AnnotationSpec`).\n+\n+But the _body_ of methods and constructors is not modeled. There's no expression class, no\n+statement class or syntax tree nodes. Instead, JavaPoet uses strings for code blocks:\n+\n+```\n+MethodSpec main = MethodSpec.methodBuilder(\"main\")\n+    .addCode(\"\"\n+        + \"int total = 0;\\n\"\n+        + \"for (int i = 0; i < 10; i++) {\\n\"\n+        + \"  total += i;\\n\"\n+        + \"}\\n\")\n     .build();\n-JavaFile ravenSourceFile = new JavaFile.Builder()\n-    .packageName(\"com.squareup.poe\")\n-    .typeSpec(raven)\n+```\n+\n+Which generates this:\n+\n+```\n+  void main() {\n+    int total = 0;\n+    for (int i = 0; i < 10; i++) {\n+      total += i;\n+    }\n+  }\n+```\n+\n+The manual semicolons, line wrapping, and indentation are tedious and so JavaPoet offers APIs to\n+make it easier. There's `addStatement()` which takes care of semicolons and newline, and\n+`beginControlFlow()` + `endControlFlow()` which are used together for braces, newlines, and\n+indentation:\n+\n+```\n+MethodSpec main = MethodSpec.methodBuilder(\"main\")\n+    .addStatement(\"int total = 0\")\n+    .beginControlFlow(\"for (int i = 0; i < 10; i++)\")\n+    .addStatement(\"total += i\")\n+    .endControlFlow()\n     .build();\n ```\n \n-Would produce the following source output:\n+This example is lame because the generated code is constant! Suppose instead of just adding 0 to 10,\n+we want to make the operation and range configurable. Here's a method that generates a method:\n+\n+```\n+  private MethodSpec computeRange(String name, int from, int to, String op) {\n+    return MethodSpec.methodBuilder(name)\n+        .returns(int.class)\n+        .addStatement(\"int result = 0\")\n+        .beginControlFlow(\"for (int i = \" + from + \"; i < \" + to + \"; i++)\")\n+        .addStatement(\"result = result \" + op + \" i\")\n+        .endControlFlow()\n+        .addStatement(\"return result\")\n+        .build();\n+  }\n+```\n+\n+And here's what we get when we call `computeRange(\"multiply10to20\", 10, 20, \"*\")`:\n+\n+```\n+  int multiply10to20() {\n+    int result = 0;\n+    for (int i = 10; i < 20; i++) {\n+      result = result * i;\n+    }\n+    return result;\n+  }\n+```\n+\n+Methods generating methods! And since JavaPoet generates source instead of bytecode, you can\n+read through it to make sure it's right.\n+\n+\n+### $L _for_ Literals\n+\n+The string-concatenation in calls to `beginControlFlow()` and `addStatement` is distracting. Too\n+many operators. To address this, JavaPoet offers a syntax inspired-by but incompatible-with\n+[`String.format()`][formatter]. It accepts **`$L`** to emit a **literal** value in the output. This\n+works just like `Formatter`'s `%s`:\n+\n+```\n+  private MethodSpec computeRange(String name, int from, int to, String op) {\n+    return MethodSpec.methodBuilder(name)\n+        .returns(int.class)\n+        .addStatement(\"int result = 0\")\n+        .beginControlFlow(\"for (int i = $L; i < $L; i++)\", from, to)\n+        .addStatement(\"result = result $L i\", op)\n+        .endControlFlow()\n+        .addStatement(\"return result\")\n+        .build();\n+  }\n+```\n+\n+Literals are emitted directly to the output code with no escaping. Arguments for literals may be\n+strings, primitives, and a few JavaPoet types described below.\n+\n+### $S _for_ Strings\n+\n+When emitting code that includes string literals, we can use **`$S`** to emit a **string**, complete\n+with wrapping quotation marks and escaping. Here's a program that emits 3 methods, each of which\n+returns its own name:\n+\n+```\n+  @Test public void stringLiterals() throws Exception {\n+    TypeSpec helloWorld = TypeSpec.classBuilder(\"HelloWorld\")\n+        .addModifiers(Modifier.PUBLIC, Modifier.FINAL)\n+        .addMethod(whatsMyName(\"slimShady\"))\n+        .addMethod(whatsMyName(\"eminem\"))\n+        .addMethod(whatsMyName(\"marshallMathers\"))\n+        .build();\n+    JavaFile javaFile = JavaFile.builder(\"com.example.helloworld\", helloWorld)\n+        .build();\n+    javaFile.emit(System.out);\n+  }\n+\n+  private MethodSpec whatsMyName(String name) {\n+    return MethodSpec.methodBuilder(name)\n+        .returns(String.class)\n+        .addStatement(\"return $S\", name)\n+        .build();\n+  }\n+```\n+\n+In this case, using `$S` gives us quotation marks:\n+\n+```\n+public final class HelloWorld {\n+  String slimShady() {\n+    return \"slimShady\";\n+  }\n+\n+  String eminem() {\n+    return \"eminem\";\n+  }\n+\n+  String marshallMathers() {\n+    return \"marshallMathers\";\n+  }\n+}\n+```\n+\n+### $T _for_ Types\n+\n+We Java programmers love our types: they make our code easier to understand. And JavaPoet is on\n+board. It has rich built-in support for types, including automatic generation of `import`\n+statements. Just use **`$T`** to reference **types**:\n+\n+```\n+    MethodSpec today = MethodSpec.methodBuilder(\"today\")\n+        .returns(Date.class)\n+        .addStatement(\"return new $T()\", Date.class)\n+        .build();\n+    TypeSpec helloWorld = TypeSpec.classBuilder(\"HelloWorld\")\n+        .addModifiers(Modifier.PUBLIC, Modifier.FINAL)\n+        .addMethod(today)\n+        .build();\n+    JavaFile javaFile = JavaFile.builder(\"com.example.helloworld\", helloWorld)\n+        .build();\n+    javaFile.emit(System.out);\n+```\n+\n+That generates the following `.java` file, complete with the necessary `import`:\n+\n+```\n+package com.example.helloworld;\n+\n+import java.util.Date;\n+\n+public final class HelloWorld {\n+  Date today() {\n+    return new Date();\n+  }\n+}\n+```\n+\n+We passed `Date.class` to reference a class that just-so-happens to be available when we're\n+generating code. This doesn't need to be the case. Here's a similar example, but this one\n+references a class that doesn't exist (yet):\n+\n+```\n+    ClassName hoverboard = ClassName.get(\"com.mattel\", \"Hoverboard\");\n+\n+    MethodSpec today = MethodSpec.methodBuilder(\"tomorrow\")\n+        .returns(hoverboard)\n+        .addStatement(\"return new $T()\", hoverboard)\n+        .build();\n+```\n+\n+And that not-yet-existent class is imported as well:\n+\n+```\n+package com.example.helloworld;\n+\n+import com.mattel.Hoverboard;\n+\n+public final class HelloWorld {\n+  Hoverboard tomorrow() {\n+    return new Hoverboard();\n+  }\n+}\n+```\n+\n+The `ClassName` type is very important, and you'll need it frequently when you're using JavaPoet.\n+It can identify any _declared_ class. Declared types are just the beginning of Java's rich type\n+system: we also have arrays, parameterized types, wildcard types, and type variables. JavaPoet has a\n+`Types` class that can compose each of these:\n+\n+```\n+    ClassName hoverboard = ClassName.get(\"com.mattel\", \"Hoverboard\");\n+    ClassName list = ClassName.get(\"java.util\", \"List\");\n+    ClassName arrayList = ClassName.get(\"java.util\", \"ArrayList\");\n+    Type listOfHoverboards = Types.parameterizedType(list, hoverboard);\n+\n+    MethodSpec today = MethodSpec.methodBuilder(\"beyond\")\n+        .returns(listOfHoverboards)\n+        .addStatement(\"$T result = new $T<>()\", listOfHoverboards, arrayList)\n+        .addStatement(\"result.add(new $T())\", hoverboard)\n+        .addStatement(\"result.add(new $T())\", hoverboard)\n+        .addStatement(\"result.add(new $T())\", hoverboard)\n+        .addStatement(\"return result\")\n+        .build();\n+```\n+\n+JavaPoet will decompose each type and import its components where possible.\n \n-```java\n-package com.squareup.poe;\n+```\n+package com.example.helloworld;\n \n+import com.mattel.Hoverboard;\n import java.util.ArrayList;\n import java.util.List;\n \n-public final class Raven {\n-  public void main() {\n-    List<String> verses = new ArrayList<String>();\n-    verses.add(\"Once upon a midnight dreary, while I pondered, weak and weary...\");\n-    verses.add(\"Over many a quaint and curious volume of forgotten lore\u2014\");\n-    System.out.println(verses);\n+public final class HelloWorld {\n+  List<Hoverboard> beyond() {\n+    List<Hoverboard> result = new ArrayList<>();\n+    result.add(new Hoverboard());\n+    result.add(new Hoverboard());\n+    result.add(new Hoverboard());\n+    return result;\n   }\n }\n ```\n \n+### $N _for_ Names\n+\n+Generated code is often self-referential. Use **`$N`** to refer to another generated declaration by\n+its name. Here's a method that calls another:\n+\n+```\n+  public String byteToHex(int b) {\n+    char[] result = new char[2];\n+    result[0] = hexDigit((b >>> 4) & 0xf);\n+    result[1] = hexDigit(b & 0xf);\n+    return new String(result);\n+  }\n+\n+  public char hexDigit(int i) {\n+    return (char) (i < 10 ? i + '0' : i - 10 + 'a');\n+  }\n+```\n+\n+When generating the code above, we pass the `hexDigit()` method as an argument to the `byteToHex()`\n+method using `$N`:\n+\n+```\n+    MethodSpec hexDigit = MethodSpec.methodBuilder(\"hexDigit\")\n+        .addParameter(int.class, \"i\")\n+        .returns(char.class)\n+        .addStatement(\"return (char) (i < 10 ? i + '0' : i - 10 + 'a')\")\n+        .build();\n+    MethodSpec byteToHex = MethodSpec.methodBuilder(\"byteToHex\")\n+        .addParameter(int.class, \"b\")\n+        .returns(String.class)\n+        .addStatement(\"char[] result = new char[2]\")\n+        .addStatement(\"result[0] = $N((b >>> 4) & 0xf)\", hexDigit)\n+        .addStatement(\"result[1] = $N(b & 0xf)\", hexDigit)\n+        .addStatement(\"return new String(result)\")\n+        .build();\n+```\n \n \n Download\n@@ -107,3 +389,4 @@ JavaWriter continues to be available in [GitHub][javawriter] and [Maven Central]\n  [snap]: https://oss.sonatype.org/content/repositories/snapshots/\n  [javawriter]: https://github.com/square/javapoet/tree/javawriter_2\n  [javawriter_maven]: http://search.maven.org/#artifactdetails%7Ccom.squareup%7Cjavawriter%7C2.5.1%7Cjar\n+ [formatter]: http://developer.android.com/reference/java/util/Formatter.html\n"
    },
    {
        "commit_hash": "4d301bc365f24038f0fb9ec8212f63952a9cf90b",
        "previous_commit_hash": "d9ec76d957b6e012f4103b1b25ba16dbf12b6f80",
        "diff_stats": {
            "additions": 282,
            "deletions": 4
        },
        "diff_content": "@@ -127,7 +127,7 @@ Methods generating methods! And since JavaPoet generates source instead of bytec\n read through it to make sure it's right.\n \n \n-### $L _for_ Literals\n+### $L for Literals\n \n The string-concatenation in calls to `beginControlFlow()` and `addStatement` is distracting. Too\n many operators. To address this, JavaPoet offers a syntax inspired-by but incompatible-with\n@@ -150,7 +150,7 @@ works just like `Formatter`'s `%s`:\n Literals are emitted directly to the output code with no escaping. Arguments for literals may be\n strings, primitives, and a few JavaPoet types described below.\n \n-### $S _for_ Strings\n+### $S for Strings\n \n When emitting code that includes string literals, we can use **`$S`** to emit a **string**, complete\n with wrapping quotation marks and escaping. Here's a program that emits 3 methods, each of which\n@@ -195,7 +195,7 @@ public final class HelloWorld {\n }\n ```\n \n-### $T _for_ Types\n+### $T for Types\n \n We Java programmers love our types: they make our code easier to understand. And JavaPoet is on\n board. It has rich built-in support for types, including automatic generation of `import`\n@@ -297,7 +297,7 @@ public final class HelloWorld {\n }\n ```\n \n-### $N _for_ Names\n+### $N for Names\n \n Generated code is often self-referential. Use **`$N`** to refer to another generated declaration by\n its name. Here's a method that calls another:\n@@ -334,6 +334,283 @@ method using `$N`:\n         .build();\n ```\n \n+### Methods\n+\n+All of the above methods have a code body. Use `Modifiers.ABSTRACT` to get a method without any\n+body. This is only legal if the enclosing class is either abstract or an interface.\n+\n+```\n+    MethodSpec flux = MethodSpec.methodBuilder(\"flux\")\n+        .addModifiers(Modifier.ABSTRACT, Modifier.PROTECTED)\n+        .build();\n+    TypeSpec helloWorld = TypeSpec.classBuilder(\"HelloWorld\")\n+        .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)\n+        .addMethod(flux)\n+        .build();\n+```\n+\n+Which generates this:\n+\n+```\n+public abstract class HelloWorld {\n+  protected abstract void flux();\n+}\n+```\n+\n+The other modifiers work where permitted. Note that when specifying modifiers, JavaPoet uses\n+[`javax.lang.model.element.Modifier`][modifier], a class that is not available on Android. This\n+limitation applies to code-generating-code only; the output code runs everywhere: JVMs, Android,\n+and GWT.\n+\n+Methods also have parameters, exceptions, varargs, Javadoc, annotations, type variables, and a\n+return type. All of these are configured with `MethodSpec.Builder`.\n+\n+### Constructors\n+\n+`MethodSpec` is a slight misnomer; it is also be used for constructors:\n+\n+```\n+    MethodSpec flux = MethodSpec.constructorBuilder()\n+        .addModifiers(Modifier.PUBLIC)\n+        .addParameter(String.class, \"greeting\")\n+        .addStatement(\"this.$N = $N\", \"greeting\", \"greeting\")\n+        .build();\n+    TypeSpec helloWorld = TypeSpec.classBuilder(\"HelloWorld\")\n+        .addModifiers(Modifier.PUBLIC)\n+        .addField(String.class, \"greeting\", Modifier.PRIVATE, Modifier.FINAL)\n+        .addMethod(flux)\n+        .build();\n+```\n+\n+Which generates this:\n+\n+```\n+public class HelloWorld {\n+  private final String greeting;\n+\n+  public HelloWorld(String greeting) {\n+    this.greeting = greeting;\n+  }\n+}\n+```\n+\n+For the most part, constructors work just like methods. When emitting code, JavaPoet will place\n+constructors before methods in the output file.\n+\n+### Parameters\n+\n+Declare parameters on methods and constructors with either `ParameterSpec.builder()` or\n+`MethodSpec`'s convenient  `addParameter()` API:\n+\n+```\n+    ParameterSpec android = ParameterSpec.builder(String.class, \"android\")\n+        .addModifiers(Modifier.FINAL)\n+        .build();\n+\n+    MethodSpec welcomeOverlords = MethodSpec.methodBuilder(\"welcomeOverlords\")\n+        .addParameter(android)\n+        .addParameter(String.class, \"robot\", Modifier.FINAL)\n+        .build();\n+```\n+\n+Though the code above to generate `android` and `robot` parameters is different, the output is the\n+same:\n+\n+```\n+  void welcomeOverlords(final String android, final String robot) {\n+  }\n+```\n+\n+The extended `Builder` form is necessary when the parameter has annotations (such as `@Nullable`).\n+\n+### Fields\n+\n+Like parameters, fields can be created either with builders or by using convenient helper methods:\n+\n+```\n+    FieldSpec android = FieldSpec.builder(String.class, \"android\")\n+        .addModifiers(Modifier.PRIVATE, Modifier.FINAL)\n+        .build();\n+    TypeSpec helloWorld = TypeSpec.classBuilder(\"HelloWorld\")\n+        .addModifiers(Modifier.PUBLIC)\n+        .addField(android)\n+        .addField(String.class, \"robot\", Modifier.PRIVATE, Modifier.FINAL)\n+        .build();\n+```\n+\n+Which generates:\n+\n+```\n+public class HelloWorld {\n+  private final String android;\n+\n+  private final String robot;\n+}\n+```\n+\n+The extended `Builder` form is necessary when a field has Javadoc, annotations, or a field\n+initializer. Field initializers use the same [`String.format()`][formatter]-like syntax as the code\n+blocks above:\n+\n+```\n+    FieldSpec android = FieldSpec.builder(String.class, \"android\")\n+        .addModifiers(Modifier.PRIVATE, Modifier.FINAL)\n+        .initializer(\"$S + $L\", \"Lollipop v.\", 5.0d)\n+        .build();\n+```\n+\n+Which generates:\n+\n+```\n+  private final String android = \"Lollipop v.\" + 5.0;\n+```\n+\n+### Interfaces\n+\n+JavaPoet has no trouble with interfaces. Note that interface methods must always be `PUBLIC\n+ABSTRACT` and interface fields must always be `PUBLIC STATIC FINAL`. These modifiers are necessary\n+when defining the interface:\n+\n+```\n+    TypeSpec helloWorld = TypeSpec.interfaceBuilder(\"HelloWorld\")\n+        .addModifiers(Modifier.PUBLIC)\n+        .addField(FieldSpec.builder(String.class, \"ONLY_THING_THAT_IS_CONSTANT\")\n+            .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)\n+            .initializer(\"$S\", \"change\")\n+            .build())\n+        .addMethod(MethodSpec.methodBuilder(\"beep\")\n+            .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)\n+            .build())\n+        .build();\n+```\n+\n+But these modifiers are omitted when the code is generated. These are the defaults so we don't need\n+to include them for `javac`'s benefit!\n+\n+```\n+public interface HelloWorld {\n+  String ONLY_THING_THAT_IS_CONSTANT = \"change\";\n+\n+  void beep();\n+}\n+```\n+\n+### Enums\n+\n+Use `enumBuilder` to create the enum type, and `addEnumConstant()` for each value:\n+\n+```\n+    TypeSpec helloWorld = TypeSpec.enumBuilder(\"Roshambo\")\n+        .addModifiers(Modifier.PUBLIC)\n+        .addEnumConstant(\"ROCK\")\n+        .addEnumConstant(\"SCISSORS\")\n+        .addEnumConstant(\"PAPER\")\n+        .build();\n+```\n+\n+To generate this:\n+\n+```\n+public enum Roshambo {\n+  ROCK,\n+\n+  SCISSORS,\n+\n+  PAPER\n+}\n+```\n+\n+Fancy enums are supported, where the enum values override methods or call a superclass constructor.\n+Here's a comprehensive example:\n+\n+```\n+    TypeSpec helloWorld = TypeSpec.enumBuilder(\"Roshambo\")\n+        .addModifiers(Modifier.PUBLIC)\n+        .addEnumConstant(\"ROCK\", TypeSpec.anonymousClassBuilder(\"$S\", \"fist\")\n+            .addMethod(MethodSpec.methodBuilder(\"toString\")\n+                .addAnnotation(Override.class)\n+                .addModifiers(Modifier.PUBLIC)\n+                .addStatement(\"return $S\", \"avalanche!\")\n+                .build())\n+            .build())\n+        .addEnumConstant(\"SCISSORS\", TypeSpec.anonymousClassBuilder(\"$S\", \"peace\")\n+            .build())\n+        .addEnumConstant(\"PAPER\", TypeSpec.anonymousClassBuilder(\"$S\", \"flat\")\n+            .build())\n+        .addField(String.class, \"handsign\", Modifier.PRIVATE, Modifier.FINAL)\n+        .addMethod(MethodSpec.constructorBuilder()\n+            .addParameter(String.class, \"handsign\")\n+            .addStatement(\"this.$N = $N\", \"handsign\", \"handsign\")\n+            .build())\n+        .build();\n+```\n+\n+Which generates this:\n+\n+```\n+public enum Roshambo {\n+  ROCK(\"fist\") {\n+    @Override\n+    public void toString() {\n+      return \"avalanche!\";\n+    }\n+  },\n+\n+  SCISSORS(\"peace\"),\n+\n+  PAPER(\"flat\");\n+\n+  private final String handsign;\n+\n+  Roshambo(String handsign) {\n+    this.handsign = handsign;\n+  }\n+}\n+```\n+\n+### Anonymous Inner Classes\n+\n+In the enum code, we used `Types.anonymousInnerClass()`. Anonymous inner classes can also be used in\n+code blocks. They are values that can be referenced with `$L`:\n+\n+```\n+    TypeSpec comparator = TypeSpec.anonymousClassBuilder(\"\")\n+        .addSuperinterface(Types.parameterizedType(Comparator.class, String.class))\n+        .addMethod(MethodSpec.methodBuilder(\"compare\")\n+            .addAnnotation(Override.class)\n+            .addModifiers(Modifier.PUBLIC)\n+            .addParameter(String.class, \"a\")\n+            .addParameter(String.class, \"b\")\n+            .addStatement(\"return $N.length() - $N.length()\", \"a\", \"b\")\n+            .build())\n+        .build();\n+\n+    TypeSpec helloWorld = TypeSpec.classBuilder(\"HelloWorld\")\n+        .addMethod(MethodSpec.methodBuilder(\"sortByLength\")\n+            .addParameter(Types.parameterizedType(List.class, String.class), \"strings\")\n+            .addStatement(\"$T.sort($N, $L)\", Collections.class, \"strings\", comparator)\n+            .build())\n+        .build();\n+```\n+\n+This generates a method that contains a class that contains a method:\n+\n+```\n+  void sortByLength(List<String> strings) {\n+    Collections.sort(strings, new Comparator<String>() {\n+      @Override\n+      public void compare(String a, String b) {\n+        return a.length() - b.length();\n+      }\n+    });\n+  }\n+```\n+\n+One particularly tricky part of defining anonymous inner classes is the arguments to the superclass\n+constructor. In the above code we're passing the empty string for no arguments:\n+`TypeSpec.anonymousClassBuilder(\"\")`. To pass different parameters use JavaPoet's code block\n+syntax with commas to separate arguments.\n+\n \n Download\n --------\n@@ -390,3 +667,4 @@ JavaWriter continues to be available in [GitHub][javawriter] and [Maven Central]\n  [javawriter]: https://github.com/square/javapoet/tree/javawriter_2\n  [javawriter_maven]: http://search.maven.org/#artifactdetails%7Ccom.squareup%7Cjavawriter%7C2.5.1%7Cjar\n  [formatter]: http://developer.android.com/reference/java/util/Formatter.html\n+ [modifier]: http://docs.oracle.com/javase/8/docs/api/javax/lang/model/element/Modifier.html\n"
    },
    {
        "commit_hash": "82d0b01db973031888667718ad54d575fd8cfb68",
        "previous_commit_hash": "4d301bc365f24038f0fb9ec8212f63952a9cf90b",
        "diff_stats": {
            "additions": 242,
            "deletions": 233
        },
        "diff_content": "@@ -12,7 +12,7 @@ the need to write boilerplate while also keeping a single source of truth for th\n \n Here's a (boring) `HelloWorld` class:\n \n-```\n+```java\n package com.example.helloworld;\n \n public final class HelloWorld {\n@@ -24,7 +24,7 @@ public final class HelloWorld {\n \n And this is the (exciting) code to generate it with JavaPoet:\n \n-```\n+```java\n MethodSpec main = MethodSpec.methodBuilder(\"main\")\n     .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n     .returns(void.class)\n@@ -60,7 +60,7 @@ annotations (`AnnotationSpec`).\n But the _body_ of methods and constructors is not modeled. There's no expression class, no\n statement class or syntax tree nodes. Instead, JavaPoet uses strings for code blocks:\n \n-```\n+```java\n MethodSpec main = MethodSpec.methodBuilder(\"main\")\n     .addCode(\"\"\n         + \"int total = 0;\\n\"\n@@ -72,13 +72,13 @@ MethodSpec main = MethodSpec.methodBuilder(\"main\")\n \n Which generates this:\n \n-```\n-  void main() {\n-    int total = 0;\n-    for (int i = 0; i < 10; i++) {\n-      total += i;\n-    }\n+```java\n+void main() {\n+  int total = 0;\n+  for (int i = 0; i < 10; i++) {\n+    total += i;\n   }\n+}\n ```\n \n The manual semicolons, line wrapping, and indentation are tedious and so JavaPoet offers APIs to\n@@ -86,7 +86,7 @@ make it easier. There's `addStatement()` which takes care of semicolons and newl\n `beginControlFlow()` + `endControlFlow()` which are used together for braces, newlines, and\n indentation:\n \n-```\n+```java\n MethodSpec main = MethodSpec.methodBuilder(\"main\")\n     .addStatement(\"int total = 0\")\n     .beginControlFlow(\"for (int i = 0; i < 10; i++)\")\n@@ -98,29 +98,29 @@ MethodSpec main = MethodSpec.methodBuilder(\"main\")\n This example is lame because the generated code is constant! Suppose instead of just adding 0 to 10,\n we want to make the operation and range configurable. Here's a method that generates a method:\n \n-```\n-  private MethodSpec computeRange(String name, int from, int to, String op) {\n-    return MethodSpec.methodBuilder(name)\n-        .returns(int.class)\n-        .addStatement(\"int result = 0\")\n-        .beginControlFlow(\"for (int i = \" + from + \"; i < \" + to + \"; i++)\")\n-        .addStatement(\"result = result \" + op + \" i\")\n-        .endControlFlow()\n-        .addStatement(\"return result\")\n-        .build();\n-  }\n+```java\n+private MethodSpec computeRange(String name, int from, int to, String op) {\n+  return MethodSpec.methodBuilder(name)\n+      .returns(int.class)\n+      .addStatement(\"int result = 0\")\n+      .beginControlFlow(\"for (int i = \" + from + \"; i < \" + to + \"; i++)\")\n+      .addStatement(\"result = result \" + op + \" i\")\n+      .endControlFlow()\n+      .addStatement(\"return result\")\n+      .build();\n+}\n ```\n \n And here's what we get when we call `computeRange(\"multiply10to20\", 10, 20, \"*\")`:\n \n-```\n-  int multiply10to20() {\n-    int result = 0;\n-    for (int i = 10; i < 20; i++) {\n-      result = result * i;\n-    }\n-    return result;\n+```java\n+int multiply10to20() {\n+  int result = 0;\n+  for (int i = 10; i < 20; i++) {\n+    result = result * i;\n   }\n+  return result;\n+}\n ```\n \n Methods generating methods! And since JavaPoet generates source instead of bytecode, you can\n@@ -134,17 +134,17 @@ many operators. To address this, JavaPoet offers a syntax inspired-by but incomp\n [`String.format()`][formatter]. It accepts **`$L`** to emit a **literal** value in the output. This\n works just like `Formatter`'s `%s`:\n \n-```\n-  private MethodSpec computeRange(String name, int from, int to, String op) {\n-    return MethodSpec.methodBuilder(name)\n-        .returns(int.class)\n-        .addStatement(\"int result = 0\")\n-        .beginControlFlow(\"for (int i = $L; i < $L; i++)\", from, to)\n-        .addStatement(\"result = result $L i\", op)\n-        .endControlFlow()\n-        .addStatement(\"return result\")\n-        .build();\n-  }\n+```java\n+private MethodSpec computeRange(String name, int from, int to, String op) {\n+  return MethodSpec.methodBuilder(name)\n+      .returns(int.class)\n+      .addStatement(\"int result = 0\")\n+      .beginControlFlow(\"for (int i = $L; i < $L; i++)\", from, to)\n+      .addStatement(\"result = result $L i\", op)\n+      .endControlFlow()\n+      .addStatement(\"return result\")\n+      .build();\n+}\n ```\n \n Literals are emitted directly to the output code with no escaping. Arguments for literals may be\n@@ -156,30 +156,32 @@ When emitting code that includes string literals, we can use **`$S`** to emit a\n with wrapping quotation marks and escaping. Here's a program that emits 3 methods, each of which\n returns its own name:\n \n-```\n-  @Test public void stringLiterals() throws Exception {\n-    TypeSpec helloWorld = TypeSpec.classBuilder(\"HelloWorld\")\n-        .addModifiers(Modifier.PUBLIC, Modifier.FINAL)\n-        .addMethod(whatsMyName(\"slimShady\"))\n-        .addMethod(whatsMyName(\"eminem\"))\n-        .addMethod(whatsMyName(\"marshallMathers\"))\n-        .build();\n-    JavaFile javaFile = JavaFile.builder(\"com.example.helloworld\", helloWorld)\n-        .build();\n-    javaFile.emit(System.out);\n-  }\n+```java\n+@Test public void stringLiterals() throws Exception {\n+  TypeSpec helloWorld = TypeSpec.classBuilder(\"HelloWorld\")\n+      .addModifiers(Modifier.PUBLIC, Modifier.FINAL)\n+      .addMethod(whatsMyName(\"slimShady\"))\n+      .addMethod(whatsMyName(\"eminem\"))\n+      .addMethod(whatsMyName(\"marshallMathers\"))\n+      .build();\n+      \n+  JavaFile javaFile = JavaFile.builder(\"com.example.helloworld\", helloWorld)\n+      .build();\n+      \n+  javaFile.emit(System.out);\n+}\n \n-  private MethodSpec whatsMyName(String name) {\n-    return MethodSpec.methodBuilder(name)\n-        .returns(String.class)\n-        .addStatement(\"return $S\", name)\n-        .build();\n-  }\n+private MethodSpec whatsMyName(String name) {\n+  return MethodSpec.methodBuilder(name)\n+      .returns(String.class)\n+      .addStatement(\"return $S\", name)\n+      .build();\n+}\n ```\n \n In this case, using `$S` gives us quotation marks:\n \n-```\n+```java\n public final class HelloWorld {\n   String slimShady() {\n     return \"slimShady\";\n@@ -201,23 +203,26 @@ We Java programmers love our types: they make our code easier to understand. And\n board. It has rich built-in support for types, including automatic generation of `import`\n statements. Just use **`$T`** to reference **types**:\n \n-```\n-    MethodSpec today = MethodSpec.methodBuilder(\"today\")\n-        .returns(Date.class)\n-        .addStatement(\"return new $T()\", Date.class)\n-        .build();\n-    TypeSpec helloWorld = TypeSpec.classBuilder(\"HelloWorld\")\n-        .addModifiers(Modifier.PUBLIC, Modifier.FINAL)\n-        .addMethod(today)\n-        .build();\n-    JavaFile javaFile = JavaFile.builder(\"com.example.helloworld\", helloWorld)\n-        .build();\n-    javaFile.emit(System.out);\n+```java\n+MethodSpec today = MethodSpec.methodBuilder(\"today\")\n+    .returns(Date.class)\n+    .addStatement(\"return new $T()\", Date.class)\n+    .build();\n+    \n+TypeSpec helloWorld = TypeSpec.classBuilder(\"HelloWorld\")\n+    .addModifiers(Modifier.PUBLIC, Modifier.FINAL)\n+    .addMethod(today)\n+    .build();\n+    \n+JavaFile javaFile = JavaFile.builder(\"com.example.helloworld\", helloWorld)\n+    .build();\n+    \n+javaFile.emit(System.out);\n ```\n \n That generates the following `.java` file, complete with the necessary `import`:\n \n-```\n+```java\n package com.example.helloworld;\n \n import java.util.Date;\n@@ -233,18 +238,18 @@ We passed `Date.class` to reference a class that just-so-happens to be available\n generating code. This doesn't need to be the case. Here's a similar example, but this one\n references a class that doesn't exist (yet):\n \n-```\n-    ClassName hoverboard = ClassName.get(\"com.mattel\", \"Hoverboard\");\n+```java\n+ClassName hoverboard = ClassName.get(\"com.mattel\", \"Hoverboard\");\n \n-    MethodSpec today = MethodSpec.methodBuilder(\"tomorrow\")\n-        .returns(hoverboard)\n-        .addStatement(\"return new $T()\", hoverboard)\n-        .build();\n+MethodSpec today = MethodSpec.methodBuilder(\"tomorrow\")\n+    .returns(hoverboard)\n+    .addStatement(\"return new $T()\", hoverboard)\n+    .build();\n ```\n \n And that not-yet-existent class is imported as well:\n \n-```\n+```java\n package com.example.helloworld;\n \n import com.mattel.Hoverboard;\n@@ -261,25 +266,25 @@ It can identify any _declared_ class. Declared types are just the beginning of J\n system: we also have arrays, parameterized types, wildcard types, and type variables. JavaPoet has a\n `Types` class that can compose each of these:\n \n-```\n-    ClassName hoverboard = ClassName.get(\"com.mattel\", \"Hoverboard\");\n-    ClassName list = ClassName.get(\"java.util\", \"List\");\n-    ClassName arrayList = ClassName.get(\"java.util\", \"ArrayList\");\n-    Type listOfHoverboards = Types.parameterizedType(list, hoverboard);\n-\n-    MethodSpec today = MethodSpec.methodBuilder(\"beyond\")\n-        .returns(listOfHoverboards)\n-        .addStatement(\"$T result = new $T<>()\", listOfHoverboards, arrayList)\n-        .addStatement(\"result.add(new $T())\", hoverboard)\n-        .addStatement(\"result.add(new $T())\", hoverboard)\n-        .addStatement(\"result.add(new $T())\", hoverboard)\n-        .addStatement(\"return result\")\n-        .build();\n+```java\n+ClassName hoverboard = ClassName.get(\"com.mattel\", \"Hoverboard\");\n+ClassName list = ClassName.get(\"java.util\", \"List\");\n+ClassName arrayList = ClassName.get(\"java.util\", \"ArrayList\");\n+Type listOfHoverboards = Types.parameterizedType(list, hoverboard);\n+\n+MethodSpec today = MethodSpec.methodBuilder(\"beyond\")\n+    .returns(listOfHoverboards)\n+    .addStatement(\"$T result = new $T<>()\", listOfHoverboards, arrayList)\n+    .addStatement(\"result.add(new $T())\", hoverboard)\n+    .addStatement(\"result.add(new $T())\", hoverboard)\n+    .addStatement(\"result.add(new $T())\", hoverboard)\n+    .addStatement(\"return result\")\n+    .build();\n ```\n \n JavaPoet will decompose each type and import its components where possible.\n \n-```\n+```java\n package com.example.helloworld;\n \n import com.mattel.Hoverboard;\n@@ -302,36 +307,37 @@ public final class HelloWorld {\n Generated code is often self-referential. Use **`$N`** to refer to another generated declaration by\n its name. Here's a method that calls another:\n \n-```\n-  public String byteToHex(int b) {\n-    char[] result = new char[2];\n-    result[0] = hexDigit((b >>> 4) & 0xf);\n-    result[1] = hexDigit(b & 0xf);\n-    return new String(result);\n-  }\n+```java\n+public String byteToHex(int b) {\n+  char[] result = new char[2];\n+  result[0] = hexDigit((b >>> 4) & 0xf);\n+  result[1] = hexDigit(b & 0xf);\n+  return new String(result);\n+}\n \n-  public char hexDigit(int i) {\n-    return (char) (i < 10 ? i + '0' : i - 10 + 'a');\n-  }\n+public char hexDigit(int i) {\n+  return (char) (i < 10 ? i + '0' : i - 10 + 'a');\n+}\n ```\n \n When generating the code above, we pass the `hexDigit()` method as an argument to the `byteToHex()`\n method using `$N`:\n \n-```\n-    MethodSpec hexDigit = MethodSpec.methodBuilder(\"hexDigit\")\n-        .addParameter(int.class, \"i\")\n-        .returns(char.class)\n-        .addStatement(\"return (char) (i < 10 ? i + '0' : i - 10 + 'a')\")\n-        .build();\n-    MethodSpec byteToHex = MethodSpec.methodBuilder(\"byteToHex\")\n-        .addParameter(int.class, \"b\")\n-        .returns(String.class)\n-        .addStatement(\"char[] result = new char[2]\")\n-        .addStatement(\"result[0] = $N((b >>> 4) & 0xf)\", hexDigit)\n-        .addStatement(\"result[1] = $N(b & 0xf)\", hexDigit)\n-        .addStatement(\"return new String(result)\")\n-        .build();\n+```java\n+MethodSpec hexDigit = MethodSpec.methodBuilder(\"hexDigit\")\n+    .addParameter(int.class, \"i\")\n+    .returns(char.class)\n+    .addStatement(\"return (char) (i < 10 ? i + '0' : i - 10 + 'a')\")\n+    .build();\n+    \n+MethodSpec byteToHex = MethodSpec.methodBuilder(\"byteToHex\")\n+    .addParameter(int.class, \"b\")\n+    .returns(String.class)\n+    .addStatement(\"char[] result = new char[2]\")\n+    .addStatement(\"result[0] = $N((b >>> 4) & 0xf)\", hexDigit)\n+    .addStatement(\"result[1] = $N(b & 0xf)\", hexDigit)\n+    .addStatement(\"return new String(result)\")\n+    .build();\n ```\n \n ### Methods\n@@ -339,19 +345,20 @@ method using `$N`:\n All of the above methods have a code body. Use `Modifiers.ABSTRACT` to get a method without any\n body. This is only legal if the enclosing class is either abstract or an interface.\n \n-```\n-    MethodSpec flux = MethodSpec.methodBuilder(\"flux\")\n-        .addModifiers(Modifier.ABSTRACT, Modifier.PROTECTED)\n-        .build();\n-    TypeSpec helloWorld = TypeSpec.classBuilder(\"HelloWorld\")\n-        .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)\n-        .addMethod(flux)\n-        .build();\n+```java\n+MethodSpec flux = MethodSpec.methodBuilder(\"flux\")\n+    .addModifiers(Modifier.ABSTRACT, Modifier.PROTECTED)\n+    .build();\n+    \n+TypeSpec helloWorld = TypeSpec.classBuilder(\"HelloWorld\")\n+    .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)\n+    .addMethod(flux)\n+    .build();\n ```\n \n Which generates this:\n \n-```\n+```java\n public abstract class HelloWorld {\n   protected abstract void flux();\n }\n@@ -369,22 +376,23 @@ return type. All of these are configured with `MethodSpec.Builder`.\n \n `MethodSpec` is a slight misnomer; it is also be used for constructors:\n \n-```\n-    MethodSpec flux = MethodSpec.constructorBuilder()\n-        .addModifiers(Modifier.PUBLIC)\n-        .addParameter(String.class, \"greeting\")\n-        .addStatement(\"this.$N = $N\", \"greeting\", \"greeting\")\n-        .build();\n-    TypeSpec helloWorld = TypeSpec.classBuilder(\"HelloWorld\")\n-        .addModifiers(Modifier.PUBLIC)\n-        .addField(String.class, \"greeting\", Modifier.PRIVATE, Modifier.FINAL)\n-        .addMethod(flux)\n-        .build();\n+```java\n+MethodSpec flux = MethodSpec.constructorBuilder()\n+    .addModifiers(Modifier.PUBLIC)\n+    .addParameter(String.class, \"greeting\")\n+    .addStatement(\"this.$N = $N\", \"greeting\", \"greeting\")\n+    .build();\n+    \n+TypeSpec helloWorld = TypeSpec.classBuilder(\"HelloWorld\")\n+    .addModifiers(Modifier.PUBLIC)\n+    .addField(String.class, \"greeting\", Modifier.PRIVATE, Modifier.FINAL)\n+    .addMethod(flux)\n+    .build();\n ```\n \n Which generates this:\n \n-```\n+```java\n public class HelloWorld {\n   private final String greeting;\n \n@@ -400,25 +408,25 @@ constructors before methods in the output file.\n ### Parameters\n \n Declare parameters on methods and constructors with either `ParameterSpec.builder()` or\n-`MethodSpec`'s convenient  `addParameter()` API:\n+`MethodSpec`'s convenient `addParameter()` API:\n \n-```\n-    ParameterSpec android = ParameterSpec.builder(String.class, \"android\")\n-        .addModifiers(Modifier.FINAL)\n-        .build();\n+```java\n+ParameterSpec android = ParameterSpec.builder(String.class, \"android\")\n+    .addModifiers(Modifier.FINAL)\n+    .build();\n \n-    MethodSpec welcomeOverlords = MethodSpec.methodBuilder(\"welcomeOverlords\")\n-        .addParameter(android)\n-        .addParameter(String.class, \"robot\", Modifier.FINAL)\n-        .build();\n+MethodSpec welcomeOverlords = MethodSpec.methodBuilder(\"welcomeOverlords\")\n+    .addParameter(android)\n+    .addParameter(String.class, \"robot\", Modifier.FINAL)\n+    .build();\n ```\n \n Though the code above to generate `android` and `robot` parameters is different, the output is the\n same:\n \n-```\n-  void welcomeOverlords(final String android, final String robot) {\n-  }\n+```java\n+void welcomeOverlords(final String android, final String robot) {\n+}\n ```\n \n The extended `Builder` form is necessary when the parameter has annotations (such as `@Nullable`).\n@@ -427,20 +435,21 @@ The extended `Builder` form is necessary when the parameter has annotations (suc\n \n Like parameters, fields can be created either with builders or by using convenient helper methods:\n \n-```\n-    FieldSpec android = FieldSpec.builder(String.class, \"android\")\n-        .addModifiers(Modifier.PRIVATE, Modifier.FINAL)\n-        .build();\n-    TypeSpec helloWorld = TypeSpec.classBuilder(\"HelloWorld\")\n-        .addModifiers(Modifier.PUBLIC)\n-        .addField(android)\n-        .addField(String.class, \"robot\", Modifier.PRIVATE, Modifier.FINAL)\n-        .build();\n+```java\n+FieldSpec android = FieldSpec.builder(String.class, \"android\")\n+    .addModifiers(Modifier.PRIVATE, Modifier.FINAL)\n+    .build();\n+    \n+TypeSpec helloWorld = TypeSpec.classBuilder(\"HelloWorld\")\n+    .addModifiers(Modifier.PUBLIC)\n+    .addField(android)\n+    .addField(String.class, \"robot\", Modifier.PRIVATE, Modifier.FINAL)\n+    .build();\n ```\n \n Which generates:\n \n-```\n+```java\n public class HelloWorld {\n   private final String android;\n \n@@ -452,17 +461,17 @@ The extended `Builder` form is necessary when a field has Javadoc, annotations,\n initializer. Field initializers use the same [`String.format()`][formatter]-like syntax as the code\n blocks above:\n \n-```\n-    FieldSpec android = FieldSpec.builder(String.class, \"android\")\n-        .addModifiers(Modifier.PRIVATE, Modifier.FINAL)\n-        .initializer(\"$S + $L\", \"Lollipop v.\", 5.0d)\n-        .build();\n+```java\n+FieldSpec android = FieldSpec.builder(String.class, \"android\")\n+    .addModifiers(Modifier.PRIVATE, Modifier.FINAL)\n+    .initializer(\"$S + $L\", \"Lollipop v.\", 5.0d)\n+    .build();\n ```\n \n Which generates:\n \n-```\n-  private final String android = \"Lollipop v.\" + 5.0;\n+```java\n+private final String android = \"Lollipop v.\" + 5.0;\n ```\n \n ### Interfaces\n@@ -471,23 +480,23 @@ JavaPoet has no trouble with interfaces. Note that interface methods must always\n ABSTRACT` and interface fields must always be `PUBLIC STATIC FINAL`. These modifiers are necessary\n when defining the interface:\n \n-```\n-    TypeSpec helloWorld = TypeSpec.interfaceBuilder(\"HelloWorld\")\n-        .addModifiers(Modifier.PUBLIC)\n-        .addField(FieldSpec.builder(String.class, \"ONLY_THING_THAT_IS_CONSTANT\")\n-            .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)\n-            .initializer(\"$S\", \"change\")\n-            .build())\n-        .addMethod(MethodSpec.methodBuilder(\"beep\")\n-            .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)\n-            .build())\n-        .build();\n+```java\n+TypeSpec helloWorld = TypeSpec.interfaceBuilder(\"HelloWorld\")\n+    .addModifiers(Modifier.PUBLIC)\n+    .addField(FieldSpec.builder(String.class, \"ONLY_THING_THAT_IS_CONSTANT\")\n+        .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)\n+        .initializer(\"$S\", \"change\")\n+        .build())\n+    .addMethod(MethodSpec.methodBuilder(\"beep\")\n+        .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)\n+        .build())\n+    .build();\n ```\n \n But these modifiers are omitted when the code is generated. These are the defaults so we don't need\n to include them for `javac`'s benefit!\n \n-```\n+```java\n public interface HelloWorld {\n   String ONLY_THING_THAT_IS_CONSTANT = \"change\";\n \n@@ -499,18 +508,18 @@ public interface HelloWorld {\n \n Use `enumBuilder` to create the enum type, and `addEnumConstant()` for each value:\n \n-```\n-    TypeSpec helloWorld = TypeSpec.enumBuilder(\"Roshambo\")\n-        .addModifiers(Modifier.PUBLIC)\n-        .addEnumConstant(\"ROCK\")\n-        .addEnumConstant(\"SCISSORS\")\n-        .addEnumConstant(\"PAPER\")\n-        .build();\n+```java\n+TypeSpec helloWorld = TypeSpec.enumBuilder(\"Roshambo\")\n+    .addModifiers(Modifier.PUBLIC)\n+    .addEnumConstant(\"ROCK\")\n+    .addEnumConstant(\"SCISSORS\")\n+    .addEnumConstant(\"PAPER\")\n+    .build();\n ```\n \n To generate this:\n \n-```\n+```java\n public enum Roshambo {\n   ROCK,\n \n@@ -523,31 +532,31 @@ public enum Roshambo {\n Fancy enums are supported, where the enum values override methods or call a superclass constructor.\n Here's a comprehensive example:\n \n-```\n-    TypeSpec helloWorld = TypeSpec.enumBuilder(\"Roshambo\")\n-        .addModifiers(Modifier.PUBLIC)\n-        .addEnumConstant(\"ROCK\", TypeSpec.anonymousClassBuilder(\"$S\", \"fist\")\n-            .addMethod(MethodSpec.methodBuilder(\"toString\")\n-                .addAnnotation(Override.class)\n-                .addModifiers(Modifier.PUBLIC)\n-                .addStatement(\"return $S\", \"avalanche!\")\n-                .build())\n-            .build())\n-        .addEnumConstant(\"SCISSORS\", TypeSpec.anonymousClassBuilder(\"$S\", \"peace\")\n-            .build())\n-        .addEnumConstant(\"PAPER\", TypeSpec.anonymousClassBuilder(\"$S\", \"flat\")\n-            .build())\n-        .addField(String.class, \"handsign\", Modifier.PRIVATE, Modifier.FINAL)\n-        .addMethod(MethodSpec.constructorBuilder()\n-            .addParameter(String.class, \"handsign\")\n-            .addStatement(\"this.$N = $N\", \"handsign\", \"handsign\")\n+```java\n+TypeSpec helloWorld = TypeSpec.enumBuilder(\"Roshambo\")\n+    .addModifiers(Modifier.PUBLIC)\n+    .addEnumConstant(\"ROCK\", TypeSpec.anonymousClassBuilder(\"$S\", \"fist\")\n+        .addMethod(MethodSpec.methodBuilder(\"toString\")\n+            .addAnnotation(Override.class)\n+            .addModifiers(Modifier.PUBLIC)\n+            .addStatement(\"return $S\", \"avalanche!\")\n             .build())\n-        .build();\n+        .build())\n+    .addEnumConstant(\"SCISSORS\", TypeSpec.anonymousClassBuilder(\"$S\", \"peace\")\n+        .build())\n+    .addEnumConstant(\"PAPER\", TypeSpec.anonymousClassBuilder(\"$S\", \"flat\")\n+        .build())\n+    .addField(String.class, \"handsign\", Modifier.PRIVATE, Modifier.FINAL)\n+    .addMethod(MethodSpec.constructorBuilder()\n+        .addParameter(String.class, \"handsign\")\n+        .addStatement(\"this.$N = $N\", \"handsign\", \"handsign\")\n+        .build())\n+    .build();\n ```\n \n Which generates this:\n \n-```\n+```java\n public enum Roshambo {\n   ROCK(\"fist\") {\n     @Override\n@@ -573,37 +582,37 @@ public enum Roshambo {\n In the enum code, we used `Types.anonymousInnerClass()`. Anonymous inner classes can also be used in\n code blocks. They are values that can be referenced with `$L`:\n \n-```\n-    TypeSpec comparator = TypeSpec.anonymousClassBuilder(\"\")\n-        .addSuperinterface(Types.parameterizedType(Comparator.class, String.class))\n-        .addMethod(MethodSpec.methodBuilder(\"compare\")\n-            .addAnnotation(Override.class)\n-            .addModifiers(Modifier.PUBLIC)\n-            .addParameter(String.class, \"a\")\n-            .addParameter(String.class, \"b\")\n-            .addStatement(\"return $N.length() - $N.length()\", \"a\", \"b\")\n-            .build())\n-        .build();\n+```java\n+TypeSpec comparator = TypeSpec.anonymousClassBuilder(\"\")\n+    .addSuperinterface(Types.parameterizedType(Comparator.class, String.class))\n+    .addMethod(MethodSpec.methodBuilder(\"compare\")\n+        .addAnnotation(Override.class)\n+        .addModifiers(Modifier.PUBLIC)\n+        .addParameter(String.class, \"a\")\n+        .addParameter(String.class, \"b\")\n+        .addStatement(\"return $N.length() - $N.length()\", \"a\", \"b\")\n+        .build())\n+    .build();\n \n-    TypeSpec helloWorld = TypeSpec.classBuilder(\"HelloWorld\")\n-        .addMethod(MethodSpec.methodBuilder(\"sortByLength\")\n-            .addParameter(Types.parameterizedType(List.class, String.class), \"strings\")\n-            .addStatement(\"$T.sort($N, $L)\", Collections.class, \"strings\", comparator)\n-            .build())\n-        .build();\n+TypeSpec helloWorld = TypeSpec.classBuilder(\"HelloWorld\")\n+    .addMethod(MethodSpec.methodBuilder(\"sortByLength\")\n+        .addParameter(Types.parameterizedType(List.class, String.class), \"strings\")\n+        .addStatement(\"$T.sort($N, $L)\", Collections.class, \"strings\", comparator)\n+        .build())\n+    .build();\n ```\n \n This generates a method that contains a class that contains a method:\n \n-```\n-  void sortByLength(List<String> strings) {\n-    Collections.sort(strings, new Comparator<String>() {\n-      @Override\n-      public void compare(String a, String b) {\n-        return a.length() - b.length();\n-      }\n-    });\n-  }\n+```java\n+void sortByLength(List<String> strings) {\n+  Collections.sort(strings, new Comparator<String>() {\n+    @Override\n+    public void compare(String a, String b) {\n+      return a.length() - b.length();\n+    }\n+  });\n+}\n ```\n \n One particularly tricky part of defining anonymous inner classes is the arguments to the superclass\n"
    },
    {
        "commit_hash": "2915976d5907512e6f3d3531efaba5b5d1858f4c",
        "previous_commit_hash": "3eeaa642cfba19d7e123a235238aef3d2ecd7237",
        "diff_stats": {
            "additions": 14,
            "deletions": 10
        },
        "diff_content": "@@ -96,11 +96,6 @@ public final class MethodSpec {\n       firstParameter = false;\n     }\n \n-    if (hasModifier(Modifier.ABSTRACT)) {\n-      codeWriter.emit(\");\\n\");\n-      return;\n-    }\n-\n     codeWriter.emit(\")\");\n     if (!exceptions.isEmpty()) {\n       codeWriter.emit(\" throws\");\n@@ -111,13 +106,22 @@ public final class MethodSpec {\n         firstException = false;\n       }\n     }\n-    codeWriter.emit(\" {\\n\");\n \n-    codeWriter.indent();\n-    codeWriter.emit(code);\n-    codeWriter.unindent();\n+    if (hasModifier(Modifier.ABSTRACT)) {\n+      codeWriter.emit(\";\\n\");\n+    } else if (hasModifier(Modifier.NATIVE)) {\n+      // Code is allowed to support stuff like GWT JSNI.\n+      codeWriter.emit(code);\n+      codeWriter.emit(\";\\n\");\n+    } else {\n+      codeWriter.emit(\" {\\n\");\n+\n+      codeWriter.indent();\n+      codeWriter.emit(code);\n+      codeWriter.unindent();\n \n-    codeWriter.emit(\"}\\n\");\n+      codeWriter.emit(\"}\\n\");\n+    }\n   }\n \n   public boolean hasModifier(Modifier modifier) {\n"
    },
    {
        "commit_hash": "2915976d5907512e6f3d3531efaba5b5d1858f4c",
        "previous_commit_hash": "3eeaa642cfba19d7e123a235238aef3d2ecd7237",
        "diff_stats": {
            "additions": 47,
            "deletions": 1
        },
        "diff_content": "@@ -385,6 +385,7 @@ public final class TypeSpecTest {\n \n   @Test public void methodThrows() throws Exception {\n     TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n+        .addModifiers(Modifier.ABSTRACT)\n         .addMethod(MethodSpec.methodBuilder(\"throwOne\")\n             .addException(IOException.class)\n             .build())\n@@ -392,18 +393,30 @@ public final class TypeSpecTest {\n             .addException(IOException.class)\n             .addException(ClassName.get(tacosPackage, \"SourCreamException\"))\n             .build())\n+        .addMethod(MethodSpec.methodBuilder(\"abstractThrow\")\n+            .addModifiers(Modifier.ABSTRACT)\n+            .addException(IOException.class)\n+            .build())\n+        .addMethod(MethodSpec.methodBuilder(\"nativeThrow\")\n+            .addModifiers(Modifier.NATIVE)\n+            .addException(IOException.class)\n+            .build())\n         .build();\n     assertThat(toString(taco)).isEqualTo(\"\"\n         + \"package com.squareup.tacos;\\n\"\n         + \"\\n\"\n         + \"import java.io.IOException;\\n\"\n         + \"\\n\"\n-        + \"class Taco {\\n\"\n+        + \"abstract class Taco {\\n\"\n         + \"  void throwOne() throws IOException {\\n\"\n         + \"  }\\n\"\n         + \"\\n\"\n         + \"  void throwTwo() throws IOException, SourCreamException {\\n\"\n         + \"  }\\n\"\n+        + \"\\n\"\n+        + \"  abstract void abstractThrow() throws IOException;\\n\"\n+        + \"\\n\"\n+        + \"  native void nativeThrow() throws IOException;\\n\"\n         + \"}\\n\");\n   }\n \n@@ -1020,6 +1033,39 @@ public final class TypeSpecTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void nativeMethods() throws Exception {\n+    TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n+        .addMethod(MethodSpec.methodBuilder(\"nativeInt\")\n+            .addModifiers(Modifier.NATIVE)\n+            .returns(int.class)\n+            .build())\n+        // GWT JSNI\n+        .addMethod(MethodSpec.methodBuilder(\"alert\")\n+            .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.NATIVE)\n+            .addParameter(String.class, \"msg\")\n+            .addCode(CodeBlock.builder()\n+                .add(\" /*-{\\n\")\n+                .indent()\n+                .addStatement(\"$$wnd.alert(msg)\")\n+                .unindent()\n+                .add(\"}-*/\")\n+                .build())\n+            .build())\n+        .build();\n+    assertThat(toString(taco)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import java.lang.String;\\n\"\n+        + \"\\n\"\n+        + \"class Taco {\\n\"\n+        + \"  native int nativeInt();\\n\"\n+        + \"\\n\"\n+        + \"  public static native void alert(String msg) /*-{\\n\"\n+        + \"    $wnd.alert(msg);\\n\"\n+        + \"  }-*/;\\n\"\n+        + \"}\\n\");\n+  }\n+\n   private String toString(TypeSpec typeSpec) {\n     return JavaFile.builder(tacosPackage, typeSpec).build().toString();\n   }\n"
    },
    {
        "commit_hash": "173eaffa5562c4fde854a40b3ab11c3dc59df80d",
        "previous_commit_hash": "4d301bc365f24038f0fb9ec8212f63952a9cf90b",
        "diff_stats": {
            "additions": 1,
            "deletions": 2
        },
        "diff_content": "@@ -371,11 +371,10 @@ public final class TypeSpec {\n     }\n \n     public TypeSpec build() {\n-      boolean isInterface = kind == Kind.INTERFACE;\n-      boolean isAbstract = modifiers.contains(Modifier.ABSTRACT) || isInterface;\n       checkArgument(kind != Kind.ENUM || !enumConstants.isEmpty(),\n           \"at least one enum constant is required for %s\", name);\n \n+      boolean isAbstract = modifiers.contains(Modifier.ABSTRACT) || kind != Kind.CLASS;\n       for (MethodSpec methodSpec : methodSpecs) {\n         checkArgument(isAbstract || !methodSpec.hasModifier(Modifier.ABSTRACT),\n             \"non-abstract type %s cannot declare abstract method %s\", name, methodSpec.name);\n"
    },
    {
        "commit_hash": "173eaffa5562c4fde854a40b3ab11c3dc59df80d",
        "previous_commit_hash": "4d301bc365f24038f0fb9ec8212f63952a9cf90b",
        "diff_stats": {
            "additions": 30,
            "deletions": 0
        },
        "diff_content": "@@ -337,6 +337,36 @@ public final class TypeSpecTest {\n         + \"}\\n\");\n   }\n \n+  /** https://github.com/square/javapoet/issues/193 */\n+  @Test public void enumsMayDefineAbstractMethods() throws Exception {\n+    TypeSpec roshambo = TypeSpec.enumBuilder(\"Tortilla\")\n+        .addModifiers(Modifier.PUBLIC)\n+        .addEnumConstant(\"CORN\", TypeSpec.anonymousClassBuilder(\"\")\n+            .addMethod(MethodSpec.methodBuilder(\"fold\")\n+                .addAnnotation(Override.class)\n+                .addModifiers(Modifier.PUBLIC)\n+                .build())\n+            .build())\n+        .addMethod(MethodSpec.methodBuilder(\"fold\")\n+            .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)\n+            .build())\n+        .build();\n+    assertThat(toString(roshambo)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import java.lang.Override;\\n\"\n+        + \"\\n\"\n+        + \"public enum Tortilla {\\n\"\n+        + \"  CORN {\\n\"\n+        + \"    @Override\\n\"\n+        + \"    public void fold() {\\n\"\n+        + \"    }\\n\"\n+        + \"  };\\n\"\n+        + \"\\n\"\n+        + \"  public abstract void fold();\\n\"\n+        + \"}\\n\");\n+  }\n+\n   @Test public void enumConstantsRequired() throws Exception {\n     try {\n       TypeSpec.enumBuilder(\"Roshambo\")\n"
    },
    {
        "commit_hash": "7e28c6f7bbb204048d144ed0b09966128dd7ea2d",
        "previous_commit_hash": "3542eba0b9a822fe051b25265175fd6acf5561dd",
        "diff_stats": {
            "additions": 9,
            "deletions": 1
        },
        "diff_content": "@@ -45,6 +45,9 @@ import static com.google.common.base.Preconditions.checkState;\n  *   <li>{@code $$} emits a dollar sign.\n  *   <li>{@code $&gt;} increases the indentation level.\n  *   <li>{@code $&lt;} decreases the indentation level.\n+ *   <li>{@code $[} begins a statement. For multiline statements, every line after the first line\n+ *       is double-indented.\n+ *   <li>{@code $]} ends a statement.\n  * </ul>\n  */\n public final class CodeBlock {\n@@ -90,6 +93,8 @@ public final class CodeBlock {\n             case '$':\n             case '>':\n             case '<':\n+            case '[':\n+            case ']':\n               nextP = p + 2;\n               break;\n \n@@ -148,7 +153,10 @@ public final class CodeBlock {\n     }\n \n     public Builder addStatement(String format, Object... args) {\n-      return add(format + \";\\n\", args);\n+      add(\"$[\");\n+      add(format, args);\n+      add(\";\\n$]\");\n+      return this;\n     }\n \n     public Builder add(CodeBlock codeBlock) {\n"
    },
    {
        "commit_hash": "7e28c6f7bbb204048d144ed0b09966128dd7ea2d",
        "previous_commit_hash": "3542eba0b9a822fe051b25265175fd6acf5561dd",
        "diff_stats": {
            "additions": 26,
            "deletions": 0
        },
        "diff_content": "@@ -61,6 +61,13 @@ final class CodeWriter {\n   private final Set<ClassName> importableTypes = new LinkedHashSet<>();\n   private boolean trailingNewline;\n \n+  /**\n+   * When emitting a statement, this is the line of the statement currently being written. The first\n+   * line of a statement is indented normally and subsequent wrapped lines are double-indented. This\n+   * is -1 when the currently-written line isn't part of a statement.\n+   */\n+  int statementLine = -1;\n+\n   public CodeWriter(Appendable out) {\n     this(out, ImmutableMap.<ClassName, String>of());\n   }\n@@ -225,6 +232,19 @@ final class CodeWriter {\n           unindent();\n           break;\n \n+        case \"$[\":\n+          checkState(statementLine == -1, \"statements cannot be re-entrant\");\n+          statementLine = 0;\n+          break;\n+\n+        case \"$]\":\n+          checkState(statementLine != -1, \"statement exit has no matching statement enter\");\n+          if (statementLine > 0) {\n+            unindent(2); // End a multi-line statement. Decrease the indentation level.\n+          }\n+          statementLine = -1;\n+          break;\n+\n         default:\n           emitAndIndent(part);\n           break;\n@@ -393,6 +413,12 @@ final class CodeWriter {\n         }\n         out.append('\\n');\n         trailingNewline = true;\n+        if (statementLine != -1) {\n+          if (statementLine == 0) {\n+            indent(2); // Begin multiple-line statement. Increase the indentation level.\n+          }\n+          statementLine++;\n+        }\n       }\n \n       first = false;\n"
    },
    {
        "commit_hash": "7e28c6f7bbb204048d144ed0b09966128dd7ea2d",
        "previous_commit_hash": "3542eba0b9a822fe051b25265175fd6acf5561dd",
        "diff_stats": {
            "additions": 114,
            "deletions": 104
        },
        "diff_content": "@@ -103,126 +103,136 @@ public final class TypeSpec {\n \n   void emit(CodeWriter codeWriter, String enumName, Set<Modifier> implicitModifiers)\n       throws IOException {\n-    if (enumName != null) {\n-      codeWriter.emit(\"$L\", enumName);\n-      if (!anonymousTypeArguments.formatParts.isEmpty()) {\n-        codeWriter.emit(\"(\");\n+    // Nested classes interrupt wrapped line indentation. Stash the current wrapping state and put\n+    // it back afterwards when this type is complete.\n+    int previousStatementLine = codeWriter.statementLine;\n+    codeWriter.statementLine = -1;\n+\n+    try {\n+      if (enumName != null) {\n+        codeWriter.emit(\"$L\", enumName);\n+        if (!anonymousTypeArguments.formatParts.isEmpty()) {\n+          codeWriter.emit(\"(\");\n+          codeWriter.emit(anonymousTypeArguments);\n+          codeWriter.emit(\")\");\n+        }\n+        if (fieldSpecs.isEmpty() && methodSpecs.isEmpty() && typeSpecs.isEmpty()) {\n+          return; // Avoid unnecessary braces \"{}\".\n+        }\n+        codeWriter.emit(\" {\\n\");\n+      } else if (anonymousTypeArguments != null) {\n+        codeWriter.emit(\"new $T(\", getOnlyElement(superinterfaces, superclass));\n         codeWriter.emit(anonymousTypeArguments);\n-        codeWriter.emit(\")\");\n-      }\n-      if (fieldSpecs.isEmpty() && methodSpecs.isEmpty() && typeSpecs.isEmpty()) {\n-        return; // Avoid unnecessary braces \"{}\".\n-      }\n-      codeWriter.emit(\" {\\n\");\n-    } else if (anonymousTypeArguments != null) {\n-      codeWriter.emit(\"new $T(\", getOnlyElement(superinterfaces, superclass));\n-      codeWriter.emit(anonymousTypeArguments);\n-      codeWriter.emit(\") {\\n\");\n-    } else {\n-      codeWriter.emitJavadoc(javadoc);\n-      codeWriter.emitAnnotations(annotations, false);\n-      codeWriter.emitModifiers(modifiers, Sets.union(implicitModifiers, kind.asMemberModifiers));\n-      codeWriter.emit(\"$L $L\", Ascii.toLowerCase(kind.name()), name);\n-      codeWriter.emitTypeVariables(typeVariables);\n-\n-      List<Type> extendsTypes;\n-      List<Type> implementsTypes;\n-      if (kind == Kind.INTERFACE) {\n-        extendsTypes = superinterfaces;\n-        implementsTypes = ImmutableList.of();\n+        codeWriter.emit(\") {\\n\");\n       } else {\n-        extendsTypes = superclass.equals(ClassName.OBJECT)\n-            ? ImmutableList.<Type>of()\n-            : ImmutableList.of(superclass);\n-        implementsTypes = superinterfaces;\n-      }\n+        codeWriter.emitJavadoc(javadoc);\n+        codeWriter.emitAnnotations(annotations, false);\n+        codeWriter.emitModifiers(modifiers, Sets.union(implicitModifiers, kind.asMemberModifiers));\n+        codeWriter.emit(\"$L $L\", Ascii.toLowerCase(kind.name()), name);\n+        codeWriter.emitTypeVariables(typeVariables);\n+\n+        List<Type> extendsTypes;\n+        List<Type> implementsTypes;\n+        if (kind == Kind.INTERFACE) {\n+          extendsTypes = superinterfaces;\n+          implementsTypes = ImmutableList.of();\n+        } else {\n+          extendsTypes = superclass.equals(ClassName.OBJECT)\n+              ? ImmutableList.<Type>of()\n+              : ImmutableList.of(superclass);\n+          implementsTypes = superinterfaces;\n+        }\n \n-      if (!extendsTypes.isEmpty()) {\n-        codeWriter.emit(\" extends\");\n-        boolean firstType = true;\n-        for (Type type : extendsTypes) {\n-          if (!firstType) codeWriter.emit(\",\");\n-          codeWriter.emit(\" $T\", type);\n-          firstType = false;\n+        if (!extendsTypes.isEmpty()) {\n+          codeWriter.emit(\" extends\");\n+          boolean firstType = true;\n+          for (Type type : extendsTypes) {\n+            if (!firstType) codeWriter.emit(\",\");\n+            codeWriter.emit(\" $T\", type);\n+            firstType = false;\n+          }\n         }\n-      }\n \n-      if (!implementsTypes.isEmpty()) {\n-        codeWriter.emit(\" implements\");\n-        boolean firstType = true;\n-        for (Type type : implementsTypes) {\n-          if (!firstType) codeWriter.emit(\",\");\n-          codeWriter.emit(\" $T\", type);\n-          firstType = false;\n+        if (!implementsTypes.isEmpty()) {\n+          codeWriter.emit(\" implements\");\n+          boolean firstType = true;\n+          for (Type type : implementsTypes) {\n+            if (!firstType) codeWriter.emit(\",\");\n+            codeWriter.emit(\" $T\", type);\n+            firstType = false;\n+          }\n         }\n-      }\n \n-      codeWriter.emit(\" {\\n\");\n-    }\n+        codeWriter.emit(\" {\\n\");\n+      }\n \n-    codeWriter.pushType(this);\n-    codeWriter.indent();\n-    boolean firstMember = true;\n-    for (Iterator<Map.Entry<String, TypeSpec>> i = enumConstants.entrySet().iterator();\n-        i.hasNext();) {\n-      Map.Entry<String, TypeSpec> enumConstant = i.next();\n-      if (!firstMember) codeWriter.emit(\"\\n\");\n-      enumConstant.getValue().emit(codeWriter, enumConstant.getKey(), ImmutableSet.<Modifier>of());\n-      firstMember = false;\n-      if (i.hasNext()) {\n-        codeWriter.emit(\",\\n\");\n-      } else if (!fieldSpecs.isEmpty() || !methodSpecs.isEmpty() || !typeSpecs.isEmpty()) {\n-        codeWriter.emit(\";\\n\");\n-      } else {\n-        codeWriter.emit(\"\\n\");\n+      codeWriter.pushType(this);\n+      codeWriter.indent();\n+      boolean firstMember = true;\n+      for (Iterator<Map.Entry<String, TypeSpec>> i = enumConstants.entrySet().iterator();\n+          i.hasNext();) {\n+        Map.Entry<String, TypeSpec> enumConstant = i.next();\n+        if (!firstMember) codeWriter.emit(\"\\n\");\n+        enumConstant.getValue()\n+            .emit(codeWriter, enumConstant.getKey(), ImmutableSet.<Modifier>of());\n+        firstMember = false;\n+        if (i.hasNext()) {\n+          codeWriter.emit(\",\\n\");\n+        } else if (!fieldSpecs.isEmpty() || !methodSpecs.isEmpty() || !typeSpecs.isEmpty()) {\n+          codeWriter.emit(\";\\n\");\n+        } else {\n+          codeWriter.emit(\"\\n\");\n+        }\n       }\n-    }\n \n-    // Static fields.\n-    for (FieldSpec fieldSpec : fieldSpecs) {\n-      if (!fieldSpec.hasModifier(Modifier.STATIC)) continue;\n-      if (!firstMember) codeWriter.emit(\"\\n\");\n-      fieldSpec.emit(codeWriter, kind.implicitFieldModifiers);\n-      firstMember = false;\n-    }\n+      // Static fields.\n+      for (FieldSpec fieldSpec : fieldSpecs) {\n+        if (!fieldSpec.hasModifier(Modifier.STATIC)) continue;\n+        if (!firstMember) codeWriter.emit(\"\\n\");\n+        fieldSpec.emit(codeWriter, kind.implicitFieldModifiers);\n+        firstMember = false;\n+      }\n \n-    // Non-static fields.\n-    for (FieldSpec fieldSpec : fieldSpecs) {\n-      if (fieldSpec.hasModifier(Modifier.STATIC)) continue;\n-      if (!firstMember) codeWriter.emit(\"\\n\");\n-      fieldSpec.emit(codeWriter, kind.implicitFieldModifiers);\n-      firstMember = false;\n-    }\n+      // Non-static fields.\n+      for (FieldSpec fieldSpec : fieldSpecs) {\n+        if (fieldSpec.hasModifier(Modifier.STATIC)) continue;\n+        if (!firstMember) codeWriter.emit(\"\\n\");\n+        fieldSpec.emit(codeWriter, kind.implicitFieldModifiers);\n+        firstMember = false;\n+      }\n \n-    // Constructors.\n-    for (MethodSpec methodSpec : methodSpecs) {\n-      if (!methodSpec.isConstructor()) continue;\n-      if (!firstMember) codeWriter.emit(\"\\n\");\n-      methodSpec.emit(codeWriter, name, kind.implicitMethodModifiers);\n-      firstMember = false;\n-    }\n+      // Constructors.\n+      for (MethodSpec methodSpec : methodSpecs) {\n+        if (!methodSpec.isConstructor()) continue;\n+        if (!firstMember) codeWriter.emit(\"\\n\");\n+        methodSpec.emit(codeWriter, name, kind.implicitMethodModifiers);\n+        firstMember = false;\n+      }\n \n-    // Methods (static and non-static).\n-    for (MethodSpec methodSpec : methodSpecs) {\n-      if (methodSpec.isConstructor()) continue;\n-      if (!firstMember) codeWriter.emit(\"\\n\");\n-      methodSpec.emit(codeWriter, name, kind.implicitMethodModifiers);\n-      firstMember = false;\n-    }\n+      // Methods (static and non-static).\n+      for (MethodSpec methodSpec : methodSpecs) {\n+        if (methodSpec.isConstructor()) continue;\n+        if (!firstMember) codeWriter.emit(\"\\n\");\n+        methodSpec.emit(codeWriter, name, kind.implicitMethodModifiers);\n+        firstMember = false;\n+      }\n \n-    // Types.\n-    for (TypeSpec typeSpec : typeSpecs) {\n-      if (!firstMember) codeWriter.emit(\"\\n\");\n-      typeSpec.emit(codeWriter, null, kind.implicitTypeModifiers);\n-      firstMember = false;\n-    }\n+      // Types.\n+      for (TypeSpec typeSpec : typeSpecs) {\n+        if (!firstMember) codeWriter.emit(\"\\n\");\n+        typeSpec.emit(codeWriter, null, kind.implicitTypeModifiers);\n+        firstMember = false;\n+      }\n \n-    codeWriter.unindent();\n-    codeWriter.popType();\n+      codeWriter.unindent();\n+      codeWriter.popType();\n \n-    codeWriter.emit(\"}\");\n-    if (enumName == null && anonymousTypeArguments == null) {\n-      codeWriter.emit(\"\\n\"); // If this type isn't also a value, include a trailing newline.\n+      codeWriter.emit(\"}\");\n+      if (enumName == null && anonymousTypeArguments == null) {\n+        codeWriter.emit(\"\\n\"); // If this type isn't also a value, include a trailing newline.\n+      }\n+    } finally {\n+      codeWriter.statementLine = previousStatementLine;\n     }\n   }\n \n"
    },
    {
        "commit_hash": "7e28c6f7bbb204048d144ed0b09966128dd7ea2d",
        "previous_commit_hash": "3542eba0b9a822fe051b25265175fd6acf5561dd",
        "diff_stats": {
            "additions": 91,
            "deletions": 0
        },
        "diff_content": "@@ -18,8 +18,10 @@ package com.squareup.javapoet;\n import java.io.IOException;\n import java.io.Serializable;\n import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n import java.lang.reflect.TypeVariable;\n import java.util.AbstractSet;\n+import java.util.Collections;\n import java.util.Comparator;\n import java.util.List;\n import java.util.Locale;\n@@ -1099,4 +1101,93 @@ public final class TypeSpecTest {\n   private String toString(TypeSpec typeSpec) {\n     return JavaFile.builder(tacosPackage, typeSpec).build().toString();\n   }\n+\n+  @Test public void multilineStatement() throws Exception {\n+    TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n+        .addMethod(MethodSpec.methodBuilder(\"toString\")\n+            .addAnnotation(Override.class)\n+            .addModifiers(Modifier.PUBLIC)\n+            .returns(String.class)\n+            .addStatement(\"return $S\\n+ $S\\n+ $S\\n+ $S\\n+ $S\",\n+                \"Taco(\", \"beef,\", \"lettuce,\", \"cheese\", \")\")\n+            .build())\n+        .build();\n+    assertThat(toString(taco)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import java.lang.Override;\\n\"\n+        + \"import java.lang.String;\\n\"\n+        + \"\\n\"\n+        + \"class Taco {\\n\"\n+        + \"  @Override\\n\"\n+        + \"  public String toString() {\\n\"\n+        + \"    return \\\"Taco(\\\"\\n\"\n+        + \"        + \\\"beef,\\\"\\n\"\n+        + \"        + \\\"lettuce,\\\"\\n\"\n+        + \"        + \\\"cheese\\\"\\n\"\n+        + \"        + \\\")\\\";\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void multilineStatementWithAnonymousClass() throws Exception {\n+    Type stringComparator = Types.parameterizedType(Comparator.class, String.class);\n+    Type listOfString = Types.parameterizedType(List.class, String.class);\n+    TypeSpec prefixComparator = TypeSpec.anonymousClassBuilder(\"\")\n+        .addSuperinterface(stringComparator)\n+        .addMethod(MethodSpec.methodBuilder(\"compare\")\n+            .addAnnotation(Override.class)\n+            .addModifiers(Modifier.PUBLIC)\n+            .returns(int.class)\n+            .addParameter(String.class, \"a\")\n+            .addParameter(String.class, \"b\")\n+            .addStatement(\"return a.substring(0, length)\\n\"\n+                + \".compareTo(b.substring(0, length))\")\n+            .build())\n+        .build();\n+    TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n+        .addMethod(MethodSpec.methodBuilder(\"comparePrefix\")\n+            .returns(stringComparator)\n+            .addParameter(int.class, \"length\", Modifier.FINAL)\n+            .addStatement(\"return $L\", prefixComparator)\n+            .build())\n+        .addMethod(MethodSpec.methodBuilder(\"sortPrefix\")\n+            .addParameter(listOfString, \"list\")\n+            .addParameter(int.class, \"length\", Modifier.FINAL)\n+            .addStatement(\"$T.sort(\\nlist,\\n$L)\", Collections.class, prefixComparator)\n+            .build())\n+        .build();\n+    assertThat(toString(taco)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import java.lang.Override;\\n\"\n+        + \"import java.lang.String;\\n\"\n+        + \"import java.util.Collections;\\n\"\n+        + \"import java.util.Comparator;\\n\"\n+        + \"import java.util.List;\\n\"\n+        + \"\\n\"\n+        + \"class Taco {\\n\"\n+        + \"  Comparator<String> comparePrefix(final int length) {\\n\"\n+        + \"    return new Comparator<String>() {\\n\"\n+        + \"      @Override\\n\"\n+        + \"      public int compare(String a, String b) {\\n\"\n+        + \"        return a.substring(0, length)\\n\"\n+        + \"            .compareTo(b.substring(0, length));\\n\"\n+        + \"      }\\n\"\n+        + \"    };\\n\"\n+        + \"  }\\n\"\n+        + \"\\n\"\n+        + \"  void sortPrefix(List<String> list, final int length) {\\n\"\n+        + \"    Collections.sort(\\n\"\n+        + \"        list,\\n\"\n+        + \"        new Comparator<String>() {\\n\"\n+        + \"          @Override\\n\"\n+        + \"          public int compare(String a, String b) {\\n\"\n+        + \"            return a.substring(0, length)\\n\"\n+        + \"                .compareTo(b.substring(0, length));\\n\"\n+        + \"          }\\n\"\n+        + \"        });\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n }\n"
    },
    {
        "commit_hash": "4d69659d36ef486afbbe8eb9e79bd56ebc57feb4",
        "previous_commit_hash": "3542eba0b9a822fe051b25265175fd6acf5561dd",
        "diff_stats": {
            "additions": 10,
            "deletions": 8
        },
        "diff_content": "@@ -15,7 +15,9 @@\n  */\n package com.squareup.javapoet;\n \n-import com.google.common.collect.ImmutableList;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n@@ -49,12 +51,12 @@ import static com.google.common.base.Preconditions.checkState;\n  */\n public final class CodeBlock {\n   /** A heterogeneous list containing string literals and value placeholders. */\n-  final ImmutableList<String> formatParts;\n-  final ImmutableList<Object> args;\n+  final List<String> formatParts;\n+  final List<Object> args;\n \n   private CodeBlock(Builder builder) {\n-    this.formatParts = builder.formatParts.build();\n-    this.args = builder.args.build();\n+    this.formatParts = Collections.unmodifiableList(new ArrayList<>(builder.formatParts));\n+    this.args = Collections.unmodifiableList(new ArrayList<>(builder.args));\n   }\n \n   public boolean isEmpty() {\n@@ -66,8 +68,8 @@ public final class CodeBlock {\n   }\n \n   public static final class Builder {\n-    final ImmutableList.Builder<String> formatParts = ImmutableList.builder();\n-    final ImmutableList.Builder<Object> args = ImmutableList.builder();\n+    final List<String> formatParts = new ArrayList<>();\n+    final List<Object> args = new ArrayList<>();\n \n     private Builder() {\n     }\n@@ -104,7 +106,7 @@ public final class CodeBlock {\n       checkArgument(args.length == expectedArgsLength,\n           \"expected %s args for %s but was %s\", expectedArgsLength, format, args.length);\n \n-      this.args.add(args);\n+      Collections.addAll(this.args, args);\n       return this;\n     }\n \n"
    },
    {
        "commit_hash": "4d69659d36ef486afbbe8eb9e79bd56ebc57feb4",
        "previous_commit_hash": "3542eba0b9a822fe051b25265175fd6acf5561dd",
        "diff_stats": {
            "additions": 5,
            "deletions": 2
        },
        "diff_content": "@@ -205,8 +205,11 @@ final class CodeWriter {\n           break;\n \n         case \"$S\":\n-          String arg = String.valueOf(codeBlock.args.get(a++));\n-          emitAndIndent(stringLiteral(arg));\n+          Object arg = codeBlock.args.get(a++);\n+          // Emit null as a literal null: no quotes.\n+          emitAndIndent(arg != null\n+              ? stringLiteral(String.valueOf(arg))\n+              : \"null\");\n           break;\n \n         case \"$T\":\n"
    },
    {
        "commit_hash": "4d69659d36ef486afbbe8eb9e79bd56ebc57feb4",
        "previous_commit_hash": "3542eba0b9a822fe051b25265175fd6acf5561dd",
        "diff_stats": {
            "additions": 4,
            "deletions": 2
        },
        "diff_content": "@@ -70,8 +70,10 @@ public final class JavaPoet {\n \n   public void writeTo(Filer filer) throws IOException {\n     for (JavaFile javaFile : javaFiles) {\n-      JavaFileObject filerSourceFile = filer.createSourceFile(\n-          javaFile.packageName + \".\" + javaFile.typeSpec.name,\n+      String fileName = javaFile.packageName.isEmpty()\n+          ? javaFile.typeSpec.name\n+          : javaFile.packageName + \".\" + javaFile.typeSpec.name;\n+      JavaFileObject filerSourceFile = filer.createSourceFile(fileName,\n           Iterables.toArray(javaFile.typeSpec.originatingElements, Element.class));\n       try (Writer writer = filerSourceFile.openWriter()) {\n         javaFile.emit(writer);\n"
    },
    {
        "commit_hash": "4d69659d36ef486afbbe8eb9e79bd56ebc57feb4",
        "previous_commit_hash": "3542eba0b9a822fe051b25265175fd6acf5561dd",
        "diff_stats": {
            "additions": 16,
            "deletions": 0
        },
        "diff_content": "@@ -1096,6 +1096,22 @@ public final class TypeSpecTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void nullStringLiteral() throws Exception {\n+    TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n+        .addField(FieldSpec.builder(String.class, \"NULL\")\n+            .initializer(\"$S\", (Object) null)\n+            .build())\n+        .build();\n+    assertThat(toString(taco)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import java.lang.String;\\n\"\n+        + \"\\n\"\n+        + \"class Taco {\\n\"\n+        + \"  String NULL = null;\\n\"\n+        + \"}\\n\");\n+  }\n+\n   private String toString(TypeSpec typeSpec) {\n     return JavaFile.builder(tacosPackage, typeSpec).build().toString();\n   }\n"
    },
    {
        "commit_hash": "e8c123dff94080b5114ae784d34b200c3880d7ea",
        "previous_commit_hash": "75725cd819943bb1cb6e1e62dc78542fd560cd24",
        "diff_stats": {
            "additions": 12,
            "deletions": 0
        },
        "diff_content": "@@ -22,6 +22,7 @@ import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Multimap;\n import com.google.common.collect.Multimaps;\n import java.io.IOException;\n+import java.io.StringWriter;\n import java.lang.reflect.Type;\n import java.util.ArrayList;\n import java.util.Collection;\n@@ -113,6 +114,17 @@ public final class AnnotationSpec {\n     return type.hashCode() + 37 * members.hashCode();\n   }\n \n+  @Override public String toString() {\n+    StringWriter out = new StringWriter();\n+    try {\n+      CodeWriter codeWriter = new CodeWriter(out);\n+      codeWriter.emit(\"$L\", this);\n+      return out.toString();\n+    } catch (IOException e) {\n+      throw new AssertionError();\n+    }\n+  }\n+\n   public static final class Builder {\n     private final Type type;\n     private final Multimap<String, CodeBlock> members = Multimaps.newListMultimap(\n"
    },
    {
        "commit_hash": "e8c123dff94080b5114ae784d34b200c3880d7ea",
        "previous_commit_hash": "75725cd819943bb1cb6e1e62dc78542fd560cd24",
        "diff_stats": {
            "additions": 12,
            "deletions": 0
        },
        "diff_content": "@@ -15,6 +15,8 @@\n  */\n package com.squareup.javapoet;\n \n+import java.io.IOException;\n+import java.io.StringWriter;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n@@ -66,6 +68,16 @@ public final class CodeBlock {\n     return formatParts.isEmpty();\n   }\n \n+  @Override public String toString() {\n+    StringWriter out = new StringWriter();\n+    try {\n+      new CodeWriter(out).emit(this);\n+      return out.toString();\n+    } catch (IOException e) {\n+      throw new AssertionError();\n+    }\n+  }\n+\n   public static Builder builder() {\n     return new Builder();\n   }\n"
    },
    {
        "commit_hash": "e8c123dff94080b5114ae784d34b200c3880d7ea",
        "previous_commit_hash": "75725cd819943bb1cb6e1e62dc78542fd560cd24",
        "diff_stats": {
            "additions": 12,
            "deletions": 0
        },
        "diff_content": "@@ -18,6 +18,7 @@ package com.squareup.javapoet;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n import java.io.IOException;\n+import java.io.StringWriter;\n import java.lang.reflect.Type;\n import java.util.ArrayList;\n import java.util.Collections;\n@@ -63,6 +64,17 @@ public final class FieldSpec {\n     codeWriter.emit(\";\\n\");\n   }\n \n+  @Override public String toString() {\n+    StringWriter out = new StringWriter();\n+    try {\n+      CodeWriter codeWriter = new CodeWriter(out);\n+      emit(codeWriter, ImmutableSet.<Modifier>of());\n+      return out.toString();\n+    } catch (IOException e) {\n+      throw new AssertionError();\n+    }\n+  }\n+\n   public static Builder builder(Type type, String name, Modifier... modifiers) {\n     checkNotNull(type, \"type == null\");\n     checkArgument(SourceVersion.isName(name), \"not a valid name: %s\", name);\n"
    },
    {
        "commit_hash": "e8c123dff94080b5114ae784d34b200c3880d7ea",
        "previous_commit_hash": "75725cd819943bb1cb6e1e62dc78542fd560cd24",
        "diff_stats": {
            "additions": 12,
            "deletions": 0
        },
        "diff_content": "@@ -18,6 +18,7 @@ package com.squareup.javapoet;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n import java.io.IOException;\n+import java.io.StringWriter;\n import java.lang.reflect.Type;\n import java.lang.reflect.TypeVariable;\n import java.util.ArrayList;\n@@ -132,6 +133,17 @@ public final class MethodSpec {\n     return name.equals(CONSTRUCTOR);\n   }\n \n+  @Override public String toString() {\n+    StringWriter out = new StringWriter();\n+    try {\n+      CodeWriter codeWriter = new CodeWriter(out);\n+      emit(codeWriter, \"Constructor\", ImmutableSet.<Modifier>of());\n+      return out.toString();\n+    } catch (IOException e) {\n+      throw new AssertionError();\n+    }\n+  }\n+\n   public static Builder methodBuilder(String name) {\n     return new Builder(name);\n   }\n"
    },
    {
        "commit_hash": "e8c123dff94080b5114ae784d34b200c3880d7ea",
        "previous_commit_hash": "75725cd819943bb1cb6e1e62dc78542fd560cd24",
        "diff_stats": {
            "additions": 12,
            "deletions": 0
        },
        "diff_content": "@@ -18,6 +18,7 @@ package com.squareup.javapoet;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n import java.io.IOException;\n+import java.io.StringWriter;\n import java.lang.reflect.Type;\n import java.util.ArrayList;\n import java.util.Collections;\n@@ -56,6 +57,17 @@ public final class ParameterSpec {\n     }\n   }\n \n+  @Override public String toString() {\n+    StringWriter out = new StringWriter();\n+    try {\n+      CodeWriter codeWriter = new CodeWriter(out);\n+      emit(codeWriter, false);\n+      return out.toString();\n+    } catch (IOException e) {\n+      throw new AssertionError();\n+    }\n+  }\n+\n   public static Builder builder(Type type, String name, Modifier... modifiers) {\n     checkNotNull(type, \"type == null\");\n     checkArgument(SourceVersion.isName(name), \"not a valid name: %s\", name);\n"
    },
    {
        "commit_hash": "e8c123dff94080b5114ae784d34b200c3880d7ea",
        "previous_commit_hash": "75725cd819943bb1cb6e1e62dc78542fd560cd24",
        "diff_stats": {
            "additions": 12,
            "deletions": 0
        },
        "diff_content": "@@ -21,6 +21,7 @@ import com.google.common.collect.ImmutableMap;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Sets;\n import java.io.IOException;\n+import java.io.StringWriter;\n import java.lang.reflect.Type;\n import java.lang.reflect.TypeVariable;\n import java.util.ArrayList;\n@@ -236,6 +237,17 @@ public final class TypeSpec {\n     }\n   }\n \n+  @Override public String toString() {\n+    StringWriter out = new StringWriter();\n+    try {\n+      CodeWriter codeWriter = new CodeWriter(out);\n+      emit(codeWriter, null, ImmutableSet.<Modifier>of());\n+      return out.toString();\n+    } catch (IOException e) {\n+      throw new AssertionError();\n+    }\n+  }\n+\n   private enum Kind {\n     CLASS(\n         ImmutableSet.<Modifier>of(),\n"
    },
    {
        "commit_hash": "e8c123dff94080b5114ae784d34b200c3880d7ea",
        "previous_commit_hash": "75725cd819943bb1cb6e1e62dc78542fd560cd24",
        "diff_stats": {
            "additions": 89,
            "deletions": 0
        },
        "diff_content": "@@ -1114,6 +1114,95 @@ public final class TypeSpecTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void annotationToString() throws Exception {\n+    AnnotationSpec annotation = AnnotationSpec.builder(SuppressWarnings.class)\n+        .addMember(\"value\", \"$S\", \"unused\")\n+        .build();\n+    assertThat(annotation.toString()).isEqualTo(\"@java.lang.SuppressWarnings(\\\"unused\\\")\");\n+  }\n+\n+  @Test public void codeBlockToString() throws Exception {\n+    CodeBlock codeBlock = CodeBlock.builder()\n+        .addStatement(\"$T $N = $S.substring(0, 3)\", String.class, \"s\", \"taco\")\n+        .build();\n+    assertThat(codeBlock.toString()).isEqualTo(\"java.lang.String s = \\\"taco\\\".substring(0, 3);\\n\");\n+  }\n+\n+  @Test public void fieldToString() throws Exception {\n+    FieldSpec field = FieldSpec.builder(String.class, \"s\", Modifier.FINAL)\n+        .initializer(\"$S.substring(0, 3)\", \"taco\")\n+        .build();\n+    assertThat(field.toString())\n+        .isEqualTo(\"final java.lang.String s = \\\"taco\\\".substring(0, 3);\\n\");\n+  }\n+\n+  @Test public void methodToString() throws Exception {\n+    MethodSpec method = MethodSpec.methodBuilder(\"toString\")\n+        .addAnnotation(Override.class)\n+        .addModifiers(Modifier.PUBLIC)\n+        .returns(String.class)\n+        .addStatement(\"return $S\", \"taco\")\n+        .build();\n+    assertThat(method.toString()).isEqualTo(\"\"\n+        + \"@java.lang.Override\\n\"\n+        + \"public java.lang.String toString() {\\n\"\n+        + \"  return \\\"taco\\\";\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void constructorToString() throws Exception {\n+    MethodSpec constructor = MethodSpec.constructorBuilder()\n+        .addModifiers(Modifier.PUBLIC)\n+        .addParameter(ClassName.get(tacosPackage, \"Taco\"), \"taco\")\n+        .addStatement(\"this.$N = $N\", \"taco\", \"taco\")\n+        .build();\n+    assertThat(constructor.toString()).isEqualTo(\"\"\n+        + \"public Constructor(com.squareup.tacos.Taco taco) {\\n\"\n+        + \"  this.taco = taco;\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void parameterToString() throws Exception {\n+    ParameterSpec parameter = ParameterSpec.builder(ClassName.get(tacosPackage, \"Taco\"), \"taco\")\n+        .addModifiers(Modifier.FINAL)\n+        .addAnnotation(ClassName.get(\"javax.annotation\", \"Nullable\"))\n+        .build();\n+    assertThat(parameter.toString())\n+        .isEqualTo(\"@javax.annotation.Nullable final com.squareup.tacos.Taco taco\");\n+  }\n+\n+  @Test public void classToString() throws Exception {\n+    TypeSpec type = TypeSpec.classBuilder(\"Taco\")\n+        .build();\n+    assertThat(type.toString()).isEqualTo(\"\"\n+        + \"class Taco {\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void anonymousClassToString() throws Exception {\n+    TypeSpec type = TypeSpec.anonymousClassBuilder(\"\")\n+        .addSuperinterface(Runnable.class)\n+        .addMethod(MethodSpec.methodBuilder(\"run\")\n+            .addAnnotation(Override.class)\n+            .addModifiers(Modifier.PUBLIC)\n+            .build())\n+        .build();\n+    assertThat(type.toString()).isEqualTo(\"\"\n+        + \"new java.lang.Runnable() {\\n\"\n+        + \"  @java.lang.Override\\n\"\n+        + \"  public void run() {\\n\"\n+        + \"  }\\n\"\n+        + \"}\");\n+  }\n+\n+  @Test public void interfaceClassToString() throws Exception {\n+    TypeSpec type = TypeSpec.interfaceBuilder(\"Taco\")\n+        .build();\n+    assertThat(type.toString()).isEqualTo(\"\"\n+        + \"interface Taco {\\n\"\n+        + \"}\\n\");\n+  }\n+\n   private String toString(TypeSpec typeSpec) {\n     return JavaFile.builder(tacosPackage, typeSpec).build().toString();\n   }\n"
    },
    {
        "commit_hash": "18c8153065689e86ca22dcd7cfc98ac22f5df9c9",
        "previous_commit_hash": "75725cd819943bb1cb6e1e62dc78542fd560cd24",
        "diff_stats": {
            "additions": 5,
            "deletions": 4
        },
        "diff_content": "@@ -49,7 +49,7 @@ import static com.google.common.base.Preconditions.checkState;\n  * honors imports, indentation, and deferred variable names.\n  */\n final class CodeWriter {\n-  private final String indent = \"  \";\n+  private final String indent;\n   private final Appendable out;\n   private int indentLevel;\n \n@@ -68,12 +68,13 @@ final class CodeWriter {\n    */\n   int statementLine = -1;\n \n-  public CodeWriter(Appendable out) {\n-    this(out, ImmutableMap.<ClassName, String>of());\n+  public CodeWriter(Appendable out, String indent) {\n+    this(out, indent, ImmutableMap.<ClassName, String>of());\n   }\n \n-  public CodeWriter(Appendable out, ImmutableMap<ClassName, String> importedTypes) {\n+  public CodeWriter(Appendable out, String indent, ImmutableMap<ClassName, String> importedTypes) {\n     this.out = checkNotNull(out);\n+    this.indent = checkNotNull(indent);\n     this.importedTypes = checkNotNull(importedTypes);\n   }\n \n"
    },
    {
        "commit_hash": "18c8153065689e86ca22dcd7cfc98ac22f5df9c9",
        "previous_commit_hash": "75725cd819943bb1cb6e1e62dc78542fd560cd24",
        "diff_stats": {
            "additions": 4,
            "deletions": 4
        },
        "diff_content": "@@ -46,14 +46,14 @@ public final class JavaFile {\n     this.typeSpec = builder.typeSpec;\n   }\n \n-  public void emit(Appendable out) throws IOException {\n+  public void emit(Appendable out, String indent) throws IOException {\n     // First pass: emit the entire class, just to collect the types we'll need to import.\n-    CodeWriter importsCollector = new CodeWriter(NULL_APPENDABLE);\n+    CodeWriter importsCollector = new CodeWriter(NULL_APPENDABLE, indent);\n     emit(importsCollector);\n     ImmutableMap<ClassName, String> suggestedImports = importsCollector.suggestedImports();\n \n     // Second pass: write the code, taking advantage of the imports.\n-    CodeWriter codeWriter = new CodeWriter(out, suggestedImports);\n+    CodeWriter codeWriter = new CodeWriter(out, indent, suggestedImports);\n     emit(codeWriter);\n   }\n \n@@ -84,7 +84,7 @@ public final class JavaFile {\n   public String toString() {\n     try {\n       StringBuilder result = new StringBuilder();\n-      emit(result);\n+      emit(result, \"  \");\n       return result.toString();\n     } catch (IOException e) {\n       throw new AssertionError();\n"
    },
    {
        "commit_hash": "18c8153065689e86ca22dcd7cfc98ac22f5df9c9",
        "previous_commit_hash": "75725cd819943bb1cb6e1e62dc78542fd560cd24",
        "diff_stats": {
            "additions": 8,
            "deletions": 2
        },
        "diff_content": "@@ -33,6 +33,12 @@ import static com.google.common.base.Preconditions.checkArgument;\n /** Writes generated types to a filesystem using the standard directory structure. */\n public final class JavaPoet {\n   private final List<JavaFile> javaFiles = new ArrayList<>();\n+  private String indent = \"  \";\n+\n+  public JavaPoet setIndent(String indent) {\n+    this.indent = indent;\n+    return this;\n+  }\n \n   public JavaPoet add(JavaFile javaFile) {\n     javaFiles.add(javaFile);\n@@ -59,7 +65,7 @@ public final class JavaPoet {\n \n       Path outputPath = outputDirectory.resolve(javaFile.typeSpec.name + \".java\");\n       try (Writer writer = new OutputStreamWriter(Files.newOutputStream(outputPath))) {\n-        javaFile.emit(writer);\n+        javaFile.emit(writer, indent);\n       }\n     }\n   }\n@@ -76,7 +82,7 @@ public final class JavaPoet {\n       JavaFileObject filerSourceFile = filer.createSourceFile(fileName,\n           Iterables.toArray(javaFile.typeSpec.originatingElements, Element.class));\n       try (Writer writer = filerSourceFile.openWriter()) {\n-        javaFile.emit(writer);\n+        javaFile.emit(writer, indent);\n       } catch (Exception e) {\n         try {\n           filerSourceFile.delete();\n"
    },
    {
        "commit_hash": "18c8153065689e86ca22dcd7cfc98ac22f5df9c9",
        "previous_commit_hash": "75725cd819943bb1cb6e1e62dc78542fd560cd24",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -347,7 +347,7 @@ public final class Types {\n   private static String typeToString(Type type) {\n     try {\n       StringBuilder result = new StringBuilder();\n-      new CodeWriter(result).emit(\"$T\", type);\n+      new CodeWriter(result, \"  \").emit(\"$T\", type);\n       return result.toString();\n     } catch (IOException e) {\n       throw new AssertionError();\n"
    },
    {
        "commit_hash": "18c8153065689e86ca22dcd7cfc98ac22f5df9c9",
        "previous_commit_hash": "75725cd819943bb1cb6e1e62dc78542fd560cd24",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -96,11 +96,11 @@ public final class JavaFileTest {\n   @Test public void topOfFileComment() throws Exception {\n     String source = JavaFile.builder(\"com.squareup.tacos\",\n         TypeSpec.classBuilder(\"Taco\").build())\n-        .addFileComment(\"Generated $L by JavaWriter. DO NOT EDIT!\", \"2015-01-13\")\n+        .addFileComment(\"Generated $L by JavaPoet. DO NOT EDIT!\", \"2015-01-13\")\n         .build()\n         .toString();\n     assertThat(source).isEqualTo(\"\"\n-        + \"// Generated 2015-01-13 by JavaWriter. DO NOT EDIT!\\n\"\n+        + \"// Generated 2015-01-13 by JavaPoet. DO NOT EDIT!\\n\"\n         + \"package com.squareup.tacos;\\n\"\n         + \"\\n\"\n         + \"class Taco {\\n\"\n"
    },
    {
        "commit_hash": "18c8153065689e86ca22dcd7cfc98ac22f5df9c9",
        "previous_commit_hash": "75725cd819943bb1cb6e1e62dc78542fd560cd24",
        "diff_stats": {
            "additions": 33,
            "deletions": 0
        },
        "diff_content": "@@ -22,7 +22,9 @@ import java.io.IOException;\n import java.nio.file.FileSystem;\n import java.nio.file.Files;\n import java.nio.file.Path;\n+import java.util.Date;\n import javax.lang.model.element.Element;\n+import javax.lang.model.element.Modifier;\n import org.junit.Rule;\n import org.junit.Test;\n import org.junit.rules.TemporaryFolder;\n@@ -193,4 +195,35 @@ public final class JavaPoetTest {\n     Path testPath2 = fsRoot.resolve(fs.getPath(\"example\", \"Test2.java\"));\n     assertThat(filer.getOriginatingElements(testPath2)).containsExactly(element2_1, element2_2);\n   }\n+\n+  @Test public void filerClassesWithTabIndent() throws IOException {\n+    TypeSpec test = TypeSpec.classBuilder(\"Test\")\n+        .addField(Date.class, \"madeFreshDate\")\n+        .addMethod(MethodSpec.methodBuilder(\"main\")\n+            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n+            .addParameter(String[].class, \"args\")\n+            .addCode(\"$T.out.println($S);\\n\", System.class, \"Hello World!\")\n+            .build())\n+        .build();\n+    javaPoet.add(\"foo\", test).setIndent(\"\\t\").writeTo(filer);\n+\n+    Path fooPath = fsRoot.resolve(fs.getPath(\"foo\", \"Test.java\"));\n+    assertThat(Files.exists(fooPath)).isTrue();\n+    String source = new String(Files.readAllBytes(fooPath));\n+\n+    assertThat(source).isEqualTo(\"\"\n+        + \"package foo;\\n\"\n+        + \"\\n\"\n+        + \"import java.lang.String;\\n\"\n+        + \"import java.lang.System;\\n\"\n+        + \"import java.util.Date;\\n\"\n+        + \"\\n\"\n+        + \"class Test {\\n\"\n+        + \"\\tDate madeFreshDate;\\n\"\n+        + \"\\n\"\n+        + \"\\tpublic static void main(String[] args) {\\n\"\n+        + \"\\t\\tSystem.out.println(\\\"Hello World!\\\");\\n\"\n+        + \"\\t}\\n\"\n+        + \"}\\n\");\n+  }\n }\n"
    },
    {
        "commit_hash": "1d7e42edac026a1c770ad60bbbd9933d8ef434e9",
        "previous_commit_hash": "0272b4b419122e9410e19fb4de754ca2d8759b3f",
        "diff_stats": {
            "additions": 113,
            "deletions": 0
        },
        "diff_content": "@@ -621,6 +621,119 @@ constructor. In the above code we're passing the empty string for no arguments:\n syntax with commas to separate arguments.\n \n \n+### Annotations\n+\n+Simple annotations are easy:\n+\n+```java\n+MethodSpec toString = MethodSpec.methodBuilder(\"toString\")\n+    .addAnnotation(Override.class)\n+    .returns(String.class)\n+    .addModifiers(Modifier.PUBLIC)\n+    .addStatement(\"return $S\", \"Hoverboard\")\n+    .build();\n+```\n+\n+Which generates this method with an `@Override` annotation:\n+\n+```java\n+  @Override\n+  public String toString() {\n+    return \"Hoverboard\";\n+  }\n+```\n+\n+Use `AnnotationSpec.builder()` to set properties on annotations:\n+\n+```java\n+MethodSpec logRecord = MethodSpec.methodBuilder(\"recordEvent\")\n+    .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)\n+    .addAnnotation(AnnotationSpec.builder(Headers.class)\n+        .addMember(\"accept\", \"$S\", \"application/json; charset=utf-8\")\n+        .addMember(\"userAgent\", \"$S\", \"Square Cash\")\n+        .build())\n+    .addParameter(LogRecord.class, \"logRecord\")\n+    .returns(LogReceipt.class)\n+    .build();\n+```\n+\n+Which generates this annotation with `accept` and `userAgent` properties:\n+\n+```java\n+@Headers(\n+    accept = \"application/json; charset=utf-8\",\n+    userAgent = \"Square Cash\"\n+)\n+LogReceipt recordEvent(LogRecord logRecord);\n+```\n+\n+When you get fancy, annotation values can be annotations themselves. Use `$L` for embedded\n+annotations:\n+\n+```java\n+MethodSpec logRecord = MethodSpec.methodBuilder(\"recordEvent\")\n+    .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)\n+    .addAnnotation(AnnotationSpec.builder(HeaderList.class)\n+        .addMember(\"value\", \"$L\", AnnotationSpec.builder(Header.class)\n+            .addMember(\"name\", \"$S\", \"Accept\")\n+            .addMember(\"value\", \"$S\", \"application/json; charset=utf-8\")\n+            .build())\n+        .addMember(\"value\", \"$L\", AnnotationSpec.builder(Header.class)\n+            .addMember(\"name\", \"$S\", \"User-Agent\")\n+            .addMember(\"value\", \"$S\", \"Square Cash\")\n+            .build())\n+        .build())\n+    .addParameter(LogRecord.class, \"logRecord\")\n+    .returns(LogReceipt.class)\n+    .build();\n+```\n+\n+Which generates this:\n+\n+```java\n+@HeaderList({\n+    @Header(name = \"Accept\", value = \"application/json; charset=utf-8\"),\n+    @Header(name = \"User-Agent\", value = \"Square Cash\")\n+})\n+LogReceipt recordEvent(LogRecord logRecord);\n+```\n+\n+Note that you can call `addMember()` multiple times with the same property name to populate a list\n+of values for that property.\n+\n+### Javadoc\n+\n+Fields, methods and types can be documented with Javadoc:\n+\n+```java\n+MethodSpec dismiss = MethodSpec.methodBuilder(\"dismiss\")\n+    .addJavadoc(\"Hides {@code message} from the caller's history. Other\\n\"\n+        + \"participants in the conversation will continue to see the\\n\"\n+        + \"message in their own history unless they also delete it.\\n\")\n+    .addJavadoc(\"\\n\")\n+    .addJavadoc(\"<p>Use {@link #delete($T)} to delete the entire\\n\"\n+        + \"conversation for all participants.\\n\", Conversation.class)\n+    .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)\n+    .addParameter(Message.class, \"message\")\n+    .build();\n+```\n+\n+Which generates this:\n+\n+```java\n+  /**\n+   * Hides {@code message} from the caller's history. Other\n+   * participants in the conversation will continue to see the\n+   * message in their own history unless they also delete it.\n+   *\n+   * <p>Use {@link #delete(Conversation)} to delete the entire\n+   * conversation for all participants.\n+   */\n+  void dismiss(Message message);\n+```\n+\n+Use `$T` when referencing types in Javadoc to get automatic imports.\n+\n Download\n --------\n \n"
    },
    {
        "commit_hash": "ad6d011c3bc0d838143717733f1c9658ab9b55e7",
        "previous_commit_hash": "75725cd819943bb1cb6e1e62dc78542fd560cd24",
        "diff_stats": {
            "additions": 2,
            "deletions": 5
        },
        "diff_content": "@@ -1,14 +1,11 @@\n language: java\n \n jdk:\n+  - oraclejdk7\n   - oraclejdk8\n \n-script:\n-  - mvn test -B\n-  - jdk_switcher use openjdk7 && mvn surefire:test -B\n-\n after_success:\n-  - jdk_switcher use oraclejdk8 && .buildscript/deploy_snapshot.sh\n+  - .buildscript/deploy_snapshot.sh\n \n env:\n   global:\n"
    },
    {
        "commit_hash": "ad6d011c3bc0d838143717733f1c9658ab9b55e7",
        "previous_commit_hash": "75725cd819943bb1cb6e1e62dc78542fd560cd24",
        "diff_stats": {
            "additions": 0,
            "deletions": 8
        },
        "diff_content": "@@ -314,14 +314,6 @@ final class CodeWriter {\n     } else if (type instanceof GenericArrayType) {\n       return emit(\"$T[]\", ((GenericArrayType) type).getGenericComponentType());\n \n-    } else if (type instanceof IntersectionType) {\n-      boolean firstBound = true;\n-      for (Type bound : ((IntersectionType) type).getBounds()) {\n-        if (!firstBound) emit(\" & \");\n-        emit(\"$T\", bound);\n-        firstBound = false;\n-      }\n-      return this;\n     }\n \n     throw new UnsupportedOperationException(\"unexpected type: \" + arg);\n"
    },
    {
        "commit_hash": "ad6d011c3bc0d838143717733f1c9658ab9b55e7",
        "previous_commit_hash": "75725cd819943bb1cb6e1e62dc78542fd560cd24",
        "diff_stats": {
            "additions": 0,
            "deletions": 22
        },
        "diff_content": "@@ -1,22 +0,0 @@\n-/*\n- * Copyright (C) 2014 Google, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.squareup.javapoet;\n-\n-import java.lang.reflect.Type;\n-\n-interface IntersectionType extends Type {\n-  Type[] getBounds();\n-}\n"
    },
    {
        "commit_hash": "ad6d011c3bc0d838143717733f1c9658ab9b55e7",
        "previous_commit_hash": "75725cd819943bb1cb6e1e62dc78542fd560cd24",
        "diff_stats": {
            "additions": 115,
            "deletions": 144
        },
        "diff_content": "@@ -16,21 +16,23 @@\n package com.squareup.javapoet;\n \n import com.google.common.base.Function;\n-import com.google.common.base.Objects;\n-import com.google.common.base.Predicates;\n import com.google.common.collect.FluentIterable;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Iterables;\n import java.io.IOException;\n-import java.lang.annotation.Annotation;\n-import java.lang.reflect.AnnotatedType;\n import java.lang.reflect.GenericArrayType;\n-import java.lang.reflect.GenericDeclaration;\n+import java.lang.reflect.InvocationHandler;\n+import java.lang.reflect.Method;\n import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Proxy;\n import java.lang.reflect.Type;\n import java.lang.reflect.TypeVariable;\n import java.lang.reflect.WildcardType;\n+import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n import javax.lang.model.element.NestingKind;\n import javax.lang.model.element.TypeElement;\n import javax.lang.model.type.ArrayType;\n@@ -70,36 +72,17 @@ public final class Types {\n    * Returns a new parameterized type, applying {@code typeArguments} to {@code rawType} and\n    * with no enclosing owner type.\n    */\n-  public static ParameterizedType parameterizedType(\n-      final Type rawType, final Type... typeArguments) {\n+  public static ParameterizedType parameterizedType(Type rawType, Type... typeArguments) {\n     checkNotPrimitive(rawType);\n     for (Type typeArgument : typeArguments) {\n       checkNotPrimitive(typeArgument);\n     }\n-\n-    return new ParameterizedType() {\n-      @Override public Type[] getActualTypeArguments() {\n-        return typeArguments.clone();\n-      }\n-      @Override public Type getRawType() {\n-        return rawType;\n-      }\n-      @Override public Type getOwnerType() {\n-        return null;\n-      }\n-      @Override public boolean equals(Object other) {\n-        return other instanceof ParameterizedType\n-            && ((ParameterizedType) other).getOwnerType() == null\n-            && rawType.equals(((ParameterizedType) other).getRawType())\n-            && Arrays.equals(typeArguments, ((ParameterizedType) other).getActualTypeArguments());\n-      }\n-      @Override public int hashCode() {\n-        return Arrays.hashCode(typeArguments) ^ rawType.hashCode();\n-      }\n-      @Override public String toString() {\n-        return typeToString(this);\n-      }\n-    };\n+    Map<String, Object> accessors = new LinkedHashMap<>();\n+    accessors.put(\"getActualTypeArguments\", typeArguments.clone());\n+    accessors.put(\"getRawType\", rawType);\n+    accessors.put(\"getOwnerType\", null);\n+    int hashCode = Arrays.hashCode(typeArguments) ^ rawType.hashCode();\n+    return newType(ParameterizedType.class, accessors, hashCode);\n   }\n \n   /**\n@@ -111,24 +94,13 @@ public final class Types {\n   }\n \n   /** Returns an array type whose elements are all instances of {@code componentType}. */\n-  public static GenericArrayType arrayOf(final Type componentType) {\n+  public static GenericArrayType arrayOf(Type componentType) {\n     checkNotNull(componentType, \"componentType == null\");\n \n-    return new GenericArrayType() {\n-      @Override public Type getGenericComponentType() {\n-        return componentType;\n-      }\n-      @Override public boolean equals(Object o) {\n-        return o instanceof GenericArrayType\n-            && Objects.equal(componentType, ((GenericArrayType) o).getGenericComponentType());\n-      }\n-      @Override public int hashCode() {\n-        return componentType.hashCode();\n-      }\n-      @Override public String toString() {\n-        return typeToString(this);\n-      }\n-    };\n+    Map<String, Object> accessors = new LinkedHashMap<>();\n+    accessors.put(\"getGenericComponentType\", componentType);\n+    int hashCode = componentType.hashCode();\n+    return newType(GenericArrayType.class, accessors, hashCode);\n   }\n \n   /**\n@@ -151,69 +123,25 @@ public final class Types {\n     return wildcardType(new Type[] {Object.class}, new Type[] {bound});\n   }\n \n-  private static WildcardType wildcardType(final Type[] upperBounds, final Type[] lowerBounds) {\n-    return new WildcardType() {\n-      @Override public Type[] getUpperBounds() {\n-        return upperBounds.clone();\n-      }\n-      @Override public Type[] getLowerBounds() {\n-        return lowerBounds.clone();\n-      }\n-      @Override public boolean equals(Object o) {\n-        return o instanceof WildcardType\n-            && Arrays.equals(upperBounds, ((WildcardType) o).getUpperBounds())\n-            && Arrays.equals(lowerBounds, ((WildcardType) o).getLowerBounds());\n-      }\n-      @Override public int hashCode() {\n-        return Arrays.hashCode(lowerBounds) ^ Arrays.hashCode(upperBounds);\n-      }\n-      @Override public String toString() {\n-        return typeToString(this);\n-      }\n-    };\n+  private static WildcardType wildcardType(Type[] upperBounds, Type[] lowerBounds) {\n+    Map<String, Object> accessors = new LinkedHashMap<>();\n+    accessors.put(\"getUpperBounds\", upperBounds.clone());\n+    accessors.put(\"getLowerBounds\", lowerBounds.clone());\n+    int hashCode = Arrays.hashCode(lowerBounds) ^ Arrays.hashCode(upperBounds);\n+    return newType(WildcardType.class, accessors, hashCode);\n   }\n \n-  public static TypeVariable<?> typeVariable(final String name, final Type... bounds) {\n+  public static TypeVariable<?> typeVariable(String name, Type... bounds) {\n     checkNotNull(name);\n     for (Type bound : bounds) {\n       checkNotPrimitive(bound);\n     }\n \n-    return new TypeVariable<GenericDeclaration>() {\n-      @Override public Type[] getBounds() {\n-        return bounds.clone();\n-      }\n-      @Override public String getName() {\n-        return name;\n-      }\n-      @Override public GenericDeclaration getGenericDeclaration() {\n-        throw new UnsupportedOperationException();\n-      }\n-      @Override public boolean equals(Object o) {\n-        return o instanceof TypeVariable\n-            && name.equals(((TypeVariable<?>) o).getName());\n-      }\n-      @Override public int hashCode() {\n-        return name.hashCode();\n-      }\n-      @Override public String toString() {\n-        return typeToString(this);\n-      }\n-\n-      // Java 8 requires these methods. We have them to compile, but we don't exercise them.\n-      @Override public AnnotatedType[] getAnnotatedBounds() {\n-        throw new UnsupportedOperationException();\n-      }\n-      @Override public <T extends Annotation> T getAnnotation(Class<T> aClass) {\n-        throw new UnsupportedOperationException();\n-      }\n-      @Override public Annotation[] getAnnotations() {\n-        throw new UnsupportedOperationException();\n-      }\n-      @Override public Annotation[] getDeclaredAnnotations() {\n-        throw new UnsupportedOperationException();\n-      }\n-    };\n+    Map<String, Object> accessors = new LinkedHashMap<>();\n+    accessors.put(\"getBounds\", bounds.clone());\n+    accessors.put(\"getName\", name);\n+    int hashCode = name.hashCode();\n+    return newType(TypeVariable.class, accessors, hashCode);\n   }\n \n   public static Type get(TypeMirror mirror) {\n@@ -238,10 +166,6 @@ public final class Types {\n         return get(t);\n       }\n \n-      @Override public Type visitIntersection(javax.lang.model.type.IntersectionType t, Void p) {\n-        return get(t);\n-      }\n-\n       @Override public Type visitWildcard(javax.lang.model.type.WildcardType t, Void p) {\n         return get(t);\n       }\n@@ -266,25 +190,50 @@ public final class Types {\n \n   private static TypeVariable<?> get(javax.lang.model.type.TypeVariable mirror) {\n     String name = mirror.asElement().getSimpleName().toString();\n+    List<? extends TypeMirror> boundsMirrors = typeVariableBounds(mirror);\n+\n+    List<Type> boundsTypes = new ArrayList<>();\n+    for (TypeMirror typeMirror : boundsMirrors) {\n+      Type bound = get(typeMirror);\n+      if (bound.equals(ClassName.OBJECT)) continue; // Omit java.lang.Object bounds.\n+      boundsTypes.add(bound);\n+    }\n+\n+    return typeVariable(name, boundsTypes.toArray(new Type[boundsTypes.size()]));\n+  }\n \n-    TypeMirror upperBound = mirror.getUpperBound();\n-    FluentIterable<TypeMirror> bounds = FluentIterable.from(ImmutableList.of(upperBound));\n-    // Try to detect intersection types for Java 7 (Java 8+ has a new TypeKind for that)\n-    // Unfortunately, we can't put this logic into Types.get() as this heuristic only really works\n-    // in the context of a TypeVariable's upper bound.\n+  /**\n+   * Returns a list of type mirrors representing the unpacked bounds of {@code typeVariable}. This\n+   * is made gnarly by the need to unpack Java 8's new IntersectionType with reflection. We don't\n+   * have that type in Java 7, and {@link TypeVariable}'s array of bounds is sufficient anyway.\n+   */\n+  @SuppressWarnings(\"unchecked\") // Gross things in support of multiple Java 7 and Java 8.\n+  private static List<? extends TypeMirror> typeVariableBounds(\n+      javax.lang.model.type.TypeVariable typeVariable) {\n+    TypeMirror upperBound = typeVariable.getUpperBound();\n+\n+    // On Java 8, unwrap an intersection type into its component bounds.\n+    if (\"INTERSECTION\".equals(upperBound.getKind().name())) {\n+      try {\n+        Method method = upperBound.getClass().getMethod(\"getBounds\");\n+        return (List<? extends TypeMirror>) method.invoke(upperBound);\n+      } catch (Exception e) {\n+        throw new RuntimeException(e);\n+      }\n+    }\n+\n+    // On Java 7, intersection types exist but without explicit API. Use a (clumsy) heuristic.\n     if (upperBound.getKind() == TypeKind.DECLARED) {\n-      TypeElement bound = (TypeElement) ((DeclaredType) upperBound).asElement();\n-      if (bound.getNestingKind() == NestingKind.ANONYMOUS) {\n-        // This is (likely) an intersection type.\n-        bounds = FluentIterable\n-            .from(ImmutableList.of(bound.getSuperclass()))\n-            .append(bound.getInterfaces());\n+      TypeElement upperBoundElement = (TypeElement) ((DeclaredType) upperBound).asElement();\n+      if (upperBoundElement.getNestingKind() == NestingKind.ANONYMOUS) {\n+        return ImmutableList.<TypeMirror>builder()\n+            .add(upperBoundElement.getSuperclass())\n+            .addAll(upperBoundElement.getInterfaces())\n+            .build();\n       }\n     }\n-    Type[] types = bounds.transform(FOR_TYPE_MIRROR)\n-        .filter(Predicates.not(Predicates.<Type>equalTo(ClassName.OBJECT)))\n-        .toArray(Type.class);\n-    return typeVariable(name, types);\n+\n+    return ImmutableList.of(upperBound);\n   }\n \n   private static Type get(javax.lang.model.type.WildcardType mirror) {\n@@ -316,28 +265,6 @@ public final class Types {\n     }\n   }\n \n-  private static Type get(javax.lang.model.type.IntersectionType mirror) {\n-    final Type[] bounds = FluentIterable.from(mirror.getBounds())\n-        .transform(FOR_TYPE_MIRROR)\n-        .filter(Predicates.not(Predicates.<Type>equalTo(ClassName.OBJECT)))\n-        .toArray(Type.class);\n-    return new IntersectionType() {\n-      @Override public Type[] getBounds() {\n-        return bounds;\n-      }\n-      @Override public int hashCode() {\n-        return Arrays.hashCode(bounds);\n-      }\n-      @Override public boolean equals(Object o) {\n-        return o instanceof IntersectionType\n-            && Arrays.equals(bounds, ((IntersectionType) o).getBounds());\n-      }\n-      @Override public String toString() {\n-        return typeToString(this);\n-      }\n-    };\n-  }\n-\n   private static void checkNotPrimitive(Type type) {\n     checkNotNull(type, \"type cannot be primitive.\");\n     checkArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive(),\n@@ -364,4 +291,48 @@ public final class Types {\n       return null;\n     }\n   }\n+\n+  /**\n+   * Implement reflective types using a dynamic proxy so we can compile on both Java 7 and Java 8,\n+   * even though {@link TypeVariable} gained new methods in Java 8 that won't compile on Java 7.\n+   */\n+  @SuppressWarnings(\"unchecked\")\n+  private static <T extends Type> T newType(\n+      final Class<T> type, final Map<String, Object> accessors, final int hashCode) {\n+    ClassLoader classLoader = Types.class.getClassLoader();\n+    Class[] classes = {type};\n+    return (T) Proxy.newProxyInstance(classLoader, classes, new InvocationHandler() {\n+      @Override public Object invoke(Object o, Method method, Object[] objects) throws Throwable {\n+        switch (method.getName()) {\n+          case \"equals\":\n+            Object other = objects[0];\n+            if (!type.isInstance(other)) return false;\n+            for (Map.Entry<String, Object> entry : accessors.entrySet()) {\n+              Object otherProperty = other.getClass().getMethod(entry.getKey()).invoke(other);\n+              if (!equal(otherProperty, entry.getValue())) return false;\n+            }\n+            return true;\n+\n+          case \"hashCode\":\n+            return hashCode;\n+\n+          case \"toString\":\n+            return typeToString((Type) o);\n+\n+          default:\n+            Object result = accessors.get(method.getName());\n+            if (result == null && !accessors.containsKey(method.getName())) {\n+              throw new UnsupportedOperationException(method.getName());\n+            }\n+            return result instanceof Object[] ? ((Object[]) result).clone() : result;\n+        }\n+      }\n+\n+      boolean equal(Object a, Object b) {\n+        if (a == null) return b == null;\n+        if (a instanceof Object[]) return Arrays.equals((Object[]) a, (Object[]) b);\n+        return a.equals(b);\n+      }\n+    });\n+  }\n }\n"
    },
    {
        "commit_hash": "ad6d011c3bc0d838143717733f1c9658ab9b55e7",
        "previous_commit_hash": "75725cd819943bb1cb6e1e62dc78542fd560cd24",
        "diff_stats": {
            "additions": 11,
            "deletions": 26
        },
        "diff_content": "@@ -19,7 +19,6 @@ import com.google.testing.compile.CompilationRule;\n import java.io.Serializable;\n import java.lang.reflect.GenericArrayType;\n import java.lang.reflect.ParameterizedType;\n-import java.lang.reflect.Type;\n import java.lang.reflect.TypeVariable;\n import java.lang.reflect.WildcardType;\n import java.nio.charset.Charset;\n@@ -75,39 +74,25 @@ public final class TypesTest {\n     List<? extends TypeParameterElement> typeVariables =\n         getElement(Parameterized.class).getTypeParameters();\n \n+    // Members of converted types use ClassName and not Class<?>.\n+    ClassName number = ClassName.get(Number.class);\n+    ClassName runnable = ClassName.get(Runnable.class);\n+    ClassName serializable = ClassName.get(Serializable.class);\n+\n     assertThat(Types.get(typeVariables.get(0).asType()))\n         .isEqualTo(Types.typeVariable(\"Simple\"));\n     assertThat(Types.get(typeVariables.get(1).asType()))\n-        .isEqualTo(Types.typeVariable(\"ExtendsClass\", Number.class));\n+        .isEqualTo(Types.typeVariable(\"ExtendsClass\", number));\n     assertThat(Types.get(typeVariables.get(2).asType()))\n-        .isEqualTo(Types.typeVariable(\"ExtendsInterface\", Runnable.class));\n+        .isEqualTo(Types.typeVariable(\"ExtendsInterface\", runnable));\n     assertThat(Types.get(typeVariables.get(3).asType()))\n         .isEqualTo(Types.typeVariable(\"ExtendsTypeVariable\", Types.typeVariable(\"Simple\")));\n     assertThat(Types.get(typeVariables.get(4).asType()))\n-        .isEqualTo(Types.typeVariable(\"Intersection\", Number.class, Runnable.class));\n+        .isEqualTo(Types.typeVariable(\"Intersection\", number, runnable));\n     assertThat(Types.get(typeVariables.get(5).asType()))\n-        .isEqualTo(Types.typeVariable(\"IntersectionOfInterfaces\",\n-            Runnable.class, Serializable.class));\n-  }\n-\n-  @Test public void typeVariableBounds() {\n-    List<? extends TypeParameterElement> typeVariables =\n-        getElement(Parameterized.class).getTypeParameters();\n-    TypeVariable typeVariable = (TypeVariable) Types.get(typeVariables.get(4).asType());\n-    Type[] bounds = typeVariable.getBounds();\n-\n-    if (bounds.length == 1) {\n-      // Java 8.\n-      IntersectionType intersectionType = (IntersectionType) bounds[0];\n-      assertThat(intersectionType.getBounds()).asList()\n-          .containsExactly(ClassName.get(Number.class), ClassName.get(Runnable.class));\n-      assertThat(intersectionType.toString())\n-          .isEqualTo(\"java.lang.Number & java.lang.Runnable\");\n-    } else {\n-      // Java \u2264 7.\n-      assertThat(bounds).asList()\n-          .containsExactly(ClassName.get(Number.class), ClassName.get(Runnable.class));\n-    }\n+        .isEqualTo(Types.typeVariable(\"IntersectionOfInterfaces\", runnable, serializable));\n+    assertThat(((TypeVariable) Types.get(typeVariables.get(4).asType())).getBounds()).asList()\n+        .containsExactly(number, runnable);\n   }\n \n   @Test public void getPrimitiveTypeMirror() {\n"
    },
    {
        "commit_hash": "6db81d3fdd3b29df5464741a6e7dcadc9a0f9c06",
        "previous_commit_hash": "f3859b036805759fc1979f5513b53fe6d0af79b3",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -207,7 +207,7 @@ public final class Types {\n    * is made gnarly by the need to unpack Java 8's new IntersectionType with reflection. We don't\n    * have that type in Java 7, and {@link TypeVariable}'s array of bounds is sufficient anyway.\n    */\n-  @SuppressWarnings(\"unchecked\") // Gross things in support of multiple Java 7 and Java 8.\n+  @SuppressWarnings(\"unchecked\") // Gross things in support of Java 7 and Java 8.\n   private static List<? extends TypeMirror> typeVariableBounds(\n       javax.lang.model.type.TypeVariable typeVariable) {\n     TypeMirror upperBound = typeVariable.getUpperBound();\n"
    },
    {
        "commit_hash": "d63c516b088348211a0ea54e55f095e97fe6abc8",
        "previous_commit_hash": "6db81d3fdd3b29df5464741a6e7dcadc9a0f9c06",
        "diff_stats": {
            "additions": 4,
            "deletions": 0
        },
        "diff_content": "@@ -68,6 +68,10 @@ final class CodeWriter {\n    */\n   int statementLine = -1;\n \n+  CodeWriter(Appendable out) {\n+    this(out, \"  \");\n+  }\n+\n   public CodeWriter(Appendable out, String indent) {\n     this(out, indent, ImmutableMap.<ClassName, String>of());\n   }\n"
    },
    {
        "commit_hash": "d63c516b088348211a0ea54e55f095e97fe6abc8",
        "previous_commit_hash": "6db81d3fdd3b29df5464741a6e7dcadc9a0f9c06",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -274,7 +274,7 @@ public final class Types {\n   private static String typeToString(Type type) {\n     try {\n       StringBuilder result = new StringBuilder();\n-      new CodeWriter(result, \"  \").emit(\"$T\", type);\n+      new CodeWriter(result).emit(\"$T\", type);\n       return result.toString();\n     } catch (IOException e) {\n       throw new AssertionError();\n"
    },
    {
        "commit_hash": "46f64399f2bf43c8db91cab67c18546e611c58ca",
        "previous_commit_hash": "74907054c085e3b33cbec4a064afcc3814ae0dd0",
        "diff_stats": {
            "additions": 7,
            "deletions": 7
        },
        "diff_content": "@@ -77,9 +77,9 @@ final class CodeWriter {\n   }\n \n   public CodeWriter(Appendable out, String indent, ImmutableMap<ClassName, String> importedTypes) {\n-    this.out = checkNotNull(out);\n-    this.indent = checkNotNull(indent);\n-    this.importedTypes = checkNotNull(importedTypes);\n+    this.out = checkNotNull(out, \"out == null\");\n+    this.indent = checkNotNull(indent, \"indent == null\");\n+    this.importedTypes = checkNotNull(importedTypes, \"importedTypes == null\");\n   }\n \n   public ImmutableMap<ClassName, String> importedTypes() {\n@@ -100,19 +100,19 @@ final class CodeWriter {\n   }\n \n   public CodeWriter unindent(int levels) {\n-    checkArgument(indentLevel - levels >= 0);\n+    checkArgument(indentLevel - levels >= 0, \"cannot unindent %s from %s\", levels, indentLevel);\n     indentLevel -= levels;\n     return this;\n   }\n \n   public CodeWriter pushPackage(String packageName) {\n-    checkState(this.packageName == null);\n-    this.packageName = checkNotNull(packageName);\n+    checkState(this.packageName == null, \"package already set: %s\", this.packageName);\n+    this.packageName = checkNotNull(packageName, \"packageName == null\");\n     return this;\n   }\n \n   public CodeWriter popPackage() {\n-    checkState(this.packageName != null);\n+    checkState(this.packageName != null, \"package already set: %s\", this.packageName);\n     this.packageName = null;\n     return this;\n   }\n"
    },
    {
        "commit_hash": "46f64399f2bf43c8db91cab67c18546e611c58ca",
        "previous_commit_hash": "74907054c085e3b33cbec4a064afcc3814ae0dd0",
        "diff_stats": {
            "additions": 7,
            "deletions": 7
        },
        "diff_content": "@@ -85,15 +85,15 @@ public final class TypeSpec {\n   }\n \n   public static Builder classBuilder(String name) {\n-    return new Builder(Kind.CLASS, checkNotNull(name), null);\n+    return new Builder(Kind.CLASS, checkNotNull(name, \"name == null\"), null);\n   }\n \n   public static Builder interfaceBuilder(String name) {\n-    return new Builder(Kind.INTERFACE, checkNotNull(name), null);\n+    return new Builder(Kind.INTERFACE, checkNotNull(name, \"name == null\"), null);\n   }\n \n   public static Builder enumBuilder(String name) {\n-    return new Builder(Kind.ENUM, checkNotNull(name), null);\n+    return new Builder(Kind.ENUM, checkNotNull(name, \"name == null\"), null);\n   }\n \n   public static Builder anonymousClassBuilder(String typeArgumentsFormat, Object... args) {\n@@ -309,13 +309,13 @@ public final class TypeSpec {\n     }\n \n     public Builder addJavadoc(String format, Object... args) {\n-      checkState(anonymousTypeArguments == null);\n+      checkState(anonymousTypeArguments == null, \"forbidden on anonymous types.\");\n       javadoc.add(format, args);\n       return this;\n     }\n \n     public Builder addAnnotation(AnnotationSpec annotationSpec) {\n-      checkState(anonymousTypeArguments == null);\n+      checkState(anonymousTypeArguments == null, \"forbidden on anonymous types.\");\n       this.annotations.add(annotationSpec);\n       return this;\n     }\n@@ -325,13 +325,13 @@ public final class TypeSpec {\n     }\n \n     public Builder addModifiers(Modifier... modifiers) {\n-      checkState(anonymousTypeArguments == null);\n+      checkState(anonymousTypeArguments == null, \"forbidden on anonymous types.\");\n       Collections.addAll(this.modifiers, modifiers);\n       return this;\n     }\n \n     public Builder addTypeVariable(TypeVariable<?> typeVariable) {\n-      checkState(anonymousTypeArguments == null);\n+      checkState(anonymousTypeArguments == null, \"forbidden on anonymous types.\");\n       typeVariables.add(typeVariable);\n       return this;\n     }\n"
    },
    {
        "commit_hash": "46f64399f2bf43c8db91cab67c18546e611c58ca",
        "previous_commit_hash": "74907054c085e3b33cbec4a064afcc3814ae0dd0",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -132,7 +132,7 @@ public final class Types {\n   }\n \n   public static TypeVariable<?> typeVariable(String name, Type... bounds) {\n-    checkNotNull(name);\n+    checkNotNull(name, \"name == null\");\n     for (Type bound : bounds) {\n       checkNotPrimitive(bound);\n     }\n"
    },
    {
        "commit_hash": "34bde0e9547549b4720b9ac6b5c12170d58bb1c8",
        "previous_commit_hash": "104f20fb07eb2318a85a3de7457b56435e579fc5",
        "diff_stats": {
            "additions": 0,
            "deletions": 6
        },
        "diff_content": "@@ -22,7 +22,6 @@\n \n     <java.version>1.7</java.version>\n     <junit.version>4.12</junit.version>\n-    <guava.version>18.0</guava.version>\n     <truth.version>1.0-SNAPSHOT</truth.version>\n     <compile-testing.version>1.0-SNAPSHOT</compile-testing.version>\n   </properties>\n@@ -52,11 +51,6 @@\n   </organization>\n \n   <dependencies>\n-    <dependency>\n-      <groupId>com.google.guava</groupId>\n-      <artifactId>guava</artifactId>\n-      <version>${guava.version}</version>\n-    </dependency>\n     <dependency>\n       <groupId>com.google.truth</groupId>\n       <artifactId>truth</artifactId>\n"
    },
    {
        "commit_hash": "34bde0e9547549b4720b9ac6b5c12170d58bb1c8",
        "previous_commit_hash": "104f20fb07eb2318a85a3de7457b56435e579fc5",
        "diff_stats": {
            "additions": 26,
            "deletions": 34
        },
        "diff_content": "@@ -15,33 +15,25 @@\n  */\n package com.squareup.javapoet;\n \n-import com.google.common.base.Supplier;\n-import com.google.common.collect.ImmutableListMultimap;\n-import com.google.common.collect.ImmutableMultimap;\n-import com.google.common.collect.ImmutableSet;\n-import com.google.common.collect.Multimap;\n-import com.google.common.collect.Multimaps;\n import java.io.IOException;\n import java.io.StringWriter;\n import java.lang.reflect.Type;\n import java.util.ArrayList;\n-import java.util.Collection;\n import java.util.Iterator;\n+import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n-import java.util.TreeMap;\n \n-import static com.google.common.base.Preconditions.checkNotNull;\n-import static com.google.common.collect.Iterables.getOnlyElement;\n+import static com.squareup.javapoet.Util.checkNotNull;\n \n /** A generated annotation on a declaration. */\n public final class AnnotationSpec {\n   public final Type type;\n-  public final ImmutableMultimap<String, CodeBlock> members;\n+  public final Map<String, List<CodeBlock>> members;\n \n   private AnnotationSpec(Builder builder) {\n     this.type = builder.type;\n-    this.members = ImmutableListMultimap.copyOf(builder.members);\n+    this.members = Util.immutableMultimap(builder.members);\n   }\n \n   void emit(CodeWriter codeWriter, boolean inline) throws IOException {\n@@ -50,10 +42,10 @@ public final class AnnotationSpec {\n     if (members.isEmpty()) {\n       // @Singleton\n       codeWriter.emit(\"@$T\", type);\n-    } else if (members.keySet().equals(ImmutableSet.of(\"value\"))) {\n+    } else if (members.size() == 1 && members.containsKey(\"value\")) {\n       // @Named(\"foo\")\n       codeWriter.emit(\"@$T(\", type);\n-      emitAnnotationValue(codeWriter, whitespace, memberSeparator, members.values());\n+      emitAnnotationValues(codeWriter, whitespace, memberSeparator, members.get(\"value\"));\n       codeWriter.emit(\")\");\n     } else {\n       // Inline:\n@@ -66,11 +58,11 @@ public final class AnnotationSpec {\n       //   )\n       codeWriter.emit(\"@$T(\" + whitespace, type);\n       codeWriter.indent(2);\n-      for (Iterator<Map.Entry<String, Collection<CodeBlock>>> i\n-          = members.asMap().entrySet().iterator(); i.hasNext();) {\n-        Map.Entry<String, Collection<CodeBlock>> entry = i.next();\n+      for (Iterator<Map.Entry<String, List<CodeBlock>>> i\n+          = members.entrySet().iterator(); i.hasNext();) {\n+        Map.Entry<String, List<CodeBlock>> entry = i.next();\n         codeWriter.emit(\"$L = \", entry.getKey());\n-        emitAnnotationValue(codeWriter, whitespace, memberSeparator, entry.getValue());\n+        emitAnnotationValues(codeWriter, whitespace, memberSeparator, entry.getValue());\n         if (i.hasNext()) codeWriter.emit(memberSeparator);\n       }\n       codeWriter.unindent(2);\n@@ -78,11 +70,11 @@ public final class AnnotationSpec {\n     }\n   }\n \n-  private void emitAnnotationValue(CodeWriter codeWriter, String whitespace, String memberSeparator,\n-      Collection<CodeBlock> value) throws IOException {\n-    if (value.size() == 1) {\n+  private void emitAnnotationValues(CodeWriter codeWriter, String whitespace,\n+      String memberSeparator, List<CodeBlock> values) throws IOException {\n+    if (values.size() == 1) {\n       codeWriter.indent(2);\n-      codeWriter.emit(getOnlyElement(value));\n+      codeWriter.emit(values.get(0));\n       codeWriter.unindent(2);\n       return;\n     }\n@@ -90,7 +82,7 @@ public final class AnnotationSpec {\n     codeWriter.emit(\"{\" + whitespace);\n     codeWriter.indent(2);\n     boolean first = true;\n-    for (CodeBlock codeBlock : value) {\n+    for (CodeBlock codeBlock : values) {\n       if (!first) codeWriter.emit(memberSeparator);\n       codeWriter.emit(codeBlock);\n       first = false;\n@@ -127,15 +119,23 @@ public final class AnnotationSpec {\n \n   public static final class Builder {\n     private final Type type;\n-    private final Multimap<String, CodeBlock> members = Multimaps.newListMultimap(\n-        new TreeMap<String, Collection<CodeBlock>>(), AnnotationSpec.<CodeBlock>listSupplier());\n+    private final Map<String, List<CodeBlock>> members = new LinkedHashMap<>();\n \n     private Builder(Type type) {\n       this.type = type;\n     }\n \n     public Builder addMember(String name, String format, Object... args) {\n-      members.put(name, CodeBlock.builder().add(format, args).build());\n+      return addMember(name, CodeBlock.builder().add(format, args).build());\n+    }\n+\n+    public Builder addMember(String name, CodeBlock codeBlock) {\n+      List<CodeBlock> values = members.get(name);\n+      if (values == null) {\n+        values = new ArrayList<>();\n+        members.put(name, values);\n+      }\n+      values.add(codeBlock);\n       return this;\n     }\n \n@@ -143,12 +143,4 @@ public final class AnnotationSpec {\n       return new AnnotationSpec(this);\n     }\n   }\n-\n-  private static <T> Supplier<List<T>> listSupplier() {\n-    return new Supplier<List<T>>() {\n-      @Override public List<T> get() {\n-        return new ArrayList<>();\n-      }\n-    };\n-  }\n }\n"
    },
    {
        "commit_hash": "34bde0e9547549b4720b9ac6b5c12170d58bb1c8",
        "previous_commit_hash": "104f20fb07eb2318a85a3de7457b56435e579fc5",
        "diff_stats": {
            "additions": 26,
            "deletions": 37
        },
        "diff_content": "@@ -15,13 +15,6 @@\n  */\n package com.squareup.javapoet;\n \n-import com.google.common.base.Ascii;\n-import com.google.common.base.Joiner;\n-import com.google.common.base.Splitter;\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableSet;\n-import com.google.common.collect.Iterables;\n-import com.google.common.collect.Sets;\n import java.lang.reflect.Type;\n import java.util.ArrayList;\n import java.util.Collections;\n@@ -30,12 +23,11 @@ import java.util.Map;\n import javax.lang.model.SourceVersion;\n import javax.lang.model.element.Element;\n import javax.lang.model.element.ElementKind;\n-import javax.lang.model.element.NestingKind;\n import javax.lang.model.element.PackageElement;\n import javax.lang.model.element.TypeElement;\n \n-import static com.google.common.base.Preconditions.checkArgument;\n-import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.squareup.javapoet.Util.checkArgument;\n+import static com.squareup.javapoet.Util.checkNotNull;\n import static javax.lang.model.element.NestingKind.MEMBER;\n import static javax.lang.model.element.NestingKind.TOP_LEVEL;\n \n@@ -44,17 +36,17 @@ public final class ClassName implements Type, Comparable<ClassName> {\n   public static final ClassName OBJECT = ClassName.get(Object.class);\n \n   /** From top to bottom. This will be [\"java.util\", \"Map\", \"Entry\"] for {@link Map.Entry}. */\n-  final ImmutableList<String> names;\n+  final List<String> names;\n   final String canonicalName;\n \n   private ClassName(List<String> names) {\n     for (int i = 1; i < names.size(); i++) {\n       checkArgument(SourceVersion.isName(names.get(i)), \"part '%s' is keyword\", names.get(i));\n     }\n-    this.names = ImmutableList.copyOf(names);\n-    this.canonicalName = Joiner.on(\".\").join(names.get(0).isEmpty()\n-        ? names.subList(1, names.size())\n-        : names);\n+    this.names = Util.immutableList(names);\n+    this.canonicalName = names.get(0).isEmpty()\n+        ? Util.join(\".\", names.subList(1, names.size()))\n+        : Util.join(\".\", names);\n   }\n \n   /** Returns the package name, like {@code \"java.util\"} for {@code Map.Entry}. */\n@@ -77,13 +69,13 @@ public final class ClassName implements Type, Comparable<ClassName> {\n    */\n   public ClassName nestedClass(String name) {\n     checkNotNull(name, \"name == null\");\n-    return new ClassName(new ImmutableList.Builder<String>()\n-        .addAll(names)\n-        .add(name)\n-        .build());\n+    List<String> result = new ArrayList<>(names.size() + 1);\n+    result.addAll(names);\n+    result.add(name);\n+    return new ClassName(result);\n   }\n \n-  public ImmutableList<String> simpleNames() {\n+  public List<String> simpleNames() {\n     return names.subList(1, names.size());\n   }\n \n@@ -93,15 +85,14 @@ public final class ClassName implements Type, Comparable<ClassName> {\n    * it is equivalent to {@code get(packageName(), name)}.\n    */\n   public ClassName peerClass(String name) {\n-    return new ClassName(new ImmutableList.Builder<String>()\n-        .addAll(names.subList(0, names.size() - 1))\n-        .add(name)\n-        .build());\n+    List<String> result = new ArrayList<>(names);\n+    result.set(result.size() - 1, name);\n+    return new ClassName(result);\n   }\n \n   /** Returns the simple name of this class, like {@code \"Entry\"} for {@link Map.Entry}. */\n   public String simpleName() {\n-    return Iterables.getLast(names);\n+    return names.get(names.size() - 1);\n   }\n \n   public static ClassName get(Class<?> clazz) {\n@@ -131,15 +122,15 @@ public final class ClassName implements Type, Comparable<ClassName> {\n \n     // Add the package name, like \"java.util.concurrent\", or \"\" for no package.\n     int p = 0;\n-    while (p < classNameString.length() && Ascii.isLowerCase(classNameString.charAt(p))) {\n+    while (p < classNameString.length() && Util.isLowerCase(classNameString.charAt(p))) {\n       p = classNameString.indexOf('.', p) + 1;\n       checkArgument(p != 0, \"couldn't make a guess for %s\", classNameString);\n     }\n     names.add(p != 0 ? classNameString.substring(0, p - 1) : \"\");\n \n     // Add the class names, like \"Map\" and \"Entry\".\n-    for (String part : Splitter.on('.').split(classNameString.substring(p))) {\n-      checkArgument(!part.isEmpty() && Ascii.isUpperCase(part.charAt(0)),\n+    for (String part : classNameString.substring(p).split(\"\\\\.\", -1)) {\n+      checkArgument(!part.isEmpty() && Util.isUpperCase(part.charAt(0)),\n           \"couldn't make a guess for %s\", classNameString);\n       names.add(part);\n     }\n@@ -153,22 +144,20 @@ public final class ClassName implements Type, Comparable<ClassName> {\n    * {@code \"java.util\"} and simple names {@code \"Map\"}, {@code \"Entry\"} yields {@link Map.Entry}.\n    */\n   public static ClassName get(String packageName, String simpleName, String... simpleNames) {\n-    return new ClassName(new ImmutableList.Builder<String>()\n-        .add(packageName)\n-        .add(simpleName)\n-        .add(simpleNames)\n-        .build());\n+    List<String> result = new ArrayList<>();\n+    result.add(packageName);\n+    result.add(simpleName);\n+    Collections.addAll(result, simpleNames);\n+    return new ClassName(result);\n   }\n \n-  private static final ImmutableSet<NestingKind> ACCEPTABLE_NESTING_KINDS =\n-      Sets.immutableEnumSet(TOP_LEVEL, MEMBER);\n-\n   /** Returns the class name for {@code element}. */\n   public static ClassName get(TypeElement element) {\n     checkNotNull(element, \"element == null\");\n     List<String> names = new ArrayList<>();\n     for (Element e = element; isClassOrInterface(e); e = e.getEnclosingElement()) {\n-      checkArgument(ACCEPTABLE_NESTING_KINDS.contains(element.getNestingKind()));\n+      checkArgument(element.getNestingKind() == TOP_LEVEL || element.getNestingKind() == MEMBER,\n+          \"unexpected type testing\");\n       names.add(e.getSimpleName().toString());\n     }\n     names.add(getPackage(element).getQualifiedName().toString());\n"
    },
    {
        "commit_hash": "34bde0e9547549b4720b9ac6b5c12170d58bb1c8",
        "previous_commit_hash": "104f20fb07eb2318a85a3de7457b56435e579fc5",
        "diff_stats": {
            "additions": 4,
            "deletions": 4
        },
        "diff_content": "@@ -21,8 +21,8 @@ import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n \n-import static com.google.common.base.Preconditions.checkArgument;\n-import static com.google.common.base.Preconditions.checkState;\n+import static com.squareup.javapoet.Util.checkArgument;\n+import static com.squareup.javapoet.Util.checkState;\n \n /**\n  * A fragment of a .java file, potentially containing declarations, statements, and documentation.\n@@ -60,8 +60,8 @@ public final class CodeBlock {\n   final List<Object> args;\n \n   private CodeBlock(Builder builder) {\n-    this.formatParts = Collections.unmodifiableList(new ArrayList<>(builder.formatParts));\n-    this.args = Collections.unmodifiableList(new ArrayList<>(builder.args));\n+    this.formatParts = Util.immutableList(builder.formatParts);\n+    this.args = Util.immutableList(builder.args);\n   }\n \n   public boolean isEmpty() {\n"
    },
    {
        "commit_hash": "34bde0e9547549b4720b9ac6b5c12170d58bb1c8",
        "previous_commit_hash": "104f20fb07eb2318a85a3de7457b56435e579fc5",
        "diff_stats": {
            "additions": 23,
            "deletions": 28
        },
        "diff_content": "@@ -15,12 +15,6 @@\n  */\n package com.squareup.javapoet;\n \n-import com.google.common.base.Ascii;\n-import com.google.common.base.Joiner;\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n-import com.google.common.collect.ImmutableSet;\n-import com.google.common.collect.ImmutableSortedMap;\n import java.io.IOException;\n import java.lang.reflect.GenericArrayType;\n import java.lang.reflect.ParameterizedType;\n@@ -28,21 +22,24 @@ import java.lang.reflect.Type;\n import java.lang.reflect.TypeVariable;\n import java.lang.reflect.WildcardType;\n import java.util.ArrayList;\n+import java.util.Collections;\n import java.util.EnumSet;\n import java.util.Formatter;\n import java.util.LinkedHashMap;\n import java.util.LinkedHashSet;\n import java.util.List;\n+import java.util.Locale;\n import java.util.Map;\n import java.util.Objects;\n import java.util.Set;\n+import java.util.TreeMap;\n import javax.lang.model.element.Element;\n import javax.lang.model.element.Modifier;\n import javax.lang.model.type.TypeMirror;\n \n-import static com.google.common.base.Preconditions.checkArgument;\n-import static com.google.common.base.Preconditions.checkNotNull;\n-import static com.google.common.base.Preconditions.checkState;\n+import static com.squareup.javapoet.Util.checkArgument;\n+import static com.squareup.javapoet.Util.checkNotNull;\n+import static com.squareup.javapoet.Util.checkState;\n \n /**\n  * Converts a {@link JavaFile} to a string suitable to both human- and javac-consumption. This\n@@ -57,7 +54,7 @@ final class CodeWriter {\n   private boolean comment = false;\n   private String packageName;\n   private final List<TypeSpec> typeSpecStack = new ArrayList<>();\n-  private final ImmutableMap<ClassName, String> importedTypes;\n+  private final Map<ClassName, String> importedTypes;\n   private final Set<ClassName> importableTypes = new LinkedHashSet<>();\n   private boolean trailingNewline;\n \n@@ -73,16 +70,16 @@ final class CodeWriter {\n   }\n \n   public CodeWriter(Appendable out, String indent) {\n-    this(out, indent, ImmutableMap.<ClassName, String>of());\n+    this(out, indent, Collections.<ClassName, String>emptyMap());\n   }\n \n-  public CodeWriter(Appendable out, String indent, ImmutableMap<ClassName, String> importedTypes) {\n+  public CodeWriter(Appendable out, String indent, Map<ClassName, String> importedTypes) {\n     this.out = checkNotNull(out, \"out == null\");\n     this.indent = checkNotNull(indent, \"indent == null\");\n     this.importedTypes = checkNotNull(importedTypes, \"importedTypes == null\");\n   }\n \n-  public ImmutableMap<ClassName, String> importedTypes() {\n+  public Map<ClassName, String> importedTypes() {\n     return importedTypes;\n   }\n \n@@ -151,8 +148,7 @@ final class CodeWriter {\n     emit(\" */\\n\");\n   }\n \n-  public void emitAnnotations(ImmutableList<AnnotationSpec> annotations, boolean inline)\n-      throws IOException {\n+  public void emitAnnotations(List<AnnotationSpec> annotations, boolean inline) throws IOException {\n     for (AnnotationSpec annotationSpec : annotations) {\n       annotationSpec.emit(this, inline);\n       emit(inline ? \" \" : \"\\n\");\n@@ -168,20 +164,20 @@ final class CodeWriter {\n     if (modifiers.isEmpty()) return;\n     for (Modifier modifier : EnumSet.copyOf(modifiers)) {\n       if (implicitModifiers.contains(modifier)) continue;\n-      emitAndIndent(Ascii.toLowerCase(modifier.name()));\n+      emitAndIndent(modifier.name().toLowerCase(Locale.US));\n       emitAndIndent(\" \");\n     }\n   }\n \n-  public void emitModifiers(ImmutableSet<Modifier> modifiers) throws IOException {\n-    emitModifiers(modifiers, ImmutableSet.<Modifier>of());\n+  public void emitModifiers(Set<Modifier> modifiers) throws IOException {\n+    emitModifiers(modifiers, Collections.<Modifier>emptySet());\n   }\n \n   /**\n    * Emit type variables with their bounds. This should only be used when declaring type variables;\n    * everywhere else bounds are omitted.\n    */\n-  public void emitTypeVariables(ImmutableList<TypeVariable<?>> typeVariables) throws IOException {\n+  public void emitTypeVariables(List<TypeVariable<?>> typeVariables) throws IOException {\n     if (typeVariables.isEmpty()) return;\n \n     emit(\"<\");\n@@ -264,7 +260,7 @@ final class CodeWriter {\n   private void emitLiteral(Object o) throws IOException {\n     if (o instanceof TypeSpec) {\n       TypeSpec typeSpec = (TypeSpec) o;\n-      typeSpec.emit(this, null, ImmutableSet.<Modifier>of());\n+      typeSpec.emit(this, null, Collections.<Modifier>emptySet());\n     } else if (o instanceof AnnotationSpec) {\n       AnnotationSpec annotationSpec = (AnnotationSpec) o;\n       annotationSpec.emit(this, true);\n@@ -305,7 +301,7 @@ final class CodeWriter {\n       if (superBounds.length == 1) {\n         return emit(\"? super $T\", superBounds[0]);\n       }\n-      checkArgument(extendsBounds.length == 1);\n+      checkArgument(extendsBounds.length == 1, \"unexpected extends bounds: %s\", type);\n       return isObject(extendsBounds[0])\n           ? emit(\"?\")\n           : emit(\"? extends $T\", extendsBounds[0]);\n@@ -358,13 +354,13 @@ final class CodeWriter {\n     }\n \n     // Look for the longest common prefix, which we can omit.\n-    ImmutableList<String> classNames = className.simpleNames();\n+    List<String> classNames = className.simpleNames();\n     int prefixLength = commonPrefixLength(classNames);\n     if (prefixLength == classNames.size()) {\n       return className.simpleName(); // Special case: a class referring to itself!\n     }\n \n-    return Joiner.on('.').join(classNames.subList(prefixLength, classNames.size()));\n+    return Util.join(\".\", classNames.subList(prefixLength, classNames.size()));\n   }\n \n   /**\n@@ -387,7 +383,7 @@ final class CodeWriter {\n    * List}, 1 for {@code AbstractMap}, 1 for {@code AbstractMap.SimpleImmutableEntry}, and 2 for\n    * {@code AbstractMap.SimpleEntry} itself.\n    */\n-  private int commonPrefixLength(ImmutableList<String> classNames) {\n+  private int commonPrefixLength(List<String> classNames) {\n     int size = Math.min(classNames.size(), typeSpecStack.size());\n     for (int i = 0; i < size; i++) {\n       String a = classNames.get(i);\n@@ -470,7 +466,7 @@ final class CodeWriter {\n    * Returns the types that should have been imported for this code. If there were any simple name\n    * collisions, that type's first use is imported.\n    */\n-  ImmutableMap<ClassName, String> suggestedImports() {\n+  Map<ClassName, String> suggestedImports() {\n     // Find the simple names that can be imported, and the classes that they target.\n     Map<String, ClassName> simpleNameToType = new LinkedHashMap<>();\n     for (Type type : importableTypes) {\n@@ -481,8 +477,7 @@ final class CodeWriter {\n     }\n \n     // Invert the map.\n-    ImmutableSortedMap.Builder<ClassName, String> typeToSimpleName\n-        = ImmutableSortedMap.naturalOrder();\n+    TreeMap<ClassName, String> typeToSimpleName = new TreeMap<>();\n     for (Map.Entry<String, ClassName> entry : simpleNameToType.entrySet()) {\n       typeToSimpleName.put(entry.getValue(), entry.getKey());\n     }\n@@ -490,7 +485,7 @@ final class CodeWriter {\n     // TODO(jwilson): omit imports from java.lang, unless their simple names is also present in the\n     //     current class's package. (Yuck.)\n \n-    return typeToSimpleName.build();\n+    return typeToSimpleName;\n   }\n \n   /** Returns the string literal representing {@code data}, including wrapping quotes. */\n"
    },
    {
        "commit_hash": "34bde0e9547549b4720b9ac6b5c12170d58bb1c8",
        "previous_commit_hash": "104f20fb07eb2318a85a3de7457b56435e579fc5",
        "diff_stats": {
            "additions": 7,
            "deletions": 9
        },
        "diff_content": "@@ -15,8 +15,6 @@\n  */\n package com.squareup.javapoet;\n \n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableSet;\n import java.io.IOException;\n import java.io.StringWriter;\n import java.lang.reflect.Type;\n@@ -27,24 +25,24 @@ import java.util.Set;\n import javax.lang.model.SourceVersion;\n import javax.lang.model.element.Modifier;\n \n-import static com.google.common.base.Preconditions.checkArgument;\n-import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.squareup.javapoet.Util.checkArgument;\n+import static com.squareup.javapoet.Util.checkNotNull;\n \n /** A generated field declaration. */\n public final class FieldSpec {\n   public final Type type;\n   public final String name;\n   public final CodeBlock javadoc;\n-  public final ImmutableList<AnnotationSpec> annotations;\n-  public final ImmutableSet<Modifier> modifiers;\n+  public final List<AnnotationSpec> annotations;\n+  public final Set<Modifier> modifiers;\n   public final CodeBlock initializer;\n \n   private FieldSpec(Builder builder) {\n     this.type = checkNotNull(builder.type, \"type == null\");\n     this.name = checkNotNull(builder.name, \"name == null\");\n     this.javadoc = builder.javadoc.build();\n-    this.annotations = ImmutableList.copyOf(builder.annotations);\n-    this.modifiers = ImmutableSet.copyOf(builder.modifiers);\n+    this.annotations = Util.immutableList(builder.annotations);\n+    this.modifiers = Util.immutableSet(builder.modifiers);\n     this.initializer = builder.initializer.build();\n   }\n \n@@ -68,7 +66,7 @@ public final class FieldSpec {\n     StringWriter out = new StringWriter();\n     try {\n       CodeWriter codeWriter = new CodeWriter(out);\n-      emit(codeWriter, ImmutableSet.<Modifier>of());\n+      emit(codeWriter, Collections.<Modifier>emptySet());\n       return out.toString();\n     } catch (IOException e) {\n       throw new AssertionError();\n"
    },
    {
        "commit_hash": "34bde0e9547549b4720b9ac6b5c12170d58bb1c8",
        "previous_commit_hash": "104f20fb07eb2318a85a3de7457b56435e579fc5",
        "diff_stats": {
            "additions": 5,
            "deletions": 5
        },
        "diff_content": "@@ -15,12 +15,12 @@\n  */\n package com.squareup.javapoet;\n \n-import com.google.common.collect.ImmutableMap;\n-import com.google.common.collect.ImmutableSet;\n import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Map;\n import javax.lang.model.element.Modifier;\n \n-import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.squareup.javapoet.Util.checkNotNull;\n \n /** A Java file containing a single top level class. */\n public final class JavaFile {\n@@ -50,7 +50,7 @@ public final class JavaFile {\n     // First pass: emit the entire class, just to collect the types we'll need to import.\n     CodeWriter importsCollector = new CodeWriter(NULL_APPENDABLE, indent);\n     emit(importsCollector);\n-    ImmutableMap<ClassName, String> suggestedImports = importsCollector.suggestedImports();\n+    Map<ClassName, String> suggestedImports = importsCollector.suggestedImports();\n \n     // Second pass: write the code, taking advantage of the imports.\n     CodeWriter codeWriter = new CodeWriter(out, indent, suggestedImports);\n@@ -76,7 +76,7 @@ public final class JavaFile {\n       codeWriter.emit(\"\\n\");\n     }\n \n-    typeSpec.emit(codeWriter, null, ImmutableSet.<Modifier>of());\n+    typeSpec.emit(codeWriter, null, Collections.<Modifier>emptySet());\n \n     codeWriter.popPackage();\n   }\n"
    },
    {
        "commit_hash": "34bde0e9547549b4720b9ac6b5c12170d58bb1c8",
        "previous_commit_hash": "104f20fb07eb2318a85a3de7457b56435e579fc5",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -15,7 +15,6 @@\n  */\n package com.squareup.javapoet;\n \n-import com.google.common.collect.Iterables;\n import java.io.File;\n import java.io.IOException;\n import java.io.OutputStreamWriter;\n@@ -28,7 +27,7 @@ import javax.annotation.processing.Filer;\n import javax.lang.model.element.Element;\n import javax.tools.JavaFileObject;\n \n-import static com.google.common.base.Preconditions.checkArgument;\n+import static com.squareup.javapoet.Util.checkArgument;\n \n /** Writes generated types to a filesystem using the standard directory structure. */\n public final class JavaPoet {\n@@ -79,8 +78,9 @@ public final class JavaPoet {\n       String fileName = javaFile.packageName.isEmpty()\n           ? javaFile.typeSpec.name\n           : javaFile.packageName + \".\" + javaFile.typeSpec.name;\n+      List<Element> originatingElements = javaFile.typeSpec.originatingElements;\n       JavaFileObject filerSourceFile = filer.createSourceFile(fileName,\n-          Iterables.toArray(javaFile.typeSpec.originatingElements, Element.class));\n+          originatingElements.toArray(new Element[originatingElements.size()]));\n       try (Writer writer = filerSourceFile.openWriter()) {\n         javaFile.emit(writer, indent);\n       } catch (Exception e) {\n"
    },
    {
        "commit_hash": "34bde0e9547549b4720b9ac6b5c12170d58bb1c8",
        "previous_commit_hash": "104f20fb07eb2318a85a3de7457b56435e579fc5",
        "diff_stats": {
            "additions": 16,
            "deletions": 18
        },
        "diff_content": "@@ -15,8 +15,6 @@\n  */\n package com.squareup.javapoet;\n \n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableSet;\n import java.io.IOException;\n import java.io.StringWriter;\n import java.lang.reflect.Type;\n@@ -29,10 +27,9 @@ import java.util.Set;\n import javax.lang.model.SourceVersion;\n import javax.lang.model.element.Modifier;\n \n-import static com.google.common.base.Preconditions.checkArgument;\n-import static com.google.common.base.Preconditions.checkNotNull;\n-import static com.google.common.base.Preconditions.checkState;\n-import static com.google.common.collect.Iterables.getLast;\n+import static com.squareup.javapoet.Util.checkArgument;\n+import static com.squareup.javapoet.Util.checkNotNull;\n+import static com.squareup.javapoet.Util.checkState;\n \n /** A generated constructor or method declaration. */\n public final class MethodSpec {\n@@ -40,13 +37,13 @@ public final class MethodSpec {\n \n   public final String name;\n   public final CodeBlock javadoc;\n-  public final ImmutableList<AnnotationSpec> annotations;\n-  public final ImmutableSet<Modifier> modifiers;\n-  public final ImmutableList<TypeVariable<?>> typeVariables;\n+  public final List<AnnotationSpec> annotations;\n+  public final Set<Modifier> modifiers;\n+  public final List<TypeVariable<?>> typeVariables;\n   public final Type returnType;\n-  public final ImmutableList<ParameterSpec> parameters;\n+  public final List<ParameterSpec> parameters;\n   public final boolean varargs;\n-  public final ImmutableList<Type> exceptions;\n+  public final List<Type> exceptions;\n   public final CodeBlock code;\n \n   private MethodSpec(Builder builder) {\n@@ -58,18 +55,19 @@ public final class MethodSpec {\n \n     this.name = checkNotNull(builder.name, \"name == null\");\n     this.javadoc = builder.javadoc.build();\n-    this.annotations = ImmutableList.copyOf(builder.annotations);\n-    this.modifiers = ImmutableSet.copyOf(builder.modifiers);\n-    this.typeVariables = ImmutableList.copyOf(builder.typeVariables);\n+    this.annotations = Util.immutableList(builder.annotations);\n+    this.modifiers = Util.immutableSet(builder.modifiers);\n+    this.typeVariables = Util.immutableList(builder.typeVariables);\n     this.returnType = builder.returnType;\n-    this.parameters = ImmutableList.copyOf(builder.parameters);\n+    this.parameters = Util.immutableList(builder.parameters);\n     this.varargs = builder.varargs;\n-    this.exceptions = ImmutableList.copyOf(builder.exceptions);\n+    this.exceptions = Util.immutableList(builder.exceptions);\n     this.code = code;\n   }\n \n   private boolean lastParameterIsArray(List<ParameterSpec> parameters) {\n-    return !parameters.isEmpty() && Types.arrayComponent(getLast(parameters).type) != null;\n+    return !parameters.isEmpty()\n+        && Types.arrayComponent(parameters.get(parameters.size() - 1).type) != null;\n   }\n \n   void emit(CodeWriter codeWriter, String enclosingName, Set<Modifier> implicitModifiers)\n@@ -137,7 +135,7 @@ public final class MethodSpec {\n     StringWriter out = new StringWriter();\n     try {\n       CodeWriter codeWriter = new CodeWriter(out);\n-      emit(codeWriter, \"Constructor\", ImmutableSet.<Modifier>of());\n+      emit(codeWriter, \"Constructor\", Collections.<Modifier>emptySet());\n       return out.toString();\n     } catch (IOException e) {\n       throw new AssertionError();\n"
    },
    {
        "commit_hash": "34bde0e9547549b4720b9ac6b5c12170d58bb1c8",
        "previous_commit_hash": "104f20fb07eb2318a85a3de7457b56435e579fc5",
        "diff_stats": {
            "additions": 7,
            "deletions": 8
        },
        "diff_content": "@@ -15,31 +15,30 @@\n  */\n package com.squareup.javapoet;\n \n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableSet;\n import java.io.IOException;\n import java.io.StringWriter;\n import java.lang.reflect.Type;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n+import java.util.Set;\n import javax.lang.model.SourceVersion;\n import javax.lang.model.element.Modifier;\n \n-import static com.google.common.base.Preconditions.checkArgument;\n-import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.squareup.javapoet.Util.checkArgument;\n+import static com.squareup.javapoet.Util.checkNotNull;\n \n /** A generated parameter declaration. */\n public final class ParameterSpec {\n   public final String name;\n-  public final ImmutableList<AnnotationSpec> annotations;\n-  public final ImmutableSet<Modifier> modifiers;\n+  public final List<AnnotationSpec> annotations;\n+  public final Set<Modifier> modifiers;\n   public final Type type;\n \n   private ParameterSpec(Builder builder) {\n     this.name = checkNotNull(builder.name, \"name == null\");\n-    this.annotations = ImmutableList.copyOf(builder.annotations);\n-    this.modifiers = ImmutableSet.copyOf(builder.modifiers);\n+    this.annotations = Util.immutableList(builder.annotations);\n+    this.modifiers = Util.immutableSet(builder.modifiers);\n     this.type = checkNotNull(builder.type, \"type == null\");\n   }\n \n"
    },
    {
        "commit_hash": "34bde0e9547549b4720b9ac6b5c12170d58bb1c8",
        "previous_commit_hash": "104f20fb07eb2318a85a3de7457b56435e579fc5",
        "diff_stats": {
            "additions": 58,
            "deletions": 61
        },
        "diff_content": "@@ -15,30 +15,26 @@\n  */\n package com.squareup.javapoet;\n \n-import com.google.common.base.Ascii;\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n-import com.google.common.collect.ImmutableSet;\n-import com.google.common.collect.Sets;\n import java.io.IOException;\n import java.io.StringWriter;\n import java.lang.reflect.Type;\n import java.lang.reflect.TypeVariable;\n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.Iterator;\n import java.util.LinkedHashMap;\n import java.util.List;\n+import java.util.Locale;\n import java.util.Map;\n import java.util.Set;\n import javax.lang.model.SourceVersion;\n import javax.lang.model.element.Element;\n import javax.lang.model.element.Modifier;\n \n-import static com.google.common.base.Preconditions.checkArgument;\n-import static com.google.common.base.Preconditions.checkNotNull;\n-import static com.google.common.base.Preconditions.checkState;\n-import static com.google.common.collect.Iterables.getOnlyElement;\n+import static com.squareup.javapoet.Util.checkArgument;\n+import static com.squareup.javapoet.Util.checkNotNull;\n+import static com.squareup.javapoet.Util.checkState;\n \n /** A generated class, interface, or enum declaration. */\n public final class TypeSpec {\n@@ -46,38 +42,38 @@ public final class TypeSpec {\n   public final String name;\n   public final CodeBlock anonymousTypeArguments;\n   public final CodeBlock javadoc;\n-  public final ImmutableList<AnnotationSpec> annotations;\n-  public final ImmutableSet<Modifier> modifiers;\n-  public final ImmutableList<TypeVariable<?>> typeVariables;\n+  public final List<AnnotationSpec> annotations;\n+  public final Set<Modifier> modifiers;\n+  public final List<TypeVariable<?>> typeVariables;\n   public final Type superclass;\n-  public final ImmutableList<Type> superinterfaces;\n-  public final ImmutableMap<String, TypeSpec> enumConstants;\n-  public final ImmutableList<FieldSpec> fieldSpecs;\n-  public final ImmutableList<MethodSpec> methodSpecs;\n-  public final ImmutableList<TypeSpec> typeSpecs;\n-  public final ImmutableList<Element> originatingElements;\n+  public final List<Type> superinterfaces;\n+  public final Map<String, TypeSpec> enumConstants;\n+  public final List<FieldSpec> fieldSpecs;\n+  public final List<MethodSpec> methodSpecs;\n+  public final List<TypeSpec> typeSpecs;\n+  public final List<Element> originatingElements;\n \n   private TypeSpec(Builder builder) {\n     this.kind = builder.kind;\n     this.name = builder.name;\n     this.anonymousTypeArguments = builder.anonymousTypeArguments;\n     this.javadoc = builder.javadoc.build();\n-    this.annotations = ImmutableList.copyOf(builder.annotations);\n-    this.modifiers = ImmutableSet.copyOf(builder.modifiers);\n-    this.typeVariables = ImmutableList.copyOf(builder.typeVariables);\n+    this.annotations = Util.immutableList(builder.annotations);\n+    this.modifiers = Util.immutableSet(builder.modifiers);\n+    this.typeVariables = Util.immutableList(builder.typeVariables);\n     this.superclass = builder.superclass;\n-    this.superinterfaces = ImmutableList.copyOf(builder.superinterfaces);\n-    this.enumConstants = ImmutableMap.copyOf(builder.enumConstants);\n-    this.fieldSpecs = ImmutableList.copyOf(builder.fieldSpecs);\n-    this.methodSpecs = ImmutableList.copyOf(builder.methodSpecs);\n-    this.typeSpecs = ImmutableList.copyOf(builder.typeSpecs);\n-\n-    ImmutableList.Builder<Element> originatingElementsBuilder = ImmutableList.builder();\n-    originatingElementsBuilder.addAll(builder.originatingElements);\n+    this.superinterfaces = Util.immutableList(builder.superinterfaces);\n+    this.enumConstants = Util.immutableMap(builder.enumConstants);\n+    this.fieldSpecs = Util.immutableList(builder.fieldSpecs);\n+    this.methodSpecs = Util.immutableList(builder.methodSpecs);\n+    this.typeSpecs = Util.immutableList(builder.typeSpecs);\n+\n+    List<Element> originatingElementsMutable = new ArrayList<>();\n+    originatingElementsMutable.addAll(builder.originatingElements);\n     for (TypeSpec typeSpec : builder.typeSpecs) {\n-      originatingElementsBuilder.addAll(typeSpec.originatingElements);\n+      originatingElementsMutable.addAll(typeSpec.originatingElements);\n     }\n-    this.originatingElements = originatingElementsBuilder.build();\n+    this.originatingElements = Util.immutableList(originatingElementsMutable);\n   }\n \n   public boolean hasModifier(Modifier modifier) {\n@@ -122,25 +118,26 @@ public final class TypeSpec {\n         }\n         codeWriter.emit(\" {\\n\");\n       } else if (anonymousTypeArguments != null) {\n-        codeWriter.emit(\"new $T(\", getOnlyElement(superinterfaces, superclass));\n+        Type supertype = !superinterfaces.isEmpty() ? superinterfaces.get(0) : superclass;\n+        codeWriter.emit(\"new $T(\", supertype);\n         codeWriter.emit(anonymousTypeArguments);\n         codeWriter.emit(\") {\\n\");\n       } else {\n         codeWriter.emitJavadoc(javadoc);\n         codeWriter.emitAnnotations(annotations, false);\n-        codeWriter.emitModifiers(modifiers, Sets.union(implicitModifiers, kind.asMemberModifiers));\n-        codeWriter.emit(\"$L $L\", Ascii.toLowerCase(kind.name()), name);\n+        codeWriter.emitModifiers(modifiers, Util.union(implicitModifiers, kind.asMemberModifiers));\n+        codeWriter.emit(\"$L $L\", kind.name().toLowerCase(Locale.US), name);\n         codeWriter.emitTypeVariables(typeVariables);\n \n         List<Type> extendsTypes;\n         List<Type> implementsTypes;\n         if (kind == Kind.INTERFACE) {\n           extendsTypes = superinterfaces;\n-          implementsTypes = ImmutableList.of();\n+          implementsTypes = Collections.emptyList();\n         } else {\n           extendsTypes = superclass.equals(ClassName.OBJECT)\n-              ? ImmutableList.<Type>of()\n-              : ImmutableList.of(superclass);\n+              ? Collections.<Type>emptyList()\n+              : Collections.singletonList(superclass);\n           implementsTypes = superinterfaces;\n         }\n \n@@ -175,7 +172,7 @@ public final class TypeSpec {\n         Map.Entry<String, TypeSpec> enumConstant = i.next();\n         if (!firstMember) codeWriter.emit(\"\\n\");\n         enumConstant.getValue()\n-            .emit(codeWriter, enumConstant.getKey(), ImmutableSet.<Modifier>of());\n+            .emit(codeWriter, enumConstant.getKey(), Collections.<Modifier>emptySet());\n         firstMember = false;\n         if (i.hasNext()) {\n           codeWriter.emit(\",\\n\");\n@@ -241,7 +238,7 @@ public final class TypeSpec {\n     StringWriter out = new StringWriter();\n     try {\n       CodeWriter codeWriter = new CodeWriter(out);\n-      emit(codeWriter, null, ImmutableSet.<Modifier>of());\n+      emit(codeWriter, null, Collections.<Modifier>emptySet());\n       return out.toString();\n     } catch (IOException e) {\n       throw new AssertionError();\n@@ -250,32 +247,32 @@ public final class TypeSpec {\n \n   private enum Kind {\n     CLASS(\n-        ImmutableSet.<Modifier>of(),\n-        ImmutableSet.<Modifier>of(),\n-        ImmutableSet.<Modifier>of(),\n-        ImmutableSet.<Modifier>of()),\n+        Collections.<Modifier>emptySet(),\n+        Collections.<Modifier>emptySet(),\n+        Collections.<Modifier>emptySet(),\n+        Collections.<Modifier>emptySet()),\n \n     INTERFACE(\n-        ImmutableSet.of(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL),\n-        ImmutableSet.of(Modifier.PUBLIC, Modifier.ABSTRACT),\n-        ImmutableSet.of(Modifier.PUBLIC, Modifier.STATIC),\n-        ImmutableSet.of(Modifier.STATIC)),\n+        Util.immutableSet(Arrays.asList(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)),\n+        Util.immutableSet(Arrays.asList(Modifier.PUBLIC, Modifier.ABSTRACT)),\n+        Util.immutableSet(Arrays.asList(Modifier.PUBLIC, Modifier.STATIC)),\n+        Util.immutableSet(Arrays.asList(Modifier.STATIC))),\n \n     ENUM(\n-        ImmutableSet.<Modifier>of(),\n-        ImmutableSet.<Modifier>of(),\n-        ImmutableSet.<Modifier>of(),\n-        ImmutableSet.of(Modifier.STATIC));\n-\n-    private final ImmutableSet<Modifier> implicitFieldModifiers;\n-    private final ImmutableSet<Modifier> implicitMethodModifiers;\n-    private final ImmutableSet<Modifier> implicitTypeModifiers;\n-    private final ImmutableSet<Modifier> asMemberModifiers;\n-\n-    private Kind(ImmutableSet<Modifier> implicitFieldModifiers,\n-        ImmutableSet<Modifier> implicitMethodModifiers,\n-        ImmutableSet<Modifier> implicitTypeModifiers,\n-        ImmutableSet<Modifier> asMemberModifiers) {\n+        Collections.<Modifier>emptySet(),\n+        Collections.<Modifier>emptySet(),\n+        Collections.<Modifier>emptySet(),\n+        Collections.singleton(Modifier.STATIC));\n+\n+    private final Set<Modifier> implicitFieldModifiers;\n+    private final Set<Modifier> implicitMethodModifiers;\n+    private final Set<Modifier> implicitTypeModifiers;\n+    private final Set<Modifier> asMemberModifiers;\n+\n+    private Kind(Set<Modifier> implicitFieldModifiers,\n+        Set<Modifier> implicitMethodModifiers,\n+        Set<Modifier> implicitTypeModifiers,\n+        Set<Modifier> asMemberModifiers) {\n       this.implicitFieldModifiers = implicitFieldModifiers;\n       this.implicitMethodModifiers = implicitMethodModifiers;\n       this.implicitTypeModifiers = implicitTypeModifiers;\n"
    },
    {
        "commit_hash": "34bde0e9547549b4720b9ac6b5c12170d58bb1c8",
        "previous_commit_hash": "104f20fb07eb2318a85a3de7457b56435e579fc5",
        "diff_stats": {
            "additions": 20,
            "deletions": 24
        },
        "diff_content": "@@ -15,10 +15,6 @@\n  */\n package com.squareup.javapoet;\n \n-import com.google.common.base.Function;\n-import com.google.common.collect.FluentIterable;\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.Iterables;\n import java.io.IOException;\n import java.lang.reflect.GenericArrayType;\n import java.lang.reflect.InvocationHandler;\n@@ -30,6 +26,8 @@ import java.lang.reflect.TypeVariable;\n import java.lang.reflect.WildcardType;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n@@ -44,21 +42,14 @@ import javax.lang.model.type.TypeKind;\n import javax.lang.model.type.TypeMirror;\n import javax.lang.model.util.SimpleTypeVisitor6;\n \n-import static com.google.common.base.Preconditions.checkArgument;\n-import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.squareup.javapoet.Util.checkArgument;\n+import static com.squareup.javapoet.Util.checkNotNull;\n \n /** Static methods for working with types. */\n // Forked from a similar class in Gson.\n public final class Types {\n   private static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\n \n-  private static final Function<TypeMirror, Type> FOR_TYPE_MIRROR =\n-      new Function<TypeMirror, Type>() {\n-        @Override public Type apply(TypeMirror input) {\n-          return get(input);\n-        }\n-      };\n-\n   static final Type NULL = new Type() {\n     @Override public String toString() {\n       return \"null\";\n@@ -89,8 +80,8 @@ public final class Types {\n    * Returns a new parameterized type, applying {@code typeArguments} to {@code rawType} and\n    * with no enclosing owner type.\n    */\n-  public static ParameterizedType parameterizedType(Type rawType, Iterable<Type> typeArguments) {\n-    return parameterizedType(rawType, Iterables.toArray(typeArguments, Type.class));\n+  public static ParameterizedType parameterizedType(Type rawType, Collection<Type> typeArguments) {\n+    return parameterizedType(rawType, typeArguments.toArray(new Type[typeArguments.size()]));\n   }\n \n   /** Returns an array type whose elements are all instances of {@code componentType}. */\n@@ -182,10 +173,15 @@ public final class Types {\n   }\n \n   private static Type get(DeclaredType t) {\n-    return t.getTypeArguments().isEmpty()\n-        ? ClassName.get((TypeElement) t.asElement())\n-        : parameterizedType(ClassName.get((TypeElement) t.asElement()),\n-            FluentIterable.from(t.getTypeArguments()).transform(FOR_TYPE_MIRROR));\n+    List<? extends TypeMirror> typeArguments = t.getTypeArguments();\n+    if (typeArguments.isEmpty()) {\n+      return ClassName.get((TypeElement) t.asElement());\n+    }\n+    List<Type> typeParameters = new ArrayList<>();\n+    for (TypeMirror typeMirror : typeArguments) {\n+      typeParameters.add(get(typeMirror));\n+    }\n+    return parameterizedType(ClassName.get((TypeElement) t.asElement()), typeParameters);\n   }\n \n   private static TypeVariable<?> get(javax.lang.model.type.TypeVariable mirror) {\n@@ -226,14 +222,14 @@ public final class Types {\n     if (upperBound.getKind() == TypeKind.DECLARED) {\n       TypeElement upperBoundElement = (TypeElement) ((DeclaredType) upperBound).asElement();\n       if (upperBoundElement.getNestingKind() == NestingKind.ANONYMOUS) {\n-        return ImmutableList.<TypeMirror>builder()\n-            .add(upperBoundElement.getSuperclass())\n-            .addAll(upperBoundElement.getInterfaces())\n-            .build();\n+        List<TypeMirror> result = new ArrayList<>();\n+        result.add(upperBoundElement.getSuperclass());\n+        result.addAll(upperBoundElement.getInterfaces());\n+        return result;\n       }\n     }\n \n-    return ImmutableList.of(upperBound);\n+    return Collections.singletonList(upperBound);\n   }\n \n   private static Type get(javax.lang.model.type.WildcardType mirror) {\n"
    },
    {
        "commit_hash": "34bde0e9547549b4720b9ac6b5c12170d58bb1c8",
        "previous_commit_hash": "104f20fb07eb2318a85a3de7457b56435e579fc5",
        "diff_stats": {
            "additions": 93,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,93 @@\n+/*\n+ * Copyright (C) 2015 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javapoet;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Like Guava, but worse and standalone. This makes it easier to mix JavaPoet with libraries that\n+ * bring their own version of Guava.\n+ */\n+final class Util {\n+  private Util() {\n+  }\n+\n+  public static <K, V> Map<K, List<V>> immutableMultimap(Map<K, List<V>> multimap) {\n+    LinkedHashMap<K, List<V>> result = new LinkedHashMap<>();\n+    for (Map.Entry<K, List<V>> entry : multimap.entrySet()) {\n+      if (entry.getValue().isEmpty()) continue;\n+      result.put(entry.getKey(), immutableList(entry.getValue()));\n+    }\n+    return Collections.unmodifiableMap(result);\n+  }\n+\n+  public static <K, V> Map<K, V> immutableMap(Map<K, V> map) {\n+    return Collections.unmodifiableMap(new LinkedHashMap<>(map));\n+  }\n+\n+  public static void checkArgument(boolean condition, String format, Object... args) {\n+    if (!condition) throw new IllegalArgumentException(String.format(format, args));\n+  }\n+\n+  public static <T> T checkNotNull(T reference, String format, Object... args) {\n+    if (reference == null) throw new NullPointerException(String.format(format, args));\n+    return reference;\n+  }\n+\n+  public static void checkState(boolean condition, String format, Object... args) {\n+    if (!condition) throw new IllegalStateException(String.format(format, args));\n+  }\n+\n+  public static <T> List<T> immutableList(List<T> list) {\n+    return Collections.unmodifiableList(new ArrayList<>(list));\n+  }\n+\n+  public static <T> Set<T> immutableSet(Collection<T> set) {\n+    return Collections.unmodifiableSet(new LinkedHashSet<>(set));\n+  }\n+\n+  public static String join(String separator, List<String> parts) {\n+    if (parts.isEmpty()) return \"\";\n+    StringBuilder result = new StringBuilder();\n+    result.append(parts.get(0));\n+    for (int i = 1; i < parts.size(); i++) {\n+      result.append(separator).append(parts.get(i));\n+    }\n+    return result.toString();\n+  }\n+\n+  public static boolean isLowerCase(char c) {\n+    return c >= 'a' && c <= 'z';\n+  }\n+\n+  public static boolean isUpperCase(char c) {\n+    return c >= 'A' && c <= 'Z';\n+  }\n+\n+  public static <T> Set<T> union(Set<T> a, Set<T> b) {\n+    Set<T> result = new LinkedHashSet<>();\n+    result.addAll(a);\n+    result.addAll(b);\n+    return result;\n+  }\n+}\n"
    },
    {
        "commit_hash": "34bde0e9547549b4720b9ac6b5c12170d58bb1c8",
        "previous_commit_hash": "104f20fb07eb2318a85a3de7457b56435e579fc5",
        "diff_stats": {
            "additions": 1,
            "deletions": 2
        },
        "diff_content": "@@ -15,7 +15,6 @@\n  */\n package com.squareup.javapoet;\n \n-import com.google.common.collect.Iterables;\n import com.google.common.jimfs.Jimfs;\n import java.io.File;\n import java.io.IOException;\n@@ -41,7 +40,7 @@ public final class JavaPoetTest {\n \n   // Used for testing java.nio.file Path behavior.\n   private final FileSystem fs = Jimfs.newFileSystem();\n-  private final Path fsRoot = Iterables.getOnlyElement(fs.getRootDirectories());\n+  private final Path fsRoot = fs.getRootDirectories().iterator().next();\n \n   // Used for testing annotation processor Filer behavior.\n   private final TestFiler filer = new TestFiler(fs, fsRoot);\n"
    },
    {
        "commit_hash": "34bde0e9547549b4720b9ac6b5c12170d58bb1c8",
        "previous_commit_hash": "104f20fb07eb2318a85a3de7457b56435e579fc5",
        "diff_stats": {
            "additions": 9,
            "deletions": 11
        },
        "diff_content": "@@ -15,9 +15,6 @@\n  */\n package com.squareup.javapoet;\n \n-import com.google.common.collect.Iterables;\n-import com.google.common.collect.LinkedHashMultimap;\n-import com.google.common.collect.SetMultimap;\n import com.sun.tools.javac.nio.JavacPathFileManager;\n import com.sun.tools.javac.nio.PathFileManager;\n import com.sun.tools.javac.util.Context;\n@@ -25,6 +22,8 @@ import java.io.IOException;\n import java.nio.file.FileSystem;\n import java.nio.file.Path;\n import java.util.Arrays;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n import java.util.Set;\n import javax.annotation.processing.Filer;\n import javax.lang.model.element.Element;\n@@ -38,27 +37,26 @@ final class TestFiler implements Filer {\n   private final String separator;\n   private final Path fileSystemRoot;\n   private final PathFileManager fileManager;\n-  private final SetMultimap<Path, Element> originatingElementsMap;\n+  private final Map<Path, Set<Element>> originatingElementsMap;\n \n   public TestFiler(FileSystem fileSystem, Path fsRoot) {\n     separator = fileSystem.getSeparator();\n     fileSystemRoot = fsRoot;\n     fileManager = new JavacPathFileManager(new Context(), false, UTF_8);\n     fileManager.setDefaultFileSystem(fileSystem);\n-    originatingElementsMap = LinkedHashMultimap.create();\n+    originatingElementsMap = new LinkedHashMap<>();\n   }\n \n   public Set<Element> getOriginatingElements(Path path) {\n     return originatingElementsMap.get(path);\n   }\n \n-  @Override\n-  public JavaFileObject createSourceFile(CharSequence name, Element... originatingElements)\n-      throws IOException {\n-    String relative = name.toString().replace(\".\", separator) + \".java\"; // Not robust, assumes well-formed.\n+  @Override public JavaFileObject createSourceFile(\n+      CharSequence name, Element... originatingElements) throws IOException {\n+    String relative = name.toString().replace(\".\", separator) + \".java\"; // Assumes well-formed.\n     Path path = fileSystemRoot.resolve(relative);\n-    originatingElementsMap.putAll(path, Arrays.asList(originatingElements));\n-    return Iterables.getOnlyElement(fileManager.getJavaFileObjects(path));\n+    originatingElementsMap.put(path, Util.immutableSet(Arrays.asList(originatingElements)));\n+    return fileManager.getJavaFileObjects(path).iterator().next();\n   }\n \n   @Override public JavaFileObject createClassFile(CharSequence name, Element... originatingElements)\n"
    },
    {
        "commit_hash": "34bde0e9547549b4720b9ac6b5c12170d58bb1c8",
        "previous_commit_hash": "104f20fb07eb2318a85a3de7457b56435e579fc5",
        "diff_stats": {
            "additions": 6,
            "deletions": 6
        },
        "diff_content": "@@ -278,9 +278,9 @@ public final class TypeSpecTest {\n         + \"package com.squareup.tacos;\\n\"\n         + \"\\n\"\n         + \"@Something(\\n\"\n-        + \"    hello = \\\"goodbye\\\",\\n\"\n+        + \"    hi = SomeType.FIELD,\\n\"\n         + \"    hey = 12,\\n\"\n-        + \"    hi = SomeType.FIELD\\n\"\n+        + \"    hello = \\\"goodbye\\\"\\n\"\n         + \")\\n\"\n         + \"public class Foo {\\n\"\n         + \"}\\n\");\n@@ -809,11 +809,11 @@ public final class TypeSpecTest {\n         + \"package com.squareup.tacos;\\n\"\n         + \"\\n\"\n         + \"@MealDeal(\\n\"\n+        + \"    price = 500,\\n\"\n         + \"    options = {\\n\"\n-        + \"        @Option(meat = Beef.class, name = \\\"taco\\\"),\\n\"\n-        + \"        @Option(meat = Chicken.class, name = \\\"quesadilla\\\")\\n\"\n-        + \"    },\\n\"\n-        + \"    price = 500\\n\"\n+        + \"        @Option(name = \\\"taco\\\", meat = Beef.class),\\n\"\n+        + \"        @Option(name = \\\"quesadilla\\\", meat = Chicken.class)\\n\"\n+        + \"    }\\n\"\n         + \")\\n\"\n         + \"class Menu {\\n\"\n         + \"}\\n\");\n"
    },
    {
        "commit_hash": "a8d7572208bf3300c504878d8ed8c58f91e2fd8e",
        "previous_commit_hash": "104f20fb07eb2318a85a3de7457b56435e579fc5",
        "diff_stats": {
            "additions": 24,
            "deletions": 4
        },
        "diff_content": "@@ -39,11 +39,13 @@ public final class JavaFile {\n   public final CodeBlock fileComment;\n   public final String packageName;\n   public final TypeSpec typeSpec;\n+  public final boolean skipJavaLangImports;\n \n   private JavaFile(Builder builder) {\n     this.fileComment = builder.fileComment.build();\n     this.packageName = builder.packageName;\n     this.typeSpec = builder.typeSpec;\n+    this.skipJavaLangImports = builder.skipJavaLangImports;\n   }\n \n   public void emit(Appendable out, String indent) throws IOException {\n@@ -69,10 +71,14 @@ public final class JavaFile {\n       codeWriter.emit(\"\\n\");\n     }\n \n-    if (!codeWriter.importedTypes().isEmpty()) {\n-      for (ClassName className : codeWriter.importedTypes().keySet()) {\n-        codeWriter.emit(\"import $L;\\n\", className);\n-      }\n+    int importedTypesCount = 0;\n+    for (ClassName className : codeWriter.importedTypes().keySet()) {\n+      if (skipJavaLangImports && className.packageName().equals(\"java.lang\")) continue;\n+      codeWriter.emit(\"import $L;\\n\", className);\n+      importedTypesCount++;\n+    }\n+\n+    if (importedTypesCount > 0) {\n       codeWriter.emit(\"\\n\");\n     }\n \n@@ -101,6 +107,7 @@ public final class JavaFile {\n     private final String packageName;\n     private final TypeSpec typeSpec;\n     private CodeBlock.Builder fileComment = CodeBlock.builder();\n+    private boolean skipJavaLangImports;\n \n     private Builder(String packageName, TypeSpec typeSpec) {\n       this.packageName = packageName;\n@@ -112,6 +119,19 @@ public final class JavaFile {\n       return this;\n     }\n \n+    /**\n+     * Call this to omit imports for classes in {@code java.lang}, such as {@code java.lang.String}.\n+     *\n+     * <p>By default, JavaPoet explicitly imports types in {@code java.lang} to defend against\n+     * naming conflicts. Suppose an (ill-advised) class is named {@code com.example.String}. When\n+     * {@code java.lang} imports are skipped, generated code in {@code com.example} that references\n+     * {@code java.lang.String} will get {@code com.example.String} instead.\n+     */\n+    public Builder skipJavaLangImports(boolean skipJavaLangImports) {\n+      this.skipJavaLangImports = skipJavaLangImports;\n+      return this;\n+    }\n+\n     public JavaFile build() {\n       return new JavaFile(this);\n     }\n"
    },
    {
        "commit_hash": "a8d7572208bf3300c504878d8ed8c58f91e2fd8e",
        "previous_commit_hash": "104f20fb07eb2318a85a3de7457b56435e579fc5",
        "diff_stats": {
            "additions": 42,
            "deletions": 0
        },
        "diff_content": "@@ -71,6 +71,48 @@ public final class JavaFileTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void skipJavaLangImportsWithConflictingClassLast() throws Exception {\n+    // Whatever is used first wins! In this case the Float in java.lang is imported.\n+    String source = JavaFile.builder(\"com.squareup.tacos\",\n+        TypeSpec.classBuilder(\"Taco\")\n+            .addField(ClassName.get(\"java.lang\", \"Float\"), \"litres\")\n+            .addField(ClassName.get(\"com.squareup.soda\", \"Float\"), \"beverage\")\n+            .build())\n+        .skipJavaLangImports(true)\n+        .build()\n+        .toString();\n+    assertThat(source).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"class Taco {\\n\"\n+        + \"  Float litres;\\n\"\n+        + \"\\n\"\n+        + \"  com.squareup.soda.Float beverage;\\n\" // Second 'Float' is fully qualified.\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void skipJavaLangImportsWithConflictingClassFirst() throws Exception {\n+    // Whatever is used first wins! In this case the Float in com.squareup.soda is imported.\n+    String source = JavaFile.builder(\"com.squareup.tacos\",\n+        TypeSpec.classBuilder(\"Taco\")\n+            .addField(ClassName.get(\"com.squareup.soda\", \"Float\"), \"beverage\")\n+            .addField(ClassName.get(\"java.lang\", \"Float\"), \"litres\")\n+            .build())\n+        .skipJavaLangImports(true)\n+        .build()\n+        .toString();\n+    assertThat(source).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import com.squareup.soda.Float;\\n\"\n+        + \"\\n\"\n+        + \"class Taco {\\n\"\n+        + \"  Float beverage;\\n\"\n+        + \"\\n\"\n+        + \"  java.lang.Float litres;\\n\" // Second 'Float' is fully qualified.\n+        + \"}\\n\");\n+  }\n+\n   @Test public void defaultPackage() throws Exception {\n     String source = JavaFile.builder(\"\",\n         TypeSpec.classBuilder(\"HelloWorld\")\n"
    },
    {
        "commit_hash": "991c92e3d6935a362858ea9dc22dc9b2262f9b63",
        "previous_commit_hash": "302a5e08706c769be6ebd0131d9fcd3f7e5bd778",
        "diff_stats": {
            "additions": 4,
            "deletions": 1
        },
        "diff_content": "@@ -494,7 +494,7 @@ final class CodeWriter {\n   }\n \n   /** Returns the string literal representing {@code data}, including wrapping quotes. */\n-  static String stringLiteral(String value) {\n+  String stringLiteral(String value) {\n     StringBuilder result = new StringBuilder();\n     result.append('\"');\n     for (int i = 0; i < value.length(); i++) {\n@@ -514,6 +514,9 @@ final class CodeWriter {\n           break;\n         case '\\n':\n           result.append(\"\\\\n\");\n+          if (i + 1 < value.length()) {\n+            result.append(\"\\\"\\n\").append(indent).append(indent).append(\"+ \\\"\");\n+          }\n           break;\n         case '\\f':\n           result.append(\"\\\\f\");\n"
    },
    {
        "commit_hash": "991c92e3d6935a362858ea9dc22dc9b2262f9b63",
        "previous_commit_hash": "302a5e08706c769be6ebd0131d9fcd3f7e5bd778",
        "diff_stats": {
            "additions": 19,
            "deletions": 0
        },
        "diff_content": "@@ -1295,4 +1295,23 @@ public final class TypeSpecTest {\n         + \"  }\\n\"\n         + \"}\\n\");\n   }\n+\n+  @Test public void multilineStrings() throws Exception {\n+    TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n+        .addField(FieldSpec.builder(String.class, \"toppings\")\n+            .initializer(\"$S\", \"shell\\nbeef\\nlettuce\\ncheese\\n\")\n+            .build())\n+        .build();\n+    assertThat(toString(taco)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import java.lang.String;\\n\"\n+        + \"\\n\"\n+        + \"class Taco {\\n\"\n+        + \"  String toppings = \\\"shell\\\\n\\\"\\n\"\n+        + \"      + \\\"beef\\\\n\\\"\\n\"\n+        + \"      + \\\"lettuce\\\\n\\\"\\n\"\n+        + \"      + \\\"cheese\\\\n\\\";\\n\"\n+        + \"}\\n\");\n+  }\n }\n"
    },
    {
        "commit_hash": "dfdc30b636ffbd053cfd26cac1c659db7a01a48e",
        "previous_commit_hash": "04746e06713df4190277b9a001b58cd4ee40ed8b",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -122,7 +122,7 @@ public final class ClassName implements Type, Comparable<ClassName> {\n \n     // Add the package name, like \"java.util.concurrent\", or \"\" for no package.\n     int p = 0;\n-    while (p < classNameString.length() && Util.isLowerCase(classNameString.charAt(p))) {\n+    while (p < classNameString.length() && Character.isLowerCase(classNameString.codePointAt(p))) {\n       p = classNameString.indexOf('.', p) + 1;\n       checkArgument(p != 0, \"couldn't make a guess for %s\", classNameString);\n     }\n@@ -130,7 +130,7 @@ public final class ClassName implements Type, Comparable<ClassName> {\n \n     // Add the class names, like \"Map\" and \"Entry\".\n     for (String part : classNameString.substring(p).split(\"\\\\.\", -1)) {\n-      checkArgument(!part.isEmpty() && Util.isUpperCase(part.charAt(0)),\n+      checkArgument(!part.isEmpty() && Character.isUpperCase(part.codePointAt(0)),\n           \"couldn't make a guess for %s\", classNameString);\n       names.add(part);\n     }\n"
    },
    {
        "commit_hash": "dfdc30b636ffbd053cfd26cac1c659db7a01a48e",
        "previous_commit_hash": "04746e06713df4190277b9a001b58cd4ee40ed8b",
        "diff_stats": {
            "additions": 0,
            "deletions": 8
        },
        "diff_content": "@@ -76,14 +76,6 @@ final class Util {\n     return result.toString();\n   }\n \n-  public static boolean isLowerCase(char c) {\n-    return c >= 'a' && c <= 'z';\n-  }\n-\n-  public static boolean isUpperCase(char c) {\n-    return c >= 'A' && c <= 'Z';\n-  }\n-\n   public static <T> Set<T> union(Set<T> a, Set<T> b) {\n     Set<T> result = new LinkedHashSet<>();\n     result.addAll(a);\n"
    },
    {
        "commit_hash": "dfdc30b636ffbd053cfd26cac1c659db7a01a48e",
        "previous_commit_hash": "04746e06713df4190277b9a001b58cd4ee40ed8b",
        "diff_stats": {
            "additions": 8,
            "deletions": 0
        },
        "diff_content": "@@ -23,6 +23,7 @@ import org.junit.Rule;\n import org.junit.Test;\n \n import static com.google.common.truth.Truth.assertThat;\n+import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.fail;\n \n public final class ClassNameTest {\n@@ -33,6 +34,13 @@ public final class ClassNameTest {\n         .isEqualTo(ClassName.get(\"java.lang\", \"String\"));\n   }\n \n+  @Test public void bestGuessNonAscii() {\n+    ClassName className = ClassName.bestGuess(\n+        \"com.\\ud835\\udc1andro\\ud835\\udc22d.\\ud835\\udc00ctiv\\ud835\\udc22ty\");\n+    assertEquals(\"com.\\ud835\\udc1andro\\ud835\\udc22d\", className.packageName());\n+    assertEquals(\"\\ud835\\udc00ctiv\\ud835\\udc22ty\", className.simpleName());\n+  }\n+\n   static class OuterClass {\n     static class InnerClass {}\n   }\n"
    },
    {
        "commit_hash": "f1740bc5d33464f1263da9c8ef540a059a60ee03",
        "previous_commit_hash": "04746e06713df4190277b9a001b58cd4ee40ed8b",
        "diff_stats": {
            "additions": 7,
            "deletions": 7
        },
        "diff_content": "@@ -157,7 +157,7 @@ with wrapping quotation marks and escaping. Here's a program that emits 3 method\n returns its own name:\n \n ```java\n-@Test public void stringLiterals() throws Exception {\n+public static void main(String[] args) throws Exception {\n   TypeSpec helloWorld = TypeSpec.classBuilder(\"HelloWorld\")\n       .addModifiers(Modifier.PUBLIC, Modifier.FINAL)\n       .addMethod(whatsMyName(\"slimShady\"))\n@@ -171,7 +171,7 @@ returns its own name:\n   javaFile.emit(System.out);\n }\n \n-private MethodSpec whatsMyName(String name) {\n+private static MethodSpec whatsMyName(String name) {\n   return MethodSpec.methodBuilder(name)\n       .returns(String.class)\n       .addStatement(\"return $S\", name)\n@@ -263,14 +263,14 @@ public final class HelloWorld {\n \n The `ClassName` type is very important, and you'll need it frequently when you're using JavaPoet.\n It can identify any _declared_ class. Declared types are just the beginning of Java's rich type\n-system: we also have arrays, parameterized types, wildcard types, and type variables. JavaPoet has a\n-`Types` class that can compose each of these:\n+system: we also have arrays, parameterized types, wildcard types, and type variables. JavaPoet has\n+classes for building each of these:\n \n ```java\n ClassName hoverboard = ClassName.get(\"com.mattel\", \"Hoverboard\");\n ClassName list = ClassName.get(\"java.util\", \"List\");\n ClassName arrayList = ClassName.get(\"java.util\", \"ArrayList\");\n-Type listOfHoverboards = Types.parameterizedType(list, hoverboard);\n+TypeName listOfHoverboards = ParameterizedTypeName.get(list, hoverboard);\n \n MethodSpec today = MethodSpec.methodBuilder(\"beyond\")\n     .returns(listOfHoverboards)\n@@ -584,7 +584,7 @@ code blocks. They are values that can be referenced with `$L`:\n \n ```java\n TypeSpec comparator = TypeSpec.anonymousClassBuilder(\"\")\n-    .addSuperinterface(Types.parameterizedType(Comparator.class, String.class))\n+    .addSuperinterface(ParameterizedTypeName.get(Comparator.class, String.class))\n     .addMethod(MethodSpec.methodBuilder(\"compare\")\n         .addAnnotation(Override.class)\n         .addModifiers(Modifier.PUBLIC)\n@@ -596,7 +596,7 @@ TypeSpec comparator = TypeSpec.anonymousClassBuilder(\"\")\n \n TypeSpec helloWorld = TypeSpec.classBuilder(\"HelloWorld\")\n     .addMethod(MethodSpec.methodBuilder(\"sortByLength\")\n-        .addParameter(Types.parameterizedType(List.class, String.class), \"strings\")\n+        .addParameter(ParameterizedTypeName.get(List.class, String.class), \"strings\")\n         .addStatement(\"$T.sort($N, $L)\", Collections.class, \"strings\", comparator)\n         .build())\n     .build();\n"
    },
    {
        "commit_hash": "f1740bc5d33464f1263da9c8ef540a059a60ee03",
        "previous_commit_hash": "04746e06713df4190277b9a001b58cd4ee40ed8b",
        "diff_stats": {
            "additions": 8,
            "deletions": 5
        },
        "diff_content": "@@ -17,7 +17,6 @@ package com.squareup.javapoet;\n \n import java.io.IOException;\n import java.io.StringWriter;\n-import java.lang.reflect.Type;\n import java.util.ArrayList;\n import java.util.Iterator;\n import java.util.LinkedHashMap;\n@@ -28,7 +27,7 @@ import static com.squareup.javapoet.Util.checkNotNull;\n \n /** A generated annotation on a declaration. */\n public final class AnnotationSpec {\n-  public final Type type;\n+  public final TypeName type;\n   public final Map<String, List<CodeBlock>> members;\n \n   private AnnotationSpec(Builder builder) {\n@@ -91,11 +90,15 @@ public final class AnnotationSpec {\n     codeWriter.emit(whitespace + \"}\");\n   }\n \n-  public static Builder builder(Type type) {\n+  public static Builder builder(ClassName type) {\n     checkNotNull(type, \"type == null\");\n     return new Builder(type);\n   }\n \n+  public static Builder builder(Class<?> type) {\n+    return builder(ClassName.get(type));\n+  }\n+\n   @Override public boolean equals(Object o) {\n     return o instanceof AnnotationSpec\n         && ((AnnotationSpec) o).type.equals(type)\n@@ -118,10 +121,10 @@ public final class AnnotationSpec {\n   }\n \n   public static final class Builder {\n-    private final Type type;\n+    private final TypeName type;\n     private final Map<String, List<CodeBlock>> members = new LinkedHashMap<>();\n \n-    private Builder(Type type) {\n+    private Builder(TypeName type) {\n       this.type = type;\n     }\n \n"
    },
    {
        "commit_hash": "f1740bc5d33464f1263da9c8ef540a059a60ee03",
        "previous_commit_hash": "04746e06713df4190277b9a001b58cd4ee40ed8b",
        "diff_stats": {
            "additions": 64,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,64 @@\n+/*\n+ * Copyright (C) 2015 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javapoet;\n+\n+import java.io.IOException;\n+import java.lang.reflect.GenericArrayType;\n+import java.lang.reflect.Type;\n+import javax.lang.model.type.ArrayType;\n+\n+import static com.squareup.javapoet.Util.checkNotNull;\n+\n+public final class ArrayTypeName extends TypeName {\n+  public final TypeName componentType;\n+\n+  private ArrayTypeName(TypeName componentType) {\n+    this.componentType = checkNotNull(componentType, \"rawType == null\");\n+  }\n+\n+  @Override public boolean equals(Object o) {\n+    return o instanceof ArrayTypeName\n+        && ((ArrayTypeName) o).componentType.equals(componentType);\n+  }\n+\n+  @Override public int hashCode() {\n+    return 31 * componentType.hashCode();\n+  }\n+\n+  @Override CodeWriter emit(CodeWriter out) throws IOException {\n+    return out.emit(\"$T[]\", componentType);\n+  }\n+\n+  /** Returns an array type whose elements are all instances of {@code componentType}. */\n+  public static ArrayTypeName of(TypeName componentType) {\n+    return new ArrayTypeName(componentType);\n+  }\n+\n+  /** Returns an array type whose elements are all instances of {@code componentType}. */\n+  public static ArrayTypeName of(Type componentType) {\n+    return of(TypeName.get(componentType));\n+  }\n+\n+  /** Returns an array type equivalent to {@code mirror}. */\n+  public static ArrayTypeName get(ArrayType mirror) {\n+    return new ArrayTypeName(get(mirror.getComponentType()));\n+  }\n+\n+  /** Returns an array type equivalent to {@code type}. */\n+  public static ArrayTypeName get(GenericArrayType type) {\n+    return ArrayTypeName.of(get(type.getGenericComponentType()));\n+  }\n+}\n"
    },
    {
        "commit_hash": "f1740bc5d33464f1263da9c8ef540a059a60ee03",
        "previous_commit_hash": "04746e06713df4190277b9a001b58cd4ee40ed8b",
        "diff_stats": {
            "additions": 4,
            "deletions": 4
        },
        "diff_content": "@@ -15,7 +15,7 @@\n  */\n package com.squareup.javapoet;\n \n-import java.lang.reflect.Type;\n+import java.io.IOException;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n@@ -32,7 +32,7 @@ import static javax.lang.model.element.NestingKind.MEMBER;\n import static javax.lang.model.element.NestingKind.TOP_LEVEL;\n \n /** A fully-qualified class name for top-level and member classes. */\n-public final class ClassName implements Type, Comparable<ClassName> {\n+public final class ClassName extends TypeName implements Comparable<ClassName> {\n   public static final ClassName OBJECT = ClassName.get(Object.class);\n \n   /** From top to bottom. This will be [\"java.util\", \"Map\", \"Entry\"] for {@link Map.Entry}. */\n@@ -189,7 +189,7 @@ public final class ClassName implements Type, Comparable<ClassName> {\n     return canonicalName.compareTo(o.canonicalName);\n   }\n \n-  @Override public String toString() {\n-    return canonicalName;\n+  @Override CodeWriter emit(CodeWriter out) throws IOException {\n+    return out.emitAndIndent(out.lookupName(this));\n   }\n }\n"
    },
    {
        "commit_hash": "f1740bc5d33464f1263da9c8ef540a059a60ee03",
        "previous_commit_hash": "04746e06713df4190277b9a001b58cd4ee40ed8b",
        "diff_stats": {
            "additions": 15,
            "deletions": 73
        },
        "diff_content": "@@ -16,11 +16,7 @@\n package com.squareup.javapoet;\n \n import java.io.IOException;\n-import java.lang.reflect.GenericArrayType;\n-import java.lang.reflect.ParameterizedType;\n import java.lang.reflect.Type;\n-import java.lang.reflect.TypeVariable;\n-import java.lang.reflect.WildcardType;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.EnumSet;\n@@ -177,17 +173,16 @@ final class CodeWriter {\n    * Emit type variables with their bounds. This should only be used when declaring type variables;\n    * everywhere else bounds are omitted.\n    */\n-  public void emitTypeVariables(List<TypeVariable<?>> typeVariables) throws IOException {\n+  public void emitTypeVariables(List<TypeVariableName> typeVariables) throws IOException {\n     if (typeVariables.isEmpty()) return;\n \n     emit(\"<\");\n     boolean firstTypeVariable = true;\n-    for (TypeVariable<?> typeVariable : typeVariables) {\n+    for (TypeVariableName typeVariable : typeVariables) {\n       if (!firstTypeVariable) emit(\", \");\n-      emit(\"$L\", typeVariable.getName());\n+      emit(\"$L\", typeVariable.name);\n       boolean firstBound = true;\n-      for (Type bound : typeVariable.getBounds()) {\n-        if (isObject(bound)) continue;\n+      for (TypeName bound : typeVariable.bounds) {\n         emit(firstBound ? \" extends $T\" : \" & $T\", bound);\n         firstBound = false;\n       }\n@@ -221,7 +216,7 @@ final class CodeWriter {\n           break;\n \n         case \"$T\":\n-          emitType(codeBlock.args.get(a++));\n+          toType(codeBlock.args.get(a++)).emit(this);\n           break;\n \n         case \"$$\":\n@@ -272,64 +267,12 @@ final class CodeWriter {\n     }\n   }\n \n-  private CodeWriter emitType(Object arg) throws IOException {\n-    Type type = toType(arg);\n-\n-    if (type instanceof Class<?>) {\n-      Class<?> classType = (Class<?>) type;\n-      if (classType.isPrimitive()) return emit(classType.getName());\n-      if (classType.isArray()) return emit(\"$T[]\", classType.getComponentType());\n-      return emitType(ClassName.get(classType));\n-\n-    } else if (type instanceof ParameterizedType) {\n-      ParameterizedType parameterizedType = (ParameterizedType) type;\n-      emitType(parameterizedType.getRawType());\n-      emitAndIndent(\"<\");\n-      boolean firstParameter = true;\n-      for (Type parameter : parameterizedType.getActualTypeArguments()) {\n-        if (!firstParameter) emitAndIndent(\", \");\n-        emitType(parameter);\n-        firstParameter = false;\n-      }\n-      emitAndIndent(\">\");\n-      return this;\n-\n-    } else if (type instanceof WildcardType) {\n-      WildcardType wildcardName = (WildcardType) type;\n-      Type[] extendsBounds = wildcardName.getUpperBounds();\n-      Type[] superBounds = wildcardName.getLowerBounds();\n-      if (superBounds.length == 1) {\n-        return emit(\"? super $T\", superBounds[0]);\n-      }\n-      checkArgument(extendsBounds.length == 1, \"unexpected extends bounds: %s\", type);\n-      return isObject(extendsBounds[0])\n-          ? emit(\"?\")\n-          : emit(\"? extends $T\", extendsBounds[0]);\n-\n-    } else if (type instanceof TypeVariable<?>) {\n-      return emitAndIndent(((TypeVariable) type).getName());\n-\n-    } else if (type instanceof ClassName) {\n-      return emitAndIndent(lookupName((ClassName) type));\n-\n-    } else if (type instanceof GenericArrayType) {\n-      return emit(\"$T[]\", ((GenericArrayType) type).getGenericComponentType());\n-\n-    }\n-\n-    throw new UnsupportedOperationException(\"unexpected type: \" + arg);\n-  }\n-\n-  private boolean isObject(Type bound) {\n-    return bound == Object.class || bound.equals(ClassName.OBJECT);\n-  }\n-\n   /**\n    * Returns the best name to identify {@code className} with in the current context. This uses the\n    * available imports and the current scope to find the shortest name available. It does not honor\n    * names visible due to inheritance.\n    */\n-  private String lookupName(ClassName className) {\n+  String lookupName(ClassName className) {\n     // Different package than current? Just look for an import.\n     if (!className.packageName().equals(packageName)) {\n       if (conflictsWithLocalName(className)) {\n@@ -350,7 +293,7 @@ final class CodeWriter {\n \n       // Fall back to the fully-qualified name. Mark the type as importable for a future pass.\n       if (!javadoc) importableTypes.add(className);\n-      return className.toString();\n+      return className.canonicalName;\n     }\n \n     // Look for the longest common prefix, which we can omit.\n@@ -398,7 +341,7 @@ final class CodeWriter {\n    * {@link #out} does it through here, since we emit indentation lazily in order to avoid\n    * unnecessary trailing whitespace.\n    */\n-  private CodeWriter emitAndIndent(String s) throws IOException {\n+  CodeWriter emitAndIndent(String s) throws IOException {\n     boolean first = true;\n     for (String line : s.split(\"\\n\", -1)) {\n       // Emit a newline character. Make sure blank lines in Javadoc & comments look good.\n@@ -442,10 +385,11 @@ final class CodeWriter {\n     }\n   }\n \n-  private Type toType(Object arg) {\n-    if (arg instanceof Type) return (Type) arg;\n-    if (arg instanceof TypeMirror) return Types.get((TypeMirror) arg);\n-    if (arg instanceof Element) return Types.get(((Element) arg).asType());\n+  private TypeName toType(Object arg) {\n+    if (arg instanceof TypeName) return (TypeName) arg;\n+    if (arg instanceof TypeMirror) return TypeName.get((TypeMirror) arg);\n+    if (arg instanceof Element) return TypeName.get(((Element) arg).asType());\n+    if (arg instanceof Type) return TypeName.get((Type) arg);\n     throw new IllegalArgumentException(\"expected type but was \" + arg);\n   }\n \n@@ -454,7 +398,7 @@ final class CodeWriter {\n   }\n \n   private String toName(Object o) {\n-    if (o instanceof CharSequence) return ((CharSequence) o).toString();\n+    if (o instanceof CharSequence) return o.toString();\n     if (o instanceof ParameterSpec) return ((ParameterSpec) o).name;\n     if (o instanceof FieldSpec) return ((FieldSpec) o).name;\n     if (o instanceof MethodSpec) return ((MethodSpec) o).name;\n@@ -469,9 +413,7 @@ final class CodeWriter {\n   Map<ClassName, String> suggestedImports() {\n     // Find the simple names that can be imported, and the classes that they target.\n     Map<String, ClassName> simpleNameToType = new LinkedHashMap<>();\n-    for (Type type : importableTypes) {\n-      if (!(type instanceof ClassName)) continue;\n-      ClassName className = (ClassName) type;\n+    for (ClassName className : importableTypes) {\n       if (simpleNameToType.containsKey(className.simpleName())) continue;\n       simpleNameToType.put(className.simpleName(), className);\n     }\n"
    },
    {
        "commit_hash": "f1740bc5d33464f1263da9c8ef540a059a60ee03",
        "previous_commit_hash": "04746e06713df4190277b9a001b58cd4ee40ed8b",
        "diff_stats": {
            "additions": 13,
            "deletions": 5
        },
        "diff_content": "@@ -30,7 +30,7 @@ import static com.squareup.javapoet.Util.checkNotNull;\n \n /** A generated field declaration. */\n public final class FieldSpec {\n-  public final Type type;\n+  public final TypeName type;\n   public final String name;\n   public final CodeBlock javadoc;\n   public final List<AnnotationSpec> annotations;\n@@ -73,15 +73,19 @@ public final class FieldSpec {\n     }\n   }\n \n-  public static Builder builder(Type type, String name, Modifier... modifiers) {\n+  public static Builder builder(TypeName type, String name, Modifier... modifiers) {\n     checkNotNull(type, \"type == null\");\n     checkArgument(SourceVersion.isName(name), \"not a valid name: %s\", name);\n     return new Builder(type, name)\n         .addModifiers(modifiers);\n   }\n \n+  public static Builder builder(Type type, String name, Modifier... modifiers) {\n+    return builder(TypeName.get(type), name, modifiers);\n+  }\n+\n   public static final class Builder {\n-    private final Type type;\n+    private final TypeName type;\n     private final String name;\n \n     private final CodeBlock.Builder javadoc = CodeBlock.builder();\n@@ -89,7 +93,7 @@ public final class FieldSpec {\n     private final List<Modifier> modifiers = new ArrayList<>();\n     private CodeBlock.Builder initializer = CodeBlock.builder();\n \n-    private Builder(Type type, String name) {\n+    private Builder(TypeName type, String name) {\n       this.type = type;\n       this.name = name;\n     }\n@@ -104,11 +108,15 @@ public final class FieldSpec {\n       return this;\n     }\n \n-    public Builder addAnnotation(Type annotation) {\n+    public Builder addAnnotation(ClassName annotation) {\n       this.annotations.add(AnnotationSpec.builder(annotation).build());\n       return this;\n     }\n \n+    public Builder addAnnotation(Class<?> annotation) {\n+      return addAnnotation(ClassName.get(annotation));\n+    }\n+\n     public Builder addModifiers(Modifier... modifiers) {\n       Collections.addAll(this.modifiers, modifiers);\n       return this;\n"
    },
    {
        "commit_hash": "f1740bc5d33464f1263da9c8ef540a059a60ee03",
        "previous_commit_hash": "04746e06713df4190277b9a001b58cd4ee40ed8b",
        "diff_stats": {
            "additions": 4,
            "deletions": 0
        },
        "diff_content": "@@ -48,6 +48,10 @@ public final class JavaFile {\n     this.skipJavaLangImports = builder.skipJavaLangImports;\n   }\n \n+  public void emit(Appendable out) throws IOException {\n+    emit(out, \"  \");\n+  }\n+\n   public void emit(Appendable out, String indent) throws IOException {\n     // First pass: emit the entire class, just to collect the types we'll need to import.\n     CodeWriter importsCollector = new CodeWriter(NULL_APPENDABLE, indent);\n"
    },
    {
        "commit_hash": "f1740bc5d33464f1263da9c8ef540a059a60ee03",
        "previous_commit_hash": "04746e06713df4190277b9a001b58cd4ee40ed8b",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -30,6 +30,7 @@ import javax.tools.JavaFileObject;\n import static com.squareup.javapoet.Util.checkArgument;\n \n /** Writes generated types to a filesystem using the standard directory structure. */\n+// TODO(jwilson): fold this into JavaFile.\n public final class JavaPoet {\n   private final List<JavaFile> javaFiles = new ArrayList<>();\n   private String indent = \"  \";\n"
    },
    {
        "commit_hash": "f1740bc5d33464f1263da9c8ef540a059a60ee03",
        "previous_commit_hash": "04746e06713df4190277b9a001b58cd4ee40ed8b",
        "diff_stats": {
            "additions": 30,
            "deletions": 15
        },
        "diff_content": "@@ -18,7 +18,6 @@ package com.squareup.javapoet;\n import java.io.IOException;\n import java.io.StringWriter;\n import java.lang.reflect.Type;\n-import java.lang.reflect.TypeVariable;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.Iterator;\n@@ -39,11 +38,11 @@ public final class MethodSpec {\n   public final CodeBlock javadoc;\n   public final List<AnnotationSpec> annotations;\n   public final Set<Modifier> modifiers;\n-  public final List<TypeVariable<?>> typeVariables;\n-  public final Type returnType;\n+  public final List<TypeVariableName> typeVariables;\n+  public final TypeName returnType;\n   public final List<ParameterSpec> parameters;\n   public final boolean varargs;\n-  public final List<Type> exceptions;\n+  public final List<TypeName> exceptions;\n   public final CodeBlock code;\n \n   private MethodSpec(Builder builder) {\n@@ -67,7 +66,7 @@ public final class MethodSpec {\n \n   private boolean lastParameterIsArray(List<ParameterSpec> parameters) {\n     return !parameters.isEmpty()\n-        && Types.arrayComponent(parameters.get(parameters.size() - 1).type) != null;\n+        && TypeName.arrayComponent(parameters.get(parameters.size() - 1).type) != null;\n   }\n \n   void emit(CodeWriter codeWriter, String enclosingName, Set<Modifier> implicitModifiers)\n@@ -99,7 +98,7 @@ public final class MethodSpec {\n     if (!exceptions.isEmpty()) {\n       codeWriter.emit(\" throws\");\n       boolean firstException = true;\n-      for (Type exception : exceptions) {\n+      for (TypeName exception : exceptions) {\n         if (!firstException) codeWriter.emit(\",\");\n         codeWriter.emit(\" $T\", exception);\n         firstException = false;\n@@ -156,10 +155,10 @@ public final class MethodSpec {\n     private final CodeBlock.Builder javadoc = CodeBlock.builder();\n     private final List<AnnotationSpec> annotations = new ArrayList<>();\n     private final List<Modifier> modifiers = new ArrayList<>();\n-    private List<TypeVariable<?>> typeVariables = new ArrayList<>();\n-    private Type returnType;\n+    private List<TypeVariableName> typeVariables = new ArrayList<>();\n+    private TypeName returnType;\n     private final List<ParameterSpec> parameters = new ArrayList<>();\n-    private final List<Type> exceptions = new ArrayList<>();\n+    private final List<TypeName> exceptions = new ArrayList<>();\n     private final CodeBlock.Builder code = CodeBlock.builder();\n     private boolean varargs;\n \n@@ -167,7 +166,7 @@ public final class MethodSpec {\n       checkArgument(name.equals(CONSTRUCTOR) || SourceVersion.isName(name),\n           \"not a valid name: %s\", name);\n       this.name = name;\n-      this.returnType = name.equals(CONSTRUCTOR) ? null : void.class;\n+      this.returnType = name.equals(CONSTRUCTOR) ? null : TypeName.VOID;\n     }\n \n     public Builder addJavadoc(String format, Object... args) {\n@@ -180,46 +179,62 @@ public final class MethodSpec {\n       return this;\n     }\n \n-    public Builder addAnnotation(Type annotation) {\n+    public Builder addAnnotation(ClassName annotation) {\n       this.annotations.add(AnnotationSpec.builder(annotation).build());\n       return this;\n     }\n \n+    public Builder addAnnotation(Class<?> annotation) {\n+      return addAnnotation(ClassName.get(annotation));\n+    }\n+\n     public Builder addModifiers(Modifier... modifiers) {\n       Collections.addAll(this.modifiers, modifiers);\n       return this;\n     }\n \n-    public Builder addTypeVariable(TypeVariable typeVariable) {\n+    public Builder addTypeVariable(TypeVariableName typeVariable) {\n       typeVariables.add(typeVariable);\n       return this;\n     }\n \n-    public Builder returns(Type returnType) {\n+    public Builder returns(TypeName returnType) {\n       checkState(!name.equals(CONSTRUCTOR), \"constructor cannot have return type.\");\n       this.returnType = returnType;\n       return this;\n     }\n \n+    public Builder returns(Type returnType) {\n+      return returns(TypeName.get(returnType));\n+    }\n+\n     public Builder addParameter(ParameterSpec parameterSpec) {\n       this.parameters.add(parameterSpec);\n       return this;\n     }\n \n-    public Builder addParameter(Type type, String name, Modifier... modifiers) {\n+    public Builder addParameter(TypeName type, String name, Modifier... modifiers) {\n       return addParameter(ParameterSpec.builder(type, name, modifiers).build());\n     }\n \n+    public Builder addParameter(Type type, String name, Modifier... modifiers) {\n+      return addParameter(TypeName.get(type), name, modifiers);\n+    }\n+\n     public Builder varargs() {\n       this.varargs = true;\n       return this;\n     }\n \n-    public Builder addException(Type exception) {\n+    public Builder addException(TypeName exception) {\n       this.exceptions.add(exception);\n       return this;\n     }\n \n+    public Builder addException(Type exception) {\n+      return addException(TypeName.get(exception));\n+    }\n+\n     public Builder addCode(String format, Object... args) {\n       code.add(format, args);\n       return this;\n"
    },
    {
        "commit_hash": "f1740bc5d33464f1263da9c8ef540a059a60ee03",
        "previous_commit_hash": "04746e06713df4190277b9a001b58cd4ee40ed8b",
        "diff_stats": {
            "additions": 14,
            "deletions": 6
        },
        "diff_content": "@@ -33,7 +33,7 @@ public final class ParameterSpec {\n   public final String name;\n   public final List<AnnotationSpec> annotations;\n   public final Set<Modifier> modifiers;\n-  public final Type type;\n+  public final TypeName type;\n \n   private ParameterSpec(Builder builder) {\n     this.name = checkNotNull(builder.name, \"name == null\");\n@@ -50,7 +50,7 @@ public final class ParameterSpec {\n     codeWriter.emitAnnotations(annotations, true);\n     codeWriter.emitModifiers(modifiers);\n     if (varargs) {\n-      codeWriter.emit(\"$T... $L\", Types.arrayComponent(type), name);\n+      codeWriter.emit(\"$T... $L\", TypeName.arrayComponent(type), name);\n     } else {\n       codeWriter.emit(\"$T $L\", type, name);\n     }\n@@ -67,21 +67,25 @@ public final class ParameterSpec {\n     }\n   }\n \n-  public static Builder builder(Type type, String name, Modifier... modifiers) {\n+  public static Builder builder(TypeName type, String name, Modifier... modifiers) {\n     checkNotNull(type, \"type == null\");\n     checkArgument(SourceVersion.isName(name), \"not a valid name: %s\", name);\n     return new Builder(type, name)\n         .addModifiers(modifiers);\n   }\n \n+  public static Builder builder(Type type, String name, Modifier... modifiers) {\n+    return builder(TypeName.get(type), name, modifiers);\n+  }\n+\n   public static final class Builder {\n-    private final Type type;\n+    private final TypeName type;\n     private final String name;\n \n     private final List<AnnotationSpec> annotations = new ArrayList<>();\n     private final List<Modifier> modifiers = new ArrayList<>();\n \n-    private Builder(Type type, String name) {\n+    private Builder(TypeName type, String name) {\n       this.type = type;\n       this.name = name;\n     }\n@@ -91,11 +95,15 @@ public final class ParameterSpec {\n       return this;\n     }\n \n-    public Builder addAnnotation(Type annotation) {\n+    public Builder addAnnotation(ClassName annotation) {\n       this.annotations.add(AnnotationSpec.builder(annotation).build());\n       return this;\n     }\n \n+    public Builder addAnnotation(Class<?> annotation) {\n+      return addAnnotation(ClassName.get(annotation));\n+    }\n+\n     public Builder addModifiers(Modifier... modifiers) {\n       Collections.addAll(this.modifiers, modifiers);\n       return this;\n"
    },
    {
        "commit_hash": "f1740bc5d33464f1263da9c8ef540a059a60ee03",
        "previous_commit_hash": "04746e06713df4190277b9a001b58cd4ee40ed8b",
        "diff_stats": {
            "additions": 79,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright (C) 2015 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javapoet;\n+\n+import java.io.IOException;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static com.squareup.javapoet.Util.checkArgument;\n+import static com.squareup.javapoet.Util.checkNotNull;\n+\n+public final class ParameterizedTypeName extends TypeName {\n+  public final ClassName rawType;\n+  public final List<TypeName> typeArguments;\n+\n+  ParameterizedTypeName(ClassName rawType, List<TypeName> typeArguments) {\n+    this.rawType = checkNotNull(rawType, \"rawType == null\");\n+    this.typeArguments = Util.immutableList(typeArguments);\n+\n+    checkArgument(!this.typeArguments.isEmpty(), \"no type arguments: %s\", rawType);\n+    for (TypeName typeArgument : this.typeArguments) {\n+      checkArgument(!typeArgument.isPrimitive() && typeArgument != VOID,\n+          \"invalid type parameter: %s\", typeArgument);\n+    }\n+  }\n+\n+  @Override public boolean equals(Object o) {\n+    return o instanceof ParameterizedTypeName\n+        && ((ParameterizedTypeName) o).rawType.equals(rawType)\n+        && ((ParameterizedTypeName) o).typeArguments.equals(typeArguments);\n+  }\n+\n+  @Override public int hashCode() {\n+    return rawType.hashCode() + 31 * typeArguments.hashCode();\n+  }\n+\n+  @Override CodeWriter emit(CodeWriter out) throws IOException {\n+    rawType.emit(out);\n+    out.emitAndIndent(\"<\");\n+    boolean firstParameter = true;\n+    for (TypeName parameter : typeArguments) {\n+      if (!firstParameter) out.emitAndIndent(\", \");\n+      parameter.emit(out);\n+      firstParameter = false;\n+    }\n+    return out.emitAndIndent(\">\");\n+  }\n+\n+  /** Returns a parameterized type, applying {@code typeArguments} to {@code rawType}. */\n+  public static ParameterizedTypeName get(ClassName rawType, TypeName... typeArguments) {\n+    return new ParameterizedTypeName(rawType, Arrays.asList(typeArguments));\n+  }\n+\n+  /** Returns a parameterized type, applying {@code typeArguments} to {@code rawType}. */\n+  public static ParameterizedTypeName get(Class<?> rawType, Type... typeArguments) {\n+    return new ParameterizedTypeName(ClassName.get(rawType), list(typeArguments));\n+  }\n+\n+  /** Returns a parameterized type equivalent to {@code type}. */\n+  public static ParameterizedTypeName get(ParameterizedType type) {\n+    return new ParameterizedTypeName(ClassName.get((Class<?>) type.getRawType()),\n+        TypeName.list(type.getActualTypeArguments()));\n+  }\n+}\n"
    },
    {
        "commit_hash": "f1740bc5d33464f1263da9c8ef540a059a60ee03",
        "previous_commit_hash": "04746e06713df4190277b9a001b58cd4ee40ed8b",
        "diff_stats": {
            "additions": 213,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,213 @@\n+/*\n+ * Copyright (C) 2015 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javapoet;\n+\n+import java.io.IOException;\n+import java.lang.reflect.GenericArrayType;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+import java.lang.reflect.WildcardType;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.ArrayType;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.NoType;\n+import javax.lang.model.type.PrimitiveType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.util.SimpleTypeVisitor7;\n+\n+/**\n+ * Any type in Java's type system, plus {@code void}. This class is an identifier for primitive\n+ * types like {@code int} and raw reference types like {@code String} and {@code List}. It also\n+ * identifies composite types like {@code char[]} and {@code Set<Long>}.\n+ *\n+ * <p>Type names are dumb identifiers only and do not model the values they name. For example, the\n+ * type name for {@code java.lang.List} doesn't know about the {@code size()} method, the fact that\n+ * lists are collections, or even that it accepts a single type parameter.\n+ *\n+ * <p>Instances of this class are immutable value objects that implement {@code equals()} and {@code\n+ * hashCode()} properly.\n+ *\n+ * <h3>Referencing existing types</h3>\n+ *\n+ * <p>Primitives and void are constants that you can reference directly: see {@link #INT}, {@link\n+ * #DOUBLE}, and {@link #VOID}.\n+ *\n+ * <p>In an annotation processor you can get a type name instance for a type mirror by calling\n+ * {@link #get(TypeMirror)}. In reflection code, you can use {@link #get(Type)}.\n+ *\n+ * <h3>Defining new types</h3>\n+ *\n+ * <p>Create new reference types like {@code com.example.HelloWorld} with {@link\n+ * ClassName#get(String, String, String...)}. To build composite types like {@code char[]} and\n+ * {@code Set<Long>}, use the factory methods on {@link ArrayTypeName}, {@link\n+ * ParameterizedTypeName}, {@link TypeVariableName}, and {@link WildcardTypeName}.\n+ */\n+public class TypeName {\n+  public static final TypeName VOID = new TypeName(\"void\");\n+  public static final TypeName BOOLEAN = new TypeName(\"boolean\");\n+  public static final TypeName BYTE = new TypeName(\"byte\");\n+  public static final TypeName SHORT = new TypeName(\"short\");\n+  public static final TypeName INT = new TypeName(\"int\");\n+  public static final TypeName LONG = new TypeName(\"long\");\n+  public static final TypeName CHAR = new TypeName(\"char\");\n+  public static final TypeName FLOAT = new TypeName(\"float\");\n+  public static final TypeName DOUBLE = new TypeName(\"double\");\n+  public static final ClassName OBJECT = ClassName.get(\"java.lang\", \"Object\");\n+\n+  /** The name of this type if it is a keyword, or null. */\n+  private final String keyword;\n+\n+  private TypeName(String keyword) {\n+    this.keyword = keyword;\n+  }\n+\n+  // Package-private constructor to prevent third-party subclasses.\n+  TypeName() {\n+    this(null);\n+  }\n+\n+  public boolean isPrimitive() {\n+    return keyword != null && this != VOID;\n+  }\n+\n+  @Override public final String toString() {\n+    try {\n+      StringBuilder result = new StringBuilder();\n+      emit(new CodeWriter(result));\n+      return result.toString();\n+    } catch (IOException e) {\n+      throw new AssertionError();\n+    }\n+  }\n+\n+  CodeWriter emit(CodeWriter out) throws IOException {\n+    if (keyword == null) throw new AssertionError();\n+    return out.emitAndIndent(keyword);\n+  }\n+\n+  /** Returns a type name equivalent to {@code mirror}. */\n+  public static TypeName get(TypeMirror mirror) {\n+    return mirror.accept(new SimpleTypeVisitor7<TypeName, Void>() {\n+      @Override public TypeName visitPrimitive(PrimitiveType t, Void p) {\n+        switch (t.getKind()) {\n+          case BOOLEAN:\n+            return TypeName.BOOLEAN;\n+          case BYTE:\n+            return TypeName.BYTE;\n+          case SHORT:\n+            return TypeName.SHORT;\n+          case INT:\n+            return TypeName.INT;\n+          case LONG:\n+            return TypeName.LONG;\n+          case CHAR:\n+            return TypeName.CHAR;\n+          case FLOAT:\n+            return TypeName.FLOAT;\n+          case DOUBLE:\n+            return TypeName.DOUBLE;\n+          default:\n+            throw new AssertionError();\n+        }\n+      }\n+\n+      @Override public TypeName visitDeclared(DeclaredType t, Void p) {\n+        ClassName rawType = ClassName.get((TypeElement) t.asElement());\n+        if (t.getTypeArguments().isEmpty()) return rawType;\n+\n+        List<TypeName> typeArgumentNames = new ArrayList<>();\n+        for (TypeMirror mirror : t.getTypeArguments()) {\n+          typeArgumentNames.add(get(mirror));\n+        }\n+        return new ParameterizedTypeName(rawType, typeArgumentNames);\n+      }\n+\n+      @Override public ArrayTypeName visitArray(ArrayType t, Void p) {\n+        return ArrayTypeName.get(t);\n+      }\n+\n+      @Override public TypeName visitTypeVariable(javax.lang.model.type.TypeVariable t, Void p) {\n+        return TypeVariableName.get(t);\n+      }\n+\n+      @Override public TypeName visitWildcard(javax.lang.model.type.WildcardType t, Void p) {\n+        return WildcardTypeName.get(t);\n+      }\n+\n+      @Override public TypeName visitNoType(NoType t, Void p) {\n+        if (t.getKind() == TypeKind.VOID) return TypeName.VOID;\n+        return super.visitUnknown(t, p);\n+      }\n+\n+      @Override protected TypeName defaultAction(TypeMirror e, Void p) {\n+        throw new IllegalArgumentException(\"Unexpected type mirror: \" + e);\n+      }\n+    }, null);\n+  }\n+\n+  /** Returns a type name equivalent to {@code type}. */\n+  public static TypeName get(Type type) {\n+    if (type instanceof Class<?>) {\n+      Class<?> classType = (Class<?>) type;\n+      if (type == void.class) return VOID;\n+      if (type == boolean.class) return BOOLEAN;\n+      if (type == byte.class) return BYTE;\n+      if (type == short.class) return SHORT;\n+      if (type == int.class) return INT;\n+      if (type == long.class) return LONG;\n+      if (type == char.class) return CHAR;\n+      if (type == float.class) return FLOAT;\n+      if (type == double.class) return DOUBLE;\n+      if (classType.isArray()) return ArrayTypeName.of(get(classType.getComponentType()));\n+      return ClassName.get(classType);\n+\n+    } else if (type instanceof ParameterizedType) {\n+      return ParameterizedTypeName.get((ParameterizedType) type);\n+\n+    } else if (type instanceof WildcardType) {\n+      return WildcardTypeName.get((WildcardType) type);\n+\n+    } else if (type instanceof TypeVariable<?>) {\n+      return TypeVariableName.get((TypeVariable<?>) type);\n+\n+    } else if (type instanceof GenericArrayType) {\n+      return ArrayTypeName.get((GenericArrayType) type);\n+\n+    } else {\n+      throw new IllegalArgumentException(\"unexpected type: \" + type);\n+    }\n+  }\n+\n+  /** Converts an array of types to a list of type names. */\n+  static List<TypeName> list(Type[] types) {\n+    List<TypeName> result = new ArrayList<>();\n+    for (Type type : types) {\n+      result.add(get(type));\n+    }\n+    return result;\n+  }\n+\n+  /** Returns the array component of {@code type}, or null if {@code type} is not an array. */\n+  static TypeName arrayComponent(TypeName type) {\n+    return type instanceof ArrayTypeName\n+        ? ((ArrayTypeName) type).componentType\n+        : null;\n+  }\n+}\n"
    },
    {
        "commit_hash": "f1740bc5d33464f1263da9c8ef540a059a60ee03",
        "previous_commit_hash": "04746e06713df4190277b9a001b58cd4ee40ed8b",
        "diff_stats": {
            "additions": 33,
            "deletions": 18
        },
        "diff_content": "@@ -18,7 +18,6 @@ package com.squareup.javapoet;\n import java.io.IOException;\n import java.io.StringWriter;\n import java.lang.reflect.Type;\n-import java.lang.reflect.TypeVariable;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n@@ -44,9 +43,9 @@ public final class TypeSpec {\n   public final CodeBlock javadoc;\n   public final List<AnnotationSpec> annotations;\n   public final Set<Modifier> modifiers;\n-  public final List<TypeVariable<?>> typeVariables;\n-  public final Type superclass;\n-  public final List<Type> superinterfaces;\n+  public final List<TypeVariableName> typeVariables;\n+  public final TypeName superclass;\n+  public final List<TypeName> superinterfaces;\n   public final Map<String, TypeSpec> enumConstants;\n   public final List<FieldSpec> fieldSpecs;\n   public final List<MethodSpec> methodSpecs;\n@@ -118,7 +117,7 @@ public final class TypeSpec {\n         }\n         codeWriter.emit(\" {\\n\");\n       } else if (anonymousTypeArguments != null) {\n-        Type supertype = !superinterfaces.isEmpty() ? superinterfaces.get(0) : superclass;\n+        TypeName supertype = !superinterfaces.isEmpty() ? superinterfaces.get(0) : superclass;\n         codeWriter.emit(\"new $T(\", supertype);\n         codeWriter.emit(anonymousTypeArguments);\n         codeWriter.emit(\") {\\n\");\n@@ -129,14 +128,14 @@ public final class TypeSpec {\n         codeWriter.emit(\"$L $L\", kind.name().toLowerCase(Locale.US), name);\n         codeWriter.emitTypeVariables(typeVariables);\n \n-        List<Type> extendsTypes;\n-        List<Type> implementsTypes;\n+        List<TypeName> extendsTypes;\n+        List<TypeName> implementsTypes;\n         if (kind == Kind.INTERFACE) {\n           extendsTypes = superinterfaces;\n           implementsTypes = Collections.emptyList();\n         } else {\n           extendsTypes = superclass.equals(ClassName.OBJECT)\n-              ? Collections.<Type>emptyList()\n+              ? Collections.<TypeName>emptyList()\n               : Collections.singletonList(superclass);\n           implementsTypes = superinterfaces;\n         }\n@@ -144,7 +143,7 @@ public final class TypeSpec {\n         if (!extendsTypes.isEmpty()) {\n           codeWriter.emit(\" extends\");\n           boolean firstType = true;\n-          for (Type type : extendsTypes) {\n+          for (TypeName type : extendsTypes) {\n             if (!firstType) codeWriter.emit(\",\");\n             codeWriter.emit(\" $T\", type);\n             firstType = false;\n@@ -154,7 +153,7 @@ public final class TypeSpec {\n         if (!implementsTypes.isEmpty()) {\n           codeWriter.emit(\" implements\");\n           boolean firstType = true;\n-          for (Type type : implementsTypes) {\n+          for (TypeName type : implementsTypes) {\n             if (!firstType) codeWriter.emit(\",\");\n             codeWriter.emit(\" $T\", type);\n             firstType = false;\n@@ -288,9 +287,9 @@ public final class TypeSpec {\n     private final CodeBlock.Builder javadoc = CodeBlock.builder();\n     private final List<AnnotationSpec> annotations = new ArrayList<>();\n     private final List<Modifier> modifiers = new ArrayList<>();\n-    private final List<TypeVariable<?>> typeVariables = new ArrayList<>();\n-    private Type superclass = ClassName.OBJECT;\n-    private final List<Type> superinterfaces = new ArrayList<>();\n+    private final List<TypeVariableName> typeVariables = new ArrayList<>();\n+    private TypeName superclass = ClassName.OBJECT;\n+    private final List<TypeName> superinterfaces = new ArrayList<>();\n     private final Map<String, TypeSpec> enumConstants = new LinkedHashMap<>();\n     private final List<FieldSpec> fieldSpecs = new ArrayList<>();\n     private final List<MethodSpec> methodSpecs = new ArrayList<>();\n@@ -317,32 +316,44 @@ public final class TypeSpec {\n       return this;\n     }\n \n-    public Builder addAnnotation(Type annotation) {\n+    public Builder addAnnotation(ClassName annotation) {\n       return addAnnotation(AnnotationSpec.builder(annotation).build());\n     }\n \n+    public Builder addAnnotation(Class<?> annotation) {\n+      return addAnnotation(ClassName.get(annotation));\n+    }\n+\n     public Builder addModifiers(Modifier... modifiers) {\n       checkState(anonymousTypeArguments == null, \"forbidden on anonymous types.\");\n       Collections.addAll(this.modifiers, modifiers);\n       return this;\n     }\n \n-    public Builder addTypeVariable(TypeVariable<?> typeVariable) {\n+    public Builder addTypeVariable(TypeVariableName typeVariable) {\n       checkState(anonymousTypeArguments == null, \"forbidden on anonymous types.\");\n       typeVariables.add(typeVariable);\n       return this;\n     }\n \n-    public Builder superclass(Type superclass) {\n+    public Builder superclass(TypeName superclass) {\n       this.superclass = superclass;\n       return this;\n     }\n \n-    public Builder addSuperinterface(Type superinterface) {\n+    public Builder superclass(Type superclass) {\n+      return superclass(TypeName.get(superclass));\n+    }\n+\n+    public Builder addSuperinterface(TypeName superinterface) {\n       this.superinterfaces.add(superinterface);\n       return this;\n     }\n \n+    public Builder addSuperinterface(Type superinterface) {\n+      return addSuperinterface(TypeName.get(superinterface));\n+    }\n+\n     public Builder addEnumConstant(String name) {\n       return addEnumConstant(name, anonymousClassBuilder(\"\").build());\n     }\n@@ -364,10 +375,14 @@ public final class TypeSpec {\n       return this;\n     }\n \n-    public Builder addField(Type type, String name, Modifier... modifiers) {\n+    public Builder addField(TypeName type, String name, Modifier... modifiers) {\n       return addField(FieldSpec.builder(type, name, modifiers).build());\n     }\n \n+    public Builder addField(Type type, String name, Modifier... modifiers) {\n+      return addField(TypeName.get(type), name, modifiers);\n+    }\n+\n     public Builder addMethod(MethodSpec methodSpec) {\n       checkArgument(methodSpec.modifiers.containsAll(kind.implicitMethodModifiers),\n           \"%s %s.%s requires modifiers %s\", kind, name, methodSpec.name,\n"
    },
    {
        "commit_hash": "f1740bc5d33464f1263da9c8ef540a059a60ee03",
        "previous_commit_hash": "04746e06713df4190277b9a001b58cd4ee40ed8b",
        "diff_stats": {
            "additions": 132,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,132 @@\n+/*\n+ * Copyright (C) 2015 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javapoet;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import javax.lang.model.element.NestingKind;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+\n+import static com.squareup.javapoet.Util.checkArgument;\n+import static com.squareup.javapoet.Util.checkNotNull;\n+\n+public final class TypeVariableName extends TypeName {\n+  public final String name;\n+  public final List<TypeName> bounds;\n+\n+  private TypeVariableName(String name, List<TypeName> bounds) {\n+    // Strip java.lang.Object from bounds if it is present.\n+    List<TypeName> boundsNoObject = new ArrayList<>(bounds);\n+    boundsNoObject.remove(OBJECT);\n+\n+    this.name = checkNotNull(name, \"name == null\");\n+    this.bounds = Collections.unmodifiableList(boundsNoObject);\n+\n+    for (TypeName bound : this.bounds) {\n+      checkArgument(!bound.isPrimitive() && bound != VOID, \"invalid bound: %s\", bound);\n+    }\n+  }\n+\n+  @Override public boolean equals(Object o) {\n+    return o instanceof TypeVariableName\n+        && ((TypeVariableName) o).name.equals(name)\n+        && ((TypeVariableName) o).bounds.equals(bounds);\n+  }\n+\n+  @Override public int hashCode() {\n+    return name.hashCode() ^ bounds.hashCode();\n+  }\n+\n+  @Override CodeWriter emit(CodeWriter out) throws IOException {\n+    return out.emitAndIndent(name);\n+  }\n+\n+  /** Returns type variable named {@code name} without bounds. */\n+  public static TypeVariableName get(String name) {\n+    return new TypeVariableName(name, Collections.<TypeName>emptyList());\n+  }\n+\n+  /** Returns type variable named {@code name} with {@code bounds}. */\n+  public static TypeVariableName get(String name, TypeName... bounds) {\n+    return new TypeVariableName(name, Arrays.asList(bounds));\n+  }\n+\n+  /** Returns type variable named {@code name} with {@code bounds}. */\n+  public static TypeVariableName get(String name, Type... bounds) {\n+    return new TypeVariableName(name, TypeName.list(bounds));\n+  }\n+\n+  /** Returns type variable equivalent to {@code mirror}. */\n+  public static TypeVariableName get(javax.lang.model.type.TypeVariable mirror) {\n+    String name = mirror.asElement().getSimpleName().toString();\n+    List<? extends TypeMirror> boundsMirrors = typeVariableBounds(mirror);\n+\n+    List<TypeName> boundsTypeNames = new ArrayList<>();\n+    for (TypeMirror typeMirror : boundsMirrors) {\n+      boundsTypeNames.add(TypeName.get(typeMirror));\n+    }\n+\n+    return new TypeVariableName(name, boundsTypeNames);\n+  }\n+\n+  /**\n+   * Returns a list of type mirrors representing the unpacked bounds of {@code typeVariable}. This\n+   * is made gnarly by the need to unpack Java 8's new IntersectionType with reflection. We don't\n+   * have that type in Java 7, and {@link TypeVariable}'s array of bounds is sufficient anyway.\n+   */\n+  @SuppressWarnings(\"unchecked\") // Gross things in support of Java 7 and Java 8.\n+  private static List<? extends TypeMirror> typeVariableBounds(\n+      javax.lang.model.type.TypeVariable typeVariable) {\n+    TypeMirror upperBound = typeVariable.getUpperBound();\n+\n+    // On Java 8, unwrap an intersection type into its component bounds.\n+    if (\"INTERSECTION\".equals(upperBound.getKind().name())) {\n+      try {\n+        Method method = upperBound.getClass().getMethod(\"getBounds\");\n+        return (List<? extends TypeMirror>) method.invoke(upperBound);\n+      } catch (Exception e) {\n+        throw new RuntimeException(e);\n+      }\n+    }\n+\n+    // On Java 7, intersection types exist but without explicit API. Use a (clumsy) heuristic.\n+    if (upperBound.getKind() == TypeKind.DECLARED) {\n+      TypeElement upperBoundElement = (TypeElement) ((DeclaredType) upperBound).asElement();\n+      if (upperBoundElement.getNestingKind() == NestingKind.ANONYMOUS) {\n+        List<TypeMirror> result = new ArrayList<>();\n+        result.add(upperBoundElement.getSuperclass());\n+        result.addAll(upperBoundElement.getInterfaces());\n+        return result;\n+      }\n+    }\n+\n+    return Collections.singletonList(upperBound);\n+  }\n+\n+  /** Returns type variable equivalent to {@code type}. */\n+  public static TypeVariableName get(TypeVariable<?> type) {\n+    return new TypeVariableName(type.getName(), TypeName.list(type.getBounds()));\n+  }\n+}\n"
    },
    {
        "commit_hash": "f1740bc5d33464f1263da9c8ef540a059a60ee03",
        "previous_commit_hash": "04746e06713df4190277b9a001b58cd4ee40ed8b",
        "diff_stats": {
            "additions": 0,
            "deletions": 334
        },
        "diff_content": "@@ -1,334 +0,0 @@\n-/**\n- * Copyright (C) 2008 Google Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.squareup.javapoet;\n-\n-import java.io.IOException;\n-import java.lang.reflect.GenericArrayType;\n-import java.lang.reflect.InvocationHandler;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.ParameterizedType;\n-import java.lang.reflect.Proxy;\n-import java.lang.reflect.Type;\n-import java.lang.reflect.TypeVariable;\n-import java.lang.reflect.WildcardType;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.LinkedHashMap;\n-import java.util.List;\n-import java.util.Map;\n-import javax.lang.model.element.NestingKind;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.type.ArrayType;\n-import javax.lang.model.type.DeclaredType;\n-import javax.lang.model.type.NoType;\n-import javax.lang.model.type.NullType;\n-import javax.lang.model.type.PrimitiveType;\n-import javax.lang.model.type.TypeKind;\n-import javax.lang.model.type.TypeMirror;\n-import javax.lang.model.util.SimpleTypeVisitor6;\n-\n-import static com.squareup.javapoet.Util.checkArgument;\n-import static com.squareup.javapoet.Util.checkNotNull;\n-\n-/** Static methods for working with types. */\n-// Forked from a similar class in Gson.\n-public final class Types {\n-  private static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\n-\n-  static final Type NULL = new Type() {\n-    @Override public String toString() {\n-      return \"null\";\n-    }\n-  };\n-\n-  private Types() {\n-  }\n-\n-  /**\n-   * Returns a new parameterized type, applying {@code typeArguments} to {@code rawType} and\n-   * with no enclosing owner type.\n-   */\n-  public static ParameterizedType parameterizedType(Type rawType, Type... typeArguments) {\n-    checkNotPrimitive(rawType);\n-    for (Type typeArgument : typeArguments) {\n-      checkNotPrimitive(typeArgument);\n-    }\n-    Map<String, Object> accessors = new LinkedHashMap<>();\n-    accessors.put(\"getActualTypeArguments\", typeArguments.clone());\n-    accessors.put(\"getRawType\", rawType);\n-    accessors.put(\"getOwnerType\", null);\n-    int hashCode = Arrays.hashCode(typeArguments) ^ rawType.hashCode();\n-    return newType(ParameterizedType.class, accessors, hashCode);\n-  }\n-\n-  /**\n-   * Returns a new parameterized type, applying {@code typeArguments} to {@code rawType} and\n-   * with no enclosing owner type.\n-   */\n-  public static ParameterizedType parameterizedType(Type rawType, Collection<Type> typeArguments) {\n-    return parameterizedType(rawType, typeArguments.toArray(new Type[typeArguments.size()]));\n-  }\n-\n-  /** Returns an array type whose elements are all instances of {@code componentType}. */\n-  public static GenericArrayType arrayOf(Type componentType) {\n-    checkNotNull(componentType, \"componentType == null\");\n-\n-    Map<String, Object> accessors = new LinkedHashMap<>();\n-    accessors.put(\"getGenericComponentType\", componentType);\n-    int hashCode = componentType.hashCode();\n-    return newType(GenericArrayType.class, accessors, hashCode);\n-  }\n-\n-  /**\n-   * Returns a type that represents an unknown type that extends {@code bound}. For example, if\n-   * {@code bound} is {@code CharSequence.class}, this returns {@code ? extends CharSequence}. If\n-   * {@code bound} is {@code Object.class}, this returns {@code ?}, which is shorthand for {@code\n-   * ? extends Object}.\n-   */\n-  public static WildcardType subtypeOf(Type bound) {\n-    checkNotPrimitive(bound);\n-    return wildcardType(new Type[] {bound}, EMPTY_TYPE_ARRAY);\n-  }\n-\n-  /**\n-   * Returns a type that represents an unknown supertype of {@code bound}. For example, if {@code\n-   * bound} is {@code String.class}, this returns {@code ? super String}.\n-   */\n-  public static WildcardType supertypeOf(Type bound) {\n-    checkNotPrimitive(bound);\n-    return wildcardType(new Type[] {Object.class}, new Type[] {bound});\n-  }\n-\n-  private static WildcardType wildcardType(Type[] upperBounds, Type[] lowerBounds) {\n-    Map<String, Object> accessors = new LinkedHashMap<>();\n-    accessors.put(\"getUpperBounds\", upperBounds.clone());\n-    accessors.put(\"getLowerBounds\", lowerBounds.clone());\n-    int hashCode = Arrays.hashCode(lowerBounds) ^ Arrays.hashCode(upperBounds);\n-    return newType(WildcardType.class, accessors, hashCode);\n-  }\n-\n-  public static TypeVariable<?> typeVariable(String name, Type... bounds) {\n-    checkNotNull(name, \"name == null\");\n-    for (Type bound : bounds) {\n-      checkNotPrimitive(bound);\n-    }\n-\n-    Map<String, Object> accessors = new LinkedHashMap<>();\n-    accessors.put(\"getBounds\", bounds.clone());\n-    accessors.put(\"getName\", name);\n-    int hashCode = name.hashCode();\n-    return newType(TypeVariable.class, accessors, hashCode);\n-  }\n-\n-  public static Type get(TypeMirror mirror) {\n-    return mirror.accept(new SimpleTypeVisitor6<Type, Void>() {\n-      @Override protected Type defaultAction(TypeMirror e, Void p) {\n-        throw new IllegalArgumentException(e.toString());\n-      }\n-\n-      @Override public GenericArrayType visitArray(ArrayType t, Void p) {\n-        return arrayOf(t.getComponentType().accept(this, null));\n-      }\n-\n-      @Override public Type visitDeclared(DeclaredType t, Void p) {\n-        return get(t);\n-      }\n-\n-      @Override public Class<?> visitPrimitive(PrimitiveType t, Void p) {\n-        return get(t);\n-      }\n-\n-      @Override public Type visitTypeVariable(javax.lang.model.type.TypeVariable t, Void p) {\n-        return get(t);\n-      }\n-\n-      @Override public Type visitWildcard(javax.lang.model.type.WildcardType t, Void p) {\n-        return get(t);\n-      }\n-\n-      @Override public Type visitNull(NullType t, Void p) {\n-        return NULL;\n-      }\n-\n-      @Override public Type visitNoType(NoType t, Void p) {\n-        if (t.getKind() == TypeKind.VOID) return void.class;\n-        return super.visitUnknown(t, p);\n-      }\n-    }, null);\n-  }\n-\n-  private static Type get(DeclaredType t) {\n-    List<? extends TypeMirror> typeArguments = t.getTypeArguments();\n-    if (typeArguments.isEmpty()) {\n-      return ClassName.get((TypeElement) t.asElement());\n-    }\n-    List<Type> typeParameters = new ArrayList<>();\n-    for (TypeMirror typeMirror : typeArguments) {\n-      typeParameters.add(get(typeMirror));\n-    }\n-    return parameterizedType(ClassName.get((TypeElement) t.asElement()), typeParameters);\n-  }\n-\n-  private static TypeVariable<?> get(javax.lang.model.type.TypeVariable mirror) {\n-    String name = mirror.asElement().getSimpleName().toString();\n-    List<? extends TypeMirror> boundsMirrors = typeVariableBounds(mirror);\n-\n-    List<Type> boundsTypes = new ArrayList<>();\n-    for (TypeMirror typeMirror : boundsMirrors) {\n-      Type bound = get(typeMirror);\n-      if (bound.equals(ClassName.OBJECT)) continue; // Omit java.lang.Object bounds.\n-      boundsTypes.add(bound);\n-    }\n-\n-    return typeVariable(name, boundsTypes.toArray(new Type[boundsTypes.size()]));\n-  }\n-\n-  /**\n-   * Returns a list of type mirrors representing the unpacked bounds of {@code typeVariable}. This\n-   * is made gnarly by the need to unpack Java 8's new IntersectionType with reflection. We don't\n-   * have that type in Java 7, and {@link TypeVariable}'s array of bounds is sufficient anyway.\n-   */\n-  @SuppressWarnings(\"unchecked\") // Gross things in support of Java 7 and Java 8.\n-  private static List<? extends TypeMirror> typeVariableBounds(\n-      javax.lang.model.type.TypeVariable typeVariable) {\n-    TypeMirror upperBound = typeVariable.getUpperBound();\n-\n-    // On Java 8, unwrap an intersection type into its component bounds.\n-    if (\"INTERSECTION\".equals(upperBound.getKind().name())) {\n-      try {\n-        Method method = upperBound.getClass().getMethod(\"getBounds\");\n-        return (List<? extends TypeMirror>) method.invoke(upperBound);\n-      } catch (Exception e) {\n-        throw new RuntimeException(e);\n-      }\n-    }\n-\n-    // On Java 7, intersection types exist but without explicit API. Use a (clumsy) heuristic.\n-    if (upperBound.getKind() == TypeKind.DECLARED) {\n-      TypeElement upperBoundElement = (TypeElement) ((DeclaredType) upperBound).asElement();\n-      if (upperBoundElement.getNestingKind() == NestingKind.ANONYMOUS) {\n-        List<TypeMirror> result = new ArrayList<>();\n-        result.add(upperBoundElement.getSuperclass());\n-        result.addAll(upperBoundElement.getInterfaces());\n-        return result;\n-      }\n-    }\n-\n-    return Collections.singletonList(upperBound);\n-  }\n-\n-  private static Type get(javax.lang.model.type.WildcardType mirror) {\n-    Type extendsBound = get(mirror.getExtendsBound());\n-    Type superBound = get(mirror.getSuperBound());\n-    return superBound != null ? Types.supertypeOf(superBound) : Types.subtypeOf(extendsBound);\n-  }\n-\n-  private static Class<?> get(PrimitiveType mirror) {\n-    switch (mirror.getKind()) {\n-      case BOOLEAN:\n-        return boolean.class;\n-      case BYTE:\n-        return byte.class;\n-      case SHORT:\n-        return short.class;\n-      case INT:\n-        return int.class;\n-      case LONG:\n-        return long.class;\n-      case CHAR:\n-        return char.class;\n-      case FLOAT:\n-        return float.class;\n-      case DOUBLE:\n-        return double.class;\n-      default:\n-        throw new AssertionError();\n-    }\n-  }\n-\n-  private static void checkNotPrimitive(Type type) {\n-    checkNotNull(type, \"type cannot be primitive.\");\n-    checkArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive(),\n-        \"type cannot be primitive.\");\n-  }\n-\n-  private static String typeToString(Type type) {\n-    try {\n-      StringBuilder result = new StringBuilder();\n-      new CodeWriter(result).emit(\"$T\", type);\n-      return result.toString();\n-    } catch (IOException e) {\n-      throw new AssertionError();\n-    }\n-  }\n-\n-  /** Returns the array component of {@code type}, or null if {@code type} is not an array. */\n-  static Type arrayComponent(Type type) {\n-    if (type instanceof Class<?>) {\n-      return ((Class<?>) type).getComponentType();\n-    } else if (type instanceof GenericArrayType) {\n-      return ((GenericArrayType) type).getGenericComponentType();\n-    } else {\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * Implement reflective types using a dynamic proxy so we can compile on both Java 7 and Java 8,\n-   * even though {@link TypeVariable} gained new methods in Java 8 that won't compile on Java 7.\n-   */\n-  @SuppressWarnings(\"unchecked\")\n-  private static <T extends Type> T newType(\n-      final Class<T> type, final Map<String, Object> accessors, final int hashCode) {\n-    ClassLoader classLoader = Types.class.getClassLoader();\n-    Class[] classes = {type};\n-    return (T) Proxy.newProxyInstance(classLoader, classes, new InvocationHandler() {\n-      @Override public Object invoke(Object o, Method method, Object[] objects) throws Throwable {\n-        switch (method.getName()) {\n-          case \"equals\":\n-            Object other = objects[0];\n-            if (!type.isInstance(other)) return false;\n-            for (Map.Entry<String, Object> entry : accessors.entrySet()) {\n-              Object otherProperty = other.getClass().getMethod(entry.getKey()).invoke(other);\n-              if (!equal(otherProperty, entry.getValue())) return false;\n-            }\n-            return true;\n-\n-          case \"hashCode\":\n-            return hashCode;\n-\n-          case \"toString\":\n-            return typeToString((Type) o);\n-\n-          default:\n-            Object result = accessors.get(method.getName());\n-            if (result == null && !accessors.containsKey(method.getName())) {\n-              throw new UnsupportedOperationException(method.getName());\n-            }\n-            return result instanceof Object[] ? ((Object[]) result).clone() : result;\n-        }\n-      }\n-\n-      boolean equal(Object a, Object b) {\n-        if (a == null) return b == null;\n-        if (a instanceof Object[]) return Arrays.equals((Object[]) a, (Object[]) b);\n-        return a.equals(b);\n-      }\n-    });\n-  }\n-}\n"
    },
    {
        "commit_hash": "f1740bc5d33464f1263da9c8ef540a059a60ee03",
        "previous_commit_hash": "04746e06713df4190277b9a001b58cd4ee40ed8b",
        "diff_stats": {
            "additions": 102,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright (C) 2015 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javapoet;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.WildcardType;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.squareup.javapoet.Util.checkArgument;\n+\n+public final class WildcardTypeName extends TypeName {\n+  public final List<TypeName> upperBounds;\n+  public final List<TypeName> lowerBounds;\n+\n+  private WildcardTypeName(List<TypeName> upperBounds, List<TypeName> lowerBounds) {\n+    this.upperBounds = Util.immutableList(upperBounds);\n+    this.lowerBounds = Util.immutableList(lowerBounds);\n+\n+    checkArgument(this.upperBounds.size() == 1, \"unexpected extends bounds: %s\", upperBounds);\n+    for (TypeName upperBound : this.upperBounds) {\n+      checkArgument(!upperBound.isPrimitive() && upperBound != VOID,\n+          \"invalid upper bound: %s\", upperBound);\n+    }\n+    for (TypeName lowerBound : this.lowerBounds) {\n+      checkArgument(!lowerBound.isPrimitive() && lowerBound != VOID,\n+          \"invalid lower bound: %s\", lowerBound);\n+    }\n+  }\n+\n+  @Override public boolean equals(Object o) {\n+    return o instanceof WildcardTypeName\n+        && ((WildcardTypeName) o).upperBounds.equals(upperBounds)\n+        && ((WildcardTypeName) o).lowerBounds.equals(lowerBounds);\n+  }\n+\n+  @Override public int hashCode() {\n+    return upperBounds.hashCode() ^ lowerBounds.hashCode();\n+  }\n+\n+  @Override CodeWriter emit(CodeWriter out) throws IOException {\n+    if (lowerBounds.size() == 1) {\n+      return out.emit(\"? super $T\", lowerBounds.get(0));\n+    }\n+    return upperBounds.get(0).equals(TypeName.OBJECT)\n+        ? out.emit(\"?\")\n+        : out.emit(\"? extends $T\", upperBounds.get(0));\n+  }\n+\n+  /**\n+   * Returns a type that represents an unknown type that extends {@code bound}. For example, if\n+   * {@code bound} is {@code CharSequence.class}, this returns {@code ? extends CharSequence}. If\n+   * {@code bound} is {@code Object.class}, this returns {@code ?}, which is shorthand for {@code\n+   * ? extends Object}.\n+   */\n+  public static WildcardTypeName subtypeOf(TypeName upperBound) {\n+    return new WildcardTypeName(Arrays.asList(upperBound), Collections.<TypeName>emptyList());\n+  }\n+\n+  public static WildcardTypeName subtypeOf(Type upperBound) {\n+    return subtypeOf(TypeName.get(upperBound));\n+  }\n+\n+  /**\n+   * Returns a type that represents an unknown supertype of {@code bound}. For example, if {@code\n+   * bound} is {@code String.class}, this returns {@code ? super String}.\n+   */\n+  public static WildcardTypeName supertypeOf(TypeName lowerBound) {\n+    return new WildcardTypeName(Arrays.<TypeName>asList(OBJECT), Arrays.asList(lowerBound));\n+  }\n+\n+  public static WildcardTypeName supertypeOf(Type lowerBound) {\n+    return supertypeOf(TypeName.get(lowerBound));\n+  }\n+\n+  public static TypeName get(javax.lang.model.type.WildcardType mirror) {\n+    TypeName extendsBound = TypeName.get(mirror.getExtendsBound());\n+    TypeName superBound = TypeName.get(mirror.getSuperBound());\n+    return superBound != null ? supertypeOf(superBound) : subtypeOf(extendsBound);\n+  }\n+\n+  public static TypeName get(WildcardType wildcardName) {\n+    return new WildcardTypeName(\n+        list(wildcardName.getUpperBounds()),\n+        list(wildcardName.getLowerBounds()));\n+  }\n+}\n"
    },
    {
        "commit_hash": "f1740bc5d33464f1263da9c8ef540a059a60ee03",
        "previous_commit_hash": "04746e06713df4190277b9a001b58cd4ee40ed8b",
        "diff_stats": {
            "additions": 26,
            "deletions": 32
        },
        "diff_content": "@@ -17,9 +17,6 @@ package com.squareup.javapoet;\n \n import java.io.IOException;\n import java.io.Serializable;\n-import java.lang.reflect.ParameterizedType;\n-import java.lang.reflect.Type;\n-import java.lang.reflect.TypeVariable;\n import java.util.AbstractSet;\n import java.util.Collections;\n import java.util.Comparator;\n@@ -62,12 +59,12 @@ public final class TypeSpecTest {\n   }\n \n   @Test public void interestingTypes() throws Exception {\n-    ParameterizedType listOfAny = Types.parameterizedType(\n-        List.class, Types.subtypeOf(Object.class));\n-    ParameterizedType listOfExtends = Types.parameterizedType(\n-        List.class, Types.subtypeOf(Serializable.class));\n-    ParameterizedType listOfSuper = Types.parameterizedType(\n-        List.class, Types.supertypeOf(String.class));\n+    TypeName listOfAny = ParameterizedTypeName.get(\n+        ClassName.get(List.class), WildcardTypeName.subtypeOf(Object.class));\n+    TypeName listOfExtends = ParameterizedTypeName.get(\n+        ClassName.get(List.class), WildcardTypeName.subtypeOf(Serializable.class));\n+    TypeName listOfSuper = ParameterizedTypeName.get(ClassName.get(List.class),\n+        WildcardTypeName.supertypeOf(String.class));\n     TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n         .addField(listOfAny, \"extendsObject\")\n         .addField(listOfExtends, \"extendsSerializable\")\n@@ -93,15 +90,12 @@ public final class TypeSpecTest {\n     ClassName foo = ClassName.get(tacosPackage, \"Foo\");\n     ClassName bar = ClassName.get(tacosPackage, \"Bar\");\n     ClassName thingThang = ClassName.get(tacosPackage, \"Thing\", \"Thang\");\n-    ParameterizedType thingThangOfFooBar\n-        = Types.parameterizedType(thingThang, foo, bar);\n+    TypeName thingThangOfFooBar = ParameterizedTypeName.get(thingThang, foo, bar);\n     ClassName thung = ClassName.get(tacosPackage, \"Thung\");\n     ClassName simpleThung = ClassName.get(tacosPackage, \"SimpleThung\");\n-    ParameterizedType thungOfSuperBar\n-        = Types.parameterizedType(thung, Types.supertypeOf(bar));\n-    ParameterizedType thungOfSuperFoo\n-        = Types.parameterizedType(thung, Types.supertypeOf(foo));\n-    ParameterizedType simpleThungOfBar = Types.parameterizedType(simpleThung, bar);\n+    TypeName thungOfSuperBar = ParameterizedTypeName.get(thung, WildcardTypeName.supertypeOf(bar));\n+    TypeName thungOfSuperFoo = ParameterizedTypeName.get(thung, WildcardTypeName.supertypeOf(foo));\n+    TypeName simpleThungOfBar = ParameterizedTypeName.get(simpleThung, bar);\n \n     ParameterSpec thungParameter = ParameterSpec.builder(thungOfSuperFoo, \"thung\")\n         .addModifiers(Modifier.FINAL)\n@@ -210,12 +204,12 @@ public final class TypeSpecTest {\n             .addAnnotation(AnnotationSpec.builder(post)\n                 .addMember(\"value\", \"$S\", \"/foo/bar\")\n                 .build())\n-            .returns(Types.parameterizedType(observable, fooBar))\n-            .addParameter(ParameterSpec.builder(Types.parameterizedType(things, thing), \"things\")\n+            .returns(ParameterizedTypeName.get(observable, fooBar))\n+            .addParameter(ParameterSpec.builder(ParameterizedTypeName.get(things, thing), \"things\")\n                 .addAnnotation(body)\n                 .build())\n             .addParameter(ParameterSpec.builder(\n-                Types.parameterizedType(map, string, string), \"query\")\n+                ParameterizedTypeName.get(map, string, string), \"query\")\n                 .addAnnotation(AnnotationSpec.builder(queryMap)\n                     .addMember(\"encodeValues\", \"false\")\n                     .build())\n@@ -453,13 +447,13 @@ public final class TypeSpecTest {\n   }\n \n   @Test public void typeVariables() throws Exception {\n-    TypeVariable<?> t = Types.typeVariable(\"T\");\n-    TypeVariable<?> p = Types.typeVariable(\"P\", Number.class);\n+    TypeVariableName t = TypeVariableName.get(\"T\");\n+    TypeVariableName p = TypeVariableName.get(\"P\", Number.class);\n     ClassName location = ClassName.get(tacosPackage, \"Location\");\n     TypeSpec typeSpec = TypeSpec.classBuilder(\"Location\")\n         .addTypeVariable(t)\n         .addTypeVariable(p)\n-        .addSuperinterface(Types.parameterizedType(Comparable.class, p))\n+        .addSuperinterface(ParameterizedTypeName.get(ClassName.get(Comparable.class), p))\n         .addField(t, \"label\")\n         .addField(p, \"x\")\n         .addField(p, \"y\")\n@@ -474,7 +468,7 @@ public final class TypeSpecTest {\n             .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n             .addTypeVariable(t)\n             .addTypeVariable(p)\n-            .returns(Types.parameterizedType(location, t, p))\n+            .returns(ParameterizedTypeName.get(location, t, p))\n             .addParameter(t, \"label\")\n             .addParameter(p, \"x\")\n             .addParameter(p, \"y\")\n@@ -512,9 +506,9 @@ public final class TypeSpecTest {\n     ClassName food = ClassName.get(\"com.squareup.tacos\", \"Food\");\n     TypeSpec typeSpec = TypeSpec.classBuilder(\"Taco\")\n         .addModifiers(Modifier.ABSTRACT)\n-        .superclass(Types.parameterizedType(AbstractSet.class, food))\n+        .superclass(ParameterizedTypeName.get(ClassName.get(AbstractSet.class), food))\n         .addSuperinterface(Serializable.class)\n-        .addSuperinterface(Types.parameterizedType(Comparable.class, taco))\n+        .addSuperinterface(ParameterizedTypeName.get(ClassName.get(Comparable.class), taco))\n         .build();\n     assertThat(toString(typeSpec)).isEqualTo(\"\"\n         + \"package com.squareup.tacos;\\n\"\n@@ -552,7 +546,7 @@ public final class TypeSpecTest {\n     ClassName taco = ClassName.get(tacosPackage, \"Taco\");\n     TypeSpec typeSpec = TypeSpec.interfaceBuilder(\"Taco\")\n         .addSuperinterface(Serializable.class)\n-        .addSuperinterface(Types.parameterizedType(Comparable.class, taco))\n+        .addSuperinterface(ParameterizedTypeName.get(ClassName.get(Comparable.class), taco))\n         .build();\n     assertThat(toString(typeSpec)).isEqualTo(\"\"\n         + \"package com.squareup.tacos;\\n\"\n@@ -574,7 +568,7 @@ public final class TypeSpecTest {\n         .addField(chips, \"chips\")\n         .addType(TypeSpec.classBuilder(taco.simpleName())\n             .addModifiers(Modifier.STATIC)\n-            .addField(Types.parameterizedType(List.class, topping), \"toppings\")\n+            .addField(ParameterizedTypeName.get(ClassName.get(List.class), topping), \"toppings\")\n             .addField(sauce, \"sauce\")\n             .addType(TypeSpec.enumBuilder(topping.simpleName())\n                 .addEnumConstant(\"SHREDDED_CHEESE\")\n@@ -713,7 +707,7 @@ public final class TypeSpecTest {\n   }\n \n   @Test public void intersectionType() {\n-    TypeVariable<?> typeVariable = Types.typeVariable(\"T\", Comparator.class, Serializable.class);\n+    TypeVariableName typeVariable = TypeVariableName.get(\"T\", Comparator.class, Serializable.class);\n     TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n         .addMethod(MethodSpec.methodBuilder(\"getComparator\")\n             .addTypeVariable(typeVariable)\n@@ -856,8 +850,8 @@ public final class TypeSpecTest {\n     TypeSpec util = TypeSpec.classBuilder(\"Util\")\n         .addMethod(MethodSpec.methodBuilder(\"commonPrefixLength\")\n             .returns(int.class)\n-            .addParameter(Types.parameterizedType(List.class, String.class), \"listA\")\n-            .addParameter(Types.parameterizedType(List.class, String.class), \"listB\")\n+            .addParameter(ParameterizedTypeName.get(List.class, String.class), \"listA\")\n+            .addParameter(ParameterizedTypeName.get(List.class, String.class), \"listB\")\n             .addCode(methodBody)\n             .build())\n         .build();\n@@ -1236,8 +1230,8 @@ public final class TypeSpecTest {\n   }\n \n   @Test public void multilineStatementWithAnonymousClass() throws Exception {\n-    Type stringComparator = Types.parameterizedType(Comparator.class, String.class);\n-    Type listOfString = Types.parameterizedType(List.class, String.class);\n+    TypeName stringComparator = ParameterizedTypeName.get(Comparator.class, String.class);\n+    TypeName listOfString = ParameterizedTypeName.get(List.class, String.class);\n     TypeSpec prefixComparator = TypeSpec.anonymousClassBuilder(\"\")\n         .addSuperinterface(stringComparator)\n         .addMethod(MethodSpec.methodBuilder(\"compare\")\n"
    },
    {
        "commit_hash": "f1740bc5d33464f1263da9c8ef540a059a60ee03",
        "previous_commit_hash": "04746e06713df4190277b9a001b58cd4ee40ed8b",
        "diff_stats": {
            "additions": 52,
            "deletions": 52
        },
        "diff_content": "@@ -17,10 +17,6 @@ package com.squareup.javapoet;\n \n import com.google.testing.compile.CompilationRule;\n import java.io.Serializable;\n-import java.lang.reflect.GenericArrayType;\n-import java.lang.reflect.ParameterizedType;\n-import java.lang.reflect.TypeVariable;\n-import java.lang.reflect.WildcardType;\n import java.nio.charset.Charset;\n import java.util.List;\n import java.util.Map;\n@@ -34,6 +30,7 @@ import org.junit.Rule;\n import org.junit.Test;\n \n import static com.google.common.truth.Truth.assertThat;\n+import static org.junit.Assert.fail;\n \n public final class TypesTest {\n   @Rule public final CompilationRule compilation = new CompilationRule();\n@@ -42,24 +39,24 @@ public final class TypesTest {\n     return compilation.getElements().getTypeElement(clazz.getCanonicalName());\n   }\n \n-  private TypeMirror getType(Class<?> clazz) {\n+  private TypeMirror getMirror(Class<?> clazz) {\n     return getElement(clazz).asType();\n   }\n \n   @Test public void getBasicTypeMirror() {\n-    assertThat(Types.get(getType(Object.class)))\n+    assertThat(TypeName.get(getMirror(Object.class)))\n         .isEqualTo(ClassName.get(Object.class));\n-    assertThat(Types.get(getType(Charset.class)))\n+    assertThat(TypeName.get(getMirror(Charset.class)))\n         .isEqualTo(ClassName.get(Charset.class));\n-    assertThat(Types.get(getType(TypesTest.class)))\n+    assertThat(TypeName.get(getMirror(TypesTest.class)))\n         .isEqualTo(ClassName.get(TypesTest.class));\n   }\n \n   @Test public void getParameterizedTypeMirror() {\n     DeclaredType setType =\n-        compilation.getTypes().getDeclaredType(getElement(Set.class), getType(Object.class));\n-    assertThat(Types.get(setType))\n-        .isEqualTo(Types.parameterizedType(ClassName.get(Set.class), ClassName.OBJECT));\n+        compilation.getTypes().getDeclaredType(getElement(Set.class), getMirror(Object.class));\n+    assertThat(TypeName.get(setType))\n+        .isEqualTo(ParameterizedTypeName.get(ClassName.get(Set.class), ClassName.OBJECT));\n   }\n \n   static class Parameterized<\n@@ -79,83 +76,86 @@ public final class TypesTest {\n     ClassName runnable = ClassName.get(Runnable.class);\n     ClassName serializable = ClassName.get(Serializable.class);\n \n-    assertThat(Types.get(typeVariables.get(0).asType()))\n-        .isEqualTo(Types.typeVariable(\"Simple\"));\n-    assertThat(Types.get(typeVariables.get(1).asType()))\n-        .isEqualTo(Types.typeVariable(\"ExtendsClass\", number));\n-    assertThat(Types.get(typeVariables.get(2).asType()))\n-        .isEqualTo(Types.typeVariable(\"ExtendsInterface\", runnable));\n-    assertThat(Types.get(typeVariables.get(3).asType()))\n-        .isEqualTo(Types.typeVariable(\"ExtendsTypeVariable\", Types.typeVariable(\"Simple\")));\n-    assertThat(Types.get(typeVariables.get(4).asType()))\n-        .isEqualTo(Types.typeVariable(\"Intersection\", number, runnable));\n-    assertThat(Types.get(typeVariables.get(5).asType()))\n-        .isEqualTo(Types.typeVariable(\"IntersectionOfInterfaces\", runnable, serializable));\n-    assertThat(((TypeVariable) Types.get(typeVariables.get(4).asType())).getBounds()).asList()\n+    assertThat(TypeName.get(typeVariables.get(0).asType()))\n+        .isEqualTo(TypeVariableName.get(\"Simple\"));\n+    assertThat(TypeName.get(typeVariables.get(1).asType()))\n+        .isEqualTo(TypeVariableName.get(\"ExtendsClass\", number));\n+    assertThat(TypeName.get(typeVariables.get(2).asType()))\n+        .isEqualTo(TypeVariableName.get(\"ExtendsInterface\", runnable));\n+    assertThat(TypeName.get(typeVariables.get(3).asType()))\n+        .isEqualTo(TypeVariableName.get(\"ExtendsTypeVariable\", TypeVariableName.get(\"Simple\")));\n+    assertThat(TypeName.get(typeVariables.get(4).asType()))\n+        .isEqualTo(TypeVariableName.get(\"Intersection\", number, runnable));\n+    assertThat(TypeName.get(typeVariables.get(5).asType()))\n+        .isEqualTo(TypeVariableName.get(\"IntersectionOfInterfaces\", runnable, serializable));\n+    assertThat(((TypeVariableName) TypeName.get(typeVariables.get(4).asType())).bounds)\n         .containsExactly(number, runnable);\n   }\n \n   @Test public void getPrimitiveTypeMirror() {\n-    assertThat(Types.get(compilation.getTypes().getPrimitiveType(TypeKind.BOOLEAN)))\n-        .isEqualTo(boolean.class);\n-    assertThat(Types.get(compilation.getTypes().getPrimitiveType(TypeKind.BYTE)))\n-        .isEqualTo(byte.class);\n-    assertThat(Types.get(compilation.getTypes().getPrimitiveType(TypeKind.SHORT)))\n-        .isEqualTo(short.class);\n-    assertThat(Types.get(compilation.getTypes().getPrimitiveType(TypeKind.INT)))\n-        .isEqualTo(int.class);\n-    assertThat(Types.get(compilation.getTypes().getPrimitiveType(TypeKind.LONG)))\n-        .isEqualTo(long.class);\n-    assertThat(Types.get(compilation.getTypes().getPrimitiveType(TypeKind.CHAR)))\n-        .isEqualTo(char.class);\n-    assertThat(Types.get(compilation.getTypes().getPrimitiveType(TypeKind.FLOAT)))\n-        .isEqualTo(float.class);\n-    assertThat(Types.get(compilation.getTypes().getPrimitiveType(TypeKind.DOUBLE)))\n-        .isEqualTo(double.class);\n+    assertThat(TypeName.get(compilation.getTypes().getPrimitiveType(TypeKind.BOOLEAN)))\n+        .isEqualTo(TypeName.BOOLEAN);\n+    assertThat(TypeName.get(compilation.getTypes().getPrimitiveType(TypeKind.BYTE)))\n+        .isEqualTo(TypeName.BYTE);\n+    assertThat(TypeName.get(compilation.getTypes().getPrimitiveType(TypeKind.SHORT)))\n+        .isEqualTo(TypeName.SHORT);\n+    assertThat(TypeName.get(compilation.getTypes().getPrimitiveType(TypeKind.INT)))\n+        .isEqualTo(TypeName.INT);\n+    assertThat(TypeName.get(compilation.getTypes().getPrimitiveType(TypeKind.LONG)))\n+        .isEqualTo(TypeName.LONG);\n+    assertThat(TypeName.get(compilation.getTypes().getPrimitiveType(TypeKind.CHAR)))\n+        .isEqualTo(TypeName.CHAR);\n+    assertThat(TypeName.get(compilation.getTypes().getPrimitiveType(TypeKind.FLOAT)))\n+        .isEqualTo(TypeName.FLOAT);\n+    assertThat(TypeName.get(compilation.getTypes().getPrimitiveType(TypeKind.DOUBLE)))\n+        .isEqualTo(TypeName.DOUBLE);\n   }\n \n   @Test public void getArrayTypeMirror() {\n-    assertThat(Types.get(compilation.getTypes().getArrayType(getType(Object.class))))\n-        .isEqualTo(Types.arrayOf(ClassName.OBJECT));\n+    assertThat(TypeName.get(compilation.getTypes().getArrayType(getMirror(Object.class))))\n+        .isEqualTo(ArrayTypeName.of(ClassName.OBJECT));\n   }\n \n   @Test public void getVoidTypeMirror() {\n-    assertThat(Types.get(compilation.getTypes().getNoType(TypeKind.VOID)))\n-        .isEqualTo(void.class);\n+    assertThat(TypeName.get(compilation.getTypes().getNoType(TypeKind.VOID)))\n+        .isEqualTo(TypeName.VOID);\n   }\n \n   @Test public void getNullTypeMirror() {\n-    assertThat(Types.get(compilation.getTypes().getNullType()))\n-        .isEqualTo(Types.NULL);\n+    try {\n+      TypeName.get(compilation.getTypes().getNullType());\n+      fail();\n+    } catch (IllegalArgumentException expected) {\n+    }\n   }\n \n   @Test public void parameterizedType() throws Exception {\n-    ParameterizedType type = Types.parameterizedType(Map.class, String.class, Long.class);\n+    ParameterizedTypeName type = ParameterizedTypeName.get(Map.class, String.class, Long.class);\n     assertThat(type.toString()).isEqualTo(\"java.util.Map<java.lang.String, java.lang.Long>\");\n   }\n \n   @Test public void arrayType() throws Exception {\n-    GenericArrayType type = Types.arrayOf(String.class);\n+    ArrayTypeName type = ArrayTypeName.of(String.class);\n     assertThat(type.toString()).isEqualTo(\"java.lang.String[]\");\n   }\n \n   @Test public void wildcardExtendsType() throws Exception {\n-    WildcardType type = Types.subtypeOf(CharSequence.class);\n+    WildcardTypeName type = WildcardTypeName.subtypeOf(CharSequence.class);\n     assertThat(type.toString()).isEqualTo(\"? extends java.lang.CharSequence\");\n   }\n \n   @Test public void wildcardExtendsObject() throws Exception {\n-    WildcardType type = Types.subtypeOf(Object.class);\n+    WildcardTypeName type = WildcardTypeName.subtypeOf(Object.class);\n     assertThat(type.toString()).isEqualTo(\"?\");\n   }\n \n   @Test public void wildcardSuperType() throws Exception {\n-    WildcardType type = Types.supertypeOf(String.class);\n+    WildcardTypeName type = WildcardTypeName.supertypeOf(String.class);\n     assertThat(type.toString()).isEqualTo(\"? super java.lang.String\");\n   }\n \n   @Test public void typeVariable() throws Exception {\n-    TypeVariable<?> type = Types.typeVariable(\"T\", CharSequence.class);\n+    TypeVariableName type = TypeVariableName.get(\"T\", CharSequence.class);\n     assertThat(type.toString()).isEqualTo(\"T\"); // (Bounds are only emitted in declaration.)\n   }\n }\n"
    },
    {
        "commit_hash": "7571d752fbab686d83d51328edf92095595d2f83",
        "previous_commit_hash": "7896b1896dae8251b710373703d94cec3f7c4228",
        "diff_stats": {
            "additions": 62,
            "deletions": 6
        },
        "diff_content": "@@ -15,11 +15,21 @@\n  */\n package com.squareup.javapoet;\n \n+import java.io.File;\n import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.io.Writer;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n import java.util.Collections;\n+import java.util.List;\n import java.util.Map;\n+import javax.annotation.processing.Filer;\n+import javax.lang.model.element.Element;\n import javax.lang.model.element.Modifier;\n+import javax.tools.JavaFileObject;\n \n+import static com.squareup.javapoet.Util.checkArgument;\n import static com.squareup.javapoet.Util.checkNotNull;\n \n /** A Java file containing a single top level class. */\n@@ -40,19 +50,17 @@ public final class JavaFile {\n   public final String packageName;\n   public final TypeSpec typeSpec;\n   public final boolean skipJavaLangImports;\n+  private final String indent;\n \n   private JavaFile(Builder builder) {\n     this.fileComment = builder.fileComment.build();\n     this.packageName = builder.packageName;\n     this.typeSpec = builder.typeSpec;\n     this.skipJavaLangImports = builder.skipJavaLangImports;\n+    this.indent = builder.indent;\n   }\n \n-  public void emit(Appendable out) throws IOException {\n-    emit(out, \"  \");\n-  }\n-\n-  public void emit(Appendable out, String indent) throws IOException {\n+  public void writeTo(Appendable out) throws IOException {\n     // First pass: emit the entire class, just to collect the types we'll need to import.\n     CodeWriter importsCollector = new CodeWriter(NULL_APPENDABLE, indent);\n     emit(importsCollector);\n@@ -63,6 +71,48 @@ public final class JavaFile {\n     emit(codeWriter);\n   }\n \n+  /** Writes this to {@code directory} the standard directory structure. */\n+  public void writeTo(Path directory) throws IOException {\n+    checkArgument(Files.notExists(directory) || Files.isDirectory(directory),\n+        \"path %s exists but is not a directory.\", directory);\n+    Path outputDirectory = directory;\n+    if (!packageName.isEmpty()) {\n+      for (String packageComponent : packageName.split(\"\\\\.\")) {\n+        outputDirectory = outputDirectory.resolve(packageComponent);\n+      }\n+      Files.createDirectories(outputDirectory);\n+    }\n+\n+    Path outputPath = outputDirectory.resolve(typeSpec.name + \".java\");\n+    try (Writer writer = new OutputStreamWriter(Files.newOutputStream(outputPath))) {\n+      writeTo(writer);\n+    }\n+  }\n+\n+  /** Writes this to {@code directory} the standard directory structure. */\n+  public void writeTo(File directory) throws IOException {\n+    writeTo(directory.toPath());\n+  }\n+\n+  /** Writes this to {@code filer}. */\n+  public void writeTo(Filer filer) throws IOException {\n+    String fileName = packageName.isEmpty()\n+        ? typeSpec.name\n+        : packageName + \".\" + typeSpec.name;\n+    List<Element> originatingElements = typeSpec.originatingElements;\n+    JavaFileObject filerSourceFile = filer.createSourceFile(fileName,\n+        originatingElements.toArray(new Element[originatingElements.size()]));\n+    try (Writer writer = filerSourceFile.openWriter()) {\n+      writeTo(writer);\n+    } catch (Exception e) {\n+      try {\n+        filerSourceFile.delete();\n+      } catch (Exception ignored) {\n+      }\n+      throw e;\n+    }\n+  }\n+\n   private void emit(CodeWriter codeWriter) throws IOException {\n     codeWriter.pushPackage(packageName);\n \n@@ -94,7 +144,7 @@ public final class JavaFile {\n   public String toString() {\n     try {\n       StringBuilder result = new StringBuilder();\n-      emit(result, \"  \");\n+      writeTo(result);\n       return result.toString();\n     } catch (IOException e) {\n       throw new AssertionError();\n@@ -112,6 +162,7 @@ public final class JavaFile {\n     private final TypeSpec typeSpec;\n     private CodeBlock.Builder fileComment = CodeBlock.builder();\n     private boolean skipJavaLangImports;\n+    private String indent = \"  \";\n \n     private Builder(String packageName, TypeSpec typeSpec) {\n       this.packageName = packageName;\n@@ -136,6 +187,11 @@ public final class JavaFile {\n       return this;\n     }\n \n+    public Builder indent(String indent) {\n+      this.indent = indent;\n+      return this;\n+    }\n+\n     public JavaFile build() {\n       return new JavaFile(this);\n     }\n"
    },
    {
        "commit_hash": "7571d752fbab686d83d51328edf92095595d2f83",
        "previous_commit_hash": "7896b1896dae8251b710373703d94cec3f7c4228",
        "diff_stats": {
            "additions": 0,
            "deletions": 96
        },
        "diff_content": "@@ -1,96 +0,0 @@\n-/*\n- * Copyright (C) 2014 Google, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.squareup.javapoet;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.io.OutputStreamWriter;\n-import java.io.Writer;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.ArrayList;\n-import java.util.List;\n-import javax.annotation.processing.Filer;\n-import javax.lang.model.element.Element;\n-import javax.tools.JavaFileObject;\n-\n-import static com.squareup.javapoet.Util.checkArgument;\n-\n-/** Writes generated types to a filesystem using the standard directory structure. */\n-// TODO(jwilson): fold this into JavaFile.\n-public final class JavaPoet {\n-  private final List<JavaFile> javaFiles = new ArrayList<>();\n-  private String indent = \"  \";\n-\n-  public JavaPoet setIndent(String indent) {\n-    this.indent = indent;\n-    return this;\n-  }\n-\n-  public JavaPoet add(JavaFile javaFile) {\n-    javaFiles.add(javaFile);\n-    return this;\n-  }\n-\n-  public JavaPoet add(String packageName, TypeSpec type) {\n-    return add(JavaFile.builder(packageName, type).build());\n-  }\n-\n-  public void writeTo(Path directory) throws IOException {\n-    checkArgument(Files.notExists(directory) || Files.isDirectory(directory),\n-        \"path %s exists but is not a directory.\", directory);\n-    for (JavaFile javaFile : javaFiles) {\n-      String packageName = javaFile.packageName;\n-\n-      Path outputDirectory = directory;\n-      if (!packageName.isEmpty()) {\n-        for (String packageComponent : packageName.split(\"\\\\.\")) {\n-          outputDirectory = outputDirectory.resolve(packageComponent);\n-        }\n-        Files.createDirectories(outputDirectory);\n-      }\n-\n-      Path outputPath = outputDirectory.resolve(javaFile.typeSpec.name + \".java\");\n-      try (Writer writer = new OutputStreamWriter(Files.newOutputStream(outputPath))) {\n-        javaFile.emit(writer, indent);\n-      }\n-    }\n-  }\n-\n-  public void writeTo(File directory) throws IOException {\n-    writeTo(directory.toPath());\n-  }\n-\n-  public void writeTo(Filer filer) throws IOException {\n-    for (JavaFile javaFile : javaFiles) {\n-      String fileName = javaFile.packageName.isEmpty()\n-          ? javaFile.typeSpec.name\n-          : javaFile.packageName + \".\" + javaFile.typeSpec.name;\n-      List<Element> originatingElements = javaFile.typeSpec.originatingElements;\n-      JavaFileObject filerSourceFile = filer.createSourceFile(fileName,\n-          originatingElements.toArray(new Element[originatingElements.size()]));\n-      try (Writer writer = filerSourceFile.openWriter()) {\n-        javaFile.emit(writer, indent);\n-      } catch (Exception e) {\n-        try {\n-          filerSourceFile.delete();\n-        } catch (Exception ignored) {\n-        }\n-        throw e;\n-      }\n-    }\n-  }\n-}\n"
    },
    {
        "commit_hash": "7571d752fbab686d83d51328edf92095595d2f83",
        "previous_commit_hash": "7896b1896dae8251b710373703d94cec3f7c4228",
        "diff_stats": {
            "additions": 25,
            "deletions": 59
        },
        "diff_content": "@@ -32,9 +32,7 @@ import org.mockito.Mockito;\n import static com.google.common.truth.Truth.assertThat;\n import static org.junit.Assert.fail;\n \n-public final class JavaPoetTest {\n-  private final JavaPoet javaPoet = new JavaPoet();\n-\n+public final class FileWritingTest {\n   // Used for testing java.io File behavior.\n   @Rule public final TemporaryFolder tmp = new TemporaryFolder();\n \n@@ -46,11 +44,13 @@ public final class JavaPoetTest {\n   private final TestFiler filer = new TestFiler(fs, fsRoot);\n \n   @Test public void pathNotDirectory() throws IOException {\n+    TypeSpec type = TypeSpec.classBuilder(\"Test\").build();\n+    JavaFile javaFile = JavaFile.builder(\"example\", type).build();\n     Path path = fs.getPath(\"/foo/bar\");\n     Files.createDirectories(path.getParent());\n     Files.createFile(path);\n     try {\n-      javaPoet.writeTo(path);\n+      javaFile.writeTo(path);\n       fail();\n     } catch (IllegalArgumentException e) {\n       assertThat(e.getMessage()).isEqualTo(\"path /foo/bar exists but is not a directory.\");\n@@ -58,10 +58,12 @@ public final class JavaPoetTest {\n   }\n \n   @Test public void fileNotDirectory() throws IOException {\n+    TypeSpec type = TypeSpec.classBuilder(\"Test\").build();\n+    JavaFile javaFile = JavaFile.builder(\"example\", type).build();\n     File file = new File(tmp.newFolder(\"foo\"), \"bar\");\n     file.createNewFile();\n     try {\n-      javaPoet.writeTo(file);\n+      javaFile.writeTo(file);\n       fail();\n     } catch (IllegalArgumentException e) {\n       assertThat(e.getMessage()).containsMatch(\"path .*?/foo/bar exists but is not a directory.\");\n@@ -70,7 +72,7 @@ public final class JavaPoetTest {\n \n   @Test public void pathDefaultPackage() throws IOException {\n     TypeSpec type = TypeSpec.classBuilder(\"Test\").build();\n-    javaPoet.add(\"\", type).writeTo(fsRoot);\n+    JavaFile.builder(\"\", type).build().writeTo(fsRoot);\n \n     Path testPath = fsRoot.resolve(\"Test.java\");\n     assertThat(Files.exists(testPath)).isTrue();\n@@ -78,7 +80,7 @@ public final class JavaPoetTest {\n \n   @Test public void fileDefaultPackage() throws IOException {\n     TypeSpec type = TypeSpec.classBuilder(\"Test\").build();\n-    javaPoet.add(\"\", type).writeTo(tmp.getRoot());\n+    JavaFile.builder(\"\", type).build().writeTo(tmp.getRoot());\n \n     File testFile = new File(tmp.getRoot(), \"Test.java\");\n     assertThat(testFile.exists()).isTrue();\n@@ -86,52 +88,17 @@ public final class JavaPoetTest {\n \n   @Test public void filerDefaultPackage() throws IOException {\n     TypeSpec type = TypeSpec.classBuilder(\"Test\").build();\n-    javaPoet.add(\"\", type).writeTo(filer);\n+    JavaFile.builder(\"\", type).build().writeTo(filer);\n \n     Path testPath = fsRoot.resolve(\"Test.java\");\n     assertThat(Files.exists(testPath)).isTrue();\n   }\n \n-  @Test public void pathSamePackage() throws IOException {\n-    TypeSpec test1 = TypeSpec.classBuilder(\"Test1\").build();\n-    TypeSpec test2 = TypeSpec.classBuilder(\"Test2\").build();\n-    javaPoet.add(\"example\", test1).add(\"example\", test2).writeTo(fsRoot);\n-\n-    Path testPath1 = fsRoot.resolve(fs.getPath(\"example\", \"Test1.java\"));\n-    assertThat(Files.exists(testPath1)).isTrue();\n-    Path testPath2 = fsRoot.resolve(fs.getPath(\"example\", \"Test2.java\"));\n-    assertThat(Files.exists(testPath2)).isTrue();\n-  }\n-\n-  @Test public void fileSamePackage() throws IOException {\n-    TypeSpec test1 = TypeSpec.classBuilder(\"Test1\").build();\n-    TypeSpec test2 = TypeSpec.classBuilder(\"Test2\").build();\n-    javaPoet.add(\"example\", test1).add(\"example\", test2).writeTo(tmp.getRoot());\n-\n-    File examplePackage = new File(tmp.getRoot(), \"example\");\n-    File testFile1 = new File(examplePackage, \"Test1.java\");\n-    assertThat(testFile1.exists()).isTrue();\n-    File testFile2 = new File(examplePackage, \"Test2.java\");\n-    assertThat(testFile2.exists()).isTrue();\n-  }\n-\n-  @Test public void filerSamePackage() throws IOException {\n-    TypeSpec test1 = TypeSpec.classBuilder(\"Test1\").build();\n-    TypeSpec test2 = TypeSpec.classBuilder(\"Test2\").build();\n-    javaPoet.add(\"example\", test1).add(\"example\", test2).writeTo(filer);\n-\n-    Path testPath1 = fsRoot.resolve(fs.getPath(\"example\", \"Test1.java\"));\n-    assertThat(Files.exists(testPath1)).isTrue();\n-    Path testPath2 = fsRoot.resolve(fs.getPath(\"example\", \"Test2.java\"));\n-    assertThat(Files.exists(testPath2)).isTrue();\n-  }\n-\n   @Test public void pathNestedClasses() throws IOException {\n-    TypeSpec test = TypeSpec.classBuilder(\"Test\").build();\n-    javaPoet.add(\"foo\", test)\n-        .add(\"foo.bar\", test)\n-        .add(\"foo.bar.baz\", test)\n-        .writeTo(fsRoot);\n+    TypeSpec type = TypeSpec.classBuilder(\"Test\").build();\n+    JavaFile.builder(\"foo\", type).build().writeTo(fsRoot);\n+    JavaFile.builder(\"foo.bar\", type).build().writeTo(fsRoot);\n+    JavaFile.builder(\"foo.bar.baz\", type).build().writeTo(fsRoot);\n \n     Path fooPath = fsRoot.resolve(fs.getPath(\"foo\", \"Test.java\"));\n     Path barPath = fsRoot.resolve(fs.getPath(\"foo\", \"bar\", \"Test.java\"));\n@@ -142,11 +109,10 @@ public final class JavaPoetTest {\n   }\n \n   @Test public void fileNestedClasses() throws IOException {\n-    TypeSpec test = TypeSpec.classBuilder(\"Test\").build();\n-    javaPoet.add(\"foo\", test)\n-        .add(\"foo.bar\", test)\n-        .add(\"foo.bar.baz\", test)\n-        .writeTo(tmp.getRoot());\n+    TypeSpec type = TypeSpec.classBuilder(\"Test\").build();\n+    JavaFile.builder(\"foo\", type).build().writeTo(tmp.getRoot());\n+    JavaFile.builder(\"foo.bar\", type).build().writeTo(tmp.getRoot());\n+    JavaFile.builder(\"foo.bar.baz\", type).build().writeTo(tmp.getRoot());\n \n     File fooDir = new File(tmp.getRoot(), \"foo\");\n     File fooFile = new File(fooDir, \"Test.java\");\n@@ -160,11 +126,10 @@ public final class JavaPoetTest {\n   }\n \n   @Test public void filerNestedClasses() throws IOException {\n-    TypeSpec test = TypeSpec.classBuilder(\"Test\").build();\n-    javaPoet.add(\"foo\", test)\n-        .add(\"foo.bar\", test)\n-        .add(\"foo.bar.baz\", test)\n-        .writeTo(filer);\n+    TypeSpec type = TypeSpec.classBuilder(\"Test\").build();\n+    JavaFile.builder(\"foo\", type).build().writeTo(filer);\n+    JavaFile.builder(\"foo.bar\", type).build().writeTo(filer);\n+    JavaFile.builder(\"foo.bar.baz\", type).build().writeTo(filer);\n \n     Path fooPath = fsRoot.resolve(fs.getPath(\"foo\", \"Test.java\"));\n     Path barPath = fsRoot.resolve(fs.getPath(\"foo\", \"bar\", \"Test.java\"));\n@@ -187,7 +152,8 @@ public final class JavaPoetTest {\n         .addOriginatingElement(element2_2)\n         .build();\n \n-    javaPoet.add(\"example\", test1).add(\"example\", test2).writeTo(filer);\n+    JavaFile.builder(\"example\", test1).build().writeTo(filer);\n+    JavaFile.builder(\"example\", test2).build().writeTo(filer);\n \n     Path testPath1 = fsRoot.resolve(fs.getPath(\"example\", \"Test1.java\"));\n     assertThat(filer.getOriginatingElements(testPath1)).containsExactly(element1_1);\n@@ -204,7 +170,7 @@ public final class JavaPoetTest {\n             .addCode(\"$T.out.println($S);\\n\", System.class, \"Hello World!\")\n             .build())\n         .build();\n-    javaPoet.add(\"foo\", test).setIndent(\"\\t\").writeTo(filer);\n+    JavaFile.builder(\"foo\", test).indent(\"\\t\").build().writeTo(filer);\n \n     Path fooPath = fsRoot.resolve(fs.getPath(\"foo\", \"Test.java\"));\n     assertThat(Files.exists(fooPath)).isTrue();\n"
    },
    {
        "commit_hash": "a82dc1e560459ce466f922ab2056218b76a6804a",
        "previous_commit_hash": "2bbcf96c5caa558bc5471eee5a2146ac8f2547c3",
        "diff_stats": {
            "additions": 7,
            "deletions": 6
        },
        "diff_content": "@@ -1,14 +1,15 @@\n Change Log\n ==========\n \n-JavaPoet 1.0.0 *(unreleased)*\n+JavaPoet 1.0.0 *(2015-01-28)*\n ----------------------------\n \n- * Project name is now `javapoet`. We renamed the project so you could simultaneously\n-   use the old JavaWriter API and our new builder-based APIs in one project.\n- * Package name is now `com.squareup.javapoet`.\n- * Builders.\n- * Automatic imports.\n+ * This update is a complete rewrite. The project name is now `javapoet`. We renamed the it so you\n+   can simultaneously use the old JavaWriter API and our new builder-based APIs in one project.\n+ * Immutable value objects and builders. Instead of streaming the `.java` file from top to bottom,\n+   you now define members in whatever way is convenient.\n+ * We now use our own models for type names.\n+ * Imports are now added automatically.\n \n \n JavaWriter 2.5.1 *(2014-12-03)*\n"
    },
    {
        "commit_hash": "5aaa1128daab347808caacb0045333874214aa31",
        "previous_commit_hash": "a82dc1e560459ce466f922ab2056218b76a6804a",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.0.0-SNAPSHOT</version>\n+  <version>1.0.0</version>\n \n   <name>JavaPoet</name>\n   <description>Use beautiful Java code to generate beautiful Java code.</description>\n@@ -54,13 +54,13 @@\n     <dependency>\n       <groupId>com.google.truth</groupId>\n       <artifactId>truth</artifactId>\n-      <version>${truth.version}</version>\n+      <version>0.25</version>\n       <scope>test</scope>\n     </dependency>\n     <dependency>\n       <groupId>com.google.testing.compile</groupId>\n       <artifactId>compile-testing</artifactId>\n-      <version>${compile-testing.version}</version>\n+      <version>0.6</version>\n       <scope>test</scope>\n     </dependency>\n     <dependency>\n"
    },
    {
        "commit_hash": "23be296fba9230c81635f58b4f723440a4e49832",
        "previous_commit_hash": "5aaa1128daab347808caacb0045333874214aa31",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.0.0</version>\n+  <version>1.1.0-SNAPSHOT</version>\n \n   <name>JavaPoet</name>\n   <description>Use beautiful Java code to generate beautiful Java code.</description>\n@@ -54,13 +54,13 @@\n     <dependency>\n       <groupId>com.google.truth</groupId>\n       <artifactId>truth</artifactId>\n-      <version>0.25</version>\n+      <version>1.0-SNAPSHOT</version>\n       <scope>test</scope>\n     </dependency>\n     <dependency>\n       <groupId>com.google.testing.compile</groupId>\n       <artifactId>compile-testing</artifactId>\n-      <version>0.6</version>\n+      <version>1.0-SNAPSHOT</version>\n       <scope>test</scope>\n     </dependency>\n     <dependency>\n"
    },
    {
        "commit_hash": "14eb7c6dd746621463eaca0fe87ac1585f330dce",
        "previous_commit_hash": "23be296fba9230c81635f58b4f723440a4e49832",
        "diff_stats": {
            "additions": 15,
            "deletions": 6
        },
        "diff_content": "@@ -15,6 +15,10 @@\n  */\n package com.squareup.javapoet;\n \n+import static com.squareup.javapoet.Util.checkArgument;\n+import static com.squareup.javapoet.Util.checkNotNull;\n+import static com.squareup.javapoet.Util.checkState;\n+\n import java.io.IOException;\n import java.io.StringWriter;\n import java.lang.reflect.Type;\n@@ -22,12 +26,10 @@ import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n import java.util.Set;\n+\n import javax.lang.model.SourceVersion;\n import javax.lang.model.element.Modifier;\n \n-import static com.squareup.javapoet.Util.checkArgument;\n-import static com.squareup.javapoet.Util.checkNotNull;\n-\n /** A generated field declaration. */\n public final class FieldSpec {\n   public final TypeName type;\n@@ -43,7 +45,9 @@ public final class FieldSpec {\n     this.javadoc = builder.javadoc.build();\n     this.annotations = Util.immutableList(builder.annotations);\n     this.modifiers = Util.immutableSet(builder.modifiers);\n-    this.initializer = builder.initializer.build();\n+    this.initializer = (builder.initializer == null)\n+        ? CodeBlock.builder().build()\n+        : builder.initializer;\n   }\n \n   public boolean hasModifier(Modifier modifier) {\n@@ -91,7 +95,7 @@ public final class FieldSpec {\n     private final CodeBlock.Builder javadoc = CodeBlock.builder();\n     private final List<AnnotationSpec> annotations = new ArrayList<>();\n     private final List<Modifier> modifiers = new ArrayList<>();\n-    private CodeBlock.Builder initializer = CodeBlock.builder();\n+    private CodeBlock initializer = null;\n \n     private Builder(TypeName type, String name) {\n       this.type = type;\n@@ -123,7 +127,12 @@ public final class FieldSpec {\n     }\n \n     public Builder initializer(String format, Object... args) {\n-      this.initializer.add(format, args);\n+      return initializer(CodeBlock.builder().add(format, args).build());\n+    }\n+\n+    public Builder initializer(CodeBlock codeBlock) {\n+      checkState(this.initializer == null, \"initializer was already set\");\n+      this.initializer = checkNotNull(codeBlock, \"codeBlock == null\");\n       return this;\n     }\n \n"
    },
    {
        "commit_hash": "14eb7c6dd746621463eaca0fe87ac1585f330dce",
        "previous_commit_hash": "23be296fba9230c81635f58b4f723440a4e49832",
        "diff_stats": {
            "additions": 47,
            "deletions": 0
        },
        "diff_content": "@@ -22,12 +22,15 @@ import java.util.Collections;\n import java.util.Comparator;\n import java.util.List;\n import java.util.Locale;\n+import java.util.Map;\n import java.util.Random;\n import javax.lang.model.element.Element;\n import javax.lang.model.element.Modifier;\n import org.junit.Test;\n import org.mockito.Mockito;\n \n+import com.google.common.collect.ImmutableMap;\n+\n import static com.google.common.truth.Truth.assertThat;\n import static org.junit.Assert.fail;\n \n@@ -847,7 +850,23 @@ public final class TypeSpecTest {\n         .endControlFlow()\n         .addStatement(\"return size\")\n         .build();\n+    CodeBlock fieldBlock = CodeBlock.builder()\n+        .add(\"$>$>\")\n+        .add(\"\\n$T.<$T, $T>builder()$>$>\", ImmutableMap.class, String.class, String.class)\n+        .add(\"\\n.add($S, $S)\", '\\'', \"&#39;\")\n+        .add(\"\\n.add($S, $S)\", '&', \"&amp;\")\n+        .add(\"\\n.add($S, $S)\", '<', \"&lt;\")\n+        .add(\"\\n.add($S, $S)\", '>', \"&gt;\")\n+        .add(\"\\n.build()$<$<\")\n+        .add(\"$<$<\")\n+        .build();\n+    FieldSpec escapeHtml = FieldSpec.builder(ParameterizedTypeName.get(\n+        Map.class, String.class, String.class), \"ESCAPE_HTML\")\n+        .addModifiers(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)\n+        .initializer(fieldBlock)\n+        .build();\n     TypeSpec util = TypeSpec.classBuilder(\"Util\")\n+        .addField(escapeHtml)\n         .addMethod(MethodSpec.methodBuilder(\"commonPrefixLength\")\n             .returns(int.class)\n             .addParameter(ParameterizedTypeName.get(List.class, String.class), \"listA\")\n@@ -858,11 +877,21 @@ public final class TypeSpecTest {\n     assertThat(toString(util)).isEqualTo(\"\"\n         + \"package com.squareup.tacos;\\n\"\n         + \"\\n\"\n+        + \"import com.google.common.collect.ImmutableMap;\\n\"\n         + \"import java.lang.Math;\\n\"\n         + \"import java.lang.String;\\n\"\n         + \"import java.util.List;\\n\"\n+        + \"import java.util.Map;\\n\"\n         + \"\\n\"\n         + \"class Util {\\n\"\n+        + \"  private static final Map<String, String> ESCAPE_HTML = \\n\"\n+        + \"      ImmutableMap.<String, String>builder()\\n\"\n+        + \"          .add(\\\"\\'\\\", \\\"&#39;\\\")\\n\"\n+        + \"          .add(\\\"&\\\", \\\"&amp;\\\")\\n\"\n+        + \"          .add(\\\"<\\\", \\\"&lt;\\\")\\n\"\n+        + \"          .add(\\\">\\\", \\\"&gt;\\\")\\n\"\n+        + \"          .build();\\n\"\n+        + \"\\n\"\n         + \"  int commonPrefixLength(List<String> listA, List<String> listB) {\\n\"\n         + \"    int size = Math.min(listA.size(), listB.size());\\n\"\n         + \"    for (int i = 0; i < size; i++) {\\n\"\n@@ -1308,4 +1337,22 @@ public final class TypeSpecTest {\n         + \"      + \\\"cheese\\\\n\\\";\\n\"\n         + \"}\\n\");\n   }\n+\n+  @Test public void doubleFieldInitialization() {\n+    try {\n+      FieldSpec.builder(String.class, \"listA\")\n+          .initializer(\"foo\")\n+          .initializer(\"bar\")\n+          .build();\n+      fail();\n+    } catch (IllegalStateException expected) {}\n+\n+    try {\n+      FieldSpec.builder(String.class, \"listA\")\n+          .initializer(CodeBlock.builder().add(\"foo\").build())\n+          .initializer(CodeBlock.builder().add(\"bar\").build())\n+          .build();\n+      fail();\n+    } catch (IllegalStateException expected) {}\n+  }\n }\n"
    },
    {
        "commit_hash": "a62798ea284d7854b58bd7f8da51caa69e782e35",
        "previous_commit_hash": "18af022bed38e039ef34c55b849f208cd059f4da",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -374,7 +374,7 @@ return type. All of these are configured with `MethodSpec.Builder`.\n \n ### Constructors\n \n-`MethodSpec` is a slight misnomer; it is also be used for constructors:\n+`MethodSpec` is a slight misnomer; it can also be used for constructors:\n \n ```java\n MethodSpec flux = MethodSpec.constructorBuilder()\n"
    },
    {
        "commit_hash": "65c00fc507e96a89b97dd6b94cbe057a925d3ded",
        "previous_commit_hash": "d746405b768be37a2a2d906e68875a5d9a1577e1",
        "diff_stats": {
            "additions": 3,
            "deletions": 0
        },
        "diff_content": "@@ -21,11 +21,14 @@ import javax.lang.model.element.TypeElement;\n import javax.lang.model.util.Elements;\n import org.junit.Rule;\n import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n \n import static com.google.common.truth.Truth.assertThat;\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.fail;\n \n+@RunWith(JUnit4.class)\n public final class ClassNameTest {\n   @Rule public CompilationRule compilationRule = new CompilationRule();\n \n"
    },
    {
        "commit_hash": "65c00fc507e96a89b97dd6b94cbe057a925d3ded",
        "previous_commit_hash": "d746405b768be37a2a2d906e68875a5d9a1577e1",
        "diff_stats": {
            "additions": 3,
            "deletions": 0
        },
        "diff_content": "@@ -27,11 +27,14 @@ import javax.lang.model.element.Modifier;\n import org.junit.Rule;\n import org.junit.Test;\n import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n import org.mockito.Mockito;\n \n import static com.google.common.truth.Truth.assertThat;\n import static org.junit.Assert.fail;\n \n+@RunWith(JUnit4.class)\n public final class FileWritingTest {\n   // Used for testing java.io File behavior.\n   @Rule public final TemporaryFolder tmp = new TemporaryFolder();\n"
    },
    {
        "commit_hash": "65c00fc507e96a89b97dd6b94cbe057a925d3ded",
        "previous_commit_hash": "d746405b768be37a2a2d906e68875a5d9a1577e1",
        "diff_stats": {
            "additions": 3,
            "deletions": 0
        },
        "diff_content": "@@ -18,9 +18,12 @@ package com.squareup.javapoet;\n import java.util.Date;\n import javax.lang.model.element.Modifier;\n import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n \n import static com.google.common.truth.Truth.assertThat;\n \n+@RunWith(JUnit4.class)\n public final class JavaFileTest {\n   @Test public void noImports() throws Exception {\n     String source = JavaFile.builder(\"com.squareup.tacos\",\n"
    },
    {
        "commit_hash": "65c00fc507e96a89b97dd6b94cbe057a925d3ded",
        "previous_commit_hash": "d746405b768be37a2a2d906e68875a5d9a1577e1",
        "diff_stats": {
            "additions": 3,
            "deletions": 0
        },
        "diff_content": "@@ -27,6 +27,8 @@ import java.util.Random;\n import javax.lang.model.element.Element;\n import javax.lang.model.element.Modifier;\n import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n import org.mockito.Mockito;\n \n import com.google.common.collect.ImmutableMap;\n@@ -34,6 +36,7 @@ import com.google.common.collect.ImmutableMap;\n import static com.google.common.truth.Truth.assertThat;\n import static org.junit.Assert.fail;\n \n+@RunWith(JUnit4.class)\n public final class TypeSpecTest {\n   private final String tacosPackage = \"com.squareup.tacos\";\n   private static final String donutsPackage = \"com.squareup.donuts\";\n"
    },
    {
        "commit_hash": "65c00fc507e96a89b97dd6b94cbe057a925d3ded",
        "previous_commit_hash": "d746405b768be37a2a2d906e68875a5d9a1577e1",
        "diff_stats": {
            "additions": 3,
            "deletions": 0
        },
        "diff_content": "@@ -28,10 +28,13 @@ import javax.lang.model.type.TypeKind;\n import javax.lang.model.type.TypeMirror;\n import org.junit.Rule;\n import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n \n import static com.google.common.truth.Truth.assertThat;\n import static org.junit.Assert.fail;\n \n+@RunWith(JUnit4.class)\n public final class TypesTest {\n   @Rule public final CompilationRule compilation = new CompilationRule();\n \n"
    },
    {
        "commit_hash": "b5074260ce2a8b8880e294cddda012aea922aa48",
        "previous_commit_hash": "aee5f128570ced5e5d19aed1712513c67a5532e3",
        "diff_stats": {
            "additions": 7,
            "deletions": 0
        },
        "diff_content": "@@ -24,6 +24,7 @@ import java.io.StringWriter;\n import java.lang.reflect.Type;\n import java.util.ArrayList;\n import java.util.Collections;\n+import java.util.Collection;\n import java.util.List;\n import java.util.Set;\n \n@@ -107,6 +108,12 @@ public final class FieldSpec {\n       return this;\n     }\n \n+    public Builder addAnnotations(Collection<AnnotationSpec> annotationSpecs) {\n+      checkArgument(annotationSpecs != null, \"annotationSpecs == null\");\n+      this.annotations.addAll(annotationSpecs);\n+      return this;\n+    }\n+\n     public Builder addAnnotation(AnnotationSpec annotationSpec) {\n       this.annotations.add(annotationSpec);\n       return this;\n"
    },
    {
        "commit_hash": "b5074260ce2a8b8880e294cddda012aea922aa48",
        "previous_commit_hash": "aee5f128570ced5e5d19aed1712513c67a5532e3",
        "diff_stats": {
            "additions": 25,
            "deletions": 0
        },
        "diff_content": "@@ -20,6 +20,7 @@ import java.io.StringWriter;\n import java.lang.reflect.Type;\n import java.util.ArrayList;\n import java.util.Collections;\n+import java.util.Collection;\n import java.util.Iterator;\n import java.util.List;\n import java.util.Set;\n@@ -174,6 +175,12 @@ public final class MethodSpec {\n       return this;\n     }\n \n+    public Builder addAnnotations(Collection<AnnotationSpec> annotationSpecs) {\n+      checkArgument(annotationSpecs != null, \"annotationSpecs == null\");\n+      this.annotations.addAll(annotationSpecs);\n+      return this;\n+    }\n+\n     public Builder addAnnotation(AnnotationSpec annotationSpec) {\n       this.annotations.add(annotationSpec);\n       return this;\n@@ -193,6 +200,12 @@ public final class MethodSpec {\n       return this;\n     }\n \n+    public Builder addTypeVariables(Collection<TypeVariableName> typeVariables) {\n+      checkArgument(typeVariables != null, \"typeVariables == null\");\n+      this.typeVariables.addAll(typeVariables);\n+      return this;\n+    }\n+\n     public Builder addTypeVariable(TypeVariableName typeVariable) {\n       typeVariables.add(typeVariable);\n       return this;\n@@ -208,6 +221,12 @@ public final class MethodSpec {\n       return returns(TypeName.get(returnType));\n     }\n \n+    public Builder addParameters(Collection<ParameterSpec> parameterSpecs) {\n+      checkArgument(parameterSpecs != null, \"parameterSpecs == null\");\n+      this.parameters.addAll(parameterSpecs);\n+      return this;\n+    }\n+\n     public Builder addParameter(ParameterSpec parameterSpec) {\n       this.parameters.add(parameterSpec);\n       return this;\n@@ -226,6 +245,12 @@ public final class MethodSpec {\n       return this;\n     }\n \n+    public Builder addExceptions(Collection<TypeName> exceptions) {\n+      checkArgument(exceptions != null, \"exceptions == null\");\n+      this.exceptions.addAll(exceptions);\n+      return this;\n+    }\n+\n     public Builder addException(TypeName exception) {\n       this.exceptions.add(exception);\n       return this;\n"
    },
    {
        "commit_hash": "b5074260ce2a8b8880e294cddda012aea922aa48",
        "previous_commit_hash": "aee5f128570ced5e5d19aed1712513c67a5532e3",
        "diff_stats": {
            "additions": 7,
            "deletions": 0
        },
        "diff_content": "@@ -20,6 +20,7 @@ import java.io.StringWriter;\n import java.lang.reflect.Type;\n import java.util.ArrayList;\n import java.util.Collections;\n+import java.util.Collection;\n import java.util.List;\n import java.util.Set;\n import javax.lang.model.SourceVersion;\n@@ -90,6 +91,12 @@ public final class ParameterSpec {\n       this.name = name;\n     }\n \n+    public Builder addAnnotations(Collection<AnnotationSpec> annotationSpecs) {\n+      checkArgument(annotationSpecs != null, \"annotationSpecs == null\");\n+      this.annotations.addAll(annotationSpecs);\n+      return this;\n+    }\n+\n     public Builder addAnnotation(AnnotationSpec annotationSpec) {\n       this.annotations.add(annotationSpec);\n       return this;\n"
    },
    {
        "commit_hash": "b5074260ce2a8b8880e294cddda012aea922aa48",
        "previous_commit_hash": "aee5f128570ced5e5d19aed1712513c67a5532e3",
        "diff_stats": {
            "additions": 45,
            "deletions": 0
        },
        "diff_content": "@@ -20,6 +20,7 @@ import java.io.StringWriter;\n import java.lang.reflect.Type;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.Collection;\n import java.util.Collections;\n import java.util.Iterator;\n import java.util.LinkedHashMap;\n@@ -310,6 +311,13 @@ public final class TypeSpec {\n       return this;\n     }\n \n+    public Builder addAnnotations(Collection<AnnotationSpec> annotationSpecs) {\n+      checkState(anonymousTypeArguments == null, \"forbidden on anonymous types.\");\n+      checkArgument(annotationSpecs != null, \"annotationSpecs == null\");\n+      this.annotations.addAll(annotationSpecs);\n+      return this;\n+    }\n+\n     public Builder addAnnotation(AnnotationSpec annotationSpec) {\n       checkState(anonymousTypeArguments == null, \"forbidden on anonymous types.\");\n       this.annotations.add(annotationSpec);\n@@ -330,6 +338,13 @@ public final class TypeSpec {\n       return this;\n     }\n \n+    public Builder addTypeVariables(Collection<TypeVariableName> typeVariables) {\n+      checkState(anonymousTypeArguments == null, \"forbidden on anonymous types.\");\n+      checkArgument(typeVariables != null, \"typeVariables == null\");\n+      this.typeVariables.addAll(typeVariables);\n+      return this;\n+    }\n+\n     public Builder addTypeVariable(TypeVariableName typeVariable) {\n       checkState(anonymousTypeArguments == null, \"forbidden on anonymous types.\");\n       typeVariables.add(typeVariable);\n@@ -345,6 +360,12 @@ public final class TypeSpec {\n       return superclass(TypeName.get(superclass));\n     }\n \n+    public Builder addSuperinterfaces(Collection<TypeName> superinterfaces) {\n+      checkArgument(superinterfaces != null, \"superinterfaces == null\");\n+      this.superinterfaces.addAll(superinterfaces);\n+      return this;\n+    }\n+\n     public Builder addSuperinterface(TypeName superinterface) {\n       this.superinterfaces.add(superinterface);\n       return this;\n@@ -367,6 +388,14 @@ public final class TypeSpec {\n       return this;\n     }\n \n+    public Builder addFields(Collection<FieldSpec> fieldSpecs) {\n+      checkArgument(fieldSpecs != null, \"fieldSpecs == null\");\n+      for (FieldSpec fieldSpec : fieldSpecs) {\n+        addField(fieldSpec);\n+      }\n+      return this;\n+    }\n+\n     public Builder addField(FieldSpec fieldSpec) {\n       checkArgument(fieldSpec.modifiers.containsAll(kind.implicitFieldModifiers),\n           \"%s %s.%s requires modifiers %s\", kind, name, fieldSpec.name,\n@@ -383,6 +412,14 @@ public final class TypeSpec {\n       return addField(TypeName.get(type), name, modifiers);\n     }\n \n+    public Builder addMethods(Collection<MethodSpec> methodSpecs) {\n+      checkArgument(methodSpecs != null, \"methodSpecs == null\");\n+      for (MethodSpec methodSpec : methodSpecs) {\n+        addMethod(methodSpec);\n+      }\n+      return this;\n+    }\n+\n     public Builder addMethod(MethodSpec methodSpec) {\n       checkArgument(methodSpec.modifiers.containsAll(kind.implicitMethodModifiers),\n           \"%s %s.%s requires modifiers %s\", kind, name, methodSpec.name,\n@@ -391,6 +428,14 @@ public final class TypeSpec {\n       return this;\n     }\n \n+    public Builder addTypes(Collection<TypeSpec> typeSpecs) {\n+      checkArgument(typeSpecs != null, \"typeSpecs == null\");\n+      for (TypeSpec typeSpec : typeSpecs) {\n+        addType(typeSpec);\n+      }\n+      return this;\n+    }\n+\n     public Builder addType(TypeSpec typeSpec) {\n       checkArgument(typeSpec.modifiers.containsAll(kind.implicitTypeModifiers),\n           \"%s %s.%s requires modifiers %s\", kind, name, typeSpec.name,\n"
    },
    {
        "commit_hash": "b5074260ce2a8b8880e294cddda012aea922aa48",
        "previous_commit_hash": "aee5f128570ced5e5d19aed1712513c67a5532e3",
        "diff_stats": {
            "additions": 36,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,36 @@\n+/*\n+ * Copyright (C) 2015 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javapoet;\n+\n+import org.junit.Test;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.junit.Assert.fail;\n+\n+public class FieldSpecTest {\n+\n+  @Test\n+  public void nullAnnotationsAddition() {\n+    try {\n+      FieldSpec.builder(int.class, \"foo\").addAnnotations(null);\n+      fail();\n+    }\n+    catch (IllegalArgumentException expected) {\n+      assertThat(expected.getMessage())\n+          .isEqualTo(\"annotationSpecs == null\");\n+    }\n+  }\n+}\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "b5074260ce2a8b8880e294cddda012aea922aa48",
        "previous_commit_hash": "aee5f128570ced5e5d19aed1712513c67a5532e3",
        "diff_stats": {
            "additions": 64,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,64 @@\n+/*\n+ * Copyright (C) 2015 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javapoet;\n+\n+import org.junit.Test;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.junit.Assert.fail;\n+\n+public final class MethodSpecTest {\n+\n+  @Test public void nullAnnotationsAddition() {\n+    try {\n+      MethodSpec.methodBuilder(\"doSomething\").addAnnotations(null);\n+      fail();\n+    } catch (IllegalArgumentException expected) {\n+      assertThat(expected.getMessage())\n+          .isEqualTo(\"annotationSpecs == null\");\n+    }\n+  }\n+\n+  @Test public void nullTypeVariablesAddition() {\n+    try {\n+      MethodSpec.methodBuilder(\"doSomething\").addTypeVariables(null);\n+      fail();\n+    } catch (IllegalArgumentException expected) {\n+      assertThat(expected.getMessage())\n+          .isEqualTo(\"typeVariables == null\");\n+    }\n+  }\n+\n+  @Test public void nullParametersAddition() {\n+    try {\n+      MethodSpec.methodBuilder(\"doSomething\").addParameters(null);\n+      fail();\n+    } catch (IllegalArgumentException expected) {\n+      assertThat(expected.getMessage())\n+          .isEqualTo(\"parameterSpecs == null\");\n+    }\n+  }\n+\n+  @Test public void nullExceptionsAddition() {\n+    try {\n+      MethodSpec.methodBuilder(\"doSomething\").addExceptions(null);\n+      fail();\n+    } catch (IllegalArgumentException expected) {\n+      assertThat(expected.getMessage())\n+          .isEqualTo(\"exceptions == null\");\n+    }\n+  }\n+}\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "b5074260ce2a8b8880e294cddda012aea922aa48",
        "previous_commit_hash": "aee5f128570ced5e5d19aed1712513c67a5532e3",
        "diff_stats": {
            "additions": 35,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,35 @@\n+/*\n+ * Copyright (C) 2015 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javapoet;\n+\n+import org.junit.Test;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.junit.Assert.fail;\n+\n+public class ParameterSpecTest {\n+\n+  @Test\n+  public void nullAnnotationsAddition() {\n+    try {\n+      ParameterSpec.builder(int.class, \"foo\").addAnnotations(null);\n+      fail();\n+    } catch (Exception e) {\n+      assertThat(e.getMessage())\n+          .isEqualTo(\"annotationSpecs == null\");\n+    }\n+  }\n+}\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "b5074260ce2a8b8880e294cddda012aea922aa48",
        "previous_commit_hash": "aee5f128570ced5e5d19aed1712513c67a5532e3",
        "diff_stats": {
            "additions": 200,
            "deletions": 12
        },
        "diff_content": "@@ -15,29 +15,25 @@\n  */\n package com.squareup.javapoet;\n \n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.util.AbstractSet;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Random;\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.Modifier;\n+import com.google.common.collect.ImmutableMap;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n import org.mockito.Mockito;\n \n-import com.google.common.collect.ImmutableMap;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.Modifier;\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.math.BigDecimal;\n+import java.util.*;\n \n import static com.google.common.truth.Truth.assertThat;\n import static org.junit.Assert.fail;\n \n @RunWith(JUnit4.class)\n public final class TypeSpecTest {\n+\n   private final String tacosPackage = \"com.squareup.tacos\";\n   private static final String donutsPackage = \"com.squareup.donuts\";\n \n@@ -1358,4 +1354,196 @@ public final class TypeSpecTest {\n       fail();\n     } catch (IllegalStateException expected) {}\n   }\n+\n+  @Test public void nullAnnotationsAddition() {\n+    try {\n+      TypeSpec.classBuilder(\"Taco\").addAnnotations(null);\n+      fail();\n+    } catch (IllegalArgumentException expected) {\n+      assertThat(expected.getMessage())\n+          .isEqualTo(\"annotationSpecs == null\");\n+    }\n+  }\n+\n+  @Test public void multipleAnnotationAddition() {\n+    TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n+        .addAnnotations(Arrays.asList(\n+            AnnotationSpec.builder(SuppressWarnings.class)\n+                .addMember(\"value\", \"$S\", \"unchecked\")\n+                .build(),\n+            AnnotationSpec.builder(Deprecated.class).build()\n+        ))\n+        .build();\n+    assertThat(toString(taco)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import java.lang.Deprecated;\\n\"\n+        + \"import java.lang.SuppressWarnings;\\n\"\n+        + \"\\n\"\n+        + \"@SuppressWarnings(\\\"unchecked\\\")\\n\"\n+        + \"@Deprecated\\n\"\n+        + \"class Taco {\\n\"\n+        + \"}\\n\"\n+          );\n+  }\n+\n+  @Test public void nullFieldsAddition() {\n+    try {\n+      TypeSpec.classBuilder(\"Taco\").addFields(null);\n+      fail();\n+    } catch (IllegalArgumentException expected) {\n+      assertThat(expected.getMessage())\n+          .isEqualTo(\"fieldSpecs == null\");\n+    }\n+  }\n+\n+  @Test public void multipleFieldAddition() {\n+    TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n+        .addFields(Arrays.asList(\n+            FieldSpec.builder(int.class, \"ANSWER\", Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)\n+                .initializer(\"$L\", 42)\n+                .build(),\n+            FieldSpec.builder(BigDecimal.class, \"price\", Modifier.PRIVATE).build()\n+        ))\n+        .build();\n+    assertThat(toString(taco)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import java.math.BigDecimal;\\n\"\n+        + \"\\n\"\n+        + \"class Taco {\\n\"\n+        + \"  private static final int ANSWER = 42;\\n\"\n+        + \"\\n\"\n+        + \"  private BigDecimal price;\\n\"\n+        + \"}\\n\"\n+    );\n+  }\n+\n+  @Test public void nullMethodsAddition() {\n+    try {\n+      TypeSpec.classBuilder(\"Taco\").addMethods(null);\n+      fail();\n+    } catch (IllegalArgumentException expected) {\n+      assertThat(expected.getMessage())\n+          .isEqualTo(\"methodSpecs == null\");\n+    }\n+  }\n+\n+  @Test public void multipleMethodAddition() {\n+    TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n+        .addMethods(Arrays.asList(\n+            MethodSpec.methodBuilder(\"getAnswer\")\n+                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n+                .returns(int.class)\n+                .addStatement(\"return $L\", 42)\n+                .build(),\n+            MethodSpec.methodBuilder(\"getRandomQuantity\")\n+                .addModifiers(Modifier.PUBLIC)\n+                .returns(int.class)\n+                .addJavadoc(\"chosen by fair dice roll ;)\")\n+                .addStatement(\"return $L\", 4)\n+                .build()\n+        ))\n+        .build();\n+    assertThat(toString(taco)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"class Taco {\\n\"\n+        + \"  public static int getAnswer() {\\n\"\n+        + \"    return 42;\\n\"\n+        + \"  }\\n\"\n+        + \"\\n\"\n+        + \"  /**\\n\"\n+        + \"   * chosen by fair dice roll ;) */\\n\"\n+        + \"  public int getRandomQuantity() {\\n\"\n+        + \"    return 4;\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\"\n+    );\n+  }\n+\n+  @Test public void nullSuperinterfacesAddition() {\n+    try {\n+      TypeSpec.classBuilder(\"Taco\").addSuperinterfaces(null);\n+      fail();\n+    } catch (IllegalArgumentException expected) {\n+      assertThat(expected.getMessage())\n+          .isEqualTo(\"superinterfaces == null\");\n+    }\n+  }\n+\n+  @Test public void multipleSuperinterfaceAddition() {\n+    TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n+        .addSuperinterfaces(Arrays.asList(\n+            TypeName.get(Serializable.class),\n+            TypeName.get(EventListener.class)\n+        ))\n+        .build();\n+    assertThat(toString(taco)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import java.io.Serializable;\\n\"\n+        + \"import java.util.EventListener;\\n\"\n+        + \"\\n\"\n+        + \"class Taco implements Serializable, EventListener {\\n\"\n+        + \"}\\n\"\n+    );\n+  }\n+\n+  @Test public void nullTypeVariablesAddition() {\n+    try {\n+      TypeSpec.classBuilder(\"Taco\").addTypeVariables(null);\n+      fail();\n+    } catch (IllegalArgumentException expected) {\n+      assertThat(expected.getMessage())\n+          .isEqualTo(\"typeVariables == null\");\n+    }\n+  }\n+\n+  @Test public void multipleTypeVariableAddition() {\n+    TypeSpec location = TypeSpec.classBuilder(\"Location\")\n+        .addTypeVariables(Arrays.asList(\n+            TypeVariableName.get(\"T\"),\n+            TypeVariableName.get(\"P\", Number.class)\n+        ))\n+        .build();\n+    assertThat(toString(location)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import java.lang.Number;\\n\"\n+        + \"\\n\"\n+        + \"class Location<T, P extends Number> {\\n\"\n+        + \"}\\n\"\n+    );\n+  }\n+\n+  @Test public void nullTypesAddition() {\n+    try {\n+      TypeSpec.classBuilder(\"Taco\").addTypes(null);\n+      fail();\n+    } catch (IllegalArgumentException expected) {\n+      assertThat(expected.getMessage())\n+          .isEqualTo(\"typeSpecs == null\");\n+    }\n+  }\n+\n+  @Test public void multipleTypeAddition() {\n+    TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n+        .addTypes(Arrays.asList(\n+            TypeSpec.classBuilder(\"Topping\").build(),\n+            TypeSpec.classBuilder(\"Sauce\").build()\n+        ))\n+        .build();\n+    assertThat(toString(taco)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"class Taco {\\n\"\n+        + \"  class Topping {\\n\"\n+        + \"  }\\n\"\n+        + \"\\n\"\n+        + \"  class Sauce {\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\"\n+    );\n+  }\n }\n"
    },
    {
        "commit_hash": "70b38e5a0b2ef538c110e4108ae51ccb41bd6034",
        "previous_commit_hash": "aee5f128570ced5e5d19aed1712513c67a5532e3",
        "diff_stats": {
            "additions": 12,
            "deletions": 3
        },
        "diff_content": "@@ -21,6 +21,7 @@ import java.lang.reflect.WildcardType;\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n+import javax.lang.model.type.TypeMirror;\n \n import static com.squareup.javapoet.Util.checkArgument;\n \n@@ -89,9 +90,17 @@ public final class WildcardTypeName extends TypeName {\n   }\n \n   public static TypeName get(javax.lang.model.type.WildcardType mirror) {\n-    TypeName extendsBound = TypeName.get(mirror.getExtendsBound());\n-    TypeName superBound = TypeName.get(mirror.getSuperBound());\n-    return superBound != null ? supertypeOf(superBound) : subtypeOf(extendsBound);\n+    TypeMirror extendsBound = mirror.getExtendsBound();\n+    if (extendsBound == null) {\n+      TypeMirror superBound = mirror.getSuperBound();\n+      if (superBound == null) {\n+        return subtypeOf(Object.class);\n+      } else {\n+        return supertypeOf(TypeName.get(superBound));\n+      }\n+    } else {\n+      return subtypeOf(TypeName.get(extendsBound));\n+    }\n   }\n \n   public static TypeName get(WildcardType wildcardName) {\n"
    },
    {
        "commit_hash": "70b38e5a0b2ef538c110e4108ae51ccb41bd6034",
        "previous_commit_hash": "aee5f128570ced5e5d19aed1712513c67a5532e3",
        "diff_stats": {
            "additions": 27,
            "deletions": 0
        },
        "diff_content": "@@ -26,6 +26,9 @@ import javax.lang.model.element.TypeParameterElement;\n import javax.lang.model.type.DeclaredType;\n import javax.lang.model.type.TypeKind;\n import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.type.WildcardType;\n+import javax.lang.model.util.Elements;\n+import javax.lang.model.util.Types;\n import org.junit.Rule;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n@@ -157,6 +160,30 @@ public final class TypesTest {\n     assertThat(type.toString()).isEqualTo(\"? super java.lang.String\");\n   }\n \n+  @Test public void wildcardMirrorNoBounds() throws Exception {\n+    WildcardType wildcard = compilation.getTypes().getWildcardType(null, null);\n+    TypeName type = TypeName.get(wildcard);\n+    assertThat(type.toString()).isEqualTo(\"?\");\n+  }\n+\n+  @Test public void wildcardMirrorExtendsType() throws Exception {\n+    Types types = compilation.getTypes();\n+    Elements elements = compilation.getElements();\n+    TypeMirror charSequence = elements.getTypeElement(CharSequence.class.getName()).asType();\n+    WildcardType wildcard = types.getWildcardType(charSequence, null);\n+    TypeName type = TypeName.get(wildcard);\n+    assertThat(type.toString()).isEqualTo(\"? extends java.lang.CharSequence\");\n+  }\n+\n+  @Test public void wildcardMirrorSuperType() throws Exception {\n+    Types types = compilation.getTypes();\n+    Elements elements = compilation.getElements();\n+    TypeMirror string = elements.getTypeElement(String.class.getName()).asType();\n+    WildcardType wildcard = types.getWildcardType(null, string);\n+    TypeName type = TypeName.get(wildcard);\n+    assertThat(type.toString()).isEqualTo(\"? super java.lang.String\");\n+  }\n+\n   @Test public void typeVariable() throws Exception {\n     TypeVariableName type = TypeVariableName.get(\"T\", CharSequence.class);\n     assertThat(type.toString()).isEqualTo(\"T\"); // (Bounds are only emitted in declaration.)\n"
    },
    {
        "commit_hash": "92207e4c17ec3cc6bcb971e7aad44264813e61df",
        "previous_commit_hash": "8ea1ac750a983a9f5b0bc04ccae047b6f6121823",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -145,7 +145,7 @@ public final class CodeBlock {\n       unindent();\n       add(\"} \", args);\n       add(controlFlow, args);\n-      add(\"{\\n\", args);\n+      add(\" {\\n\", args);\n       indent();\n       return this;\n     }\n"
    },
    {
        "commit_hash": "92207e4c17ec3cc6bcb971e7aad44264813e61df",
        "previous_commit_hash": "8ea1ac750a983a9f5b0bc04ccae047b6f6121823",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -924,7 +924,7 @@ public final class TypeSpecTest {\n         + \"  void choices() {\\n\"\n         + \"    if (5 < 4)  {\\n\"\n         + \"      System.out.println(\\\"wat\\\");\\n\"\n-        + \"    } else if (5 < 6){\\n\"\n+        + \"    } else if (5 < 6) {\\n\"\n         + \"      System.out.println(\\\"hello\\\");\\n\"\n         + \"    }\\n\"\n         + \"  }\\n\"\n"
    },
    {
        "commit_hash": "cbe76bba09cf887a48b0b4fa370330ab1fd2103f",
        "previous_commit_hash": "31c205513996c48ec41f82d2bbdd9cca30d7c1a0",
        "diff_stats": {
            "additions": 1,
            "deletions": 3
        },
        "diff_content": "@@ -143,9 +143,7 @@ public final class CodeBlock {\n      */\n     public Builder nextControlFlow(String controlFlow, Object... args) {\n       unindent();\n-      add(\"} \", args);\n-      add(controlFlow, args);\n-      add(\" {\\n\", args);\n+      add(\"} \" + controlFlow + \" {\\n\", args);\n       indent();\n       return this;\n     }\n"
    },
    {
        "commit_hash": "cbe76bba09cf887a48b0b4fa370330ab1fd2103f",
        "previous_commit_hash": "31c205513996c48ec41f82d2bbdd9cca30d7c1a0",
        "diff_stats": {
            "additions": 27,
            "deletions": 0
        },
        "diff_content": "@@ -1546,4 +1546,31 @@ public final class TypeSpecTest {\n         + \"}\\n\"\n     );\n   }\n+\n+  @Test public void tryCatch() {\n+    TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n+      .addMethod(\n+        MethodSpec.methodBuilder(\"addTopping\")\n+          .addParameter(ClassName.get(\"com.squareup.tacos\", \"Topping\"), \"topping\")\n+          .beginControlFlow(\"try\")\n+          .addCode(\"/* do something tricky with the topping */\\n\")\n+          .nextControlFlow(\"catch ($T e)\",\n+            ClassName.get(\"com.squareup.tacos\", \"IllegalToppingException\"))\n+          .endControlFlow()\n+          .build()\n+      )\n+      .build();\n+    assertThat(toString(taco)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"class Taco {\\n\"\n+        + \"  void addTopping(Topping topping) {\\n\"\n+        + \"    try {\\n\"\n+        + \"      /* do something tricky with the topping */\\n\"\n+        + \"    } catch (IllegalToppingException e) {\\n\"\n+        + \"    }\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\"\n+    );\n+  }\n }\n"
    },
    {
        "commit_hash": "eb7776058fb3aa05c997026bf26e5c6666e9d7ba",
        "previous_commit_hash": "31c205513996c48ec41f82d2bbdd9cca30d7c1a0",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -22,8 +22,8 @@\n \n     <java.version>1.7</java.version>\n     <junit.version>4.12</junit.version>\n-    <truth.version>1.0-SNAPSHOT</truth.version>\n-    <compile-testing.version>1.0-SNAPSHOT</compile-testing.version>\n+    <truth.version>0.25</truth.version>\n+    <compile-testing.version>0.6</compile-testing.version>\n   </properties>\n \n   <scm>\n"
    },
    {
        "commit_hash": "4168fb77aff7024a7d69744bcace0c863a861511",
        "previous_commit_hash": "23be296fba9230c81635f58b4f723440a4e49832",
        "diff_stats": {
            "additions": 48,
            "deletions": 0
        },
        "diff_content": "@@ -71,6 +71,16 @@ public class TypeName {\n   public static final TypeName DOUBLE = new TypeName(\"double\");\n   public static final ClassName OBJECT = ClassName.get(\"java.lang\", \"Object\");\n \n+  private static final ClassName BOXED_VOID = ClassName.get(\"java.lang\", \"Void\");\n+  private static final ClassName BOXED_BOOLEAN = ClassName.get(\"java.lang\", \"Boolean\");\n+  private static final ClassName BOXED_BYTE = ClassName.get(\"java.lang\", \"Byte\");\n+  private static final ClassName BOXED_SHORT = ClassName.get(\"java.lang\", \"Short\");\n+  private static final ClassName BOXED_INT = ClassName.get(\"java.lang\", \"Integer\");\n+  private static final ClassName BOXED_LONG = ClassName.get(\"java.lang\", \"Long\");\n+  private static final ClassName BOXED_CHAR = ClassName.get(\"java.lang\", \"Character\");\n+  private static final ClassName BOXED_FLOAT = ClassName.get(\"java.lang\", \"Float\");\n+  private static final ClassName BOXED_DOUBLE = ClassName.get(\"java.lang\", \"Double\");\n+\n   /** The name of this type if it is a keyword, or null. */\n   private final String keyword;\n \n@@ -87,6 +97,44 @@ public class TypeName {\n     return keyword != null && this != VOID;\n   }\n \n+  /**\n+   * Returns a boxed type if this is a primitive type (like {@code Integer} for {@code int}) or\n+   * {@code void}. Returns this type if boxing doesn't apply.\n+   */\n+  public TypeName box() {\n+    if (keyword == null) return this; // Doesn't need boxing.\n+    if (this == VOID) return BOXED_VOID;\n+    if (this == BOOLEAN) return BOXED_BOOLEAN;\n+    if (this == BYTE) return BOXED_BYTE;\n+    if (this == SHORT) return BOXED_SHORT;\n+    if (this == INT) return BOXED_INT;\n+    if (this == LONG) return BOXED_LONG;\n+    if (this == CHAR) return BOXED_CHAR;\n+    if (this == FLOAT) return BOXED_FLOAT;\n+    if (this == DOUBLE) return BOXED_DOUBLE;\n+    throw new AssertionError(keyword);\n+  }\n+\n+  /**\n+   * Returns an unboxed type if this is a boxed primitive type (like {@code int} for {@code\n+   * Integer}) or {@code Void}. Returns this type if it is already unboxed.\n+   *\n+   * @throws UnsupportedOperationException if this type isn't eligible for unboxing.\n+   */\n+  public TypeName unbox() {\n+    if (keyword != null) return this; // Already unboxed.\n+    if (this.equals(BOXED_VOID)) return VOID;\n+    if (this.equals(BOXED_BOOLEAN)) return BOOLEAN;\n+    if (this.equals(BOXED_BYTE)) return BYTE;\n+    if (this.equals(BOXED_SHORT)) return SHORT;\n+    if (this.equals(BOXED_INT)) return INT;\n+    if (this.equals(BOXED_LONG)) return LONG;\n+    if (this.equals(BOXED_CHAR)) return CHAR;\n+    if (this.equals(BOXED_FLOAT)) return FLOAT;\n+    if (this.equals(BOXED_DOUBLE)) return DOUBLE;\n+    throw new UnsupportedOperationException(\"cannot unbox \" + this);\n+  }\n+\n   @Override public final String toString() {\n     try {\n       StringBuilder result = new StringBuilder();\n"
    },
    {
        "commit_hash": "4168fb77aff7024a7d69744bcace0c863a861511",
        "previous_commit_hash": "23be296fba9230c81635f58b4f723440a4e49832",
        "diff_stats": {
            "additions": 26,
            "deletions": 0
        },
        "diff_content": "@@ -158,4 +158,30 @@ public final class TypesTest {\n     TypeVariableName type = TypeVariableName.get(\"T\", CharSequence.class);\n     assertThat(type.toString()).isEqualTo(\"T\"); // (Bounds are only emitted in declaration.)\n   }\n+\n+  @Test public void box() throws Exception {\n+    assertThat(TypeName.INT.box()).isEqualTo(ClassName.get(Integer.class));\n+    assertThat(TypeName.VOID.box()).isEqualTo(ClassName.get(Void.class));\n+    assertThat(ClassName.get(Integer.class).box()).isEqualTo(ClassName.get(Integer.class));\n+    assertThat(ClassName.get(Void.class).box()).isEqualTo(ClassName.get(Void.class));\n+    assertThat(TypeName.OBJECT.box()).isEqualTo(TypeName.OBJECT);\n+    assertThat(ClassName.get(String.class).box()).isEqualTo(ClassName.get(String.class));\n+  }\n+\n+  @Test public void unbox() throws Exception {\n+    assertThat(TypeName.INT).isEqualTo(TypeName.INT.unbox());\n+    assertThat(TypeName.VOID).isEqualTo(TypeName.VOID.unbox());\n+    assertThat(ClassName.get(Integer.class).unbox()).isEqualTo(TypeName.INT.unbox());\n+    assertThat(ClassName.get(Void.class).unbox()).isEqualTo(TypeName.VOID.unbox());\n+    try {\n+      TypeName.OBJECT.unbox();\n+      fail();\n+    } catch (UnsupportedOperationException expected) {\n+    }\n+    try {\n+      ClassName.get(String.class).unbox();\n+      fail();\n+    } catch (UnsupportedOperationException expected) {\n+    }\n+  }\n }\n"
    },
    {
        "commit_hash": "cb2a6f497ad340b974f8817400bc755218aca59e",
        "previous_commit_hash": "33bb07eac9bc92bb4df30d71623dac0a2a1adf37",
        "diff_stats": {
            "additions": 59,
            "deletions": 1
        },
        "diff_content": "@@ -19,13 +19,19 @@ import java.io.IOException;\n import java.io.StringWriter;\n import java.lang.reflect.Type;\n import java.util.ArrayList;\n-import java.util.Collections;\n import java.util.Collection;\n+import java.util.Collections;\n import java.util.Iterator;\n+import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Set;\n import javax.lang.model.SourceVersion;\n+import javax.lang.model.element.ExecutableElement;\n import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeParameterElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.type.TypeVariable;\n \n import static com.squareup.javapoet.Util.checkArgument;\n import static com.squareup.javapoet.Util.checkNotNull;\n@@ -150,6 +156,52 @@ public final class MethodSpec {\n     return new Builder(CONSTRUCTOR);\n   }\n \n+  /**\n+   * Create a builder which overrides {@code method}. This will copy its visibility modifiers, type\n+   * parameters, return type, name, parameters, and throws declarations. An {@link Override}\n+   * annotation will be added.\n+   */\n+  public static Builder overriding(ExecutableElement method) {\n+    checkNotNull(method, \"method == null\");\n+\n+    Set<Modifier> modifiers = method.getModifiers();\n+    if (modifiers.contains(Modifier.PRIVATE)\n+        || modifiers.contains(Modifier.FINAL)\n+        || modifiers.contains(Modifier.STATIC)) {\n+      throw new IllegalArgumentException(\"cannot override method with modifiers: \" + modifiers);\n+    }\n+\n+    String methodName = method.getSimpleName().toString();\n+    MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder(methodName);\n+\n+    // TODO copy method annotations.\n+    // TODO check to ensure we're not duplicating override annotation.\n+    methodBuilder.addAnnotation(Override.class);\n+\n+    modifiers = new LinkedHashSet<>(modifiers); // Local copy so we can remove.\n+    modifiers.remove(Modifier.ABSTRACT);\n+    methodBuilder.addModifiers(modifiers);\n+\n+    for (TypeParameterElement typeParameterElement : method.getTypeParameters()) {\n+      methodBuilder.addTypeVariable(\n+          TypeVariableName.get((TypeVariable) typeParameterElement.asType()));\n+    }\n+\n+    methodBuilder.returns(TypeName.get(method.getReturnType()));\n+\n+    for (VariableElement parameter : method.getParameters()) {\n+      // TODO copy parameter annotations.\n+      methodBuilder.addParameter(TypeName.get(parameter.asType()),\n+          parameter.getSimpleName().toString());\n+    }\n+\n+    for (TypeMirror thrownType : method.getThrownTypes()) {\n+      methodBuilder.addException(TypeName.get(thrownType));\n+    }\n+\n+    return methodBuilder;\n+  }\n+\n   public static final class Builder {\n     private final String name;\n \n@@ -200,6 +252,12 @@ public final class MethodSpec {\n       return this;\n     }\n \n+    public Builder addModifiers(Collection<Modifier> modifiers) {\n+      checkNotNull(modifiers, \"modifiers == null\");\n+      this.modifiers.addAll(modifiers);\n+      return this;\n+    }\n+\n     public Builder addTypeVariables(Collection<TypeVariableName> typeVariables) {\n       checkArgument(typeVariables != null, \"typeVariables == null\");\n       this.typeVariables.addAll(typeVariables);\n"
    },
    {
        "commit_hash": "cb2a6f497ad340b974f8817400bc755218aca59e",
        "previous_commit_hash": "33bb07eac9bc92bb4df30d71623dac0a2a1adf37",
        "diff_stats": {
            "additions": 101,
            "deletions": 9
        },
        "diff_content": "@@ -15,20 +15,40 @@\n  */\n package com.squareup.javapoet;\n \n+import com.google.common.collect.ImmutableSet;\n+import com.google.testing.compile.CompilationRule;\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Target;\n+import java.util.List;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n+import org.junit.Ignore;\n+import org.junit.Rule;\n import org.junit.Test;\n \n+import static com.google.common.collect.Iterables.getOnlyElement;\n import static com.google.common.truth.Truth.assertThat;\n+import static javax.lang.model.util.ElementFilter.methodsIn;\n import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n \n public final class MethodSpecTest {\n+  @Rule public final CompilationRule compilation = new CompilationRule();\n+\n+  private TypeElement getElement(Class<?> clazz) {\n+    return compilation.getElements().getTypeElement(clazz.getCanonicalName());\n+  }\n \n   @Test public void nullAnnotationsAddition() {\n     try {\n       MethodSpec.methodBuilder(\"doSomething\").addAnnotations(null);\n       fail();\n     } catch (IllegalArgumentException expected) {\n-      assertThat(expected.getMessage())\n-          .isEqualTo(\"annotationSpecs == null\");\n+      assertThat(expected).hasMessage(\"annotationSpecs == null\");\n     }\n   }\n \n@@ -37,8 +57,7 @@ public final class MethodSpecTest {\n       MethodSpec.methodBuilder(\"doSomething\").addTypeVariables(null);\n       fail();\n     } catch (IllegalArgumentException expected) {\n-      assertThat(expected.getMessage())\n-          .isEqualTo(\"typeVariables == null\");\n+      assertThat(expected).hasMessage(\"typeVariables == null\");\n     }\n   }\n \n@@ -47,8 +66,7 @@ public final class MethodSpecTest {\n       MethodSpec.methodBuilder(\"doSomething\").addParameters(null);\n       fail();\n     } catch (IllegalArgumentException expected) {\n-      assertThat(expected.getMessage())\n-          .isEqualTo(\"parameterSpecs == null\");\n+      assertThat(expected).hasMessage(\"parameterSpecs == null\");\n     }\n   }\n \n@@ -57,8 +75,82 @@ public final class MethodSpecTest {\n       MethodSpec.methodBuilder(\"doSomething\").addExceptions(null);\n       fail();\n     } catch (IllegalArgumentException expected) {\n-      assertThat(expected.getMessage())\n-          .isEqualTo(\"exceptions == null\");\n+      assertThat(expected).hasMessage(\"exceptions == null\");\n+    }\n+  }\n+\n+  @Target(ElementType.PARAMETER)\n+  @interface Nullable {\n+  }\n+\n+  @SuppressWarnings(\"unused\") // Used via mirror API.\n+  abstract static class Everything {\n+    @Deprecated protected abstract <T extends Runnable & Closeable> Runnable everything(\n+        @Nullable String thing, List<? extends T> things) throws IOException, SecurityException;\n+  }\n+\n+  @SuppressWarnings(\"unused\") // Used via mirror API.\n+  abstract static class HasAnnotation {\n+    @Override public abstract String toString();\n+  }\n+\n+  @Test public void overrideEverything() {\n+    TypeElement classElement = getElement(Everything.class);\n+    ExecutableElement methodElement = getOnlyElement(methodsIn(classElement.getEnclosedElements()));\n+\n+    MethodSpec method = MethodSpec.overriding(methodElement).build();\n+    assertThat(method.toString()).isEqualTo(\"\"\n+        + \"@java.lang.Override\\n\"\n+        + \"protected <T extends java.lang.Runnable & java.io.Closeable> \"\n+        + \"java.lang.Runnable everything(java.lang.String arg0, java.util.List<? extends T> arg1) \"\n+        + \"throws java.io.IOException, java.lang.SecurityException {\\n\"\n+        + \"}\\n\");\n+    // TODO see TODOs in MethodSpec.override\n+    //assertThat(method.toString()).isEqualTo(\"\"\n+    //    + \"@java.lang.Override\\n\"\n+    //    + \"@java.lang.Deprecated\\n\"\n+    //    + \"protected <T extends java.lang.Runnable & java.io.Closeable> \"\n+    //    + \"java.lang.Runnable everything(\"\n+    //    + \"@com.squareup.javapoet.MethodSpecTest.Nullable java.lang.String arg0, \"\n+    //    + \"java.util.List<? extends T> arg1) \"\n+    //    + \"throws java.io.IOException, java.lang.SecurityException {\\n\"\n+    //    + \"}\\n\");\n+  }\n+\n+  @Ignore // TODO see TODOs in MethodSpec.override\n+  @Test public void overrideDoesNotCopyOverrideAnnotation() {\n+    TypeElement classElement = getElement(Everything.class);\n+    ExecutableElement methodElement = getOnlyElement(methodsIn(classElement.getEnclosedElements()));\n+\n+    MethodSpec method = MethodSpec.overriding(methodElement).build();\n+    assertThat(method.toString()).isEqualTo(\"\"\n+        + \"@java.lang.Override\\n\"\n+        + \"public java.lang.String toString() {\"\n+        + \"}\");\n+  }\n+\n+  @Test public void overrideInvalidModifiers() {\n+    ExecutableElement method = mock(ExecutableElement.class);\n+    when(method.getModifiers()).thenReturn(ImmutableSet.of(Modifier.FINAL));\n+    try {\n+      MethodSpec.overriding(method);\n+      fail();\n+    } catch (IllegalArgumentException expected) {\n+      assertThat(expected).hasMessage(\"cannot override method with modifiers: [final]\");\n+    }\n+    when(method.getModifiers()).thenReturn(ImmutableSet.of(Modifier.PRIVATE));\n+    try {\n+      MethodSpec.overriding(method);\n+      fail();\n+    } catch (IllegalArgumentException expected) {\n+      assertThat(expected).hasMessage(\"cannot override method with modifiers: [private]\");\n+    }\n+    when(method.getModifiers()).thenReturn(ImmutableSet.of(Modifier.STATIC));\n+    try {\n+      MethodSpec.overriding(method);\n+      fail();\n+    } catch (IllegalArgumentException expected) {\n+      assertThat(expected).hasMessage(\"cannot override method with modifiers: [static]\");\n     }\n   }\n-}\n\\ No newline at end of file\n+}\n"
    },
    {
        "commit_hash": "233bc154f99f0cdcb5b7c50a33821b63caa3b00b",
        "previous_commit_hash": "395a2bc03853d96e25524c98cc58ef601795d92c",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -40,7 +40,7 @@ TypeSpec helloWorld = TypeSpec.classBuilder(\"HelloWorld\")\n JavaFile javaFile = JavaFile.builder(\"com.example.helloworld\", helloWorld)\n     .build();\n \n-javaFile.emit(System.out);\n+javaFile.writeTo(System.out);\n ```\n \n To declare the main method, we've created a `MethodSpec` \"main\" configured with modifiers, return\n@@ -168,7 +168,7 @@ public static void main(String[] args) throws Exception {\n   JavaFile javaFile = JavaFile.builder(\"com.example.helloworld\", helloWorld)\n       .build();\n       \n-  javaFile.emit(System.out);\n+  javaFile.writeTo(System.out);\n }\n \n private static MethodSpec whatsMyName(String name) {\n@@ -217,7 +217,7 @@ TypeSpec helloWorld = TypeSpec.classBuilder(\"HelloWorld\")\n JavaFile javaFile = JavaFile.builder(\"com.example.helloworld\", helloWorld)\n     .build();\n     \n-javaFile.emit(System.out);\n+javaFile.writeTo(System.out);\n ```\n \n That generates the following `.java` file, complete with the necessary `import`:\n"
    },
    {
        "commit_hash": "817d1dd2f3f814db62b44f9baf34185935b7656e",
        "previous_commit_hash": "233bc154f99f0cdcb5b7c50a33821b63caa3b00b",
        "diff_stats": {
            "additions": 43,
            "deletions": 11
        },
        "diff_content": "@@ -17,9 +17,13 @@ package com.squareup.javapoet;\n \n import java.io.IOException;\n import java.io.StringWriter;\n+import java.lang.reflect.Type;\n import java.util.ArrayList;\n-import java.util.Collections;\n+import java.util.Arrays;\n+import java.util.Iterator;\n import java.util.List;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.type.TypeMirror;\n \n import static com.squareup.javapoet.Util.checkArgument;\n import static com.squareup.javapoet.Util.checkState;\n@@ -90,7 +94,7 @@ public final class CodeBlock {\n     }\n \n     public Builder add(String format, Object... args) {\n-      int expectedArgsLength = 0;\n+      Iterator<Object> i = Arrays.asList(args).iterator();\n       for (int p = 0, nextP; p < format.length(); p = nextP) {\n         if (format.charAt(p) != '$') {\n           nextP = format.indexOf('$', p + 1);\n@@ -98,35 +102,63 @@ public final class CodeBlock {\n         } else {\n           checkState(p + 1 < format.length(), \"dangling $ in format string %s\", format);\n           switch (format.charAt(p + 1)) {\n-            case 'L':\n             case 'N':\n+              this.args.add(argToName(i.next()));\n+              break;\n+            case 'L':\n+              this.args.add(argToLiteral(i.next()));\n+              break;\n             case 'S':\n+              this.args.add(argToString(i.next()));\n+              break;\n             case 'T':\n-              expectedArgsLength++;\n-              // Fall through.\n+              this.args.add(argToType(i.next()));\n+              break;\n             case '$':\n             case '>':\n             case '<':\n             case '[':\n             case ']':\n-              nextP = p + 2;\n               break;\n-\n             default:\n               throw new IllegalArgumentException(\"invalid format string: \" + format);\n           }\n+\n+          nextP = p + 2;\n         }\n \n         formatParts.add(format.substring(p, nextP));\n       }\n \n-      checkArgument(args.length == expectedArgsLength,\n-          \"expected %s args for %s but was %s\", expectedArgsLength, format, args.length);\n-\n-      Collections.addAll(this.args, args);\n+      checkArgument(!i.hasNext(), \"unexpected args for %s: %s\", format, Arrays.asList(args));\n       return this;\n     }\n \n+    private String argToName(Object o) {\n+      if (o instanceof CharSequence) return o.toString();\n+      if (o instanceof ParameterSpec) return ((ParameterSpec) o).name;\n+      if (o instanceof FieldSpec) return ((FieldSpec) o).name;\n+      if (o instanceof MethodSpec) return ((MethodSpec) o).name;\n+      if (o instanceof TypeSpec) return ((TypeSpec) o).name;\n+      throw new IllegalArgumentException(\"expected name but was \" + o);\n+    }\n+\n+    private Object argToLiteral(Object o) {\n+      return o;\n+    }\n+\n+    private String argToString(Object o) {\n+      return o != null ? String.valueOf(o) : null;\n+    }\n+\n+    private TypeName argToType(Object o) {\n+      if (o instanceof TypeName) return (TypeName) o;\n+      if (o instanceof TypeMirror) return TypeName.get((TypeMirror) o);\n+      if (o instanceof Element) return TypeName.get(((Element) o).asType());\n+      if (o instanceof Type) return TypeName.get((Type) o);\n+      throw new IllegalArgumentException(\"expected type but was \" + o);\n+    }\n+\n     /**\n      * @param controlFlow the control flow construct and its code, such as \"if (foo == 5)\".\n      * Shouldn't contain braces or newline characters.\n"
    },
    {
        "commit_hash": "817d1dd2f3f814db62b44f9baf34185935b7656e",
        "previous_commit_hash": "233bc154f99f0cdcb5b7c50a33821b63caa3b00b",
        "diff_stats": {
            "additions": 6,
            "deletions": 29
        },
        "diff_content": "@@ -16,7 +16,6 @@\n package com.squareup.javapoet;\n \n import java.io.IOException;\n-import java.lang.reflect.Type;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.EnumSet;\n@@ -29,9 +28,7 @@ import java.util.Map;\n import java.util.Objects;\n import java.util.Set;\n import java.util.TreeMap;\n-import javax.lang.model.element.Element;\n import javax.lang.model.element.Modifier;\n-import javax.lang.model.type.TypeMirror;\n \n import static com.squareup.javapoet.Util.checkArgument;\n import static com.squareup.javapoet.Util.checkNotNull;\n@@ -204,19 +201,20 @@ final class CodeWriter {\n           break;\n \n         case \"$N\":\n-          emitName(codeBlock.args.get(a++));\n+          emitAndIndent((String) codeBlock.args.get(a++));\n           break;\n \n         case \"$S\":\n-          Object arg = codeBlock.args.get(a++);\n+          String string = (String) codeBlock.args.get(a++);\n           // Emit null as a literal null: no quotes.\n-          emitAndIndent(arg != null\n-              ? stringLiteral(String.valueOf(arg))\n+          emitAndIndent(string != null\n+              ? stringLiteral(string)\n               : \"null\");\n           break;\n \n         case \"$T\":\n-          toType(codeBlock.args.get(a++)).emit(this);\n+          TypeName typeName = (TypeName) codeBlock.args.get(a++);\n+          typeName.emit(this);\n           break;\n \n         case \"$$\":\n@@ -385,27 +383,6 @@ final class CodeWriter {\n     }\n   }\n \n-  private TypeName toType(Object arg) {\n-    if (arg instanceof TypeName) return (TypeName) arg;\n-    if (arg instanceof TypeMirror) return TypeName.get((TypeMirror) arg);\n-    if (arg instanceof Element) return TypeName.get(((Element) arg).asType());\n-    if (arg instanceof Type) return TypeName.get((Type) arg);\n-    throw new IllegalArgumentException(\"expected type but was \" + arg);\n-  }\n-\n-  private void emitName(Object o) throws IOException {\n-    emitAndIndent(toName(o));\n-  }\n-\n-  private String toName(Object o) {\n-    if (o instanceof CharSequence) return o.toString();\n-    if (o instanceof ParameterSpec) return ((ParameterSpec) o).name;\n-    if (o instanceof FieldSpec) return ((FieldSpec) o).name;\n-    if (o instanceof MethodSpec) return ((MethodSpec) o).name;\n-    if (o instanceof TypeSpec) return ((TypeSpec) o).name;\n-    throw new IllegalArgumentException(\"expected name but was \" + o);\n-  }\n-\n   /**\n    * Returns the types that should have been imported for this code. If there were any simple name\n    * collisions, that type's first use is imported.\n"
    },
    {
        "commit_hash": "817d1dd2f3f814db62b44f9baf34185935b7656e",
        "previous_commit_hash": "233bc154f99f0cdcb5b7c50a33821b63caa3b00b",
        "diff_stats": {
            "additions": 158,
            "deletions": 49
        },
        "diff_content": "@@ -16,27 +16,44 @@\n package com.squareup.javapoet;\n \n import com.google.common.collect.ImmutableMap;\n+import com.google.testing.compile.CompilationRule;\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.math.BigDecimal;\n+import java.util.AbstractSet;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.EventListener;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Random;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeMirror;\n+import org.junit.Rule;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n import org.mockito.Mockito;\n \n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.Modifier;\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.math.BigDecimal;\n-import java.util.*;\n-\n import static com.google.common.truth.Truth.assertThat;\n import static org.junit.Assert.fail;\n \n @RunWith(JUnit4.class)\n public final class TypeSpecTest {\n-\n   private final String tacosPackage = \"com.squareup.tacos\";\n   private static final String donutsPackage = \"com.squareup.donuts\";\n \n+  @Rule public final CompilationRule compilation = new CompilationRule();\n+\n+  private TypeElement getElement(Class<?> clazz) {\n+    return compilation.getElements().getTypeElement(clazz.getCanonicalName());\n+  }\n+\n   @Test public void basic() throws Exception {\n     TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n         .addMethod(MethodSpec.methodBuilder(\"toString\")\n@@ -1371,8 +1388,7 @@ public final class TypeSpecTest {\n             AnnotationSpec.builder(SuppressWarnings.class)\n                 .addMember(\"value\", \"$S\", \"unchecked\")\n                 .build(),\n-            AnnotationSpec.builder(Deprecated.class).build()\n-        ))\n+            AnnotationSpec.builder(Deprecated.class).build()))\n         .build();\n     assertThat(toString(taco)).isEqualTo(\"\"\n         + \"package com.squareup.tacos;\\n\"\n@@ -1383,8 +1399,7 @@ public final class TypeSpecTest {\n         + \"@SuppressWarnings(\\\"unchecked\\\")\\n\"\n         + \"@Deprecated\\n\"\n         + \"class Taco {\\n\"\n-        + \"}\\n\"\n-          );\n+        + \"}\\n\");\n   }\n \n   @Test public void nullFieldsAddition() {\n@@ -1400,11 +1415,8 @@ public final class TypeSpecTest {\n   @Test public void multipleFieldAddition() {\n     TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n         .addFields(Arrays.asList(\n-            FieldSpec.builder(int.class, \"ANSWER\", Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)\n-                .initializer(\"$L\", 42)\n-                .build(),\n-            FieldSpec.builder(BigDecimal.class, \"price\", Modifier.PRIVATE).build()\n-        ))\n+            FieldSpec.builder(int.class, \"ANSWER\", Modifier.STATIC, Modifier.FINAL).build(),\n+            FieldSpec.builder(BigDecimal.class, \"price\", Modifier.PRIVATE).build()))\n         .build();\n     assertThat(toString(taco)).isEqualTo(\"\"\n         + \"package com.squareup.tacos;\\n\"\n@@ -1412,11 +1424,10 @@ public final class TypeSpecTest {\n         + \"import java.math.BigDecimal;\\n\"\n         + \"\\n\"\n         + \"class Taco {\\n\"\n-        + \"  private static final int ANSWER = 42;\\n\"\n+        + \"  static final int ANSWER;\\n\"\n         + \"\\n\"\n         + \"  private BigDecimal price;\\n\"\n-        + \"}\\n\"\n-    );\n+        + \"}\\n\");\n   }\n \n   @Test public void nullMethodsAddition() {\n@@ -1442,8 +1453,7 @@ public final class TypeSpecTest {\n                 .returns(int.class)\n                 .addJavadoc(\"chosen by fair dice roll ;)\")\n                 .addStatement(\"return $L\", 4)\n-                .build()\n-        ))\n+                .build()))\n         .build();\n     assertThat(toString(taco)).isEqualTo(\"\"\n         + \"package com.squareup.tacos;\\n\"\n@@ -1458,8 +1468,7 @@ public final class TypeSpecTest {\n         + \"  public int getRandomQuantity() {\\n\"\n         + \"    return 4;\\n\"\n         + \"  }\\n\"\n-        + \"}\\n\"\n-    );\n+        + \"}\\n\");\n   }\n \n   @Test public void nullSuperinterfacesAddition() {\n@@ -1476,8 +1485,7 @@ public final class TypeSpecTest {\n     TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n         .addSuperinterfaces(Arrays.asList(\n             TypeName.get(Serializable.class),\n-            TypeName.get(EventListener.class)\n-        ))\n+            TypeName.get(EventListener.class)))\n         .build();\n     assertThat(toString(taco)).isEqualTo(\"\"\n         + \"package com.squareup.tacos;\\n\"\n@@ -1486,8 +1494,7 @@ public final class TypeSpecTest {\n         + \"import java.util.EventListener;\\n\"\n         + \"\\n\"\n         + \"class Taco implements Serializable, EventListener {\\n\"\n-        + \"}\\n\"\n-    );\n+        + \"}\\n\");\n   }\n \n   @Test public void nullTypeVariablesAddition() {\n@@ -1504,8 +1511,7 @@ public final class TypeSpecTest {\n     TypeSpec location = TypeSpec.classBuilder(\"Location\")\n         .addTypeVariables(Arrays.asList(\n             TypeVariableName.get(\"T\"),\n-            TypeVariableName.get(\"P\", Number.class)\n-        ))\n+            TypeVariableName.get(\"P\", Number.class)))\n         .build();\n     assertThat(toString(location)).isEqualTo(\"\"\n         + \"package com.squareup.tacos;\\n\"\n@@ -1513,8 +1519,7 @@ public final class TypeSpecTest {\n         + \"import java.lang.Number;\\n\"\n         + \"\\n\"\n         + \"class Location<T, P extends Number> {\\n\"\n-        + \"}\\n\"\n-    );\n+        + \"}\\n\");\n   }\n \n   @Test public void nullTypesAddition() {\n@@ -1531,8 +1536,7 @@ public final class TypeSpecTest {\n     TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n         .addTypes(Arrays.asList(\n             TypeSpec.classBuilder(\"Topping\").build(),\n-            TypeSpec.classBuilder(\"Sauce\").build()\n-        ))\n+            TypeSpec.classBuilder(\"Sauce\").build()))\n         .build();\n     assertThat(toString(taco)).isEqualTo(\"\"\n         + \"package com.squareup.tacos;\\n\"\n@@ -1543,23 +1547,20 @@ public final class TypeSpecTest {\n         + \"\\n\"\n         + \"  class Sauce {\\n\"\n         + \"  }\\n\"\n-        + \"}\\n\"\n-    );\n+        + \"}\\n\");\n   }\n \n   @Test public void tryCatch() {\n     TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n-      .addMethod(\n-        MethodSpec.methodBuilder(\"addTopping\")\n-          .addParameter(ClassName.get(\"com.squareup.tacos\", \"Topping\"), \"topping\")\n-          .beginControlFlow(\"try\")\n-          .addCode(\"/* do something tricky with the topping */\\n\")\n-          .nextControlFlow(\"catch ($T e)\",\n-            ClassName.get(\"com.squareup.tacos\", \"IllegalToppingException\"))\n-          .endControlFlow()\n-          .build()\n-      )\n-      .build();\n+        .addMethod(MethodSpec.methodBuilder(\"addTopping\")\n+            .addParameter(ClassName.get(\"com.squareup.tacos\", \"Topping\"), \"topping\")\n+            .beginControlFlow(\"try\")\n+            .addCode(\"/* do something tricky with the topping */\\n\")\n+            .nextControlFlow(\"catch ($T e)\",\n+                ClassName.get(\"com.squareup.tacos\", \"IllegalToppingException\"))\n+            .endControlFlow()\n+            .build())\n+        .build();\n     assertThat(toString(taco)).isEqualTo(\"\"\n         + \"package com.squareup.tacos;\\n\"\n         + \"\\n\"\n@@ -1570,7 +1571,115 @@ public final class TypeSpecTest {\n         + \"    } catch (IllegalToppingException e) {\\n\"\n         + \"    }\\n\"\n         + \"  }\\n\"\n-        + \"}\\n\"\n-    );\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void literalFromAnything() {\n+    Object value = new Object() {\n+      @Override public String toString() {\n+        return \"foo\";\n+      }\n+    };\n+    assertThat(codeBlock(\"$L\", value).toString()).isEqualTo(\"foo\");\n+  }\n+\n+  @Test public void nameFromCharSequence() {\n+    assertThat(codeBlock(\"$N\", \"text\").toString()).isEqualTo(\"text\");\n+  }\n+\n+  @Test public void nameFromField() {\n+    FieldSpec field = FieldSpec.builder(String.class, \"field\").build();\n+    assertThat(codeBlock(\"$N\", field).toString()).isEqualTo(\"field\");\n+  }\n+\n+  @Test public void nameFromParameter() {\n+    ParameterSpec parameter = ParameterSpec.builder(String.class, \"parameter\").build();\n+    assertThat(codeBlock(\"$N\", parameter).toString()).isEqualTo(\"parameter\");\n+  }\n+\n+  @Test public void nameFromMethod() {\n+    MethodSpec method = MethodSpec.methodBuilder(\"method\")\n+        .addModifiers(Modifier.ABSTRACT)\n+        .returns(String.class)\n+        .build();\n+    assertThat(codeBlock(\"$N\", method).toString()).isEqualTo(\"method\");\n+  }\n+\n+  @Test public void nameFromType() {\n+    TypeSpec type = TypeSpec.classBuilder(\"Type\").build();\n+    assertThat(codeBlock(\"$N\", type).toString()).isEqualTo(\"Type\");\n+  }\n+\n+  @Test public void nameFromUnsupportedType() {\n+    try {\n+      CodeBlock.builder().add(\"$N\", String.class);\n+      fail();\n+    } catch (IllegalArgumentException expected) {\n+      assertThat(expected).hasMessage(\"expected name but was \" + String.class);\n+    }\n+  }\n+\n+  @Test public void stringFromAnything() {\n+    Object value = new Object() {\n+      @Override public String toString() {\n+        return \"foo\";\n+      }\n+    };\n+    assertThat(codeBlock(\"$S\", value).toString()).isEqualTo(\"\\\"foo\\\"\");\n+  }\n+\n+  @Test public void stringFromNull() {\n+    assertThat(codeBlock(\"$S\", new Object[] { null }).toString()).isEqualTo(\"null\");\n+  }\n+\n+  @Test public void typeFromTypeName() {\n+    TypeName typeName = TypeName.get(String.class);\n+    assertThat(codeBlock(\"$T\", typeName).toString()).isEqualTo(\"java.lang.String\");\n+  }\n+\n+  @Test public void typeFromTypeMirror() {\n+    TypeMirror mirror = getElement(String.class).asType();\n+    assertThat(codeBlock(\"$T\", mirror).toString()).isEqualTo(\"java.lang.String\");\n+  }\n+\n+  @Test public void typeFromTypeElement() {\n+    TypeElement element = getElement(String.class);\n+    assertThat(codeBlock(\"$T\", element).toString()).isEqualTo(\"java.lang.String\");\n+  }\n+\n+  @Test public void typeFromReflectType() {\n+    assertThat(codeBlock(\"$T\", String.class).toString()).isEqualTo(\"java.lang.String\");\n+  }\n+\n+  @Test public void typeFromUnsupportedType() {\n+    try {\n+      CodeBlock.builder().add(\"$T\", \"java.lang.String\");\n+      fail();\n+    } catch (IllegalArgumentException expected) {\n+      assertThat(expected).hasMessage(\"expected type but was java.lang.String\");\n+    }\n+  }\n+\n+  @Test public void tooManyArguments() {\n+    try {\n+      CodeBlock.builder().add(\"$$\", \"foo\");\n+      fail();\n+    } catch (IllegalArgumentException expected) {\n+      assertThat(expected).hasMessage(\"unexpected args for $$: [foo]\");\n+    }\n+  }\n+\n+  @Test public void tooFewArguments() {\n+    try {\n+      CodeBlock.builder().add(\"$S\");\n+      fail();\n+    } catch (NoSuchElementException expected) {\n+    }\n+  }\n+\n+  private CodeBlock codeBlock(String format, Object... args) {\n+    return CodeBlock.builder()\n+        .add(format, args)\n+        .build();\n   }\n }\n"
    },
    {
        "commit_hash": "266e413b2f5fc180715455815d15d7000259729a",
        "previous_commit_hash": "20e17fdc5ffd0b63fffa384e98efc95b46930e71",
        "diff_stats": {
            "additions": 9,
            "deletions": 4
        },
        "diff_content": "@@ -23,10 +23,15 @@ git checkout -t origin/gh-pages\n # Delete everything\n rm -rf *\n \n-# Download the latest javadoc\n-curl -L \"https://search.maven.org/remote_content?g=$GROUP_ID&a=$ARTIFACT_ID&v=LATEST&c=javadoc\" > javadoc.zip\n-unzip javadoc.zip\n-rm javadoc.zip\n+# Download the latest javadoc to directories like 'javadoc/javapoet'.\n+for DOCUMENTED_ARTIFACT in javawriter javapoet\n+do\n+  curl -L \"https://search.maven.org/remote_content?g=$GROUP_ID&a=$DOCUMENTED_ARTIFACT&v=LATEST&c=javadoc\" > javadoc.zip\n+  JAVADOC_DIR=\"javadoc/${DOCUMENTED_ARTIFACT}\"\n+  mkdir -p $JAVADOC_DIR\n+  unzip javadoc.zip -d $JAVADOC_DIR\n+  rm javadoc.zip\n+done\n \n # Stage all files in git and create a commit\n git add .\n"
    },
    {
        "commit_hash": "2afa46c64e730e0efa090d8a526830cd9ffbd2bc",
        "previous_commit_hash": "266e413b2f5fc180715455815d15d7000259729a",
        "diff_stats": {
            "additions": 3,
            "deletions": 0
        },
        "diff_content": "@@ -50,6 +50,8 @@ that to a `HelloWorld.java` file.\n In this case we write the file to `System.out`, but we could also get it as a string\n (`JavaFile.toString()`) or write it to the file system (`JavaPoet.writeTo()`).\n \n+The [JavaPoet Javadoc][javadoc] catalogs the complete JavaPoet API, which we explore below.\n+\n ### Code & Control Flow\n \n Most of JavaPoet's API uses plain old immutable Java objects. There's also builders, method chaining\n@@ -786,6 +788,7 @@ JavaWriter continues to be available in [GitHub][javawriter] and [Maven Central]\n \n  [dl]: https://search.maven.org/remote_content?g=com.squareup&a=javapoet&v=LATEST\n  [snap]: https://oss.sonatype.org/content/repositories/snapshots/\n+ [javadoc]: https://square.github.io/javapoet/javadoc/javapoet/\n  [javawriter]: https://github.com/square/javapoet/tree/javawriter_2\n  [javawriter_maven]: http://search.maven.org/#artifactdetails%7Ccom.squareup%7Cjavawriter%7C2.5.1%7Cjar\n  [formatter]: http://developer.android.com/reference/java/util/Formatter.html\n"
    },
    {
        "commit_hash": "4e9ad1ea4f3aeeb8cb4201161b9673302fec4c9e",
        "previous_commit_hash": "2afa46c64e730e0efa090d8a526830cd9ffbd2bc",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -50,7 +50,7 @@ that to a `HelloWorld.java` file.\n In this case we write the file to `System.out`, but we could also get it as a string\n (`JavaFile.toString()`) or write it to the file system (`JavaPoet.writeTo()`).\n \n-The [JavaPoet Javadoc][javadoc] catalogs the complete JavaPoet API, which we explore below.\n+The [Javadoc][javadoc] catalogs the complete JavaPoet API, which we explore below.\n \n ### Code & Control Flow\n \n"
    },
    {
        "commit_hash": "8107e2f96ca3b0f3ba21d6dada10097a551dd71b",
        "previous_commit_hash": "4e9ad1ea4f3aeeb8cb4201161b9673302fec4c9e",
        "diff_stats": {
            "additions": 19,
            "deletions": 0
        },
        "diff_content": "@@ -51,6 +51,7 @@ public final class MethodSpec {\n   public final boolean varargs;\n   public final List<TypeName> exceptions;\n   public final CodeBlock code;\n+  public final CodeBlock defaultValue;\n \n   private MethodSpec(Builder builder) {\n     CodeBlock code = builder.code.build();\n@@ -68,6 +69,7 @@ public final class MethodSpec {\n     this.parameters = Util.immutableList(builder.parameters);\n     this.varargs = builder.varargs;\n     this.exceptions = Util.immutableList(builder.exceptions);\n+    this.defaultValue = builder.defaultValue;\n     this.code = code;\n   }\n \n@@ -102,6 +104,12 @@ public final class MethodSpec {\n     }\n \n     codeWriter.emit(\")\");\n+\n+    if (defaultValue != null && !defaultValue.isEmpty()) {\n+      codeWriter.emit(\" default \");\n+      codeWriter.emit(defaultValue);\n+    }\n+\n     if (!exceptions.isEmpty()) {\n       codeWriter.emit(\" throws\");\n       boolean firstException = true;\n@@ -214,6 +222,7 @@ public final class MethodSpec {\n     private final List<TypeName> exceptions = new ArrayList<>();\n     private final CodeBlock.Builder code = CodeBlock.builder();\n     private boolean varargs;\n+    private CodeBlock defaultValue;\n \n     private Builder(String name) {\n       checkArgument(name.equals(CONSTRUCTOR) || SourceVersion.isName(name),\n@@ -328,6 +337,16 @@ public final class MethodSpec {\n       return this;\n     }\n \n+    public Builder defaultValue(String format, Object... args) {\n+      return defaultValue(CodeBlock.builder().add(format, args).build());\n+    }\n+\n+    public Builder defaultValue(CodeBlock codeBlock) {\n+      checkState(this.defaultValue == null, \"defaultValue was already set\");\n+      this.defaultValue = checkNotNull(codeBlock, \"codeBlock == null\");\n+      return this;\n+    }\n+\n     /**\n      * @param controlFlow the control flow construct and its code, such as \"if (foo == 5)\".\n      * Shouldn't contain braces or newline characters.\n"
    },
    {
        "commit_hash": "8107e2f96ca3b0f3ba21d6dada10097a551dd71b",
        "previous_commit_hash": "4e9ad1ea4f3aeeb8cb4201161b9673302fec4c9e",
        "diff_stats": {
            "additions": 19,
            "deletions": 2
        },
        "diff_content": "@@ -98,6 +98,10 @@ public final class TypeSpec {\n         .build());\n   }\n \n+  public static Builder annotationBuilder(String name) {\n+    return new Builder(Kind.ANNOTATION, checkNotNull(name, \"name == null\"), null);\n+  }\n+\n   void emit(CodeWriter codeWriter, String enumName, Set<Modifier> implicitModifiers)\n       throws IOException {\n     // Nested classes interrupt wrapped line indentation. Stash the current wrapping state and put\n@@ -126,7 +130,11 @@ public final class TypeSpec {\n         codeWriter.emitJavadoc(javadoc);\n         codeWriter.emitAnnotations(annotations, false);\n         codeWriter.emitModifiers(modifiers, Util.union(implicitModifiers, kind.asMemberModifiers));\n-        codeWriter.emit(\"$L $L\", kind.name().toLowerCase(Locale.US), name);\n+        if (kind == Kind.ANNOTATION) {\n+          codeWriter.emit(\"$L $L\", \"@interface\", name);\n+        } else {\n+          codeWriter.emit(\"$L $L\", kind.name().toLowerCase(Locale.US), name);\n+        }\n         codeWriter.emitTypeVariables(typeVariables);\n \n         List<TypeName> extendsTypes;\n@@ -262,7 +270,13 @@ public final class TypeSpec {\n         Collections.<Modifier>emptySet(),\n         Collections.<Modifier>emptySet(),\n         Collections.<Modifier>emptySet(),\n-        Collections.singleton(Modifier.STATIC));\n+        Collections.singleton(Modifier.STATIC)),\n+\n+    ANNOTATION(\n+        Util.immutableSet(Arrays.asList(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)),\n+        Util.immutableSet(Arrays.asList(Modifier.PUBLIC, Modifier.ABSTRACT)),\n+        Util.immutableSet(Arrays.asList(Modifier.PUBLIC, Modifier.STATIC)),\n+        Util.immutableSet(Arrays.asList(Modifier.STATIC)));\n \n     private final Set<Modifier> implicitFieldModifiers;\n     private final Set<Modifier> implicitMethodModifiers;\n@@ -424,6 +438,9 @@ public final class TypeSpec {\n       checkArgument(methodSpec.modifiers.containsAll(kind.implicitMethodModifiers),\n           \"%s %s.%s requires modifiers %s\", kind, name, methodSpec.name,\n           kind.implicitMethodModifiers);\n+      if (kind != Kind.ANNOTATION) {\n+        checkState(methodSpec.defaultValue == null, \"default method != null\");\n+      }\n       methodSpecs.add(methodSpec);\n       return this;\n     }\n"
    },
    {
        "commit_hash": "8107e2f96ca3b0f3ba21d6dada10097a551dd71b",
        "previous_commit_hash": "4e9ad1ea4f3aeeb8cb4201161b9673302fec4c9e",
        "diff_stats": {
            "additions": 61,
            "deletions": 0
        },
        "diff_content": "@@ -650,6 +650,59 @@ public final class TypeSpecTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void annotation() throws Exception {\n+    TypeSpec annotation = TypeSpec.annotationBuilder(\"MyAnnotation\")\n+        .addModifiers(Modifier.PUBLIC)\n+        .addMethod(MethodSpec.methodBuilder(\"test\")\n+                .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)\n+                .defaultValue(\"$L\", 0)\n+                .returns(int.class)\n+                .build())\n+        .build();\n+\n+    assertThat(toString(annotation)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"public @interface MyAnnotation {\\n\"\n+        + \"  int test() default 0;\\n\"\n+        + \"}\\n\"\n+    );\n+  }\n+\n+  @Test public void innerAnnotationInAnnotationDeclaration() throws Exception {\n+    TypeSpec bar = TypeSpec.annotationBuilder(\"Bar\")\n+        .addMethod(MethodSpec.methodBuilder(\"value\")\n+            .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)\n+            .defaultValue(\"@$T\", Deprecated.class)\n+            .returns(Deprecated.class)\n+            .build())\n+        .build();\n+\n+    assertThat(toString(bar)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import java.lang.Deprecated;\\n\"\n+        + \"\\n\"\n+        + \"@interface Bar {\\n\"\n+        + \"  Deprecated value() default @Deprecated;\\n\"\n+        + \"}\\n\"\n+    );\n+  }\n+\n+  @Test\n+  public void classCannotHaveDefaultValueForMethod() throws Exception {\n+    try {\n+      TypeSpec.classBuilder(\"Tacos\")\n+          .addMethod(MethodSpec.methodBuilder(\"test\")\n+              .addModifiers(Modifier.PUBLIC)\n+              .defaultValue(\"0\")\n+              .returns(int.class)\n+              .build())\n+          .build();\n+      fail();\n+    } catch (IllegalStateException expected) {}\n+  }\n+\n   @Test public void referencedAndDeclaredSimpleNamesConflict() throws Exception {\n     FieldSpec internalTop = FieldSpec.builder(\n         ClassName.get(tacosPackage, \"Top\"), \"internalTop\").build();\n@@ -1242,6 +1295,14 @@ public final class TypeSpecTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void annotationDeclarationToString() throws Exception {\n+    TypeSpec type = TypeSpec.annotationBuilder(\"Taco\")\n+        .build();\n+    assertThat(type.toString()).isEqualTo(\"\"\n+        + \"@interface Taco {\\n\"\n+        + \"}\\n\");\n+  }\n+\n   private String toString(TypeSpec typeSpec) {\n     return JavaFile.builder(tacosPackage, typeSpec).build().toString();\n   }\n"
    },
    {
        "commit_hash": "8a96c5d5ae0e3ff5f60cee12015703bb7d799cc3",
        "previous_commit_hash": "2191f1c817175fd0b6e815529a71406b22837d47",
        "diff_stats": {
            "additions": 28,
            "deletions": 0
        },
        "diff_content": "@@ -1635,6 +1635,34 @@ public final class TypeSpecTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void ifElse() {\n+    TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n+        .addMethod(\n+            MethodSpec.methodBuilder(\"isDelicious\")\n+                .addParameter(TypeName.INT, \"count\")\n+                .returns(TypeName.BOOLEAN)\n+                .beginControlFlow(\"if (count > 0)\")\n+                .addStatement(\"return true\")\n+                .nextControlFlow(\"else\")\n+                .addStatement(\"return false\")\n+                .endControlFlow()\n+                .build()\n+        )\n+        .build();\n+    assertThat(toString(taco)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"class Taco {\\n\"\n+        + \"  boolean isDelicious(int count) {\\n\"\n+        + \"    if (count > 0) {\\n\"\n+        + \"      return true;\\n\"\n+        + \"    } else {\\n\"\n+        + \"      return false;\\n\"\n+        + \"    }\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n   @Test public void literalFromAnything() {\n     Object value = new Object() {\n       @Override public String toString() {\n"
    },
    {
        "commit_hash": "a167b3ac1102f48ca87ec536b773449d1b369996",
        "previous_commit_hash": "2191f1c817175fd0b6e815529a71406b22837d47",
        "diff_stats": {
            "additions": 3,
            "deletions": 0
        },
        "diff_content": "@@ -366,6 +366,9 @@ public final class TypeSpec {\n     }\n \n     public Builder superclass(TypeName superclass) {\n+      checkState(this.superclass == ClassName.OBJECT,\n+          \"superclass already set to \" + this.superclass);\n+      checkArgument(!superclass.isPrimitive(), \"superclass may not be a primitive\");\n       this.superclass = superclass;\n       return this;\n     }\n"
    },
    {
        "commit_hash": "a167b3ac1102f48ca87ec536b773449d1b369996",
        "previous_commit_hash": "2191f1c817175fd0b6e815529a71406b22837d47",
        "diff_stats": {
            "additions": 16,
            "deletions": 0
        },
        "diff_content": "@@ -1738,6 +1738,22 @@ public final class TypeSpecTest {\n     }\n   }\n \n+  @Test public void invalidSuperClass() {\n+    try {\n+      TypeSpec.classBuilder(\"foo\")\n+          .superclass(ClassName.get(List.class))\n+          .superclass(ClassName.get(Map.class));\n+      fail();\n+    } catch (IllegalStateException expected) {\n+    }\n+    try {\n+      TypeSpec.classBuilder(\"foo\")\n+          .superclass(TypeName.INT);\n+      fail();\n+    } catch (IllegalArgumentException expected) {\n+    }\n+  }\n+\n   private CodeBlock codeBlock(String format, Object... args) {\n     return CodeBlock.builder()\n         .add(format, args)\n"
    },
    {
        "commit_hash": "e2e94bfe9a906d498a05a67f54ac0b2dfd4555ca",
        "previous_commit_hash": "317a01a41619bd3819b0fa1c2c4bd50b951b11ed",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -141,7 +141,7 @@ public final class JavaFile {\n     codeWriter.popPackage();\n   }\n \n-  public String toString() {\n+  @Override public String toString() {\n     try {\n       StringBuilder result = new StringBuilder();\n       writeTo(result);\n"
    },
    {
        "commit_hash": "9afa9fde726f7abbd9b9b1f589f98a157895aa32",
        "previous_commit_hash": "0b2107767d39882b0f896f2dc29970e8bafd3349",
        "diff_stats": {
            "additions": 6,
            "deletions": 0
        },
        "diff_content": "@@ -99,6 +99,12 @@ public final class AnnotationSpec {\n     return builder(ClassName.get(type));\n   }\n \n+  public Builder toBuilder() {\n+    Builder builder = new Builder(type);\n+    builder.members.putAll(members);\n+    return builder;\n+  }\n+\n   @Override public boolean equals(Object o) {\n     return o instanceof AnnotationSpec\n         && ((AnnotationSpec) o).type.equals(type)\n"
    },
    {
        "commit_hash": "9afa9fde726f7abbd9b9b1f589f98a157895aa32",
        "previous_commit_hash": "0b2107767d39882b0f896f2dc29970e8bafd3349",
        "diff_stats": {
            "additions": 7,
            "deletions": 0
        },
        "diff_content": "@@ -86,6 +86,13 @@ public final class CodeBlock {\n     return new Builder();\n   }\n \n+  public Builder toBuilder() {\n+    Builder builder = new Builder();\n+    builder.formatParts.addAll(formatParts);\n+    builder.args.addAll(args);\n+    return builder;\n+  }\n+\n   public static final class Builder {\n     final List<String> formatParts = new ArrayList<>();\n     final List<Object> args = new ArrayList<>();\n"
    },
    {
        "commit_hash": "9afa9fde726f7abbd9b9b1f589f98a157895aa32",
        "previous_commit_hash": "0b2107767d39882b0f896f2dc29970e8bafd3349",
        "diff_stats": {
            "additions": 9,
            "deletions": 0
        },
        "diff_content": "@@ -89,6 +89,15 @@ public final class FieldSpec {\n     return builder(TypeName.get(type), name, modifiers);\n   }\n \n+  public Builder toBuilder() {\n+    Builder builder = new Builder(type, name);\n+    builder.javadoc.add(javadoc);\n+    builder.annotations.addAll(annotations);\n+    builder.modifiers.addAll(modifiers);\n+    builder.initializer = initializer.isEmpty() ? null : initializer;\n+    return builder;\n+  }\n+\n   public static final class Builder {\n     private final TypeName type;\n     private final String name;\n"
    },
    {
        "commit_hash": "9afa9fde726f7abbd9b9b1f589f98a157895aa32",
        "previous_commit_hash": "0b2107767d39882b0f896f2dc29970e8bafd3349",
        "diff_stats": {
            "additions": 8,
            "deletions": 0
        },
        "diff_content": "@@ -157,6 +157,14 @@ public final class JavaFile {\n     return new Builder(packageName, typeSpec);\n   }\n \n+  public Builder toBuilder() {\n+    Builder builder = new Builder(packageName, typeSpec);\n+    builder.fileComment.add(fileComment);\n+    builder.skipJavaLangImports = skipJavaLangImports;\n+    builder.indent = indent;\n+    return builder;\n+  }\n+\n   public static final class Builder {\n     private final String packageName;\n     private final TypeSpec typeSpec;\n"
    },
    {
        "commit_hash": "9afa9fde726f7abbd9b9b1f589f98a157895aa32",
        "previous_commit_hash": "0b2107767d39882b0f896f2dc29970e8bafd3349",
        "diff_stats": {
            "additions": 15,
            "deletions": 0
        },
        "diff_content": "@@ -210,6 +210,21 @@ public final class MethodSpec {\n     return methodBuilder;\n   }\n \n+  public Builder toBuilder() {\n+    Builder builder = new Builder(name);\n+    builder.javadoc.add(javadoc);\n+    builder.annotations.addAll(annotations);\n+    builder.modifiers.addAll(modifiers);\n+    builder.typeVariables.addAll(typeVariables);\n+    builder.returnType = returnType;\n+    builder.parameters.addAll(parameters);\n+    builder.exceptions.addAll(exceptions);\n+    builder.code.add(code);\n+    builder.varargs = varargs;\n+    builder.defaultValue = defaultValue;\n+    return builder;\n+  }\n+\n   public static final class Builder {\n     private final String name;\n \n"
    },
    {
        "commit_hash": "9afa9fde726f7abbd9b9b1f589f98a157895aa32",
        "previous_commit_hash": "0b2107767d39882b0f896f2dc29970e8bafd3349",
        "diff_stats": {
            "additions": 7,
            "deletions": 0
        },
        "diff_content": "@@ -79,6 +79,13 @@ public final class ParameterSpec {\n     return builder(TypeName.get(type), name, modifiers);\n   }\n \n+  public Builder toBuilder() {\n+    Builder builder = new Builder(type, name);\n+    builder.annotations.addAll(annotations);\n+    builder.modifiers.addAll(modifiers);\n+    return builder;\n+  }\n+\n   public static final class Builder {\n     private final TypeName type;\n     private final String name;\n"
    },
    {
        "commit_hash": "9afa9fde726f7abbd9b9b1f589f98a157895aa32",
        "previous_commit_hash": "0b2107767d39882b0f896f2dc29970e8bafd3349",
        "diff_stats": {
            "additions": 15,
            "deletions": 0
        },
        "diff_content": "@@ -102,6 +102,21 @@ public final class TypeSpec {\n     return new Builder(Kind.ANNOTATION, checkNotNull(name, \"name == null\"), null);\n   }\n \n+  public Builder toBuilder() {\n+    Builder builder = new Builder(kind, name, anonymousTypeArguments);\n+    builder.javadoc.add(javadoc);\n+    builder.annotations.addAll(annotations);\n+    builder.modifiers.addAll(modifiers);\n+    builder.typeVariables.addAll(typeVariables);\n+    builder.superclass = superclass;\n+    builder.superinterfaces.addAll(superinterfaces);\n+    builder.enumConstants.putAll(enumConstants);\n+    builder.fieldSpecs.addAll(fieldSpecs);\n+    builder.methodSpecs.addAll(methodSpecs);\n+    builder.typeSpecs.addAll(typeSpecs);\n+    return builder;\n+  }\n+\n   void emit(CodeWriter codeWriter, String enumName, Set<Modifier> implicitModifiers)\n       throws IOException {\n     // Nested classes interrupt wrapped line indentation. Stash the current wrapping state and put\n"
    },
    {
        "commit_hash": "34961b1c0ace6aac0d763b7114ae3b5856105396",
        "previous_commit_hash": "36111773c3e068934e2fb26df7084be3b90aee7c",
        "diff_stats": {
            "additions": 2,
            "deletions": 1
        },
        "diff_content": "@@ -15,6 +15,7 @@\n  */\n package com.squareup.javapoet;\n \n+import com.google.common.jimfs.Configuration;\n import com.google.common.jimfs.Jimfs;\n import java.io.File;\n import java.io.IOException;\n@@ -40,7 +41,7 @@ public final class FileWritingTest {\n   @Rule public final TemporaryFolder tmp = new TemporaryFolder();\n \n   // Used for testing java.nio.file Path behavior.\n-  private final FileSystem fs = Jimfs.newFileSystem();\n+  private final FileSystem fs = Jimfs.newFileSystem(Configuration.unix());\n   private final Path fsRoot = fs.getRootDirectories().iterator().next();\n \n   // Used for testing annotation processor Filer behavior.\n"
    },
    {
        "commit_hash": "f70f8715e340eb0bada170ec44a4f1e5b528e380",
        "previous_commit_hash": "34961b1c0ace6aac0d763b7114ae3b5856105396",
        "diff_stats": {
            "additions": 2,
            "deletions": 1
        },
        "diff_content": "@@ -70,7 +70,8 @@ public final class FileWritingTest {\n       javaFile.writeTo(file);\n       fail();\n     } catch (IllegalArgumentException e) {\n-      assertThat(e.getMessage()).containsMatch(\"path .*?/foo/bar exists but is not a directory.\");\n+      assertThat(e.getMessage()).isEqualTo(\n+          \"path \" + file.getPath() + \" exists but is not a directory.\");\n     }\n   }\n \n"
    },
    {
        "commit_hash": "723a03d10c30cf47bb7865f7bdbe9fc0c3979b29",
        "previous_commit_hash": "36111773c3e068934e2fb26df7084be3b90aee7c",
        "diff_stats": {
            "additions": 31,
            "deletions": 8
        },
        "diff_content": "@@ -22,12 +22,14 @@ import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.EnumSet;\n import java.util.Iterator;\n import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n import java.util.Set;\n+\n import javax.lang.model.SourceVersion;\n import javax.lang.model.element.Element;\n import javax.lang.model.element.Modifier;\n@@ -35,6 +37,8 @@ import javax.lang.model.element.Modifier;\n import static com.squareup.javapoet.Util.checkArgument;\n import static com.squareup.javapoet.Util.checkNotNull;\n import static com.squareup.javapoet.Util.checkState;\n+import static com.squareup.javapoet.Util.hasDefaultModifier;\n+import static com.squareup.javapoet.Util.requireExactlyOneOf;\n \n /** A generated class, interface, or enum declaration. */\n public final class TypeSpec {\n@@ -429,9 +433,14 @@ public final class TypeSpec {\n     }\n \n     public Builder addField(FieldSpec fieldSpec) {\n-      checkArgument(fieldSpec.modifiers.containsAll(kind.implicitFieldModifiers),\n-          \"%s %s.%s requires modifiers %s\", kind, name, fieldSpec.name,\n-          kind.implicitFieldModifiers);\n+      checkState(kind != Kind.ANNOTATION, \"%s %s cannot have fields\", kind, name);\n+      if (kind == Kind.INTERFACE) {\n+        requireExactlyOneOf(EnumSet.of(Modifier.PUBLIC, Modifier.PRIVATE),\n+            fieldSpec.modifiers);\n+        Set<Modifier> check = EnumSet.of(Modifier.STATIC, Modifier.FINAL);\n+        checkState(fieldSpec.modifiers.containsAll(check), \"%s %s.%s requires modifiers %s\",\n+            kind, name, fieldSpec.name, check);\n+      }\n       fieldSpecs.add(fieldSpec);\n       return this;\n     }\n@@ -453,11 +462,25 @@ public final class TypeSpec {\n     }\n \n     public Builder addMethod(MethodSpec methodSpec) {\n-      checkArgument(methodSpec.modifiers.containsAll(kind.implicitMethodModifiers),\n-          \"%s %s.%s requires modifiers %s\", kind, name, methodSpec.name,\n-          kind.implicitMethodModifiers);\n+      if (kind == Kind.INTERFACE) {\n+        Set<Modifier> mods = EnumSet.of(Modifier.ABSTRACT, Modifier.STATIC);\n+        if (Util.DEFAULT != null) {\n+          mods.add(Util.DEFAULT);\n+        }\n+        requireExactlyOneOf(mods, methodSpec.modifiers);\n+        requireExactlyOneOf(EnumSet.of(Modifier.PUBLIC, Modifier.PRIVATE),\n+            methodSpec.modifiers);\n+      } else if (kind == Kind.ANNOTATION) {\n+        checkState(methodSpec.modifiers.containsAll(kind.implicitMethodModifiers),\n+            \"%s %s.%s cannot have modifiers\", kind, name, methodSpec.name);\n+      }\n       if (kind != Kind.ANNOTATION) {\n-        checkState(methodSpec.defaultValue == null, \"default method != null\");\n+        checkState(methodSpec.defaultValue == null, \"%s %s.%s cannot have a default value\",\n+            kind, name, methodSpec.name);\n+      }\n+      if (kind != Kind.INTERFACE) {\n+        checkState(!hasDefaultModifier(methodSpec.modifiers), \"%s %s.%s cannot be default\",\n+            kind, name, methodSpec.name);\n       }\n       methodSpecs.add(methodSpec);\n       return this;\n@@ -474,7 +497,7 @@ public final class TypeSpec {\n     public Builder addType(TypeSpec typeSpec) {\n       checkArgument(typeSpec.modifiers.containsAll(kind.implicitTypeModifiers),\n           \"%s %s.%s requires modifiers %s\", kind, name, typeSpec.name,\n-          kind.implicitFieldModifiers);\n+          kind.implicitTypeModifiers);\n       typeSpecs.add(typeSpec);\n       return this;\n     }\n"
    },
    {
        "commit_hash": "723a03d10c30cf47bb7865f7bdbe9fc0c3979b29",
        "previous_commit_hash": "36111773c3e068934e2fb26df7084be3b90aee7c",
        "diff_stats": {
            "additions": 71,
            "deletions": 0
        },
        "diff_content": "@@ -24,6 +24,8 @@ import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n+import javax.lang.model.element.Modifier;\n+\n /**\n  * Like Guava, but worse and standalone. This makes it easier to mix JavaPoet with libraries that\n  * bring their own version of Guava.\n@@ -32,6 +34,16 @@ final class Util {\n   private Util() {\n   }\n \n+  public static final Modifier DEFAULT;\n+  static {\n+    Modifier def = null;\n+    try {\n+      def = Modifier.valueOf(\"DEFAULT\");\n+    } catch (IllegalArgumentException ignored) {\n+    }\n+    DEFAULT = def;\n+  }\n+\n   public static <K, V> Map<K, List<V>> immutableMultimap(Map<K, List<V>> multimap) {\n     LinkedHashMap<K, List<V>> result = new LinkedHashMap<>();\n     for (Map.Entry<K, List<V>> entry : multimap.entrySet()) {\n@@ -82,4 +94,63 @@ final class Util {\n     result.addAll(b);\n     return result;\n   }\n+\n+  public static <T> Set<Set<T>> powerSet(Set<T> originalSet) {\n+    Set<Set<T>> sets = new LinkedHashSet<>();\n+    if (originalSet.isEmpty()) {\n+      sets.add(new LinkedHashSet<T>());\n+      return sets;\n+    }\n+    List<T> list = new ArrayList<T>(originalSet);\n+    T head = list.get(0);\n+    Set<T> rest = new LinkedHashSet<T>(list.subList(1, list.size()));\n+    for (Set<T> set : powerSet(rest)) {\n+      Set<T> newSet = new LinkedHashSet<T>();\n+      newSet.add(head);\n+      newSet.addAll(set);\n+      sets.add(newSet);\n+      sets.add(set);\n+    }\n+    return sets;\n+}\n+\n+  /**\n+   * Finds a subset of {@code set} in {@code modifiers}. Ignores empty subsets,\n+   * and if {@code set} is empty then {@code true} is always returned.\n+   *\n+   * @param modifiers\n+   *          - The input modifiers\n+   * @param set\n+   *          - The set of modifiers to make subsets of\n+   */\n+  public static void requireSubsetOf(Set<Modifier> set, Set<Modifier> modifiers) {\n+    Set<Set<Modifier>> powerSet = powerSet(set);\n+    boolean containsSubset = set.isEmpty();\n+    for (Set<Modifier> subset : powerSet) {\n+      if (subset.isEmpty()) {\n+        continue;\n+      }\n+      containsSubset |= modifiers.containsAll(subset);\n+    }\n+    checkState(containsSubset, \"%s should contain a subset of %s\", modifiers, set);\n+  }\n+\n+  public static void requireExactlyOneOf(Set<Modifier> set, Set<Modifier> modifiers) {\n+    boolean containsOne = false;\n+    boolean containsMany = false;\n+    for (Modifier check : set) {\n+      boolean containsCheck = modifiers.contains(check);\n+      containsMany = containsOne && containsCheck;\n+      if (containsMany) {\n+        break;\n+      }\n+      containsOne |= containsCheck;\n+    }\n+    checkState(containsOne, \"%s must contain one of %s\", modifiers, set);\n+    checkState(!containsMany, \"%s must contain only one of %s\", modifiers, set);\n+  }\n+\n+  public static boolean hasDefaultModifier(Collection<Modifier> modifiers) {\n+    return DEFAULT != null && modifiers.contains(DEFAULT);\n+  }\n }\n"
    },
    {
        "commit_hash": "723a03d10c30cf47bb7865f7bdbe9fc0c3979b29",
        "previous_commit_hash": "36111773c3e068934e2fb26df7084be3b90aee7c",
        "diff_stats": {
            "additions": 45,
            "deletions": 0
        },
        "diff_content": "@@ -17,6 +17,7 @@ package com.squareup.javapoet;\n \n import com.google.common.collect.ImmutableMap;\n import com.google.testing.compile.CompilationRule;\n+\n import java.io.IOException;\n import java.io.Serializable;\n import java.math.BigDecimal;\n@@ -30,10 +31,12 @@ import java.util.Locale;\n import java.util.Map;\n import java.util.NoSuchElementException;\n import java.util.Random;\n+\n import javax.lang.model.element.Element;\n import javax.lang.model.element.Modifier;\n import javax.lang.model.element.TypeElement;\n import javax.lang.model.type.TypeMirror;\n+\n import org.junit.Rule;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n@@ -42,6 +45,7 @@ import org.mockito.Mockito;\n \n import static com.google.common.truth.Truth.assertThat;\n import static org.junit.Assert.fail;\n+import static org.junit.Assume.assumeTrue;\n \n @RunWith(JUnit4.class)\n public final class TypeSpecTest {\n@@ -54,6 +58,10 @@ public final class TypeSpecTest {\n     return compilation.getElements().getTypeElement(clazz.getCanonicalName());\n   }\n \n+  private boolean isJava8() {\n+    return Util.DEFAULT != null;\n+  }\n+\n   @Test public void basic() throws Exception {\n     TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n         .addMethod(MethodSpec.methodBuilder(\"toString\")\n@@ -703,6 +711,43 @@ public final class TypeSpecTest {\n     } catch (IllegalStateException expected) {}\n   }\n \n+  @Test\n+  public void classCannotHaveDefaultMethods() throws Exception {\n+    assumeTrue(isJava8());\n+    try {\n+      TypeSpec.classBuilder(\"Tacos\")\n+          .addMethod(MethodSpec.methodBuilder(\"test\")\n+              .addModifiers(Modifier.PUBLIC, Modifier.valueOf(\"DEFAULT\"))\n+              .returns(int.class)\n+              .addCode(CodeBlock.builder().addStatement(\"return 0\").build())\n+              .build())\n+          .build();\n+      fail();\n+    } catch (IllegalStateException expected) {}\n+  }\n+\n+  @Test\n+  public void interfaceDefaultMethods() throws Exception {\n+    assumeTrue(isJava8());\n+    TypeSpec bar = TypeSpec.interfaceBuilder(\"Tacos\")\n+        .addMethod(MethodSpec.methodBuilder(\"test\")\n+            .addModifiers(Modifier.PUBLIC, Modifier.valueOf(\"DEFAULT\"))\n+            .returns(int.class)\n+            .addCode(CodeBlock.builder().addStatement(\"return 0\").build())\n+            .build())\n+        .build();\n+    \n+    assertThat(toString(bar)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"interface Tacos {\\n\"\n+        + \"  default int test() {\\n\"\n+        + \"    return 0;\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\"\n+    );\n+  }\n+\n   @Test public void referencedAndDeclaredSimpleNamesConflict() throws Exception {\n     FieldSpec internalTop = FieldSpec.builder(\n         ClassName.get(tacosPackage, \"Top\"), \"internalTop\").build();\n"
    },
    {
        "commit_hash": "40cd658cc8ae1e3c03b5a91f4d1dcfd529ae1795",
        "previous_commit_hash": "14216e0ec71a1f622d4f4ae4d7ca4aa0aa4f3d16",
        "diff_stats": {
            "additions": 3,
            "deletions": 10
        },
        "diff_content": "@@ -29,7 +29,6 @@ import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n import java.util.Set;\n-\n import javax.lang.model.SourceVersion;\n import javax.lang.model.element.Element;\n import javax.lang.model.element.Modifier;\n@@ -435,8 +434,7 @@ public final class TypeSpec {\n     public Builder addField(FieldSpec fieldSpec) {\n       checkState(kind != Kind.ANNOTATION, \"%s %s cannot have fields\", kind, name);\n       if (kind == Kind.INTERFACE) {\n-        requireExactlyOneOf(EnumSet.of(Modifier.PUBLIC, Modifier.PRIVATE),\n-            fieldSpec.modifiers);\n+        requireExactlyOneOf(fieldSpec.modifiers, Modifier.PUBLIC, Modifier.PRIVATE);\n         Set<Modifier> check = EnumSet.of(Modifier.STATIC, Modifier.FINAL);\n         checkState(fieldSpec.modifiers.containsAll(check), \"%s %s.%s requires modifiers %s\",\n             kind, name, fieldSpec.name, check);\n@@ -463,13 +461,8 @@ public final class TypeSpec {\n \n     public Builder addMethod(MethodSpec methodSpec) {\n       if (kind == Kind.INTERFACE) {\n-        Set<Modifier> mods = EnumSet.of(Modifier.ABSTRACT, Modifier.STATIC);\n-        if (Util.DEFAULT != null) {\n-          mods.add(Util.DEFAULT);\n-        }\n-        requireExactlyOneOf(mods, methodSpec.modifiers);\n-        requireExactlyOneOf(EnumSet.of(Modifier.PUBLIC, Modifier.PRIVATE),\n-            methodSpec.modifiers);\n+        requireExactlyOneOf(methodSpec.modifiers, Modifier.ABSTRACT, Modifier.STATIC, Util.DEFAULT);\n+        requireExactlyOneOf(methodSpec.modifiers, Modifier.PUBLIC, Modifier.PRIVATE);\n       } else if (kind == Kind.ANNOTATION) {\n         checkState(methodSpec.modifiers.containsAll(kind.implicitMethodModifiers),\n             \"%s %s.%s cannot have modifiers\", kind, name, methodSpec.name);\n"
    },
    {
        "commit_hash": "40cd658cc8ae1e3c03b5a91f4d1dcfd529ae1795",
        "previous_commit_hash": "14216e0ec71a1f622d4f4ae4d7ca4aa0aa4f3d16",
        "diff_stats": {
            "additions": 7,
            "deletions": 53
        },
        "diff_content": "@@ -23,7 +23,6 @@ import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n-\n import javax.lang.model.element.Modifier;\n \n /**\n@@ -34,6 +33,7 @@ final class Util {\n   private Util() {\n   }\n \n+  /** Modifier.DEFAULT doesn't exist until Java 8, but we want to run on earlier releases. */\n   public static final Modifier DEFAULT;\n   static {\n     Modifier def = null;\n@@ -95,59 +95,13 @@ final class Util {\n     return result;\n   }\n \n-  public static <T> Set<Set<T>> powerSet(Set<T> originalSet) {\n-    Set<Set<T>> sets = new LinkedHashSet<>();\n-    if (originalSet.isEmpty()) {\n-      sets.add(new LinkedHashSet<T>());\n-      return sets;\n-    }\n-    List<T> list = new ArrayList<T>(originalSet);\n-    T head = list.get(0);\n-    Set<T> rest = new LinkedHashSet<T>(list.subList(1, list.size()));\n-    for (Set<T> set : powerSet(rest)) {\n-      Set<T> newSet = new LinkedHashSet<T>();\n-      newSet.add(head);\n-      newSet.addAll(set);\n-      sets.add(newSet);\n-      sets.add(set);\n-    }\n-    return sets;\n-}\n-\n-  /**\n-   * Finds a subset of {@code set} in {@code modifiers}. Ignores empty subsets,\n-   * and if {@code set} is empty then {@code true} is always returned.\n-   *\n-   * @param modifiers\n-   *          - The input modifiers\n-   * @param set\n-   *          - The set of modifiers to make subsets of\n-   */\n-  public static void requireSubsetOf(Set<Modifier> set, Set<Modifier> modifiers) {\n-    Set<Set<Modifier>> powerSet = powerSet(set);\n-    boolean containsSubset = set.isEmpty();\n-    for (Set<Modifier> subset : powerSet) {\n-      if (subset.isEmpty()) {\n-        continue;\n-      }\n-      containsSubset |= modifiers.containsAll(subset);\n-    }\n-    checkState(containsSubset, \"%s should contain a subset of %s\", modifiers, set);\n-  }\n-\n-  public static void requireExactlyOneOf(Set<Modifier> set, Set<Modifier> modifiers) {\n-    boolean containsOne = false;\n-    boolean containsMany = false;\n-    for (Modifier check : set) {\n-      boolean containsCheck = modifiers.contains(check);\n-      containsMany = containsOne && containsCheck;\n-      if (containsMany) {\n-        break;\n-      }\n-      containsOne |= containsCheck;\n+  public static void requireExactlyOneOf(Set<Modifier> modifiers, Modifier... mutuallyExclusive) {\n+    int count = 0;\n+    for (Modifier check : mutuallyExclusive) {\n+      if (check == null && Util.DEFAULT == null) continue; // Skip 'DEFAULT' if it doesn't exist!\n+      if (modifiers.contains(check)) count++;\n     }\n-    checkState(containsOne, \"%s must contain one of %s\", modifiers, set);\n-    checkState(!containsMany, \"%s must contain only one of %s\", modifiers, set);\n+    checkArgument(count == 1, \"%s must contain one of %s\", modifiers, mutuallyExclusive);\n   }\n \n   public static boolean hasDefaultModifier(Collection<Modifier> modifiers) {\n"
    },
    {
        "commit_hash": "cb9c84b19cf23caec9ba667378f8ce6089bb02cb",
        "previous_commit_hash": "50e568dd2af19945c6040147a4d2c45a6a096618",
        "diff_stats": {
            "additions": 4,
            "deletions": 0
        },
        "diff_content": "@@ -49,6 +49,7 @@ final class CodeWriter {\n   private final List<TypeSpec> typeSpecStack = new ArrayList<>();\n   private final Map<ClassName, String> importedTypes;\n   private final Set<ClassName> importableTypes = new LinkedHashSet<>();\n+  private final Set<String> referencedNames = new LinkedHashSet<>();\n   private boolean trailingNewline;\n \n   /**\n@@ -280,6 +281,7 @@ final class CodeWriter {\n       String importedName = importedTypes.get(className);\n       if (importedName != null) {\n         if (!javadoc) importableTypes.add(className);\n+        referencedNames.add(importedName);\n         return importedName;\n       }\n \n@@ -301,6 +303,7 @@ final class CodeWriter {\n       return className.simpleName(); // Special case: a class referring to itself!\n     }\n \n+    referencedNames.add(classNames.get(0));\n     return Util.join(\".\", classNames.subList(prefixLength, classNames.size()));\n   }\n \n@@ -391,6 +394,7 @@ final class CodeWriter {\n     // Find the simple names that can be imported, and the classes that they target.\n     Map<String, ClassName> simpleNameToType = new LinkedHashMap<>();\n     for (ClassName className : importableTypes) {\n+      if (referencedNames.contains(className.simpleName())) continue;\n       if (simpleNameToType.containsKey(className.simpleName())) continue;\n       simpleNameToType.put(className.simpleName(), className);\n     }\n"
    },
    {
        "commit_hash": "cb9c84b19cf23caec9ba667378f8ce6089bb02cb",
        "previous_commit_hash": "50e568dd2af19945c6040147a4d2c45a6a096618",
        "diff_stats": {
            "additions": 19,
            "deletions": 0
        },
        "diff_content": "@@ -811,6 +811,25 @@ public final class TypeSpecTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void simpleNamesConflictInThisAndOtherPackage() throws Exception {\n+    FieldSpec internalOther = FieldSpec.builder(\n+        ClassName.get(tacosPackage, \"Other\"), \"internalOther\").build();\n+    FieldSpec externalOther = FieldSpec.builder(\n+        ClassName.get(donutsPackage, \"Other\"), \"externalOther\").build();\n+    TypeSpec gen = TypeSpec.classBuilder(\"Gen\")\n+        .addField(internalOther)\n+        .addField(externalOther)\n+        .build();\n+    assertThat(toString(gen)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"class Gen {\\n\"\n+        + \"  Other internalOther;\\n\"\n+        + \"\\n\"\n+        + \"  com.squareup.donuts.Other externalOther;\\n\"\n+        + \"}\\n\");\n+  }\n+\n   @Test public void originatingElementsIncludesThoseOfNestedTypes() {\n     Element outerElement = Mockito.mock(Element.class);\n     Element innerElement = Mockito.mock(Element.class);\n"
    },
    {
        "commit_hash": "8d7e0a0d6909d50e967c602d20fd78d0a2ec8633",
        "previous_commit_hash": "bc3c8cad524f0441ef775ae617b83689b8418089",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -47,7 +47,7 @@ import static com.squareup.javapoet.Util.checkState;\n  *       MethodSpec methods}, and {@linkplain TypeSpec types}.\n  *   <li>{@code $S} escapes the value as a <em>string</em>, wraps it with double quotes, and emits\n  *       that. For example, {@code 6\" sandwich} is emitted {@code \"6\\\" sandwich\"}.\n- *   <li>{@code T} emits a <em>type</em> reference. Types will be imported if possible. Arguments\n+ *   <li>{@code $T} emits a <em>type</em> reference. Types will be imported if possible. Arguments\n  *       for types may be {@linkplain Class classes}, {@linkplain javax.lang.model.type.TypeMirror\n ,*       type mirrors}, and {@linkplain javax.lang.model.element.Element elements}.\n  *   <li>{@code $$} emits a dollar sign.\n"
    },
    {
        "commit_hash": "83e5d0c7ee9fc741847b7596096ec6f9d7450bbb",
        "previous_commit_hash": "bc3c8cad524f0441ef775ae617b83689b8418089",
        "diff_stats": {
            "additions": 3,
            "deletions": 1
        },
        "diff_content": "@@ -16,6 +16,7 @@\n package com.squareup.javapoet;\n \n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.LinkedHashMap;\n@@ -101,7 +102,8 @@ final class Util {\n       if (check == null && Util.DEFAULT == null) continue; // Skip 'DEFAULT' if it doesn't exist!\n       if (modifiers.contains(check)) count++;\n     }\n-    checkArgument(count == 1, \"%s must contain one of %s\", modifiers, mutuallyExclusive);\n+    checkArgument(count == 1, \"modifiers %s must contain one of %s\",\n+            modifiers, Arrays.toString(mutuallyExclusive));\n   }\n \n   public static boolean hasDefaultModifier(Collection<Modifier> modifiers) {\n"
    },
    {
        "commit_hash": "2288620db87cb0a134bf61ae277b48f28895271a",
        "previous_commit_hash": "28a40bbfe4e5cf03716cd010a70ce502714df470",
        "diff_stats": {
            "additions": 2,
            "deletions": 1
        },
        "diff_content": "@@ -104,7 +104,8 @@ public final class ClassName extends TypeName implements Comparable<ClassName> {\n     for (Class<?> c = clazz; c != null; c = c.getEnclosingClass()) {\n       names.add(c.getSimpleName());\n     }\n-    names.add(clazz.getPackage().getName());\n+    if (clazz.getPackage() != null)\n+      names.add(clazz.getPackage().getName());\n     Collections.reverse(names);\n     return new ClassName(names);\n   }\n"
    },
    {
        "commit_hash": "2ae53e321dbc6dc240af086ccfa109d1646ff9ca",
        "previous_commit_hash": "84e27b97892d68cf48e48428f6602918bceec3e9",
        "diff_stats": {
            "additions": 2,
            "deletions": 1
        },
        "diff_content": "@@ -104,8 +104,9 @@ public final class ClassName extends TypeName implements Comparable<ClassName> {\n     for (Class<?> c = clazz; c != null; c = c.getEnclosingClass()) {\n       names.add(c.getSimpleName());\n     }\n-    if (clazz.getPackage() != null)\n+    if (clazz.getPackage() != null) {\n       names.add(clazz.getPackage().getName());\n+    }\n     Collections.reverse(names);\n     return new ClassName(names);\n   }\n"
    },
    {
        "commit_hash": "937b404cf3905d686e5b41ed66275628937f00ab",
        "previous_commit_hash": "2ae53e321dbc6dc240af086ccfa109d1646ff9ca",
        "diff_stats": {
            "additions": 66,
            "deletions": 0
        },
        "diff_content": "@@ -25,6 +25,14 @@ import java.util.Map;\n \n import static com.squareup.javapoet.Util.checkNotNull;\n \n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.AnnotationValue;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.util.SimpleAnnotationValueVisitor7;\n+\n /** A generated annotation on a declaration. */\n public final class AnnotationSpec {\n   public final TypeName type;\n@@ -90,6 +98,18 @@ public final class AnnotationSpec {\n     codeWriter.emit(whitespace + \"}\");\n   }\n \n+  public static AnnotationSpec get(AnnotationMirror annotation) {\n+    TypeElement element = (TypeElement) annotation.getAnnotationType().asElement();\n+    AnnotationSpec.Builder builder = AnnotationSpec.builder(ClassName.get(element));\n+    Visitor visitor = new Visitor(builder);\n+    for (ExecutableElement executableElement : annotation.getElementValues().keySet()) {\n+      String name = executableElement.getSimpleName().toString();\n+      AnnotationValue value = annotation.getElementValues().get(executableElement);\n+      value.accept(visitor, new Entry(name, value));\n+    }\n+    return builder.build();\n+  }\n+\n   public static Builder builder(ClassName type) {\n     checkNotNull(type, \"type == null\");\n     return new Builder(type);\n@@ -152,4 +172,50 @@ public final class AnnotationSpec {\n       return new AnnotationSpec(this);\n     }\n   }\n+\n+  /**\n+   * Tuple of name and value.\n+   */\n+  private static class Entry {\n+    final String name;\n+    final AnnotationValue value;\n+\n+    Entry(String name, AnnotationValue value) {\n+      this.name = name;\n+      this.value = value;\n+    }\n+  }\n+\n+  /**\n+   * Annotation value visitor adding members to the given builder instance.\n+   */\n+  private static class Visitor extends SimpleAnnotationValueVisitor7<Builder, Entry> {\n+    final Builder builder;\n+\n+    Visitor(Builder builder) {\n+      super(builder);\n+      this.builder = builder;\n+    }\n+\n+    @Override\n+    protected Builder defaultAction(Object o, Entry entry) {\n+      return builder.addMember(entry.name, \"$L\", entry.value);\n+    }\n+\n+    @Override\n+    public Builder visitAnnotation(AnnotationMirror a, Entry entry) {\n+      return builder.addMember(entry.name, \"$L\", get(a));\n+    }\n+\n+    @Override\n+    public Builder visitEnumConstant(VariableElement c, Entry entry) {\n+      return builder.addMember(entry.name, \"$T.$L\", c.asType(), c.getSimpleName());\n+    }\n+\n+    @Override\n+    public Builder visitType(TypeMirror t, Entry entry) {\n+      return builder.addMember(entry.name, \"$T.class\", t);\n+    }\n+  }\n+\n }\n"
    },
    {
        "commit_hash": "937b404cf3905d686e5b41ed66275628937f00ab",
        "previous_commit_hash": "2ae53e321dbc6dc240af086ccfa109d1646ff9ca",
        "diff_stats": {
            "additions": 148,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright (C) 2015 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javapoet;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.annotation.Inherited;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+import javax.lang.model.element.TypeElement;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import com.google.testing.compile.CompilationRule;\n+\n+public final class AnnotationSpecTest {\n+\n+  @Retention(RetentionPolicy.RUNTIME)\n+  public @interface AnnotationA {\n+  }\n+\n+  @Inherited\n+  @Retention(RetentionPolicy.RUNTIME)\n+  public @interface AnnotationB {\n+  }\n+\n+  @Retention(RetentionPolicy.RUNTIME)\n+  public @interface AnnotationC {\n+    String value();\n+  }\n+\n+  static enum Breakfast {\n+    WAFFLES, PANCAKES\n+  }\n+\n+  @Retention(RetentionPolicy.RUNTIME)\n+  public @interface HasDefaultsAnnotation {\n+\n+    byte a() default 5;\n+\n+    short b() default 6;\n+\n+    int c() default 7;\n+\n+    long d() default 8;\n+\n+    float e() default 9.0f;\n+\n+    double f() default 10.0;\n+\n+    char g() default 'k';\n+\n+    boolean h() default true;\n+\n+    Breakfast i() default Breakfast.WAFFLES;\n+\n+    AnnotationA j() default @AnnotationA();\n+\n+    String k() default \"maple\";\n+\n+    Class<? extends Annotation> l() default AnnotationB.class;\n+\n+    int[] m() default {1, 2, 3};\n+\n+    Breakfast[] n() default {Breakfast.WAFFLES, Breakfast.PANCAKES};\n+\n+    Breakfast o();\n+\n+    int p();\n+\n+    AnnotationC q() default @AnnotationC(\"foo\");\n+  }\n+\n+  @HasDefaultsAnnotation(\n+      o = Breakfast.PANCAKES,\n+      p = 1701,\n+      f = 11.1,\n+      m = {9, 8, 1},\n+      l = Override.class,\n+      j = @AnnotationA,\n+      q = @AnnotationC(\"bar\"))\n+  public class IsAnnotated {\n+    // empty\n+  }\n+\n+  @Rule\n+  public final CompilationRule compilation = new CompilationRule();\n+\n+  @Test\n+  public void testHasDefaultAnnotation() {\n+    String name = IsAnnotated.class.getCanonicalName();\n+    TypeElement element = compilation.getElements().getTypeElement(name);\n+    AnnotationSpec annotation = AnnotationSpec.get(element.getAnnotationMirrors().get(0));\n+    assertThat(annotation.toString()).isEqualTo(\n+        \"@com.squareup.javapoet.AnnotationSpecTest.HasDefaultsAnnotation(\"\n+            + \"o = com.squareup.javapoet.AnnotationSpecTest.Breakfast.PANCAKES\"\n+            + \", p = 1701\"\n+            + \", f = 11.1\"\n+            + \", m = {9, 8, 1}\"\n+            + \", l = java.lang.Override.class\"\n+            + \", j = @com.squareup.javapoet.AnnotationSpecTest.AnnotationA\"\n+            + \", q = @com.squareup.javapoet.AnnotationSpecTest.AnnotationC(\\\"bar\\\")\"\n+            + \")\");\n+  }\n+\n+  @Test\n+  public void testHasDefaultAnnotationWithImport() {\n+    String name = IsAnnotated.class.getCanonicalName();\n+    TypeElement element = compilation.getElements().getTypeElement(name);\n+    AnnotationSpec annotation = AnnotationSpec.get(element.getAnnotationMirrors().get(0));\n+    TypeSpec.Builder typeBuilder = TypeSpec.classBuilder(IsAnnotated.class.getSimpleName());\n+    typeBuilder.addAnnotation(annotation);\n+    JavaFile file = JavaFile.builder(\"com.squareup.javapoet\", typeBuilder.build()).build();\n+    assertThat(file.toString()).isEqualTo(\n+        \"package com.squareup.javapoet;\\n\"\n+            + \"\\n\"\n+            + \"import java.lang.Override;\\n\"\n+            + \"\\n\"\n+            + \"@AnnotationSpecTest.HasDefaultsAnnotation(\\n\"\n+            + \"    o = AnnotationSpecTest.Breakfast.PANCAKES,\\n\"\n+            + \"    p = 1701,\\n\"\n+            + \"    f = 11.1,\\n\"\n+            + \"    m = {9, 8, 1},\\n\"\n+            + \"    l = Override.class,\\n\"\n+            + \"    j = @AnnotationSpecTest.AnnotationA,\\n\"\n+            + \"    q = @AnnotationSpecTest.AnnotationC(\\\"bar\\\")\\n\"\n+            + \")\\n\"\n+            + \"class IsAnnotated {\\n\"\n+            + \"}\\n\"\n+    );\n+  }\n+}\n"
    },
    {
        "commit_hash": "da9e893102bebde02ff01cca95ea084ce521cbf9",
        "previous_commit_hash": "2ae53e321dbc6dc240af086ccfa109d1646ff9ca",
        "diff_stats": {
            "additions": 24,
            "deletions": 0
        },
        "diff_content": "@@ -15,10 +15,13 @@\n  */\n package com.squareup.javapoet;\n \n+import java.io.ByteArrayInputStream;\n import java.io.File;\n import java.io.IOException;\n+import java.io.InputStream;\n import java.io.OutputStreamWriter;\n import java.io.Writer;\n+import java.net.URI;\n import java.nio.file.Files;\n import java.nio.file.Path;\n import java.util.Collections;\n@@ -28,6 +31,8 @@ import javax.annotation.processing.Filer;\n import javax.lang.model.element.Element;\n import javax.lang.model.element.Modifier;\n import javax.tools.JavaFileObject;\n+import javax.tools.JavaFileObject.Kind;\n+import javax.tools.SimpleJavaFileObject;\n \n import static com.squareup.javapoet.Util.checkArgument;\n import static com.squareup.javapoet.Util.checkNotNull;\n@@ -151,6 +156,25 @@ public final class JavaFile {\n     }\n   }\n \n+  public JavaFileObject toJavaFileObject() {\n+    URI uri = URI.create((packageName.isEmpty()\n+        ? typeSpec.name\n+        : packageName.replace('.', '/') + '/' + typeSpec.name)\n+        + Kind.SOURCE.extension);\n+    return new SimpleJavaFileObject(uri, Kind.SOURCE) {\n+      private final long lastModified = System.currentTimeMillis();\n+      @Override public String getCharContent(boolean ignoreEncodingErrors) {\n+        return JavaFile.this.toString();\n+      }\n+      @Override public InputStream openInputStream() throws IOException {\n+        return new ByteArrayInputStream(getCharContent(true).getBytes());\n+      }\n+      @Override public long getLastModified() {\n+        return lastModified;\n+      }\n+    };\n+  }\n+\n   public static Builder builder(String packageName, TypeSpec typeSpec) {\n     checkNotNull(packageName, \"packageName == null\");\n     checkNotNull(typeSpec, \"typeSpec == null\");\n"
    },
    {
        "commit_hash": "da9e893102bebde02ff01cca95ea084ce521cbf9",
        "previous_commit_hash": "2ae53e321dbc6dc240af086ccfa109d1646ff9ca",
        "diff_stats": {
            "additions": 127,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,127 @@\n+/*\n+ * Copyright (C) 2015 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javapoet;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collections;\n+import java.util.Locale;\n+import java.util.concurrent.Callable;\n+\n+import javax.lang.model.element.Modifier;\n+import javax.tools.DiagnosticCollector;\n+import javax.tools.JavaCompiler;\n+import javax.tools.JavaCompiler.CompilationTask;\n+import javax.tools.JavaFileObject;\n+import javax.tools.JavaFileObject.Kind;\n+import javax.tools.StandardJavaFileManager;\n+import javax.tools.StandardLocation;\n+import javax.tools.ToolProvider;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+import com.google.common.io.ByteStreams;\n+\n+@RunWith(JUnit4.class)\n+public class FileReadingTest {\n+  \n+  // Used for storing compilation output.\n+  @Rule public final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  @Test public void javaFileObjectUri() {\n+    TypeSpec type = TypeSpec.classBuilder(\"Test\").build();\n+    assertThat(JavaFile.builder(\"\", type).build().toJavaFileObject().toUri())\n+        .isEqualTo(URI.create(\"Test.java\"));\n+    assertThat(JavaFile.builder(\"foo\", type).build().toJavaFileObject().toUri())\n+        .isEqualTo(URI.create(\"foo/Test.java\"));\n+    assertThat(JavaFile.builder(\"com.example\", type).build().toJavaFileObject().toUri())\n+        .isEqualTo(URI.create(\"com/example/Test.java\"));\n+  }\n+  \n+  @Test public void javaFileObjectKind() {\n+    JavaFile javaFile = JavaFile.builder(\"\", TypeSpec.classBuilder(\"Test\").build()).build();\n+    assertThat(javaFile.toJavaFileObject().getKind()).isEqualTo(Kind.SOURCE);\n+  }\n+  \n+  @Test public void javaFileObjectCharacterContent() throws IOException {\n+    TypeSpec type = TypeSpec.classBuilder(\"Test\")\n+        .addJavadoc(\"Testing, 1, 2, 3!\")\n+        .addMethod(MethodSpec.methodBuilder(\"fooBar\").build())\n+        .build();\n+    JavaFile javaFile = JavaFile.builder(\"foo\", type).build();\n+    JavaFileObject javaFileObject = javaFile.toJavaFileObject();\n+    \n+    // We can never have encoding issues (everything is in process)\n+    assertThat(javaFileObject.getCharContent(true)).isEqualTo(javaFile.toString());\n+    assertThat(javaFileObject.getCharContent(false)).isEqualTo(javaFile.toString());\n+  }\n+  \n+  @Test public void javaFileObjectInputStream() throws IOException {\n+    JavaFile javaFile = JavaFile.builder(\"foo\", TypeSpec.classBuilder(\"Test\").build())\n+        .addFileComment(\"\\u00A9 Copyright character gets you everytime\")\n+        .build();\n+    byte[] bytes = ByteStreams.toByteArray(javaFile.toJavaFileObject().openInputStream());\n+    \n+    // Be explicit with the default charset to assert the implicit behavior in the code\n+    assertThat(bytes).isEqualTo(javaFile.toString().getBytes(Charset.defaultCharset()));\n+  }\n+  \n+  @Test public void compileJavaFile() throws Exception {\n+    final String value = \"Hello World!\";\n+    TypeSpec type = TypeSpec.classBuilder(\"Test\")\n+        .addModifiers(Modifier.PUBLIC)\n+        .addSuperinterface(ParameterizedTypeName.get(Callable.class, String.class))\n+        .addMethod(MethodSpec.methodBuilder(\"call\")\n+            .returns(String.class)\n+            .addModifiers(Modifier.PUBLIC)\n+            .addStatement(\"return $S\", value)\n+            .build())\n+        .build();\n+    JavaFile javaFile = JavaFile.builder(\"foo\", type).build();\n+\n+    JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n+    DiagnosticCollector<JavaFileObject> diagnosticCollector = new DiagnosticCollector<>();\n+    StandardJavaFileManager fileManager = compiler.getStandardFileManager(diagnosticCollector, \n+        Locale.getDefault(), StandardCharsets.UTF_8);\n+    File classOutput = temporaryFolder.newFolder();\n+    fileManager.setLocation(StandardLocation.CLASS_OUTPUT, Collections.singleton(classOutput));\n+    CompilationTask task = compiler.getTask(null, \n+        fileManager,\n+        diagnosticCollector,\n+        Collections.<String>emptySet(),\n+        Collections.<String>emptySet(),\n+        Collections.singleton(javaFile.toJavaFileObject()));\n+    \n+    assertThat(task.call()).isTrue();\n+    assertThat(diagnosticCollector.getDiagnostics()).isEmpty();\n+\n+    ClassLoader loader = new URLClassLoader(new URL[] { classOutput.toURI().toURL() });\n+    Callable<?> test = Class.forName(\"foo.Test\", true, loader).asSubclass(Callable.class).newInstance();\n+    assertThat(Callable.class.getMethod(\"call\").invoke(test)).isEqualTo(value);\n+  }\n+\n+}\n"
    },
    {
        "commit_hash": "f06f90e1a887e766fb9d3ed934a8853ba02c1f5b",
        "previous_commit_hash": "5f619e393b26311b04ce34cf7092029fb9a66893",
        "diff_stats": {
            "additions": 5,
            "deletions": 11
        },
        "diff_content": "@@ -15,19 +15,13 @@\n  */\n package com.squareup.javapoet;\n \n-import static com.google.common.truth.Truth.assertThat;\n-\n-import java.io.File;\n import java.io.IOException;\n import java.net.URI;\n-import java.net.URL;\n-import java.net.URLClassLoader;\n import java.nio.charset.Charset;\n import java.nio.charset.StandardCharsets;\n import java.util.Collections;\n import java.util.Locale;\n import java.util.concurrent.Callable;\n-\n import javax.lang.model.element.Modifier;\n import javax.tools.DiagnosticCollector;\n import javax.tools.JavaCompiler;\n@@ -37,15 +31,15 @@ import javax.tools.JavaFileObject.Kind;\n import javax.tools.StandardJavaFileManager;\n import javax.tools.StandardLocation;\n import javax.tools.ToolProvider;\n-\n import org.junit.Rule;\n import org.junit.Test;\n import org.junit.rules.TemporaryFolder;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n-\n import com.google.common.io.ByteStreams;\n \n+import static com.google.common.truth.Truth.assertThat;\n+\n @RunWith(JUnit4.class)\n public class FileReadingTest {\n   \n@@ -107,8 +101,8 @@ public class FileReadingTest {\n     DiagnosticCollector<JavaFileObject> diagnosticCollector = new DiagnosticCollector<>();\n     StandardJavaFileManager fileManager = compiler.getStandardFileManager(diagnosticCollector, \n         Locale.getDefault(), StandardCharsets.UTF_8);\n-    File classOutput = temporaryFolder.newFolder();\n-    fileManager.setLocation(StandardLocation.CLASS_OUTPUT, Collections.singleton(classOutput));\n+    fileManager.setLocation(StandardLocation.CLASS_OUTPUT,\n+        Collections.singleton(temporaryFolder.newFolder()));\n     CompilationTask task = compiler.getTask(null, \n         fileManager,\n         diagnosticCollector,\n@@ -119,7 +113,7 @@ public class FileReadingTest {\n     assertThat(task.call()).isTrue();\n     assertThat(diagnosticCollector.getDiagnostics()).isEmpty();\n \n-    ClassLoader loader = new URLClassLoader(new URL[] { classOutput.toURI().toURL() });\n+    ClassLoader loader = fileManager.getClassLoader(StandardLocation.CLASS_OUTPUT);\n     Callable<?> test = Class.forName(\"foo.Test\", true, loader).asSubclass(Callable.class).newInstance();\n     assertThat(Callable.class.getMethod(\"call\").invoke(test)).isEqualTo(value);\n   }\n"
    },
    {
        "commit_hash": "1e0eee173d0fbff67036439f5fac171e637e3ecb",
        "previous_commit_hash": "2e3af69dc2f9396f2f1b8286224075951e5d0930",
        "diff_stats": {
            "additions": 11,
            "deletions": 1
        },
        "diff_content": "@@ -121,7 +121,9 @@ public final class AnnotationSpec {\n \n   public Builder toBuilder() {\n     Builder builder = new Builder(type);\n-    builder.members.putAll(members);\n+    for (Map.Entry<String, List<CodeBlock>> entry : members.entrySet()) {\n+      builder.members.put(entry.getKey(), new ArrayList<>(entry.getValue()));\n+    }\n     return builder;\n   }\n \n@@ -216,6 +218,14 @@ public final class AnnotationSpec {\n     public Builder visitType(TypeMirror t, Entry entry) {\n       return builder.addMember(entry.name, \"$T.class\", t);\n     }\n+\n+    @Override\n+    public Builder visitArray(List<? extends AnnotationValue> values, Entry entry) {\n+      for (AnnotationValue value : values) {\n+        value.accept(this, new Entry(entry.name, value));\n+      }\n+      return builder;\n+    }\n   }\n \n }\n"
    },
    {
        "commit_hash": "1e0eee173d0fbff67036439f5fac171e637e3ecb",
        "previous_commit_hash": "2e3af69dc2f9396f2f1b8286224075951e5d0930",
        "diff_stats": {
            "additions": 92,
            "deletions": 3
        },
        "diff_content": "@@ -85,6 +85,9 @@ public final class AnnotationSpecTest {\n     int p();\n \n     AnnotationC q() default @AnnotationC(\"foo\");\n+\n+    Class<? extends Number>[] r() default {Byte.class, Short.class, Integer.class, Long.class};\n+\n   }\n \n   @HasDefaultsAnnotation(\n@@ -94,7 +97,8 @@ public final class AnnotationSpecTest {\n       m = {9, 8, 1},\n       l = Override.class,\n       j = @AnnotationA,\n-      q = @AnnotationC(\"bar\"))\n+      q = @AnnotationC(\"bar\"),\n+      r = {Float.class, Double.class})\n   public class IsAnnotated {\n     // empty\n   }\n@@ -116,6 +120,7 @@ public final class AnnotationSpecTest {\n             + \", l = java.lang.Override.class\"\n             + \", j = @com.squareup.javapoet.AnnotationSpecTest.AnnotationA\"\n             + \", q = @com.squareup.javapoet.AnnotationSpecTest.AnnotationC(\\\"bar\\\")\"\n+            + \", r = {java.lang.Float.class, java.lang.Double.class}\"\n             + \")\");\n   }\n \n@@ -130,19 +135,103 @@ public final class AnnotationSpecTest {\n     assertThat(file.toString()).isEqualTo(\n         \"package com.squareup.javapoet;\\n\"\n             + \"\\n\"\n+            + \"import java.lang.Double;\\n\"\n+            + \"import java.lang.Float;\\n\"\n             + \"import java.lang.Override;\\n\"\n             + \"\\n\"\n             + \"@AnnotationSpecTest.HasDefaultsAnnotation(\\n\"\n             + \"    o = AnnotationSpecTest.Breakfast.PANCAKES,\\n\"\n             + \"    p = 1701,\\n\"\n             + \"    f = 11.1,\\n\"\n-            + \"    m = {9, 8, 1},\\n\"\n+            + \"    m = {\\n\"\n+            + \"        9,\\n\"\n+            + \"        8,\\n\"\n+            + \"        1\\n\"\n+            + \"    },\\n\"\n             + \"    l = Override.class,\\n\"\n             + \"    j = @AnnotationSpecTest.AnnotationA,\\n\"\n-            + \"    q = @AnnotationSpecTest.AnnotationC(\\\"bar\\\")\\n\"\n+            + \"    q = @AnnotationSpecTest.AnnotationC(\\\"bar\\\"),\\n\"\n+            + \"    r = {\\n\"\n+            + \"        Float.class,\\n\"\n+            + \"        Double.class\\n\"\n+            + \"    }\\n\"\n             + \")\\n\"\n             + \"class IsAnnotated {\\n\"\n             + \"}\\n\"\n     );\n   }\n+\n+  @Test\n+  public void testEmptyArray() {\n+    AnnotationSpec.Builder builder = AnnotationSpec.builder(HasDefaultsAnnotation.class);\n+    builder.addMember(\"n\", \"$L\", \"{}\");\n+    assertThat(builder.build().toString()).isEqualTo(\n+        \"@com.squareup.javapoet.AnnotationSpecTest.HasDefaultsAnnotation(\" + \"n = {}\" + \")\");\n+    builder.addMember(\"m\", \"$L\", \"{}\");\n+    assertThat(builder.build().toString())\n+        .isEqualTo(\n+            \"@com.squareup.javapoet.AnnotationSpecTest.HasDefaultsAnnotation(\"\n+                + \"n = {}, m = {}\"\n+                + \")\");\n+  }\n+\n+  @Test\n+  public void testDynamicArrayOfEnumConstants() {\n+    AnnotationSpec.Builder builder = AnnotationSpec.builder(HasDefaultsAnnotation.class);\n+    builder.addMember(\"n\", \"$T.$L\", Breakfast.class, Breakfast.PANCAKES);\n+    assertThat(builder.build().toString()).isEqualTo(\n+        \"@com.squareup.javapoet.AnnotationSpecTest.HasDefaultsAnnotation(\"\n+            + \"n = com.squareup.javapoet.AnnotationSpecTest.Breakfast.PANCAKES\"\n+            + \")\");\n+\n+    // builder = AnnotationSpec.builder(HasDefaultsAnnotation.class);\n+    builder.addMember(\"n\", \"$T.$L\", Breakfast.class, Breakfast.WAFFLES);\n+    builder.addMember(\"n\", \"$T.$L\", Breakfast.class, Breakfast.PANCAKES);\n+    assertThat(builder.build().toString()).isEqualTo(\n+        \"@com.squareup.javapoet.AnnotationSpecTest.HasDefaultsAnnotation(\"\n+            + \"n = {\"\n+            + \"com.squareup.javapoet.AnnotationSpecTest.Breakfast.PANCAKES\"\n+            + \", com.squareup.javapoet.AnnotationSpecTest.Breakfast.WAFFLES\"\n+            + \", com.squareup.javapoet.AnnotationSpecTest.Breakfast.PANCAKES\"\n+            + \"})\");\n+\n+    builder = builder.build().toBuilder(); // idempotent\n+    assertThat(builder.build().toString()).isEqualTo(\n+        \"@com.squareup.javapoet.AnnotationSpecTest.HasDefaultsAnnotation(\"\n+            + \"n = {\"\n+            + \"com.squareup.javapoet.AnnotationSpecTest.Breakfast.PANCAKES\"\n+            + \", com.squareup.javapoet.AnnotationSpecTest.Breakfast.WAFFLES\"\n+            + \", com.squareup.javapoet.AnnotationSpecTest.Breakfast.PANCAKES\"\n+            + \"})\");\n+\n+    builder.addMember(\"n\", \"$T.$L\", Breakfast.class, Breakfast.WAFFLES);\n+    assertThat(builder.build().toString()).isEqualTo(\n+        \"@com.squareup.javapoet.AnnotationSpecTest.HasDefaultsAnnotation(\"\n+            + \"n = {\"\n+            + \"com.squareup.javapoet.AnnotationSpecTest.Breakfast.PANCAKES\"\n+            + \", com.squareup.javapoet.AnnotationSpecTest.Breakfast.WAFFLES\"\n+            + \", com.squareup.javapoet.AnnotationSpecTest.Breakfast.PANCAKES\"\n+            + \", com.squareup.javapoet.AnnotationSpecTest.Breakfast.WAFFLES\"\n+            + \"})\");\n+  }\n+\n+  @Test\n+  public void testHasDefaultAnnotationToBuilder() {\n+    String name = IsAnnotated.class.getCanonicalName();\n+    TypeElement element = compilation.getElements().getTypeElement(name);\n+    AnnotationSpec.Builder builder = AnnotationSpec.get(element.getAnnotationMirrors().get(0))\n+        .toBuilder();\n+    builder.addMember(\"m\", \"$L\", 123);\n+    assertThat(builder.build().toString()).isEqualTo(\n+        \"@com.squareup.javapoet.AnnotationSpecTest.HasDefaultsAnnotation(\"\n+            + \"o = com.squareup.javapoet.AnnotationSpecTest.Breakfast.PANCAKES\"\n+            + \", p = 1701\"\n+            + \", f = 11.1\"\n+            + \", m = {9, 8, 1, 123}\"\n+            + \", l = java.lang.Override.class\"\n+            + \", j = @com.squareup.javapoet.AnnotationSpecTest.AnnotationA\"\n+            + \", q = @com.squareup.javapoet.AnnotationSpecTest.AnnotationC(\\\"bar\\\")\"\n+            + \", r = {java.lang.Float.class, java.lang.Double.class}\"\n+            + \")\");\n+  }\n }\n"
    },
    {
        "commit_hash": "bedeff32986dc665a5499d68d38a508d7bf187fe",
        "previous_commit_hash": "9e31383e46edd2da2f1059b5cc5bcdd43f64f9f4",
        "diff_stats": {
            "additions": 5,
            "deletions": 1
        },
        "diff_content": "@@ -323,7 +323,11 @@ public final class MethodSpec {\n     }\n \n     public Builder varargs() {\n-      this.varargs = true;\n+      return varargs(true);\n+    }\n+\n+    public Builder varargs(boolean varargs) {\n+      this.varargs = varargs;\n       return this;\n     }\n \n"
    },
    {
        "commit_hash": "cc275673f824a909813b50e9746728f2c1d24b37",
        "previous_commit_hash": "9e5558c68482534f5d64083fcbb823884d4e188b",
        "diff_stats": {
            "additions": 17,
            "deletions": 0
        },
        "diff_content": "@@ -1,6 +1,23 @@\n Change Log\n ==========\n \n+JavaPoet 1.1.0 *(2015-05-25)*\n+----------------------------\n+\n+ * New: Eager validation of argument types like `$T` and `$N`.\n+ * New: `MethodSpec.varargs(boolean)` to generate varags methods.\n+ * New: `AnnotationSpec.get()` and `MethodSpec.overriding()` to create annotations and methods from\n+   the `javax.lang.model` API.\n+ * New: `JavaFile.toJavaFileObject()`.\n+ * New: Java 8 `DEFAULT` modifier.\n+ * New: `toBuilder()` methods to build upon objects already constructed.\n+ * New: Generate `@interface` annotation types.\n+ * New: `TypeName.box()` and `TypeName.unbox()` convenience APIs.\n+ * Fix: `nextControlFlow()` accepts arguments.\n+ * Fix: Reject duplicate calls to set the superclass.\n+ * Fix: `WildcardTypeName.get(WildcardType)` no longer throws a `NullPointerException`.\n+ * Fix: Don't allow double field initialization.\n+\n JavaPoet 1.0.0 *(2015-01-28)*\n ----------------------------\n \n"
    },
    {
        "commit_hash": "cc275673f824a909813b50e9746728f2c1d24b37",
        "previous_commit_hash": "9e5558c68482534f5d64083fcbb823884d4e188b",
        "diff_stats": {
            "additions": 5,
            "deletions": 14
        },
        "diff_content": "@@ -175,9 +175,6 @@ public final class AnnotationSpec {\n     }\n   }\n \n-  /**\n-   * Tuple of name and value.\n-   */\n   private static class Entry {\n     final String name;\n     final AnnotationValue value;\n@@ -199,33 +196,27 @@ public final class AnnotationSpec {\n       this.builder = builder;\n     }\n \n-    @Override\n-    protected Builder defaultAction(Object o, Entry entry) {\n+    @Override protected Builder defaultAction(Object o, Entry entry) {\n       return builder.addMember(entry.name, \"$L\", entry.value);\n     }\n \n-    @Override\n-    public Builder visitAnnotation(AnnotationMirror a, Entry entry) {\n+    @Override public Builder visitAnnotation(AnnotationMirror a, Entry entry) {\n       return builder.addMember(entry.name, \"$L\", get(a));\n     }\n \n-    @Override\n-    public Builder visitEnumConstant(VariableElement c, Entry entry) {\n+    @Override public Builder visitEnumConstant(VariableElement c, Entry entry) {\n       return builder.addMember(entry.name, \"$T.$L\", c.asType(), c.getSimpleName());\n     }\n \n-    @Override\n-    public Builder visitType(TypeMirror t, Entry entry) {\n+    @Override public Builder visitType(TypeMirror t, Entry entry) {\n       return builder.addMember(entry.name, \"$T.class\", t);\n     }\n \n-    @Override\n-    public Builder visitArray(List<? extends AnnotationValue> values, Entry entry) {\n+    @Override public Builder visitArray(List<? extends AnnotationValue> values, Entry entry) {\n       for (AnnotationValue value : values) {\n         value.accept(this, new Entry(entry.name, value));\n       }\n       return builder;\n     }\n   }\n-\n }\n"
    },
    {
        "commit_hash": "cc275673f824a909813b50e9746728f2c1d24b37",
        "previous_commit_hash": "9e5558c68482534f5d64083fcbb823884d4e188b",
        "diff_stats": {
            "additions": 8,
            "deletions": 8
        },
        "diff_content": "@@ -15,22 +15,20 @@\n  */\n package com.squareup.javapoet;\n \n-import static com.squareup.javapoet.Util.checkArgument;\n-import static com.squareup.javapoet.Util.checkNotNull;\n-import static com.squareup.javapoet.Util.checkState;\n-\n import java.io.IOException;\n import java.io.StringWriter;\n import java.lang.reflect.Type;\n import java.util.ArrayList;\n import java.util.Collections;\n-import java.util.Collection;\n import java.util.List;\n import java.util.Set;\n-\n import javax.lang.model.SourceVersion;\n import javax.lang.model.element.Modifier;\n \n+import static com.squareup.javapoet.Util.checkArgument;\n+import static com.squareup.javapoet.Util.checkNotNull;\n+import static com.squareup.javapoet.Util.checkState;\n+\n /** A generated field declaration. */\n public final class FieldSpec {\n   public final TypeName type;\n@@ -117,9 +115,11 @@ public final class FieldSpec {\n       return this;\n     }\n \n-    public Builder addAnnotations(Collection<AnnotationSpec> annotationSpecs) {\n+    public Builder addAnnotations(Iterable<AnnotationSpec> annotationSpecs) {\n       checkArgument(annotationSpecs != null, \"annotationSpecs == null\");\n-      this.annotations.addAll(annotationSpecs);\n+      for (AnnotationSpec annotationSpec : annotationSpecs) {\n+        this.annotations.add(annotationSpec);\n+      }\n       return this;\n     }\n \n"
    },
    {
        "commit_hash": "cc275673f824a909813b50e9746728f2c1d24b37",
        "previous_commit_hash": "9e5558c68482534f5d64083fcbb823884d4e188b",
        "diff_stats": {
            "additions": 20,
            "deletions": 11
        },
        "diff_content": "@@ -19,7 +19,6 @@ import java.io.IOException;\n import java.io.StringWriter;\n import java.lang.reflect.Type;\n import java.util.ArrayList;\n-import java.util.Collection;\n import java.util.Collections;\n import java.util.Iterator;\n import java.util.LinkedHashSet;\n@@ -251,9 +250,11 @@ public final class MethodSpec {\n       return this;\n     }\n \n-    public Builder addAnnotations(Collection<AnnotationSpec> annotationSpecs) {\n+    public Builder addAnnotations(Iterable<AnnotationSpec> annotationSpecs) {\n       checkArgument(annotationSpecs != null, \"annotationSpecs == null\");\n-      this.annotations.addAll(annotationSpecs);\n+      for (AnnotationSpec annotationSpec : annotationSpecs) {\n+        this.annotations.add(annotationSpec);\n+      }\n       return this;\n     }\n \n@@ -276,15 +277,19 @@ public final class MethodSpec {\n       return this;\n     }\n \n-    public Builder addModifiers(Collection<Modifier> modifiers) {\n+    public Builder addModifiers(Iterable<Modifier> modifiers) {\n       checkNotNull(modifiers, \"modifiers == null\");\n-      this.modifiers.addAll(modifiers);\n+      for (Modifier modifier : modifiers) {\n+        this.modifiers.add(modifier);\n+      }\n       return this;\n     }\n \n-    public Builder addTypeVariables(Collection<TypeVariableName> typeVariables) {\n+    public Builder addTypeVariables(Iterable<TypeVariableName> typeVariables) {\n       checkArgument(typeVariables != null, \"typeVariables == null\");\n-      this.typeVariables.addAll(typeVariables);\n+      for (TypeVariableName typeVariable : typeVariables) {\n+        this.typeVariables.add(typeVariable);\n+      }\n       return this;\n     }\n \n@@ -303,9 +308,11 @@ public final class MethodSpec {\n       return returns(TypeName.get(returnType));\n     }\n \n-    public Builder addParameters(Collection<ParameterSpec> parameterSpecs) {\n+    public Builder addParameters(Iterable<ParameterSpec> parameterSpecs) {\n       checkArgument(parameterSpecs != null, \"parameterSpecs == null\");\n-      this.parameters.addAll(parameterSpecs);\n+      for (ParameterSpec parameterSpec : parameterSpecs) {\n+        this.parameters.add(parameterSpec);\n+      }\n       return this;\n     }\n \n@@ -331,9 +338,11 @@ public final class MethodSpec {\n       return this;\n     }\n \n-    public Builder addExceptions(Collection<TypeName> exceptions) {\n+    public Builder addExceptions(Iterable<? extends TypeName> exceptions) {\n       checkArgument(exceptions != null, \"exceptions == null\");\n-      this.exceptions.addAll(exceptions);\n+      for (TypeName exception : exceptions) {\n+        this.exceptions.add(exception);\n+      }\n       return this;\n     }\n \n"
    },
    {
        "commit_hash": "cc275673f824a909813b50e9746728f2c1d24b37",
        "previous_commit_hash": "9e5558c68482534f5d64083fcbb823884d4e188b",
        "diff_stats": {
            "additions": 4,
            "deletions": 3
        },
        "diff_content": "@@ -20,7 +20,6 @@ import java.io.StringWriter;\n import java.lang.reflect.Type;\n import java.util.ArrayList;\n import java.util.Collections;\n-import java.util.Collection;\n import java.util.List;\n import java.util.Set;\n import javax.lang.model.SourceVersion;\n@@ -98,9 +97,11 @@ public final class ParameterSpec {\n       this.name = name;\n     }\n \n-    public Builder addAnnotations(Collection<AnnotationSpec> annotationSpecs) {\n+    public Builder addAnnotations(Iterable<AnnotationSpec> annotationSpecs) {\n       checkArgument(annotationSpecs != null, \"annotationSpecs == null\");\n-      this.annotations.addAll(annotationSpecs);\n+      for (AnnotationSpec annotationSpec : annotationSpecs) {\n+        this.annotations.add(annotationSpec);\n+      }\n       return this;\n     }\n \n"
    },
    {
        "commit_hash": "cc275673f824a909813b50e9746728f2c1d24b37",
        "previous_commit_hash": "9e5558c68482534f5d64083fcbb823884d4e188b",
        "diff_stats": {
            "additions": 15,
            "deletions": 10
        },
        "diff_content": "@@ -20,7 +20,6 @@ import java.io.StringWriter;\n import java.lang.reflect.Type;\n import java.util.ArrayList;\n import java.util.Arrays;\n-import java.util.Collection;\n import java.util.Collections;\n import java.util.EnumSet;\n import java.util.Iterator;\n@@ -343,10 +342,12 @@ public final class TypeSpec {\n       return this;\n     }\n \n-    public Builder addAnnotations(Collection<AnnotationSpec> annotationSpecs) {\n+    public Builder addAnnotations(Iterable<AnnotationSpec> annotationSpecs) {\n       checkState(anonymousTypeArguments == null, \"forbidden on anonymous types.\");\n       checkArgument(annotationSpecs != null, \"annotationSpecs == null\");\n-      this.annotations.addAll(annotationSpecs);\n+      for (AnnotationSpec annotationSpec : annotationSpecs) {\n+        this.annotations.add(annotationSpec);\n+      }\n       return this;\n     }\n \n@@ -370,10 +371,12 @@ public final class TypeSpec {\n       return this;\n     }\n \n-    public Builder addTypeVariables(Collection<TypeVariableName> typeVariables) {\n+    public Builder addTypeVariables(Iterable<TypeVariableName> typeVariables) {\n       checkState(anonymousTypeArguments == null, \"forbidden on anonymous types.\");\n       checkArgument(typeVariables != null, \"typeVariables == null\");\n-      this.typeVariables.addAll(typeVariables);\n+      for (TypeVariableName typeVariable : typeVariables) {\n+        this.typeVariables.add(typeVariable);\n+      }\n       return this;\n     }\n \n@@ -395,9 +398,11 @@ public final class TypeSpec {\n       return superclass(TypeName.get(superclass));\n     }\n \n-    public Builder addSuperinterfaces(Collection<TypeName> superinterfaces) {\n+    public Builder addSuperinterfaces(Iterable<? extends TypeName> superinterfaces) {\n       checkArgument(superinterfaces != null, \"superinterfaces == null\");\n-      this.superinterfaces.addAll(superinterfaces);\n+      for (TypeName superinterface : superinterfaces) {\n+        this.superinterfaces.add(superinterface);\n+      }\n       return this;\n     }\n \n@@ -423,7 +428,7 @@ public final class TypeSpec {\n       return this;\n     }\n \n-    public Builder addFields(Collection<FieldSpec> fieldSpecs) {\n+    public Builder addFields(Iterable<FieldSpec> fieldSpecs) {\n       checkArgument(fieldSpecs != null, \"fieldSpecs == null\");\n       for (FieldSpec fieldSpec : fieldSpecs) {\n         addField(fieldSpec);\n@@ -451,7 +456,7 @@ public final class TypeSpec {\n       return addField(TypeName.get(type), name, modifiers);\n     }\n \n-    public Builder addMethods(Collection<MethodSpec> methodSpecs) {\n+    public Builder addMethods(Iterable<MethodSpec> methodSpecs) {\n       checkArgument(methodSpecs != null, \"methodSpecs == null\");\n       for (MethodSpec methodSpec : methodSpecs) {\n         addMethod(methodSpec);\n@@ -479,7 +484,7 @@ public final class TypeSpec {\n       return this;\n     }\n \n-    public Builder addTypes(Collection<TypeSpec> typeSpecs) {\n+    public Builder addTypes(Iterable<TypeSpec> typeSpecs) {\n       checkArgument(typeSpecs != null, \"typeSpecs == null\");\n       for (TypeSpec typeSpec : typeSpecs) {\n         addType(typeSpec);\n"
    },
    {
        "commit_hash": "cc275673f824a909813b50e9746728f2c1d24b37",
        "previous_commit_hash": "9e5558c68482534f5d64083fcbb823884d4e188b",
        "diff_stats": {
            "additions": 4,
            "deletions": 4
        },
        "diff_content": "@@ -98,12 +98,12 @@ final class Util {\n \n   public static void requireExactlyOneOf(Set<Modifier> modifiers, Modifier... mutuallyExclusive) {\n     int count = 0;\n-    for (Modifier check : mutuallyExclusive) {\n-      if (check == null && Util.DEFAULT == null) continue; // Skip 'DEFAULT' if it doesn't exist!\n-      if (modifiers.contains(check)) count++;\n+    for (Modifier modifier : mutuallyExclusive) {\n+      if (modifier == null && Util.DEFAULT == null) continue; // Skip 'DEFAULT' if it doesn't exist!\n+      if (modifiers.contains(modifier)) count++;\n     }\n     checkArgument(count == 1, \"modifiers %s must contain one of %s\",\n-            modifiers, Arrays.toString(mutuallyExclusive));\n+        modifiers, Arrays.toString(mutuallyExclusive));\n   }\n \n   public static boolean hasDefaultModifier(Collection<Modifier> modifiers) {\n"
    },
    {
        "commit_hash": "cc275673f824a909813b50e9746728f2c1d24b37",
        "previous_commit_hash": "9e5558c68482534f5d64083fcbb823884d4e188b",
        "diff_stats": {
            "additions": 44,
            "deletions": 29
        },
        "diff_content": "@@ -15,19 +15,16 @@\n  */\n package com.squareup.javapoet;\n \n-import static com.google.common.truth.Truth.assertThat;\n-\n+import com.google.testing.compile.CompilationRule;\n import java.lang.annotation.Annotation;\n import java.lang.annotation.Inherited;\n import java.lang.annotation.Retention;\n import java.lang.annotation.RetentionPolicy;\n-\n import javax.lang.model.element.TypeElement;\n-\n import org.junit.Rule;\n import org.junit.Test;\n \n-import com.google.testing.compile.CompilationRule;\n+import static com.google.common.truth.Truth.assertThat;\n \n public final class AnnotationSpecTest {\n \n@@ -45,7 +42,7 @@ public final class AnnotationSpecTest {\n     String value();\n   }\n \n-  static enum Breakfast {\n+  enum Breakfast {\n     WAFFLES, PANCAKES\n   }\n \n@@ -103,29 +100,46 @@ public final class AnnotationSpecTest {\n     // empty\n   }\n \n-  @Rule\n-  public final CompilationRule compilation = new CompilationRule();\n+  @Rule public final CompilationRule compilation = new CompilationRule();\n \n-  @Test\n-  public void testHasDefaultAnnotation() {\n+  @Test public void defaultAnnotation() {\n     String name = IsAnnotated.class.getCanonicalName();\n     TypeElement element = compilation.getElements().getTypeElement(name);\n     AnnotationSpec annotation = AnnotationSpec.get(element.getAnnotationMirrors().get(0));\n-    assertThat(annotation.toString()).isEqualTo(\n-        \"@com.squareup.javapoet.AnnotationSpecTest.HasDefaultsAnnotation(\"\n-            + \"o = com.squareup.javapoet.AnnotationSpecTest.Breakfast.PANCAKES\"\n-            + \", p = 1701\"\n-            + \", f = 11.1\"\n-            + \", m = {9, 8, 1}\"\n-            + \", l = java.lang.Override.class\"\n-            + \", j = @com.squareup.javapoet.AnnotationSpecTest.AnnotationA\"\n-            + \", q = @com.squareup.javapoet.AnnotationSpecTest.AnnotationC(\\\"bar\\\")\"\n-            + \", r = {java.lang.Float.class, java.lang.Double.class}\"\n-            + \")\");\n+\n+    TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n+        .addAnnotation(annotation)\n+        .build();\n+    assertThat(toString(taco)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import com.squareup.javapoet.AnnotationSpecTest;\\n\"\n+        + \"import java.lang.Double;\\n\"\n+        + \"import java.lang.Float;\\n\"\n+        + \"import java.lang.Override;\\n\"\n+        + \"\\n\"\n+        + \"@AnnotationSpecTest.HasDefaultsAnnotation(\\n\"\n+        + \"    o = AnnotationSpecTest.Breakfast.PANCAKES,\\n\"\n+        + \"    p = 1701,\\n\"\n+        + \"    f = 11.1,\\n\"\n+        + \"    m = {\\n\"\n+        + \"        9,\\n\"\n+        + \"        8,\\n\"\n+        + \"        1\\n\"\n+        + \"    },\\n\"\n+        + \"    l = Override.class,\\n\"\n+        + \"    j = @AnnotationSpecTest.AnnotationA,\\n\"\n+        + \"    q = @AnnotationSpecTest.AnnotationC(\\\"bar\\\"),\\n\"\n+        + \"    r = {\\n\"\n+        + \"        Float.class,\\n\"\n+        + \"        Double.class\\n\"\n+        + \"    }\\n\"\n+        + \")\\n\"\n+        + \"class Taco {\\n\"\n+        + \"}\\n\");\n   }\n \n-  @Test\n-  public void testHasDefaultAnnotationWithImport() {\n+  @Test public void defaultAnnotationWithImport() {\n     String name = IsAnnotated.class.getCanonicalName();\n     TypeElement element = compilation.getElements().getTypeElement(name);\n     AnnotationSpec annotation = AnnotationSpec.get(element.getAnnotationMirrors().get(0));\n@@ -161,8 +175,7 @@ public final class AnnotationSpecTest {\n     );\n   }\n \n-  @Test\n-  public void testEmptyArray() {\n+  @Test public void emptyArray() {\n     AnnotationSpec.Builder builder = AnnotationSpec.builder(HasDefaultsAnnotation.class);\n     builder.addMember(\"n\", \"$L\", \"{}\");\n     assertThat(builder.build().toString()).isEqualTo(\n@@ -175,8 +188,7 @@ public final class AnnotationSpecTest {\n                 + \")\");\n   }\n \n-  @Test\n-  public void testDynamicArrayOfEnumConstants() {\n+  @Test public void dynamicArrayOfEnumConstants() {\n     AnnotationSpec.Builder builder = AnnotationSpec.builder(HasDefaultsAnnotation.class);\n     builder.addMember(\"n\", \"$T.$L\", Breakfast.class, Breakfast.PANCAKES);\n     assertThat(builder.build().toString()).isEqualTo(\n@@ -215,8 +227,7 @@ public final class AnnotationSpecTest {\n             + \"})\");\n   }\n \n-  @Test\n-  public void testHasDefaultAnnotationToBuilder() {\n+  @Test public void defaultAnnotationToBuilder() {\n     String name = IsAnnotated.class.getCanonicalName();\n     TypeElement element = compilation.getElements().getTypeElement(name);\n     AnnotationSpec.Builder builder = AnnotationSpec.get(element.getAnnotationMirrors().get(0))\n@@ -234,4 +245,8 @@ public final class AnnotationSpecTest {\n             + \", r = {java.lang.Float.class, java.lang.Double.class}\"\n             + \")\");\n   }\n+\n+  private String toString(TypeSpec typeSpec) {\n+    return JavaFile.builder(\"com.squareup.tacos\", typeSpec).build().toString();\n+  }\n }\n"
    },
    {
        "commit_hash": "82807524ae3a8f9e0ea34afdd2f5f1477ab64d3a",
        "previous_commit_hash": "deb5519769b04547ba263a83cf5ffc9f9118870f",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.1.0-SNAPSHOT</version>\n+  <version>1.1.0</version>\n \n   <name>JavaPoet</name>\n   <description>Use beautiful Java code to generate beautiful Java code.</description>\n@@ -54,13 +54,13 @@\n     <dependency>\n       <groupId>com.google.truth</groupId>\n       <artifactId>truth</artifactId>\n-      <version>1.0-SNAPSHOT</version>\n+      <version>0.25</version>\n       <scope>test</scope>\n     </dependency>\n     <dependency>\n       <groupId>com.google.testing.compile</groupId>\n       <artifactId>compile-testing</artifactId>\n-      <version>1.0-SNAPSHOT</version>\n+      <version>0.6</version>\n       <scope>test</scope>\n     </dependency>\n     <dependency>\n"
    },
    {
        "commit_hash": "2ddbb90789ae9c8eea9d8264b964748c76703a81",
        "previous_commit_hash": "82807524ae3a8f9e0ea34afdd2f5f1477ab64d3a",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.1.0</version>\n+  <version>1.2.0-SNAPSHOT</version>\n \n   <name>JavaPoet</name>\n   <description>Use beautiful Java code to generate beautiful Java code.</description>\n@@ -54,13 +54,13 @@\n     <dependency>\n       <groupId>com.google.truth</groupId>\n       <artifactId>truth</artifactId>\n-      <version>0.25</version>\n+      <version>1.0-SNAPSHOT</version>\n       <scope>test</scope>\n     </dependency>\n     <dependency>\n       <groupId>com.google.testing.compile</groupId>\n       <artifactId>compile-testing</artifactId>\n-      <version>0.6</version>\n+      <version>1.0-SNAPSHOT</version>\n       <scope>test</scope>\n     </dependency>\n     <dependency>\n"
    },
    {
        "commit_hash": "869f9dd91b6fce1133d137b5eae8ba543c92806a",
        "previous_commit_hash": "2ddbb90789ae9c8eea9d8264b964748c76703a81",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -744,12 +744,12 @@ Download [the latest .jar][dl] or depend via Maven:\n <dependency>\n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.0.0</version>\n+  <version>1.1.0</version>\n </dependency>\n ```\n or Gradle:\n ```groovy\n-compile 'com.squareup:javapoet:1.0.0'\n+compile 'com.squareup:javapoet:1.1.0'\n ```\n \n Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].\n"
    },
    {
        "commit_hash": "2143e2c593cf2a5bfa9600fdfd0a376d75091a2b",
        "previous_commit_hash": "869f9dd91b6fce1133d137b5eae8ba543c92806a",
        "diff_stats": {
            "additions": 14,
            "deletions": 0
        },
        "diff_content": "@@ -51,6 +51,7 @@ public final class TypeSpec {\n   public final List<TypeName> superinterfaces;\n   public final Map<String, TypeSpec> enumConstants;\n   public final List<FieldSpec> fieldSpecs;\n+  public final CodeBlock staticBlock;\n   public final List<MethodSpec> methodSpecs;\n   public final List<TypeSpec> typeSpecs;\n   public final List<Element> originatingElements;\n@@ -67,6 +68,7 @@ public final class TypeSpec {\n     this.superinterfaces = Util.immutableList(builder.superinterfaces);\n     this.enumConstants = Util.immutableMap(builder.enumConstants);\n     this.fieldSpecs = Util.immutableList(builder.fieldSpecs);\n+    this.staticBlock = builder.staticBlock.build();\n     this.methodSpecs = Util.immutableList(builder.methodSpecs);\n     this.typeSpecs = Util.immutableList(builder.typeSpecs);\n \n@@ -216,6 +218,12 @@ public final class TypeSpec {\n         firstMember = false;\n       }\n \n+      if (!staticBlock.isEmpty()) {\n+        if (!firstMember) codeWriter.emit(\"\\n\");\n+        codeWriter.emit(staticBlock);\n+        firstMember = false;\n+      }\n+\n       // Non-static fields.\n       for (FieldSpec fieldSpec : fieldSpecs) {\n         if (fieldSpec.hasModifier(Modifier.STATIC)) continue;\n@@ -324,6 +332,7 @@ public final class TypeSpec {\n     private final List<TypeName> superinterfaces = new ArrayList<>();\n     private final Map<String, TypeSpec> enumConstants = new LinkedHashMap<>();\n     private final List<FieldSpec> fieldSpecs = new ArrayList<>();\n+    private final CodeBlock.Builder staticBlock = CodeBlock.builder();\n     private final List<MethodSpec> methodSpecs = new ArrayList<>();\n     private final List<TypeSpec> typeSpecs = new ArrayList<>();\n     private final List<Element> originatingElements = new ArrayList<>();\n@@ -456,6 +465,11 @@ public final class TypeSpec {\n       return addField(TypeName.get(type), name, modifiers);\n     }\n \n+    public Builder addStaticBlock(CodeBlock block) {\n+      staticBlock.beginControlFlow(\"static\").add(block).endControlFlow();\n+      return this;\n+    }\n+\n     public Builder addMethods(Iterable<MethodSpec> methodSpecs) {\n       checkArgument(methodSpecs != null, \"methodSpecs == null\");\n       for (MethodSpec methodSpec : methodSpecs) {\n"
    },
    {
        "commit_hash": "2143e2c593cf2a5bfa9600fdfd0a376d75091a2b",
        "previous_commit_hash": "869f9dd91b6fce1133d137b5eae8ba543c92806a",
        "diff_stats": {
            "additions": 34,
            "deletions": 1
        },
        "diff_content": "@@ -736,7 +736,7 @@ public final class TypeSpecTest {\n             .addCode(CodeBlock.builder().addStatement(\"return 0\").build())\n             .build())\n         .build();\n-    \n+\n     assertThat(toString(bar)).isEqualTo(\"\"\n         + \"package com.squareup.tacos;\\n\"\n         + \"\\n\"\n@@ -1846,6 +1846,39 @@ public final class TypeSpecTest {\n     }\n   }\n \n+  @Test public void staticCodeBlock() {\n+    TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n+            .addField(String.class, \"mFoo\", Modifier.PRIVATE)\n+            .addField(String.class, \"FOO\", Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)\n+            .addStaticBlock(CodeBlock.builder()\n+                    .addStatement(\"FOO = $S\", \"FOO\")\n+                    .build())\n+            .addMethod(MethodSpec.methodBuilder(\"toString\")\n+                    .addAnnotation(Override.class)\n+                    .addModifiers(Modifier.PUBLIC)\n+                    .returns(String.class)\n+                    .addCode(\"return FOO;\\n\")\n+                    .build())\n+            .build();\n+      assertThat(toString(taco)).isEqualTo(\"\"\n+            + \"package com.squareup.tacos;\\n\"\n+            + \"\\n\"\n+            + \"import java.lang.Override;\\n\"\n+            + \"import java.lang.String;\\n\"\n+            + \"\\n\"\n+            + \"class Taco {\\n\"\n+            + \"  private static final String FOO;\\n\\n\"\n+            + \"  static {\\n\"\n+            + \"    FOO = \\\"FOO\\\";\\n\"\n+            + \"  }\\n\\n\"\n+            + \"  private String mFoo;\\n\\n\"\n+            + \"  @Override\\n\"\n+            + \"  public String toString() {\\n\"\n+            + \"    return FOO;\\n\"\n+            + \"  }\\n\"\n+            + \"}\\n\");\n+  }\n+\n   private CodeBlock codeBlock(String format, Object... args) {\n     return CodeBlock.builder()\n         .add(format, args)\n"
    },
    {
        "commit_hash": "6d8573cc967b43810ee69cde9f7a60e3542504a2",
        "previous_commit_hash": "d38648e891492c5c57513f7219030d4c1908ba36",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -787,7 +787,7 @@ JavaWriter continues to be available in [GitHub][javawriter] and [Maven Central]\n \n \n  [dl]: https://search.maven.org/remote_content?g=com.squareup&a=javapoet&v=LATEST\n- [snap]: https://oss.sonatype.org/content/repositories/snapshots/\n+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/com/squareup/javapoet/\n  [javadoc]: https://square.github.io/javapoet/javadoc/javapoet/\n  [javawriter]: https://github.com/square/javapoet/tree/javawriter_2\n  [javawriter_maven]: http://search.maven.org/#artifactdetails%7Ccom.squareup%7Cjavawriter%7C2.5.1%7Cjar\n"
    },
    {
        "commit_hash": "6d8573cc967b43810ee69cde9f7a60e3542504a2",
        "previous_commit_hash": "d38648e891492c5c57513f7219030d4c1908ba36",
        "diff_stats": {
            "additions": 54,
            "deletions": 17
        },
        "diff_content": "@@ -24,13 +24,19 @@ import java.util.Iterator;\n import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Set;\n+\n import javax.lang.model.SourceVersion;\n+import javax.lang.model.element.AnnotationMirror;\n import javax.lang.model.element.ExecutableElement;\n import javax.lang.model.element.Modifier;\n import javax.lang.model.element.TypeParameterElement;\n import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.ExecutableType;\n import javax.lang.model.type.TypeMirror;\n import javax.lang.model.type.TypeVariable;\n+import javax.lang.model.util.Elements;\n+import javax.lang.model.util.Types;\n \n import static com.squareup.javapoet.Util.checkArgument;\n import static com.squareup.javapoet.Util.checkNotNull;\n@@ -164,12 +170,27 @@ public final class MethodSpec {\n   }\n \n   /**\n-   * Create a builder which overrides {@code method}. This will copy its visibility modifiers, type\n-   * parameters, return type, name, parameters, and throws declarations. An {@link Override}\n-   * annotation will be added.\n+   * Create a method spec builder which overrides {@code method}.\n+   * <p>\n+   * Same as {@code overriding(method, (DeclaredType) method.getEnclosingElement().asType())}.\n+   */\n+  public static MethodSpec.Builder overriding(ExecutableElement method,\n+      Elements elements, Types types) {\n+    DeclaredType containing = (DeclaredType) method.getEnclosingElement().asType();\n+    return overriding(method, containing, elements, types);\n+  }\n+\n+  /**\n+   * Create a method spec builder which overrides {@code method} that is viewed as being a member\n+   * of the specified {@code containing} class or interface.\n+   * <p>\n+   * This will copy its visibility modifiers, type parameters, return type, name, parameters, and\n+   * throws declarations. An {@link Override} annotation will be added.\n    */\n-  public static Builder overriding(ExecutableElement method) {\n+  public static Builder overriding(ExecutableElement method, DeclaredType containing,\n+      Elements elements, Types types) {\n     checkNotNull(method, \"method == null\");\n+    checkNotNull(containing, \"containing == null\");\n \n     Set<Modifier> modifiers = method.getModifiers();\n     if (modifiers.contains(Modifier.PRIVATE)\n@@ -181,26 +202,42 @@ public final class MethodSpec {\n     String methodName = method.getSimpleName().toString();\n     MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder(methodName);\n \n-    // TODO copy method annotations.\n-    // TODO check to ensure we're not duplicating override annotation.\n     methodBuilder.addAnnotation(Override.class);\n+    TypeMirror overrideType = elements.getTypeElement(Override.class.getCanonicalName()).asType();\n+    for (AnnotationMirror mirror : method.getAnnotationMirrors()) {\n+      if (types.isSameType(mirror.getAnnotationType(), overrideType)) {\n+        continue;\n+      }\n+      methodBuilder.addAnnotation(AnnotationSpec.get(mirror));\n+    }\n \n-    modifiers = new LinkedHashSet<>(modifiers); // Local copy so we can remove.\n+    modifiers = new LinkedHashSet<>(modifiers);\n     modifiers.remove(Modifier.ABSTRACT);\n     methodBuilder.addModifiers(modifiers);\n \n     for (TypeParameterElement typeParameterElement : method.getTypeParameters()) {\n-      methodBuilder.addTypeVariable(\n-          TypeVariableName.get((TypeVariable) typeParameterElement.asType()));\n-    }\n-\n-    methodBuilder.returns(TypeName.get(method.getReturnType()));\n-\n-    for (VariableElement parameter : method.getParameters()) {\n-      // TODO copy parameter annotations.\n-      methodBuilder.addParameter(TypeName.get(parameter.asType()),\n-          parameter.getSimpleName().toString());\n+      TypeVariable var = (TypeVariable) typeParameterElement.asType();\n+      methodBuilder.addTypeVariable(TypeVariableName.get(var));\n+    }\n+\n+    ExecutableType executableType = (ExecutableType) types.asMemberOf(containing, method);\n+    methodBuilder.returns(TypeName.get(executableType.getReturnType()));\n+\n+    List<? extends VariableElement> parameters = method.getParameters();\n+    List<? extends TypeMirror> parameterTypes = executableType.getParameterTypes();\n+    for (int index = 0; index < parameters.size(); index++) {\n+      VariableElement parameter = parameters.get(index);\n+      TypeName type = TypeName.get(parameterTypes.get(index));\n+      String name = parameter.getSimpleName().toString();\n+      Modifier[] paramods = new Modifier[parameter.getModifiers().size()];\n+      parameter.getModifiers().toArray(paramods);\n+      ParameterSpec.Builder psb = ParameterSpec.builder(type, name, paramods);\n+      for (AnnotationMirror mirror : parameter.getAnnotationMirrors()) {\n+        psb.addAnnotation(AnnotationSpec.get(mirror));\n+      }\n+      methodBuilder.addParameter(psb.build());\n     }\n+    methodBuilder.varargs(method.isVarArgs());\n \n     for (TypeMirror thrownType : method.getThrownTypes()) {\n       methodBuilder.addException(TypeName.get(thrownType));\n"
    },
    {
        "commit_hash": "6d8573cc967b43810ee69cde9f7a60e3542504a2",
        "previous_commit_hash": "d38648e891492c5c57513f7219030d4c1908ba36",
        "diff_stats": {
            "additions": 63,
            "deletions": 26
        },
        "diff_content": "@@ -21,11 +21,17 @@ import java.io.Closeable;\n import java.io.IOException;\n import java.lang.annotation.ElementType;\n import java.lang.annotation.Target;\n+import java.util.Collection;\n import java.util.List;\n+import java.util.concurrent.Callable;\n+import javax.lang.model.element.Element;\n import javax.lang.model.element.ExecutableElement;\n import javax.lang.model.element.Modifier;\n import javax.lang.model.element.TypeElement;\n-import org.junit.Ignore;\n+import javax.lang.model.util.Elements;\n+import javax.lang.model.util.Types;\n+import javax.lang.model.type.DeclaredType;\n+import org.junit.Before;\n import org.junit.Rule;\n import org.junit.Test;\n \n@@ -39,8 +45,25 @@ import static org.mockito.Mockito.when;\n public final class MethodSpecTest {\n   @Rule public final CompilationRule compilation = new CompilationRule();\n \n+  private Elements elements;\n+  private Types types;\n+\n+  @Before public void setUp() {\n+    elements = compilation.getElements();\n+    types = compilation.getTypes();\n+  }\n+\n   private TypeElement getElement(Class<?> clazz) {\n-    return compilation.getElements().getTypeElement(clazz.getCanonicalName());\n+    return elements.getTypeElement(clazz.getCanonicalName());\n+  }\n+\n+  private ExecutableElement findFirst(Collection<ExecutableElement> elements, String name) {\n+    for (ExecutableElement executableElement : elements) {\n+      if (executableElement.getSimpleName().toString().equals(name)) {\n+        return executableElement;\n+      }\n+    }\n+    throw new IllegalArgumentException(name + \" not found in \" + elements);\n   }\n \n   @Test public void nullAnnotationsAddition() {\n@@ -83,71 +106,85 @@ public final class MethodSpecTest {\n   @interface Nullable {\n   }\n \n-  @SuppressWarnings(\"unused\") // Used via mirror API.\n   abstract static class Everything {\n     @Deprecated protected abstract <T extends Runnable & Closeable> Runnable everything(\n         @Nullable String thing, List<? extends T> things) throws IOException, SecurityException;\n   }\n \n-  @SuppressWarnings(\"unused\") // Used via mirror API.\n   abstract static class HasAnnotation {\n     @Override public abstract String toString();\n   }\n \n+  interface ExtendsOthers extends Callable<Integer>, Comparable<Long> {\n+  }\n+\n   @Test public void overrideEverything() {\n     TypeElement classElement = getElement(Everything.class);\n+    DeclaredType classType = (DeclaredType) classElement.asType();\n     ExecutableElement methodElement = getOnlyElement(methodsIn(classElement.getEnclosedElements()));\n-\n-    MethodSpec method = MethodSpec.overriding(methodElement).build();\n+    MethodSpec method = MethodSpec.overriding(methodElement, classType, elements, types).build();\n     assertThat(method.toString()).isEqualTo(\"\"\n         + \"@java.lang.Override\\n\"\n+        + \"@java.lang.Deprecated\\n\"\n         + \"protected <T extends java.lang.Runnable & java.io.Closeable> \"\n-        + \"java.lang.Runnable everything(java.lang.String arg0, java.util.List<? extends T> arg1) \"\n+        + \"java.lang.Runnable everything(\"\n+        + \"@com.squareup.javapoet.MethodSpecTest.Nullable java.lang.String arg0, \"\n+        + \"java.util.List<? extends T> arg1) \"\n         + \"throws java.io.IOException, java.lang.SecurityException {\\n\"\n         + \"}\\n\");\n-    // TODO see TODOs in MethodSpec.override\n-    //assertThat(method.toString()).isEqualTo(\"\"\n-    //    + \"@java.lang.Override\\n\"\n-    //    + \"@java.lang.Deprecated\\n\"\n-    //    + \"protected <T extends java.lang.Runnable & java.io.Closeable> \"\n-    //    + \"java.lang.Runnable everything(\"\n-    //    + \"@com.squareup.javapoet.MethodSpecTest.Nullable java.lang.String arg0, \"\n-    //    + \"java.util.List<? extends T> arg1) \"\n-    //    + \"throws java.io.IOException, java.lang.SecurityException {\\n\"\n-    //    + \"}\\n\");\n   }\n \n-  @Ignore // TODO see TODOs in MethodSpec.override\n   @Test public void overrideDoesNotCopyOverrideAnnotation() {\n-    TypeElement classElement = getElement(Everything.class);\n-    ExecutableElement methodElement = getOnlyElement(methodsIn(classElement.getEnclosedElements()));\n+    TypeElement classElement = getElement(HasAnnotation.class);\n+    DeclaredType classType = (DeclaredType) classElement.asType();\n+    ExecutableElement exec = getOnlyElement(methodsIn(classElement.getEnclosedElements()));\n+    MethodSpec method = MethodSpec.overriding(exec, classType, elements, types).build();\n+    assertThat(method.toString()).isEqualTo(\"\"\n+        + \"@java.lang.Override\\n\"\n+        + \"public java.lang.String toString() {\\n\"\n+        + \"}\\n\");\n+  }\n \n-    MethodSpec method = MethodSpec.overriding(methodElement).build();\n+  @Test public void overrideExtendsOthersWorksWithActualTypeParameters() {\n+    TypeElement classElement = getElement(ExtendsOthers.class);\n+    DeclaredType classType = (DeclaredType) classElement.asType();\n+    List<ExecutableElement> methods = methodsIn(elements.getAllMembers(classElement));\n+    ExecutableElement exec = findFirst(methods, \"call\");\n+    MethodSpec method = MethodSpec.overriding(exec, classType, elements, types).build();\n     assertThat(method.toString()).isEqualTo(\"\"\n         + \"@java.lang.Override\\n\"\n-        + \"public java.lang.String toString() {\"\n-        + \"}\");\n+        + \"public java.lang.Integer call() throws java.lang.Exception {\\n\"\n+        + \"}\\n\");\n+    exec = findFirst(methods, \"compareTo\");\n+    method = MethodSpec.overriding(exec, classType, elements, types).build();\n+    assertThat(method.toString()).isEqualTo(\"\"\n+        + \"@java.lang.Override\\n\"\n+        + \"public int compareTo(java.lang.Long arg0) {\\n\"\n+        + \"}\\n\");\n   }\n \n   @Test public void overrideInvalidModifiers() {\n     ExecutableElement method = mock(ExecutableElement.class);\n     when(method.getModifiers()).thenReturn(ImmutableSet.of(Modifier.FINAL));\n+    Element element = mock(Element.class);\n+    when(element.asType()).thenReturn(mock(DeclaredType.class));\n+    when(method.getEnclosingElement()).thenReturn(element);\n     try {\n-      MethodSpec.overriding(method);\n+      MethodSpec.overriding(method, elements, types);\n       fail();\n     } catch (IllegalArgumentException expected) {\n       assertThat(expected).hasMessage(\"cannot override method with modifiers: [final]\");\n     }\n     when(method.getModifiers()).thenReturn(ImmutableSet.of(Modifier.PRIVATE));\n     try {\n-      MethodSpec.overriding(method);\n+      MethodSpec.overriding(method, elements, types);\n       fail();\n     } catch (IllegalArgumentException expected) {\n       assertThat(expected).hasMessage(\"cannot override method with modifiers: [private]\");\n     }\n     when(method.getModifiers()).thenReturn(ImmutableSet.of(Modifier.STATIC));\n     try {\n-      MethodSpec.overriding(method);\n+      MethodSpec.overriding(method, elements, types);\n       fail();\n     } catch (IllegalArgumentException expected) {\n       assertThat(expected).hasMessage(\"cannot override method with modifiers: [static]\");\n"
    },
    {
        "commit_hash": "0cece47a8a4affd298d9001e129168946f0e9d37",
        "previous_commit_hash": "e5532b4ee2c1551d4e2e6777dbe6e637c27cdc3f",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -3,7 +3,7 @@ JavaPoet\n \n `JavaPoet` is a Java API for generating `.java` source files.\n \n-Source file generation can useful when doing things such as annotation processing or interacting\n+Source file generation can be useful when doing things such as annotation processing or interacting\n with metadata files (e.g., database schemas, protocol formats). By generating code, you eliminate\n the need to write boilerplate while also keeping a single source of truth for the metadata.\n \n"
    },
    {
        "commit_hash": "a89eed06ff6133a99af5b54478ffec183f2f7b85",
        "previous_commit_hash": "eeff85d68dc5a2753c4eb3cc5461c0a106a89167",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -245,7 +245,7 @@ public class TypeName {\n \n   /** Converts an array of types to a list of type names. */\n   static List<TypeName> list(Type[] types) {\n-    List<TypeName> result = new ArrayList<>();\n+    List<TypeName> result = new ArrayList<>(types.length);\n     for (Type type : types) {\n       result.add(get(type));\n     }\n"
    },
    {
        "commit_hash": "8774c6d9f1e6e113e910acd83f6e66b45f953049",
        "previous_commit_hash": "c0413f592a5afee56f9010e07a5e789341c3e874",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -130,6 +130,7 @@ public final class TypeSpec {\n \n     try {\n       if (enumName != null) {\n+        codeWriter.emitJavadoc(javadoc);\n         codeWriter.emit(\"$L\", enumName);\n         if (!anonymousTypeArguments.formatParts.isEmpty()) {\n           codeWriter.emit(\"(\");\n@@ -346,7 +347,6 @@ public final class TypeSpec {\n     }\n \n     public Builder addJavadoc(String format, Object... args) {\n-      checkState(anonymousTypeArguments == null, \"forbidden on anonymous types.\");\n       javadoc.add(format, args);\n       return this;\n     }\n"
    },
    {
        "commit_hash": "8774c6d9f1e6e113e910acd83f6e66b45f953049",
        "previous_commit_hash": "c0413f592a5afee56f9010e07a5e789341c3e874",
        "diff_stats": {
            "additions": 6,
            "deletions": 1
        },
        "diff_content": "@@ -310,7 +310,9 @@ public final class TypeSpecTest {\n   @Test public void enumWithSubclassing() throws Exception {\n     TypeSpec roshambo = TypeSpec.enumBuilder(\"Roshambo\")\n         .addModifiers(Modifier.PUBLIC)\n-        .addEnumConstant(\"ROCK\")\n+        .addEnumConstant(\"ROCK\", TypeSpec.anonymousClassBuilder(\"\")\n+            .addJavadoc(\"Avalanche!\\n\")\n+            .build())\n         .addEnumConstant(\"PAPER\", TypeSpec.anonymousClassBuilder(\"$S\", \"flat\")\n             .addMethod(MethodSpec.methodBuilder(\"toString\")\n                 .addAnnotation(Override.class)\n@@ -337,6 +339,9 @@ public final class TypeSpecTest {\n         + \"import java.lang.String;\\n\"\n         + \"\\n\"\n         + \"public enum Roshambo {\\n\"\n+        + \"  /**\\n\"\n+        + \"   * Avalanche!\\n\"\n+        + \"   */\\n\"\n         + \"  ROCK,\\n\"\n         + \"\\n\"\n         + \"  PAPER(\\\"flat\\\") {\\n\"\n"
    },
    {
        "commit_hash": "5963d9ff4f753dedaaf3ef2814403848e3b2fd8d",
        "previous_commit_hash": "9c15424252db0f8179d381c322439630f97377f0",
        "diff_stats": {
            "additions": 43,
            "deletions": 10
        },
        "diff_content": "@@ -22,6 +22,7 @@ import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Iterator;\n import java.util.List;\n+\n import javax.lang.model.element.Element;\n import javax.lang.model.type.TypeMirror;\n \n@@ -106,41 +107,73 @@ public final class CodeBlock {\n         if (format.charAt(p) != '$') {\n           nextP = format.indexOf('$', p + 1);\n           if (nextP == -1) nextP = format.length();\n+          formatParts.add(format.substring(p, nextP));\n         } else {\n           checkState(p + 1 < format.length(), \"dangling $ in format string %s\", format);\n-          switch (format.charAt(p + 1)) {\n+          /* Rules:\n+           * Format must be in the form $[Numeric Index]{N, L, S, T}\n+           * OR\n+           * in the form ${$, >, <, [, ]}\n+           * Numeric index is ONE BASED (for consistency with java formatting)\n+           * Numeric indexing must refer to a format argument within the args array\n+           * Only progress iteration over the argument iterator if we do not hit an indexed entry\n+           */\n+          int countOfIndexCharacters = 0;\n+          while (isSimpleDigit(format.charAt(p + countOfIndexCharacters + 1))) {\n+            countOfIndexCharacters++;\n+            checkArgument(format.length() > p + countOfIndexCharacters + 1,\n+                \"Dangling format characters '%s' in format string '%s'\",\n+                format.substring(p), format);\n+          }\n+\n+          int argsIndex = -1;\n+          if (countOfIndexCharacters != 0) {\n+            argsIndex = Integer.parseInt(format.substring(p + 1, p + 1 + countOfIndexCharacters));\n+            checkArgument(argsIndex <= args.length,\n+                \"Argument index %s in '%s' is larger than number of parameters\",\n+                argsIndex, format);\n+            checkArgument(argsIndex > 0,\n+                \"Argument index %s in '%s' is less than one, the minimum format index\",\n+                argsIndex, format);\n+          }\n+          switch (format.charAt(p + countOfIndexCharacters + 1)) {\n             case 'N':\n-              this.args.add(argToName(i.next()));\n+              this.args.add(argToName((argsIndex == -1) ? i.next() : args[argsIndex - 1]));\n               break;\n             case 'L':\n-              this.args.add(argToLiteral(i.next()));\n+              this.args.add(argToLiteral((argsIndex == -1) ? i.next() : args[argsIndex - 1]));\n               break;\n             case 'S':\n-              this.args.add(argToString(i.next()));\n+              this.args.add(argToString((argsIndex == -1) ? i.next() : args[argsIndex - 1]));\n               break;\n             case 'T':\n-              this.args.add(argToType(i.next()));\n+              this.args.add(argToType((argsIndex == -1) ? i.next() : args[argsIndex - 1]));\n               break;\n             case '$':\n             case '>':\n             case '<':\n             case '[':\n             case ']':\n+              checkState(argsIndex == -1, \"$$, $>, $<, $[ and $] may not have an index\");\n               break;\n             default:\n               throw new IllegalArgumentException(\"invalid format string: \" + format);\n           }\n \n-          nextP = p + 2;\n+          nextP = p + countOfIndexCharacters + 2;\n+          formatParts.add(String.format(\"%c%c\", format.charAt(p), format.charAt(nextP - 1)));\n         }\n-\n-        formatParts.add(format.substring(p, nextP));\n       }\n-\n-      checkArgument(!i.hasNext(), \"unexpected args for %s: %s\", format, Arrays.asList(args));\n       return this;\n     }\n \n+    /**\n+     * A version of {@link Character#isDigit(char)} that only accepts '0'-'9'.\n+     */\n+    private boolean isSimpleDigit(char toCheck) {\n+      return toCheck >= '0' && toCheck <= '9';\n+    }\n+\n     private String argToName(Object o) {\n       if (o instanceof CharSequence) return o.toString();\n       if (o instanceof ParameterSpec) return ((ParameterSpec) o).name;\n"
    },
    {
        "commit_hash": "5963d9ff4f753dedaaf3ef2814403848e3b2fd8d",
        "previous_commit_hash": "9c15424252db0f8179d381c322439630f97377f0",
        "diff_stats": {
            "additions": 193,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright (C) 2015 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javapoet;\n+\n+import org.junit.Test;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.junit.Assert.fail;\n+\n+public class CodeBlockTest {\n+  \n+  @Test\n+  public void indentCannotBeIndexed() {\n+    try {\n+      CodeBlock.builder().add(\"$1>\", \"taco\").build();\n+      fail();\n+    } catch (IllegalStateException exp) {\n+      assertThat(exp).hasMessage(\"$$, $>, $<, $[ and $] may not have an index\");\n+    }\n+  }\n+  \n+  @Test\n+  public void deindentCannotBeIndexed() {\n+    try {\n+      CodeBlock.builder().add(\"$1<\", \"taco\").build();\n+      fail();\n+    } catch (IllegalStateException exp) {\n+      assertThat(exp).hasMessage(\"$$, $>, $<, $[ and $] may not have an index\");\n+    }\n+  }\n+  \n+  @Test\n+  public void dollarSignEscapeCannotBeIndexed() {\n+    try {\n+      CodeBlock.builder().add(\"$1$\", \"taco\").build();\n+      fail();\n+    } catch (IllegalStateException exp) {\n+      assertThat(exp).hasMessage(\"$$, $>, $<, $[ and $] may not have an index\");\n+    }\n+  }\n+ \n+  @Test\n+  public void statementBeginningCannotBeIndexed() {\n+    try {\n+      CodeBlock.builder().add(\"$1[\", \"taco\").build();\n+      fail();\n+    } catch (IllegalStateException exp) {\n+      assertThat(exp).hasMessage(\"$$, $>, $<, $[ and $] may not have an index\");\n+    }\n+  }\n+  \n+  @Test\n+  public void statementEndingCannotBeIndexed() {\n+    try {\n+      CodeBlock.builder().add(\"$1]\", \"taco\").build();\n+      fail();\n+    } catch (IllegalStateException exp) {\n+      assertThat(exp).hasMessage(\"$$, $>, $<, $[ and $] may not have an index\");\n+    }\n+  }\n+  \n+  @Test\n+  public void nameFormatCanBeIndexed() {\n+    CodeBlock block = CodeBlock.builder().add(\"$N $1N\", \"taco\").build();\n+    assertThat(block.toString()).isEqualTo(\"taco taco\");\n+  }\n+  \n+  @Test\n+  public void literalFormatCanBeIndexed() {\n+    CodeBlock block = CodeBlock.builder().add(\"$L $1L\", \"taco\").build();\n+    assertThat(block.toString()).isEqualTo(\"taco taco\");\n+  }\n+  \n+  @Test\n+  public void stringFormatCanBeIndexed() {\n+    CodeBlock block = CodeBlock.builder().add(\"$S $1S\", \"taco\").build();\n+    assertThat(block.toString()).isEqualTo(\"\\\"taco\\\" \\\"taco\\\"\");\n+  }\n+  \n+  @Test\n+  public void typeFormatCanBeIndexed() {\n+    CodeBlock block = CodeBlock.builder().add(\"$T $1T\", String.class).build();\n+    assertThat(block.toString()).isEqualTo(\"java.lang.String java.lang.String\");\n+  }\n+  \n+  @Test\n+  public void indexTooHigh() {\n+    try {\n+      CodeBlock.builder().add(\"$T $2T\", String.class).build();\n+      fail();\n+    } catch (IllegalArgumentException exp) {\n+      assertThat(exp).hasMessage(\"Argument index 2 in '$T $2T' is larger than number of parameters\");\n+    }\n+  }\n+  \n+  @Test\n+  public void indexIsZero() {\n+    try {\n+    CodeBlock.builder().add(\"$T $0T\", String.class).build();\n+    fail();\n+    } catch(IllegalArgumentException exp) {\n+      assertThat(exp).hasMessage(\"Argument index 0 in '$T $0T' is less than one, the minimum format index\");\n+    }\n+  }\n+  \n+  @Test\n+  public void indexIsNegative() {\n+    try {\n+      CodeBlock.builder().add(\"$T $-1T\", String.class).build();\n+      fail();\n+    } catch (IllegalArgumentException exp) {\n+      assertThat(exp).hasMessage(\"invalid format string: $T $-1T\");\n+    }\n+  }\n+  \n+  @Test\n+  public void indexWithoutFormatType() {\n+    try {\n+      CodeBlock.builder().add(\"$1\", String.class).build();\n+      fail();\n+    } catch (IllegalArgumentException exp) {\n+      assertThat(exp).hasMessage(\"Dangling format characters '$1' in format string '$1'\");\n+    }\n+  }\n+  \n+  @Test\n+  public void indexWithoutFormatTypeNotAtStringEnd() {\n+    try {\n+      CodeBlock.builder().add(\"$1 taco\", String.class).build();\n+      fail();\n+    } catch (IllegalArgumentException exp) {\n+      assertThat(exp).hasMessage(\"invalid format string: $1 taco\");\n+    }\n+  }\n+  \n+  @Test\n+  public void formatIndicatorAlone() {\n+    try {\n+      CodeBlock.builder().add(\"$\", String.class).build();\n+      fail();\n+    } catch (IllegalStateException exp) {\n+      assertThat(exp).hasMessage(\"dangling $ in format string $\");\n+    }\n+  }\n+  \n+  @Test\n+  public void formatIndicatorWithoutIndexOrFormatType() {\n+    try {\n+      CodeBlock.builder().add(\"$ tacoString\", String.class).build();\n+      fail();\n+    } catch (IllegalArgumentException exp) {\n+      assertThat(exp).hasMessage(\"invalid format string: $ tacoString\");\n+    }\n+  }\n+  \n+  @Test\n+  public void indexingDoesNotIncreaseNaturalIndex() {\n+    CodeBlock block = CodeBlock.builder().add(\"$L $L $2L $L\", 1, 2, 3).build();\n+    assertThat(block.toString()).isEqualTo(\"1 2 2 3\");\n+  }\n+  \n+  @Test\n+  public void indexingSelectsProperPosition() {\n+    CodeBlock block = CodeBlock.builder().add(\"$L $L $L $3L $2L $1L\", 1, 2, 3).build();\n+    assertThat(block.toString()).isEqualTo(\"1 2 3 3 2 1\");\n+  }\n+  \n+  @Test\n+  public void indexingCanBeInterleved() {\n+    CodeBlock block = CodeBlock.builder().add(\"$L $3L $L $2L $L $1L\", 1, 2, 3).build();\n+    assertThat(block.toString()).isEqualTo(\"1 3 2 2 3 1\");\n+  }\n+  \n+  @Test\n+  public void sameIndexCanBeUsedWithDifferentFormats() {\n+    CodeBlock block = CodeBlock.builder().add(\"$1T.out.println($1S)\", ClassName.get(System.class)).build();\n+    assertThat(block.toString()).isEqualTo(\"java.lang.System.out.println(\\\"java.lang.System\\\")\");\n+  }\n+  \n+}\n"
    },
    {
        "commit_hash": "5963d9ff4f753dedaaf3ef2814403848e3b2fd8d",
        "previous_commit_hash": "9c15424252db0f8179d381c322439630f97377f0",
        "diff_stats": {
            "additions": 26,
            "deletions": 9
        },
        "diff_content": "@@ -1043,6 +1043,32 @@ public final class TypeSpecTest {\n         + \"  }\\n\"\n         + \"}\\n\");\n   }\n+  \n+  @Test public void indexedElseIf() throws Exception {\n+    TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n+        .addMethod(MethodSpec.methodBuilder(\"choices\")\n+            .beginControlFlow(\"if ($1L != null || $1L == $2L)\", \"taco\", \"otherTaco\")\n+            .addStatement(\"$T.out.println($S)\", System.class, \"only one taco? NOO!\")\n+            .nextControlFlow(\"else if ($1L.$3L && $2L.$3L)\", \"taco\", \"otherTaco\", \"isSupreme()\")\n+            .addStatement(\"$T.out.println($S)\", System.class, \"taco heaven\")\n+            .endControlFlow()\n+            .build())\n+        .build();\n+    assertThat(toString(taco)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import java.lang.System;\\n\"\n+        + \"\\n\"\n+        + \"class Taco {\\n\"\n+        + \"  void choices() {\\n\"\n+        + \"    if (taco != null || taco == otherTaco) {\\n\"\n+        + \"      System.out.println(\\\"only one taco? NOO!\\\");\\n\"\n+        + \"    } else if (taco.isSupreme() && otherTaco.isSupreme()) {\\n\"\n+        + \"      System.out.println(\\\"taco heaven\\\");\\n\"\n+        + \"    }\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n \n   @Test public void elseIf() throws Exception {\n     TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n@@ -1818,15 +1844,6 @@ public final class TypeSpecTest {\n     }\n   }\n \n-  @Test public void tooManyArguments() {\n-    try {\n-      CodeBlock.builder().add(\"$$\", \"foo\");\n-      fail();\n-    } catch (IllegalArgumentException expected) {\n-      assertThat(expected).hasMessage(\"unexpected args for $$: [foo]\");\n-    }\n-  }\n-\n   @Test public void tooFewArguments() {\n     try {\n       CodeBlock.builder().add(\"$S\");\n"
    },
    {
        "commit_hash": "aa8980fcb8b14698bc970ba4571582dc6729ca9f",
        "previous_commit_hash": "553fe8a18d54e4b3bda42d439687ba59b9b6b2e3",
        "diff_stats": {
            "additions": 43,
            "deletions": 37
        },
        "diff_content": "@@ -24,7 +24,6 @@ import java.util.Iterator;\n import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Set;\n-\n import javax.lang.model.SourceVersion;\n import javax.lang.model.element.AnnotationMirror;\n import javax.lang.model.element.ExecutableElement;\n@@ -35,7 +34,6 @@ import javax.lang.model.type.DeclaredType;\n import javax.lang.model.type.ExecutableType;\n import javax.lang.model.type.TypeMirror;\n import javax.lang.model.type.TypeVariable;\n-import javax.lang.model.util.Elements;\n import javax.lang.model.util.Types;\n \n import static com.squareup.javapoet.Util.checkArgument;\n@@ -45,6 +43,7 @@ import static com.squareup.javapoet.Util.checkState;\n /** A generated constructor or method declaration. */\n public final class MethodSpec {\n   static final String CONSTRUCTOR = \"<init>\";\n+  static final ClassName OVERRIDE = ClassName.get(Override.class);\n \n   public final String name;\n   public final CodeBlock javadoc;\n@@ -170,27 +169,13 @@ public final class MethodSpec {\n   }\n \n   /**\n-   * Create a method spec builder which overrides {@code method}.\n-   * <p>\n-   * Same as {@code overriding(method, (DeclaredType) method.getEnclosingElement().asType())}.\n-   */\n-  public static MethodSpec.Builder overriding(ExecutableElement method,\n-      Elements elements, Types types) {\n-    DeclaredType containing = (DeclaredType) method.getEnclosingElement().asType();\n-    return overriding(method, containing, elements, types);\n-  }\n-\n-  /**\n-   * Create a method spec builder which overrides {@code method} that is viewed as being a member\n-   * of the specified {@code containing} class or interface.\n-   * <p>\n-   * This will copy its visibility modifiers, type parameters, return type, name, parameters, and\n+   * Returns a new method spec builder that overrides {@code method}.\n+   *\n+   * <p>This will copy its visibility modifiers, type parameters, return type, name, parameters, and\n    * throws declarations. An {@link Override} annotation will be added.\n    */\n-  public static Builder overriding(ExecutableElement method, DeclaredType containing,\n-      Elements elements, Types types) {\n+  public static Builder overriding(ExecutableElement method) {\n     checkNotNull(method, \"method == null\");\n-    checkNotNull(containing, \"containing == null\");\n \n     Set<Modifier> modifiers = method.getModifiers();\n     if (modifiers.contains(Modifier.PRIVATE)\n@@ -202,13 +187,11 @@ public final class MethodSpec {\n     String methodName = method.getSimpleName().toString();\n     MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder(methodName);\n \n-    methodBuilder.addAnnotation(Override.class);\n-    TypeMirror overrideType = elements.getTypeElement(Override.class.getCanonicalName()).asType();\n+    methodBuilder.addAnnotation(OVERRIDE);\n     for (AnnotationMirror mirror : method.getAnnotationMirrors()) {\n-      if (types.isSameType(mirror.getAnnotationType(), overrideType)) {\n-        continue;\n-      }\n-      methodBuilder.addAnnotation(AnnotationSpec.get(mirror));\n+      AnnotationSpec annotationSpec = AnnotationSpec.get(mirror);\n+      if (annotationSpec.type.equals(OVERRIDE)) continue;\n+      methodBuilder.addAnnotation(annotationSpec);\n     }\n \n     modifiers = new LinkedHashSet<>(modifiers);\n@@ -220,22 +203,19 @@ public final class MethodSpec {\n       methodBuilder.addTypeVariable(TypeVariableName.get(var));\n     }\n \n-    ExecutableType executableType = (ExecutableType) types.asMemberOf(containing, method);\n-    methodBuilder.returns(TypeName.get(executableType.getReturnType()));\n+    methodBuilder.returns(TypeName.get(method.getReturnType()));\n \n     List<? extends VariableElement> parameters = method.getParameters();\n-    List<? extends TypeMirror> parameterTypes = executableType.getParameterTypes();\n-    for (int index = 0; index < parameters.size(); index++) {\n-      VariableElement parameter = parameters.get(index);\n-      TypeName type = TypeName.get(parameterTypes.get(index));\n+    for (VariableElement parameter : parameters) {\n+      TypeName type = TypeName.get(parameter.asType());\n       String name = parameter.getSimpleName().toString();\n-      Modifier[] paramods = new Modifier[parameter.getModifiers().size()];\n-      parameter.getModifiers().toArray(paramods);\n-      ParameterSpec.Builder psb = ParameterSpec.builder(type, name, paramods);\n+      Set<Modifier> parameterModifiers = parameter.getModifiers();\n+      ParameterSpec.Builder parameterBuilder = ParameterSpec.builder(type, name)\n+          .addModifiers(parameterModifiers.toArray(new Modifier[parameterModifiers.size()]));\n       for (AnnotationMirror mirror : parameter.getAnnotationMirrors()) {\n-        psb.addAnnotation(AnnotationSpec.get(mirror));\n+        parameterBuilder.addAnnotation(AnnotationSpec.get(mirror));\n       }\n-      methodBuilder.addParameter(psb.build());\n+      methodBuilder.addParameter(parameterBuilder.build());\n     }\n     methodBuilder.varargs(method.isVarArgs());\n \n@@ -246,6 +226,32 @@ public final class MethodSpec {\n     return methodBuilder;\n   }\n \n+  /**\n+   * Returns a new method spec builder that overrides {@code method} as a member of {@code\n+   * enclosing}. This will resolve type parameters: for example overriding {@link\n+   * Comparable#compareTo} in a type that implements {@code Comparable<Movie>}, the {@code T}\n+   * parameter will be resolved to {@code Movie}.\n+   *\n+   * <p>This will copy its visibility modifiers, type parameters, return type, name, parameters, and\n+   * throws declarations. An {@link Override} annotation will be added.\n+   */\n+  public static Builder overriding(\n+      ExecutableElement method, DeclaredType enclosing, Types types) {\n+    ExecutableType executableType = (ExecutableType) types.asMemberOf(enclosing, method);\n+    List<? extends TypeMirror> resolvedParameterTypes = executableType.getParameterTypes();\n+    TypeMirror resolvedReturnType = executableType.getReturnType();\n+\n+    Builder builder = overriding(method);\n+    builder.returns(TypeName.get(resolvedReturnType));\n+    for (int i = 0, size = builder.parameters.size(); i < size; i++) {\n+      ParameterSpec parameter = builder.parameters.get(i);\n+      TypeName type = TypeName.get(resolvedParameterTypes.get(i));\n+      builder.parameters.set(i, parameter.toBuilder(type, parameter.name).build());\n+    }\n+\n+    return builder;\n+  }\n+\n   public Builder toBuilder() {\n     Builder builder = new Builder(name);\n     builder.javadoc.add(javadoc);\n"
    },
    {
        "commit_hash": "aa8980fcb8b14698bc970ba4571582dc6729ca9f",
        "previous_commit_hash": "553fe8a18d54e4b3bda42d439687ba59b9b6b2e3",
        "diff_stats": {
            "additions": 4,
            "deletions": 0
        },
        "diff_content": "@@ -79,6 +79,10 @@ public final class ParameterSpec {\n   }\n \n   public Builder toBuilder() {\n+    return toBuilder(type, name);\n+  }\n+\n+  Builder toBuilder(TypeName type, String name) {\n     Builder builder = new Builder(type, name);\n     builder.annotations.addAll(annotations);\n     builder.modifiers.addAll(modifiers);\n"
    },
    {
        "commit_hash": "aa8980fcb8b14698bc970ba4571582dc6729ca9f",
        "previous_commit_hash": "553fe8a18d54e4b3bda42d439687ba59b9b6b2e3",
        "diff_stats": {
            "additions": 8,
            "deletions": 10
        },
        "diff_content": "@@ -28,9 +28,9 @@ import javax.lang.model.element.Element;\n import javax.lang.model.element.ExecutableElement;\n import javax.lang.model.element.Modifier;\n import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.DeclaredType;\n import javax.lang.model.util.Elements;\n import javax.lang.model.util.Types;\n-import javax.lang.model.type.DeclaredType;\n import org.junit.Before;\n import org.junit.Rule;\n import org.junit.Test;\n@@ -120,9 +120,8 @@ public final class MethodSpecTest {\n \n   @Test public void overrideEverything() {\n     TypeElement classElement = getElement(Everything.class);\n-    DeclaredType classType = (DeclaredType) classElement.asType();\n     ExecutableElement methodElement = getOnlyElement(methodsIn(classElement.getEnclosedElements()));\n-    MethodSpec method = MethodSpec.overriding(methodElement, classType, elements, types).build();\n+    MethodSpec method = MethodSpec.overriding(methodElement).build();\n     assertThat(method.toString()).isEqualTo(\"\"\n         + \"@java.lang.Override\\n\"\n         + \"@java.lang.Deprecated\\n\"\n@@ -136,9 +135,8 @@ public final class MethodSpecTest {\n \n   @Test public void overrideDoesNotCopyOverrideAnnotation() {\n     TypeElement classElement = getElement(HasAnnotation.class);\n-    DeclaredType classType = (DeclaredType) classElement.asType();\n     ExecutableElement exec = getOnlyElement(methodsIn(classElement.getEnclosedElements()));\n-    MethodSpec method = MethodSpec.overriding(exec, classType, elements, types).build();\n+    MethodSpec method = MethodSpec.overriding(exec).build();\n     assertThat(method.toString()).isEqualTo(\"\"\n         + \"@java.lang.Override\\n\"\n         + \"public java.lang.String toString() {\\n\"\n@@ -150,13 +148,13 @@ public final class MethodSpecTest {\n     DeclaredType classType = (DeclaredType) classElement.asType();\n     List<ExecutableElement> methods = methodsIn(elements.getAllMembers(classElement));\n     ExecutableElement exec = findFirst(methods, \"call\");\n-    MethodSpec method = MethodSpec.overriding(exec, classType, elements, types).build();\n+    MethodSpec method = MethodSpec.overriding(exec, classType, types).build();\n     assertThat(method.toString()).isEqualTo(\"\"\n         + \"@java.lang.Override\\n\"\n         + \"public java.lang.Integer call() throws java.lang.Exception {\\n\"\n         + \"}\\n\");\n     exec = findFirst(methods, \"compareTo\");\n-    method = MethodSpec.overriding(exec, classType, elements, types).build();\n+    method = MethodSpec.overriding(exec, classType, types).build();\n     assertThat(method.toString()).isEqualTo(\"\"\n         + \"@java.lang.Override\\n\"\n         + \"public int compareTo(java.lang.Long arg0) {\\n\"\n@@ -170,21 +168,21 @@ public final class MethodSpecTest {\n     when(element.asType()).thenReturn(mock(DeclaredType.class));\n     when(method.getEnclosingElement()).thenReturn(element);\n     try {\n-      MethodSpec.overriding(method, elements, types);\n+      MethodSpec.overriding(method);\n       fail();\n     } catch (IllegalArgumentException expected) {\n       assertThat(expected).hasMessage(\"cannot override method with modifiers: [final]\");\n     }\n     when(method.getModifiers()).thenReturn(ImmutableSet.of(Modifier.PRIVATE));\n     try {\n-      MethodSpec.overriding(method, elements, types);\n+      MethodSpec.overriding(method);\n       fail();\n     } catch (IllegalArgumentException expected) {\n       assertThat(expected).hasMessage(\"cannot override method with modifiers: [private]\");\n     }\n     when(method.getModifiers()).thenReturn(ImmutableSet.of(Modifier.STATIC));\n     try {\n-      MethodSpec.overriding(method, elements, types);\n+      MethodSpec.overriding(method);\n       fail();\n     } catch (IllegalArgumentException expected) {\n       assertThat(expected).hasMessage(\"cannot override method with modifiers: [static]\");\n"
    },
    {
        "commit_hash": "49d1d83a68023d35facec7103d46fb6b073810fe",
        "previous_commit_hash": "553fe8a18d54e4b3bda42d439687ba59b9b6b2e3",
        "diff_stats": {
            "additions": 10,
            "deletions": 0
        },
        "diff_content": "@@ -1,6 +1,16 @@\n Change Log\n ==========\n \n+JavaPoet 1.2.0 *(TBA)*\n+----------------------------\n+\n+ * New: Arguments may have positional indexes like `$1T` and `$2N`. Indexes can be used to refer to\n+   the same argument multiple times in a single format string.\n+ * New: Permit Javadoc on enum constants.\n+ * New: Class initializer blocks with `addStaticBlock()`.\n+ * Fix: `MethodSpec.overriding()` retains annotations.\n+\n+\n JavaPoet 1.1.0 *(2015-05-25)*\n ----------------------------\n \n"
    },
    {
        "commit_hash": "fe9cc5f18a8c90ff421aff2a5f68bd6ffc60b8b5",
        "previous_commit_hash": "8694525ae7533cff932e55239da5725180df62f6",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -1,7 +1,7 @@\n Change Log\n ==========\n \n-JavaPoet 1.2.0 *(TBA)*\n+JavaPoet 1.2.0 *(2015-07-04)*\n ----------------------------\n \n  * New: Arguments may have positional indexes like `$1T` and `$2N`. Indexes can be used to refer to\n"
    },
    {
        "commit_hash": "639f406d30515f0ae0793180d54be456d1b68414",
        "previous_commit_hash": "fe9cc5f18a8c90ff421aff2a5f68bd6ffc60b8b5",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.2.0-SNAPSHOT</version>\n+  <version>1.2.0</version>\n \n   <name>JavaPoet</name>\n   <description>Use beautiful Java code to generate beautiful Java code.</description>\n@@ -54,13 +54,13 @@\n     <dependency>\n       <groupId>com.google.truth</groupId>\n       <artifactId>truth</artifactId>\n-      <version>1.0-SNAPSHOT</version>\n+      <version>0.25</version>\n       <scope>test</scope>\n     </dependency>\n     <dependency>\n       <groupId>com.google.testing.compile</groupId>\n       <artifactId>compile-testing</artifactId>\n-      <version>1.0-SNAPSHOT</version>\n+      <version>0.6</version>\n       <scope>test</scope>\n     </dependency>\n     <dependency>\n"
    },
    {
        "commit_hash": "b0991083e2b785b86ba55d941c9d3d409909affc",
        "previous_commit_hash": "639f406d30515f0ae0793180d54be456d1b68414",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.2.0</version>\n+  <version>1.3.0-SNAPSHOT</version>\n \n   <name>JavaPoet</name>\n   <description>Use beautiful Java code to generate beautiful Java code.</description>\n@@ -54,13 +54,13 @@\n     <dependency>\n       <groupId>com.google.truth</groupId>\n       <artifactId>truth</artifactId>\n-      <version>0.25</version>\n+      <version>1.0-SNAPSHOT</version>\n       <scope>test</scope>\n     </dependency>\n     <dependency>\n       <groupId>com.google.testing.compile</groupId>\n       <artifactId>compile-testing</artifactId>\n-      <version>0.6</version>\n+      <version>1.0-SNAPSHOT</version>\n       <scope>test</scope>\n     </dependency>\n     <dependency>\n"
    },
    {
        "commit_hash": "12ffaab09687925b6fddf720dfd65facd63395f0",
        "previous_commit_hash": "b0991083e2b785b86ba55d941c9d3d409909affc",
        "diff_stats": {
            "additions": 38,
            "deletions": 0
        },
        "diff_content": "@@ -17,6 +17,7 @@ package com.squareup.javapoet;\n \n import java.util.Date;\n import javax.lang.model.element.Modifier;\n+import org.junit.Ignore;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n@@ -116,6 +117,43 @@ public final class JavaFileTest {\n         + \"}\\n\");\n   }\n \n+  @Ignore(\"https://github.com/square/javapoet/issues/298\")\n+  @Test public void conflictingSimpleNames() throws Exception {\n+    String source = JavaFile.builder(\"com.squareup.tacos\",\n+        TypeSpec.classBuilder(\"A\")\n+            .addType(TypeSpec.classBuilder(\"B\")\n+                .addType(TypeSpec.classBuilder(\"Twin\").build())\n+                .addType(TypeSpec.classBuilder(\"C\")\n+                    .addField(ClassName.get(\"com.squareup.tacos\", \"A\", \"Twin\", \"D\"), \"d\")\n+                    .build())\n+                .build())\n+            .addType(TypeSpec.classBuilder(\"Twin\")\n+                .addType(TypeSpec.classBuilder(\"D\")\n+                    .build())\n+                .build())\n+            .build())\n+        .build()\n+        .toString();\n+    assertThat(source).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"class A {\\n\"\n+        + \"  class B {\\n\"\n+        + \"    class Twin {\\n\"\n+        + \"    }\\n\"\n+        + \"\\n\"\n+        + \"    class C {\\n\"\n+        + \"      A.Twin.D d;\\n\"\n+        + \"    }\\n\"\n+        + \"  }\\n\"\n+        + \"\\n\"\n+        + \"  class Twin {\\n\"\n+        + \"    class D {\\n\"\n+        + \"    }\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n   @Test public void defaultPackage() throws Exception {\n     String source = JavaFile.builder(\"\",\n         TypeSpec.classBuilder(\"HelloWorld\")\n"
    },
    {
        "commit_hash": "5a37c2aa596377cb4c9b6f916614407fd0a7d3db",
        "previous_commit_hash": "dfa195e79e03f5e9846be8c475eb61b687de7ef5",
        "diff_stats": {
            "additions": 6,
            "deletions": 0
        },
        "diff_content": "@@ -81,6 +81,12 @@\n       <version>1.10.16</version>\n       <scope>test</scope>\n     </dependency>\n+    <dependency>\n+      <groupId>org.eclipse.jdt.core.compiler</groupId>\n+      <artifactId>ecj</artifactId>\n+      <version>4.4.2</version>\n+      <scope>test</scope>\n+    </dependency>\n   </dependencies>\n \n   <build>\n"
    },
    {
        "commit_hash": "5a37c2aa596377cb4c9b6f916614407fd0a7d3db",
        "previous_commit_hash": "dfa195e79e03f5e9846be8c475eb61b687de7ef5",
        "diff_stats": {
            "additions": 10,
            "deletions": 0
        },
        "diff_content": "@@ -25,6 +25,7 @@ import java.util.Collections;\n import java.util.List;\n import javax.lang.model.element.NestingKind;\n import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.TypeParameterElement;\n import javax.lang.model.type.DeclaredType;\n import javax.lang.model.type.TypeKind;\n import javax.lang.model.type.TypeMirror;\n@@ -120,6 +121,15 @@ public final class TypeVariableName extends TypeName {\n         result.addAll(upperBoundElement.getInterfaces());\n         return result;\n       }\n+    } else if (upperBound.getKind() == TypeKind.TYPEVAR) {\n+      // Workaround for intersection types in Eclipse:\n+      // Eclipse returns an equivalent TypeVariable for intersection types\n+      // (wrapping the same internal TypeVariableBinding).\n+      TypeParameterElement upperBoundElement =\n+          (TypeParameterElement) ((javax.lang.model.type.TypeVariable) upperBound).asElement();\n+      if (upperBoundElement.equals(typeVariable.asElement())) {\n+        return upperBoundElement.getBounds();\n+      }\n     }\n \n     return Collections.singletonList(upperBound);\n"
    },
    {
        "commit_hash": "5a37c2aa596377cb4c9b6f916614407fd0a7d3db",
        "previous_commit_hash": "dfa195e79e03f5e9846be8c475eb61b687de7ef5",
        "diff_stats": {
            "additions": 220,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,220 @@\n+/*\n+ * Copyright (C) 2014 Google, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javapoet;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.junit.Assert.*;\n+\n+import java.io.Serializable;\n+import java.nio.charset.Charset;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.TypeParameterElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.type.WildcardType;\n+import javax.lang.model.util.Elements;\n+import javax.lang.model.util.Types;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+import com.google.testing.compile.CompilationRule;\n+\n+public abstract class AbstractTypesTest {\n+  protected abstract Elements getElements();\n+  protected abstract Types getTypes();\n+\n+  private TypeElement getElement(Class<?> clazz) {\n+    return getElements().getTypeElement(clazz.getCanonicalName());\n+  }\n+\n+  private TypeMirror getMirror(Class<?> clazz) {\n+    return getElement(clazz).asType();\n+  }\n+\n+  @Test public void getBasicTypeMirror() {\n+    assertThat(TypeName.get(getMirror(Object.class)))\n+        .isEqualTo(ClassName.get(Object.class));\n+    assertThat(TypeName.get(getMirror(Charset.class)))\n+        .isEqualTo(ClassName.get(Charset.class));\n+    assertThat(TypeName.get(getMirror(AbstractTypesTest.class)))\n+        .isEqualTo(ClassName.get(AbstractTypesTest.class));\n+  }\n+\n+  @Test public void getParameterizedTypeMirror() {\n+    DeclaredType setType =\n+        getTypes().getDeclaredType(getElement(Set.class), getMirror(Object.class));\n+    assertThat(TypeName.get(setType))\n+        .isEqualTo(ParameterizedTypeName.get(ClassName.get(Set.class), ClassName.OBJECT));\n+  }\n+\n+  static class Parameterized<\n+      Simple,\n+      ExtendsClass extends Number,\n+      ExtendsInterface extends Runnable,\n+      ExtendsTypeVariable extends Simple,\n+      Intersection extends Number & Runnable,\n+      IntersectionOfInterfaces extends Runnable & Serializable> {}\n+\n+  @Test public void getTypeVariableTypeMirror() {\n+    List<? extends TypeParameterElement> typeVariables =\n+        getElement(Parameterized.class).getTypeParameters();\n+\n+    // Members of converted types use ClassName and not Class<?>.\n+    ClassName number = ClassName.get(Number.class);\n+    ClassName runnable = ClassName.get(Runnable.class);\n+    ClassName serializable = ClassName.get(Serializable.class);\n+\n+    assertThat(TypeName.get(typeVariables.get(0).asType()))\n+        .isEqualTo(TypeVariableName.get(\"Simple\"));\n+    assertThat(TypeName.get(typeVariables.get(1).asType()))\n+        .isEqualTo(TypeVariableName.get(\"ExtendsClass\", number));\n+    assertThat(TypeName.get(typeVariables.get(2).asType()))\n+        .isEqualTo(TypeVariableName.get(\"ExtendsInterface\", runnable));\n+    assertThat(TypeName.get(typeVariables.get(3).asType()))\n+        .isEqualTo(TypeVariableName.get(\"ExtendsTypeVariable\", TypeVariableName.get(\"Simple\")));\n+    assertThat(TypeName.get(typeVariables.get(4).asType()))\n+        .isEqualTo(TypeVariableName.get(\"Intersection\", number, runnable));\n+    assertThat(TypeName.get(typeVariables.get(5).asType()))\n+        .isEqualTo(TypeVariableName.get(\"IntersectionOfInterfaces\", runnable, serializable));\n+    assertThat(((TypeVariableName) TypeName.get(typeVariables.get(4).asType())).bounds)\n+        .containsExactly(number, runnable);\n+  }\n+\n+  @Test public void getPrimitiveTypeMirror() {\n+    assertThat(TypeName.get(getTypes().getPrimitiveType(TypeKind.BOOLEAN)))\n+        .isEqualTo(TypeName.BOOLEAN);\n+    assertThat(TypeName.get(getTypes().getPrimitiveType(TypeKind.BYTE)))\n+        .isEqualTo(TypeName.BYTE);\n+    assertThat(TypeName.get(getTypes().getPrimitiveType(TypeKind.SHORT)))\n+        .isEqualTo(TypeName.SHORT);\n+    assertThat(TypeName.get(getTypes().getPrimitiveType(TypeKind.INT)))\n+        .isEqualTo(TypeName.INT);\n+    assertThat(TypeName.get(getTypes().getPrimitiveType(TypeKind.LONG)))\n+        .isEqualTo(TypeName.LONG);\n+    assertThat(TypeName.get(getTypes().getPrimitiveType(TypeKind.CHAR)))\n+        .isEqualTo(TypeName.CHAR);\n+    assertThat(TypeName.get(getTypes().getPrimitiveType(TypeKind.FLOAT)))\n+        .isEqualTo(TypeName.FLOAT);\n+    assertThat(TypeName.get(getTypes().getPrimitiveType(TypeKind.DOUBLE)))\n+        .isEqualTo(TypeName.DOUBLE);\n+  }\n+\n+  @Test public void getArrayTypeMirror() {\n+    assertThat(TypeName.get(getTypes().getArrayType(getMirror(Object.class))))\n+        .isEqualTo(ArrayTypeName.of(ClassName.OBJECT));\n+  }\n+\n+  @Test public void getVoidTypeMirror() {\n+    assertThat(TypeName.get(getTypes().getNoType(TypeKind.VOID)))\n+        .isEqualTo(TypeName.VOID);\n+  }\n+\n+  @Test public void getNullTypeMirror() {\n+    try {\n+      TypeName.get(getTypes().getNullType());\n+      fail();\n+    } catch (IllegalArgumentException expected) {\n+    }\n+  }\n+\n+  @Test public void parameterizedType() throws Exception {\n+    ParameterizedTypeName type = ParameterizedTypeName.get(Map.class, String.class, Long.class);\n+    assertThat(type.toString()).isEqualTo(\"java.util.Map<java.lang.String, java.lang.Long>\");\n+  }\n+\n+  @Test public void arrayType() throws Exception {\n+    ArrayTypeName type = ArrayTypeName.of(String.class);\n+    assertThat(type.toString()).isEqualTo(\"java.lang.String[]\");\n+  }\n+\n+  @Test public void wildcardExtendsType() throws Exception {\n+    WildcardTypeName type = WildcardTypeName.subtypeOf(CharSequence.class);\n+    assertThat(type.toString()).isEqualTo(\"? extends java.lang.CharSequence\");\n+  }\n+\n+  @Test public void wildcardExtendsObject() throws Exception {\n+    WildcardTypeName type = WildcardTypeName.subtypeOf(Object.class);\n+    assertThat(type.toString()).isEqualTo(\"?\");\n+  }\n+\n+  @Test public void wildcardSuperType() throws Exception {\n+    WildcardTypeName type = WildcardTypeName.supertypeOf(String.class);\n+    assertThat(type.toString()).isEqualTo(\"? super java.lang.String\");\n+  }\n+\n+  @Test public void wildcardMirrorNoBounds() throws Exception {\n+    WildcardType wildcard = getTypes().getWildcardType(null, null);\n+    TypeName type = TypeName.get(wildcard);\n+    assertThat(type.toString()).isEqualTo(\"?\");\n+  }\n+\n+  @Test public void wildcardMirrorExtendsType() throws Exception {\n+    Types types = getTypes();\n+    Elements elements = getElements();\n+    TypeMirror charSequence = elements.getTypeElement(CharSequence.class.getName()).asType();\n+    WildcardType wildcard = types.getWildcardType(charSequence, null);\n+    TypeName type = TypeName.get(wildcard);\n+    assertThat(type.toString()).isEqualTo(\"? extends java.lang.CharSequence\");\n+  }\n+\n+  @Test public void wildcardMirrorSuperType() throws Exception {\n+    Types types = getTypes();\n+    Elements elements = getElements();\n+    TypeMirror string = elements.getTypeElement(String.class.getName()).asType();\n+    WildcardType wildcard = types.getWildcardType(null, string);\n+    TypeName type = TypeName.get(wildcard);\n+    assertThat(type.toString()).isEqualTo(\"? super java.lang.String\");\n+  }\n+\n+  @Test public void typeVariable() throws Exception {\n+    TypeVariableName type = TypeVariableName.get(\"T\", CharSequence.class);\n+    assertThat(type.toString()).isEqualTo(\"T\"); // (Bounds are only emitted in declaration.)\n+  }\n+\n+  @Test public void box() throws Exception {\n+    assertThat(TypeName.INT.box()).isEqualTo(ClassName.get(Integer.class));\n+    assertThat(TypeName.VOID.box()).isEqualTo(ClassName.get(Void.class));\n+    assertThat(ClassName.get(Integer.class).box()).isEqualTo(ClassName.get(Integer.class));\n+    assertThat(ClassName.get(Void.class).box()).isEqualTo(ClassName.get(Void.class));\n+    assertThat(TypeName.OBJECT.box()).isEqualTo(TypeName.OBJECT);\n+    assertThat(ClassName.get(String.class).box()).isEqualTo(ClassName.get(String.class));\n+  }\n+\n+  @Test public void unbox() throws Exception {\n+    assertThat(TypeName.INT).isEqualTo(TypeName.INT.unbox());\n+    assertThat(TypeName.VOID).isEqualTo(TypeName.VOID.unbox());\n+    assertThat(ClassName.get(Integer.class).unbox()).isEqualTo(TypeName.INT.unbox());\n+    assertThat(ClassName.get(Void.class).unbox()).isEqualTo(TypeName.VOID.unbox());\n+    try {\n+      TypeName.OBJECT.unbox();\n+      fail();\n+    } catch (UnsupportedOperationException expected) {\n+    }\n+    try {\n+      ClassName.get(String.class).unbox();\n+      fail();\n+    } catch (UnsupportedOperationException expected) {\n+    }\n+  }\n+}\n"
    },
    {
        "commit_hash": "5a37c2aa596377cb4c9b6f916614407fd0a7d3db",
        "previous_commit_hash": "dfa195e79e03f5e9846be8c475eb61b687de7ef5",
        "diff_stats": {
            "additions": 158,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,158 @@\n+/*\n+ * Copyright (C) 2014 Google, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javapoet;\n+\n+import static com.google.common.base.Charsets.*;\n+import static com.google.common.base.Preconditions.*;\n+\n+import java.util.Locale;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.processing.AbstractProcessor;\n+import javax.annotation.processing.ProcessingEnvironment;\n+import javax.annotation.processing.Processor;\n+import javax.annotation.processing.RoundEnvironment;\n+import javax.lang.model.SourceVersion;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.util.Elements;\n+import javax.lang.model.util.Types;\n+import javax.tools.DiagnosticCollector;\n+import javax.tools.JavaCompiler;\n+import javax.tools.JavaFileManager;\n+import javax.tools.JavaFileObject;\n+\n+import org.eclipse.jdt.internal.compiler.tool.EclipseCompiler;\n+import org.junit.Rule;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.junit.runners.model.Statement;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+@RunWith(JUnit4.class)\n+public final class TypesEclipseTest extends AbstractTypesTest {\n+  /**\n+   * A {@link JUnit4} {@link Rule} that executes tests such that a instances of {@link Elements} and\n+   * {@link Types} are available during execution.\n+   *\n+   * <p>To use this rule in a test, just add the following field: <pre>   {@code\n+   *   @Rule public CompilationRule compilationRule = new CompilationRule();}\n+   *\n+   * @author Gregory Kick\n+   */\n+  public static final class CompilationRule implements TestRule {\n+    private Elements elements;\n+    private Types types;\n+\n+    @Override\n+    public Statement apply(final Statement base, Description description) {\n+      return new Statement() {\n+        @Override public void evaluate() throws Throwable {\n+          final AtomicReference<Throwable> thrown = new AtomicReference<Throwable>();\n+          boolean successful = compile(ImmutableList.of(new AbstractProcessor() {\n+            @Override\n+            public SourceVersion getSupportedSourceVersion() {\n+              return SourceVersion.latest();\n+            }\n+\n+            @Override\n+            public Set<String> getSupportedAnnotationTypes() {\n+              return ImmutableSet.of(\"*\");\n+            }\n+\n+            @Override\n+            public synchronized void init(ProcessingEnvironment processingEnv) {\n+              super.init(processingEnv);\n+              elements = processingEnv.getElementUtils();\n+              types = processingEnv.getTypeUtils();\n+            }\n+\n+            @Override\n+            public boolean process(Set<? extends TypeElement> annotations,\n+                RoundEnvironment roundEnv) {\n+              // just run the test on the last round after compilation is over\n+              if (roundEnv.processingOver()) {\n+                try {\n+                  base.evaluate();\n+                } catch (Throwable e) {\n+                  thrown.set(e);\n+                }\n+              }\n+              return false;\n+            }\n+          }));\n+          checkState(successful);\n+          Throwable t = thrown.get();\n+          if (t != null) {\n+            throw t;\n+          }\n+        }\n+      };\n+    }\n+\n+    /**\n+     * Returns the {@link Elements} instance associated with the current execution of the rule.\n+     *\n+     * @throws IllegalStateException if this method is invoked outside the execution of the rule.\n+     */\n+    public Elements getElements() {\n+      checkState(elements != null, \"Not running within the rule\");\n+      return elements;\n+    }\n+\n+    /**\n+     * Returns the {@link Types} instance associated with the current execution of the rule.\n+     *\n+     * @throws IllegalStateException if this method is invoked outside the execution of the rule.\n+     */\n+    public Types getTypes() {\n+      checkState(elements != null, \"Not running within the rule\");\n+      return types;\n+    }\n+\n+    static private boolean compile(Iterable<? extends Processor> processors) {\n+      JavaCompiler compiler = new EclipseCompiler();\n+      DiagnosticCollector<JavaFileObject> diagnosticCollector =\n+          new DiagnosticCollector<JavaFileObject>();\n+      JavaFileManager fileManager = compiler.getStandardFileManager(diagnosticCollector, Locale.getDefault(), UTF_8);\n+      JavaCompiler.CompilationTask task = compiler.getTask(\n+          null,\n+          fileManager,\n+          diagnosticCollector,\n+          ImmutableSet.<String>of(),\n+          ImmutableSet.of(TypesEclipseTest.class.getCanonicalName()),\n+          ImmutableSet.<JavaFileObject>of());\n+      task.setProcessors(processors);\n+      return task.call();\n+    }\n+  }\n+\n+  @Rule public final CompilationRule compilation = new CompilationRule();\n+\n+  @Override\n+  protected Elements getElements() {\n+    return compilation.getElements();\n+  }\n+\n+  @Override\n+  protected Types getTypes() {\n+    return compilation.getTypes();\n+  }\n+}\n"
    },
    {
        "commit_hash": "5a37c2aa596377cb4c9b6f916614407fd0a7d3db",
        "previous_commit_hash": "dfa195e79e03f5e9846be8c475eb61b687de7ef5",
        "diff_stats": {
            "additions": 9,
            "deletions": 186
        },
        "diff_content": "@@ -15,203 +15,26 @@\n  */\n package com.squareup.javapoet;\n \n-import com.google.testing.compile.CompilationRule;\n-import java.io.Serializable;\n-import java.nio.charset.Charset;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.element.TypeParameterElement;\n-import javax.lang.model.type.DeclaredType;\n-import javax.lang.model.type.TypeKind;\n-import javax.lang.model.type.TypeMirror;\n-import javax.lang.model.type.WildcardType;\n import javax.lang.model.util.Elements;\n import javax.lang.model.util.Types;\n+\n import org.junit.Rule;\n-import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n \n-import static com.google.common.truth.Truth.assertThat;\n-import static org.junit.Assert.fail;\n+import com.google.testing.compile.CompilationRule;\n \n @RunWith(JUnit4.class)\n-public final class TypesTest {\n+public final class TypesTest extends AbstractTypesTest {\n   @Rule public final CompilationRule compilation = new CompilationRule();\n \n-  private TypeElement getElement(Class<?> clazz) {\n-    return compilation.getElements().getTypeElement(clazz.getCanonicalName());\n-  }\n-\n-  private TypeMirror getMirror(Class<?> clazz) {\n-    return getElement(clazz).asType();\n-  }\n-\n-  @Test public void getBasicTypeMirror() {\n-    assertThat(TypeName.get(getMirror(Object.class)))\n-        .isEqualTo(ClassName.get(Object.class));\n-    assertThat(TypeName.get(getMirror(Charset.class)))\n-        .isEqualTo(ClassName.get(Charset.class));\n-    assertThat(TypeName.get(getMirror(TypesTest.class)))\n-        .isEqualTo(ClassName.get(TypesTest.class));\n-  }\n-\n-  @Test public void getParameterizedTypeMirror() {\n-    DeclaredType setType =\n-        compilation.getTypes().getDeclaredType(getElement(Set.class), getMirror(Object.class));\n-    assertThat(TypeName.get(setType))\n-        .isEqualTo(ParameterizedTypeName.get(ClassName.get(Set.class), ClassName.OBJECT));\n-  }\n-\n-  static class Parameterized<\n-      Simple,\n-      ExtendsClass extends Number,\n-      ExtendsInterface extends Runnable,\n-      ExtendsTypeVariable extends Simple,\n-      Intersection extends Number & Runnable,\n-      IntersectionOfInterfaces extends Runnable & Serializable> {}\n-\n-  @Test public void getTypeVariableTypeMirror() {\n-    List<? extends TypeParameterElement> typeVariables =\n-        getElement(Parameterized.class).getTypeParameters();\n-\n-    // Members of converted types use ClassName and not Class<?>.\n-    ClassName number = ClassName.get(Number.class);\n-    ClassName runnable = ClassName.get(Runnable.class);\n-    ClassName serializable = ClassName.get(Serializable.class);\n-\n-    assertThat(TypeName.get(typeVariables.get(0).asType()))\n-        .isEqualTo(TypeVariableName.get(\"Simple\"));\n-    assertThat(TypeName.get(typeVariables.get(1).asType()))\n-        .isEqualTo(TypeVariableName.get(\"ExtendsClass\", number));\n-    assertThat(TypeName.get(typeVariables.get(2).asType()))\n-        .isEqualTo(TypeVariableName.get(\"ExtendsInterface\", runnable));\n-    assertThat(TypeName.get(typeVariables.get(3).asType()))\n-        .isEqualTo(TypeVariableName.get(\"ExtendsTypeVariable\", TypeVariableName.get(\"Simple\")));\n-    assertThat(TypeName.get(typeVariables.get(4).asType()))\n-        .isEqualTo(TypeVariableName.get(\"Intersection\", number, runnable));\n-    assertThat(TypeName.get(typeVariables.get(5).asType()))\n-        .isEqualTo(TypeVariableName.get(\"IntersectionOfInterfaces\", runnable, serializable));\n-    assertThat(((TypeVariableName) TypeName.get(typeVariables.get(4).asType())).bounds)\n-        .containsExactly(number, runnable);\n-  }\n-\n-  @Test public void getPrimitiveTypeMirror() {\n-    assertThat(TypeName.get(compilation.getTypes().getPrimitiveType(TypeKind.BOOLEAN)))\n-        .isEqualTo(TypeName.BOOLEAN);\n-    assertThat(TypeName.get(compilation.getTypes().getPrimitiveType(TypeKind.BYTE)))\n-        .isEqualTo(TypeName.BYTE);\n-    assertThat(TypeName.get(compilation.getTypes().getPrimitiveType(TypeKind.SHORT)))\n-        .isEqualTo(TypeName.SHORT);\n-    assertThat(TypeName.get(compilation.getTypes().getPrimitiveType(TypeKind.INT)))\n-        .isEqualTo(TypeName.INT);\n-    assertThat(TypeName.get(compilation.getTypes().getPrimitiveType(TypeKind.LONG)))\n-        .isEqualTo(TypeName.LONG);\n-    assertThat(TypeName.get(compilation.getTypes().getPrimitiveType(TypeKind.CHAR)))\n-        .isEqualTo(TypeName.CHAR);\n-    assertThat(TypeName.get(compilation.getTypes().getPrimitiveType(TypeKind.FLOAT)))\n-        .isEqualTo(TypeName.FLOAT);\n-    assertThat(TypeName.get(compilation.getTypes().getPrimitiveType(TypeKind.DOUBLE)))\n-        .isEqualTo(TypeName.DOUBLE);\n-  }\n-\n-  @Test public void getArrayTypeMirror() {\n-    assertThat(TypeName.get(compilation.getTypes().getArrayType(getMirror(Object.class))))\n-        .isEqualTo(ArrayTypeName.of(ClassName.OBJECT));\n-  }\n-\n-  @Test public void getVoidTypeMirror() {\n-    assertThat(TypeName.get(compilation.getTypes().getNoType(TypeKind.VOID)))\n-        .isEqualTo(TypeName.VOID);\n-  }\n-\n-  @Test public void getNullTypeMirror() {\n-    try {\n-      TypeName.get(compilation.getTypes().getNullType());\n-      fail();\n-    } catch (IllegalArgumentException expected) {\n-    }\n-  }\n-\n-  @Test public void parameterizedType() throws Exception {\n-    ParameterizedTypeName type = ParameterizedTypeName.get(Map.class, String.class, Long.class);\n-    assertThat(type.toString()).isEqualTo(\"java.util.Map<java.lang.String, java.lang.Long>\");\n-  }\n-\n-  @Test public void arrayType() throws Exception {\n-    ArrayTypeName type = ArrayTypeName.of(String.class);\n-    assertThat(type.toString()).isEqualTo(\"java.lang.String[]\");\n-  }\n-\n-  @Test public void wildcardExtendsType() throws Exception {\n-    WildcardTypeName type = WildcardTypeName.subtypeOf(CharSequence.class);\n-    assertThat(type.toString()).isEqualTo(\"? extends java.lang.CharSequence\");\n-  }\n-\n-  @Test public void wildcardExtendsObject() throws Exception {\n-    WildcardTypeName type = WildcardTypeName.subtypeOf(Object.class);\n-    assertThat(type.toString()).isEqualTo(\"?\");\n-  }\n-\n-  @Test public void wildcardSuperType() throws Exception {\n-    WildcardTypeName type = WildcardTypeName.supertypeOf(String.class);\n-    assertThat(type.toString()).isEqualTo(\"? super java.lang.String\");\n-  }\n-\n-  @Test public void wildcardMirrorNoBounds() throws Exception {\n-    WildcardType wildcard = compilation.getTypes().getWildcardType(null, null);\n-    TypeName type = TypeName.get(wildcard);\n-    assertThat(type.toString()).isEqualTo(\"?\");\n-  }\n-\n-  @Test public void wildcardMirrorExtendsType() throws Exception {\n-    Types types = compilation.getTypes();\n-    Elements elements = compilation.getElements();\n-    TypeMirror charSequence = elements.getTypeElement(CharSequence.class.getName()).asType();\n-    WildcardType wildcard = types.getWildcardType(charSequence, null);\n-    TypeName type = TypeName.get(wildcard);\n-    assertThat(type.toString()).isEqualTo(\"? extends java.lang.CharSequence\");\n-  }\n-\n-  @Test public void wildcardMirrorSuperType() throws Exception {\n-    Types types = compilation.getTypes();\n-    Elements elements = compilation.getElements();\n-    TypeMirror string = elements.getTypeElement(String.class.getName()).asType();\n-    WildcardType wildcard = types.getWildcardType(null, string);\n-    TypeName type = TypeName.get(wildcard);\n-    assertThat(type.toString()).isEqualTo(\"? super java.lang.String\");\n-  }\n-\n-  @Test public void typeVariable() throws Exception {\n-    TypeVariableName type = TypeVariableName.get(\"T\", CharSequence.class);\n-    assertThat(type.toString()).isEqualTo(\"T\"); // (Bounds are only emitted in declaration.)\n-  }\n-\n-  @Test public void box() throws Exception {\n-    assertThat(TypeName.INT.box()).isEqualTo(ClassName.get(Integer.class));\n-    assertThat(TypeName.VOID.box()).isEqualTo(ClassName.get(Void.class));\n-    assertThat(ClassName.get(Integer.class).box()).isEqualTo(ClassName.get(Integer.class));\n-    assertThat(ClassName.get(Void.class).box()).isEqualTo(ClassName.get(Void.class));\n-    assertThat(TypeName.OBJECT.box()).isEqualTo(TypeName.OBJECT);\n-    assertThat(ClassName.get(String.class).box()).isEqualTo(ClassName.get(String.class));\n+  @Override\n+  protected Elements getElements() {\n+    return compilation.getElements();\n   }\n \n-  @Test public void unbox() throws Exception {\n-    assertThat(TypeName.INT).isEqualTo(TypeName.INT.unbox());\n-    assertThat(TypeName.VOID).isEqualTo(TypeName.VOID.unbox());\n-    assertThat(ClassName.get(Integer.class).unbox()).isEqualTo(TypeName.INT.unbox());\n-    assertThat(ClassName.get(Void.class).unbox()).isEqualTo(TypeName.VOID.unbox());\n-    try {\n-      TypeName.OBJECT.unbox();\n-      fail();\n-    } catch (UnsupportedOperationException expected) {\n-    }\n-    try {\n-      ClassName.get(String.class).unbox();\n-      fail();\n-    } catch (UnsupportedOperationException expected) {\n-    }\n+  @Override\n+  protected Types getTypes() {\n+    return compilation.getTypes();\n   }\n }\n"
    },
    {
        "commit_hash": "ff68284b0352639173e282376850607ab7e98140",
        "previous_commit_hash": "5a37c2aa596377cb4c9b6f916614407fd0a7d3db",
        "diff_stats": {
            "additions": 7,
            "deletions": 50
        },
        "diff_content": "@@ -16,18 +16,13 @@\n package com.squareup.javapoet;\n \n import java.io.IOException;\n-import java.lang.reflect.Method;\n import java.lang.reflect.Type;\n import java.lang.reflect.TypeVariable;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n-import javax.lang.model.element.NestingKind;\n-import javax.lang.model.element.TypeElement;\n import javax.lang.model.element.TypeParameterElement;\n-import javax.lang.model.type.DeclaredType;\n-import javax.lang.model.type.TypeKind;\n import javax.lang.model.type.TypeMirror;\n \n import static com.squareup.javapoet.Util.checkArgument;\n@@ -81,8 +76,13 @@ public final class TypeVariableName extends TypeName {\n \n   /** Returns type variable equivalent to {@code mirror}. */\n   public static TypeVariableName get(javax.lang.model.type.TypeVariable mirror) {\n-    String name = mirror.asElement().getSimpleName().toString();\n-    List<? extends TypeMirror> boundsMirrors = typeVariableBounds(mirror);\n+    return get((TypeParameterElement) mirror.asElement());\n+  }\n+\n+  /** Returns type variable equivalent to {@code element}. */\n+  public static TypeVariableName get(TypeParameterElement element) {\n+    String name = element.getSimpleName().toString();\n+    List<? extends TypeMirror> boundsMirrors = element.getBounds();\n \n     List<TypeName> boundsTypeNames = new ArrayList<>();\n     for (TypeMirror typeMirror : boundsMirrors) {\n@@ -92,49 +92,6 @@ public final class TypeVariableName extends TypeName {\n     return new TypeVariableName(name, boundsTypeNames);\n   }\n \n-  /**\n-   * Returns a list of type mirrors representing the unpacked bounds of {@code typeVariable}. This\n-   * is made gnarly by the need to unpack Java 8's new IntersectionType with reflection. We don't\n-   * have that type in Java 7, and {@link TypeVariable}'s array of bounds is sufficient anyway.\n-   */\n-  @SuppressWarnings(\"unchecked\") // Gross things in support of Java 7 and Java 8.\n-  private static List<? extends TypeMirror> typeVariableBounds(\n-      javax.lang.model.type.TypeVariable typeVariable) {\n-    TypeMirror upperBound = typeVariable.getUpperBound();\n-\n-    // On Java 8, unwrap an intersection type into its component bounds.\n-    if (\"INTERSECTION\".equals(upperBound.getKind().name())) {\n-      try {\n-        Method method = upperBound.getClass().getMethod(\"getBounds\");\n-        return (List<? extends TypeMirror>) method.invoke(upperBound);\n-      } catch (Exception e) {\n-        throw new RuntimeException(e);\n-      }\n-    }\n-\n-    // On Java 7, intersection types exist but without explicit API. Use a (clumsy) heuristic.\n-    if (upperBound.getKind() == TypeKind.DECLARED) {\n-      TypeElement upperBoundElement = (TypeElement) ((DeclaredType) upperBound).asElement();\n-      if (upperBoundElement.getNestingKind() == NestingKind.ANONYMOUS) {\n-        List<TypeMirror> result = new ArrayList<>();\n-        result.add(upperBoundElement.getSuperclass());\n-        result.addAll(upperBoundElement.getInterfaces());\n-        return result;\n-      }\n-    } else if (upperBound.getKind() == TypeKind.TYPEVAR) {\n-      // Workaround for intersection types in Eclipse:\n-      // Eclipse returns an equivalent TypeVariable for intersection types\n-      // (wrapping the same internal TypeVariableBinding).\n-      TypeParameterElement upperBoundElement =\n-          (TypeParameterElement) ((javax.lang.model.type.TypeVariable) upperBound).asElement();\n-      if (upperBoundElement.equals(typeVariable.asElement())) {\n-        return upperBoundElement.getBounds();\n-      }\n-    }\n-\n-    return Collections.singletonList(upperBound);\n-  }\n-\n   /** Returns type variable equivalent to {@code type}. */\n   public static TypeVariableName get(TypeVariable<?> type) {\n     return new TypeVariableName(type.getName(), TypeName.list(type.getBounds()));\n"
    },
    {
        "commit_hash": "55ef17207f7ab2ac7e19446eb6633eab907aed7d",
        "previous_commit_hash": "b716399da5d35529fb70a05e4c88df587b5310a3",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -744,12 +744,12 @@ Download [the latest .jar][dl] or depend via Maven:\n <dependency>\n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.1.0</version>\n+  <version>1.2.0</version>\n </dependency>\n ```\n or Gradle:\n ```groovy\n-compile 'com.squareup:javapoet:1.1.0'\n+compile 'com.squareup:javapoet:1.2.0'\n ```\n \n Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].\n"
    },
    {
        "commit_hash": "fbfc47aa6e6f5ad8d4eb1abd8f556da1da71ff70",
        "previous_commit_hash": "a0f783c4c3ba439c7f2e59f4fa8faea50ab007ec",
        "diff_stats": {
            "additions": 2,
            "deletions": 1
        },
        "diff_content": "@@ -592,6 +592,7 @@ TypeSpec comparator = TypeSpec.anonymousClassBuilder(\"\")\n         .addModifiers(Modifier.PUBLIC)\n         .addParameter(String.class, \"a\")\n         .addParameter(String.class, \"b\")\n+        .returns(int.class)\n         .addStatement(\"return $N.length() - $N.length()\", \"a\", \"b\")\n         .build())\n     .build();\n@@ -610,7 +611,7 @@ This generates a method that contains a class that contains a method:\n void sortByLength(List<String> strings) {\n   Collections.sort(strings, new Comparator<String>() {\n     @Override\n-    public void compare(String a, String b) {\n+    public int compare(String a, String b) {\n       return a.length() - b.length();\n     }\n   });\n"
    },
    {
        "commit_hash": "262a3e2811e748c869d5b587e9a450168ff32f4e",
        "previous_commit_hash": "8a17f0a5dc1f10ea2a571261b57348fb1c1e22c9",
        "diff_stats": {
            "additions": 140,
            "deletions": 36
        },
        "diff_content": "@@ -19,7 +19,6 @@ import java.io.IOException;\n import java.io.StringWriter;\n import java.lang.reflect.Type;\n import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.Iterator;\n import java.util.List;\n \n@@ -102,7 +101,10 @@ public final class CodeBlock {\n     }\n \n     public Builder add(String format, Object... args) {\n-      Iterator<Object> i = Arrays.asList(args).iterator();\n+      List<Character> paramChars = new ArrayList<>();\n+      List<Integer> paramIndexes = new ArrayList<>();\n+      boolean autoIndexing = false;\n+      int i = 0;\n       for (int p = 0, nextP; p < format.length(); p = nextP) {\n         if (format.charAt(p) != '$') {\n           nextP = format.indexOf('$', p + 1);\n@@ -125,48 +127,150 @@ public final class CodeBlock {\n                 \"Dangling format characters '%s' in format string '%s'\",\n                 format.substring(p), format);\n           }\n+          if (!paramChars.isEmpty()) {\n+            if (autoIndexing) {\n+              char toCheck = format.charAt(p + 1);\n+              checkArgument(countOfIndexCharacters == 0,\n+                  \"cannot mix indexed and positional parameters\");\n+              checkArgument(isValidParameterChar(toCheck), \"invalid format string: %s\", format);\n \n-          int argsIndex = -1;\n-          if (countOfIndexCharacters != 0) {\n-            argsIndex = Integer.parseInt(format.substring(p + 1, p + 1 + countOfIndexCharacters));\n-            checkArgument(argsIndex <= args.length,\n-                \"Argument index %s in '%s' is larger than number of parameters\",\n-                argsIndex, format);\n-            checkArgument(argsIndex > 0,\n-                \"Argument index %s in '%s' is less than one, the minimum format index\",\n-                argsIndex, format);\n-          }\n-          switch (format.charAt(p + countOfIndexCharacters + 1)) {\n-            case 'N':\n-              this.args.add(argToName((argsIndex == -1) ? i.next() : args[argsIndex - 1]));\n-              break;\n-            case 'L':\n-              this.args.add(argToLiteral((argsIndex == -1) ? i.next() : args[argsIndex - 1]));\n-              break;\n-            case 'S':\n-              this.args.add(argToString((argsIndex == -1) ? i.next() : args[argsIndex - 1]));\n-              break;\n-            case 'T':\n-              this.args.add(argToType((argsIndex == -1) ? i.next() : args[argsIndex - 1]));\n-              break;\n-            case '$':\n-            case '>':\n-            case '<':\n-            case '[':\n-            case ']':\n-              checkState(argsIndex == -1, \"$$, $>, $<, $[ and $] may not have an index\");\n-              break;\n-            default:\n-              throw new IllegalArgumentException(\"invalid format string: \" + format);\n+              if (!isNonIndexedChar(toCheck)) {\n+                paramChars.add(toCheck);\n+                paramIndexes.add(i);\n+                i++;\n+              }\n+\n+              nextP = p + 2;\n+              formatParts.add(\"$\" + toCheck);\n+            } else {\n+              char toCheck = format.charAt(p + countOfIndexCharacters + 1);\n+              if (countOfIndexCharacters == 0) {\n+                boolean valid = isValidParameterChar(toCheck);\n+                checkArgument(valid, \"invalid format string: %s\", format);\n+                checkArgument(isNonIndexedChar(toCheck),\n+                    \"cannot mix indexed and positional paramters\");\n+              } else {\n+                checkArgument(!isNonIndexedChar(toCheck),\n+                    \"$$, $>, $<, $[ and $] may not have an index\");\n+              }\n+              int argsIndex =\n+                  Integer.parseInt(format.substring(p + 1, p + 1 + countOfIndexCharacters));\n+              checkArgument(argsIndex <= args.length,\n+                  \"Argument index %s in '%s' is larger than number of parameters\",\n+                  argsIndex, format);\n+              checkArgument(argsIndex > 0,\n+                  \"Argument index %s in '%s' is less than one, the minimum format index\",\n+                  argsIndex, format);\n+\n+              if (!isNonIndexedChar(toCheck)) {\n+                paramChars.add(toCheck);\n+                paramIndexes.add(argsIndex - 1);\n+              }\n+\n+              nextP = p + countOfIndexCharacters + 2;\n+              formatParts.add(\"$\" + toCheck);\n+            }\n+          } else {\n+            char toCheck = format.charAt(p + countOfIndexCharacters + 1);\n+            int index = -1;\n+            if (countOfIndexCharacters == 0) {\n+              boolean valid = isValidParameterChar(toCheck);\n+              checkArgument(valid, \"invalid format string: %s\", format);\n+              if (!isNonIndexedChar(toCheck)) {\n+                index = i;\n+                i++;\n+              }\n+              autoIndexing = true;\n+            } else {\n+              checkArgument(isValidParameterChar(toCheck), \"invalid format string: %s\", format);\n+              checkArgument(!isNonIndexedChar(toCheck),\n+                  \"$$, $>, $<, $[ and $] may not have an index\");\n+              autoIndexing = false;\n+              int argsIndex =\n+                  Integer.parseInt(format.substring(p + 1, p + 1 + countOfIndexCharacters));\n+              checkArgument(argsIndex <= args.length,\n+                  \"Argument index %s in '%s' is larger than number of parameters\",\n+                  argsIndex, format);\n+              checkArgument(argsIndex > 0,\n+                  \"Argument index %s in '%s' is less than one, the minimum format index\",\n+                  argsIndex, format);\n+              index = argsIndex - 1;\n+            }\n+\n+            if (index > -1) {\n+              paramChars.add(toCheck);\n+              paramIndexes.add(index);\n+            }\n+\n+            nextP = p + countOfIndexCharacters + 2;\n+            formatParts.add(\"$\" + toCheck);\n           }\n+        }\n+      }\n+      int max = -1;\n+      for (int j = 0; j < paramIndexes.size(); j++) {\n+        max = Math.max(max, paramIndexes.get(j));\n+      }\n+      checkArgument(max < args.length,\n+          \"Not enough parameters were given; expected %s, got %s\", max + 1, args.length);\n+      checkArgument(max == args.length - 1,\n+          \"Too many parameters were given; expected %s, got %s\", max + 1, args.length);\n \n-          nextP = p + countOfIndexCharacters + 2;\n-          formatParts.add(String.format(\"%c%c\", format.charAt(p), format.charAt(nextP - 1)));\n+      Iterator<Character> iterChars = paramChars.iterator();\n+      Iterator<Integer> iterIndexes = paramIndexes.iterator();\n+      for (; iterChars.hasNext();) {\n+        char c = iterChars.next();\n+        int index = iterIndexes.next();\n+        switch (c) {\n+          case 'N':\n+            this.args.add(argToName(args[index]));\n+            break;\n+          case 'L':\n+            this.args.add(argToLiteral(args[index]));\n+            break;\n+          case 'S':\n+            this.args.add(argToString(args[index]));\n+            break;\n+          case 'T':\n+            this.args.add(argToType(args[index]));\n+            break;\n+          default:\n+            throw new IllegalStateException(\"format char '\" + c + \"' was unexpected\");\n         }\n       }\n       return this;\n     }\n \n+    private boolean isValidParameterChar(char toCheck) {\n+      switch (toCheck) {\n+        case 'N':\n+        case 'L':\n+        case 'S':\n+        case 'T':\n+        case '$':\n+        case '>':\n+        case '<':\n+        case '[':\n+        case ']':\n+          return true;\n+        default:\n+          return false;\n+      }\n+    }\n+\n+    private boolean isNonIndexedChar(char toCheck) {\n+      switch (toCheck) {\n+        case '$':\n+        case '>':\n+        case '<':\n+        case '[':\n+        case ']':\n+          return true;\n+        default:\n+          return false;\n+      }\n+    }\n+\n     /**\n      * A version of {@link Character#isDigit(char)} that only accepts '0'-'9'.\n      */\n"
    },
    {
        "commit_hash": "262a3e2811e748c869d5b587e9a450168ff32f4e",
        "previous_commit_hash": "8a17f0a5dc1f10ea2a571261b57348fb1c1e22c9",
        "diff_stats": {
            "additions": 19,
            "deletions": 37
        },
        "diff_content": "@@ -27,7 +27,7 @@ public class CodeBlockTest {\n     try {\n       CodeBlock.builder().add(\"$1>\", \"taco\").build();\n       fail();\n-    } catch (IllegalStateException exp) {\n+    } catch (IllegalArgumentException exp) {\n       assertThat(exp).hasMessage(\"$$, $>, $<, $[ and $] may not have an index\");\n     }\n   }\n@@ -37,7 +37,7 @@ public class CodeBlockTest {\n     try {\n       CodeBlock.builder().add(\"$1<\", \"taco\").build();\n       fail();\n-    } catch (IllegalStateException exp) {\n+    } catch (IllegalArgumentException exp) {\n       assertThat(exp).hasMessage(\"$$, $>, $<, $[ and $] may not have an index\");\n     }\n   }\n@@ -47,7 +47,7 @@ public class CodeBlockTest {\n     try {\n       CodeBlock.builder().add(\"$1$\", \"taco\").build();\n       fail();\n-    } catch (IllegalStateException exp) {\n+    } catch (IllegalArgumentException exp) {\n       assertThat(exp).hasMessage(\"$$, $>, $<, $[ and $] may not have an index\");\n     }\n   }\n@@ -57,7 +57,7 @@ public class CodeBlockTest {\n     try {\n       CodeBlock.builder().add(\"$1[\", \"taco\").build();\n       fail();\n-    } catch (IllegalStateException exp) {\n+    } catch (IllegalArgumentException exp) {\n       assertThat(exp).hasMessage(\"$$, $>, $<, $[ and $] may not have an index\");\n     }\n   }\n@@ -67,62 +67,62 @@ public class CodeBlockTest {\n     try {\n       CodeBlock.builder().add(\"$1]\", \"taco\").build();\n       fail();\n-    } catch (IllegalStateException exp) {\n+    } catch (IllegalArgumentException exp) {\n       assertThat(exp).hasMessage(\"$$, $>, $<, $[ and $] may not have an index\");\n     }\n   }\n   \n   @Test\n   public void nameFormatCanBeIndexed() {\n-    CodeBlock block = CodeBlock.builder().add(\"$N $1N\", \"taco\").build();\n-    assertThat(block.toString()).isEqualTo(\"taco taco\");\n+    CodeBlock block = CodeBlock.builder().add(\"$1N\", \"taco\").build();\n+    assertThat(block.toString()).isEqualTo(\"taco\");\n   }\n   \n   @Test\n   public void literalFormatCanBeIndexed() {\n-    CodeBlock block = CodeBlock.builder().add(\"$L $1L\", \"taco\").build();\n-    assertThat(block.toString()).isEqualTo(\"taco taco\");\n+    CodeBlock block = CodeBlock.builder().add(\"$1L\", \"taco\").build();\n+    assertThat(block.toString()).isEqualTo(\"taco\");\n   }\n   \n   @Test\n   public void stringFormatCanBeIndexed() {\n-    CodeBlock block = CodeBlock.builder().add(\"$S $1S\", \"taco\").build();\n-    assertThat(block.toString()).isEqualTo(\"\\\"taco\\\" \\\"taco\\\"\");\n+    CodeBlock block = CodeBlock.builder().add(\"$1S\", \"taco\").build();\n+    assertThat(block.toString()).isEqualTo(\"\\\"taco\\\"\");\n   }\n   \n   @Test\n   public void typeFormatCanBeIndexed() {\n-    CodeBlock block = CodeBlock.builder().add(\"$T $1T\", String.class).build();\n-    assertThat(block.toString()).isEqualTo(\"java.lang.String java.lang.String\");\n+    CodeBlock block = CodeBlock.builder().add(\"$1T\", String.class).build();\n+    assertThat(block.toString()).isEqualTo(\"java.lang.String\");\n   }\n   \n   @Test\n   public void indexTooHigh() {\n     try {\n-      CodeBlock.builder().add(\"$T $2T\", String.class).build();\n+      CodeBlock.builder().add(\"$2T\", String.class).build();\n       fail();\n     } catch (IllegalArgumentException exp) {\n-      assertThat(exp).hasMessage(\"Argument index 2 in '$T $2T' is larger than number of parameters\");\n+      assertThat(exp).hasMessage(\"Argument index 2 in '$2T' is larger than number of parameters\");\n     }\n   }\n   \n   @Test\n   public void indexIsZero() {\n     try {\n-    CodeBlock.builder().add(\"$T $0T\", String.class).build();\n+    CodeBlock.builder().add(\"$0T\", String.class).build();\n     fail();\n     } catch(IllegalArgumentException exp) {\n-      assertThat(exp).hasMessage(\"Argument index 0 in '$T $0T' is less than one, the minimum format index\");\n+      assertThat(exp).hasMessage(\"Argument index 0 in '$0T' is less than one, the minimum format index\");\n     }\n   }\n   \n   @Test\n   public void indexIsNegative() {\n     try {\n-      CodeBlock.builder().add(\"$T $-1T\", String.class).build();\n+      CodeBlock.builder().add(\"$-1T\", String.class).build();\n       fail();\n     } catch (IllegalArgumentException exp) {\n-      assertThat(exp).hasMessage(\"invalid format string: $T $-1T\");\n+      assertThat(exp).hasMessage(\"invalid format string: $-1T\");\n     }\n   }\n   \n@@ -166,24 +166,6 @@ public class CodeBlockTest {\n     }\n   }\n   \n-  @Test\n-  public void indexingDoesNotIncreaseNaturalIndex() {\n-    CodeBlock block = CodeBlock.builder().add(\"$L $L $2L $L\", 1, 2, 3).build();\n-    assertThat(block.toString()).isEqualTo(\"1 2 2 3\");\n-  }\n-  \n-  @Test\n-  public void indexingSelectsProperPosition() {\n-    CodeBlock block = CodeBlock.builder().add(\"$L $L $L $3L $2L $1L\", 1, 2, 3).build();\n-    assertThat(block.toString()).isEqualTo(\"1 2 3 3 2 1\");\n-  }\n-  \n-  @Test\n-  public void indexingCanBeInterleved() {\n-    CodeBlock block = CodeBlock.builder().add(\"$L $3L $L $2L $L $1L\", 1, 2, 3).build();\n-    assertThat(block.toString()).isEqualTo(\"1 3 2 2 3 1\");\n-  }\n-  \n   @Test\n   public void sameIndexCanBeUsedWithDifferentFormats() {\n     CodeBlock block = CodeBlock.builder().add(\"$1T.out.println($1S)\", ClassName.get(System.class)).build();\n"
    },
    {
        "commit_hash": "262a3e2811e748c869d5b587e9a450168ff32f4e",
        "previous_commit_hash": "8a17f0a5dc1f10ea2a571261b57348fb1c1e22c9",
        "diff_stats": {
            "additions": 11,
            "deletions": 1
        },
        "diff_content": "@@ -1848,7 +1848,17 @@ public final class TypeSpecTest {\n     try {\n       CodeBlock.builder().add(\"$S\");\n       fail();\n-    } catch (NoSuchElementException expected) {\n+    } catch (IllegalArgumentException expected) {\n+      assertThat(expected).hasMessage(\"Not enough parameters were given; expected 1, got 0\");\n+    }\n+  }\n+\n+  @Test public void unusedArguments() {\n+    try {\n+      CodeBlock.builder().add(\"\", \"foo\");\n+      fail();\n+    } catch (IllegalArgumentException expected) {\n+      assertThat(expected).hasMessage(\"Too many parameters were given; expected 0, got 1\");\n     }\n   }\n \n"
    },
    {
        "commit_hash": "cf6ac80e576aa08de9ca93c082f035b543583a76",
        "previous_commit_hash": "8d27eca70744894c83fd5bdbbd564f9e5c5ea946",
        "diff_stats": {
            "additions": 48,
            "deletions": 155
        },
        "diff_content": "@@ -19,14 +19,11 @@ import java.io.IOException;\n import java.io.StringWriter;\n import java.lang.reflect.Type;\n import java.util.ArrayList;\n-import java.util.Iterator;\n import java.util.List;\n-\n import javax.lang.model.element.Element;\n import javax.lang.model.type.TypeMirror;\n \n import static com.squareup.javapoet.Util.checkArgument;\n-import static com.squareup.javapoet.Util.checkState;\n \n /**\n  * A fragment of a .java file, potentially containing declarations, statements, and documentation.\n@@ -101,126 +98,53 @@ public final class CodeBlock {\n     }\n \n     public Builder add(String format, Object... args) {\n-      List<Character> paramChars = new ArrayList<>();\n-      List<Integer> paramIndexes = new ArrayList<>();\n-      boolean autoIndexing = false;\n-      int i = 0;\n-      for (int p = 0, nextP; p < format.length(); p = nextP) {\n+      boolean hasRelative = false;\n+      boolean hasIndexed = false;\n+      int parameterCount = 0;\n+\n+      for (int p = 0; p < format.length();) {\n         if (format.charAt(p) != '$') {\n-          nextP = format.indexOf('$', p + 1);\n+          int nextP = format.indexOf('$', p + 1);\n           if (nextP == -1) nextP = format.length();\n           formatParts.add(format.substring(p, nextP));\n+          p = nextP;\n+          continue;\n+        }\n+\n+        p++; // '$'.\n+\n+        // Consume zero or more digits, leaving 'c' as the first non-digit char after the '$'.\n+        int indexStart = p;\n+        char c;\n+        do {\n+          checkArgument(p < format.length(), \"dangling format characters in '%s'\", format);\n+          c = format.charAt(p++);\n+        } while (c >= '0' && c <= '9');\n+        int indexEnd = p - 1;\n+\n+        // If 'c' doesn't take an argument, we're done.\n+        if (c == '$' || c == '>' || c == '<' || c == '[' || c == ']') {\n+          checkArgument(indexStart == indexEnd, \"$$, $>, $<, $[ and $] may not have an index\");\n+          formatParts.add(\"$\" + c);\n+          continue;\n+        }\n+\n+        // Find either the indexed argument, or the relative argument. (0-based).\n+        int index;\n+        if (indexStart < indexEnd) {\n+          index = Integer.parseInt(format.substring(indexStart, indexEnd)) - 1;\n+          hasIndexed = true;\n         } else {\n-          checkState(p + 1 < format.length(), \"dangling $ in format string %s\", format);\n-          /* Rules:\n-           * Format must be in the form $[Numeric Index]{N, L, S, T}\n-           * OR\n-           * in the form ${$, >, <, [, ]}\n-           * Numeric index is ONE BASED (for consistency with java formatting)\n-           * Numeric indexing must refer to a format argument within the args array\n-           * Only progress iteration over the argument iterator if we do not hit an indexed entry\n-           */\n-          int countOfIndexCharacters = 0;\n-          while (isSimpleDigit(format.charAt(p + countOfIndexCharacters + 1))) {\n-            countOfIndexCharacters++;\n-            checkArgument(format.length() > p + countOfIndexCharacters + 1,\n-                \"Dangling format characters '%s' in format string '%s'\",\n-                format.substring(p), format);\n-          }\n-          if (!paramChars.isEmpty()) {\n-            if (autoIndexing) {\n-              char toCheck = format.charAt(p + 1);\n-              checkArgument(countOfIndexCharacters == 0,\n-                  \"cannot mix indexed and positional parameters\");\n-              checkArgument(isValidParameterChar(toCheck), \"invalid format string: %s\", format);\n-\n-              if (!isNonIndexedChar(toCheck)) {\n-                paramChars.add(toCheck);\n-                paramIndexes.add(i);\n-                i++;\n-              }\n-\n-              nextP = p + 2;\n-              formatParts.add(\"$\" + toCheck);\n-            } else {\n-              char toCheck = format.charAt(p + countOfIndexCharacters + 1);\n-              if (countOfIndexCharacters == 0) {\n-                boolean valid = isValidParameterChar(toCheck);\n-                checkArgument(valid, \"invalid format string: %s\", format);\n-                checkArgument(isNonIndexedChar(toCheck),\n-                    \"cannot mix indexed and positional paramters\");\n-              } else {\n-                checkArgument(!isNonIndexedChar(toCheck),\n-                    \"$$, $>, $<, $[ and $] may not have an index\");\n-              }\n-              int argsIndex =\n-                  Integer.parseInt(format.substring(p + 1, p + 1 + countOfIndexCharacters));\n-              checkArgument(argsIndex <= args.length,\n-                  \"Argument index %s in '%s' is larger than number of parameters\",\n-                  argsIndex, format);\n-              checkArgument(argsIndex > 0,\n-                  \"Argument index %s in '%s' is less than one, the minimum format index\",\n-                  argsIndex, format);\n-\n-              if (!isNonIndexedChar(toCheck)) {\n-                paramChars.add(toCheck);\n-                paramIndexes.add(argsIndex - 1);\n-              }\n-\n-              nextP = p + countOfIndexCharacters + 2;\n-              formatParts.add(\"$\" + toCheck);\n-            }\n-          } else {\n-            char toCheck = format.charAt(p + countOfIndexCharacters + 1);\n-            int index = -1;\n-            if (countOfIndexCharacters == 0) {\n-              boolean valid = isValidParameterChar(toCheck);\n-              checkArgument(valid, \"invalid format string: %s\", format);\n-              if (!isNonIndexedChar(toCheck)) {\n-                index = i;\n-                i++;\n-              }\n-              autoIndexing = true;\n-            } else {\n-              checkArgument(isValidParameterChar(toCheck), \"invalid format string: %s\", format);\n-              checkArgument(!isNonIndexedChar(toCheck),\n-                  \"$$, $>, $<, $[ and $] may not have an index\");\n-              autoIndexing = false;\n-              int argsIndex =\n-                  Integer.parseInt(format.substring(p + 1, p + 1 + countOfIndexCharacters));\n-              checkArgument(argsIndex <= args.length,\n-                  \"Argument index %s in '%s' is larger than number of parameters\",\n-                  argsIndex, format);\n-              checkArgument(argsIndex > 0,\n-                  \"Argument index %s in '%s' is less than one, the minimum format index\",\n-                  argsIndex, format);\n-              index = argsIndex - 1;\n-            }\n-\n-            if (index > -1) {\n-              paramChars.add(toCheck);\n-              paramIndexes.add(index);\n-            }\n-\n-            nextP = p + countOfIndexCharacters + 2;\n-            formatParts.add(\"$\" + toCheck);\n-          }\n+          index = parameterCount;\n+          hasRelative = true;\n         }\n-      }\n-      int max = -1;\n-      for (int j = 0; j < paramIndexes.size(); j++) {\n-        max = Math.max(max, paramIndexes.get(j));\n-      }\n-      checkArgument(max < args.length,\n-          \"Not enough parameters were given; expected %s, got %s\", max + 1, args.length);\n-      checkArgument(max == args.length - 1,\n-          \"Too many parameters were given; expected %s, got %s\", max + 1, args.length);\n-\n-      Iterator<Character> iterChars = paramChars.iterator();\n-      Iterator<Integer> iterIndexes = paramIndexes.iterator();\n-      for (; iterChars.hasNext();) {\n-        char c = iterChars.next();\n-        int index = iterIndexes.next();\n+        parameterCount++;\n+\n+        checkArgument(index >= 0 && index < args.length,\n+            \"index %d for '%s' not in range (received %s arguments)\",\n+            index + 1, format.substring(indexStart - 1, indexEnd + 1), args.length);\n+        checkArgument(!hasIndexed || !hasRelative, \"cannot mix indexed and positional parameters\");\n+\n         switch (c) {\n           case 'N':\n             this.args.add(argToName(args[index]));\n@@ -235,47 +159,16 @@ public final class CodeBlock {\n             this.args.add(argToType(args[index]));\n             break;\n           default:\n-            throw new IllegalStateException(\"format char '\" + c + \"' was unexpected\");\n+            throw new IllegalArgumentException(\n+                String.format(\"invalid format string: '%s'\", format));\n         }\n-      }\n-      return this;\n-    }\n-\n-    private boolean isValidParameterChar(char toCheck) {\n-      switch (toCheck) {\n-        case 'N':\n-        case 'L':\n-        case 'S':\n-        case 'T':\n-        case '$':\n-        case '>':\n-        case '<':\n-        case '[':\n-        case ']':\n-          return true;\n-        default:\n-          return false;\n-      }\n-    }\n \n-    private boolean isNonIndexedChar(char toCheck) {\n-      switch (toCheck) {\n-        case '$':\n-        case '>':\n-        case '<':\n-        case '[':\n-        case ']':\n-          return true;\n-        default:\n-          return false;\n+        formatParts.add(\"$\" + c);\n       }\n-    }\n \n-    /**\n-     * A version of {@link Character#isDigit(char)} that only accepts '0'-'9'.\n-     */\n-    private boolean isSimpleDigit(char toCheck) {\n-      return toCheck >= '0' && toCheck <= '9';\n+      checkArgument(parameterCount >= args.length,\n+          \"unused arguments: expected %s, received %s\", parameterCount, args.length);\n+      return this;\n     }\n \n     private String argToName(Object o) {\n"
    },
    {
        "commit_hash": "cf6ac80e576aa08de9ca93c082f035b543583a76",
        "previous_commit_hash": "8d27eca70744894c83fd5bdbbd564f9e5c5ea946",
        "diff_stats": {
            "additions": 14,
            "deletions": 12
        },
        "diff_content": "@@ -102,17 +102,17 @@ public class CodeBlockTest {\n       CodeBlock.builder().add(\"$2T\", String.class).build();\n       fail();\n     } catch (IllegalArgumentException exp) {\n-      assertThat(exp).hasMessage(\"Argument index 2 in '$2T' is larger than number of parameters\");\n+      assertThat(exp).hasMessage(\"index 2 for '$2T' not in range (received 1 arguments)\");\n     }\n   }\n   \n   @Test\n   public void indexIsZero() {\n     try {\n-    CodeBlock.builder().add(\"$0T\", String.class).build();\n-    fail();\n-    } catch(IllegalArgumentException exp) {\n-      assertThat(exp).hasMessage(\"Argument index 0 in '$0T' is less than one, the minimum format index\");\n+      CodeBlock.builder().add(\"$0T\", String.class).build();\n+      fail();\n+    } catch (IllegalArgumentException exp) {\n+      assertThat(exp).hasMessage(\"index 0 for '$0T' not in range (received 1 arguments)\");\n     }\n   }\n   \n@@ -122,7 +122,7 @@ public class CodeBlockTest {\n       CodeBlock.builder().add(\"$-1T\", String.class).build();\n       fail();\n     } catch (IllegalArgumentException exp) {\n-      assertThat(exp).hasMessage(\"invalid format string: $-1T\");\n+      assertThat(exp).hasMessage(\"invalid format string: '$-1T'\");\n     }\n   }\n   \n@@ -132,7 +132,7 @@ public class CodeBlockTest {\n       CodeBlock.builder().add(\"$1\", String.class).build();\n       fail();\n     } catch (IllegalArgumentException exp) {\n-      assertThat(exp).hasMessage(\"Dangling format characters '$1' in format string '$1'\");\n+      assertThat(exp).hasMessage(\"dangling format characters in '$1'\");\n     }\n   }\n   \n@@ -142,7 +142,7 @@ public class CodeBlockTest {\n       CodeBlock.builder().add(\"$1 taco\", String.class).build();\n       fail();\n     } catch (IllegalArgumentException exp) {\n-      assertThat(exp).hasMessage(\"invalid format string: $1 taco\");\n+      assertThat(exp).hasMessage(\"invalid format string: '$1 taco'\");\n     }\n   }\n   \n@@ -151,8 +151,8 @@ public class CodeBlockTest {\n     try {\n       CodeBlock.builder().add(\"$\", String.class).build();\n       fail();\n-    } catch (IllegalStateException exp) {\n-      assertThat(exp).hasMessage(\"dangling $ in format string $\");\n+    } catch (IllegalArgumentException exp) {\n+      assertThat(exp).hasMessage(\"dangling format characters in '$'\");\n     }\n   }\n   \n@@ -162,13 +162,15 @@ public class CodeBlockTest {\n       CodeBlock.builder().add(\"$ tacoString\", String.class).build();\n       fail();\n     } catch (IllegalArgumentException exp) {\n-      assertThat(exp).hasMessage(\"invalid format string: $ tacoString\");\n+      assertThat(exp).hasMessage(\"invalid format string: '$ tacoString'\");\n     }\n   }\n   \n   @Test\n   public void sameIndexCanBeUsedWithDifferentFormats() {\n-    CodeBlock block = CodeBlock.builder().add(\"$1T.out.println($1S)\", ClassName.get(System.class)).build();\n+    CodeBlock block = CodeBlock.builder()\n+        .add(\"$1T.out.println($1S)\", ClassName.get(System.class))\n+        .build();\n     assertThat(block.toString()).isEqualTo(\"java.lang.System.out.println(\\\"java.lang.System\\\")\");\n   }\n   \n"
    },
    {
        "commit_hash": "cf6ac80e576aa08de9ca93c082f035b543583a76",
        "previous_commit_hash": "8d27eca70744894c83fd5bdbbd564f9e5c5ea946",
        "diff_stats": {
            "additions": 24,
            "deletions": 15
        },
        "diff_content": "@@ -667,10 +667,10 @@ public final class TypeSpecTest {\n     TypeSpec annotation = TypeSpec.annotationBuilder(\"MyAnnotation\")\n         .addModifiers(Modifier.PUBLIC)\n         .addMethod(MethodSpec.methodBuilder(\"test\")\n-                .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)\n-                .defaultValue(\"$L\", 0)\n-                .returns(int.class)\n-                .build())\n+            .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)\n+            .defaultValue(\"$L\", 0)\n+            .returns(int.class)\n+            .build())\n         .build();\n \n     assertThat(toString(annotation)).isEqualTo(\"\"\n@@ -743,13 +743,13 @@ public final class TypeSpecTest {\n         .build();\n \n     assertThat(toString(bar)).isEqualTo(\"\"\n-        + \"package com.squareup.tacos;\\n\"\n-        + \"\\n\"\n-        + \"interface Tacos {\\n\"\n-        + \"  default int test() {\\n\"\n-        + \"    return 0;\\n\"\n-        + \"  }\\n\"\n-        + \"}\\n\"\n+            + \"package com.squareup.tacos;\\n\"\n+            + \"\\n\"\n+            + \"interface Tacos {\\n\"\n+            + \"  default int test() {\\n\"\n+            + \"    return 0;\\n\"\n+            + \"  }\\n\"\n+            + \"}\\n\"\n     );\n   }\n \n@@ -1849,16 +1849,25 @@ public final class TypeSpecTest {\n       CodeBlock.builder().add(\"$S\");\n       fail();\n     } catch (IllegalArgumentException expected) {\n-      assertThat(expected).hasMessage(\"Not enough parameters were given; expected 1, got 0\");\n+      assertThat(expected).hasMessage(\"index 1 for '$S' not in range (received 0 arguments)\");\n+    }\n+  }\n+\n+  @Test public void unusedArgumentsRelative() {\n+    try {\n+      CodeBlock.builder().add(\"$L $L\", \"a\", \"b\", \"c\");\n+      fail();\n+    } catch (IllegalArgumentException expected) {\n+      assertThat(expected).hasMessage(\"unused arguments: expected 2, received 3\");\n     }\n   }\n \n-  @Test public void unusedArguments() {\n+  @Test public void unusedArgumentsIndexed() {\n     try {\n-      CodeBlock.builder().add(\"\", \"foo\");\n+      CodeBlock.builder().add(\"$1L $2L\", \"a\", \"b\", \"c\");\n       fail();\n     } catch (IllegalArgumentException expected) {\n-      assertThat(expected).hasMessage(\"Too many parameters were given; expected 0, got 1\");\n+      assertThat(expected).hasMessage(\"unused arguments: expected 2, received 3\");\n     }\n   }\n \n"
    },
    {
        "commit_hash": "a5f49c26941650212ac4c952958fcec98b7a5f4b",
        "previous_commit_hash": "66b156f436904cf38956890f8ff6e66c7e1d2661",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -61,7 +61,7 @@\n     <!-- Checks for whitespace                               -->\n     <!-- See http://checkstyle.sf.net/config_whitespace.html -->\n     <module name=\"GenericWhitespace\"/>\n-    <module name=\"EmptyForIteratorPad\"/>\n+    <!--<module name=\"EmptyForIteratorPad\"/>-->\n     <module name=\"MethodParamPad\"/>\n     <module name=\"NoWhitespaceAfter\"/>\n     <module name=\"NoWhitespaceBefore\"/>\n"
    },
    {
        "commit_hash": "a5f49c26941650212ac4c952958fcec98b7a5f4b",
        "previous_commit_hash": "66b156f436904cf38956890f8ff6e66c7e1d2661",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -66,7 +66,7 @@ public final class AnnotationSpec {\n       codeWriter.emit(\"@$T(\" + whitespace, type);\n       codeWriter.indent(2);\n       for (Iterator<Map.Entry<String, List<CodeBlock>>> i\n-          = members.entrySet().iterator(); i.hasNext();) {\n+          = members.entrySet().iterator(); i.hasNext(); ) {\n         Map.Entry<String, List<CodeBlock>> entry = i.next();\n         codeWriter.emit(\"$L = \", entry.getKey());\n         emitAnnotationValues(codeWriter, whitespace, memberSeparator, entry.getValue());\n"
    },
    {
        "commit_hash": "a5f49c26941650212ac4c952958fcec98b7a5f4b",
        "previous_commit_hash": "66b156f436904cf38956890f8ff6e66c7e1d2661",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -102,7 +102,7 @@ public final class CodeBlock {\n       boolean hasIndexed = false;\n       int parameterCount = 0;\n \n-      for (int p = 0; p < format.length();) {\n+      for (int p = 0; p < format.length(); ) {\n         if (format.charAt(p) != '$') {\n           int nextP = format.indexOf('$', p + 1);\n           if (nextP == -1) nextP = format.length();\n"
    },
    {
        "commit_hash": "a5f49c26941650212ac4c952958fcec98b7a5f4b",
        "previous_commit_hash": "66b156f436904cf38956890f8ff6e66c7e1d2661",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -100,7 +100,7 @@ public final class MethodSpec {\n     }\n \n     boolean firstParameter = true;\n-    for (Iterator<ParameterSpec> i = parameters.iterator(); i.hasNext();) {\n+    for (Iterator<ParameterSpec> i = parameters.iterator(); i.hasNext(); ) {\n       ParameterSpec parameter = i.next();\n       if (!firstParameter) codeWriter.emit(\", \");\n       parameter.emit(codeWriter, !i.hasNext() && varargs);\n"
    },
    {
        "commit_hash": "a5f49c26941650212ac4c952958fcec98b7a5f4b",
        "previous_commit_hash": "66b156f436904cf38956890f8ff6e66c7e1d2661",
        "diff_stats": {
            "additions": 124,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright (C) 2015 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javapoet;\n+\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.lang.model.SourceVersion;\n+\n+import static com.squareup.javapoet.Util.checkNotNull;\n+\n+/**\n+ * Assigns Java identifier names to avoid collisions, keywords, and invalid characters. To use,\n+ * first create an instance and allocate all of the names that you need. Typically this is a\n+ * mix of user-supplied names and constants: <pre>   {@code\n+ *\n+ *   NameAllocator nameAllocator = new NameAllocator();\n+ *   for (MyProperty property : properties) {\n+ *     nameAllocator.newName(property.name(), property);\n+ *   }\n+ *   nameAllocator.newName(\"sb\", \"string builder\");\n+ * }</pre>\n+ *\n+ * Pass a unique tag object to each allocation. The tag scopes the name, and can be used to look up\n+ * the allocated name later. Typically the tag is the object that is being named. In the above\n+ * example we use {@code property} for the user-supplied property names, and {@code \"string\n+ * builder\"} for our constant string builder.\n+ *\n+ * <p>Once we've allocated names we can use them when generating code: <pre>   {@code\n+ *\n+ *   MethodSpec.Builder builder = MethodSpec.methodBuilder(\"toString\")\n+ *       .addAnnotation(Override.class)\n+ *       .addModifiers(Modifier.PUBLIC)\n+ *       .returns(String.class);\n+ *\n+ *   builder.addStatement(\"$1T $2N = new $1T()\",\n+ *       StringBuilder.class, nameAllocator.get(\"string builder\"));\n+ *   for (MyProperty property : properties) {\n+ *     builder.addStatement(\"$N.append($N)\",\n+ *         nameAllocator.get(\"string builder\"), nameAllocator.get(property));\n+ *   }\n+ *   builder.addStatement(\"return $N\", nameAllocator.get(\"string builder\"));\n+ *   return builder.build();\n+ * }</pre>\n+ *\n+ * The above code generates unique names if presented with conflicts. Given user-supplied properties\n+ * with names {@code ab} and {@code sb} this generates the following:  <pre>   {@code\n+ *\n+ *   @Override\n+ *   public String toString() {\n+ *     StringBuilder sb_ = new StringBuilder();\n+ *     sb_.append(ab);\n+ *     sb_.append(sb);\n+ *     return sb_.toString();\n+ *   }\n+ * }</pre>\n+ *\n+ * The underscore is appended to {@code sb} to avoid conflicting with the user-supplied {@code sb}\n+ * property. Underscores are also prefixed for names that start with a digit, and used to replace\n+ * name-unsafe characters like space or dash.\n+ */\n+public final class NameAllocator {\n+  private final Set<String> allocatedNames = new LinkedHashSet<>();\n+  private final Map<Object, String> tagToName = new LinkedHashMap<>();\n+\n+  public String newName(String suggestion, Object tag) {\n+    checkNotNull(suggestion, \"suggestion\");\n+    checkNotNull(tag, \"tag\");\n+\n+    suggestion = toJavaIdentifier(suggestion);\n+\n+    while (SourceVersion.isKeyword(suggestion) || !allocatedNames.add(suggestion)) {\n+      suggestion = suggestion + \"_\";\n+    }\n+\n+    String replaced = tagToName.put(tag, suggestion);\n+    if (replaced != null) {\n+      tagToName.put(tag, replaced); // Put things back as they were!\n+      throw new IllegalArgumentException(\"tag \" + tag + \" cannot be used for both '\" + replaced\n+          + \"' and '\" + suggestion + \"'\");\n+    }\n+\n+    return suggestion;\n+  }\n+\n+  public static String toJavaIdentifier(String suggestion) {\n+    StringBuilder result = new StringBuilder();\n+    for (int i = 0; i < suggestion.length(); ) {\n+      int codePoint = suggestion.codePointAt(i);\n+      if (i == 0\n+          && !Character.isJavaIdentifierStart(codePoint)\n+          && Character.isJavaIdentifierPart(codePoint)) {\n+        result.append(\"_\");\n+      }\n+\n+      int validCodePoint = Character.isJavaIdentifierPart(codePoint) ? codePoint : '_';\n+      result.appendCodePoint(validCodePoint);\n+      i += Character.charCount(codePoint);\n+    }\n+    return result.toString();\n+  }\n+\n+  public String get(Object tag) {\n+    String result = tagToName.get(tag);\n+    if (result == null) {\n+      throw new IllegalArgumentException(\"unknown tag: \" + tag);\n+    }\n+    return result;\n+  }\n+}\n"
    },
    {
        "commit_hash": "a5f49c26941650212ac4c952958fcec98b7a5f4b",
        "previous_commit_hash": "66b156f436904cf38956890f8ff6e66c7e1d2661",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -196,7 +196,7 @@ public final class TypeSpec {\n       codeWriter.indent();\n       boolean firstMember = true;\n       for (Iterator<Map.Entry<String, TypeSpec>> i = enumConstants.entrySet().iterator();\n-          i.hasNext();) {\n+          i.hasNext(); ) {\n         Map.Entry<String, TypeSpec> enumConstant = i.next();\n         if (!firstMember) codeWriter.emit(\"\\n\");\n         enumConstant.getValue()\n"
    },
    {
        "commit_hash": "a5f49c26941650212ac4c952958fcec98b7a5f4b",
        "previous_commit_hash": "66b156f436904cf38956890f8ff6e66c7e1d2661",
        "diff_stats": {
            "additions": 88,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright (C) 2015 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javapoet;\n+\n+import org.junit.Test;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.junit.Assert.fail;\n+\n+public final class NameAllocatorTest {\n+  @Test public void usage() throws Exception {\n+    NameAllocator nameAllocator = new NameAllocator();\n+    assertThat(nameAllocator.newName(\"foo\", 1)).isEqualTo(\"foo\");\n+    assertThat(nameAllocator.newName(\"bar\", 2)).isEqualTo(\"bar\");\n+    assertThat(nameAllocator.get(1)).isEqualTo(\"foo\");\n+    assertThat(nameAllocator.get(2)).isEqualTo(\"bar\");\n+  }\n+\n+  @Test public void nameCollision() throws Exception {\n+    NameAllocator nameAllocator = new NameAllocator();\n+    assertThat(nameAllocator.newName(\"foo\", 1)).isEqualTo(\"foo\");\n+    assertThat(nameAllocator.newName(\"foo\", 2)).isEqualTo(\"foo_\");\n+    assertThat(nameAllocator.newName(\"foo\", 3)).isEqualTo(\"foo__\");\n+    assertThat(nameAllocator.get(1)).isEqualTo(\"foo\");\n+    assertThat(nameAllocator.get(2)).isEqualTo(\"foo_\");\n+    assertThat(nameAllocator.get(3)).isEqualTo(\"foo__\");\n+  }\n+\n+  @Test public void characterMappingSubstitute() throws Exception {\n+    NameAllocator nameAllocator = new NameAllocator();\n+    assertThat(nameAllocator.newName(\"a-b\", 1)).isEqualTo(\"a_b\");\n+  }\n+\n+  @Test public void characterMappingSurrogate() throws Exception {\n+    NameAllocator nameAllocator = new NameAllocator();\n+    assertThat(nameAllocator.newName(\"a\\uD83C\\uDF7Ab\", 1)).isEqualTo(\"a_b\");\n+  }\n+\n+  @Test public void characterMappingInvalidStartButValidPart() throws Exception {\n+    NameAllocator nameAllocator = new NameAllocator();\n+    assertThat(nameAllocator.newName(\"1ab\", 1)).isEqualTo(\"_1ab\");\n+  }\n+\n+  @Test public void characterMappingInvalidStartIsInvalidPart() throws Exception {\n+    NameAllocator nameAllocator = new NameAllocator();\n+    assertThat(nameAllocator.newName(\"&ab\", 1)).isEqualTo(\"_ab\");\n+  }\n+\n+  @Test public void javaKeyword() throws Exception {\n+    NameAllocator nameAllocator = new NameAllocator();\n+    assertThat(nameAllocator.newName(\"public\", 1)).isEqualTo(\"public_\");\n+    assertThat(nameAllocator.get(1)).isEqualTo(\"public_\");\n+  }\n+\n+  @Test public void tagReuseForbidden() throws Exception {\n+    NameAllocator nameAllocator = new NameAllocator();\n+    nameAllocator.newName(\"foo\", 1);\n+    try {\n+      nameAllocator.newName(\"bar\", 1);\n+      fail();\n+    } catch (IllegalArgumentException expected) {\n+      assertThat(expected).hasMessage(\"tag 1 cannot be used for both 'foo' and 'bar'\");\n+    }\n+  }\n+\n+  @Test public void useBeforeAllocateForbidden() throws Exception {\n+    NameAllocator nameAllocator = new NameAllocator();\n+    try {\n+      nameAllocator.get(1);\n+      fail();\n+    } catch (IllegalArgumentException expected) {\n+      assertThat(expected).hasMessage(\"unknown tag: 1\");\n+    }\n+  }\n+}\n"
    },
    {
        "commit_hash": "ee9e4da8f7b7191ca150205c12f7abd1c92b736e",
        "previous_commit_hash": "c2a686d75cf0b621571a4fb9286521a29badfe79",
        "diff_stats": {
            "additions": 1,
            "deletions": 2
        },
        "diff_content": "@@ -131,6 +131,7 @@ public final class TypeSpec {\n     try {\n       if (enumName != null) {\n         codeWriter.emitJavadoc(javadoc);\n+        codeWriter.emitAnnotations(annotations, false);\n         codeWriter.emit(\"$L\", enumName);\n         if (!anonymousTypeArguments.formatParts.isEmpty()) {\n           codeWriter.emit(\"(\");\n@@ -352,7 +353,6 @@ public final class TypeSpec {\n     }\n \n     public Builder addAnnotations(Iterable<AnnotationSpec> annotationSpecs) {\n-      checkState(anonymousTypeArguments == null, \"forbidden on anonymous types.\");\n       checkArgument(annotationSpecs != null, \"annotationSpecs == null\");\n       for (AnnotationSpec annotationSpec : annotationSpecs) {\n         this.annotations.add(annotationSpec);\n@@ -361,7 +361,6 @@ public final class TypeSpec {\n     }\n \n     public Builder addAnnotation(AnnotationSpec annotationSpec) {\n-      checkState(anonymousTypeArguments == null, \"forbidden on anonymous types.\");\n       this.annotations.add(annotationSpec);\n       return this;\n     }\n"
    },
    {
        "commit_hash": "ee9e4da8f7b7191ca150205c12f7abd1c92b736e",
        "previous_commit_hash": "c2a686d75cf0b621571a4fb9286521a29badfe79",
        "diff_stats": {
            "additions": 25,
            "deletions": 0
        },
        "diff_content": "@@ -441,6 +441,31 @@ public final class TypeSpecTest {\n         + \"}\\n\");\n   }\n \n+  /** https://github.com/square/javapoet/issues/253 */\n+  @Test public void enumWithAnnotatedValues() throws Exception {\n+    TypeSpec roshambo = TypeSpec.enumBuilder(\"Roshambo\")\n+        .addModifiers(Modifier.PUBLIC)\n+        .addEnumConstant(\"ROCK\", TypeSpec.anonymousClassBuilder(\"\")\n+            .addAnnotation(Deprecated.class)\n+            .build())\n+        .addEnumConstant(\"PAPER\")\n+        .addEnumConstant(\"SCISSORS\")\n+        .build();\n+    assertThat(toString(roshambo)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import java.lang.Deprecated;\\n\"\n+        + \"\\n\"\n+        + \"public enum Roshambo {\\n\"\n+        + \"  @Deprecated\\n\"\n+        + \"  ROCK,\\n\"\n+        + \"\\n\"\n+        + \"  PAPER,\\n\"\n+        + \"\\n\"\n+        + \"  SCISSORS\\n\"\n+        + \"}\\n\");\n+  }\n+\n   @Test public void methodThrows() throws Exception {\n     TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n         .addModifiers(Modifier.ABSTRACT)\n"
    },
    {
        "commit_hash": "5dff6c537a450dae93192f367269a2ff092a3793",
        "previous_commit_hash": "0b0e5d8b935476bf4a30852cf843d55330f33f84",
        "diff_stats": {
            "additions": 0,
            "deletions": 5
        },
        "diff_content": "@@ -33,12 +33,7 @@ import javax.lang.model.type.WildcardType;\n import javax.lang.model.util.Elements;\n import javax.lang.model.util.Types;\n \n-import org.junit.Rule;\n import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.junit.runners.JUnit4;\n-\n-import com.google.testing.compile.CompilationRule;\n \n public abstract class AbstractTypesTest {\n   protected abstract Elements getElements();\n"
    },
    {
        "commit_hash": "5dff6c537a450dae93192f367269a2ff092a3793",
        "previous_commit_hash": "0b0e5d8b935476bf4a30852cf843d55330f33f84",
        "diff_stats": {
            "additions": 0,
            "deletions": 1
        },
        "diff_content": "@@ -29,7 +29,6 @@ import java.util.EventListener;\n import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n-import java.util.NoSuchElementException;\n import java.util.Random;\n \n import javax.lang.model.element.Element;\n"
    },
    {
        "commit_hash": "dc836e498fde995a74c71f363957522192b69ed5",
        "previous_commit_hash": "beebe467ae28c3d6288922fd1c04c0d455ddc858",
        "diff_stats": {
            "additions": 39,
            "deletions": 2
        },
        "diff_content": "@@ -296,9 +296,9 @@ final class CodeWriter {\n       return className.canonicalName;\n     }\n \n-    // Look for the longest common prefix, which we can omit.\n+    // Look for the longest non-conflicting common prefix, which we can omit.\n     List<String> classNames = className.simpleNames();\n-    int prefixLength = commonPrefixLength(classNames);\n+    int prefixLength = nonConflictingCommonPrefixLength(classNames);\n     if (prefixLength == classNames.size()) {\n       return className.simpleName(); // Special case: a class referring to itself!\n     }\n@@ -337,6 +337,43 @@ final class CodeWriter {\n     return size;\n   }\n \n+  /**\n+   * Returns the common prefix of {@code classNames} and the current nesting scope which doesn't\n+   * conflict with a type name in the current scope (any member of a parent type, except for\n+   * {@code classNames} itself).\n+   */\n+  private int nonConflictingCommonPrefixLength(List<String> classNames) {\n+    int index = commonPrefixLength(classNames);\n+\n+    // Class is referring to itself\n+    if (index == classNames.size()) return index;\n+\n+    // Try to find the least-qualified non-conflicting name\n+    for (; index > 0; index--) {\n+      if (!parentTypeHasMemberType(classNames.get(index), index)) {\n+        // No parent type has a member type with a conflicting name\n+        return index;\n+      }\n+    }\n+\n+    return 0; // Fully-qualified name.\n+  }\n+\n+  /**\n+   * Walk down the type stack and return true if any type on the stack\n+   * has {@code className} as a member, except the type at {@code index}.\n+   */\n+  private boolean parentTypeHasMemberType(String className, int index) {\n+    for (int i = 0; i < typeSpecStack.size(); i++) {\n+      if (index != (i + 1)) {\n+        for (TypeSpec nestedTypeSpec : typeSpecStack.get(i).typeSpecs) {\n+          if (nestedTypeSpec.name.equals(className)) return true;\n+        }\n+      }\n+    }\n+    return false;\n+  }\n+\n   /**\n    * Emits {@code s} with indentation as required. It's important that all code that writes to\n    * {@link #out} does it through here, since we emit indentation lazily in order to avoid\n"
    },
    {
        "commit_hash": "dc836e498fde995a74c71f363957522192b69ed5",
        "previous_commit_hash": "beebe467ae28c3d6288922fd1c04c0d455ddc858",
        "diff_stats": {
            "additions": 77,
            "deletions": 3
        },
        "diff_content": "@@ -17,7 +17,6 @@ package com.squareup.javapoet;\n \n import java.util.Date;\n import javax.lang.model.element.Modifier;\n-import org.junit.Ignore;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n@@ -117,8 +116,7 @@ public final class JavaFileTest {\n         + \"}\\n\");\n   }\n \n-  @Ignore(\"https://github.com/square/javapoet/issues/298\")\n-  @Test public void conflictingSimpleNames() throws Exception {\n+  @Test public void conflictingParentName() throws Exception {\n     String source = JavaFile.builder(\"com.squareup.tacos\",\n         TypeSpec.classBuilder(\"A\")\n             .addType(TypeSpec.classBuilder(\"B\")\n@@ -154,6 +152,82 @@ public final class JavaFileTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void conflictingChildName() throws Exception {\n+    String source = JavaFile.builder(\"com.squareup.tacos\",\n+        TypeSpec.classBuilder(\"A\")\n+            .addType(TypeSpec.classBuilder(\"B\")\n+                .addType(TypeSpec.classBuilder(\"C\")\n+                    .addField(ClassName.get(\"com.squareup.tacos\", \"A\", \"Twin\", \"D\"), \"d\")\n+                    .addType(TypeSpec.classBuilder(\"Twin\").build())\n+                    .build())\n+                .build())\n+            .addType(TypeSpec.classBuilder(\"Twin\")\n+                .addType(TypeSpec.classBuilder(\"D\")\n+                    .build())\n+                .build())\n+            .build())\n+        .build()\n+        .toString();\n+    assertThat(source).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"class A {\\n\"\n+        + \"  class B {\\n\"\n+        + \"    class C {\\n\"\n+        + \"      A.Twin.D d;\\n\"\n+        + \"\\n\"\n+        + \"      class Twin {\\n\"\n+        + \"      }\\n\"\n+        + \"    }\\n\"\n+        + \"  }\\n\"\n+        + \"\\n\"\n+        + \"  class Twin {\\n\"\n+        + \"    class D {\\n\"\n+        + \"    }\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void conflictingNameOutOfScope() throws Exception {\n+    String source = JavaFile.builder(\"com.squareup.tacos\",\n+        TypeSpec.classBuilder(\"A\")\n+            .addType(TypeSpec.classBuilder(\"B\")\n+                .addType(TypeSpec.classBuilder(\"C\")\n+                    .addField(ClassName.get(\"com.squareup.tacos\", \"A\", \"Twin\", \"D\"), \"d\")\n+                    .addType(TypeSpec.classBuilder(\"Nested\")\n+                        .addType(TypeSpec.classBuilder(\"Twin\").build())\n+                        .build())\n+                    .build())\n+                .build())\n+            .addType(TypeSpec.classBuilder(\"Twin\")\n+                .addType(TypeSpec.classBuilder(\"D\")\n+                    .build())\n+                .build())\n+            .build())\n+        .build()\n+        .toString();\n+    assertThat(source).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"class A {\\n\"\n+        + \"  class B {\\n\"\n+        + \"    class C {\\n\"\n+        + \"      Twin.D d;\\n\"\n+        + \"\\n\"\n+        + \"      class Nested {\\n\"\n+        + \"        class Twin {\\n\"\n+        + \"        }\\n\"\n+        + \"      }\\n\"\n+        + \"    }\\n\"\n+        + \"  }\\n\"\n+        + \"\\n\"\n+        + \"  class Twin {\\n\"\n+        + \"    class D {\\n\"\n+        + \"    }\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n   @Test public void defaultPackage() throws Exception {\n     String source = JavaFile.builder(\"\",\n         TypeSpec.classBuilder(\"HelloWorld\")\n"
    },
    {
        "commit_hash": "6551850b3eaa4f5ff4b6ce6a2b2102d281a11fee",
        "previous_commit_hash": "99739456865136a6c294989a5a3e66f20fa5991a",
        "diff_stats": {
            "additions": 11,
            "deletions": 1
        },
        "diff_content": "@@ -18,6 +18,11 @@ package com.squareup.javapoet;\n import java.io.IOException;\n import java.lang.reflect.GenericArrayType;\n import java.lang.reflect.Type;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import javax.lang.model.element.TypeParameterElement;\n import javax.lang.model.type.ArrayType;\n \n import static com.squareup.javapoet.Util.checkNotNull;\n@@ -54,7 +59,12 @@ public final class ArrayTypeName extends TypeName {\n \n   /** Returns an array type equivalent to {@code mirror}. */\n   public static ArrayTypeName get(ArrayType mirror) {\n-    return new ArrayTypeName(get(mirror.getComponentType()));\n+    return get(mirror, new LinkedHashMap<TypeParameterElement, TypeVariableName>());\n+  }\n+\n+  static ArrayTypeName get(\n+      ArrayType mirror, Map<TypeParameterElement, TypeVariableName> typeVariables) {\n+    return new ArrayTypeName(get(mirror.getComponentType(), typeVariables));\n   }\n \n   /** Returns an array type equivalent to {@code type}. */\n"
    },
    {
        "commit_hash": "6551850b3eaa4f5ff4b6ce6a2b2102d281a11fee",
        "previous_commit_hash": "99739456865136a6c294989a5a3e66f20fa5991a",
        "diff_stats": {
            "additions": 14,
            "deletions": 4
        },
        "diff_content": "@@ -22,8 +22,13 @@ import java.lang.reflect.Type;\n import java.lang.reflect.TypeVariable;\n import java.lang.reflect.WildcardType;\n import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n import java.util.List;\n+import java.util.Map;\n+\n import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.TypeParameterElement;\n import javax.lang.model.type.ArrayType;\n import javax.lang.model.type.DeclaredType;\n import javax.lang.model.type.NoType;\n@@ -152,6 +157,11 @@ public class TypeName {\n \n   /** Returns a type name equivalent to {@code mirror}. */\n   public static TypeName get(TypeMirror mirror) {\n+    return get(mirror, new LinkedHashMap<TypeParameterElement, TypeVariableName>());\n+  }\n+\n+  static TypeName get(TypeMirror mirror,\n+      final Map<TypeParameterElement, TypeVariableName> typeVariables) {\n     return mirror.accept(new SimpleTypeVisitor7<TypeName, Void>() {\n       @Override public TypeName visitPrimitive(PrimitiveType t, Void p) {\n         switch (t.getKind()) {\n@@ -182,21 +192,21 @@ public class TypeName {\n \n         List<TypeName> typeArgumentNames = new ArrayList<>();\n         for (TypeMirror mirror : t.getTypeArguments()) {\n-          typeArgumentNames.add(get(mirror));\n+          typeArgumentNames.add(get(mirror, typeVariables));\n         }\n         return new ParameterizedTypeName(rawType, typeArgumentNames);\n       }\n \n       @Override public ArrayTypeName visitArray(ArrayType t, Void p) {\n-        return ArrayTypeName.get(t);\n+        return ArrayTypeName.get(t, typeVariables);\n       }\n \n       @Override public TypeName visitTypeVariable(javax.lang.model.type.TypeVariable t, Void p) {\n-        return TypeVariableName.get(t);\n+        return TypeVariableName.get(t, typeVariables);\n       }\n \n       @Override public TypeName visitWildcard(javax.lang.model.type.WildcardType t, Void p) {\n-        return WildcardTypeName.get(t);\n+        return WildcardTypeName.get(t, typeVariables);\n       }\n \n       @Override public TypeName visitNoType(NoType t, Void p) {\n"
    },
    {
        "commit_hash": "6551850b3eaa4f5ff4b6ce6a2b2102d281a11fee",
        "previous_commit_hash": "99739456865136a6c294989a5a3e66f20fa5991a",
        "diff_stats": {
            "additions": 45,
            "deletions": 13
        },
        "diff_content": "@@ -17,13 +17,15 @@ package com.squareup.javapoet;\n \n import java.io.IOException;\n import java.lang.reflect.Type;\n-import java.lang.reflect.TypeVariable;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n+import java.util.Map;\n+\n import javax.lang.model.element.TypeParameterElement;\n import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.type.TypeVariable;\n \n import static com.squareup.javapoet.Util.checkArgument;\n import static com.squareup.javapoet.Util.checkNotNull;\n@@ -33,18 +35,21 @@ public final class TypeVariableName extends TypeName {\n   public final List<TypeName> bounds;\n \n   private TypeVariableName(String name, List<TypeName> bounds) {\n-    // Strip java.lang.Object from bounds if it is present.\n-    List<TypeName> boundsNoObject = new ArrayList<>(bounds);\n-    boundsNoObject.remove(OBJECT);\n-\n     this.name = checkNotNull(name, \"name == null\");\n-    this.bounds = Collections.unmodifiableList(boundsNoObject);\n+    this.bounds = bounds;\n \n     for (TypeName bound : this.bounds) {\n       checkArgument(!bound.isPrimitive() && bound != VOID, \"invalid bound: %s\", bound);\n     }\n   }\n \n+  private static TypeVariableName of(String name, List<TypeName> bounds) {\n+    // Strip java.lang.Object from bounds if it is present.\n+    List<TypeName> boundsNoObject = new ArrayList<>(bounds);\n+    boundsNoObject.remove(OBJECT);\n+    return new TypeVariableName(name, Collections.unmodifiableList(boundsNoObject));\n+  }\n+\n   @Override public boolean equals(Object o) {\n     return o instanceof TypeVariableName\n         && ((TypeVariableName) o).name.equals(name)\n@@ -61,24 +66,51 @@ public final class TypeVariableName extends TypeName {\n \n   /** Returns type variable named {@code name} without bounds. */\n   public static TypeVariableName get(String name) {\n-    return new TypeVariableName(name, Collections.<TypeName>emptyList());\n+    return TypeVariableName.of(name, Collections.<TypeName>emptyList());\n   }\n \n   /** Returns type variable named {@code name} with {@code bounds}. */\n   public static TypeVariableName get(String name, TypeName... bounds) {\n-    return new TypeVariableName(name, Arrays.asList(bounds));\n+    return TypeVariableName.of(name, Arrays.asList(bounds));\n   }\n \n   /** Returns type variable named {@code name} with {@code bounds}. */\n   public static TypeVariableName get(String name, Type... bounds) {\n-    return new TypeVariableName(name, TypeName.list(bounds));\n+    return TypeVariableName.of(name, TypeName.list(bounds));\n   }\n \n   /** Returns type variable equivalent to {@code mirror}. */\n-  public static TypeVariableName get(javax.lang.model.type.TypeVariable mirror) {\n+  public static TypeVariableName get(TypeVariable mirror) {\n     return get((TypeParameterElement) mirror.asElement());\n   }\n \n+  /**\n+   * Make a TypeVariableName for the given TypeMirror. This form is used internally to avoid\n+   * infinite recursion in cases like {@code Enum<E extends Enum<E>>}. When we encounter such a\n+   * thing, we will make a TypeVariableName without bounds and add that to the {@code typeVariables}\n+   * map before looking up the bounds. Then if we encounter this TypeVariable again while\n+   * constructing the bounds, we can just return it from the map. And, the code that put the entry\n+   * in {@code variables} will make sure that the bounds are filled in before returning.\n+   */\n+  static TypeVariableName get(\n+      TypeVariable mirror, Map<TypeParameterElement, TypeVariableName> typeVariables) {\n+    TypeParameterElement element = (TypeParameterElement) mirror.asElement();\n+    TypeVariableName typeVariableName = typeVariables.get(element);\n+    if (typeVariableName == null) {\n+      // Since the bounds field is public, we need to make it an unmodifiableList. But we control\n+      // the List that that wraps, which means we can change it before returning.\n+      List<TypeName> bounds = new ArrayList<>();\n+      List<TypeName> visibleBounds = Collections.unmodifiableList(bounds);\n+      typeVariableName = new TypeVariableName(element.getSimpleName().toString(), visibleBounds);\n+      typeVariables.put(element, typeVariableName);\n+      for (TypeMirror typeMirror : element.getBounds()) {\n+        bounds.add(TypeName.get(typeMirror, typeVariables));\n+      }\n+      bounds.remove(OBJECT);\n+    }\n+    return typeVariableName;\n+  }\n+\n   /** Returns type variable equivalent to {@code element}. */\n   public static TypeVariableName get(TypeParameterElement element) {\n     String name = element.getSimpleName().toString();\n@@ -89,11 +121,11 @@ public final class TypeVariableName extends TypeName {\n       boundsTypeNames.add(TypeName.get(typeMirror));\n     }\n \n-    return new TypeVariableName(name, boundsTypeNames);\n+    return TypeVariableName.of(name, boundsTypeNames);\n   }\n \n   /** Returns type variable equivalent to {@code type}. */\n-  public static TypeVariableName get(TypeVariable<?> type) {\n-    return new TypeVariableName(type.getName(), TypeName.list(type.getBounds()));\n+  public static TypeVariableName get(java.lang.reflect.TypeVariable<?> type) {\n+    return TypeVariableName.of(type.getName(), TypeName.list(type.getBounds()));\n   }\n }\n"
    },
    {
        "commit_hash": "6551850b3eaa4f5ff4b6ce6a2b2102d281a11fee",
        "previous_commit_hash": "99739456865136a6c294989a5a3e66f20fa5991a",
        "diff_stats": {
            "additions": 11,
            "deletions": 2
        },
        "diff_content": "@@ -20,7 +20,10 @@ import java.lang.reflect.Type;\n import java.lang.reflect.WildcardType;\n import java.util.Arrays;\n import java.util.Collections;\n+import java.util.LinkedHashMap;\n import java.util.List;\n+import java.util.Map;\n+import javax.lang.model.element.TypeParameterElement;\n import javax.lang.model.type.TypeMirror;\n \n import static com.squareup.javapoet.Util.checkArgument;\n@@ -90,16 +93,22 @@ public final class WildcardTypeName extends TypeName {\n   }\n \n   public static TypeName get(javax.lang.model.type.WildcardType mirror) {\n+    return get(mirror, new LinkedHashMap<TypeParameterElement, TypeVariableName>());\n+  }\n+\n+  static TypeName get(\n+      javax.lang.model.type.WildcardType mirror,\n+      Map<TypeParameterElement, TypeVariableName> typeVariables) {\n     TypeMirror extendsBound = mirror.getExtendsBound();\n     if (extendsBound == null) {\n       TypeMirror superBound = mirror.getSuperBound();\n       if (superBound == null) {\n         return subtypeOf(Object.class);\n       } else {\n-        return supertypeOf(TypeName.get(superBound));\n+        return supertypeOf(TypeName.get(superBound, typeVariables));\n       }\n     } else {\n-      return subtypeOf(TypeName.get(extendsBound));\n+      return subtypeOf(TypeName.get(extendsBound, typeVariables));\n     }\n   }\n \n"
    },
    {
        "commit_hash": "6551850b3eaa4f5ff4b6ce6a2b2102d281a11fee",
        "previous_commit_hash": "99739456865136a6c294989a5a3e66f20fa5991a",
        "diff_stats": {
            "additions": 22,
            "deletions": 0
        },
        "diff_content": "@@ -96,6 +96,28 @@ public abstract class AbstractTypesTest {\n         .containsExactly(number, runnable);\n   }\n \n+  static class Recursive<T extends Map<List<T>, Set<T[]>>> {}\n+\n+  @Test\n+  public void getTypeVariableTypeMirrorRecursive() {\n+    TypeMirror typeMirror = getElement(Recursive.class).asType();\n+    ParameterizedTypeName typeName = (ParameterizedTypeName) TypeName.get(typeMirror);\n+    String className = Recursive.class.getCanonicalName();\n+    assertThat(typeName.toString()).isEqualTo(className + \"<T>\");\n+\n+    TypeVariableName typeVariableName = (TypeVariableName) typeName.typeArguments.get(0);\n+\n+    try {\n+      typeVariableName.bounds.set(0, null);\n+      fail(\"Expected UnsupportedOperationException\");\n+    } catch (UnsupportedOperationException expected) {\n+    }\n+\n+    assertThat(typeVariableName.toString()).isEqualTo(\"T\");\n+    assertThat(typeVariableName.bounds.toString())\n+        .isEqualTo(\"[java.util.Map<java.util.List<T>, java.util.Set<T[]>>]\");\n+  }\n+\n   @Test public void getPrimitiveTypeMirror() {\n     assertThat(TypeName.get(getTypes().getPrimitiveType(TypeKind.BOOLEAN)))\n         .isEqualTo(TypeName.BOOLEAN);\n"
    },
    {
        "commit_hash": "62a8b20e38fab093f94be1e96a98040935103a29",
        "previous_commit_hash": "ec8c5d59a9ac7e7bcab7d147182d602422126da6",
        "diff_stats": {
            "additions": 0,
            "deletions": 1
        },
        "diff_content": "@@ -18,7 +18,6 @@ package com.squareup.javapoet;\n import java.io.IOException;\n import java.lang.reflect.GenericArrayType;\n import java.lang.reflect.Type;\n-import java.util.HashMap;\n import java.util.LinkedHashMap;\n import java.util.Map;\n \n"
    },
    {
        "commit_hash": "62a8b20e38fab093f94be1e96a98040935103a29",
        "previous_commit_hash": "ec8c5d59a9ac7e7bcab7d147182d602422126da6",
        "diff_stats": {
            "additions": 0,
            "deletions": 1
        },
        "diff_content": "@@ -22,7 +22,6 @@ import java.lang.reflect.Type;\n import java.lang.reflect.TypeVariable;\n import java.lang.reflect.WildcardType;\n import java.util.ArrayList;\n-import java.util.HashMap;\n import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n"
    },
    {
        "commit_hash": "38abbc1e4cfd5b6b611f93b621667d54f19b16b3",
        "previous_commit_hash": "ec8c5d59a9ac7e7bcab7d147182d602422126da6",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -231,12 +231,12 @@ final class CodeWriter {\n           break;\n \n         case \"$[\":\n-          checkState(statementLine == -1, \"statements cannot be re-entrant\");\n+          checkState(statementLine == -1, \"statement enter $[ followed by statement enter $[\");\n           statementLine = 0;\n           break;\n \n         case \"$]\":\n-          checkState(statementLine != -1, \"statement exit has no matching statement enter\");\n+          checkState(statementLine != -1, \"statement exit $] has no matching statement enter $[\");\n           if (statementLine > 0) {\n             unindent(2); // End a multi-line statement. Decrease the indentation level.\n           }\n"
    },
    {
        "commit_hash": "38abbc1e4cfd5b6b611f93b621667d54f19b16b3",
        "previous_commit_hash": "ec8c5d59a9ac7e7bcab7d147182d602422126da6",
        "diff_stats": {
            "additions": 54,
            "deletions": 51
        },
        "diff_content": "@@ -20,10 +20,8 @@ import org.junit.Test;\n import static com.google.common.truth.Truth.assertThat;\n import static org.junit.Assert.fail;\n \n-public class CodeBlockTest {\n-  \n-  @Test\n-  public void indentCannotBeIndexed() {\n+public final class CodeBlockTest {\n+  @Test public void indentCannotBeIndexed() {\n     try {\n       CodeBlock.builder().add(\"$1>\", \"taco\").build();\n       fail();\n@@ -32,8 +30,7 @@ public class CodeBlockTest {\n     }\n   }\n   \n-  @Test\n-  public void deindentCannotBeIndexed() {\n+  @Test public void deindentCannotBeIndexed() {\n     try {\n       CodeBlock.builder().add(\"$1<\", \"taco\").build();\n       fail();\n@@ -42,8 +39,7 @@ public class CodeBlockTest {\n     }\n   }\n   \n-  @Test\n-  public void dollarSignEscapeCannotBeIndexed() {\n+  @Test public void dollarSignEscapeCannotBeIndexed() {\n     try {\n       CodeBlock.builder().add(\"$1$\", \"taco\").build();\n       fail();\n@@ -52,8 +48,7 @@ public class CodeBlockTest {\n     }\n   }\n  \n-  @Test\n-  public void statementBeginningCannotBeIndexed() {\n+  @Test public void statementBeginningCannotBeIndexed() {\n     try {\n       CodeBlock.builder().add(\"$1[\", \"taco\").build();\n       fail();\n@@ -62,8 +57,7 @@ public class CodeBlockTest {\n     }\n   }\n   \n-  @Test\n-  public void statementEndingCannotBeIndexed() {\n+  @Test public void statementEndingCannotBeIndexed() {\n     try {\n       CodeBlock.builder().add(\"$1]\", \"taco\").build();\n       fail();\n@@ -72,106 +66,115 @@ public class CodeBlockTest {\n     }\n   }\n   \n-  @Test\n-  public void nameFormatCanBeIndexed() {\n+  @Test public void nameFormatCanBeIndexed() {\n     CodeBlock block = CodeBlock.builder().add(\"$1N\", \"taco\").build();\n     assertThat(block.toString()).isEqualTo(\"taco\");\n   }\n   \n-  @Test\n-  public void literalFormatCanBeIndexed() {\n+  @Test public void literalFormatCanBeIndexed() {\n     CodeBlock block = CodeBlock.builder().add(\"$1L\", \"taco\").build();\n     assertThat(block.toString()).isEqualTo(\"taco\");\n   }\n   \n-  @Test\n-  public void stringFormatCanBeIndexed() {\n+  @Test public void stringFormatCanBeIndexed() {\n     CodeBlock block = CodeBlock.builder().add(\"$1S\", \"taco\").build();\n     assertThat(block.toString()).isEqualTo(\"\\\"taco\\\"\");\n   }\n   \n-  @Test\n-  public void typeFormatCanBeIndexed() {\n+  @Test public void typeFormatCanBeIndexed() {\n     CodeBlock block = CodeBlock.builder().add(\"$1T\", String.class).build();\n     assertThat(block.toString()).isEqualTo(\"java.lang.String\");\n   }\n   \n-  @Test\n-  public void indexTooHigh() {\n+  @Test public void indexTooHigh() {\n     try {\n       CodeBlock.builder().add(\"$2T\", String.class).build();\n       fail();\n-    } catch (IllegalArgumentException exp) {\n-      assertThat(exp).hasMessage(\"index 2 for '$2T' not in range (received 1 arguments)\");\n+    } catch (IllegalArgumentException expected) {\n+      assertThat(expected).hasMessage(\"index 2 for '$2T' not in range (received 1 arguments)\");\n     }\n   }\n   \n-  @Test\n-  public void indexIsZero() {\n+  @Test public void indexIsZero() {\n     try {\n       CodeBlock.builder().add(\"$0T\", String.class).build();\n       fail();\n-    } catch (IllegalArgumentException exp) {\n-      assertThat(exp).hasMessage(\"index 0 for '$0T' not in range (received 1 arguments)\");\n+    } catch (IllegalArgumentException expected) {\n+      assertThat(expected).hasMessage(\"index 0 for '$0T' not in range (received 1 arguments)\");\n     }\n   }\n   \n-  @Test\n-  public void indexIsNegative() {\n+  @Test public void indexIsNegative() {\n     try {\n       CodeBlock.builder().add(\"$-1T\", String.class).build();\n       fail();\n-    } catch (IllegalArgumentException exp) {\n-      assertThat(exp).hasMessage(\"invalid format string: '$-1T'\");\n+    } catch (IllegalArgumentException expected) {\n+      assertThat(expected).hasMessage(\"invalid format string: '$-1T'\");\n     }\n   }\n   \n-  @Test\n-  public void indexWithoutFormatType() {\n+  @Test public void indexWithoutFormatType() {\n     try {\n       CodeBlock.builder().add(\"$1\", String.class).build();\n       fail();\n-    } catch (IllegalArgumentException exp) {\n-      assertThat(exp).hasMessage(\"dangling format characters in '$1'\");\n+    } catch (IllegalArgumentException expected) {\n+      assertThat(expected).hasMessage(\"dangling format characters in '$1'\");\n     }\n   }\n   \n-  @Test\n-  public void indexWithoutFormatTypeNotAtStringEnd() {\n+  @Test public void indexWithoutFormatTypeNotAtStringEnd() {\n     try {\n       CodeBlock.builder().add(\"$1 taco\", String.class).build();\n       fail();\n-    } catch (IllegalArgumentException exp) {\n-      assertThat(exp).hasMessage(\"invalid format string: '$1 taco'\");\n+    } catch (IllegalArgumentException expected) {\n+      assertThat(expected).hasMessage(\"invalid format string: '$1 taco'\");\n     }\n   }\n   \n-  @Test\n-  public void formatIndicatorAlone() {\n+  @Test public void formatIndicatorAlone() {\n     try {\n       CodeBlock.builder().add(\"$\", String.class).build();\n       fail();\n-    } catch (IllegalArgumentException exp) {\n-      assertThat(exp).hasMessage(\"dangling format characters in '$'\");\n+    } catch (IllegalArgumentException expected) {\n+      assertThat(expected).hasMessage(\"dangling format characters in '$'\");\n     }\n   }\n   \n-  @Test\n-  public void formatIndicatorWithoutIndexOrFormatType() {\n+  @Test public void formatIndicatorWithoutIndexOrFormatType() {\n     try {\n       CodeBlock.builder().add(\"$ tacoString\", String.class).build();\n       fail();\n-    } catch (IllegalArgumentException exp) {\n-      assertThat(exp).hasMessage(\"invalid format string: '$ tacoString'\");\n+    } catch (IllegalArgumentException expected) {\n+      assertThat(expected).hasMessage(\"invalid format string: '$ tacoString'\");\n     }\n   }\n   \n-  @Test\n-  public void sameIndexCanBeUsedWithDifferentFormats() {\n+  @Test public void sameIndexCanBeUsedWithDifferentFormats() {\n     CodeBlock block = CodeBlock.builder()\n         .add(\"$1T.out.println($1S)\", ClassName.get(System.class))\n         .build();\n     assertThat(block.toString()).isEqualTo(\"java.lang.System.out.println(\\\"java.lang.System\\\")\");\n   }\n-  \n+\n+  @Test public void tooManyStatementEnters() {\n+    CodeBlock codeBlock = CodeBlock.builder().add(\"$[$[\").build();\n+    try {\n+      // We can't report this error until rendering type because code blocks might be composed.\n+      codeBlock.toString();\n+      fail();\n+    } catch (IllegalStateException expected) {\n+      assertThat(expected).hasMessage(\"statement enter $[ followed by statement enter $[\");\n+    }\n+  }\n+\n+  @Test public void statementExitWithoutStatementEnter() {\n+    CodeBlock codeBlock = CodeBlock.builder().add(\"$]\").build();\n+    try {\n+      // We can't report this error until rendering type because code blocks might be composed.\n+      codeBlock.toString();\n+      fail();\n+    } catch (IllegalStateException expected) {\n+      assertThat(expected).hasMessage(\"statement exit $] has no matching statement enter $[\");\n+    }\n+  }\n }\n"
    },
    {
        "commit_hash": "f6ad309596e9c7ddf4e8420b62507d1dd22887c0",
        "previous_commit_hash": "6a07eecedee4a368a3a1dbdc1a1cb4b88027ae7a",
        "diff_stats": {
            "additions": 8,
            "deletions": 5
        },
        "diff_content": "@@ -101,12 +101,15 @@ public final class ClassName extends TypeName implements Comparable<ClassName> {\n     checkArgument(!void.class.equals(clazz), \"'void' type cannot be represented as a ClassName\");\n     checkArgument(!clazz.isArray(), \"array types cannot be represented as a ClassName\");\n     List<String> names = new ArrayList<>();\n-    for (Class<?> c = clazz; c != null; c = c.getEnclosingClass()) {\n-      names.add(c.getSimpleName());\n-    }\n-    if (clazz.getPackage() != null) {\n-      names.add(clazz.getPackage().getName());\n+    while (true) {\n+      names.add(clazz.getSimpleName());\n+      Class<?> enclosing = clazz.getEnclosingClass();\n+      if (enclosing == null) break;\n+      clazz = enclosing;\n     }\n+    // Avoid unreliable Class.getPackage(). https://github.com/square/javapoet/issues/295\n+    int lastDot = clazz.getName().lastIndexOf('.');\n+    if (lastDot != -1) names.add(clazz.getName().substring(0, lastDot));\n     Collections.reverse(names);\n     return new ClassName(names);\n   }\n"
    },
    {
        "commit_hash": "ebcbf38ea15430394523edabc247a6dc5a1a42b2",
        "previous_commit_hash": "f6ad309596e9c7ddf4e8420b62507d1dd22887c0",
        "diff_stats": {
            "additions": 5,
            "deletions": 8
        },
        "diff_content": "@@ -101,15 +101,12 @@ public final class ClassName extends TypeName implements Comparable<ClassName> {\n     checkArgument(!void.class.equals(clazz), \"'void' type cannot be represented as a ClassName\");\n     checkArgument(!clazz.isArray(), \"array types cannot be represented as a ClassName\");\n     List<String> names = new ArrayList<>();\n-    while (true) {\n-      names.add(clazz.getSimpleName());\n-      Class<?> enclosing = clazz.getEnclosingClass();\n-      if (enclosing == null) break;\n-      clazz = enclosing;\n+    for (Class<?> c = clazz; c != null; c = c.getEnclosingClass()) {\n+      names.add(c.getSimpleName());\n+    }\n+    if (clazz.getPackage() != null) {\n+      names.add(clazz.getPackage().getName());\n     }\n-    // Avoid unreliable Class.getPackage(). https://github.com/square/javapoet/issues/295\n-    int lastDot = clazz.getName().lastIndexOf('.');\n-    if (lastDot != -1) names.add(clazz.getName().substring(0, lastDot));\n     Collections.reverse(names);\n     return new ClassName(names);\n   }\n"
    },
    {
        "commit_hash": "c11551974df548b6a3830eb6bfa1a52b95412280",
        "previous_commit_hash": "ebcbf38ea15430394523edabc247a6dc5a1a42b2",
        "diff_stats": {
            "additions": 8,
            "deletions": 5
        },
        "diff_content": "@@ -101,12 +101,15 @@ public final class ClassName extends TypeName implements Comparable<ClassName> {\n     checkArgument(!void.class.equals(clazz), \"'void' type cannot be represented as a ClassName\");\n     checkArgument(!clazz.isArray(), \"array types cannot be represented as a ClassName\");\n     List<String> names = new ArrayList<>();\n-    for (Class<?> c = clazz; c != null; c = c.getEnclosingClass()) {\n-      names.add(c.getSimpleName());\n-    }\n-    if (clazz.getPackage() != null) {\n-      names.add(clazz.getPackage().getName());\n+    while (true) {\n+      names.add(clazz.getSimpleName());\n+      Class<?> enclosing = clazz.getEnclosingClass();\n+      if (enclosing == null) break;\n+      clazz = enclosing;\n     }\n+    // Avoid unreliable Class.getPackage(). https://github.com/square/javapoet/issues/295\n+    int lastDot = clazz.getName().lastIndexOf('.');\n+    if (lastDot != -1) names.add(clazz.getName().substring(0, lastDot));\n     Collections.reverse(names);\n     return new ClassName(names);\n   }\n"
    },
    {
        "commit_hash": "d597130d3b4d3d379d56f7ed602867f8afeab429",
        "previous_commit_hash": "ebcbf38ea15430394523edabc247a6dc5a1a42b2",
        "diff_stats": {
            "additions": 10,
            "deletions": 0
        },
        "diff_content": "@@ -1,6 +1,16 @@\n Change Log\n ==========\n \n+JavaPoet 1.3.0 *(2015-09-20)*\n+----------------------------\n+\n+ * New: `NameAllocator` API makes it easy to declare non-conflicting names.\n+ * New: Support annotations on enum values.\n+ * Fix: Avoid infinite recursion in `TypeName.get(TypeMirror)`.\n+ * Fix: Use qualified name for conflicting simple names in the same file.\n+ * Fix: Better messages for parameter indexing errors.\n+\n+\n JavaPoet 1.2.0 *(2015-07-04)*\n ----------------------------\n \n"
    },
    {
        "commit_hash": "725eed1a97fd0b88435172e5cedbb968516f9929",
        "previous_commit_hash": "5f349c8f71b63728fb24f737a99732967088b672",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.3.0-SNAPSHOT</version>\n+  <version>1.3.0</version>\n \n   <name>JavaPoet</name>\n   <description>Use beautiful Java code to generate beautiful Java code.</description>\n@@ -54,13 +54,13 @@\n     <dependency>\n       <groupId>com.google.truth</groupId>\n       <artifactId>truth</artifactId>\n-      <version>1.0-SNAPSHOT</version>\n+      <version>0.27</version>\n       <scope>test</scope>\n     </dependency>\n     <dependency>\n       <groupId>com.google.testing.compile</groupId>\n       <artifactId>compile-testing</artifactId>\n-      <version>1.0-SNAPSHOT</version>\n+      <version>0.7</version>\n       <scope>test</scope>\n     </dependency>\n     <dependency>\n"
    },
    {
        "commit_hash": "b71a8d627abc0945ff960616b2ede27ebab84641",
        "previous_commit_hash": "725eed1a97fd0b88435172e5cedbb968516f9929",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.3.0</version>\n+  <version>1.4.0-SNAPSHOT</version>\n \n   <name>JavaPoet</name>\n   <description>Use beautiful Java code to generate beautiful Java code.</description>\n@@ -54,13 +54,13 @@\n     <dependency>\n       <groupId>com.google.truth</groupId>\n       <artifactId>truth</artifactId>\n-      <version>0.27</version>\n+      <version>1.0-SNAPSHOT</version>\n       <scope>test</scope>\n     </dependency>\n     <dependency>\n       <groupId>com.google.testing.compile</groupId>\n       <artifactId>compile-testing</artifactId>\n-      <version>0.7</version>\n+      <version>1.0-SNAPSHOT</version>\n       <scope>test</scope>\n     </dependency>\n     <dependency>\n"
    },
    {
        "commit_hash": "aecf1d5e686e52ceaa033ad736eafae08afb732f",
        "previous_commit_hash": "b71a8d627abc0945ff960616b2ede27ebab84641",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -60,7 +60,7 @@ import static com.squareup.javapoet.Util.checkNotNull;\n  * The above code generates unique names if presented with conflicts. Given user-supplied properties\n  * with names {@code ab} and {@code sb} this generates the following:  <pre>   {@code\n  *\n- *   @Override\n+ *   &#64;Override\n  *   public String toString() {\n  *     StringBuilder sb_ = new StringBuilder();\n  *     sb_.append(ab);\n"
    },
    {
        "commit_hash": "a18a39ecc914d66f1ab402a4b00d5234ab4a7225",
        "previous_commit_hash": "74ed3249db71532d14b670e053df67875dbca23b",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -745,12 +745,12 @@ Download [the latest .jar][dl] or depend via Maven:\n <dependency>\n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.2.0</version>\n+  <version>1.3.0</version>\n </dependency>\n ```\n or Gradle:\n ```groovy\n-compile 'com.squareup:javapoet:1.2.0'\n+compile 'com.squareup:javapoet:1.3.0'\n ```\n \n Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].\n"
    },
    {
        "commit_hash": "f96704d173ffd309da0d48368be577e2defa5310",
        "previous_commit_hash": "ebde08a42d191127b2c08e26513f81ced71ca902",
        "diff_stats": {
            "additions": 8,
            "deletions": 0
        },
        "diff_content": "@@ -63,6 +63,14 @@ public final class ClassName extends TypeName implements Comparable<ClassName> {\n     return new ClassName(names.subList(0, names.size() - 1));\n   }\n \n+  /**\n+   * Returns the top class in this nesting group. Equivalent to chained calls to {@link\n+   * #enclosingClassName()} until the result's enclosing class is null.\n+   */\n+  public ClassName topLevelClassName() {\n+    return new ClassName(names.subList(0, 2));\n+  }\n+\n   /**\n    * Returns a new {@link ClassName} instance for the specified {@code name} as nested inside this\n    * class.\n"
    },
    {
        "commit_hash": "f96704d173ffd309da0d48368be577e2defa5310",
        "previous_commit_hash": "ebde08a42d191127b2c08e26513f81ced71ca902",
        "diff_stats": {
            "additions": 63,
            "deletions": 105
        },
        "diff_content": "@@ -27,12 +27,12 @@ import java.util.Locale;\n import java.util.Map;\n import java.util.Objects;\n import java.util.Set;\n-import java.util.TreeMap;\n import javax.lang.model.element.Modifier;\n \n import static com.squareup.javapoet.Util.checkArgument;\n import static com.squareup.javapoet.Util.checkNotNull;\n import static com.squareup.javapoet.Util.checkState;\n+import static com.squareup.javapoet.Util.join;\n \n /**\n  * Converts a {@link JavaFile} to a string suitable to both human- and javac-consumption. This\n@@ -47,8 +47,8 @@ final class CodeWriter {\n   private boolean comment = false;\n   private String packageName;\n   private final List<TypeSpec> typeSpecStack = new ArrayList<>();\n-  private final Map<ClassName, String> importedTypes;\n-  private final Set<ClassName> importableTypes = new LinkedHashSet<>();\n+  private final Map<String, ClassName> importedTypes;\n+  private final Map<String, ClassName> importableTypes = new LinkedHashMap<>();\n   private final Set<String> referencedNames = new LinkedHashSet<>();\n   private boolean trailingNewline;\n \n@@ -64,16 +64,16 @@ final class CodeWriter {\n   }\n \n   public CodeWriter(Appendable out, String indent) {\n-    this(out, indent, Collections.<ClassName, String>emptyMap());\n+    this(out, indent, Collections.<String, ClassName>emptyMap());\n   }\n \n-  public CodeWriter(Appendable out, String indent, Map<ClassName, String> importedTypes) {\n+  public CodeWriter(Appendable out, String indent, Map<String, ClassName> importedTypes) {\n     this.out = checkNotNull(out, \"out == null\");\n     this.indent = checkNotNull(indent, \"indent == null\");\n     this.importedTypes = checkNotNull(importedTypes, \"importedTypes == null\");\n   }\n \n-  public Map<ClassName, String> importedTypes() {\n+  public Map<String, ClassName> importedTypes() {\n     return importedTypes;\n   }\n \n@@ -272,106 +272,79 @@ final class CodeWriter {\n    * names visible due to inheritance.\n    */\n   String lookupName(ClassName className) {\n-    // Different package than current? Just look for an import.\n-    if (!className.packageName().equals(packageName)) {\n-      if (conflictsWithLocalName(className)) {\n-        return className.toString(); // A local name conflicts? Use the fully-qualified name.\n-      }\n-\n-      String importedName = importedTypes.get(className);\n-      if (importedName != null) {\n-        if (!javadoc) importableTypes.add(className);\n-        referencedNames.add(importedName);\n-        return importedName;\n-      }\n-\n-      // If the target class wasn't imported, perhaps its enclosing class was. Try that.\n-      ClassName enclosingClassName = className.enclosingClassName();\n-      if (enclosingClassName != null) {\n-        return lookupName(enclosingClassName) + \".\" + className.simpleName();\n+    // Find the shortest suffix of className that resolves to className. This uses both local type\n+    // names (so `Entry` in `Map` refers to `Map.Entry`). Also uses imports.\n+    boolean nameResolved = false;\n+    for (ClassName c = className; c != null; c = c.enclosingClassName()) {\n+      ClassName resolved = resolve(c.simpleName());\n+      nameResolved = resolved != null;\n+\n+      if (Objects.equals(resolved, c)) {\n+        int suffixOffset = c.simpleNames().size() - 1;\n+        return join(\".\", className.simpleNames().subList(\n+            suffixOffset, className.simpleNames().size()));\n       }\n+    }\n \n-      // Fall back to the fully-qualified name. Mark the type as importable for a future pass.\n-      if (!javadoc) importableTypes.add(className);\n-      return className.canonicalName;\n+    // If the class is in the same package, we're done.\n+    if (Objects.equals(packageName, className.packageName())) {\n+      referencedNames.add(className.topLevelClassName().simpleName());\n+      return join(\".\", className.simpleNames());\n     }\n \n-    // Look for the longest non-conflicting common prefix, which we can omit.\n-    List<String> classNames = className.simpleNames();\n-    int prefixLength = nonConflictingCommonPrefixLength(classNames);\n-    if (prefixLength == classNames.size()) {\n-      return className.simpleName(); // Special case: a class referring to itself!\n+    // We'll have to use the fully-qualified name. Mark the type as importable for a future pass.\n+    if (!javadoc && !nameResolved) {\n+      importableType(className);\n     }\n \n-    referencedNames.add(classNames.get(0));\n-    return Util.join(\".\", classNames.subList(prefixLength, classNames.size()));\n+    return className.canonicalName;\n   }\n \n-  /**\n-   * Returns true if {@code className} conflicts with a visible class name in the current scope and\n-   * cannot be referred to by its short name.\n-   */\n-  private boolean conflictsWithLocalName(ClassName className) {\n-    for (TypeSpec typeSpec : typeSpecStack) {\n-      if (Objects.equals(typeSpec.name, className.simpleName())) return true;\n-      for (TypeSpec visibleChild : typeSpec.typeSpecs) {\n-        if (Objects.equals(visibleChild.name, className.simpleName())) return true;\n-      }\n+  private void importableType(ClassName className) {\n+    ClassName topLevelClassName = className.topLevelClassName();\n+    String simpleName = topLevelClassName.simpleName();\n+    ClassName replaced = importableTypes.put(simpleName, topLevelClassName);\n+    if (replaced != null) {\n+      importableTypes.put(simpleName, replaced); // On collision, prefer the first inserted.\n     }\n-    return false;\n   }\n \n   /**\n-   * Returns the common prefix of {@code classNames} and the current nesting scope. For example,\n-   * suppose the current scope is {@code AbstractMap.SimpleEntry}. This will return 0 for {@code\n-   * List}, 1 for {@code AbstractMap}, 1 for {@code AbstractMap.SimpleImmutableEntry}, and 2 for\n-   * {@code AbstractMap.SimpleEntry} itself.\n+   * Returns the class referenced by {@code simpleName}, using the current nesting context and\n+   * imports.\n    */\n-  private int commonPrefixLength(List<String> classNames) {\n-    int size = Math.min(classNames.size(), typeSpecStack.size());\n-    for (int i = 0; i < size; i++) {\n-      String a = classNames.get(i);\n-      String b = typeSpecStack.get(i).name;\n-      if (!a.equals(b)) return i;\n+  // TODO(jwilson): also honor superclass members when resolving names.\n+  private ClassName resolve(String simpleName) {\n+    // Match a child of the current (potentially nested) class.\n+    for (int i = typeSpecStack.size() - 1; i >= 0; i--) {\n+      TypeSpec typeSpec = typeSpecStack.get(i);\n+      for (TypeSpec visibleChild : typeSpec.typeSpecs) {\n+        if (Objects.equals(visibleChild.name, simpleName)) {\n+          return stackClassName(i, simpleName);\n+        }\n+      }\n     }\n-    return size;\n-  }\n-\n-  /**\n-   * Returns the common prefix of {@code classNames} and the current nesting scope which doesn't\n-   * conflict with a type name in the current scope (any member of a parent type, except for\n-   * {@code classNames} itself).\n-   */\n-  private int nonConflictingCommonPrefixLength(List<String> classNames) {\n-    int index = commonPrefixLength(classNames);\n \n-    // Class is referring to itself\n-    if (index == classNames.size()) return index;\n-\n-    // Try to find the least-qualified non-conflicting name\n-    for (; index > 0; index--) {\n-      if (!parentTypeHasMemberType(classNames.get(index), index)) {\n-        // No parent type has a member type with a conflicting name\n-        return index;\n-      }\n+    // Match the top-level class.\n+    if (typeSpecStack.size() > 0 && Objects.equals(typeSpecStack.get(0).name, simpleName)) {\n+      return ClassName.get(packageName, simpleName);\n     }\n \n-    return 0; // Fully-qualified name.\n+    // Match an imported type.\n+    ClassName importedType = importedTypes.get(simpleName);\n+    if (importedType != null) return importedType;\n+\n+    // No match.\n+    return null;\n   }\n \n-  /**\n-   * Walk down the type stack and return true if any type on the stack\n-   * has {@code className} as a member, except the type at {@code index}.\n-   */\n-  private boolean parentTypeHasMemberType(String className, int index) {\n-    for (int i = 0; i < typeSpecStack.size(); i++) {\n-      if (index != (i + 1)) {\n-        for (TypeSpec nestedTypeSpec : typeSpecStack.get(i).typeSpecs) {\n-          if (nestedTypeSpec.name.equals(className)) return true;\n-        }\n-      }\n+  /** Returns the class named {@code simpleName} when nested in the class at {@code stackDepth}. */\n+  private ClassName stackClassName(int stackDepth, String simpleName) {\n+    ClassName className = ClassName.get(packageName, typeSpecStack.get(0).name);\n+    for (int i = 1; i <= stackDepth; i++) {\n+      className = className.nestedClass(typeSpecStack.get(i).name);\n     }\n-    return false;\n+    return className.nestedClass(simpleName);\n   }\n \n   /**\n@@ -427,25 +400,10 @@ final class CodeWriter {\n    * Returns the types that should have been imported for this code. If there were any simple name\n    * collisions, that type's first use is imported.\n    */\n-  Map<ClassName, String> suggestedImports() {\n-    // Find the simple names that can be imported, and the classes that they target.\n-    Map<String, ClassName> simpleNameToType = new LinkedHashMap<>();\n-    for (ClassName className : importableTypes) {\n-      if (referencedNames.contains(className.simpleName())) continue;\n-      if (simpleNameToType.containsKey(className.simpleName())) continue;\n-      simpleNameToType.put(className.simpleName(), className);\n-    }\n-\n-    // Invert the map.\n-    TreeMap<ClassName, String> typeToSimpleName = new TreeMap<>();\n-    for (Map.Entry<String, ClassName> entry : simpleNameToType.entrySet()) {\n-      typeToSimpleName.put(entry.getValue(), entry.getKey());\n-    }\n-\n-    // TODO(jwilson): omit imports from java.lang, unless their simple names is also present in the\n-    //     current class's package. (Yuck.)\n-\n-    return typeToSimpleName;\n+  Map<String, ClassName> suggestedImports() {\n+    Map<String, ClassName> result = new LinkedHashMap<>(importableTypes);\n+    result.keySet().removeAll(referencedNames);\n+    return result;\n   }\n \n   /** Returns the string literal representing {@code data}, including wrapping quotes. */\n"
    },
    {
        "commit_hash": "f96704d173ffd309da0d48368be577e2defa5310",
        "previous_commit_hash": "ebde08a42d191127b2c08e26513f81ced71ca902",
        "diff_stats": {
            "additions": 3,
            "deletions": 2
        },
        "diff_content": "@@ -27,6 +27,7 @@ import java.nio.file.Path;\n import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n+import java.util.TreeSet;\n import javax.annotation.processing.Filer;\n import javax.lang.model.element.Element;\n import javax.lang.model.element.Modifier;\n@@ -69,7 +70,7 @@ public final class JavaFile {\n     // First pass: emit the entire class, just to collect the types we'll need to import.\n     CodeWriter importsCollector = new CodeWriter(NULL_APPENDABLE, indent);\n     emit(importsCollector);\n-    Map<ClassName, String> suggestedImports = importsCollector.suggestedImports();\n+    Map<String, ClassName> suggestedImports = importsCollector.suggestedImports();\n \n     // Second pass: write the code, taking advantage of the imports.\n     CodeWriter codeWriter = new CodeWriter(out, indent, suggestedImports);\n@@ -131,7 +132,7 @@ public final class JavaFile {\n     }\n \n     int importedTypesCount = 0;\n-    for (ClassName className : codeWriter.importedTypes().keySet()) {\n+    for (ClassName className : new TreeSet<>(codeWriter.importedTypes().values())) {\n       if (skipJavaLangImports && className.packageName().equals(\"java.lang\")) continue;\n       codeWriter.emit(\"import $L;\\n\", className);\n       importedTypesCount++;\n"
    },
    {
        "commit_hash": "f96704d173ffd309da0d48368be577e2defa5310",
        "previous_commit_hash": "ebde08a42d191127b2c08e26513f81ced71ca902",
        "diff_stats": {
            "additions": 21,
            "deletions": 0
        },
        "diff_content": "@@ -228,6 +228,27 @@ public final class JavaFileTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void nestedClassAndSuperclassShareName() throws Exception {\n+    String source = JavaFile.builder(\"com.squareup.tacos\",\n+        TypeSpec.classBuilder(\"Taco\")\n+            .superclass(ClassName.get(\"com.squareup.wire\", \"Message\"))\n+            .addType(TypeSpec.classBuilder(\"Builder\")\n+                .superclass(ClassName.get(\"com.squareup.wire\", \"Message\", \"Builder\"))\n+                .build())\n+            .build())\n+        .build()\n+        .toString();\n+    assertThat(source).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import com.squareup.wire.Message;\\n\"\n+        + \"\\n\"\n+        + \"class Taco extends Message {\\n\"\n+        + \"  class Builder extends Message.Builder {\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n   @Test public void defaultPackage() throws Exception {\n     String source = JavaFile.builder(\"\",\n         TypeSpec.classBuilder(\"HelloWorld\")\n"
    },
    {
        "commit_hash": "4dbeee0ff7a9b6b7bd5f5bd3cf6390a9c3e7aa27",
        "previous_commit_hash": "4ee84e2372a8cfe60e991b4d2f948e6af05fd1da",
        "diff_stats": {
            "additions": 21,
            "deletions": 0
        },
        "diff_content": "@@ -755,6 +755,27 @@ public final class TypeSpecTest {\n     } catch (IllegalStateException expected) {}\n   }\n \n+  @Test\n+  public void interfaceStaticMethods() throws Exception {\n+    TypeSpec bar = TypeSpec.interfaceBuilder(\"Tacos\")\n+        .addMethod(MethodSpec.methodBuilder(\"test\")\n+            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n+            .returns(int.class)\n+            .addCode(CodeBlock.builder().addStatement(\"return 0\").build())\n+            .build())\n+        .build();\n+\n+    assertThat(toString(bar)).isEqualTo(\"\"\n+            + \"package com.squareup.tacos;\\n\"\n+            + \"\\n\"\n+            + \"interface Tacos {\\n\"\n+            + \"  static int test() {\\n\"\n+            + \"    return 0;\\n\"\n+            + \"  }\\n\"\n+            + \"}\\n\"\n+    );\n+  }\n+\n   @Test\n   public void interfaceDefaultMethods() throws Exception {\n     assumeTrue(isJava8());\n"
    },
    {
        "commit_hash": "00e7258edba952a9b981d9afedaa5ba6405fd0e4",
        "previous_commit_hash": "a81264c5a5fa8cd61206e4a1223474b0eee05ca8",
        "diff_stats": {
            "additions": 32,
            "deletions": 3
        },
        "diff_content": "@@ -72,10 +72,24 @@ import static com.squareup.javapoet.Util.checkNotNull;\n  * The underscore is appended to {@code sb} to avoid conflicting with the user-supplied {@code sb}\n  * property. Underscores are also prefixed for names that start with a digit, and used to replace\n  * name-unsafe characters like space or dash.\n+ *\n+ * <p>When dealing with multiple independent inner scopes, use a {@link #clone()} of the\n+ * NameAllocator used for the outer scope to further refine name allocation for a specific inner\n+ * scope.\n  */\n-public final class NameAllocator {\n-  private final Set<String> allocatedNames = new LinkedHashSet<>();\n-  private final Map<Object, String> tagToName = new LinkedHashMap<>();\n+public final class NameAllocator implements Cloneable {\n+  private final Set<String> allocatedNames;\n+  private final Map<Object, String> tagToName;\n+\n+  public NameAllocator() {\n+    this(new LinkedHashSet<String>(), new LinkedHashMap<Object, String>());\n+  }\n+\n+  private NameAllocator(LinkedHashSet<String> allocatedNames,\n+                        LinkedHashMap<Object, String> tagToName) {\n+    this.allocatedNames = allocatedNames;\n+    this.tagToName = tagToName;\n+  }\n \n   public String newName(String suggestion, Object tag) {\n     checkNotNull(suggestion, \"suggestion\");\n@@ -121,4 +135,19 @@ public final class NameAllocator {\n     }\n     return result;\n   }\n+\n+  /**\n+   * Create a deep copy of this NameAllocator. Useful to create multiple independent refinements\n+   * of a NameAllocator to be used in the respective definition of multiples, independently-scoped,\n+   * inner code blocks.\n+   *\n+   * @return A deep copy of this NameAllocator.\n+   */\n+  @Override\n+  public NameAllocator clone() {\n+    return new NameAllocator(\n+        new LinkedHashSet<>(this.allocatedNames),\n+        new LinkedHashMap<>(this.tagToName));\n+  }\n+\n }\n"
    },
    {
        "commit_hash": "00e7258edba952a9b981d9afedaa5ba6405fd0e4",
        "previous_commit_hash": "a81264c5a5fa8cd61206e4a1223474b0eee05ca8",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -85,4 +85,17 @@ public final class NameAllocatorTest {\n       assertThat(expected).hasMessage(\"unknown tag: 1\");\n     }\n   }\n+\n+  @Test public void cloneUsage() throws Exception {\n+    NameAllocator outterAllocator = new NameAllocator();\n+    outterAllocator.newName(\"foo\", 1);\n+\n+    NameAllocator innerAllocator1 = outterAllocator.clone();\n+    assertThat(innerAllocator1.newName(\"bar\", 2)).isEqualTo(\"bar\");\n+    assertThat(innerAllocator1.newName(\"foo\", 3)).isEqualTo(\"foo_\");\n+\n+    NameAllocator innerAllocator2 = outterAllocator.clone();\n+    assertThat(innerAllocator2.newName(\"foo\", 2)).isEqualTo(\"foo_\");\n+    assertThat(innerAllocator2.newName(\"bar\", 3)).isEqualTo(\"bar\");\n+  }\n }\n"
    },
    {
        "commit_hash": "5588188a021fafc82edb7c1d923136d8b958600f",
        "previous_commit_hash": "150b196373d967b308ffe26f9f4b6eb8ad05ef25",
        "diff_stats": {
            "additions": 53,
            "deletions": 0
        },
        "diff_content": "@@ -17,11 +17,17 @@ package com.squareup.javapoet;\n \n import java.io.IOException;\n import java.io.StringWriter;\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Method;\n import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n import java.util.Iterator;\n import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.Objects;\n \n import static com.squareup.javapoet.Util.checkNotNull;\n \n@@ -98,6 +104,53 @@ public final class AnnotationSpec {\n     codeWriter.emit(whitespace + \"}\");\n   }\n \n+  public static AnnotationSpec get(Annotation annotation) {\n+    return get(annotation, false);\n+  }\n+\n+  public static AnnotationSpec get(Annotation annotation, boolean includeDefaultValues) {\n+    Builder builder = builder(annotation.annotationType());\n+    try {\n+      Method[] methods = annotation.annotationType().getDeclaredMethods();\n+      Arrays.sort(methods, new Comparator<Method>() {\n+        @Override\n+        public int compare(Method m1, Method m2) {\n+          return m1.getName().compareTo(m2.getName());\n+        }\n+      });\n+      for (Method method : methods) {\n+        Object value = method.invoke(annotation);\n+        if (!includeDefaultValues) {\n+          if (Objects.deepEquals(value, method.getDefaultValue())) {\n+            continue;\n+          }\n+        }\n+        if (value.getClass().isArray()) {\n+          for (int i = 0; i < Array.getLength(value); i++) {\n+            addAnnotationValue(builder, method.getName(), Array.get(value, i));\n+          }\n+          continue;\n+        }\n+        if (value instanceof Annotation) {\n+          builder.addMember(method.getName(), \"$L\", get((Annotation) value));\n+          continue;\n+        }\n+        addAnnotationValue(builder, method.getName(), value);\n+      }\n+    } catch (Exception e) {\n+      throw new RuntimeException(\"Reflecting \" + annotation + \" failed!\", e);\n+    }\n+    return builder.build();\n+  }\n+\n+  private static Builder addAnnotationValue(Builder builder, String name, Object value) {\n+    if (value instanceof Class<?>) return builder.addMember(name, \"$T.class\", value);\n+    if (value instanceof Enum) return builder.addMember(name, \"$T.$L\", value.getClass(), value);\n+    if (value instanceof String) return builder.addMember(name, \"$S\", value);\n+    if (value instanceof Float) return builder.addMember(name, \"$Lf\", value);\n+    // return literal/toString anyway\n+    return builder.addMember(name, \"$L\", value);\n+  }\n   public static AnnotationSpec get(AnnotationMirror annotation) {\n     TypeElement element = (TypeElement) annotation.getAnnotationType().asElement();\n     AnnotationSpec.Builder builder = AnnotationSpec.builder(ClassName.get(element));\n"
    },
    {
        "commit_hash": "5588188a021fafc82edb7c1d923136d8b958600f",
        "previous_commit_hash": "150b196373d967b308ffe26f9f4b6eb8ad05ef25",
        "diff_stats": {
            "additions": 83,
            "deletions": 1
        },
        "diff_content": "@@ -42,7 +42,7 @@ public final class AnnotationSpecTest {\n     String value();\n   }\n \n-  enum Breakfast {\n+  public enum Breakfast {\n     WAFFLES, PANCAKES\n   }\n \n@@ -246,6 +246,88 @@ public final class AnnotationSpecTest {\n             + \")\");\n   }\n \n+  @Test public void reflectAnnotation() {\n+    HasDefaultsAnnotation annotation = IsAnnotated.class.getAnnotation(HasDefaultsAnnotation.class);\n+    AnnotationSpec spec = AnnotationSpec.get(annotation);\n+    TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n+        .addAnnotation(spec)\n+        .build();\n+    assertThat(toString(taco)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import com.squareup.javapoet.AnnotationSpecTest;\\n\"\n+        + \"import java.lang.Double;\\n\"\n+        + \"import java.lang.Float;\\n\"\n+        + \"import java.lang.Override;\\n\"\n+        + \"\\n\"\n+        + \"@AnnotationSpecTest.HasDefaultsAnnotation(\\n\"\n+        + \"    f = 11.1,\\n\"\n+        + \"    l = Override.class,\\n\"\n+        + \"    m = {\\n\"\n+        + \"        9,\\n\"\n+        + \"        8,\\n\"\n+        + \"        1\\n\"\n+        + \"    },\\n\"\n+        + \"    o = AnnotationSpecTest.Breakfast.PANCAKES,\\n\"\n+        + \"    p = 1701,\\n\"\n+        + \"    q = @AnnotationSpecTest.AnnotationC(\\\"bar\\\"),\\n\"\n+        + \"    r = {\\n\"\n+        + \"        Float.class,\\n\"\n+        + \"        Double.class\\n\"\n+        + \"    }\\n\"\n+        + \")\\n\"\n+        + \"class Taco {\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void reflectAnnotationWithDefaults() {\n+    HasDefaultsAnnotation annotation = IsAnnotated.class.getAnnotation(HasDefaultsAnnotation.class);\n+    AnnotationSpec spec = AnnotationSpec.get(annotation, true);\n+    TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n+        .addAnnotation(spec)\n+        .build();\n+    assertThat(toString(taco)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import com.squareup.javapoet.AnnotationSpecTest;\\n\"\n+        + \"import java.lang.Double;\\n\"\n+        + \"import java.lang.Float;\\n\"\n+        + \"import java.lang.Override;\\n\"\n+        + \"\\n\"\n+        + \"@AnnotationSpecTest.HasDefaultsAnnotation(\\n\"\n+        + \"    a = 5,\\n\"\n+        + \"    b = 6,\\n\"\n+        + \"    c = 7,\\n\"\n+        + \"    d = 8,\\n\"\n+        + \"    e = 9.0f,\\n\"\n+        + \"    f = 11.1,\\n\"\n+        + \"    g = k,\\n\"\n+        + \"    h = true,\\n\"\n+        + \"    i = AnnotationSpecTest.Breakfast.WAFFLES,\\n\"\n+        + \"    j = @AnnotationSpecTest.AnnotationA,\\n\"\n+        + \"    k = \\\"maple\\\",\\n\"\n+        + \"    l = Override.class,\\n\"\n+        + \"    m = {\\n\"\n+        + \"        9,\\n\"\n+        + \"        8,\\n\"\n+        + \"        1\\n\"\n+        + \"    },\\n\"\n+        + \"    n = {\\n\"\n+        + \"        AnnotationSpecTest.Breakfast.WAFFLES,\\n\"\n+        + \"        AnnotationSpecTest.Breakfast.PANCAKES\\n\"\n+        + \"    },\\n\"\n+        + \"    o = AnnotationSpecTest.Breakfast.PANCAKES,\\n\"\n+        + \"    p = 1701,\\n\"\n+        + \"    q = @AnnotationSpecTest.AnnotationC(\\\"bar\\\"),\\n\"\n+        + \"    r = {\\n\"\n+        + \"        Float.class,\\n\"\n+        + \"        Double.class\\n\"\n+        + \"    }\\n\"\n+        + \")\\n\"\n+        + \"class Taco {\\n\"\n+        + \"}\\n\");\n+  }\n+\n   private String toString(TypeSpec typeSpec) {\n     return JavaFile.builder(\"com.squareup.tacos\", typeSpec).build().toString();\n   }\n"
    },
    {
        "commit_hash": "4d235546d1e3aa6b32bf4279886fa3085327a384",
        "previous_commit_hash": "72c74144d8998138b1d69f9284191a7cf3de7c10",
        "diff_stats": {
            "additions": 3,
            "deletions": 1
        },
        "diff_content": "@@ -145,7 +145,9 @@ public final class AnnotationSpec {\n \n   private static Builder addAnnotationValue(Builder builder, String name, Object value) {\n     if (value instanceof Class<?>) return builder.addMember(name, \"$T.class\", value);\n-    if (value instanceof Enum) return builder.addMember(name, \"$T.$L\", value.getClass(), value);\n+    if (value instanceof Enum) {\n+      return builder.addMember(name, \"$T.$L\", value.getClass(), ((Enum<?>) value).name());\n+    }\n     if (value instanceof String) return builder.addMember(name, \"$S\", value);\n     if (value instanceof Float) return builder.addMember(name, \"$Lf\", value);\n     // return literal/toString anyway\n"
    },
    {
        "commit_hash": "4d235546d1e3aa6b32bf4279886fa3085327a384",
        "previous_commit_hash": "72c74144d8998138b1d69f9284191a7cf3de7c10",
        "diff_stats": {
            "additions": 6,
            "deletions": 5
        },
        "diff_content": "@@ -43,7 +43,8 @@ public final class AnnotationSpecTest {\n   }\n \n   public enum Breakfast {\n-    WAFFLES, PANCAKES\n+    WAFFLES, PANCAKES;\n+    public String toString() { return name() + \" with cherries!\"; };\n   }\n \n   @Retention(RetentionPolicy.RUNTIME)\n@@ -190,15 +191,15 @@ public final class AnnotationSpecTest {\n \n   @Test public void dynamicArrayOfEnumConstants() {\n     AnnotationSpec.Builder builder = AnnotationSpec.builder(HasDefaultsAnnotation.class);\n-    builder.addMember(\"n\", \"$T.$L\", Breakfast.class, Breakfast.PANCAKES);\n+    builder.addMember(\"n\", \"$T.$L\", Breakfast.class, Breakfast.PANCAKES.name());\n     assertThat(builder.build().toString()).isEqualTo(\n         \"@com.squareup.javapoet.AnnotationSpecTest.HasDefaultsAnnotation(\"\n             + \"n = com.squareup.javapoet.AnnotationSpecTest.Breakfast.PANCAKES\"\n             + \")\");\n \n     // builder = AnnotationSpec.builder(HasDefaultsAnnotation.class);\n-    builder.addMember(\"n\", \"$T.$L\", Breakfast.class, Breakfast.WAFFLES);\n-    builder.addMember(\"n\", \"$T.$L\", Breakfast.class, Breakfast.PANCAKES);\n+    builder.addMember(\"n\", \"$T.$L\", Breakfast.class, Breakfast.WAFFLES.name());\n+    builder.addMember(\"n\", \"$T.$L\", Breakfast.class, Breakfast.PANCAKES.name());\n     assertThat(builder.build().toString()).isEqualTo(\n         \"@com.squareup.javapoet.AnnotationSpecTest.HasDefaultsAnnotation(\"\n             + \"n = {\"\n@@ -216,7 +217,7 @@ public final class AnnotationSpecTest {\n             + \", com.squareup.javapoet.AnnotationSpecTest.Breakfast.PANCAKES\"\n             + \"})\");\n \n-    builder.addMember(\"n\", \"$T.$L\", Breakfast.class, Breakfast.WAFFLES);\n+    builder.addMember(\"n\", \"$T.$L\", Breakfast.class, Breakfast.WAFFLES.name());\n     assertThat(builder.build().toString()).isEqualTo(\n         \"@com.squareup.javapoet.AnnotationSpecTest.HasDefaultsAnnotation(\"\n             + \"n = {\"\n"
    },
    {
        "commit_hash": "9dd1e4cedf454c94b86f1705bdddcf0d166c9b15",
        "previous_commit_hash": "50e0cbbb8dbe392875dd15e418476cfaaeb908c0",
        "diff_stats": {
            "additions": 5,
            "deletions": 4
        },
        "diff_content": "@@ -183,13 +183,14 @@ public final class AnnotationSpec {\n   }\n \n   @Override public boolean equals(Object o) {\n-    return o instanceof AnnotationSpec\n-        && ((AnnotationSpec) o).type.equals(type)\n-        && ((AnnotationSpec) o).members.equals(members);\n+    if (this == o) return true;\n+    if (o == null) return false;\n+    if (getClass() != o.getClass()) return false;\n+    return toString().equals(o.toString());\n   }\n \n   @Override public int hashCode() {\n-    return type.hashCode() + 37 * members.hashCode();\n+    return toString().hashCode();\n   }\n \n   @Override public String toString() {\n"
    },
    {
        "commit_hash": "9dd1e4cedf454c94b86f1705bdddcf0d166c9b15",
        "previous_commit_hash": "50e0cbbb8dbe392875dd15e418476cfaaeb908c0",
        "diff_stats": {
            "additions": 11,
            "deletions": 0
        },
        "diff_content": "@@ -69,6 +69,17 @@ public final class CodeBlock {\n     return formatParts.isEmpty();\n   }\n \n+  @Override public boolean equals(Object o) {\n+    if (this == o) return true;\n+    if (o == null) return false;\n+    if (getClass() != o.getClass()) return false;\n+    return toString().equals(o.toString());\n+  }\n+\n+  @Override public int hashCode() {\n+    return toString().hashCode();\n+  }\n+\n   @Override public String toString() {\n     StringWriter out = new StringWriter();\n     try {\n"
    },
    {
        "commit_hash": "9dd1e4cedf454c94b86f1705bdddcf0d166c9b15",
        "previous_commit_hash": "50e0cbbb8dbe392875dd15e418476cfaaeb908c0",
        "diff_stats": {
            "additions": 6,
            "deletions": 2
        },
        "diff_content": "@@ -327,7 +327,7 @@ final class CodeWriter {\n \n     // Match the top-level class.\n     if (typeSpecStack.size() > 0 && Objects.equals(typeSpecStack.get(0).name, simpleName)) {\n-      return ClassName.get(packageName, simpleName);\n+      return ClassName.get(getPackageNameNullSafe(), simpleName);\n     }\n \n     // Match an imported type.\n@@ -340,13 +340,17 @@ final class CodeWriter {\n \n   /** Returns the class named {@code simpleName} when nested in the class at {@code stackDepth}. */\n   private ClassName stackClassName(int stackDepth, String simpleName) {\n-    ClassName className = ClassName.get(packageName, typeSpecStack.get(0).name);\n+    ClassName className = ClassName.get(getPackageNameNullSafe(), typeSpecStack.get(0).name);\n     for (int i = 1; i <= stackDepth; i++) {\n       className = className.nestedClass(typeSpecStack.get(i).name);\n     }\n     return className.nestedClass(simpleName);\n   }\n \n+  private String getPackageNameNullSafe() {\n+    return packageName == null ? \"\" : packageName;\n+  }\n+\n   /**\n    * Emits {@code s} with indentation as required. It's important that all code that writes to\n    * {@link #out} does it through here, since we emit indentation lazily in order to avoid\n"
    },
    {
        "commit_hash": "9dd1e4cedf454c94b86f1705bdddcf0d166c9b15",
        "previous_commit_hash": "50e0cbbb8dbe392875dd15e418476cfaaeb908c0",
        "diff_stats": {
            "additions": 11,
            "deletions": 0
        },
        "diff_content": "@@ -65,6 +65,17 @@ public final class FieldSpec {\n     codeWriter.emit(\";\\n\");\n   }\n \n+  @Override public boolean equals(Object o) {\n+    if (this == o) return true;\n+    if (o == null) return false;\n+    if (getClass() != o.getClass()) return false;\n+    return toString().equals(o.toString());\n+  }\n+\n+  @Override public int hashCode() {\n+    return toString().hashCode();\n+  }\n+\n   @Override public String toString() {\n     StringWriter out = new StringWriter();\n     try {\n"
    },
    {
        "commit_hash": "9dd1e4cedf454c94b86f1705bdddcf0d166c9b15",
        "previous_commit_hash": "50e0cbbb8dbe392875dd15e418476cfaaeb908c0",
        "diff_stats": {
            "additions": 11,
            "deletions": 0
        },
        "diff_content": "@@ -147,6 +147,17 @@ public final class JavaFile {\n     codeWriter.popPackage();\n   }\n \n+  @Override public boolean equals(Object o) {\n+    if (this == o) return true;\n+    if (o == null) return false;\n+    if (getClass() != o.getClass()) return false;\n+    return toString().equals(o.toString());\n+  }\n+\n+  @Override public int hashCode() {\n+    return toString().hashCode();\n+  }\n+\n   @Override public String toString() {\n     try {\n       StringBuilder result = new StringBuilder();\n"
    },
    {
        "commit_hash": "9dd1e4cedf454c94b86f1705bdddcf0d166c9b15",
        "previous_commit_hash": "50e0cbbb8dbe392875dd15e418476cfaaeb908c0",
        "diff_stats": {
            "additions": 11,
            "deletions": 0
        },
        "diff_content": "@@ -149,6 +149,17 @@ public final class MethodSpec {\n     return name.equals(CONSTRUCTOR);\n   }\n \n+  @Override public boolean equals(Object o) {\n+    if (this == o) return true;\n+    if (o == null) return false;\n+    if (getClass() != o.getClass()) return false;\n+    return toString().equals(o.toString());\n+  }\n+\n+  @Override public int hashCode() {\n+    return toString().hashCode();\n+  }\n+\n   @Override public String toString() {\n     StringWriter out = new StringWriter();\n     try {\n"
    },
    {
        "commit_hash": "9dd1e4cedf454c94b86f1705bdddcf0d166c9b15",
        "previous_commit_hash": "50e0cbbb8dbe392875dd15e418476cfaaeb908c0",
        "diff_stats": {
            "additions": 11,
            "deletions": 0
        },
        "diff_content": "@@ -56,6 +56,17 @@ public final class ParameterSpec {\n     }\n   }\n \n+  @Override public boolean equals(Object o) {\n+    if (this == o) return true;\n+    if (o == null) return false;\n+    if (getClass() != o.getClass()) return false;\n+    return toString().equals(o.toString());\n+  }\n+\n+  @Override public int hashCode() {\n+    return toString().hashCode();\n+  }\n+\n   @Override public String toString() {\n     StringWriter out = new StringWriter();\n     try {\n"
    },
    {
        "commit_hash": "9dd1e4cedf454c94b86f1705bdddcf0d166c9b15",
        "previous_commit_hash": "50e0cbbb8dbe392875dd15e418476cfaaeb908c0",
        "diff_stats": {
            "additions": 11,
            "deletions": 0
        },
        "diff_content": "@@ -139,6 +139,17 @@ public class TypeName {\n     throw new UnsupportedOperationException(\"cannot unbox \" + this);\n   }\n \n+  @Override public boolean equals(Object o) {\n+    if (this == o) return true;\n+    if (o == null) return false;\n+    if (getClass() != o.getClass()) return false;\n+    return toString().equals(o.toString());\n+  }\n+\n+  @Override public int hashCode() {\n+    return toString().hashCode();\n+  }\n+\n   @Override public final String toString() {\n     try {\n       StringBuilder result = new StringBuilder();\n"
    },
    {
        "commit_hash": "9dd1e4cedf454c94b86f1705bdddcf0d166c9b15",
        "previous_commit_hash": "50e0cbbb8dbe392875dd15e418476cfaaeb908c0",
        "diff_stats": {
            "additions": 11,
            "deletions": 0
        },
        "diff_content": "@@ -269,6 +269,17 @@ public final class TypeSpec {\n     }\n   }\n \n+  @Override public boolean equals(Object o) {\n+    if (this == o) return true;\n+    if (o == null) return false;\n+    if (getClass() != o.getClass()) return false;\n+    return toString().equals(o.toString());\n+  }\n+\n+  @Override public int hashCode() {\n+    return toString().hashCode();\n+  }\n+\n   @Override public String toString() {\n     StringWriter out = new StringWriter();\n     try {\n"
    },
    {
        "commit_hash": "9dd1e4cedf454c94b86f1705bdddcf0d166c9b15",
        "previous_commit_hash": "50e0cbbb8dbe392875dd15e418476cfaaeb908c0",
        "diff_stats": {
            "additions": 11,
            "deletions": 0
        },
        "diff_content": "@@ -103,6 +103,17 @@ public final class AnnotationSpecTest {\n \n   @Rule public final CompilationRule compilation = new CompilationRule();\n \n+  @Test public void equalsAndHashCode() {\n+    AnnotationSpec a = AnnotationSpec.builder(AnnotationC.class).build();\n+    AnnotationSpec b = AnnotationSpec.builder(AnnotationC.class).build();\n+    assertThat(a.equals(b)).isTrue();\n+    assertThat(a.hashCode()).isEqualTo(b.hashCode());\n+    a = AnnotationSpec.builder(AnnotationC.class).addMember(\"value\", \"$S\", \"123\").build();\n+    b = AnnotationSpec.builder(AnnotationC.class).addMember(\"value\", \"$S\", \"123\").build();\n+    assertThat(a.equals(b)).isTrue();\n+    assertThat(a.hashCode()).isEqualTo(b.hashCode());\n+  }\n+\n   @Test public void defaultAnnotation() {\n     String name = IsAnnotated.class.getCanonicalName();\n     TypeElement element = compilation.getElements().getTypeElement(name);\n"
    },
    {
        "commit_hash": "9dd1e4cedf454c94b86f1705bdddcf0d166c9b15",
        "previous_commit_hash": "50e0cbbb8dbe392875dd15e418476cfaaeb908c0",
        "diff_stats": {
            "additions": 11,
            "deletions": 0
        },
        "diff_content": "@@ -21,6 +21,17 @@ import static com.google.common.truth.Truth.assertThat;\n import static org.junit.Assert.fail;\n \n public final class CodeBlockTest {\n+  @Test public void equalsAndHashCode() {\n+    CodeBlock a = CodeBlock.builder().build();\n+    CodeBlock b = CodeBlock.builder().build();\n+    assertThat(a.equals(b)).isTrue();\n+    assertThat(a.hashCode()).isEqualTo(b.hashCode());\n+    a = CodeBlock.builder().add(\"$L\", \"taco\").build();\n+    b = CodeBlock.builder().add(\"$L\", \"taco\").build();\n+    assertThat(a.equals(b)).isTrue();\n+    assertThat(a.hashCode()).isEqualTo(b.hashCode());\n+  }\n+\n   @Test public void indentCannotBeIndexed() {\n     try {\n       CodeBlock.builder().add(\"$1>\", \"taco\").build();\n"
    },
    {
        "commit_hash": "9dd1e4cedf454c94b86f1705bdddcf0d166c9b15",
        "previous_commit_hash": "50e0cbbb8dbe392875dd15e418476cfaaeb908c0",
        "diff_stats": {
            "additions": 13,
            "deletions": 2
        },
        "diff_content": "@@ -20,10 +20,21 @@ import org.junit.Test;\n import static com.google.common.truth.Truth.assertThat;\n import static org.junit.Assert.fail;\n \n+import javax.lang.model.element.Modifier;\n+\n public class FieldSpecTest {\n+  @Test public void equalsAndHashCode() {\n+    FieldSpec a = FieldSpec.builder(int.class, \"foo\").build();\n+    FieldSpec b = FieldSpec.builder(int.class, \"foo\").build();\n+    assertThat(a.equals(b)).isTrue();\n+    assertThat(a.hashCode()).isEqualTo(b.hashCode());\n+    a = FieldSpec.builder(int.class, \"FOO\", Modifier.PUBLIC, Modifier.STATIC).build();\n+    b = FieldSpec.builder(int.class, \"FOO\", Modifier.PUBLIC, Modifier.STATIC).build();\n+    assertThat(a.equals(b)).isTrue();\n+    assertThat(a.hashCode()).isEqualTo(b.hashCode());\n+  }\n \n-  @Test\n-  public void nullAnnotationsAddition() {\n+  @Test public void nullAnnotationsAddition() {\n     try {\n       FieldSpec.builder(int.class, \"foo\").addAnnotations(null);\n       fail();\n"
    },
    {
        "commit_hash": "9dd1e4cedf454c94b86f1705bdddcf0d166c9b15",
        "previous_commit_hash": "50e0cbbb8dbe392875dd15e418476cfaaeb908c0",
        "diff_stats": {
            "additions": 18,
            "deletions": 0
        },
        "diff_content": "@@ -188,4 +188,22 @@ public final class MethodSpecTest {\n       assertThat(expected).hasMessage(\"cannot override method with modifiers: [static]\");\n     }\n   }\n+\n+  @Test public void equalsAndHashCode() {\n+    MethodSpec a = MethodSpec.constructorBuilder().build();\n+    MethodSpec b = MethodSpec.constructorBuilder().build();\n+    assertThat(a.equals(b)).isTrue();\n+    assertThat(a.hashCode()).isEqualTo(b.hashCode());\n+    a = MethodSpec.methodBuilder(\"taco\").build();\n+    b = MethodSpec.methodBuilder(\"taco\").build();\n+    assertThat(a.equals(b)).isTrue();\n+    assertThat(a.hashCode()).isEqualTo(b.hashCode());\n+    TypeElement classElement = getElement(Everything.class);\n+    ExecutableElement methodElement = getOnlyElement(methodsIn(classElement.getEnclosedElements()));\n+    a = MethodSpec.overriding(methodElement).build();\n+    b = MethodSpec.overriding(methodElement).build();\n+    assertThat(a.equals(b)).isTrue();\n+    assertThat(a.hashCode()).isEqualTo(b.hashCode());\n+  }\n+\n }\n"
    },
    {
        "commit_hash": "9dd1e4cedf454c94b86f1705bdddcf0d166c9b15",
        "previous_commit_hash": "50e0cbbb8dbe392875dd15e418476cfaaeb908c0",
        "diff_stats": {
            "additions": 13,
            "deletions": 2
        },
        "diff_content": "@@ -20,10 +20,21 @@ import org.junit.Test;\n import static com.google.common.truth.Truth.assertThat;\n import static org.junit.Assert.fail;\n \n+import javax.lang.model.element.Modifier;\n+\n public class ParameterSpecTest {\n+  @Test public void equalsAndHashCode() {\n+    ParameterSpec a = ParameterSpec.builder(int.class, \"foo\").build();\n+    ParameterSpec b = ParameterSpec.builder(int.class, \"foo\").build();\n+    assertThat(a.equals(b)).isTrue();\n+    assertThat(a.hashCode()).isEqualTo(b.hashCode());\n+    a = ParameterSpec.builder(int.class, \"i\").addModifiers(Modifier.STATIC).build();\n+    b = ParameterSpec.builder(int.class, \"i\").addModifiers(Modifier.STATIC).build();\n+    assertThat(a.equals(b)).isTrue();\n+    assertThat(a.hashCode()).isEqualTo(b.hashCode());\n+  }\n \n-  @Test\n-  public void nullAnnotationsAddition() {\n+  @Test public void nullAnnotationsAddition() {\n     try {\n       ParameterSpec.builder(int.class, \"foo\").addAnnotations(null);\n       fail();\n"
    },
    {
        "commit_hash": "9dd1e4cedf454c94b86f1705bdddcf0d166c9b15",
        "previous_commit_hash": "50e0cbbb8dbe392875dd15e418476cfaaeb908c0",
        "diff_stats": {
            "additions": 78,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright (C) 2015 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javapoet;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import java.io.Serializable;\n+import java.rmi.server.UID;\n+import java.util.Comparator;\n+import java.util.Set;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class TypeNameTest {\n+\n+  @Test public void equalsAndHashCodePrimitive() {\n+    test(TypeName.BOOLEAN, TypeName.BOOLEAN);\n+    test(TypeName.BYTE, TypeName.BYTE);\n+    test(TypeName.CHAR, TypeName.CHAR);\n+    test(TypeName.DOUBLE, TypeName.DOUBLE);\n+    test(TypeName.FLOAT, TypeName.FLOAT);\n+    test(TypeName.INT, TypeName.INT);\n+    test(TypeName.LONG, TypeName.LONG);\n+    test(TypeName.SHORT, TypeName.SHORT);\n+    test(TypeName.VOID, TypeName.VOID);\n+  }\n+\n+  @Test public void equalsAndHashCodeArrayTypeName() {\n+    test(ArrayTypeName.of(Object.class), ArrayTypeName.of(Object.class));\n+    test(TypeName.get(Object[].class), ArrayTypeName.of(Object.class));\n+    // ? check(ClassName.bestGuess(\"java.lang.Object[]\"), ArrayTypeName.of(Object.class));\n+  }\n+\n+  @Test public void equalsAndHashCodeClassName() {\n+    test(ClassName.get(Object.class), ClassName.get(Object.class));\n+    test(TypeName.get(Object.class), ClassName.get(Object.class));\n+    test(ClassName.bestGuess(\"java.lang.Object\"), ClassName.get(Object.class));\n+  }\n+  \n+  @Test public void equalsAndHashCodeParameterizedTypeName() {\n+    test(ParameterizedTypeName.get(Object.class), ParameterizedTypeName.get(Object.class));\n+    test(ParameterizedTypeName.get(Set.class, UID.class), ParameterizedTypeName.get(Set.class, UID.class));\n+  }\n+  \n+  @Test public void equalsAndHashCodeTypeVariableName() {\n+    test(TypeVariableName.get(Object.class), TypeVariableName.get(Object.class));\n+    TypeVariableName typeVariable1 = TypeVariableName.get(\"T\", Comparator.class, Serializable.class);\n+    TypeVariableName typeVariable2 = TypeVariableName.get(\"T\", Comparator.class, Serializable.class);\n+    test(typeVariable1, typeVariable2);\n+  }\n+\n+  @Test public void equalsAndHashCodeWildcardTypeName() {\n+    test(WildcardTypeName.subtypeOf(Object.class), WildcardTypeName.subtypeOf(Object.class));\n+    test(WildcardTypeName.subtypeOf(Serializable.class), WildcardTypeName.subtypeOf(Serializable.class));\n+    test(WildcardTypeName.supertypeOf(String.class), WildcardTypeName.supertypeOf(String.class));\n+  }\n+\n+  private void test(TypeName a, TypeName b) {\n+    Assert.assertEquals(a.toString(), b.toString());\n+    assertThat(a.equals(b)).isTrue();\n+    assertThat(a.hashCode()).isEqualTo(b.hashCode());\n+  }\n+\n+}\n"
    },
    {
        "commit_hash": "9dd1e4cedf454c94b86f1705bdddcf0d166c9b15",
        "previous_commit_hash": "50e0cbbb8dbe392875dd15e418476cfaaeb908c0",
        "diff_stats": {
            "additions": 21,
            "deletions": 0
        },
        "diff_content": "@@ -36,6 +36,7 @@ import javax.lang.model.element.Modifier;\n import javax.lang.model.element.TypeElement;\n import javax.lang.model.type.TypeMirror;\n \n+import org.junit.Assert;\n import org.junit.Rule;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n@@ -82,6 +83,7 @@ public final class TypeSpecTest {\n         + \"    return \\\"taco\\\";\\n\"\n         + \"  }\\n\"\n         + \"}\\n\");\n+    Assert.assertEquals(472949424, taco.hashCode()); // update expected number if source changes\n   }\n \n   @Test public void interestingTypes() throws Exception {\n@@ -1965,6 +1967,25 @@ public final class TypeSpecTest {\n             + \"}\\n\");\n   }\n \n+  @Test public void equalsAndHashCode() {\n+    TypeSpec a = TypeSpec.interfaceBuilder(\"taco\").build();\n+    TypeSpec b = TypeSpec.interfaceBuilder(\"taco\").build();\n+    assertThat(a.equals(b)).isTrue();\n+    assertThat(a.hashCode()).isEqualTo(b.hashCode());\n+    a = TypeSpec.classBuilder(\"taco\").build();\n+    b = TypeSpec.classBuilder(\"taco\").build();\n+    assertThat(a.equals(b)).isTrue();\n+    assertThat(a.hashCode()).isEqualTo(b.hashCode());\n+    a = TypeSpec.enumBuilder(\"taco\").addEnumConstant(\"SALSA\").build();\n+    b = TypeSpec.enumBuilder(\"taco\").addEnumConstant(\"SALSA\").build();\n+    assertThat(a.equals(b)).isTrue();\n+    assertThat(a.hashCode()).isEqualTo(b.hashCode());\n+    a = TypeSpec.annotationBuilder(\"taco\").build();\n+    b = TypeSpec.annotationBuilder(\"taco\").build();\n+    assertThat(a.equals(b)).isTrue();\n+    assertThat(a.hashCode()).isEqualTo(b.hashCode());\n+  }\n+\n   private CodeBlock codeBlock(String format, Object... args) {\n     return CodeBlock.builder()\n         .add(format, args)\n"
    },
    {
        "commit_hash": "55f8bb81be356843c17c41b5645fa7ae8a7a0f4c",
        "previous_commit_hash": "44c278882ca7b314c54e6db15bf48f4188d925f9",
        "diff_stats": {
            "additions": 9,
            "deletions": 10
        },
        "diff_content": "@@ -39,13 +39,16 @@ import static com.squareup.javapoet.Util.join;\n  * honors imports, indentation, and deferred variable names.\n  */\n final class CodeWriter {\n+  /** Sentinel value that indicates that no user-provided package has been set. */\n+  private static final String NO_PACKAGE = new String();\n+\n   private final String indent;\n   private final Appendable out;\n   private int indentLevel;\n \n   private boolean javadoc = false;\n   private boolean comment = false;\n-  private String packageName;\n+  private String packageName = NO_PACKAGE;\n   private final List<TypeSpec> typeSpecStack = new ArrayList<>();\n   private final Map<String, ClassName> importedTypes;\n   private final Map<String, ClassName> importableTypes = new LinkedHashMap<>();\n@@ -97,14 +100,14 @@ final class CodeWriter {\n   }\n \n   public CodeWriter pushPackage(String packageName) {\n-    checkState(this.packageName == null, \"package already set: %s\", this.packageName);\n+    checkState(this.packageName == NO_PACKAGE, \"package already set: %s\", this.packageName);\n     this.packageName = checkNotNull(packageName, \"packageName == null\");\n     return this;\n   }\n \n   public CodeWriter popPackage() {\n-    checkState(this.packageName != null, \"package already set: %s\", this.packageName);\n-    this.packageName = null;\n+    checkState(this.packageName != NO_PACKAGE, \"package already set: %s\", this.packageName);\n+    this.packageName = NO_PACKAGE;\n     return this;\n   }\n \n@@ -327,7 +330,7 @@ final class CodeWriter {\n \n     // Match the top-level class.\n     if (typeSpecStack.size() > 0 && Objects.equals(typeSpecStack.get(0).name, simpleName)) {\n-      return ClassName.get(getPackageNameNullSafe(), simpleName);\n+      return ClassName.get(packageName, simpleName);\n     }\n \n     // Match an imported type.\n@@ -340,17 +343,13 @@ final class CodeWriter {\n \n   /** Returns the class named {@code simpleName} when nested in the class at {@code stackDepth}. */\n   private ClassName stackClassName(int stackDepth, String simpleName) {\n-    ClassName className = ClassName.get(getPackageNameNullSafe(), typeSpecStack.get(0).name);\n+    ClassName className = ClassName.get(packageName, typeSpecStack.get(0).name);\n     for (int i = 1; i <= stackDepth; i++) {\n       className = className.nestedClass(typeSpecStack.get(i).name);\n     }\n     return className.nestedClass(simpleName);\n   }\n \n-  private String getPackageNameNullSafe() {\n-    return packageName == null ? \"\" : packageName;\n-  }\n-\n   /**\n    * Emits {@code s} with indentation as required. It's important that all code that writes to\n    * {@link #out} does it through here, since we emit indentation lazily in order to avoid\n"
    },
    {
        "commit_hash": "a6716680d0328420b62ed4bd8ad2949b7f051fb9",
        "previous_commit_hash": "c8b9d019a3ac8d676e38c6fb43a1ca7b4f74341e",
        "diff_stats": {
            "additions": 57,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright (C) 2015 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javapoet;\n+\n+import java.io.IOException;\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+public final class AnnotatedTypeName extends TypeName {\n+\n+  public static AnnotatedTypeName get(TypeName type, AnnotationSpec... annotations) {\n+    return new AnnotatedTypeName(type, Arrays.asList(annotations));\n+  }\n+\n+  public static AnnotatedTypeName get(Type type, Annotation... annotations) {\n+    List<AnnotationSpec> specs = new ArrayList<>();\n+    for (int i = 0; i < annotations.length; i++) {\n+      specs.add(AnnotationSpec.get(annotations[i]));\n+    }\n+    return new AnnotatedTypeName(TypeName.get(type), specs);\n+  }\n+\n+  public final TypeName type;\n+  public final List<AnnotationSpec> annotations;\n+\n+  AnnotatedTypeName(TypeName type, List<AnnotationSpec> annotations) {\n+    this.type = type;\n+    this.annotations = Util.immutableList(annotations);\n+  }\n+\n+  @Override CodeWriter emit(CodeWriter out) throws IOException {\n+    if (!annotations.isEmpty()) {\n+      for (AnnotationSpec annotation : annotations) {\n+        annotation.emit(out, true);\n+        out.emit(\" \");\n+      }\n+    }\n+    return type.emit(out);\n+  }\n+\n+}\n"
    },
    {
        "commit_hash": "a6716680d0328420b62ed4bd8ad2949b7f051fb9",
        "previous_commit_hash": "c8b9d019a3ac8d676e38c6fb43a1ca7b4f74341e",
        "diff_stats": {
            "additions": 10,
            "deletions": 0
        },
        "diff_content": "@@ -22,6 +22,7 @@ import java.lang.reflect.Type;\n import java.lang.reflect.TypeVariable;\n import java.lang.reflect.WildcardType;\n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n@@ -97,6 +98,15 @@ public class TypeName {\n     this(null);\n   }\n \n+  public AnnotatedTypeName annotated(AnnotationSpec... annotations) {\n+    return new AnnotatedTypeName(this, Arrays.asList(annotations));\n+  }\n+\n+  public ParameterizedTypeName parameterized(TypeName... parameters) {\n+    Util.checkState(this instanceof ClassName, \"expected to be a ClassName, but am \" + this);\n+    return new ParameterizedTypeName((ClassName) this, Arrays.asList(parameters));\n+  }\n+\n   public boolean isPrimitive() {\n     return keyword != null && this != VOID;\n   }\n"
    },
    {
        "commit_hash": "a6716680d0328420b62ed4bd8ad2949b7f051fb9",
        "previous_commit_hash": "c8b9d019a3ac8d676e38c6fb43a1ca7b4f74341e",
        "diff_stats": {
            "additions": 64,
            "deletions": 30
        },
        "diff_content": "@@ -16,63 +16,97 @@\n package com.squareup.javapoet;\n \n import static com.google.common.truth.Truth.assertThat;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotEquals;\n \n import java.io.Serializable;\n+import java.lang.annotation.Documented;\n import java.rmi.server.UID;\n import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n import java.util.Set;\n-\n-import org.junit.Assert;\n import org.junit.Test;\n+import com.squareup.javapoet.AnnotationSpecTest.AnnotationA;\n+import com.squareup.javapoet.AnnotationSpecTest.AnnotationB;\n \n public class TypeNameTest {\n \n   @Test public void equalsAndHashCodePrimitive() {\n-    test(TypeName.BOOLEAN, TypeName.BOOLEAN);\n-    test(TypeName.BYTE, TypeName.BYTE);\n-    test(TypeName.CHAR, TypeName.CHAR);\n-    test(TypeName.DOUBLE, TypeName.DOUBLE);\n-    test(TypeName.FLOAT, TypeName.FLOAT);\n-    test(TypeName.INT, TypeName.INT);\n-    test(TypeName.LONG, TypeName.LONG);\n-    test(TypeName.SHORT, TypeName.SHORT);\n-    test(TypeName.VOID, TypeName.VOID);\n+    assertEqualsHashCodeAndToString(TypeName.BOOLEAN, TypeName.BOOLEAN);\n+    assertEqualsHashCodeAndToString(TypeName.BYTE, TypeName.BYTE);\n+    assertEqualsHashCodeAndToString(TypeName.CHAR, TypeName.CHAR);\n+    assertEqualsHashCodeAndToString(TypeName.DOUBLE, TypeName.DOUBLE);\n+    assertEqualsHashCodeAndToString(TypeName.FLOAT, TypeName.FLOAT);\n+    assertEqualsHashCodeAndToString(TypeName.INT, TypeName.INT);\n+    assertEqualsHashCodeAndToString(TypeName.LONG, TypeName.LONG);\n+    assertEqualsHashCodeAndToString(TypeName.SHORT, TypeName.SHORT);\n+    assertEqualsHashCodeAndToString(TypeName.VOID, TypeName.VOID);\n   }\n \n   @Test public void equalsAndHashCodeArrayTypeName() {\n-    test(ArrayTypeName.of(Object.class), ArrayTypeName.of(Object.class));\n-    test(TypeName.get(Object[].class), ArrayTypeName.of(Object.class));\n-    // ? check(ClassName.bestGuess(\"java.lang.Object[]\"), ArrayTypeName.of(Object.class));\n+    assertEqualsHashCodeAndToString(ArrayTypeName.of(Object.class),\n+        ArrayTypeName.of(Object.class));\n+    assertEqualsHashCodeAndToString(TypeName.get(Object[].class),\n+        ArrayTypeName.of(Object.class));\n   }\n \n   @Test public void equalsAndHashCodeClassName() {\n-    test(ClassName.get(Object.class), ClassName.get(Object.class));\n-    test(TypeName.get(Object.class), ClassName.get(Object.class));\n-    test(ClassName.bestGuess(\"java.lang.Object\"), ClassName.get(Object.class));\n+    assertEqualsHashCodeAndToString(ClassName.get(Object.class), ClassName.get(Object.class));\n+    assertEqualsHashCodeAndToString(TypeName.get(Object.class), ClassName.get(Object.class));\n+    assertEqualsHashCodeAndToString(ClassName.bestGuess(\"java.lang.Object\"),\n+        ClassName.get(Object.class));\n   }\n-  \n+\n   @Test public void equalsAndHashCodeParameterizedTypeName() {\n-    test(ParameterizedTypeName.get(Object.class), ParameterizedTypeName.get(Object.class));\n-    test(ParameterizedTypeName.get(Set.class, UID.class), ParameterizedTypeName.get(Set.class, UID.class));\n+    assertEqualsHashCodeAndToString(ParameterizedTypeName.get(Object.class),\n+        ParameterizedTypeName.get(Object.class));\n+    assertEqualsHashCodeAndToString(ParameterizedTypeName.get(Set.class, UID.class),\n+        ParameterizedTypeName.get(Set.class, UID.class));\n+    assertNotEquals(ClassName.get(List.class), ParameterizedTypeName.get(List.class,\n+        String.class));\n   }\n-  \n+\n   @Test public void equalsAndHashCodeTypeVariableName() {\n-    test(TypeVariableName.get(Object.class), TypeVariableName.get(Object.class));\n-    TypeVariableName typeVariable1 = TypeVariableName.get(\"T\", Comparator.class, Serializable.class);\n-    TypeVariableName typeVariable2 = TypeVariableName.get(\"T\", Comparator.class, Serializable.class);\n-    test(typeVariable1, typeVariable2);\n+    assertEqualsHashCodeAndToString(TypeVariableName.get(Object.class),\n+        TypeVariableName.get(Object.class));\n+    TypeVariableName typeVar1 = TypeVariableName.get(\"T\", Comparator.class, Serializable.class);\n+    TypeVariableName typeVar2 = TypeVariableName.get(\"T\", Comparator.class, Serializable.class);\n+    assertEqualsHashCodeAndToString(typeVar1, typeVar2);\n   }\n \n   @Test public void equalsAndHashCodeWildcardTypeName() {\n-    test(WildcardTypeName.subtypeOf(Object.class), WildcardTypeName.subtypeOf(Object.class));\n-    test(WildcardTypeName.subtypeOf(Serializable.class), WildcardTypeName.subtypeOf(Serializable.class));\n-    test(WildcardTypeName.supertypeOf(String.class), WildcardTypeName.supertypeOf(String.class));\n+    assertEqualsHashCodeAndToString(WildcardTypeName.subtypeOf(Object.class),\n+        WildcardTypeName.subtypeOf(Object.class));\n+    assertEqualsHashCodeAndToString(WildcardTypeName.subtypeOf(Serializable.class),\n+        WildcardTypeName.subtypeOf(Serializable.class));\n+    assertEqualsHashCodeAndToString(WildcardTypeName.supertypeOf(String.class),\n+        WildcardTypeName.supertypeOf(String.class));\n   }\n \n-  private void test(TypeName a, TypeName b) {\n-    Assert.assertEquals(a.toString(), b.toString());\n+  @Test public void equalsAndHashCodeAnnotatedTypeName() {\n+    assertEqualsHashCodeAndToString(TypeName.BYTE.annotated(list()),\n+        TypeName.BYTE.annotated(list()));\n+    assertEqualsHashCodeAndToString(TypeName.INT.annotated(list(Override.class)),\n+        TypeName.INT.annotated(list(Override.class)));\n+    assertEqualsHashCodeAndToString(\n+        ClassName.get(Map.class).annotated(list(AnnotationA.class, AnnotationB.class)),\n+        ClassName.get(Map.class).annotated(list(AnnotationA.class, AnnotationB.class)));\n+    assertNotEquals(TypeName.CHAR, TypeName.CHAR.annotated(list(Documented.class)));\n+  }\n+\n+  private void assertEqualsHashCodeAndToString(TypeName a, TypeName b) {\n+    assertEquals(a.toString(), b.toString());\n     assertThat(a.equals(b)).isTrue();\n     assertThat(a.hashCode()).isEqualTo(b.hashCode());\n   }\n \n+  private AnnotationSpec[] list(Class<?>... types) {\n+    AnnotationSpec[] annotations = new AnnotationSpec[types.length];\n+    for (int i = 0; i < types.length; i++) {\n+      annotations[i] = AnnotationSpec.builder(types[i]).build();\n+    }\n+    return annotations;\n+  }\n+\n }\n"
    },
    {
        "commit_hash": "43db56716e85504cdcb8c0f3652b53c2fef3c506",
        "previous_commit_hash": "852b1bb78224e2fd3a183b6175e388044d775ae1",
        "diff_stats": {
            "additions": 0,
            "deletions": 57
        },
        "diff_content": "@@ -1,57 +0,0 @@\n-/*\n- * Copyright (C) 2015 Square, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.squareup.javapoet;\n-\n-import java.io.IOException;\n-import java.lang.annotation.Annotation;\n-import java.lang.reflect.Type;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-\n-public final class AnnotatedTypeName extends TypeName {\n-\n-  public static AnnotatedTypeName get(TypeName type, AnnotationSpec... annotations) {\n-    return new AnnotatedTypeName(type, Arrays.asList(annotations));\n-  }\n-\n-  public static AnnotatedTypeName get(Type type, Annotation... annotations) {\n-    List<AnnotationSpec> specs = new ArrayList<>();\n-    for (int i = 0; i < annotations.length; i++) {\n-      specs.add(AnnotationSpec.get(annotations[i]));\n-    }\n-    return new AnnotatedTypeName(TypeName.get(type), specs);\n-  }\n-\n-  public final TypeName type;\n-  public final List<AnnotationSpec> annotations;\n-\n-  AnnotatedTypeName(TypeName type, List<AnnotationSpec> annotations) {\n-    this.type = type;\n-    this.annotations = Util.immutableList(annotations);\n-  }\n-\n-  @Override CodeWriter emit(CodeWriter out) throws IOException {\n-    if (!annotations.isEmpty()) {\n-      for (AnnotationSpec annotation : annotations) {\n-        annotation.emit(out, true);\n-        out.emit(\" \");\n-      }\n-    }\n-    return type.emit(out);\n-  }\n-\n-}\n"
    },
    {
        "commit_hash": "43db56716e85504cdcb8c0f3652b53c2fef3c506",
        "previous_commit_hash": "852b1bb78224e2fd3a183b6175e388044d775ae1",
        "diff_stats": {
            "additions": 0,
            "deletions": 10
        },
        "diff_content": "@@ -22,7 +22,6 @@ import java.lang.reflect.Type;\n import java.lang.reflect.TypeVariable;\n import java.lang.reflect.WildcardType;\n import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n@@ -98,15 +97,6 @@ public class TypeName {\n     this(null);\n   }\n \n-  public AnnotatedTypeName annotated(AnnotationSpec... annotations) {\n-    return new AnnotatedTypeName(this, Arrays.asList(annotations));\n-  }\n-\n-  public ParameterizedTypeName parameterized(TypeName... parameters) {\n-    Util.checkState(this instanceof ClassName, \"expected to be a ClassName, but am \" + this);\n-    return new ParameterizedTypeName((ClassName) this, Arrays.asList(parameters));\n-  }\n-\n   public boolean isPrimitive() {\n     return keyword != null && this != VOID;\n   }\n"
    },
    {
        "commit_hash": "43db56716e85504cdcb8c0f3652b53c2fef3c506",
        "previous_commit_hash": "852b1bb78224e2fd3a183b6175e388044d775ae1",
        "diff_stats": {
            "additions": 30,
            "deletions": 64
        },
        "diff_content": "@@ -16,97 +16,63 @@\n package com.squareup.javapoet;\n \n import static com.google.common.truth.Truth.assertThat;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNotEquals;\n \n import java.io.Serializable;\n-import java.lang.annotation.Documented;\n import java.rmi.server.UID;\n import java.util.Comparator;\n-import java.util.List;\n-import java.util.Map;\n import java.util.Set;\n+\n+import org.junit.Assert;\n import org.junit.Test;\n-import com.squareup.javapoet.AnnotationSpecTest.AnnotationA;\n-import com.squareup.javapoet.AnnotationSpecTest.AnnotationB;\n \n public class TypeNameTest {\n \n   @Test public void equalsAndHashCodePrimitive() {\n-    assertEqualsHashCodeAndToString(TypeName.BOOLEAN, TypeName.BOOLEAN);\n-    assertEqualsHashCodeAndToString(TypeName.BYTE, TypeName.BYTE);\n-    assertEqualsHashCodeAndToString(TypeName.CHAR, TypeName.CHAR);\n-    assertEqualsHashCodeAndToString(TypeName.DOUBLE, TypeName.DOUBLE);\n-    assertEqualsHashCodeAndToString(TypeName.FLOAT, TypeName.FLOAT);\n-    assertEqualsHashCodeAndToString(TypeName.INT, TypeName.INT);\n-    assertEqualsHashCodeAndToString(TypeName.LONG, TypeName.LONG);\n-    assertEqualsHashCodeAndToString(TypeName.SHORT, TypeName.SHORT);\n-    assertEqualsHashCodeAndToString(TypeName.VOID, TypeName.VOID);\n+    test(TypeName.BOOLEAN, TypeName.BOOLEAN);\n+    test(TypeName.BYTE, TypeName.BYTE);\n+    test(TypeName.CHAR, TypeName.CHAR);\n+    test(TypeName.DOUBLE, TypeName.DOUBLE);\n+    test(TypeName.FLOAT, TypeName.FLOAT);\n+    test(TypeName.INT, TypeName.INT);\n+    test(TypeName.LONG, TypeName.LONG);\n+    test(TypeName.SHORT, TypeName.SHORT);\n+    test(TypeName.VOID, TypeName.VOID);\n   }\n \n   @Test public void equalsAndHashCodeArrayTypeName() {\n-    assertEqualsHashCodeAndToString(ArrayTypeName.of(Object.class),\n-        ArrayTypeName.of(Object.class));\n-    assertEqualsHashCodeAndToString(TypeName.get(Object[].class),\n-        ArrayTypeName.of(Object.class));\n+    test(ArrayTypeName.of(Object.class), ArrayTypeName.of(Object.class));\n+    test(TypeName.get(Object[].class), ArrayTypeName.of(Object.class));\n+    // ? check(ClassName.bestGuess(\"java.lang.Object[]\"), ArrayTypeName.of(Object.class));\n   }\n \n   @Test public void equalsAndHashCodeClassName() {\n-    assertEqualsHashCodeAndToString(ClassName.get(Object.class), ClassName.get(Object.class));\n-    assertEqualsHashCodeAndToString(TypeName.get(Object.class), ClassName.get(Object.class));\n-    assertEqualsHashCodeAndToString(ClassName.bestGuess(\"java.lang.Object\"),\n-        ClassName.get(Object.class));\n+    test(ClassName.get(Object.class), ClassName.get(Object.class));\n+    test(TypeName.get(Object.class), ClassName.get(Object.class));\n+    test(ClassName.bestGuess(\"java.lang.Object\"), ClassName.get(Object.class));\n   }\n-\n+  \n   @Test public void equalsAndHashCodeParameterizedTypeName() {\n-    assertEqualsHashCodeAndToString(ParameterizedTypeName.get(Object.class),\n-        ParameterizedTypeName.get(Object.class));\n-    assertEqualsHashCodeAndToString(ParameterizedTypeName.get(Set.class, UID.class),\n-        ParameterizedTypeName.get(Set.class, UID.class));\n-    assertNotEquals(ClassName.get(List.class), ParameterizedTypeName.get(List.class,\n-        String.class));\n+    test(ParameterizedTypeName.get(Object.class), ParameterizedTypeName.get(Object.class));\n+    test(ParameterizedTypeName.get(Set.class, UID.class), ParameterizedTypeName.get(Set.class, UID.class));\n   }\n-\n+  \n   @Test public void equalsAndHashCodeTypeVariableName() {\n-    assertEqualsHashCodeAndToString(TypeVariableName.get(Object.class),\n-        TypeVariableName.get(Object.class));\n-    TypeVariableName typeVar1 = TypeVariableName.get(\"T\", Comparator.class, Serializable.class);\n-    TypeVariableName typeVar2 = TypeVariableName.get(\"T\", Comparator.class, Serializable.class);\n-    assertEqualsHashCodeAndToString(typeVar1, typeVar2);\n+    test(TypeVariableName.get(Object.class), TypeVariableName.get(Object.class));\n+    TypeVariableName typeVariable1 = TypeVariableName.get(\"T\", Comparator.class, Serializable.class);\n+    TypeVariableName typeVariable2 = TypeVariableName.get(\"T\", Comparator.class, Serializable.class);\n+    test(typeVariable1, typeVariable2);\n   }\n \n   @Test public void equalsAndHashCodeWildcardTypeName() {\n-    assertEqualsHashCodeAndToString(WildcardTypeName.subtypeOf(Object.class),\n-        WildcardTypeName.subtypeOf(Object.class));\n-    assertEqualsHashCodeAndToString(WildcardTypeName.subtypeOf(Serializable.class),\n-        WildcardTypeName.subtypeOf(Serializable.class));\n-    assertEqualsHashCodeAndToString(WildcardTypeName.supertypeOf(String.class),\n-        WildcardTypeName.supertypeOf(String.class));\n+    test(WildcardTypeName.subtypeOf(Object.class), WildcardTypeName.subtypeOf(Object.class));\n+    test(WildcardTypeName.subtypeOf(Serializable.class), WildcardTypeName.subtypeOf(Serializable.class));\n+    test(WildcardTypeName.supertypeOf(String.class), WildcardTypeName.supertypeOf(String.class));\n   }\n \n-  @Test public void equalsAndHashCodeAnnotatedTypeName() {\n-    assertEqualsHashCodeAndToString(TypeName.BYTE.annotated(list()),\n-        TypeName.BYTE.annotated(list()));\n-    assertEqualsHashCodeAndToString(TypeName.INT.annotated(list(Override.class)),\n-        TypeName.INT.annotated(list(Override.class)));\n-    assertEqualsHashCodeAndToString(\n-        ClassName.get(Map.class).annotated(list(AnnotationA.class, AnnotationB.class)),\n-        ClassName.get(Map.class).annotated(list(AnnotationA.class, AnnotationB.class)));\n-    assertNotEquals(TypeName.CHAR, TypeName.CHAR.annotated(list(Documented.class)));\n-  }\n-\n-  private void assertEqualsHashCodeAndToString(TypeName a, TypeName b) {\n-    assertEquals(a.toString(), b.toString());\n+  private void test(TypeName a, TypeName b) {\n+    Assert.assertEquals(a.toString(), b.toString());\n     assertThat(a.equals(b)).isTrue();\n     assertThat(a.hashCode()).isEqualTo(b.hashCode());\n   }\n \n-  private AnnotationSpec[] list(Class<?>... types) {\n-    AnnotationSpec[] annotations = new AnnotationSpec[types.length];\n-    for (int i = 0; i < types.length; i++) {\n-      annotations[i] = AnnotationSpec.builder(types[i]).build();\n-    }\n-    return annotations;\n-  }\n-\n }\n"
    },
    {
        "commit_hash": "9d49d102e48c052b71ed64b5e575a38d784f5d49",
        "previous_commit_hash": "3bdc6b5c3faa4884684fd0b7ab2457e4bb7e45ff",
        "diff_stats": {
            "additions": 17,
            "deletions": 1
        },
        "diff_content": "@@ -18,7 +18,10 @@ package com.squareup.javapoet;\n import java.io.IOException;\n import java.lang.reflect.GenericArrayType;\n import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.LinkedHashMap;\n+import java.util.List;\n import java.util.Map;\n \n import javax.lang.model.element.TypeParameterElement;\n@@ -30,9 +33,22 @@ public final class ArrayTypeName extends TypeName {\n   public final TypeName componentType;\n \n   private ArrayTypeName(TypeName componentType) {\n+    this(componentType, new ArrayList<AnnotationSpec>());\n+  }\n+\n+  private ArrayTypeName(TypeName componentType, List<AnnotationSpec> annotations) {\n+    super(annotations);\n     this.componentType = checkNotNull(componentType, \"rawType == null\");\n   }\n \n+  @Override public ArrayTypeName annotated(AnnotationSpec... annotations) {\n+    return annotated(Arrays.asList(annotations));\n+  }\n+\n+  @Override public ArrayTypeName annotated(List<AnnotationSpec> annotations) {\n+    return new ArrayTypeName(componentType, annotations);\n+  }\n+\n   @Override public boolean equals(Object o) {\n     return o instanceof ArrayTypeName\n         && ((ArrayTypeName) o).componentType.equals(componentType);\n@@ -43,7 +59,7 @@ public final class ArrayTypeName extends TypeName {\n   }\n \n   @Override CodeWriter emit(CodeWriter out) throws IOException {\n-    return out.emit(\"$T[]\", componentType);\n+    return emitAnnotations(out).emit(\"$T[]\", componentType);\n   }\n \n   /** Returns an array type whose elements are all instances of {@code componentType}. */\n"
    },
    {
        "commit_hash": "9d49d102e48c052b71ed64b5e575a38d784f5d49",
        "previous_commit_hash": "3bdc6b5c3faa4884684fd0b7ab2457e4bb7e45ff",
        "diff_stats": {
            "additions": 15,
            "deletions": 1
        },
        "diff_content": "@@ -17,6 +17,7 @@ package com.squareup.javapoet;\n \n import java.io.IOException;\n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n@@ -40,6 +41,11 @@ public final class ClassName extends TypeName implements Comparable<ClassName> {\n   final String canonicalName;\n \n   private ClassName(List<String> names) {\n+    this(names, new ArrayList<AnnotationSpec>());\n+  }\n+\n+  private ClassName(List<String> names, List<AnnotationSpec> annotations) {\n+    super(annotations);\n     for (int i = 1; i < names.size(); i++) {\n       checkArgument(SourceVersion.isName(names.get(i)), \"part '%s' is keyword\", names.get(i));\n     }\n@@ -49,6 +55,14 @@ public final class ClassName extends TypeName implements Comparable<ClassName> {\n         : Util.join(\".\", names);\n   }\n \n+  @Override public ClassName annotated(AnnotationSpec... annotations) {\n+    return annotated(Arrays.asList(annotations));\n+  }\n+\n+  @Override public ClassName annotated(List<AnnotationSpec> annotations) {\n+    return new ClassName(names, annotations);\n+  }\n+\n   /** Returns the package name, like {@code \"java.util\"} for {@code Map.Entry}. */\n   public String packageName() {\n     return names.get(0);\n@@ -203,6 +217,6 @@ public final class ClassName extends TypeName implements Comparable<ClassName> {\n   }\n \n   @Override CodeWriter emit(CodeWriter out) throws IOException {\n-    return out.emitAndIndent(out.lookupName(this));\n+    return emitAnnotations(out).emitAndIndent(out.lookupName(this));\n   }\n }\n"
    },
    {
        "commit_hash": "9d49d102e48c052b71ed64b5e575a38d784f5d49",
        "previous_commit_hash": "3bdc6b5c3faa4884684fd0b7ab2457e4bb7e45ff",
        "diff_stats": {
            "additions": 16,
            "deletions": 0
        },
        "diff_content": "@@ -18,6 +18,7 @@ package com.squareup.javapoet;\n import java.io.IOException;\n import java.lang.reflect.ParameterizedType;\n import java.lang.reflect.Type;\n+import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.List;\n \n@@ -29,6 +30,12 @@ public final class ParameterizedTypeName extends TypeName {\n   public final List<TypeName> typeArguments;\n \n   ParameterizedTypeName(ClassName rawType, List<TypeName> typeArguments) {\n+    this(rawType, typeArguments, new ArrayList<AnnotationSpec>());\n+  }\n+\n+  ParameterizedTypeName(ClassName rawType, List<TypeName> typeArguments,\n+      List<AnnotationSpec> annotations) {\n+    super(annotations);\n     this.rawType = checkNotNull(rawType, \"rawType == null\");\n     this.typeArguments = Util.immutableList(typeArguments);\n \n@@ -39,6 +46,14 @@ public final class ParameterizedTypeName extends TypeName {\n     }\n   }\n \n+  @Override public ParameterizedTypeName annotated(AnnotationSpec... annotations) {\n+    return annotated(Arrays.asList(annotations));\n+  }\n+\n+  @Override public ParameterizedTypeName annotated(List<AnnotationSpec> annotations) {\n+    return new ParameterizedTypeName(rawType, typeArguments, annotations);\n+  }\n+\n   @Override public boolean equals(Object o) {\n     return o instanceof ParameterizedTypeName\n         && ((ParameterizedTypeName) o).rawType.equals(rawType)\n@@ -50,6 +65,7 @@ public final class ParameterizedTypeName extends TypeName {\n   }\n \n   @Override CodeWriter emit(CodeWriter out) throws IOException {\n+    emitAnnotations(out);\n     rawType.emit(out);\n     out.emitAndIndent(\"<\");\n     boolean firstParameter = true;\n"
    },
    {
        "commit_hash": "9d49d102e48c052b71ed64b5e575a38d784f5d49",
        "previous_commit_hash": "3bdc6b5c3faa4884684fd0b7ab2457e4bb7e45ff",
        "diff_stats": {
            "additions": 32,
            "deletions": 3
        },
        "diff_content": "@@ -22,6 +22,7 @@ import java.lang.reflect.Type;\n import java.lang.reflect.TypeVariable;\n import java.lang.reflect.WildcardType;\n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n@@ -87,14 +88,34 @@ public class TypeName {\n \n   /** The name of this type if it is a keyword, or null. */\n   private final String keyword;\n+  public final List<AnnotationSpec> annotations;\n \n   private TypeName(String keyword) {\n+    this(keyword, new ArrayList<AnnotationSpec>());\n+  }\n+\n+  private TypeName(String keyword, List<AnnotationSpec> annotations) {\n     this.keyword = keyword;\n+    this.annotations = Util.immutableList(annotations);\n   }\n \n   // Package-private constructor to prevent third-party subclasses.\n-  TypeName() {\n-    this(null);\n+  TypeName(List<AnnotationSpec> annotations) {\n+    this(null, annotations);\n+  }\n+\n+  public TypeName annotated(AnnotationSpec... annotations) {\n+    Util.checkNotNull(annotations, \"annotations == null\");\n+    return new TypeName(keyword, Arrays.asList(annotations));\n+  }\n+\n+  public TypeName annotated(List<AnnotationSpec> annotations) {\n+    Util.checkNotNull(annotations, \"annotations == null\");\n+    return new TypeName(keyword, annotations);\n+  }\n+\n+  public boolean isAnnotated() {\n+    return !annotations.isEmpty();\n   }\n \n   public boolean isPrimitive() {\n@@ -162,7 +183,15 @@ public class TypeName {\n \n   CodeWriter emit(CodeWriter out) throws IOException {\n     if (keyword == null) throw new AssertionError();\n-    return out.emitAndIndent(keyword);\n+    return emitAnnotations(out).emitAndIndent(keyword);\n+  }\n+\n+  CodeWriter emitAnnotations(CodeWriter out) throws IOException {\n+    for (AnnotationSpec annotation : annotations) {\n+      annotation.emit(out, true);\n+      out.emit(\" \");\n+    }\n+    return out;\n   }\n \n   /** Returns a type name equivalent to {@code mirror}. */\n"
    },
    {
        "commit_hash": "9d49d102e48c052b71ed64b5e575a38d784f5d49",
        "previous_commit_hash": "3bdc6b5c3faa4884684fd0b7ab2457e4bb7e45ff",
        "diff_stats": {
            "additions": 14,
            "deletions": 1
        },
        "diff_content": "@@ -35,6 +35,11 @@ public final class TypeVariableName extends TypeName {\n   public final List<TypeName> bounds;\n \n   private TypeVariableName(String name, List<TypeName> bounds) {\n+    this(name, bounds, new ArrayList<AnnotationSpec>());\n+  }\n+\n+  private TypeVariableName(String name, List<TypeName> bounds, List<AnnotationSpec> annotations) {\n+    super(annotations);\n     this.name = checkNotNull(name, \"name == null\");\n     this.bounds = bounds;\n \n@@ -43,6 +48,14 @@ public final class TypeVariableName extends TypeName {\n     }\n   }\n \n+  @Override public TypeVariableName annotated(AnnotationSpec... annotations) {\n+    return annotated(Arrays.asList(annotations));\n+  }\n+\n+  @Override public TypeVariableName annotated(List<AnnotationSpec> annotations) {\n+    return new TypeVariableName(name, bounds, annotations);\n+  }\n+\n   private static TypeVariableName of(String name, List<TypeName> bounds) {\n     // Strip java.lang.Object from bounds if it is present.\n     List<TypeName> boundsNoObject = new ArrayList<>(bounds);\n@@ -61,7 +74,7 @@ public final class TypeVariableName extends TypeName {\n   }\n \n   @Override CodeWriter emit(CodeWriter out) throws IOException {\n-    return out.emitAndIndent(name);\n+    return emitAnnotations(out).emitAndIndent(name);\n   }\n \n   /** Returns type variable named {@code name} without bounds. */\n"
    },
    {
        "commit_hash": "9d49d102e48c052b71ed64b5e575a38d784f5d49",
        "previous_commit_hash": "3bdc6b5c3faa4884684fd0b7ab2457e4bb7e45ff",
        "diff_stats": {
            "additions": 16,
            "deletions": 0
        },
        "diff_content": "@@ -18,6 +18,7 @@ package com.squareup.javapoet;\n import java.io.IOException;\n import java.lang.reflect.Type;\n import java.lang.reflect.WildcardType;\n+import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.LinkedHashMap;\n@@ -33,6 +34,12 @@ public final class WildcardTypeName extends TypeName {\n   public final List<TypeName> lowerBounds;\n \n   private WildcardTypeName(List<TypeName> upperBounds, List<TypeName> lowerBounds) {\n+    this(upperBounds, lowerBounds, new ArrayList<AnnotationSpec>());\n+  }\n+\n+  private WildcardTypeName(List<TypeName> upperBounds, List<TypeName> lowerBounds,\n+      List<AnnotationSpec> annotations) {\n+    super(annotations);\n     this.upperBounds = Util.immutableList(upperBounds);\n     this.lowerBounds = Util.immutableList(lowerBounds);\n \n@@ -47,6 +54,14 @@ public final class WildcardTypeName extends TypeName {\n     }\n   }\n \n+  @Override public WildcardTypeName annotated(AnnotationSpec... annotations) {\n+    return annotated(Arrays.asList(annotations));\n+  }\n+\n+  @Override public WildcardTypeName annotated(List<AnnotationSpec> annotations) {\n+    return new WildcardTypeName(upperBounds, lowerBounds, annotations);\n+  }\n+\n   @Override public boolean equals(Object o) {\n     return o instanceof WildcardTypeName\n         && ((WildcardTypeName) o).upperBounds.equals(upperBounds)\n@@ -58,6 +73,7 @@ public final class WildcardTypeName extends TypeName {\n   }\n \n   @Override CodeWriter emit(CodeWriter out) throws IOException {\n+    emitAnnotations(out);\n     if (lowerBounds.size() == 1) {\n       return out.emit(\"? super $T\", lowerBounds.get(0));\n     }\n"
    },
    {
        "commit_hash": "9d49d102e48c052b71ed64b5e575a38d784f5d49",
        "previous_commit_hash": "3bdc6b5c3faa4884684fd0b7ab2457e4bb7e45ff",
        "diff_stats": {
            "additions": 90,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright (C) 2015 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javapoet;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.List;\n+import org.junit.Test;\n+\n+public class AnnotatedTypeNameTest {\n+\n+  private final static String NN = NeverNull.class.getCanonicalName();\n+\n+  public @interface NeverNull {}\n+\n+  @Test(expected=NullPointerException.class) public void nullAnnotationArray() {\n+    TypeName.BOOLEAN.annotated((AnnotationSpec[]) null);\n+  }\n+\n+  @Test(expected=NullPointerException.class) public void nullAnnotationList() {\n+    TypeName.DOUBLE.annotated((List<AnnotationSpec>) null);\n+  }\n+\n+  @Test public void annotated() {\n+    TypeName simpleString = TypeName.get(String.class);\n+    assertFalse(simpleString.isAnnotated());\n+    assertEquals(simpleString, TypeName.get(String.class));\n+    TypeName annotated = simpleString.annotated(AnnotationSpec.builder(NeverNull.class).build());\n+    assertTrue(annotated.isAnnotated());\n+    assertEquals(simpleString, annotated.annotated());\n+    assertFalse(annotated.annotated().isAnnotated());\n+  }\n+\n+  @Test public void annotatedType() {\n+    String expected = \"@\" + NN + \" java.lang.String\";\n+    AnnotationSpec annotation = AnnotationSpec.builder(NeverNull.class).build();\n+    TypeName type = TypeName.get(String.class);\n+    String actual = type.annotated(annotation).toString();\n+    assertEquals(expected, actual);\n+  }\n+\n+  @Test public void annotatedParameterizedType() {\n+    String expected = \"@\" + NN + \" java.util.List<java.lang.String>\";\n+    AnnotationSpec annotation = AnnotationSpec.builder(NeverNull.class).build();\n+    TypeName type = ParameterizedTypeName.get(List.class, String.class);\n+    String actual = type.annotated(annotation).toString();\n+    assertEquals(expected, actual);\n+  }\n+\n+  @Test public void annotatedArgumentOfParameterizedType() {\n+    String expected = \"java.util.List<@\" + NN + \" java.lang.String>\";\n+    AnnotationSpec annotation = AnnotationSpec.builder(NeverNull.class).build();\n+    TypeName type = TypeName.get(String.class).annotated(annotation);\n+    ClassName list = ClassName.get(List.class);\n+    String actual = ParameterizedTypeName.get(list, type).toString();\n+    assertEquals(expected, actual);\n+  }\n+\n+  @Test public void annotatedWildcardTypeNameWithSuper() {\n+    String expected = \"? super @\" + NN + \" java.lang.String\";\n+    AnnotationSpec annotation = AnnotationSpec.builder(NeverNull.class).build();\n+    TypeName type = TypeName.get(String.class).annotated(annotation);\n+    String actual = WildcardTypeName.supertypeOf(type).toString();\n+    assertEquals(expected, actual);\n+  }\n+\n+  @Test public void annotatedWildcardTypeNameWithExtends() {\n+    String expected = \"? extends @\" + NN + \" java.lang.String\";\n+    AnnotationSpec annotation = AnnotationSpec.builder(NeverNull.class).build();\n+    TypeName type = TypeName.get(String.class).annotated(annotation);\n+    String actual = WildcardTypeName.subtypeOf(type).toString();\n+    assertEquals(expected, actual);\n+  }\n+\n+}\n"
    },
    {
        "commit_hash": "969d6398b2942eaebdaf867bf5cd3a4eb254b1af",
        "previous_commit_hash": "e7534b96fc07aaf1ba2134a820d71b1b55c390d2",
        "diff_stats": {
            "additions": 5,
            "deletions": 1
        },
        "diff_content": "@@ -84,6 +84,10 @@ public final class ArrayTypeName extends TypeName {\n \n   /** Returns an array type equivalent to {@code type}. */\n   public static ArrayTypeName get(GenericArrayType type) {\n-    return ArrayTypeName.of(get(type.getGenericComponentType()));\n+    return get(type, new LinkedHashMap<Type, TypeVariableName>());\n+  }\n+\n+  static ArrayTypeName get(GenericArrayType type, Map<Type, TypeVariableName> map) {\n+    return ArrayTypeName.of(get(type.getGenericComponentType(), map));\n   }\n }\n"
    },
    {
        "commit_hash": "969d6398b2942eaebdaf867bf5cd3a4eb254b1af",
        "previous_commit_hash": "e7534b96fc07aaf1ba2134a820d71b1b55c390d2",
        "diff_stats": {
            "additions": 8,
            "deletions": 1
        },
        "diff_content": "@@ -20,7 +20,9 @@ import java.lang.reflect.ParameterizedType;\n import java.lang.reflect.Type;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.LinkedHashMap;\n import java.util.List;\n+import java.util.Map;\n \n import static com.squareup.javapoet.Util.checkArgument;\n import static com.squareup.javapoet.Util.checkNotNull;\n@@ -89,7 +91,12 @@ public final class ParameterizedTypeName extends TypeName {\n \n   /** Returns a parameterized type equivalent to {@code type}. */\n   public static ParameterizedTypeName get(ParameterizedType type) {\n+    return get(type, new LinkedHashMap<Type, TypeVariableName>());\n+  }\n+\n+  /** Returns a parameterized type equivalent to {@code type}. */\n+  static ParameterizedTypeName get(ParameterizedType type, Map<Type, TypeVariableName> map) {\n     return new ParameterizedTypeName(ClassName.get((Class<?>) type.getRawType()),\n-        TypeName.list(type.getActualTypeArguments()));\n+        TypeName.list(type.getActualTypeArguments(), map));\n   }\n }\n"
    },
    {
        "commit_hash": "969d6398b2942eaebdaf867bf5cd3a4eb254b1af",
        "previous_commit_hash": "e7534b96fc07aaf1ba2134a820d71b1b55c390d2",
        "diff_stats": {
            "additions": 14,
            "deletions": 6
        },
        "diff_content": "@@ -261,6 +261,10 @@ public class TypeName {\n \n   /** Returns a type name equivalent to {@code type}. */\n   public static TypeName get(Type type) {\n+    return get(type, new LinkedHashMap<Type, TypeVariableName>());\n+  }\n+\n+  static TypeName get(Type type, Map<Type, TypeVariableName> map) {\n     if (type instanceof Class<?>) {\n       Class<?> classType = (Class<?>) type;\n       if (type == void.class) return VOID;\n@@ -272,20 +276,20 @@ public class TypeName {\n       if (type == char.class) return CHAR;\n       if (type == float.class) return FLOAT;\n       if (type == double.class) return DOUBLE;\n-      if (classType.isArray()) return ArrayTypeName.of(get(classType.getComponentType()));\n+      if (classType.isArray()) return ArrayTypeName.of(get(classType.getComponentType(), map));\n       return ClassName.get(classType);\n \n     } else if (type instanceof ParameterizedType) {\n-      return ParameterizedTypeName.get((ParameterizedType) type);\n+      return ParameterizedTypeName.get((ParameterizedType) type, map);\n \n     } else if (type instanceof WildcardType) {\n-      return WildcardTypeName.get((WildcardType) type);\n+      return WildcardTypeName.get((WildcardType) type, map);\n \n     } else if (type instanceof TypeVariable<?>) {\n-      return TypeVariableName.get((TypeVariable<?>) type);\n+      return TypeVariableName.get((TypeVariable<?>) type, map);\n \n     } else if (type instanceof GenericArrayType) {\n-      return ArrayTypeName.get((GenericArrayType) type);\n+      return ArrayTypeName.get((GenericArrayType) type, map);\n \n     } else {\n       throw new IllegalArgumentException(\"unexpected type: \" + type);\n@@ -294,9 +298,13 @@ public class TypeName {\n \n   /** Converts an array of types to a list of type names. */\n   static List<TypeName> list(Type[] types) {\n+    return list(types, new LinkedHashMap<Type, TypeVariableName>());\n+  }\n+\n+  static List<TypeName> list(Type[] types, Map<Type, TypeVariableName> map) {\n     List<TypeName> result = new ArrayList<>(types.length);\n     for (Type type : types) {\n-      result.add(get(type));\n+      result.add(get(type, map));\n     }\n     return result;\n   }\n"
    },
    {
        "commit_hash": "969d6398b2942eaebdaf867bf5cd3a4eb254b1af",
        "previous_commit_hash": "e7534b96fc07aaf1ba2134a820d71b1b55c390d2",
        "diff_stats": {
            "additions": 19,
            "deletions": 1
        },
        "diff_content": "@@ -20,6 +20,7 @@ import java.lang.reflect.Type;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n+import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n \n@@ -139,6 +140,23 @@ public final class TypeVariableName extends TypeName {\n \n   /** Returns type variable equivalent to {@code type}. */\n   public static TypeVariableName get(java.lang.reflect.TypeVariable<?> type) {\n-    return TypeVariableName.of(type.getName(), TypeName.list(type.getBounds()));\n+    return get(type, new LinkedHashMap<Type, TypeVariableName>());\n+  }\n+\n+  /** @see #get(java.lang.reflect.TypeVariable, Map) */\n+  static TypeVariableName get(java.lang.reflect.TypeVariable<?> type,\n+      Map<Type, TypeVariableName> map) {\n+    TypeVariableName result = map.get(type);\n+    if (result == null) {\n+      List<TypeName> bounds = new ArrayList<>();\n+      List<TypeName> visibleBounds = Collections.unmodifiableList(bounds);\n+      result = new TypeVariableName(type.getName(), visibleBounds);\n+      map.put(type, result);\n+      for (Type bound : type.getBounds()) {\n+        bounds.add(TypeName.get(bound, map));\n+      }\n+      bounds.remove(OBJECT);\n+    }\n+    return result;\n   }\n }\n"
    },
    {
        "commit_hash": "969d6398b2942eaebdaf867bf5cd3a4eb254b1af",
        "previous_commit_hash": "e7534b96fc07aaf1ba2134a820d71b1b55c390d2",
        "diff_stats": {
            "additions": 6,
            "deletions": 2
        },
        "diff_content": "@@ -129,8 +129,12 @@ public final class WildcardTypeName extends TypeName {\n   }\n \n   public static TypeName get(WildcardType wildcardName) {\n+    return get(wildcardName, new LinkedHashMap<Type, TypeVariableName>());\n+  }\n+\n+  static TypeName get(WildcardType wildcardName, Map<Type, TypeVariableName> map) {\n     return new WildcardTypeName(\n-        list(wildcardName.getUpperBounds()),\n-        list(wildcardName.getLowerBounds()));\n+        list(wildcardName.getUpperBounds(), map),\n+        list(wildcardName.getLowerBounds(), map));\n   }\n }\n"
    },
    {
        "commit_hash": "969d6398b2942eaebdaf867bf5cd3a4eb254b1af",
        "previous_commit_hash": "e7534b96fc07aaf1ba2134a820d71b1b55c390d2",
        "diff_stats": {
            "additions": 54,
            "deletions": 30
        },
        "diff_content": "@@ -16,61 +16,85 @@\n package com.squareup.javapoet;\n \n import static com.google.common.truth.Truth.assertThat;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotEquals;\n \n import java.io.Serializable;\n+import java.lang.reflect.Method;\n import java.rmi.server.UID;\n import java.util.Comparator;\n+import java.util.List;\n import java.util.Set;\n-\n-import org.junit.Assert;\n import org.junit.Test;\n \n public class TypeNameTest {\n \n+  protected <E extends Enum<E>> E generic(E[] values) {\n+    return values[0];\n+  }\n+\n+  @Test public void genericType() throws Exception {\n+    Method recursiveEnum = getClass().getDeclaredMethod(\"generic\", Enum[].class);\n+    TypeName.get(recursiveEnum.getReturnType());\n+    TypeName.get(recursiveEnum.getGenericReturnType());\n+    TypeName.get(recursiveEnum.getParameterTypes()[0]);\n+    TypeName.get(recursiveEnum.getGenericParameterTypes()[0]);\n+  }\n+\n   @Test public void equalsAndHashCodePrimitive() {\n-    test(TypeName.BOOLEAN, TypeName.BOOLEAN);\n-    test(TypeName.BYTE, TypeName.BYTE);\n-    test(TypeName.CHAR, TypeName.CHAR);\n-    test(TypeName.DOUBLE, TypeName.DOUBLE);\n-    test(TypeName.FLOAT, TypeName.FLOAT);\n-    test(TypeName.INT, TypeName.INT);\n-    test(TypeName.LONG, TypeName.LONG);\n-    test(TypeName.SHORT, TypeName.SHORT);\n-    test(TypeName.VOID, TypeName.VOID);\n+    assertEqualsHashCodeAndToString(TypeName.BOOLEAN, TypeName.BOOLEAN);\n+    assertEqualsHashCodeAndToString(TypeName.BYTE, TypeName.BYTE);\n+    assertEqualsHashCodeAndToString(TypeName.CHAR, TypeName.CHAR);\n+    assertEqualsHashCodeAndToString(TypeName.DOUBLE, TypeName.DOUBLE);\n+    assertEqualsHashCodeAndToString(TypeName.FLOAT, TypeName.FLOAT);\n+    assertEqualsHashCodeAndToString(TypeName.INT, TypeName.INT);\n+    assertEqualsHashCodeAndToString(TypeName.LONG, TypeName.LONG);\n+    assertEqualsHashCodeAndToString(TypeName.SHORT, TypeName.SHORT);\n+    assertEqualsHashCodeAndToString(TypeName.VOID, TypeName.VOID);\n   }\n \n   @Test public void equalsAndHashCodeArrayTypeName() {\n-    test(ArrayTypeName.of(Object.class), ArrayTypeName.of(Object.class));\n-    test(TypeName.get(Object[].class), ArrayTypeName.of(Object.class));\n-    // ? check(ClassName.bestGuess(\"java.lang.Object[]\"), ArrayTypeName.of(Object.class));\n+    assertEqualsHashCodeAndToString(ArrayTypeName.of(Object.class),\n+        ArrayTypeName.of(Object.class));\n+    assertEqualsHashCodeAndToString(TypeName.get(Object[].class),\n+        ArrayTypeName.of(Object.class));\n   }\n \n   @Test public void equalsAndHashCodeClassName() {\n-    test(ClassName.get(Object.class), ClassName.get(Object.class));\n-    test(TypeName.get(Object.class), ClassName.get(Object.class));\n-    test(ClassName.bestGuess(\"java.lang.Object\"), ClassName.get(Object.class));\n+    assertEqualsHashCodeAndToString(ClassName.get(Object.class), ClassName.get(Object.class));\n+    assertEqualsHashCodeAndToString(TypeName.get(Object.class), ClassName.get(Object.class));\n+    assertEqualsHashCodeAndToString(ClassName.bestGuess(\"java.lang.Object\"),\n+        ClassName.get(Object.class));\n   }\n-  \n+\n   @Test public void equalsAndHashCodeParameterizedTypeName() {\n-    test(ParameterizedTypeName.get(Object.class), ParameterizedTypeName.get(Object.class));\n-    test(ParameterizedTypeName.get(Set.class, UID.class), ParameterizedTypeName.get(Set.class, UID.class));\n+    assertEqualsHashCodeAndToString(ParameterizedTypeName.get(Object.class),\n+        ParameterizedTypeName.get(Object.class));\n+    assertEqualsHashCodeAndToString(ParameterizedTypeName.get(Set.class, UID.class),\n+        ParameterizedTypeName.get(Set.class, UID.class));\n+    assertNotEquals(ClassName.get(List.class), ParameterizedTypeName.get(List.class,\n+        String.class));\n   }\n-  \n+\n   @Test public void equalsAndHashCodeTypeVariableName() {\n-    test(TypeVariableName.get(Object.class), TypeVariableName.get(Object.class));\n-    TypeVariableName typeVariable1 = TypeVariableName.get(\"T\", Comparator.class, Serializable.class);\n-    TypeVariableName typeVariable2 = TypeVariableName.get(\"T\", Comparator.class, Serializable.class);\n-    test(typeVariable1, typeVariable2);\n+    assertEqualsHashCodeAndToString(TypeVariableName.get(Object.class),\n+        TypeVariableName.get(Object.class));\n+    TypeVariableName typeVar1 = TypeVariableName.get(\"T\", Comparator.class, Serializable.class);\n+    TypeVariableName typeVar2 = TypeVariableName.get(\"T\", Comparator.class, Serializable.class);\n+    assertEqualsHashCodeAndToString(typeVar1, typeVar2);\n   }\n \n   @Test public void equalsAndHashCodeWildcardTypeName() {\n-    test(WildcardTypeName.subtypeOf(Object.class), WildcardTypeName.subtypeOf(Object.class));\n-    test(WildcardTypeName.subtypeOf(Serializable.class), WildcardTypeName.subtypeOf(Serializable.class));\n-    test(WildcardTypeName.supertypeOf(String.class), WildcardTypeName.supertypeOf(String.class));\n+    assertEqualsHashCodeAndToString(WildcardTypeName.subtypeOf(Object.class),\n+        WildcardTypeName.subtypeOf(Object.class));\n+    assertEqualsHashCodeAndToString(WildcardTypeName.subtypeOf(Serializable.class),\n+        WildcardTypeName.subtypeOf(Serializable.class));\n+    assertEqualsHashCodeAndToString(WildcardTypeName.supertypeOf(String.class),\n+        WildcardTypeName.supertypeOf(String.class));\n   }\n \n-  private void test(TypeName a, TypeName b) {\n-    Assert.assertEquals(a.toString(), b.toString());\n+  private void assertEqualsHashCodeAndToString(TypeName a, TypeName b) {\n+    assertEquals(a.toString(), b.toString());\n     assertThat(a.equals(b)).isTrue();\n     assertThat(a.hashCode()).isEqualTo(b.hashCode());\n   }\n"
    },
    {
        "commit_hash": "74e7ea9e7a70c71b73829a399467b940f18c48c4",
        "previous_commit_hash": "852b1bb78224e2fd3a183b6175e388044d775ae1",
        "diff_stats": {
            "additions": 0,
            "deletions": 46
        },
        "diff_content": "@@ -1,46 +0,0 @@\n-#!/bin/bash\n-\n-set -ex\n-\n-REPO=\"git@github.com:square/javapoet.git\"\n-GROUP_ID=\"com.squareup\"\n-ARTIFACT_ID=\"javapoet\"\n-\n-DIR=temp-clone\n-\n-# Delete any existing temporary website clone\n-rm -rf $DIR\n-\n-# Clone the current repo into temp folder\n-git clone $REPO $DIR\n-\n-# Move working directory into temp folder\n-cd $DIR\n-\n-# Checkout and track the gh-pages branch\n-git checkout -t origin/gh-pages\n-\n-# Delete everything\n-rm -rf *\n-\n-# Download the latest javadoc to directories like 'javadoc/javapoet'.\n-for DOCUMENTED_ARTIFACT in javawriter javapoet\n-do\n-  curl -L \"https://search.maven.org/remote_content?g=$GROUP_ID&a=$DOCUMENTED_ARTIFACT&v=LATEST&c=javadoc\" > javadoc.zip\n-  JAVADOC_DIR=\"javadoc/${DOCUMENTED_ARTIFACT}\"\n-  mkdir -p $JAVADOC_DIR\n-  unzip javadoc.zip -d $JAVADOC_DIR\n-  rm javadoc.zip\n-done\n-\n-# Stage all files in git and create a commit\n-git add .\n-git add -u\n-git commit -m \"Website at $(date)\"\n-\n-# Push the new files up to GitHub\n-git push origin gh-pages\n-\n-# Delete our temp folder\n-cd ..\n-rm -rf $DIR\n"
    },
    {
        "commit_hash": "77e89f03810d9270ddc908a0d34b25e1b9b0a6ce",
        "previous_commit_hash": "c5109fa0009cc8f4d50843a220ec46d3f98399d2",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -789,7 +789,7 @@ JavaWriter continues to be available in [GitHub][javawriter] and [Maven Central]\n \n  [dl]: https://search.maven.org/remote_content?g=com.squareup&a=javapoet&v=LATEST\n  [snap]: https://oss.sonatype.org/content/repositories/snapshots/com/squareup/javapoet/\n- [javadoc]: https://square.github.io/javapoet/javadoc/javapoet/\n+ [javadoc]: https://square.github.io/javapoet/1.x/javapoet/\n  [javawriter]: https://github.com/square/javapoet/tree/javawriter_2\n  [javawriter_maven]: http://search.maven.org/#artifactdetails%7Ccom.squareup%7Cjavawriter%7C2.5.1%7Cjar\n  [formatter]: http://developer.android.com/reference/java/util/Formatter.html\n"
    },
    {
        "commit_hash": "bb8e4fc33b271d6867ea1be5638649315fc18811",
        "previous_commit_hash": "77e89f03810d9270ddc908a0d34b25e1b9b0a6ce",
        "diff_stats": {
            "additions": 6,
            "deletions": 1
        },
        "diff_content": "@@ -289,6 +289,11 @@ final class CodeWriter {\n       }\n     }\n \n+    // If the name resolved but wasn't a match, we're stuck with the fully qualified name.\n+    if (nameResolved) {\n+      return className.canonicalName;\n+    }\n+\n     // If the class is in the same package, we're done.\n     if (Objects.equals(packageName, className.packageName())) {\n       referencedNames.add(className.topLevelClassName().simpleName());\n@@ -296,7 +301,7 @@ final class CodeWriter {\n     }\n \n     // We'll have to use the fully-qualified name. Mark the type as importable for a future pass.\n-    if (!javadoc && !nameResolved) {\n+    if (!javadoc) {\n       importableType(className);\n     }\n \n"
    },
    {
        "commit_hash": "bb8e4fc33b271d6867ea1be5638649315fc18811",
        "previous_commit_hash": "77e89f03810d9270ddc908a0d34b25e1b9b0a6ce",
        "diff_stats": {
            "additions": 19,
            "deletions": 0
        },
        "diff_content": "@@ -302,4 +302,23 @@ public final class JavaFileTest {\n         + \"class Taco {\\n\"\n         + \"}\\n\");\n   }\n+\n+  @Test public void packageClassConflictsWithNestedClass() throws Exception {\n+    String source = JavaFile.builder(\"com.squareup.tacos\",\n+        TypeSpec.classBuilder(\"Taco\")\n+            .addField(ClassName.get(\"com.squareup.tacos\", \"A\"), \"a\")\n+            .addType(TypeSpec.classBuilder(\"A\").build())\n+            .build())\n+        .build()\n+        .toString();\n+    assertThat(source).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"class Taco {\\n\"\n+        + \"  com.squareup.tacos.A a;\\n\"\n+        + \"\\n\"\n+        + \"  class A {\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n }\n"
    },
    {
        "commit_hash": "006a54bc9a09ddae9861b88c09c02cddf60d3268",
        "previous_commit_hash": "b59cde516d0a6e7d28f03e373f48e08f31c6dc7b",
        "diff_stats": {
            "additions": 24,
            "deletions": 0
        },
        "diff_content": "@@ -249,6 +249,30 @@ public final class JavaFileTest {\n         + \"}\\n\");\n   }\n \n+  /** https://github.com/square/javapoet/issues/366 */\n+  @Test public void annotationIsNestedClass() throws Exception {\n+    String source = JavaFile.builder(\"com.squareup.tacos\",\n+        TypeSpec.classBuilder(\"TestComponent\")\n+            .addAnnotation(ClassName.get(\"dagger\", \"Component\"))\n+            .addType(TypeSpec.classBuilder(\"Builder\")\n+                .addAnnotation(ClassName.get(\"dagger\", \"Component\", \"Builder\"))\n+                .build())\n+            .build())\n+        .build()\n+        .toString();\n+    assertThat(source).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import dagger.Component;\\n\"\n+        + \"\\n\"\n+        + \"@Component\\n\"\n+        + \"class TestComponent {\\n\"\n+        + \"  @Component.Builder\\n\"\n+        + \"  class Builder {\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n   @Test public void defaultPackage() throws Exception {\n     String source = JavaFile.builder(\"\",\n         TypeSpec.classBuilder(\"HelloWorld\")\n"
    },
    {
        "commit_hash": "f70958f97c4514d90de2b1b79d17cf6e446d7a63",
        "previous_commit_hash": "1f07dd446d926fdd4a20ecb6490063d0aba0dbd6",
        "diff_stats": {
            "additions": 14,
            "deletions": 0
        },
        "diff_content": "@@ -1,6 +1,20 @@\n Change Log\n ==========\n \n+JavaPoet 1.4.0 *(2015-11-13)*\n+----------------------------\n+\n+ * New: `AnnotationSpec.get(Annotation)`.\n+ * New: Type annotations! `TypeName.annotated()` can attach annotations like `@Nullable` directly to\n+   types. This works for both top-level types and type parameters as in `List<@Nullable String>`.\n+ * New: `equals()` and `hashCode()` on `AnnotationSpec`, `CodeBlock`, `FieldSpec`, `JavaFile`,\n+   `MethodSpec`, `ParameterSpec`, `TypeName`, and `TypeSpec`.\n+ * New: `NameAllocator.clone()` to refine a NameAllocator for use in an inner scope code block.\n+ * Fix: Don't stack overflow when `TypeVariableName` gets a self-referential type.\n+ * Fix: Better handling of name collisions on imports. Previously JavaPoet did the wrong thing when\n+   a referenced type and a nested types had the same name.\n+\n+\n JavaPoet 1.3.0 *(2015-09-20)*\n ----------------------------\n \n"
    },
    {
        "commit_hash": "27ddf3785d08d065262f64746f493621d3b95812",
        "previous_commit_hash": "f70958f97c4514d90de2b1b79d17cf6e446d7a63",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.4.0-SNAPSHOT</version>\n+  <version>1.4.0</version>\n \n   <name>JavaPoet</name>\n   <description>Use beautiful Java code to generate beautiful Java code.</description>\n@@ -54,13 +54,13 @@\n     <dependency>\n       <groupId>com.google.truth</groupId>\n       <artifactId>truth</artifactId>\n-      <version>1.0-SNAPSHOT</version>\n+      <version>0.27</version>\n       <scope>test</scope>\n     </dependency>\n     <dependency>\n       <groupId>com.google.testing.compile</groupId>\n       <artifactId>compile-testing</artifactId>\n-      <version>1.0-SNAPSHOT</version>\n+      <version>0.6</version>\n       <scope>test</scope>\n     </dependency>\n     <dependency>\n"
    },
    {
        "commit_hash": "cf4b9a0df9432800e7b3d2b1b67ab4b1db5bf1e9",
        "previous_commit_hash": "27ddf3785d08d065262f64746f493621d3b95812",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.4.0</version>\n+  <version>1.5.0-SNAPSHOT</version>\n \n   <name>JavaPoet</name>\n   <description>Use beautiful Java code to generate beautiful Java code.</description>\n@@ -54,13 +54,13 @@\n     <dependency>\n       <groupId>com.google.truth</groupId>\n       <artifactId>truth</artifactId>\n-      <version>0.27</version>\n+      <version>1.0-SNAPSHOT</version>\n       <scope>test</scope>\n     </dependency>\n     <dependency>\n       <groupId>com.google.testing.compile</groupId>\n       <artifactId>compile-testing</artifactId>\n-      <version>0.6</version>\n+      <version>1.0-SNAPSHOT</version>\n       <scope>test</scope>\n     </dependency>\n     <dependency>\n"
    },
    {
        "commit_hash": "e51d3947933fe8029d0e2bbccc0bf32f9cdb8d0c",
        "previous_commit_hash": "cf4b9a0df9432800e7b3d2b1b67ab4b1db5bf1e9",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -745,12 +745,12 @@ Download [the latest .jar][dl] or depend via Maven:\n <dependency>\n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.3.0</version>\n+  <version>1.4.0</version>\n </dependency>\n ```\n or Gradle:\n ```groovy\n-compile 'com.squareup:javapoet:1.3.0'\n+compile 'com.squareup:javapoet:1.4.0'\n ```\n \n Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].\n"
    },
    {
        "commit_hash": "6980db0d3757d13f1332f1137f8aa8689d8f0265",
        "previous_commit_hash": "29727b0639e0bbf70515c575093f5ff72d94f54a",
        "diff_stats": {
            "additions": 3,
            "deletions": 0
        },
        "diff_content": "@@ -309,6 +309,9 @@ final class CodeWriter {\n   }\n \n   private void importableType(ClassName className) {\n+    if (className.packageName().isEmpty()) {\n+      return;\n+    }\n     ClassName topLevelClassName = className.topLevelClassName();\n     String simpleName = topLevelClassName.simpleName();\n     ClassName replaced = importableTypes.put(simpleName, topLevelClassName);\n"
    },
    {
        "commit_hash": "6980db0d3757d13f1332f1137f8aa8689d8f0265",
        "previous_commit_hash": "29727b0639e0bbf70515c575093f5ff72d94f54a",
        "diff_stats": {
            "additions": 12,
            "deletions": 0
        },
        "diff_content": "@@ -295,6 +295,18 @@ public final class JavaFileTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void defaultPackageTypesAreNotImported() throws Exception {\n+    String source = JavaFile.builder(\"hello\",\n+          TypeSpec.classBuilder(\"World\").addSuperinterface(ClassName.get(\"\", \"Test\")).build())\n+        .build()\n+        .toString();\n+    assertThat(source).isEqualTo(\"\"\n+        + \"package hello;\\n\"\n+        + \"\\n\"\n+        + \"class World implements Test {\\n\"\n+        + \"}\\n\");\n+  }\n+\n   @Test public void topOfFileComment() throws Exception {\n     String source = JavaFile.builder(\"com.squareup.tacos\",\n         TypeSpec.classBuilder(\"Taco\").build())\n"
    },
    {
        "commit_hash": "4ce8e427b533ec2a598ae9c967487713ce731662",
        "previous_commit_hash": "4522c42783ac897f26b98232ca39c76a803b07b1",
        "diff_stats": {
            "additions": 19,
            "deletions": 5
        },
        "diff_content": "@@ -111,7 +111,8 @@ public final class CodeBlock {\n     public Builder add(String format, Object... args) {\n       boolean hasRelative = false;\n       boolean hasIndexed = false;\n-      int parameterCount = 0;\n+      int relativeParameterCount = 0;\n+      int[] indexedParameterCount = new int[args.length];\n \n       for (int p = 0; p < format.length(); ) {\n         if (format.charAt(p) != '$') {\n@@ -145,11 +146,12 @@ public final class CodeBlock {\n         if (indexStart < indexEnd) {\n           index = Integer.parseInt(format.substring(indexStart, indexEnd)) - 1;\n           hasIndexed = true;\n+          indexedParameterCount[index % args.length]++; // modulo is needed, checked below anyway\n         } else {\n-          index = parameterCount;\n+          index = relativeParameterCount;\n           hasRelative = true;\n+          relativeParameterCount++;\n         }\n-        parameterCount++;\n \n         checkArgument(index >= 0 && index < args.length,\n             \"index %d for '%s' not in range (received %s arguments)\",\n@@ -177,8 +179,20 @@ public final class CodeBlock {\n         formatParts.add(\"$\" + c);\n       }\n \n-      checkArgument(parameterCount >= args.length,\n-          \"unused arguments: expected %s, received %s\", parameterCount, args.length);\n+      if (hasRelative) {\n+        checkArgument(relativeParameterCount >= args.length,\n+            \"unused arguments: expected %s, received %s\", relativeParameterCount, args.length);\n+      }\n+      if (hasIndexed) {\n+        List<String> unused = new ArrayList<>();\n+        for (int i = 0; i < args.length; i++) {\n+          if (indexedParameterCount[i] == 0) {\n+            unused.add(\"$\" + (i + 1));\n+          }\n+        }\n+        String s = unused.size() == 1 ? \"\" : \"s\";\n+        checkArgument(unused.isEmpty(), \"unused argument%s: %s\", s, Util.join(\", \", unused));\n+      }\n       return this;\n     }\n \n"
    },
    {
        "commit_hash": "4ce8e427b533ec2a598ae9c967487713ce731662",
        "previous_commit_hash": "4522c42783ac897f26b98232ca39c76a803b07b1",
        "diff_stats": {
            "additions": 13,
            "deletions": 1
        },
        "diff_content": "@@ -1914,7 +1914,19 @@ public final class TypeSpecTest {\n       CodeBlock.builder().add(\"$1L $2L\", \"a\", \"b\", \"c\");\n       fail();\n     } catch (IllegalArgumentException expected) {\n-      assertThat(expected).hasMessage(\"unused arguments: expected 2, received 3\");\n+      assertThat(expected).hasMessage(\"unused argument: $3\");\n+    }\n+    try {\n+      CodeBlock.builder().add(\"$1L $1L $1L\", \"a\", \"b\", \"c\");\n+      fail();\n+    } catch (IllegalArgumentException expected) {\n+      assertThat(expected).hasMessage(\"unused arguments: $2, $3\");\n+    }\n+    try {\n+      CodeBlock.builder().add(\"$3L $1L $3L $1L $3L\", \"a\", \"b\", \"c\", \"d\");\n+      fail();\n+    } catch (IllegalArgumentException expected) {\n+      assertThat(expected).hasMessage(\"unused arguments: $2, $4\");\n     }\n   }\n \n"
    },
    {
        "commit_hash": "633e4ac4bb8841c8f9dc5ef95548a9ca7939e535",
        "previous_commit_hash": "251cb9a9797dabfe873ae6901fdabe8ea7c052cf",
        "diff_stats": {
            "additions": 15,
            "deletions": 0
        },
        "diff_content": "@@ -19,6 +19,7 @@ import java.util.LinkedHashMap;\n import java.util.LinkedHashSet;\n import java.util.Map;\n import java.util.Set;\n+import java.util.UUID;\n import javax.lang.model.SourceVersion;\n \n import static com.squareup.javapoet.Util.checkNotNull;\n@@ -91,6 +92,19 @@ public final class NameAllocator implements Cloneable {\n     this.tagToName = tagToName;\n   }\n \n+  /**\n+   * Return a new name using {@code suggestion} that will not be a Java identifier or clash with\n+   * other names.\n+   */\n+  public String newName(String suggestion) {\n+    return newName(suggestion, UUID.randomUUID().toString());\n+  }\n+\n+  /**\n+   * Return a new name using {@code suggestion} that will not be a Java identifier or clash with\n+   * other names. The returned value can be queried multiple times by passing {@code tag} to\n+   * {@link #get(Object)}.\n+   */\n   public String newName(String suggestion, Object tag) {\n     checkNotNull(suggestion, \"suggestion\");\n     checkNotNull(tag, \"tag\");\n@@ -128,6 +142,7 @@ public final class NameAllocator implements Cloneable {\n     return result.toString();\n   }\n \n+  /** Retrieve a name created with {@link #newName(String, Object)}. */\n   public String get(Object tag) {\n     String result = tagToName.get(tag);\n     if (result == null) {\n"
    },
    {
        "commit_hash": "633e4ac4bb8841c8f9dc5ef95548a9ca7939e535",
        "previous_commit_hash": "251cb9a9797dabfe873ae6901fdabe8ea7c052cf",
        "diff_stats": {
            "additions": 7,
            "deletions": 0
        },
        "diff_content": "@@ -30,6 +30,13 @@ public final class NameAllocatorTest {\n   }\n \n   @Test public void nameCollision() throws Exception {\n+    NameAllocator nameAllocator = new NameAllocator();\n+    assertThat(nameAllocator.newName(\"foo\")).isEqualTo(\"foo\");\n+    assertThat(nameAllocator.newName(\"foo\")).isEqualTo(\"foo_\");\n+    assertThat(nameAllocator.newName(\"foo\")).isEqualTo(\"foo__\");\n+  }\n+\n+  @Test public void nameCollisionWithTag() throws Exception {\n     NameAllocator nameAllocator = new NameAllocator();\n     assertThat(nameAllocator.newName(\"foo\", 1)).isEqualTo(\"foo\");\n     assertThat(nameAllocator.newName(\"foo\", 2)).isEqualTo(\"foo_\");\n"
    },
    {
        "commit_hash": "408388c35a4c0b815ec2108c3d9c2afd10f2e036",
        "previous_commit_hash": "c635835c2096a437b442fb352aca165f3353cdc3",
        "diff_stats": {
            "additions": 0,
            "deletions": 5
        },
        "diff_content": "@@ -19,7 +19,6 @@ import java.io.IOException;\n import java.lang.reflect.GenericArrayType;\n import java.lang.reflect.Type;\n import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n@@ -41,10 +40,6 @@ public final class ArrayTypeName extends TypeName {\n     this.componentType = checkNotNull(componentType, \"rawType == null\");\n   }\n \n-  @Override public ArrayTypeName annotated(AnnotationSpec... annotations) {\n-    return annotated(Arrays.asList(annotations));\n-  }\n-\n   @Override public ArrayTypeName annotated(List<AnnotationSpec> annotations) {\n     return new ArrayTypeName(componentType, annotations);\n   }\n"
    },
    {
        "commit_hash": "408388c35a4c0b815ec2108c3d9c2afd10f2e036",
        "previous_commit_hash": "c635835c2096a437b442fb352aca165f3353cdc3",
        "diff_stats": {
            "additions": 0,
            "deletions": 5
        },
        "diff_content": "@@ -17,7 +17,6 @@ package com.squareup.javapoet;\n \n import java.io.IOException;\n import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n@@ -55,10 +54,6 @@ public final class ClassName extends TypeName implements Comparable<ClassName> {\n         : Util.join(\".\", names);\n   }\n \n-  @Override public ClassName annotated(AnnotationSpec... annotations) {\n-    return annotated(Arrays.asList(annotations));\n-  }\n-\n   @Override public ClassName annotated(List<AnnotationSpec> annotations) {\n     return new ClassName(names, annotations);\n   }\n"
    },
    {
        "commit_hash": "408388c35a4c0b815ec2108c3d9c2afd10f2e036",
        "previous_commit_hash": "c635835c2096a437b442fb352aca165f3353cdc3",
        "diff_stats": {
            "additions": 0,
            "deletions": 4
        },
        "diff_content": "@@ -48,10 +48,6 @@ public final class ParameterizedTypeName extends TypeName {\n     }\n   }\n \n-  @Override public ParameterizedTypeName annotated(AnnotationSpec... annotations) {\n-    return annotated(Arrays.asList(annotations));\n-  }\n-\n   @Override public ParameterizedTypeName annotated(List<AnnotationSpec> annotations) {\n     return new ParameterizedTypeName(rawType, typeArguments, annotations);\n   }\n"
    },
    {
        "commit_hash": "408388c35a4c0b815ec2108c3d9c2afd10f2e036",
        "previous_commit_hash": "c635835c2096a437b442fb352aca165f3353cdc3",
        "diff_stats": {
            "additions": 2,
            "deletions": 3
        },
        "diff_content": "@@ -104,9 +104,8 @@ public class TypeName {\n     this(null, annotations);\n   }\n \n-  public TypeName annotated(AnnotationSpec... annotations) {\n-    Util.checkNotNull(annotations, \"annotations == null\");\n-    return new TypeName(keyword, Arrays.asList(annotations));\n+  public final TypeName annotated(AnnotationSpec... annotations) {\n+    return annotated(Arrays.asList(annotations));\n   }\n \n   public TypeName annotated(List<AnnotationSpec> annotations) {\n"
    },
    {
        "commit_hash": "408388c35a4c0b815ec2108c3d9c2afd10f2e036",
        "previous_commit_hash": "c635835c2096a437b442fb352aca165f3353cdc3",
        "diff_stats": {
            "additions": 0,
            "deletions": 4
        },
        "diff_content": "@@ -49,10 +49,6 @@ public final class TypeVariableName extends TypeName {\n     }\n   }\n \n-  @Override public TypeVariableName annotated(AnnotationSpec... annotations) {\n-    return annotated(Arrays.asList(annotations));\n-  }\n-\n   @Override public TypeVariableName annotated(List<AnnotationSpec> annotations) {\n     return new TypeVariableName(name, bounds, annotations);\n   }\n"
    },
    {
        "commit_hash": "408388c35a4c0b815ec2108c3d9c2afd10f2e036",
        "previous_commit_hash": "c635835c2096a437b442fb352aca165f3353cdc3",
        "diff_stats": {
            "additions": 0,
            "deletions": 4
        },
        "diff_content": "@@ -54,10 +54,6 @@ public final class WildcardTypeName extends TypeName {\n     }\n   }\n \n-  @Override public WildcardTypeName annotated(AnnotationSpec... annotations) {\n-    return annotated(Arrays.asList(annotations));\n-  }\n-\n   @Override public WildcardTypeName annotated(List<AnnotationSpec> annotations) {\n     return new WildcardTypeName(upperBounds, lowerBounds, annotations);\n   }\n"
    },
    {
        "commit_hash": "5141a9400c75c5ad1aecfe5faf51f913e89efd03",
        "previous_commit_hash": "3471d03374b9be4fd38b7b02b230a12374685430",
        "diff_stats": {
            "additions": 23,
            "deletions": 12
        },
        "diff_content": "@@ -127,7 +127,7 @@ public final class AnnotationSpec {\n         }\n         if (value.getClass().isArray()) {\n           for (int i = 0; i < Array.getLength(value); i++) {\n-            addAnnotationValue(builder, method.getName(), Array.get(value, i));\n+            builder.addValue(method.getName(), Array.get(value, i));\n           }\n           continue;\n         }\n@@ -135,7 +135,7 @@ public final class AnnotationSpec {\n           builder.addMember(method.getName(), \"$L\", get((Annotation) value));\n           continue;\n         }\n-        addAnnotationValue(builder, method.getName(), value);\n+        builder.addValue(method.getName(), value);\n       }\n     } catch (Exception e) {\n       throw new RuntimeException(\"Reflecting \" + annotation + \" failed!\", e);\n@@ -143,16 +143,6 @@ public final class AnnotationSpec {\n     return builder.build();\n   }\n \n-  private static Builder addAnnotationValue(Builder builder, String name, Object value) {\n-    if (value instanceof Class<?>) return builder.addMember(name, \"$T.class\", value);\n-    if (value instanceof Enum) {\n-      return builder.addMember(name, \"$T.$L\", value.getClass(), ((Enum<?>) value).name());\n-    }\n-    if (value instanceof String) return builder.addMember(name, \"$S\", value);\n-    if (value instanceof Float) return builder.addMember(name, \"$Lf\", value);\n-    // return literal/toString anyway\n-    return builder.addMember(name, \"$L\", value);\n-  }\n   public static AnnotationSpec get(AnnotationMirror annotation) {\n     TypeElement element = (TypeElement) annotation.getAnnotationType().asElement();\n     AnnotationSpec.Builder builder = AnnotationSpec.builder(ClassName.get(element));\n@@ -226,6 +216,27 @@ public final class AnnotationSpec {\n       return this;\n     }\n \n+    /**\n+     * Delegates to {@link #addMember(String, String, Object...)}, with parameter {@code format}\n+     * depending on the given {@code value} object. Falls back to {@code \"$L\"} literal format if\n+     * the class of the given {@code value} object is not supported.\n+     */\n+    private Builder addValue(String memberName, Object value) {\n+      if (value instanceof Class<?>) {\n+        return addMember(memberName, \"$T.class\", value);\n+      }\n+      if (value instanceof Enum) {\n+        return addMember(memberName, \"$T.$L\", value.getClass(), ((Enum<?>) value).name());\n+      }\n+      if (value instanceof String) {\n+        return addMember(memberName, \"$S\", value);\n+      }\n+      if (value instanceof Float) {\n+        return addMember(memberName, \"$Lf\", value);\n+      }\n+      return addMember(memberName, \"$L\", value);\n+    }\n+\n     public AnnotationSpec build() {\n       return new AnnotationSpec(this);\n     }\n"
    },
    {
        "commit_hash": "97f40446edd5f66145bde79c4a7c0de6a88716e9",
        "previous_commit_hash": "0a08c07a229eaf482adc1c40618812ee4ff9cbdd",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -99,7 +99,7 @@\n     <module name=\"InnerAssignment\"/>\n     <!--<module name=\"MagicNumber\"/>-->\n     <module name=\"MissingSwitchDefault\"/>\n-    <module name=\"RedundantThrows\"/>\n+    <!--module name=\"RedundantThrows\"/-->\n     <module name=\"SimplifyBooleanExpression\"/>\n     <module name=\"SimplifyBooleanReturn\"/>\n \n"
    },
    {
        "commit_hash": "97f40446edd5f66145bde79c4a7c0de6a88716e9",
        "previous_commit_hash": "0a08c07a229eaf482adc1c40618812ee4ff9cbdd",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -104,7 +104,7 @@\n       <plugin>\n         <groupId>org.apache.maven.plugins</groupId>\n         <artifactId>maven-checkstyle-plugin</artifactId>\n-        <version>2.13</version>\n+        <version>2.17</version>\n         <configuration>\n           <failsOnError>true</failsOnError>\n           <configLocation>checkstyle.xml</configLocation>\n"
    },
    {
        "commit_hash": "97f40446edd5f66145bde79c4a7c0de6a88716e9",
        "previous_commit_hash": "0a08c07a229eaf482adc1c40618812ee4ff9cbdd",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -66,11 +66,11 @@ final class CodeWriter {\n     this(out, \"  \");\n   }\n \n-  public CodeWriter(Appendable out, String indent) {\n+  CodeWriter(Appendable out, String indent) {\n     this(out, indent, Collections.<String, ClassName>emptyMap());\n   }\n \n-  public CodeWriter(Appendable out, String indent, Map<String, ClassName> importedTypes) {\n+  CodeWriter(Appendable out, String indent, Map<String, ClassName> importedTypes) {\n     this.out = checkNotNull(out, \"out == null\");\n     this.indent = checkNotNull(indent, \"indent == null\");\n     this.importedTypes = checkNotNull(importedTypes, \"importedTypes == null\");\n"
    },
    {
        "commit_hash": "97f40446edd5f66145bde79c4a7c0de6a88716e9",
        "previous_commit_hash": "0a08c07a229eaf482adc1c40618812ee4ff9cbdd",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -321,7 +321,7 @@ public final class TypeSpec {\n     private final Set<Modifier> implicitTypeModifiers;\n     private final Set<Modifier> asMemberModifiers;\n \n-    private Kind(Set<Modifier> implicitFieldModifiers,\n+    Kind(Set<Modifier> implicitFieldModifiers,\n         Set<Modifier> implicitMethodModifiers,\n         Set<Modifier> implicitTypeModifiers,\n         Set<Modifier> asMemberModifiers) {\n"
    },
    {
        "commit_hash": "b162ce2270c6a4039a85e29258a47e190643dd10",
        "previous_commit_hash": "19b8ecd35f67ace7d21b0cb96703856a1fd7b4af",
        "diff_stats": {
            "additions": 20,
            "deletions": 9
        },
        "diff_content": "@@ -15,12 +15,12 @@\n  */\n package com.squareup.javapoet;\n \n-import com.sun.tools.javac.nio.JavacPathFileManager;\n-import com.sun.tools.javac.nio.PathFileManager;\n-import com.sun.tools.javac.util.Context;\n import java.io.IOException;\n+import java.io.OutputStream;\n import java.nio.file.FileSystem;\n+import java.nio.file.Files;\n import java.nio.file.Path;\n+import java.nio.file.spi.FileSystemProvider;\n import java.util.Arrays;\n import java.util.LinkedHashMap;\n import java.util.Map;\n@@ -30,20 +30,31 @@ import javax.lang.model.element.Element;\n import javax.tools.FileObject;\n import javax.tools.JavaFileManager;\n import javax.tools.JavaFileObject;\n-\n-import static java.nio.charset.StandardCharsets.UTF_8;\n+import javax.tools.SimpleJavaFileObject;\n \n final class TestFiler implements Filer {\n+  class Source extends SimpleJavaFileObject {\n+    private final Path path;\n+    protected Source(Path path) {\n+      super(path.toUri(), Kind.SOURCE);\n+      this.path = path;\n+    }\n+    @Override public OutputStream openOutputStream() throws IOException {\n+      Path parent = path.getParent();\n+      if (!Files.exists(parent)) fileSystemProvider.createDirectory(parent);\n+      return fileSystemProvider.newOutputStream(path);\n+    }\n+  }\n+\n   private final String separator;\n   private final Path fileSystemRoot;\n-  private final PathFileManager fileManager;\n+  private final FileSystemProvider fileSystemProvider;\n   private final Map<Path, Set<Element>> originatingElementsMap;\n \n   public TestFiler(FileSystem fileSystem, Path fsRoot) {\n     separator = fileSystem.getSeparator();\n     fileSystemRoot = fsRoot;\n-    fileManager = new JavacPathFileManager(new Context(), false, UTF_8);\n-    fileManager.setDefaultFileSystem(fileSystem);\n+    fileSystemProvider = fileSystem.provider();\n     originatingElementsMap = new LinkedHashMap<>();\n   }\n \n@@ -56,7 +67,7 @@ final class TestFiler implements Filer {\n     String relative = name.toString().replace(\".\", separator) + \".java\"; // Assumes well-formed.\n     Path path = fileSystemRoot.resolve(relative);\n     originatingElementsMap.put(path, Util.immutableSet(Arrays.asList(originatingElements)));\n-    return fileManager.getJavaFileObjects(path).iterator().next();\n+    return new Source(path);\n   }\n \n   @Override public JavaFileObject createClassFile(CharSequence name, Element... originatingElements)\n"
    },
    {
        "commit_hash": "9eec3e9ad28e035566744d784b1dab289a75c564",
        "previous_commit_hash": "6e8b62a6d8636be085ff9e857344d49cd8bdca75",
        "diff_stats": {
            "additions": 3,
            "deletions": 0
        },
        "diff_content": "@@ -234,6 +234,9 @@ public final class AnnotationSpec {\n       if (value instanceof Float) {\n         return addMember(memberName, \"$Lf\", value);\n       }\n+      if (value instanceof Character) {\n+        return addMember(memberName, \"'$L'\", value);\n+      }\n       return addMember(memberName, \"$L\", value);\n     }\n \n"
    },
    {
        "commit_hash": "9eec3e9ad28e035566744d784b1dab289a75c564",
        "previous_commit_hash": "6e8b62a6d8636be085ff9e857344d49cd8bdca75",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -313,7 +313,7 @@ public final class AnnotationSpecTest {\n         + \"    d = 8,\\n\"\n         + \"    e = 9.0f,\\n\"\n         + \"    f = 11.1,\\n\"\n-        + \"    g = k,\\n\"\n+        + \"    g = 'k',\\n\"\n         + \"    h = true,\\n\"\n         + \"    i = AnnotationSpecTest.Breakfast.WAFFLES,\\n\"\n         + \"    j = @AnnotationSpecTest.AnnotationA,\\n\"\n"
    },
    {
        "commit_hash": "757e123353dd7ab964c7c6178cdf34d955484bdb",
        "previous_commit_hash": "9eec3e9ad28e035566744d784b1dab289a75c564",
        "diff_stats": {
            "additions": 5,
            "deletions": 1
        },
        "diff_content": "@@ -235,7 +235,11 @@ public final class AnnotationSpec {\n         return addMember(memberName, \"$Lf\", value);\n       }\n       if (value instanceof Character) {\n-        return addMember(memberName, \"'$L'\", value);\n+        String literal = CodeWriter.stringLiteral(value.toString(), \"\");\n+        literal = literal.substring(1, literal.length() - 1);\n+        if (literal.equals(\"\\\\\\\"\")) literal = \"\\\"\";\n+        if (literal.equals(\"'\")) literal = \"\\\\'\";\n+        return addMember(memberName, \"'$L'\", literal);\n       }\n       return addMember(memberName, \"$L\", value);\n     }\n"
    },
    {
        "commit_hash": "757e123353dd7ab964c7c6178cdf34d955484bdb",
        "previous_commit_hash": "9eec3e9ad28e035566744d784b1dab289a75c564",
        "diff_stats": {
            "additions": 4,
            "deletions": 0
        },
        "diff_content": "@@ -419,6 +419,10 @@ final class CodeWriter {\n \n   /** Returns the string literal representing {@code data}, including wrapping quotes. */\n   String stringLiteral(String value) {\n+    return stringLiteral(value, indent);\n+  }\n+\n+  static String stringLiteral(String value, String indent) {\n     StringBuilder result = new StringBuilder();\n     result.append('\"');\n     for (int i = 0; i < value.length(); i++) {\n"
    },
    {
        "commit_hash": "757e123353dd7ab964c7c6178cdf34d955484bdb",
        "previous_commit_hash": "9eec3e9ad28e035566744d784b1dab289a75c564",
        "diff_stats": {
            "additions": 11,
            "deletions": 2
        },
        "diff_content": "@@ -62,7 +62,7 @@ public final class AnnotationSpecTest {\n \n     double f() default 10.0;\n \n-    char g() default 'k';\n+    char[] g() default {0, 0xCAFE, 'z', '\u20ac', '\"', '\\'', '\\t', '\\n'};\n \n     boolean h() default true;\n \n@@ -313,7 +313,16 @@ public final class AnnotationSpecTest {\n         + \"    d = 8,\\n\"\n         + \"    e = 9.0f,\\n\"\n         + \"    f = 11.1,\\n\"\n-        + \"    g = 'k',\\n\"\n+        + \"    g = {\\n\"\n+        + \"        '\\\\u0000',\\n\"\n+        + \"        '\ucafe',\\n\"\n+        + \"        'z',\\n\"\n+        + \"        '\u20ac',\\n\"\n+        + \"        '\\\"',\\n\"\n+        + \"        '\\\\'',\\n\"\n+        + \"        '\\\\t',\\n\"\n+        + \"        '\\\\n'\\n\"\n+        + \"    },\\n\"\n         + \"    h = true,\\n\"\n         + \"    i = AnnotationSpecTest.Breakfast.WAFFLES,\\n\"\n         + \"    j = @AnnotationSpecTest.AnnotationA,\\n\"\n"
    },
    {
        "commit_hash": "caabf2c227a7e8a6a2496c2de9baf1528d21065b",
        "previous_commit_hash": "512e2169209eecea05862c9bbe5e2dc51474ddd4",
        "diff_stats": {
            "additions": 64,
            "deletions": 5
        },
        "diff_content": "@@ -23,10 +23,12 @@ import java.util.Formatter;\n import java.util.LinkedHashMap;\n import java.util.LinkedHashSet;\n import java.util.List;\n+import java.util.ListIterator;\n import java.util.Locale;\n import java.util.Map;\n import java.util.Objects;\n import java.util.Set;\n+import javax.lang.model.SourceVersion;\n import javax.lang.model.element.Modifier;\n \n import static com.squareup.javapoet.Util.checkArgument;\n@@ -50,6 +52,8 @@ final class CodeWriter {\n   private boolean comment = false;\n   private String packageName = NO_PACKAGE;\n   private final List<TypeSpec> typeSpecStack = new ArrayList<>();\n+  private final Set<String> staticImportClassNames;\n+  private final Set<String> staticImports;\n   private final Map<String, ClassName> importedTypes;\n   private final Map<String, ClassName> importableTypes = new LinkedHashMap<>();\n   private final Set<String> referencedNames = new LinkedHashSet<>();\n@@ -63,17 +67,23 @@ final class CodeWriter {\n   int statementLine = -1;\n \n   CodeWriter(Appendable out) {\n-    this(out, \"  \");\n+    this(out, \"  \", Collections.<String>emptySet());\n   }\n \n-  CodeWriter(Appendable out, String indent) {\n-    this(out, indent, Collections.<String, ClassName>emptyMap());\n+  CodeWriter(Appendable out, String indent, Set<String> staticImports) {\n+    this(out, indent, Collections.<String, ClassName>emptyMap(), staticImports);\n   }\n \n-  CodeWriter(Appendable out, String indent, Map<String, ClassName> importedTypes) {\n+  CodeWriter(Appendable out, String indent, Map<String, ClassName> importedTypes,\n+      Set<String> staticImports) {\n     this.out = checkNotNull(out, \"out == null\");\n     this.indent = checkNotNull(indent, \"indent == null\");\n     this.importedTypes = checkNotNull(importedTypes, \"importedTypes == null\");\n+    this.staticImports = checkNotNull(staticImports, \"staticImports == null\");\n+    this.staticImportClassNames = new LinkedHashSet<>();\n+    for (String signature : staticImports) {\n+      staticImportClassNames.add(signature.substring(0, signature.lastIndexOf('.')));\n+    }\n   }\n \n   public Map<String, ClassName> importedTypes() {\n@@ -198,7 +208,10 @@ final class CodeWriter {\n \n   public CodeWriter emit(CodeBlock codeBlock) throws IOException {\n     int a = 0;\n-    for (String part : codeBlock.formatParts) {\n+    ClassName deferredTypeName = null; // used by \"import static\" logic\n+    ListIterator<String> partIterator = codeBlock.formatParts.listIterator();\n+    while (partIterator.hasNext()) {\n+      String part = partIterator.next();\n       switch (part) {\n         case \"$L\":\n           emitLiteral(codeBlock.args.get(a++));\n@@ -218,6 +231,17 @@ final class CodeWriter {\n \n         case \"$T\":\n           TypeName typeName = (TypeName) codeBlock.args.get(a++);\n+          // defer \"typeName.emit(this)\" if next format part will be handled by the default case\n+          if (typeName instanceof ClassName && partIterator.hasNext()) {\n+            if (!codeBlock.formatParts.get(partIterator.nextIndex()).startsWith(\"$\")) {\n+              ClassName candidate = (ClassName) typeName;\n+              if (staticImportClassNames.contains(candidate.canonicalName)) {\n+                checkState(deferredTypeName == null, \"pending type for static import?!\");\n+                deferredTypeName = candidate;\n+                break;\n+              }\n+            }\n+          }\n           typeName.emit(this);\n           break;\n \n@@ -247,6 +271,18 @@ final class CodeWriter {\n           break;\n \n         default:\n+          // handle deferred type\n+          if (deferredTypeName != null) {\n+            if (part.startsWith(\".\")) {\n+              if (emitStaticImportMember(deferredTypeName.canonicalName, part)) {\n+                // okay, static import hit and all was emitted, so clean-up and jump to next part\n+                deferredTypeName = null;\n+                break;\n+              }\n+            }\n+            deferredTypeName.emit(this);\n+            deferredTypeName = null;\n+          }\n           emitAndIndent(part);\n           break;\n       }\n@@ -254,6 +290,29 @@ final class CodeWriter {\n     return this;\n   }\n \n+  private static String gleanMemberName(String part) {\n+    for (int i = 1; i <= part.length(); i++) {\n+      if (!SourceVersion.isIdentifier(part.substring(0, i))) {\n+        return part.substring(0, i - 1);\n+      }\n+    }\n+    return part;\n+  }\n+\n+  private boolean emitStaticImportMember(String canonical, String part) throws IOException {\n+    String partWithoutLeadingDot = part.substring(1);\n+    char first = partWithoutLeadingDot.charAt(0);\n+    if (!partWithoutLeadingDot.isEmpty() && Character.isJavaIdentifierStart(first)) {\n+      String explicit = canonical + \".\" + gleanMemberName(partWithoutLeadingDot);\n+      String wildcard = canonical + \".*\";\n+      if (staticImports.contains(explicit) || staticImports.contains(wildcard)) {\n+        emitAndIndent(partWithoutLeadingDot);\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n   private void emitLiteral(Object o) throws IOException {\n     if (o instanceof TypeSpec) {\n       TypeSpec typeSpec = (TypeSpec) o;\n"
    },
    {
        "commit_hash": "caabf2c227a7e8a6a2496c2de9baf1528d21065b",
        "previous_commit_hash": "512e2169209eecea05862c9bbe5e2dc51474ddd4",
        "diff_stats": {
            "additions": 34,
            "deletions": 3
        },
        "diff_content": "@@ -24,9 +24,11 @@ import java.io.Writer;\n import java.net.URI;\n import java.nio.file.Files;\n import java.nio.file.Path;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n import java.util.TreeSet;\n import javax.annotation.processing.Filer;\n import javax.lang.model.element.Element;\n@@ -56,6 +58,7 @@ public final class JavaFile {\n   public final String packageName;\n   public final TypeSpec typeSpec;\n   public final boolean skipJavaLangImports;\n+  private final Set<String> staticImports;\n   private final String indent;\n \n   private JavaFile(Builder builder) {\n@@ -63,17 +66,18 @@ public final class JavaFile {\n     this.packageName = builder.packageName;\n     this.typeSpec = builder.typeSpec;\n     this.skipJavaLangImports = builder.skipJavaLangImports;\n+    this.staticImports = Util.immutableSet(builder.staticImports);\n     this.indent = builder.indent;\n   }\n \n   public void writeTo(Appendable out) throws IOException {\n     // First pass: emit the entire class, just to collect the types we'll need to import.\n-    CodeWriter importsCollector = new CodeWriter(NULL_APPENDABLE, indent);\n+    CodeWriter importsCollector = new CodeWriter(NULL_APPENDABLE, indent, staticImports);\n     emit(importsCollector);\n     Map<String, ClassName> suggestedImports = importsCollector.suggestedImports();\n \n     // Second pass: write the code, taking advantage of the imports.\n-    CodeWriter codeWriter = new CodeWriter(out, indent, suggestedImports);\n+    CodeWriter codeWriter = new CodeWriter(out, indent, suggestedImports, staticImports);\n     emit(codeWriter);\n   }\n \n@@ -131,6 +135,13 @@ public final class JavaFile {\n       codeWriter.emit(\"\\n\");\n     }\n \n+    if (!staticImports.isEmpty()) {\n+      for (String signature : staticImports) {\n+        codeWriter.emit(\"import static $L;\\n\", signature);\n+      }\n+      codeWriter.emit(\"\\n\");\n+    }\n+\n     int importedTypesCount = 0;\n     for (ClassName className : new TreeSet<>(codeWriter.importedTypes().values())) {\n       if (skipJavaLangImports && className.packageName().equals(\"java.lang\")) continue;\n@@ -204,7 +215,8 @@ public final class JavaFile {\n   public static final class Builder {\n     private final String packageName;\n     private final TypeSpec typeSpec;\n-    private CodeBlock.Builder fileComment = CodeBlock.builder();\n+    private final CodeBlock.Builder fileComment = CodeBlock.builder();\n+    private final Set<String> staticImports = new TreeSet<>();\n     private boolean skipJavaLangImports;\n     private String indent = \"  \";\n \n@@ -218,6 +230,25 @@ public final class JavaFile {\n       return this;\n     }\n \n+    public Builder addStaticImport(Enum<?> constant) {\n+      return addStaticImport(ClassName.get(constant.getDeclaringClass()), constant.name());\n+    }\n+\n+    public Builder addStaticImport(Class<?> clazz, String... names) {\n+      return addStaticImport(ClassName.get(clazz), names);\n+    }\n+\n+    public Builder addStaticImport(ClassName className, String... names) {\n+      checkArgument(className != null, \"className == null\");\n+      checkArgument(names != null, \"names == null\");\n+      checkArgument(names.length > 0, \"names array is empty\");\n+      for (String name : names) {\n+        checkArgument(name != null, \"null entry in names array: %s\", Arrays.toString(names));\n+        staticImports.add(className.canonicalName + \".\" + name);\n+      }\n+      return this;\n+    }\n+\n     /**\n      * Call this to omit imports for classes in {@code java.lang}, such as {@code java.lang.String}.\n      *\n"
    },
    {
        "commit_hash": "caabf2c227a7e8a6a2496c2de9baf1528d21065b",
        "previous_commit_hash": "512e2169209eecea05862c9bbe5e2dc51474ddd4",
        "diff_stats": {
            "additions": 3,
            "deletions": 1
        },
        "diff_content": "@@ -30,6 +30,7 @@ import static com.squareup.javapoet.Util.checkNotNull;\n public final class ParameterizedTypeName extends TypeName {\n   public final ClassName rawType;\n   public final List<TypeName> typeArguments;\n+  private final int hashCode;\n \n   ParameterizedTypeName(ClassName rawType, List<TypeName> typeArguments) {\n     this(rawType, typeArguments, new ArrayList<AnnotationSpec>());\n@@ -40,6 +41,7 @@ public final class ParameterizedTypeName extends TypeName {\n     super(annotations);\n     this.rawType = checkNotNull(rawType, \"rawType == null\");\n     this.typeArguments = Util.immutableList(typeArguments);\n+    this.hashCode = rawType.hashCode() + 31 * typeArguments.hashCode();\n \n     checkArgument(!this.typeArguments.isEmpty(), \"no type arguments: %s\", rawType);\n     for (TypeName typeArgument : this.typeArguments) {\n@@ -59,7 +61,7 @@ public final class ParameterizedTypeName extends TypeName {\n   }\n \n   @Override public int hashCode() {\n-    return rawType.hashCode() + 31 * typeArguments.hashCode();\n+    return hashCode;\n   }\n \n   @Override CodeWriter emit(CodeWriter out) throws IOException {\n"
    },
    {
        "commit_hash": "caabf2c227a7e8a6a2496c2de9baf1528d21065b",
        "previous_commit_hash": "512e2169209eecea05862c9bbe5e2dc51474ddd4",
        "diff_stats": {
            "additions": 3,
            "deletions": 2
        },
        "diff_content": "@@ -163,11 +163,12 @@ public class TypeName {\n     if (this == o) return true;\n     if (o == null) return false;\n     if (getClass() != o.getClass()) return false;\n-    return toString().equals(o.toString());\n+    return keyword.equals(((TypeName) o).keyword);\n   }\n \n   @Override public int hashCode() {\n-    return toString().hashCode();\n+    if (keyword == null) throw new AssertionError();\n+    return keyword.hashCode();\n   }\n \n   @Override public final String toString() {\n"
    },
    {
        "commit_hash": "caabf2c227a7e8a6a2496c2de9baf1528d21065b",
        "previous_commit_hash": "512e2169209eecea05862c9bbe5e2dc51474ddd4",
        "diff_stats": {
            "additions": 3,
            "deletions": 1
        },
        "diff_content": "@@ -34,6 +34,7 @@ import static com.squareup.javapoet.Util.checkNotNull;\n public final class TypeVariableName extends TypeName {\n   public final String name;\n   public final List<TypeName> bounds;\n+  private final int hashCode;\n \n   private TypeVariableName(String name, List<TypeName> bounds) {\n     this(name, bounds, new ArrayList<AnnotationSpec>());\n@@ -43,6 +44,7 @@ public final class TypeVariableName extends TypeName {\n     super(annotations);\n     this.name = checkNotNull(name, \"name == null\");\n     this.bounds = bounds;\n+    this.hashCode = name.hashCode() ^ bounds.hashCode();\n \n     for (TypeName bound : this.bounds) {\n       checkArgument(!bound.isPrimitive() && bound != VOID, \"invalid bound: %s\", bound);\n@@ -67,7 +69,7 @@ public final class TypeVariableName extends TypeName {\n   }\n \n   @Override public int hashCode() {\n-    return name.hashCode() ^ bounds.hashCode();\n+    return hashCode;\n   }\n \n   @Override CodeWriter emit(CodeWriter out) throws IOException {\n"
    },
    {
        "commit_hash": "caabf2c227a7e8a6a2496c2de9baf1528d21065b",
        "previous_commit_hash": "512e2169209eecea05862c9bbe5e2dc51474ddd4",
        "diff_stats": {
            "additions": 3,
            "deletions": 1
        },
        "diff_content": "@@ -32,6 +32,7 @@ import static com.squareup.javapoet.Util.checkArgument;\n public final class WildcardTypeName extends TypeName {\n   public final List<TypeName> upperBounds;\n   public final List<TypeName> lowerBounds;\n+  private final int hashCode;\n \n   private WildcardTypeName(List<TypeName> upperBounds, List<TypeName> lowerBounds) {\n     this(upperBounds, lowerBounds, new ArrayList<AnnotationSpec>());\n@@ -42,6 +43,7 @@ public final class WildcardTypeName extends TypeName {\n     super(annotations);\n     this.upperBounds = Util.immutableList(upperBounds);\n     this.lowerBounds = Util.immutableList(lowerBounds);\n+    this.hashCode = upperBounds.hashCode() ^ lowerBounds.hashCode();\n \n     checkArgument(this.upperBounds.size() == 1, \"unexpected extends bounds: %s\", upperBounds);\n     for (TypeName upperBound : this.upperBounds) {\n@@ -65,7 +67,7 @@ public final class WildcardTypeName extends TypeName {\n   }\n \n   @Override public int hashCode() {\n-    return upperBounds.hashCode() ^ lowerBounds.hashCode();\n+    return hashCode;\n   }\n \n   @Override CodeWriter emit(CodeWriter out) throws IOException {\n"
    },
    {
        "commit_hash": "caabf2c227a7e8a6a2496c2de9baf1528d21065b",
        "previous_commit_hash": "512e2169209eecea05862c9bbe5e2dc51474ddd4",
        "diff_stats": {
            "additions": 138,
            "deletions": 0
        },
        "diff_content": "@@ -16,6 +16,7 @@\n package com.squareup.javapoet;\n \n import java.util.Date;\n+import java.util.concurrent.TimeUnit;\n import javax.lang.model.element.Modifier;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n@@ -25,6 +26,143 @@ import static com.google.common.truth.Truth.assertThat;\n \n @RunWith(JUnit4.class)\n public final class JavaFileTest {\n+  @Test public void importStaticForCrazyFormatsWorks() {\n+    JavaFile.builder(\"com.squareup.tacos\",\n+        TypeSpec.classBuilder(\"Taco\")\n+            .addStaticBlock(CodeBlock.builder()\n+                .addStatement(\"$T$T\", Runtime.class, Runtime.class)\n+                .addStatement(\"$1T$1T\", Runtime.class)\n+                .addStatement(\"$1T$2L$1T\", Runtime.class, \"?\")\n+                .addStatement(\"$1T$2L$2S$1T\", Runtime.class, \"?\")\n+                .build())\n+            .build())\n+        .addStaticImport(Runtime.class, \"*\")\n+        .build()\n+        .toString();\n+  }\n+\n+  @Test public void importStaticMixed() {\n+    JavaFile source = JavaFile.builder(\"com.squareup.tacos\",\n+        TypeSpec.classBuilder(\"Taco\")\n+            .addStaticBlock(CodeBlock.builder()\n+                .addStatement(\"assert $1T.valueOf(\\\"BLOCKED\\\") == $1T.BLOCKED\", Thread.State.class)\n+                .addStatement(\"$T.gc()\", System.class)\n+                .addStatement(\"$1T.out.println($1T.nanoTime())\", System.class)\n+                .build())\n+            .addMethod(MethodSpec.constructorBuilder()\n+                .addParameter(Thread.State[].class, \"states\")\n+                .varargs(true)\n+                .build())\n+            .build())\n+        .addStaticImport(Thread.State.BLOCKED)\n+        .addStaticImport(System.class, \"*\")\n+        .addStaticImport(Thread.State.class, \"valueOf\")\n+        .build();\n+    assertThat(source.toString()).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import static java.lang.System.*;\\n\"\n+        + \"import static java.lang.Thread.State.BLOCKED;\\n\"\n+        + \"import static java.lang.Thread.State.valueOf;\\n\"\n+        + \"\\n\"\n+        + \"import java.lang.Thread;\\n\"\n+        + \"\\n\"\n+        + \"class Taco {\\n\"\n+        + \"  static {\\n\"\n+        + \"    assert valueOf(\\\"BLOCKED\\\") == BLOCKED;\\n\"\n+        + \"    gc();\\n\"\n+        + \"    out.println(nanoTime());\\n\"\n+        + \"  }\\n\"\n+        + \"\\n\"\n+        + \"  Taco(Thread.State... states) {\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void importStaticNone() {\n+    assertThat(JavaFile.builder(\"readme\", importStaticTypeSpec(\"Util\"))\n+        .build().toString()).isEqualTo(\"\"\n+        + \"package readme;\\n\"\n+        + \"\\n\"\n+        + \"import java.lang.System;\\n\"\n+        + \"import java.util.concurrent.TimeUnit;\\n\"\n+        + \"\\n\"\n+        + \"class Util {\\n\"\n+        + \"  public static long minutesToSeconds(long minutes) {\\n\"\n+        + \"    System.gc();\\n\"\n+        + \"    return TimeUnit.SECONDS.convert(minutes, TimeUnit.MINUTES);\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void importStaticOnce() {\n+    assertThat(JavaFile.builder(\"readme\", importStaticTypeSpec(\"Util\"))\n+        .addStaticImport(TimeUnit.SECONDS)\n+        .build().toString()).isEqualTo(\"\"\n+        + \"package readme;\\n\"\n+        + \"\\n\"\n+        + \"import static java.util.concurrent.TimeUnit.SECONDS;\\n\"\n+        + \"\\n\"\n+        + \"import java.lang.System;\\n\"\n+        + \"import java.util.concurrent.TimeUnit;\\n\"\n+        + \"\\n\"\n+        + \"class Util {\\n\"\n+        + \"  public static long minutesToSeconds(long minutes) {\\n\"\n+        + \"    System.gc();\\n\"\n+        + \"    return SECONDS.convert(minutes, TimeUnit.MINUTES);\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void importStaticTwice() {\n+    assertThat(JavaFile.builder(\"readme\", importStaticTypeSpec(\"Util\"))\n+        .addStaticImport(TimeUnit.SECONDS)\n+        .addStaticImport(TimeUnit.MINUTES)\n+        .build().toString()).isEqualTo(\"\"\n+            + \"package readme;\\n\"\n+            + \"\\n\"\n+            + \"import static java.util.concurrent.TimeUnit.MINUTES;\\n\"\n+            + \"import static java.util.concurrent.TimeUnit.SECONDS;\\n\"\n+            + \"\\n\"\n+            + \"import java.lang.System;\\n\"\n+            + \"\\n\"\n+            + \"class Util {\\n\"\n+            + \"  public static long minutesToSeconds(long minutes) {\\n\"\n+            + \"    System.gc();\\n\"\n+            + \"    return SECONDS.convert(minutes, MINUTES);\\n\"\n+            + \"  }\\n\"\n+            + \"}\\n\");\n+  }\n+\n+  @Test public void importStaticUsingWildcards() {\n+    assertThat(JavaFile.builder(\"readme\", importStaticTypeSpec(\"Util\"))\n+        .addStaticImport(TimeUnit.class, \"*\")\n+        .addStaticImport(System.class, \"*\")\n+        .build().toString()).isEqualTo(\"\"\n+            + \"package readme;\\n\"\n+            + \"\\n\"\n+            + \"import static java.lang.System.*;\\n\"\n+            + \"import static java.util.concurrent.TimeUnit.*;\\n\"\n+            + \"\\n\"\n+            + \"class Util {\\n\"\n+            + \"  public static long minutesToSeconds(long minutes) {\\n\"\n+            + \"    gc();\\n\"\n+            + \"    return SECONDS.convert(minutes, MINUTES);\\n\"\n+            + \"  }\\n\"\n+            + \"}\\n\");\n+  }\n+\n+  private TypeSpec importStaticTypeSpec(String name) {\n+    MethodSpec method = MethodSpec.methodBuilder(\"minutesToSeconds\")\n+        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n+        .returns(long.class)\n+        .addParameter(long.class, \"minutes\")\n+        .addStatement(\"$T.gc()\", System.class)\n+        .addStatement(\"return $1T.SECONDS.convert(minutes, $1T.MINUTES)\", TimeUnit.class)\n+        .build();\n+    return TypeSpec.classBuilder(name).addMethod(method).build();\n+\n+  }\n   @Test public void noImports() throws Exception {\n     String source = JavaFile.builder(\"com.squareup.tacos\",\n         TypeSpec.classBuilder(\"Taco\").build())\n"
    },
    {
        "commit_hash": "e28883e53aec58121b5ca039c505e0c66935bfd6",
        "previous_commit_hash": "b07f520f0b14acce1feea56ad6582305d4cf8ca1",
        "diff_stats": {
            "additions": 11,
            "deletions": 0
        },
        "diff_content": "@@ -1,6 +1,17 @@\n Change Log\n ==========\n \n+JavaPoet 1.5.0-SNAPSHOT *(not yet released)*\n+----------------------------\n+\n+ * New: `import static`! See `JavaFile.Builder.addStaticImport()` variants.\n+ * New: Overload `NameAllocator.newName(String)` for creating a one-off name without a tag.\n+ * Fix: AnnotationSpec escapes character literals properly.\n+ * Fix: Don't stack overflow when `TypeVariableName` is part of `ParameterizedTypeName`.\n+ * Fix: Reporting not used indexed arguments in like `add(\"$1S\", \"a\", \"b\")`.\n+ * Fix: Prevent import of types located in the default package, i.e. have no package name.\n+\n+\n JavaPoet 1.4.0 *(2015-11-13)*\n ----------------------------\n \n"
    },
    {
        "commit_hash": "e28883e53aec58121b5ca039c505e0c66935bfd6",
        "previous_commit_hash": "b07f520f0b14acce1feea56ad6582305d4cf8ca1",
        "diff_stats": {
            "additions": 57,
            "deletions": 1
        },
        "diff_content": "@@ -274,7 +274,7 @@ ClassName list = ClassName.get(\"java.util\", \"List\");\n ClassName arrayList = ClassName.get(\"java.util\", \"ArrayList\");\n TypeName listOfHoverboards = ParameterizedTypeName.get(list, hoverboard);\n \n-MethodSpec today = MethodSpec.methodBuilder(\"beyond\")\n+MethodSpec beyond = MethodSpec.methodBuilder(\"beyond\")\n     .returns(listOfHoverboards)\n     .addStatement(\"$T result = new $T<>()\", listOfHoverboards, arrayList)\n     .addStatement(\"result.add(new $T())\", hoverboard)\n@@ -304,6 +304,62 @@ public final class HelloWorld {\n }\n ```\n \n+#### Import static\n+\n+JavaPoet supports `import static`. It does it via explicitly collecting type member names. Let's\n+enhance the previous example with some static sugar:\n+\n+```java\n+...\n+ClassName namedBoards = ClassName.get(\"com.mattel\", \"Hoverboard\", \"Boards\");\n+\n+MethodSpec beyond = MethodSpec.methodBuilder(\"beyond\")\n+    .returns(listOfHoverboards)\n+    .addStatement(\"$T result = new $T<>()\", listOfHoverboards, arrayList)\n+    .addStatement(\"result.add($T.createNimbus(2000))\", hoverboard)\n+    .addStatement(\"result.add($T.createNimbus(\\\"2001\\\"))\", hoverboard)\n+    .addStatement(\"result.add($T.createNimbus($T.THUNDERBOLT))\", namedBoards)\n+    .addStatement(\"$T.sort(result)\", Collections.class)\n+    .addStatement(\"return result.isEmpty() $T.emptyList() : result\", Collections.class)\n+    .build();\n+\n+TypeSpec hello = TypeSpec.classBuilder(\"HelloWorld\")\n+    .addMethod(beyond)\n+    .build();\n+\n+JavaFile.builder(\"com.example.helloworld\", hello)\n+    .addStaticImport(hoverboard, \"createNimbus\")\n+    .addStaticImport(namedBoards, \"*\")\n+    .addStaticImport(Collections.class, \"*\")\n+    .build();\n+```\n+\n+JavaPoet will first add your `import static` block to the file as configured, match and mangle\n+all calls accordingly and also import all other types as needed.\n+\n+```java\n+package com.example.helloworld;\n+\n+import static com.mattel.Hoverboard.Boards.*;\n+import static com.mattel.Hoverboard.createNimbus;\n+import static java.util.Collections.*;\n+\n+import com.mattel.Hoverboard;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+class HelloWorld {\n+  List<Hoverboard> beyond() {\n+    List<Hoverboard> result = new ArrayList<>();\n+    result.add(createNimbus(2000));\n+    result.add(createNimbus(\"2001\"));\n+    result.add(createNimbus(THUNDERBOLT));\n+    sort(result);\n+    return result.isEmpty() ? emptyList() : result;\n+  }\n+}\n+```\n+\n ### $N for Names\n \n Generated code is often self-referential. Use **`$N`** to refer to another generated declaration by\n"
    },
    {
        "commit_hash": "e28883e53aec58121b5ca039c505e0c66935bfd6",
        "previous_commit_hash": "b07f520f0b14acce1feea56ad6582305d4cf8ca1",
        "diff_stats": {
            "additions": 9,
            "deletions": 8
        },
        "diff_content": "@@ -290,7 +290,8 @@ final class CodeWriter {\n     return this;\n   }\n \n-  private static String gleanMemberName(String part) {\n+  private static String extractMemberName(String part) {\n+    checkArgument(Character.isJavaIdentifierStart(part.charAt(0)), \"not an identifier: %s\", part);\n     for (int i = 1; i <= part.length(); i++) {\n       if (!SourceVersion.isIdentifier(part.substring(0, i))) {\n         return part.substring(0, i - 1);\n@@ -301,14 +302,14 @@ final class CodeWriter {\n \n   private boolean emitStaticImportMember(String canonical, String part) throws IOException {\n     String partWithoutLeadingDot = part.substring(1);\n+    if (partWithoutLeadingDot.isEmpty()) return false;\n     char first = partWithoutLeadingDot.charAt(0);\n-    if (!partWithoutLeadingDot.isEmpty() && Character.isJavaIdentifierStart(first)) {\n-      String explicit = canonical + \".\" + gleanMemberName(partWithoutLeadingDot);\n-      String wildcard = canonical + \".*\";\n-      if (staticImports.contains(explicit) || staticImports.contains(wildcard)) {\n-        emitAndIndent(partWithoutLeadingDot);\n-        return true;\n-      }\n+    if (!Character.isJavaIdentifierStart(first)) return false;\n+    String explicit = canonical + \".\" + extractMemberName(partWithoutLeadingDot);\n+    String wildcard = canonical + \".*\";\n+    if (staticImports.contains(explicit) || staticImports.contains(wildcard)) {\n+      emitAndIndent(partWithoutLeadingDot);\n+      return true;\n     }\n     return false;\n   }\n"
    },
    {
        "commit_hash": "e28883e53aec58121b5ca039c505e0c66935bfd6",
        "previous_commit_hash": "b07f520f0b14acce1feea56ad6582305d4cf8ca1",
        "diff_stats": {
            "additions": 56,
            "deletions": 1
        },
        "diff_content": "@@ -15,6 +15,7 @@\n  */\n package com.squareup.javapoet;\n \n+import java.util.Collections;\n import java.util.Date;\n import java.util.concurrent.TimeUnit;\n import javax.lang.model.element.Modifier;\n@@ -26,19 +27,73 @@ import static com.google.common.truth.Truth.assertThat;\n \n @RunWith(JUnit4.class)\n public final class JavaFileTest {\n+  @Test public void importStaticReadmeExample() {\n+    ClassName hoverboard = ClassName.get(\"com.mattel\", \"Hoverboard\");\n+    ClassName namedBoards = ClassName.get(\"com.mattel\", \"Hoverboard\", \"Boards\");\n+    ClassName list = ClassName.get(\"java.util\", \"List\");\n+    ClassName arrayList = ClassName.get(\"java.util\", \"ArrayList\");\n+    TypeName listOfHoverboards = ParameterizedTypeName.get(list, hoverboard);\n+    MethodSpec beyond = MethodSpec.methodBuilder(\"beyond\")\n+        .returns(listOfHoverboards)\n+        .addStatement(\"$T result = new $T<>()\", listOfHoverboards, arrayList)\n+        .addStatement(\"result.add($T.createNimbus(2000))\", hoverboard)\n+        .addStatement(\"result.add($T.createNimbus(\\\"2001\\\"))\", hoverboard)\n+        .addStatement(\"result.add($T.createNimbus($T.THUNDERBOLT))\", hoverboard, namedBoards)\n+        .addStatement(\"$T.sort(result)\", Collections.class)\n+        .addStatement(\"return result.isEmpty() $T.emptyList() : result\", Collections.class)\n+        .build();\n+    TypeSpec hello = TypeSpec.classBuilder(\"HelloWorld\")\n+        .addMethod(beyond)\n+        .build();\n+    JavaFile example = JavaFile.builder(\"com.example.helloworld\", hello)\n+        .addStaticImport(hoverboard, \"createNimbus\")\n+        .addStaticImport(namedBoards, \"*\")\n+        .addStaticImport(Collections.class, \"*\")\n+        .build();\n+    assertThat(example.toString()).isEqualTo(\"\"\n+        + \"package com.example.helloworld;\\n\"\n+        + \"\\n\"\n+        + \"import static com.mattel.Hoverboard.Boards.*;\\n\"\n+        + \"import static com.mattel.Hoverboard.createNimbus;\\n\"\n+        + \"import static java.util.Collections.*;\\n\"\n+        + \"\\n\"\n+        + \"import com.mattel.Hoverboard;\\n\"\n+        + \"import java.util.ArrayList;\\n\"\n+        + \"import java.util.List;\\n\"\n+        + \"\\n\"\n+        + \"class HelloWorld {\\n\"\n+        + \"  List<Hoverboard> beyond() {\\n\"\n+        + \"    List<Hoverboard> result = new ArrayList<>();\\n\"\n+        + \"    result.add(createNimbus(2000));\\n\"\n+        + \"    result.add(createNimbus(\\\"2001\\\"));\\n\"\n+        + \"    result.add(createNimbus(THUNDERBOLT));\\n\"\n+        + \"    sort(result);\\n\"\n+        + \"    return result.isEmpty() emptyList() : result;\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n   @Test public void importStaticForCrazyFormatsWorks() {\n+    MethodSpec method = MethodSpec.methodBuilder(\"method\").build();\n     JavaFile.builder(\"com.squareup.tacos\",\n         TypeSpec.classBuilder(\"Taco\")\n             .addStaticBlock(CodeBlock.builder()\n+                .addStatement(\"$T\", Runtime.class)\n+                .addStatement(\"$T.a()\", Runtime.class)\n+                .addStatement(\"$T.X\", Runtime.class)\n                 .addStatement(\"$T$T\", Runtime.class, Runtime.class)\n+                .addStatement(\"$T.$T\", Runtime.class, Runtime.class)\n                 .addStatement(\"$1T$1T\", Runtime.class)\n                 .addStatement(\"$1T$2L$1T\", Runtime.class, \"?\")\n                 .addStatement(\"$1T$2L$2S$1T\", Runtime.class, \"?\")\n+                .addStatement(\"$1T$2L$2S$1T$3N$1T\", Runtime.class, \"?\", method)\n+                .addStatement(\"$T$L\", Runtime.class, \"?\")\n+                .addStatement(\"$T$S\", Runtime.class, \"?\")\n+                .addStatement(\"$T$N\", Runtime.class, method)\n                 .build())\n             .build())\n         .addStaticImport(Runtime.class, \"*\")\n         .build()\n-        .toString();\n+        .toString(); // don't look at the generated code...\n   }\n \n   @Test public void importStaticMixed() {\n"
    },
    {
        "commit_hash": "5f68b2c0ea5af2b93a28116748c878f32d2a58ee",
        "previous_commit_hash": "7d22a5c0879eb25810a31d454f39dca823cd2b1e",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -1,7 +1,7 @@\n Change Log\n ==========\n \n-JavaPoet 1.5.0-SNAPSHOT *(not yet released)*\n+JavaPoet 1.5.0 *(2016-01-10)*\n ----------------------------\n \n  * New: `import static`! See `JavaFile.Builder.addStaticImport()` variants.\n"
    },
    {
        "commit_hash": "d04195eda335f35ddfd547110d39eed692ef3084",
        "previous_commit_hash": "5f68b2c0ea5af2b93a28116748c878f32d2a58ee",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.5.0-SNAPSHOT</version>\n+  <version>1.5.0</version>\n \n   <name>JavaPoet</name>\n   <description>Use beautiful Java code to generate beautiful Java code.</description>\n@@ -54,13 +54,13 @@\n     <dependency>\n       <groupId>com.google.truth</groupId>\n       <artifactId>truth</artifactId>\n-      <version>1.0-SNAPSHOT</version>\n+      <version>0.28</version>\n       <scope>test</scope>\n     </dependency>\n     <dependency>\n       <groupId>com.google.testing.compile</groupId>\n       <artifactId>compile-testing</artifactId>\n-      <version>1.0-SNAPSHOT</version>\n+      <version>0.8</version>\n       <scope>test</scope>\n     </dependency>\n     <dependency>\n"
    },
    {
        "commit_hash": "70353373ead4dbf4c3db04cda72da75a05ae7b36",
        "previous_commit_hash": "d04195eda335f35ddfd547110d39eed692ef3084",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.5.0</version>\n+  <version>1.6.0-SNAPSHOT</version>\n \n   <name>JavaPoet</name>\n   <description>Use beautiful Java code to generate beautiful Java code.</description>\n@@ -54,13 +54,13 @@\n     <dependency>\n       <groupId>com.google.truth</groupId>\n       <artifactId>truth</artifactId>\n-      <version>0.28</version>\n+      <version>1.0-SNAPSHOT</version>\n       <scope>test</scope>\n     </dependency>\n     <dependency>\n       <groupId>com.google.testing.compile</groupId>\n       <artifactId>compile-testing</artifactId>\n-      <version>0.8</version>\n+      <version>1.0-SNAPSHOT</version>\n       <scope>test</scope>\n     </dependency>\n     <dependency>\n"
    },
    {
        "commit_hash": "fcdb088f4fa4ee566bb9a081b3a6a77e80b48058",
        "previous_commit_hash": "70353373ead4dbf4c3db04cda72da75a05ae7b36",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -801,12 +801,12 @@ Download [the latest .jar][dl] or depend via Maven:\n <dependency>\n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.4.0</version>\n+  <version>1.5.0</version>\n </dependency>\n ```\n or Gradle:\n ```groovy\n-compile 'com.squareup:javapoet:1.4.0'\n+compile 'com.squareup:javapoet:1.5.0'\n ```\n \n Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].\n"
    },
    {
        "commit_hash": "9ffa01c506ff040df200c164c533987d0fb58112",
        "previous_commit_hash": "fcdb088f4fa4ee566bb9a081b3a6a77e80b48058",
        "diff_stats": {
            "additions": 0,
            "deletions": 9
        },
        "diff_content": "@@ -44,15 +44,6 @@ public final class ArrayTypeName extends TypeName {\n     return new ArrayTypeName(componentType, annotations);\n   }\n \n-  @Override public boolean equals(Object o) {\n-    return o instanceof ArrayTypeName\n-        && ((ArrayTypeName) o).componentType.equals(componentType);\n-  }\n-\n-  @Override public int hashCode() {\n-    return 31 * componentType.hashCode();\n-  }\n-\n   @Override CodeWriter emit(CodeWriter out) throws IOException {\n     return emitAnnotations(out).emit(\"$T[]\", componentType);\n   }\n"
    },
    {
        "commit_hash": "9ffa01c506ff040df200c164c533987d0fb58112",
        "previous_commit_hash": "fcdb088f4fa4ee566bb9a081b3a6a77e80b48058",
        "diff_stats": {
            "additions": 0,
            "deletions": 9
        },
        "diff_content": "@@ -198,15 +198,6 @@ public final class ClassName extends TypeName implements Comparable<ClassName> {\n     return (PackageElement) type;\n   }\n \n-  @Override public boolean equals(Object o) {\n-    return o instanceof ClassName\n-        && canonicalName.equals(((ClassName) o).canonicalName);\n-  }\n-\n-  @Override public int hashCode() {\n-    return canonicalName.hashCode();\n-  }\n-\n   @Override public int compareTo(ClassName o) {\n     return canonicalName.compareTo(o.canonicalName);\n   }\n"
    },
    {
        "commit_hash": "9ffa01c506ff040df200c164c533987d0fb58112",
        "previous_commit_hash": "fcdb088f4fa4ee566bb9a081b3a6a77e80b48058",
        "diff_stats": {
            "additions": 0,
            "deletions": 12
        },
        "diff_content": "@@ -30,7 +30,6 @@ import static com.squareup.javapoet.Util.checkNotNull;\n public final class ParameterizedTypeName extends TypeName {\n   public final ClassName rawType;\n   public final List<TypeName> typeArguments;\n-  private final int hashCode;\n \n   ParameterizedTypeName(ClassName rawType, List<TypeName> typeArguments) {\n     this(rawType, typeArguments, new ArrayList<AnnotationSpec>());\n@@ -41,7 +40,6 @@ public final class ParameterizedTypeName extends TypeName {\n     super(annotations);\n     this.rawType = checkNotNull(rawType, \"rawType == null\");\n     this.typeArguments = Util.immutableList(typeArguments);\n-    this.hashCode = rawType.hashCode() + 31 * typeArguments.hashCode();\n \n     checkArgument(!this.typeArguments.isEmpty(), \"no type arguments: %s\", rawType);\n     for (TypeName typeArgument : this.typeArguments) {\n@@ -54,16 +52,6 @@ public final class ParameterizedTypeName extends TypeName {\n     return new ParameterizedTypeName(rawType, typeArguments, annotations);\n   }\n \n-  @Override public boolean equals(Object o) {\n-    return o instanceof ParameterizedTypeName\n-        && ((ParameterizedTypeName) o).rawType.equals(rawType)\n-        && ((ParameterizedTypeName) o).typeArguments.equals(typeArguments);\n-  }\n-\n-  @Override public int hashCode() {\n-    return hashCode;\n-  }\n-\n   @Override CodeWriter emit(CodeWriter out) throws IOException {\n     emitAnnotations(out);\n     rawType.emit(out);\n"
    },
    {
        "commit_hash": "9ffa01c506ff040df200c164c533987d0fb58112",
        "previous_commit_hash": "fcdb088f4fa4ee566bb9a081b3a6a77e80b48058",
        "diff_stats": {
            "additions": 4,
            "deletions": 5
        },
        "diff_content": "@@ -159,16 +159,15 @@ public class TypeName {\n     throw new UnsupportedOperationException(\"cannot unbox \" + this);\n   }\n \n-  @Override public boolean equals(Object o) {\n+  @Override public final boolean equals(Object o) {\n     if (this == o) return true;\n     if (o == null) return false;\n     if (getClass() != o.getClass()) return false;\n-    return keyword.equals(((TypeName) o).keyword);\n+    return toString().equals(o.toString());\n   }\n \n-  @Override public int hashCode() {\n-    if (keyword == null) throw new AssertionError();\n-    return keyword.hashCode();\n+  @Override public final int hashCode() {\n+    return toString().hashCode();\n   }\n \n   @Override public final String toString() {\n"
    },
    {
        "commit_hash": "9ffa01c506ff040df200c164c533987d0fb58112",
        "previous_commit_hash": "fcdb088f4fa4ee566bb9a081b3a6a77e80b48058",
        "diff_stats": {
            "additions": 0,
            "deletions": 12
        },
        "diff_content": "@@ -34,7 +34,6 @@ import static com.squareup.javapoet.Util.checkNotNull;\n public final class TypeVariableName extends TypeName {\n   public final String name;\n   public final List<TypeName> bounds;\n-  private final int hashCode;\n \n   private TypeVariableName(String name, List<TypeName> bounds) {\n     this(name, bounds, new ArrayList<AnnotationSpec>());\n@@ -44,7 +43,6 @@ public final class TypeVariableName extends TypeName {\n     super(annotations);\n     this.name = checkNotNull(name, \"name == null\");\n     this.bounds = bounds;\n-    this.hashCode = name.hashCode() ^ bounds.hashCode();\n \n     for (TypeName bound : this.bounds) {\n       checkArgument(!bound.isPrimitive() && bound != VOID, \"invalid bound: %s\", bound);\n@@ -62,16 +60,6 @@ public final class TypeVariableName extends TypeName {\n     return new TypeVariableName(name, Collections.unmodifiableList(boundsNoObject));\n   }\n \n-  @Override public boolean equals(Object o) {\n-    return o instanceof TypeVariableName\n-        && ((TypeVariableName) o).name.equals(name)\n-        && ((TypeVariableName) o).bounds.equals(bounds);\n-  }\n-\n-  @Override public int hashCode() {\n-    return hashCode;\n-  }\n-\n   @Override CodeWriter emit(CodeWriter out) throws IOException {\n     return emitAnnotations(out).emitAndIndent(name);\n   }\n"
    },
    {
        "commit_hash": "9ffa01c506ff040df200c164c533987d0fb58112",
        "previous_commit_hash": "fcdb088f4fa4ee566bb9a081b3a6a77e80b48058",
        "diff_stats": {
            "additions": 0,
            "deletions": 12
        },
        "diff_content": "@@ -32,7 +32,6 @@ import static com.squareup.javapoet.Util.checkArgument;\n public final class WildcardTypeName extends TypeName {\n   public final List<TypeName> upperBounds;\n   public final List<TypeName> lowerBounds;\n-  private final int hashCode;\n \n   private WildcardTypeName(List<TypeName> upperBounds, List<TypeName> lowerBounds) {\n     this(upperBounds, lowerBounds, new ArrayList<AnnotationSpec>());\n@@ -43,7 +42,6 @@ public final class WildcardTypeName extends TypeName {\n     super(annotations);\n     this.upperBounds = Util.immutableList(upperBounds);\n     this.lowerBounds = Util.immutableList(lowerBounds);\n-    this.hashCode = upperBounds.hashCode() ^ lowerBounds.hashCode();\n \n     checkArgument(this.upperBounds.size() == 1, \"unexpected extends bounds: %s\", upperBounds);\n     for (TypeName upperBound : this.upperBounds) {\n@@ -60,16 +58,6 @@ public final class WildcardTypeName extends TypeName {\n     return new WildcardTypeName(upperBounds, lowerBounds, annotations);\n   }\n \n-  @Override public boolean equals(Object o) {\n-    return o instanceof WildcardTypeName\n-        && ((WildcardTypeName) o).upperBounds.equals(upperBounds)\n-        && ((WildcardTypeName) o).lowerBounds.equals(lowerBounds);\n-  }\n-\n-  @Override public int hashCode() {\n-    return hashCode;\n-  }\n-\n   @Override CodeWriter emit(CodeWriter out) throws IOException {\n     emitAnnotations(out);\n     if (lowerBounds.size() == 1) {\n"
    },
    {
        "commit_hash": "9ffa01c506ff040df200c164c533987d0fb58112",
        "previous_commit_hash": "fcdb088f4fa4ee566bb9a081b3a6a77e80b48058",
        "diff_stats": {
            "additions": 26,
            "deletions": 11
        },
        "diff_content": "@@ -17,6 +17,7 @@ package com.squareup.javapoet;\n \n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotEquals;\n import static org.junit.Assert.assertTrue;\n \n import java.util.List;\n@@ -25,6 +26,7 @@ import org.junit.Test;\n public class AnnotatedTypeNameTest {\n \n   private final static String NN = NeverNull.class.getCanonicalName();\n+  private final AnnotationSpec NEVER_NULL = AnnotationSpec.builder(NeverNull.class).build();\n \n   public @interface NeverNull {}\n \n@@ -40,7 +42,7 @@ public class AnnotatedTypeNameTest {\n     TypeName simpleString = TypeName.get(String.class);\n     assertFalse(simpleString.isAnnotated());\n     assertEquals(simpleString, TypeName.get(String.class));\n-    TypeName annotated = simpleString.annotated(AnnotationSpec.builder(NeverNull.class).build());\n+    TypeName annotated = simpleString.annotated(NEVER_NULL);\n     assertTrue(annotated.isAnnotated());\n     assertEquals(simpleString, annotated.annotated());\n     assertFalse(annotated.annotated().isAnnotated());\n@@ -48,24 +50,21 @@ public class AnnotatedTypeNameTest {\n \n   @Test public void annotatedType() {\n     String expected = \"@\" + NN + \" java.lang.String\";\n-    AnnotationSpec annotation = AnnotationSpec.builder(NeverNull.class).build();\n     TypeName type = TypeName.get(String.class);\n-    String actual = type.annotated(annotation).toString();\n+    String actual = type.annotated(NEVER_NULL).toString();\n     assertEquals(expected, actual);\n   }\n \n   @Test public void annotatedParameterizedType() {\n     String expected = \"@\" + NN + \" java.util.List<java.lang.String>\";\n-    AnnotationSpec annotation = AnnotationSpec.builder(NeverNull.class).build();\n     TypeName type = ParameterizedTypeName.get(List.class, String.class);\n-    String actual = type.annotated(annotation).toString();\n+    String actual = type.annotated(NEVER_NULL).toString();\n     assertEquals(expected, actual);\n   }\n \n   @Test public void annotatedArgumentOfParameterizedType() {\n     String expected = \"java.util.List<@\" + NN + \" java.lang.String>\";\n-    AnnotationSpec annotation = AnnotationSpec.builder(NeverNull.class).build();\n-    TypeName type = TypeName.get(String.class).annotated(annotation);\n+    TypeName type = TypeName.get(String.class).annotated(NEVER_NULL);\n     ClassName list = ClassName.get(List.class);\n     String actual = ParameterizedTypeName.get(list, type).toString();\n     assertEquals(expected, actual);\n@@ -73,18 +72,34 @@ public class AnnotatedTypeNameTest {\n \n   @Test public void annotatedWildcardTypeNameWithSuper() {\n     String expected = \"? super @\" + NN + \" java.lang.String\";\n-    AnnotationSpec annotation = AnnotationSpec.builder(NeverNull.class).build();\n-    TypeName type = TypeName.get(String.class).annotated(annotation);\n+    TypeName type = TypeName.get(String.class).annotated(NEVER_NULL);\n     String actual = WildcardTypeName.supertypeOf(type).toString();\n     assertEquals(expected, actual);\n   }\n \n   @Test public void annotatedWildcardTypeNameWithExtends() {\n     String expected = \"? extends @\" + NN + \" java.lang.String\";\n-    AnnotationSpec annotation = AnnotationSpec.builder(NeverNull.class).build();\n-    TypeName type = TypeName.get(String.class).annotated(annotation);\n+    TypeName type = TypeName.get(String.class).annotated(NEVER_NULL);\n     String actual = WildcardTypeName.subtypeOf(type).toString();\n     assertEquals(expected, actual);\n   }\n \n+  @Test public void annotatedEquivalence() {\n+    annotatedEquivalence(TypeName.VOID);\n+    annotatedEquivalence(ArrayTypeName.get(Object[].class));\n+    annotatedEquivalence(ClassName.get(Object.class));\n+    annotatedEquivalence(ParameterizedTypeName.get(List.class, Object.class));\n+    annotatedEquivalence(TypeVariableName.get(Object.class));\n+    annotatedEquivalence(WildcardTypeName.get(Object.class));\n+  }\n+\n+  private void annotatedEquivalence(TypeName type) {\n+    assertFalse(type.isAnnotated());\n+    assertEquals(type, type);\n+    assertEquals(type.annotated(NEVER_NULL), type.annotated(NEVER_NULL));\n+    assertNotEquals(type, type.annotated(NEVER_NULL));\n+    assertEquals(type.hashCode(), type.hashCode());\n+    assertEquals(type.annotated(NEVER_NULL).hashCode(), type.annotated(NEVER_NULL).hashCode());\n+    assertNotEquals(type.hashCode(), type.annotated(NEVER_NULL).hashCode());\n+  }\n }\n"
    },
    {
        "commit_hash": "62764fafc3d4380dbf9a81bbb063098b6076ed77",
        "previous_commit_hash": "1488b84dd8f3becf076e63de818ba625a24cf754",
        "diff_stats": {
            "additions": 5,
            "deletions": 0
        },
        "diff_content": "@@ -1,6 +1,11 @@\n Change Log\n ==========\n \n+JavaPoet 1.5.1 *(2016-01-10)*\n+----------------------------\n+\n+ * Fix: Annotated `TypeName` instances are only equal if their annotations are equal.\n+\n JavaPoet 1.5.0 *(2016-01-10)*\n ----------------------------\n \n"
    },
    {
        "commit_hash": "830751cdd5222d3f0d22e4d7ecc81904faaa73a2",
        "previous_commit_hash": "62764fafc3d4380dbf9a81bbb063098b6076ed77",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -801,12 +801,12 @@ Download [the latest .jar][dl] or depend via Maven:\n <dependency>\n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.5.0</version>\n+  <version>1.5.1</version>\n </dependency>\n ```\n or Gradle:\n ```groovy\n-compile 'com.squareup:javapoet:1.5.0'\n+compile 'com.squareup:javapoet:1.5.1'\n ```\n \n Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].\n"
    },
    {
        "commit_hash": "c810627978b07289c8481d368f501de19c38f598",
        "previous_commit_hash": "830751cdd5222d3f0d22e4d7ecc81904faaa73a2",
        "diff_stats": {
            "additions": 19,
            "deletions": 30
        },
        "diff_content": "@@ -29,6 +29,7 @@ import java.util.List;\n import java.util.Map;\n import java.util.Objects;\n \n+import static com.squareup.javapoet.Util.characterLiteralWithoutSingleQuotes;\n import static com.squareup.javapoet.Util.checkNotNull;\n \n import javax.lang.model.element.AnnotationMirror;\n@@ -127,7 +128,7 @@ public final class AnnotationSpec {\n         }\n         if (value.getClass().isArray()) {\n           for (int i = 0; i < Array.getLength(value); i++) {\n-            builder.addValue(method.getName(), Array.get(value, i));\n+            builder.addMemberForValue(method.getName(), Array.get(value, i));\n           }\n           continue;\n         }\n@@ -135,7 +136,7 @@ public final class AnnotationSpec {\n           builder.addMember(method.getName(), \"$L\", get((Annotation) value));\n           continue;\n         }\n-        builder.addValue(method.getName(), value);\n+        builder.addMemberForValue(method.getName(), value);\n       }\n     } catch (Exception e) {\n       throw new RuntimeException(\"Reflecting \" + annotation + \" failed!\", e);\n@@ -150,7 +151,7 @@ public final class AnnotationSpec {\n     for (ExecutableElement executableElement : annotation.getElementValues().keySet()) {\n       String name = executableElement.getSimpleName().toString();\n       AnnotationValue value = annotation.getElementValues().get(executableElement);\n-      value.accept(visitor, new Entry(name, value));\n+      value.accept(visitor, name);\n     }\n     return builder.build();\n   }\n@@ -221,7 +222,9 @@ public final class AnnotationSpec {\n      * depending on the given {@code value} object. Falls back to {@code \"$L\"} literal format if\n      * the class of the given {@code value} object is not supported.\n      */\n-    private Builder addValue(String memberName, Object value) {\n+    Builder addMemberForValue(String memberName, Object value) {\n+      checkNotNull(memberName, \"memberName == null\");\n+      checkNotNull(value, \"value == null, constant non-null value expected for %s\", memberName);\n       if (value instanceof Class<?>) {\n         return addMember(memberName, \"$T.class\", value);\n       }\n@@ -235,11 +238,7 @@ public final class AnnotationSpec {\n         return addMember(memberName, \"$Lf\", value);\n       }\n       if (value instanceof Character) {\n-        String literal = CodeWriter.stringLiteral(value.toString(), \"\");\n-        literal = literal.substring(1, literal.length() - 1);\n-        if (literal.equals(\"\\\\\\\"\")) literal = \"\\\"\";\n-        if (literal.equals(\"'\")) literal = \"\\\\'\";\n-        return addMember(memberName, \"'$L'\", literal);\n+        return addMember(memberName, \"'$L'\", characterLiteralWithoutSingleQuotes((char) value));\n       }\n       return addMember(memberName, \"$L\", value);\n     }\n@@ -249,20 +248,10 @@ public final class AnnotationSpec {\n     }\n   }\n \n-  private static class Entry {\n-    final String name;\n-    final AnnotationValue value;\n-\n-    Entry(String name, AnnotationValue value) {\n-      this.name = name;\n-      this.value = value;\n-    }\n-  }\n-\n   /**\n    * Annotation value visitor adding members to the given builder instance.\n    */\n-  private static class Visitor extends SimpleAnnotationValueVisitor7<Builder, Entry> {\n+  private static class Visitor extends SimpleAnnotationValueVisitor7<Builder, String> {\n     final Builder builder;\n \n     Visitor(Builder builder) {\n@@ -270,25 +259,25 @@ public final class AnnotationSpec {\n       this.builder = builder;\n     }\n \n-    @Override protected Builder defaultAction(Object o, Entry entry) {\n-      return builder.addMember(entry.name, \"$L\", entry.value);\n+    @Override protected Builder defaultAction(Object o, String name) {\n+      return builder.addMemberForValue(name, o);\n     }\n \n-    @Override public Builder visitAnnotation(AnnotationMirror a, Entry entry) {\n-      return builder.addMember(entry.name, \"$L\", get(a));\n+    @Override public Builder visitAnnotation(AnnotationMirror a, String name) {\n+      return builder.addMember(name, \"$L\", get(a));\n     }\n \n-    @Override public Builder visitEnumConstant(VariableElement c, Entry entry) {\n-      return builder.addMember(entry.name, \"$T.$L\", c.asType(), c.getSimpleName());\n+    @Override public Builder visitEnumConstant(VariableElement c, String name) {\n+      return builder.addMember(name, \"$T.$L\", c.asType(), c.getSimpleName());\n     }\n \n-    @Override public Builder visitType(TypeMirror t, Entry entry) {\n-      return builder.addMember(entry.name, \"$T.class\", t);\n+    @Override public Builder visitType(TypeMirror t, String name) {\n+      return builder.addMember(name, \"$T.class\", t);\n     }\n \n-    @Override public Builder visitArray(List<? extends AnnotationValue> values, Entry entry) {\n+    @Override public Builder visitArray(List<? extends AnnotationValue> values, String name) {\n       for (AnnotationValue value : values) {\n-        value.accept(this, new Entry(entry.name, value));\n+        value.accept(this, name);\n       }\n       return builder;\n     }\n"
    },
    {
        "commit_hash": "c810627978b07289c8481d368f501de19c38f598",
        "previous_commit_hash": "830751cdd5222d3f0d22e4d7ecc81904faaa73a2",
        "diff_stats": {
            "additions": 2,
            "deletions": 49
        },
        "diff_content": "@@ -19,7 +19,6 @@ import java.io.IOException;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.EnumSet;\n-import java.util.Formatter;\n import java.util.LinkedHashMap;\n import java.util.LinkedHashSet;\n import java.util.List;\n@@ -35,6 +34,7 @@ import static com.squareup.javapoet.Util.checkArgument;\n import static com.squareup.javapoet.Util.checkNotNull;\n import static com.squareup.javapoet.Util.checkState;\n import static com.squareup.javapoet.Util.join;\n+import static com.squareup.javapoet.Util.stringLiteralWithDoubleQuotes;\n \n /**\n  * Converts a {@link JavaFile} to a string suitable to both human- and javac-consumption. This\n@@ -225,7 +225,7 @@ final class CodeWriter {\n           String string = (String) codeBlock.args.get(a++);\n           // Emit null as a literal null: no quotes.\n           emitAndIndent(string != null\n-              ? stringLiteral(string)\n+              ? stringLiteralWithDoubleQuotes(string, indent)\n               : \"null\");\n           break;\n \n@@ -476,51 +476,4 @@ final class CodeWriter {\n     result.keySet().removeAll(referencedNames);\n     return result;\n   }\n-\n-  /** Returns the string literal representing {@code data}, including wrapping quotes. */\n-  String stringLiteral(String value) {\n-    return stringLiteral(value, indent);\n-  }\n-\n-  static String stringLiteral(String value, String indent) {\n-    StringBuilder result = new StringBuilder();\n-    result.append('\"');\n-    for (int i = 0; i < value.length(); i++) {\n-      char c = value.charAt(i);\n-      switch (c) {\n-        case '\"':\n-          result.append(\"\\\\\\\"\");\n-          break;\n-        case '\\\\':\n-          result.append(\"\\\\\\\\\");\n-          break;\n-        case '\\b':\n-          result.append(\"\\\\b\");\n-          break;\n-        case '\\t':\n-          result.append(\"\\\\t\");\n-          break;\n-        case '\\n':\n-          result.append(\"\\\\n\");\n-          if (i + 1 < value.length()) {\n-            result.append(\"\\\"\\n\").append(indent).append(indent).append(\"+ \\\"\");\n-          }\n-          break;\n-        case '\\f':\n-          result.append(\"\\\\f\");\n-          break;\n-        case '\\r':\n-          result.append(\"\\\\r\");\n-          break;\n-        default:\n-          if (Character.isISOControl(c)) {\n-            new Formatter(result).format(\"\\\\u%04x\", (int) c);\n-          } else {\n-            result.append(c);\n-          }\n-      }\n-    }\n-    result.append('\"');\n-    return result.toString();\n-  }\n }\n"
    },
    {
        "commit_hash": "c810627978b07289c8481d368f501de19c38f598",
        "previous_commit_hash": "830751cdd5222d3f0d22e4d7ecc81904faaa73a2",
        "diff_stats": {
            "additions": 52,
            "deletions": 12
        },
        "diff_content": "@@ -15,6 +15,8 @@\n  */\n package com.squareup.javapoet;\n \n+import static java.lang.Character.isISOControl;\n+\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n@@ -35,7 +37,7 @@ final class Util {\n   }\n \n   /** Modifier.DEFAULT doesn't exist until Java 8, but we want to run on earlier releases. */\n-  public static final Modifier DEFAULT;\n+  static final Modifier DEFAULT;\n   static {\n     Modifier def = null;\n     try {\n@@ -45,7 +47,7 @@ final class Util {\n     DEFAULT = def;\n   }\n \n-  public static <K, V> Map<K, List<V>> immutableMultimap(Map<K, List<V>> multimap) {\n+  static <K, V> Map<K, List<V>> immutableMultimap(Map<K, List<V>> multimap) {\n     LinkedHashMap<K, List<V>> result = new LinkedHashMap<>();\n     for (Map.Entry<K, List<V>> entry : multimap.entrySet()) {\n       if (entry.getValue().isEmpty()) continue;\n@@ -54,32 +56,32 @@ final class Util {\n     return Collections.unmodifiableMap(result);\n   }\n \n-  public static <K, V> Map<K, V> immutableMap(Map<K, V> map) {\n+  static <K, V> Map<K, V> immutableMap(Map<K, V> map) {\n     return Collections.unmodifiableMap(new LinkedHashMap<>(map));\n   }\n \n-  public static void checkArgument(boolean condition, String format, Object... args) {\n+  static void checkArgument(boolean condition, String format, Object... args) {\n     if (!condition) throw new IllegalArgumentException(String.format(format, args));\n   }\n \n-  public static <T> T checkNotNull(T reference, String format, Object... args) {\n+  static <T> T checkNotNull(T reference, String format, Object... args) {\n     if (reference == null) throw new NullPointerException(String.format(format, args));\n     return reference;\n   }\n \n-  public static void checkState(boolean condition, String format, Object... args) {\n+  static void checkState(boolean condition, String format, Object... args) {\n     if (!condition) throw new IllegalStateException(String.format(format, args));\n   }\n \n-  public static <T> List<T> immutableList(List<T> list) {\n+  static <T> List<T> immutableList(List<T> list) {\n     return Collections.unmodifiableList(new ArrayList<>(list));\n   }\n \n-  public static <T> Set<T> immutableSet(Collection<T> set) {\n+  static <T> Set<T> immutableSet(Collection<T> set) {\n     return Collections.unmodifiableSet(new LinkedHashSet<>(set));\n   }\n \n-  public static String join(String separator, List<String> parts) {\n+  static String join(String separator, List<String> parts) {\n     if (parts.isEmpty()) return \"\";\n     StringBuilder result = new StringBuilder();\n     result.append(parts.get(0));\n@@ -89,14 +91,14 @@ final class Util {\n     return result.toString();\n   }\n \n-  public static <T> Set<T> union(Set<T> a, Set<T> b) {\n+  static <T> Set<T> union(Set<T> a, Set<T> b) {\n     Set<T> result = new LinkedHashSet<>();\n     result.addAll(a);\n     result.addAll(b);\n     return result;\n   }\n \n-  public static void requireExactlyOneOf(Set<Modifier> modifiers, Modifier... mutuallyExclusive) {\n+  static void requireExactlyOneOf(Set<Modifier> modifiers, Modifier... mutuallyExclusive) {\n     int count = 0;\n     for (Modifier modifier : mutuallyExclusive) {\n       if (modifier == null && Util.DEFAULT == null) continue; // Skip 'DEFAULT' if it doesn't exist!\n@@ -106,7 +108,45 @@ final class Util {\n         modifiers, Arrays.toString(mutuallyExclusive));\n   }\n \n-  public static boolean hasDefaultModifier(Collection<Modifier> modifiers) {\n+  static boolean hasDefaultModifier(Collection<Modifier> modifiers) {\n     return DEFAULT != null && modifiers.contains(DEFAULT);\n   }\n+\n+  static String characterLiteralWithoutSingleQuotes(char c) {\n+    // see https://docs.oracle.com/javase/specs/jls/se7/html/jls-3.html#jls-3.10.6\n+    switch (c) {\n+      case '\\b': return \"\\\\b\"; /* \\u0008: backspace (BS) */\n+      case '\\t': return \"\\\\t\"; /* \\u0009: horizontal tab (HT) */\n+      case '\\n': return \"\\\\n\"; /* \\u000a: linefeed (LF) */\n+      case '\\f': return \"\\\\f\"; /* \\u000c: form feed (FF) */\n+      case '\\r': return \"\\\\r\"; /* \\u000d: carriage return (CR) */\n+      case '\\\"': return \"\\\"\";  /* \\u0022: double quote (\") */\n+      case '\\'': return \"\\\\'\"; /* \\u0027: single quote (') */\n+      case '\\\\': return \"\\\\\";  /* \\u005c: backslash (\\) */\n+      default:\n+        return isISOControl(c) ? String.format(\"\\\\u%04x\", (int) c) : Character.toString(c);\n+    }\n+  }\n+\n+  /** Returns the string literal representing {@code value}, including wrapping double quotes. */\n+  static String stringLiteralWithDoubleQuotes(String value, String indent) {\n+    StringBuilder result = new StringBuilder(value.length() + 2);\n+    result.append('\"');\n+    for (int i = 0; i < value.length(); i++) {\n+      char c = value.charAt(i);\n+      // trivial case: single quote must not be escaped\n+      if (c == '\\'') {\n+        result.append(\"'\");\n+        continue;\n+      }\n+      // default case: just let character literal do its work\n+      result.append(characterLiteralWithoutSingleQuotes(c));\n+      // need to append indent after linefeed?\n+      if (c == '\\n' && i + 1 < value.length()) {\n+        result.append(\"\\\"\\n\").append(indent).append(indent).append(\"+ \\\"\");\n+      }\n+    }\n+    result.append('\"');\n+    return result.toString();\n+  }\n }\n"
    },
    {
        "commit_hash": "c810627978b07289c8481d368f501de19c38f598",
        "previous_commit_hash": "830751cdd5222d3f0d22e4d7ecc81904faaa73a2",
        "diff_stats": {
            "additions": 2,
            "deletions": 1
        },
        "diff_content": "@@ -62,7 +62,7 @@ public final class AnnotationSpecTest {\n \n     double f() default 10.0;\n \n-    char[] g() default {0, 0xCAFE, 'z', '\u20ac', '\"', '\\'', '\\t', '\\n'};\n+    char[] g() default {0, 0xCAFE, 'z', '\u20ac', '\u2115', '\"', '\\'', '\\t', '\\n'};\n \n     boolean h() default true;\n \n@@ -318,6 +318,7 @@ public final class AnnotationSpecTest {\n         + \"        '\ucafe',\\n\"\n         + \"        'z',\\n\"\n         + \"        '\u20ac',\\n\"\n+        + \"        '\u2115',\\n\"\n         + \"        '\\\"',\\n\"\n         + \"        '\\\\'',\\n\"\n         + \"        '\\\\t',\\n\"\n"
    },
    {
        "commit_hash": "c810627978b07289c8481d368f501de19c38f598",
        "previous_commit_hash": "830751cdd5222d3f0d22e4d7ecc81904faaa73a2",
        "diff_stats": {
            "additions": 73,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright (C) 2016 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javapoet;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import org.junit.Test;\n+\n+public class UtilTest {\n+  @Test public void characterLiteral() {\n+    assertEquals(\"a\", Util.characterLiteralWithoutSingleQuotes('a'));\n+    assertEquals(\"b\", Util.characterLiteralWithoutSingleQuotes('b'));\n+    assertEquals(\"c\", Util.characterLiteralWithoutSingleQuotes('c'));\n+    assertEquals(\"%\", Util.characterLiteralWithoutSingleQuotes('%'));\n+    // common escapes\n+    assertEquals(\"\\\\b\", Util.characterLiteralWithoutSingleQuotes('\\b'));\n+    assertEquals(\"\\\\t\", Util.characterLiteralWithoutSingleQuotes('\\t'));\n+    assertEquals(\"\\\\n\", Util.characterLiteralWithoutSingleQuotes('\\n'));\n+    assertEquals(\"\\\\f\", Util.characterLiteralWithoutSingleQuotes('\\f'));\n+    assertEquals(\"\\\\r\", Util.characterLiteralWithoutSingleQuotes('\\r'));\n+    assertEquals(\"\\\"\", Util.characterLiteralWithoutSingleQuotes('\"'));\n+    assertEquals(\"\\\\'\", Util.characterLiteralWithoutSingleQuotes('\\''));\n+    assertEquals(\"\\\\\", Util.characterLiteralWithoutSingleQuotes('\\\\'));\n+    // octal escapes\n+    assertEquals(\"\\\\u0000\", Util.characterLiteralWithoutSingleQuotes('\\0'));\n+    assertEquals(\"\\\\u0007\", Util.characterLiteralWithoutSingleQuotes('\\7'));\n+    assertEquals(\"?\", Util.characterLiteralWithoutSingleQuotes('\\77'));\n+    assertEquals(\"\\\\u007f\", Util.characterLiteralWithoutSingleQuotes('\\177'));\n+    assertEquals(\"\u00bf\", Util.characterLiteralWithoutSingleQuotes('\\277'));\n+    assertEquals(\"\u00ff\", Util.characterLiteralWithoutSingleQuotes('\\377'));\n+    // unicode escapes\n+    assertEquals(\"\\\\u0000\", Util.characterLiteralWithoutSingleQuotes('\\u0000'));\n+    assertEquals(\"\\\\u0001\", Util.characterLiteralWithoutSingleQuotes('\\u0001'));\n+    assertEquals(\"\\\\u0002\", Util.characterLiteralWithoutSingleQuotes('\\u0002'));\n+    assertEquals(\"\u20ac\", Util.characterLiteralWithoutSingleQuotes('\\u20AC'));\n+    assertEquals(\"\u2603\", Util.characterLiteralWithoutSingleQuotes('\\u2603'));\n+    assertEquals(\"\u2660\", Util.characterLiteralWithoutSingleQuotes('\\u2660'));\n+    assertEquals(\"\u2663\", Util.characterLiteralWithoutSingleQuotes('\\u2663'));\n+    assertEquals(\"\u2665\", Util.characterLiteralWithoutSingleQuotes('\\u2665'));\n+    assertEquals(\"\u2666\", Util.characterLiteralWithoutSingleQuotes('\\u2666'));\n+    assertEquals(\"\u2735\", Util.characterLiteralWithoutSingleQuotes('\\u2735'));\n+    assertEquals(\"\u273a\", Util.characterLiteralWithoutSingleQuotes('\\u273A'));\n+    assertEquals(\"\uff0f\", Util.characterLiteralWithoutSingleQuotes('\\uFF0F'));\n+  }\n+\n+  @Test public void stringLiteral() {\n+    stringLiteral(\"abc\");\n+    stringLiteral(\"\u2666\u2665\u2660\u2663\");\n+    stringLiteral(\"\u20ac\\\\t@\\\\t$\", \"\u20ac\\t@\\t$\", \" \");\n+    stringLiteral(\"abc();\\\\n\\\"\\n  + \\\"def();\", \"abc();\\ndef();\", \" \");\n+  }\n+\n+  void stringLiteral(String string) {\n+    stringLiteral(string, string, \" \");\n+  }\n+\n+  void stringLiteral(String expected, String value, String indent) {\n+    assertEquals(\"\\\"\" + expected + \"\\\"\", Util.stringLiteralWithDoubleQuotes(value, indent));\n+  }\n+}\n"
    },
    {
        "commit_hash": "4dd534906a1e8aa8b15883706878a45fdb1437da",
        "previous_commit_hash": "830751cdd5222d3f0d22e4d7ecc81904faaa73a2",
        "diff_stats": {
            "additions": 23,
            "deletions": 0
        },
        "diff_content": "@@ -19,6 +19,7 @@ import java.util.Collections;\n import java.util.Date;\n import java.util.concurrent.TimeUnit;\n import javax.lang.model.element.Modifier;\n+import org.junit.Ignore;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n@@ -134,6 +135,28 @@ public final class JavaFileTest {\n         + \"}\\n\");\n   }\n \n+  @Ignore(\"addStaticImport doesn't support members with $L\")\n+  @Test public void importStaticDynamic() {\n+    JavaFile source = JavaFile.builder(\"com.squareup.tacos\",\n+        TypeSpec.classBuilder(\"Taco\")\n+            .addMethod(MethodSpec.methodBuilder(\"main\")\n+                .addStatement(\"$T.$L.println($S)\", System.class, \"out\", \"hello\")\n+                .build())\n+            .build())\n+        .addStaticImport(System.class, \"out\")\n+        .build();\n+    assertThat(source.toString()).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import static java.lang.System.out;\\n\"\n+        + \"\\n\"\n+        + \"class Taco {\\n\"\n+        + \"  void main() {\\n\"\n+        + \"    out.println(\\\"hello\\\");\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n   @Test public void importStaticNone() {\n     assertThat(JavaFile.builder(\"readme\", importStaticTypeSpec(\"Util\"))\n         .build().toString()).isEqualTo(\"\"\n"
    },
    {
        "commit_hash": "191787d4ba266b7bb172effa5eb00df6875b39a7",
        "previous_commit_hash": "e3e7652c8abdd64a6d0d5aa723421cba2311ecfe",
        "diff_stats": {
            "additions": 3,
            "deletions": 1
        },
        "diff_content": "@@ -54,7 +54,9 @@\n     <module name=\"LineLength\">\n       <property name=\"max\" value=\"100\"/>\n     </module>\n-    <module name=\"MethodLength\"/>\n+    <module name=\"MethodLength\">\n+      <property name=\"max\" value=\"155\"/>\n+    </module>\n     <module name=\"ParameterNumber\"/>\n \n \n"
    },
    {
        "commit_hash": "191787d4ba266b7bb172effa5eb00df6875b39a7",
        "previous_commit_hash": "e3e7652c8abdd64a6d0d5aa723421cba2311ecfe",
        "diff_stats": {
            "additions": 24,
            "deletions": 0
        },
        "diff_content": "@@ -52,6 +52,7 @@ public final class TypeSpec {\n   public final Map<String, TypeSpec> enumConstants;\n   public final List<FieldSpec> fieldSpecs;\n   public final CodeBlock staticBlock;\n+  public final CodeBlock initializerBlock;\n   public final List<MethodSpec> methodSpecs;\n   public final List<TypeSpec> typeSpecs;\n   public final List<Element> originatingElements;\n@@ -69,6 +70,7 @@ public final class TypeSpec {\n     this.enumConstants = Util.immutableMap(builder.enumConstants);\n     this.fieldSpecs = Util.immutableList(builder.fieldSpecs);\n     this.staticBlock = builder.staticBlock.build();\n+    this.initializerBlock = builder.initializerBlock.build();\n     this.methodSpecs = Util.immutableList(builder.methodSpecs);\n     this.typeSpecs = Util.immutableList(builder.typeSpecs);\n \n@@ -118,6 +120,8 @@ public final class TypeSpec {\n     builder.fieldSpecs.addAll(fieldSpecs);\n     builder.methodSpecs.addAll(methodSpecs);\n     builder.typeSpecs.addAll(typeSpecs);\n+    builder.initializerBlock.add(initializerBlock);\n+    builder.staticBlock.add(staticBlock);\n     return builder;\n   }\n \n@@ -234,6 +238,13 @@ public final class TypeSpec {\n         firstMember = false;\n       }\n \n+      // Initializer block.\n+      if (!initializerBlock.isEmpty()) {\n+        if (!firstMember) codeWriter.emit(\"\\n\");\n+        codeWriter.emit(initializerBlock);\n+        firstMember = false;\n+      }\n+\n       // Constructors.\n       for (MethodSpec methodSpec : methodSpecs) {\n         if (!methodSpec.isConstructor()) continue;\n@@ -346,6 +357,7 @@ public final class TypeSpec {\n     private final Map<String, TypeSpec> enumConstants = new LinkedHashMap<>();\n     private final List<FieldSpec> fieldSpecs = new ArrayList<>();\n     private final CodeBlock.Builder staticBlock = CodeBlock.builder();\n+    private final CodeBlock.Builder initializerBlock = CodeBlock.builder();\n     private final List<MethodSpec> methodSpecs = new ArrayList<>();\n     private final List<TypeSpec> typeSpecs = new ArrayList<>();\n     private final List<Element> originatingElements = new ArrayList<>();\n@@ -480,6 +492,18 @@ public final class TypeSpec {\n       return this;\n     }\n \n+    public Builder addInitializerBlock(CodeBlock block) {\n+      if ((kind != Kind.CLASS && kind != Kind.ENUM)) {\n+        throw new UnsupportedOperationException(kind + \" can't have initializer blocks\");\n+      }\n+      initializerBlock.add(\"{\\n\")\n+          .indent()\n+          .add(block)\n+          .unindent()\n+          .add(\"}\\n\");\n+      return this;\n+    }\n+\n     public Builder addMethods(Iterable<MethodSpec> methodSpecs) {\n       checkArgument(methodSpecs != null, \"methodSpecs == null\");\n       for (MethodSpec methodSpec : methodSpecs) {\n"
    },
    {
        "commit_hash": "191787d4ba266b7bb172effa5eb00df6875b39a7",
        "previous_commit_hash": "e3e7652c8abdd64a6d0d5aa723421cba2311ecfe",
        "diff_stats": {
            "additions": 196,
            "deletions": 55
        },
        "diff_content": "@@ -17,7 +17,6 @@ package com.squareup.javapoet;\n \n import com.google.common.collect.ImmutableMap;\n import com.google.testing.compile.CompilationRule;\n-\n import java.io.IOException;\n import java.io.Serializable;\n import java.math.BigDecimal;\n@@ -30,12 +29,10 @@ import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n import java.util.Random;\n-\n import javax.lang.model.element.Element;\n import javax.lang.model.element.Modifier;\n import javax.lang.model.element.TypeElement;\n import javax.lang.model.type.TypeMirror;\n-\n import org.junit.Assert;\n import org.junit.Rule;\n import org.junit.Test;\n@@ -399,7 +396,7 @@ public final class TypeSpecTest {\n   @Test public void enumConstantsRequired() throws Exception {\n     try {\n       TypeSpec.enumBuilder(\"Roshambo\")\n-        .build();\n+          .build();\n       fail();\n     } catch (IllegalArgumentException expected) {\n     }\n@@ -408,8 +405,8 @@ public final class TypeSpecTest {\n   @Test public void onlyEnumsMayHaveEnumConstants() throws Exception {\n     try {\n       TypeSpec.classBuilder(\"Roshambo\")\n-        .addEnumConstant(\"ROCK\")\n-        .build();\n+          .addEnumConstant(\"ROCK\")\n+          .build();\n       fail();\n     } catch (IllegalStateException expected) {\n     }\n@@ -739,7 +736,8 @@ public final class TypeSpecTest {\n               .build())\n           .build();\n       fail();\n-    } catch (IllegalStateException expected) {}\n+    } catch (IllegalStateException expected) {\n+    }\n   }\n \n   @Test\n@@ -754,7 +752,8 @@ public final class TypeSpecTest {\n               .build())\n           .build();\n       fail();\n-    } catch (IllegalStateException expected) {}\n+    } catch (IllegalStateException expected) {\n+    }\n   }\n \n   @Test\n@@ -768,13 +767,13 @@ public final class TypeSpecTest {\n         .build();\n \n     assertThat(toString(bar)).isEqualTo(\"\"\n-            + \"package com.squareup.tacos;\\n\"\n-            + \"\\n\"\n-            + \"interface Tacos {\\n\"\n-            + \"  static int test() {\\n\"\n-            + \"    return 0;\\n\"\n-            + \"  }\\n\"\n-            + \"}\\n\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"interface Tacos {\\n\"\n+        + \"  static int test() {\\n\"\n+        + \"    return 0;\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\"\n     );\n   }\n \n@@ -790,13 +789,13 @@ public final class TypeSpecTest {\n         .build();\n \n     assertThat(toString(bar)).isEqualTo(\"\"\n-            + \"package com.squareup.tacos;\\n\"\n-            + \"\\n\"\n-            + \"interface Tacos {\\n\"\n-            + \"  default int test() {\\n\"\n-            + \"    return 0;\\n\"\n-            + \"  }\\n\"\n-            + \"}\\n\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"interface Tacos {\\n\"\n+        + \"  default int test() {\\n\"\n+        + \"    return 0;\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\"\n     );\n   }\n \n@@ -1090,7 +1089,7 @@ public final class TypeSpecTest {\n         + \"  }\\n\"\n         + \"}\\n\");\n   }\n-  \n+\n   @Test public void indexedElseIf() throws Exception {\n     TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n         .addMethod(MethodSpec.methodBuilder(\"choices\")\n@@ -1564,7 +1563,8 @@ public final class TypeSpecTest {\n           .initializer(\"bar\")\n           .build();\n       fail();\n-    } catch (IllegalStateException expected) {}\n+    } catch (IllegalStateException expected) {\n+    }\n \n     try {\n       FieldSpec.builder(String.class, \"listA\")\n@@ -1572,7 +1572,8 @@ public final class TypeSpecTest {\n           .initializer(CodeBlock.builder().add(\"bar\").build())\n           .build();\n       fail();\n-    } catch (IllegalStateException expected) {}\n+    } catch (IllegalStateException expected) {\n+    }\n   }\n \n   @Test public void nullAnnotationsAddition() {\n@@ -1860,7 +1861,7 @@ public final class TypeSpecTest {\n   }\n \n   @Test public void stringFromNull() {\n-    assertThat(codeBlock(\"$S\", new Object[] { null }).toString()).isEqualTo(\"null\");\n+    assertThat(codeBlock(\"$S\", new Object[] {null}).toString()).isEqualTo(\"null\");\n   }\n \n   @Test public void typeFromTypeName() {\n@@ -1948,35 +1949,175 @@ public final class TypeSpecTest {\n \n   @Test public void staticCodeBlock() {\n     TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n-            .addField(String.class, \"mFoo\", Modifier.PRIVATE)\n-            .addField(String.class, \"FOO\", Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)\n-            .addStaticBlock(CodeBlock.builder()\n-                    .addStatement(\"FOO = $S\", \"FOO\")\n-                    .build())\n-            .addMethod(MethodSpec.methodBuilder(\"toString\")\n-                    .addAnnotation(Override.class)\n-                    .addModifiers(Modifier.PUBLIC)\n-                    .returns(String.class)\n-                    .addCode(\"return FOO;\\n\")\n-                    .build())\n-            .build();\n-      assertThat(toString(taco)).isEqualTo(\"\"\n-            + \"package com.squareup.tacos;\\n\"\n-            + \"\\n\"\n-            + \"import java.lang.Override;\\n\"\n-            + \"import java.lang.String;\\n\"\n-            + \"\\n\"\n-            + \"class Taco {\\n\"\n-            + \"  private static final String FOO;\\n\\n\"\n-            + \"  static {\\n\"\n-            + \"    FOO = \\\"FOO\\\";\\n\"\n-            + \"  }\\n\\n\"\n-            + \"  private String mFoo;\\n\\n\"\n-            + \"  @Override\\n\"\n-            + \"  public String toString() {\\n\"\n-            + \"    return FOO;\\n\"\n-            + \"  }\\n\"\n-            + \"}\\n\");\n+        .addField(String.class, \"foo\", Modifier.PRIVATE)\n+        .addField(String.class, \"FOO\", Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)\n+        .addStaticBlock(CodeBlock.builder()\n+            .addStatement(\"FOO = $S\", \"FOO\")\n+            .build())\n+        .addMethod(MethodSpec.methodBuilder(\"toString\")\n+            .addAnnotation(Override.class)\n+            .addModifiers(Modifier.PUBLIC)\n+            .returns(String.class)\n+            .addCode(\"return FOO;\\n\")\n+            .build())\n+        .build();\n+    assertThat(toString(taco)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import java.lang.Override;\\n\"\n+        + \"import java.lang.String;\\n\"\n+        + \"\\n\"\n+        + \"class Taco {\\n\"\n+        + \"  private static final String FOO;\\n\"\n+        + \"\\n\"\n+        + \"  static {\\n\"\n+        + \"    FOO = \\\"FOO\\\";\\n\"\n+        + \"  }\\n\"\n+        + \"\\n\"\n+        + \"  private String foo;\\n\"\n+        + \"\\n\"\n+        + \"  @Override\\n\"\n+        + \"  public String toString() {\\n\"\n+        + \"    return FOO;\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void initializerBlockInRightPlace() {\n+    TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n+        .addField(String.class, \"foo\", Modifier.PRIVATE)\n+        .addField(String.class, \"FOO\", Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)\n+        .addStaticBlock(CodeBlock.builder()\n+            .addStatement(\"FOO = $S\", \"FOO\")\n+            .build())\n+        .addMethod(MethodSpec.constructorBuilder().build())\n+        .addMethod(MethodSpec.methodBuilder(\"toString\")\n+            .addAnnotation(Override.class)\n+            .addModifiers(Modifier.PUBLIC)\n+            .returns(String.class)\n+            .addCode(\"return FOO;\\n\")\n+            .build())\n+        .addInitializerBlock(CodeBlock.builder()\n+            .addStatement(\"foo = $S\", \"FOO\")\n+            .build())\n+        .build();\n+    assertThat(toString(taco)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import java.lang.Override;\\n\"\n+        + \"import java.lang.String;\\n\"\n+        + \"\\n\"\n+        + \"class Taco {\\n\"\n+        + \"  private static final String FOO;\\n\"\n+        + \"\\n\"\n+        + \"  static {\\n\"\n+        + \"    FOO = \\\"FOO\\\";\\n\"\n+        + \"  }\\n\"\n+        + \"\\n\"\n+        + \"  private String foo;\\n\"\n+        + \"\\n\"\n+        + \"  {\\n\"\n+        + \"    foo = \\\"FOO\\\";\\n\"\n+        + \"  }\\n\"\n+        + \"\\n\"\n+        + \"  Taco() {\\n\"\n+        + \"  }\\n\"\n+        + \"\\n\"\n+        + \"  @Override\\n\"\n+        + \"  public String toString() {\\n\"\n+        + \"    return FOO;\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void initializersToBuilder() {\n+    // Tests if toBuilder() contains correct static and instance initializers\n+    TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n+        .addField(String.class, \"foo\", Modifier.PRIVATE)\n+        .addField(String.class, \"FOO\", Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)\n+        .addStaticBlock(CodeBlock.builder()\n+            .addStatement(\"FOO = $S\", \"FOO\")\n+            .build())\n+        .addMethod(MethodSpec.constructorBuilder().build())\n+        .addMethod(MethodSpec.methodBuilder(\"toString\")\n+            .addAnnotation(Override.class)\n+            .addModifiers(Modifier.PUBLIC)\n+            .returns(String.class)\n+            .addCode(\"return FOO;\\n\")\n+            .build())\n+        .addInitializerBlock(CodeBlock.builder()\n+            .addStatement(\"foo = $S\", \"FOO\")\n+            .build())\n+        .build();\n+    \n+    TypeSpec recreatedTaco = taco.toBuilder().build();\n+    assertThat(toString(taco)).isEqualTo(toString(recreatedTaco));\n+\n+    TypeSpec initializersAdded = taco.toBuilder()\n+        .addInitializerBlock(CodeBlock.builder()\n+            .addStatement(\"foo = $S\", \"instanceFoo\")\n+            .build())\n+        .addStaticBlock(CodeBlock.builder()\n+            .addStatement(\"FOO = $S\", \"staticFoo\")\n+            .build())\n+        .build();\n+\n+    assertThat(toString(initializersAdded)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import java.lang.Override;\\n\"\n+        + \"import java.lang.String;\\n\"\n+        + \"\\n\"\n+        + \"class Taco {\\n\"\n+        + \"  private static final String FOO;\\n\"\n+        + \"\\n\"\n+        + \"  static {\\n\"\n+        + \"    FOO = \\\"FOO\\\";\\n\"\n+        + \"  }\\n\"\n+        + \"  static {\\n\"\n+        + \"    FOO = \\\"staticFoo\\\";\\n\"\n+        + \"  }\\n\"\n+        + \"\\n\"\n+        + \"  private String foo;\\n\"\n+        + \"\\n\"\n+        + \"  {\\n\"\n+        + \"    foo = \\\"FOO\\\";\\n\"\n+        + \"  }\\n\"\n+        + \"  {\\n\"\n+        + \"    foo = \\\"instanceFoo\\\";\\n\"\n+        + \"  }\\n\"\n+        + \"\\n\"\n+        + \"  Taco() {\\n\"\n+        + \"  }\\n\"\n+        + \"\\n\"\n+        + \"  @Override\\n\"\n+        + \"  public String toString() {\\n\"\n+        + \"    return FOO;\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test\n+  public void initializerBlockUnsupportedExceptionOnInterface() {\n+    TypeSpec.Builder interfaceBuilder = TypeSpec.interfaceBuilder(\"Taco\");\n+\n+    try {\n+      interfaceBuilder.addInitializerBlock(CodeBlock.builder().build());\n+      fail(\"Exception expected\");\n+    } catch (UnsupportedOperationException e) {\n+    }\n+  }\n+\n+  @Test\n+  public void initializerBlockUnsupportedExceptionOnAnnotation() {\n+\n+    TypeSpec.Builder annotationBuilder = TypeSpec.annotationBuilder(\"Taco\");\n+\n+    try {\n+      annotationBuilder.addInitializerBlock(CodeBlock.builder().build());\n+      fail(\"Exception expected\");\n+    } catch (UnsupportedOperationException e) {\n+    }\n   }\n \n   @Test public void equalsAndHashCode() {\n"
    },
    {
        "commit_hash": "d19fee4b8b2e805e70725182ff48091adfcdb412",
        "previous_commit_hash": "bbdaa34e4d73165d92a76e0c342fbd6f7c5fc787",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -302,7 +302,7 @@ public final class TypeSpec {\n     }\n   }\n \n-  private enum Kind {\n+  public enum Kind {\n     CLASS(\n         Collections.<Modifier>emptySet(),\n         Collections.<Modifier>emptySet(),\n"
    },
    {
        "commit_hash": "2d21ad7ac0ec54afe0f0becf500a4ce7f17716dd",
        "previous_commit_hash": "e66ed4514245eedace3ffb90495429bde6779940",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -41,7 +41,7 @@ public final class ArrayTypeName extends TypeName {\n   }\n \n   @Override public ArrayTypeName annotated(List<AnnotationSpec> annotations) {\n-    return new ArrayTypeName(componentType, annotations);\n+    return new ArrayTypeName(componentType, prependAnnotations(annotations));\n   }\n \n   @Override CodeWriter emit(CodeWriter out) throws IOException {\n"
    },
    {
        "commit_hash": "2d21ad7ac0ec54afe0f0becf500a4ce7f17716dd",
        "previous_commit_hash": "e66ed4514245eedace3ffb90495429bde6779940",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -55,7 +55,7 @@ public final class ClassName extends TypeName implements Comparable<ClassName> {\n   }\n \n   @Override public ClassName annotated(List<AnnotationSpec> annotations) {\n-    return new ClassName(names, annotations);\n+    return new ClassName(names, prependAnnotations(annotations));\n   }\n \n   /** Returns the package name, like {@code \"java.util\"} for {@code Map.Entry}. */\n"
    },
    {
        "commit_hash": "2d21ad7ac0ec54afe0f0becf500a4ce7f17716dd",
        "previous_commit_hash": "e66ed4514245eedace3ffb90495429bde6779940",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -49,7 +49,7 @@ public final class ParameterizedTypeName extends TypeName {\n   }\n \n   @Override public ParameterizedTypeName annotated(List<AnnotationSpec> annotations) {\n-    return new ParameterizedTypeName(rawType, typeArguments, annotations);\n+    return new ParameterizedTypeName(rawType, typeArguments, prependAnnotations(annotations));\n   }\n \n   @Override CodeWriter emit(CodeWriter out) throws IOException {\n"
    },
    {
        "commit_hash": "2d21ad7ac0ec54afe0f0becf500a4ce7f17716dd",
        "previous_commit_hash": "e66ed4514245eedace3ffb90495429bde6779940",
        "diff_stats": {
            "additions": 7,
            "deletions": 1
        },
        "diff_content": "@@ -110,7 +110,13 @@ public class TypeName {\n \n   public TypeName annotated(List<AnnotationSpec> annotations) {\n     Util.checkNotNull(annotations, \"annotations == null\");\n-    return new TypeName(keyword, annotations);\n+    return new TypeName(keyword, prependAnnotations(annotations));\n+  }\n+\n+  protected final List<AnnotationSpec> prependAnnotations(List<AnnotationSpec> annotations) {\n+    List<AnnotationSpec> allAnnotations = new ArrayList<>(annotations);\n+    allAnnotations.addAll(this.annotations);\n+    return allAnnotations;\n   }\n \n   public boolean isAnnotated() {\n"
    },
    {
        "commit_hash": "2d21ad7ac0ec54afe0f0becf500a4ce7f17716dd",
        "previous_commit_hash": "e66ed4514245eedace3ffb90495429bde6779940",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -55,7 +55,7 @@ public final class WildcardTypeName extends TypeName {\n   }\n \n   @Override public WildcardTypeName annotated(List<AnnotationSpec> annotations) {\n-    return new WildcardTypeName(upperBounds, lowerBounds, annotations);\n+    return new WildcardTypeName(upperBounds, lowerBounds, prependAnnotations(annotations));\n   }\n \n   @Override CodeWriter emit(CodeWriter out) throws IOException {\n"
    },
    {
        "commit_hash": "2d21ad7ac0ec54afe0f0becf500a4ce7f17716dd",
        "previous_commit_hash": "e66ed4514245eedace3ffb90495429bde6779940",
        "diff_stats": {
            "additions": 11,
            "deletions": 2
        },
        "diff_content": "@@ -44,8 +44,7 @@ public class AnnotatedTypeNameTest {\n     assertEquals(simpleString, TypeName.get(String.class));\n     TypeName annotated = simpleString.annotated(NEVER_NULL);\n     assertTrue(annotated.isAnnotated());\n-    assertEquals(simpleString, annotated.annotated());\n-    assertFalse(annotated.annotated().isAnnotated());\n+    assertEquals(annotated, annotated.annotated());\n   }\n \n   @Test public void annotatedType() {\n@@ -55,6 +54,16 @@ public class AnnotatedTypeNameTest {\n     assertEquals(expected, actual);\n   }\n \n+  @Test public void annotatedTwice() {\n+    String expected = \"@java.lang.Override @\" + NN + \" java.lang.String\";\n+    TypeName type = TypeName.get(String.class);\n+    String actual =\n+        type.annotated(NEVER_NULL)\n+            .annotated(AnnotationSpec.builder(Override.class).build())\n+            .toString();\n+    assertEquals(expected, actual);\n+  }\n+\n   @Test public void annotatedParameterizedType() {\n     String expected = \"@\" + NN + \" java.util.List<java.lang.String>\";\n     TypeName type = ParameterizedTypeName.get(List.class, String.class);\n"
    },
    {
        "commit_hash": "023d25687224734cf539bd6f2d2ddc4f89f46125",
        "previous_commit_hash": "2d21ad7ac0ec54afe0f0becf500a4ce7f17716dd",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -41,7 +41,7 @@ public final class ArrayTypeName extends TypeName {\n   }\n \n   @Override public ArrayTypeName annotated(List<AnnotationSpec> annotations) {\n-    return new ArrayTypeName(componentType, prependAnnotations(annotations));\n+    return new ArrayTypeName(componentType, concatAnnotations(annotations));\n   }\n \n   @Override CodeWriter emit(CodeWriter out) throws IOException {\n"
    },
    {
        "commit_hash": "023d25687224734cf539bd6f2d2ddc4f89f46125",
        "previous_commit_hash": "2d21ad7ac0ec54afe0f0becf500a4ce7f17716dd",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -55,7 +55,7 @@ public final class ClassName extends TypeName implements Comparable<ClassName> {\n   }\n \n   @Override public ClassName annotated(List<AnnotationSpec> annotations) {\n-    return new ClassName(names, prependAnnotations(annotations));\n+    return new ClassName(names, concatAnnotations(annotations));\n   }\n \n   /** Returns the package name, like {@code \"java.util\"} for {@code Map.Entry}. */\n"
    },
    {
        "commit_hash": "023d25687224734cf539bd6f2d2ddc4f89f46125",
        "previous_commit_hash": "2d21ad7ac0ec54afe0f0becf500a4ce7f17716dd",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -49,7 +49,7 @@ public final class ParameterizedTypeName extends TypeName {\n   }\n \n   @Override public ParameterizedTypeName annotated(List<AnnotationSpec> annotations) {\n-    return new ParameterizedTypeName(rawType, typeArguments, prependAnnotations(annotations));\n+    return new ParameterizedTypeName(rawType, typeArguments, concatAnnotations(annotations));\n   }\n \n   @Override CodeWriter emit(CodeWriter out) throws IOException {\n"
    },
    {
        "commit_hash": "023d25687224734cf539bd6f2d2ddc4f89f46125",
        "previous_commit_hash": "2d21ad7ac0ec54afe0f0becf500a4ce7f17716dd",
        "diff_stats": {
            "additions": 4,
            "deletions": 4
        },
        "diff_content": "@@ -110,12 +110,12 @@ public class TypeName {\n \n   public TypeName annotated(List<AnnotationSpec> annotations) {\n     Util.checkNotNull(annotations, \"annotations == null\");\n-    return new TypeName(keyword, prependAnnotations(annotations));\n+    return new TypeName(keyword, concatAnnotations(annotations));\n   }\n \n-  protected final List<AnnotationSpec> prependAnnotations(List<AnnotationSpec> annotations) {\n-    List<AnnotationSpec> allAnnotations = new ArrayList<>(annotations);\n-    allAnnotations.addAll(this.annotations);\n+  protected final List<AnnotationSpec> concatAnnotations(List<AnnotationSpec> annotations) {\n+    List<AnnotationSpec> allAnnotations = new ArrayList<>(this.annotations);\n+    allAnnotations.addAll(annotations);\n     return allAnnotations;\n   }\n \n"
    },
    {
        "commit_hash": "023d25687224734cf539bd6f2d2ddc4f89f46125",
        "previous_commit_hash": "2d21ad7ac0ec54afe0f0becf500a4ce7f17716dd",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -55,7 +55,7 @@ public final class WildcardTypeName extends TypeName {\n   }\n \n   @Override public WildcardTypeName annotated(List<AnnotationSpec> annotations) {\n-    return new WildcardTypeName(upperBounds, lowerBounds, prependAnnotations(annotations));\n+    return new WildcardTypeName(upperBounds, lowerBounds, concatAnnotations(annotations));\n   }\n \n   @Override CodeWriter emit(CodeWriter out) throws IOException {\n"
    },
    {
        "commit_hash": "023d25687224734cf539bd6f2d2ddc4f89f46125",
        "previous_commit_hash": "2d21ad7ac0ec54afe0f0becf500a4ce7f17716dd",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -55,7 +55,7 @@ public class AnnotatedTypeNameTest {\n   }\n \n   @Test public void annotatedTwice() {\n-    String expected = \"@java.lang.Override @\" + NN + \" java.lang.String\";\n+    String expected = \"@\" + NN + \" @java.lang.Override java.lang.String\";\n     TypeName type = TypeName.get(String.class);\n     String actual =\n         type.annotated(NEVER_NULL)\n"
    },
    {
        "commit_hash": "c759d9a47276b392739f8711c8a476f98c2b2f6a",
        "previous_commit_hash": "0ee14809c410c8cf52f4c7e5612cda5bbc3b7097",
        "diff_stats": {
            "additions": 5,
            "deletions": 2
        },
        "diff_content": "@@ -22,7 +22,6 @@ import java.util.ArrayList;\n import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n-\n import javax.lang.model.element.TypeParameterElement;\n import javax.lang.model.type.ArrayType;\n \n@@ -44,8 +43,12 @@ public final class ArrayTypeName extends TypeName {\n     return new ArrayTypeName(componentType, concatAnnotations(annotations));\n   }\n \n+  @Override public TypeName withoutAnnotations() {\n+    return new ArrayTypeName(componentType);\n+  }\n+\n   @Override CodeWriter emit(CodeWriter out) throws IOException {\n-    return emitAnnotations(out).emit(\"$T[]\", componentType);\n+    return out.emit(\"$T[]\", componentType);\n   }\n \n   /** Returns an array type whose elements are all instances of {@code componentType}. */\n"
    },
    {
        "commit_hash": "c759d9a47276b392739f8711c8a476f98c2b2f6a",
        "previous_commit_hash": "0ee14809c410c8cf52f4c7e5612cda5bbc3b7097",
        "diff_stats": {
            "additions": 5,
            "deletions": 1
        },
        "diff_content": "@@ -58,6 +58,10 @@ public final class ClassName extends TypeName implements Comparable<ClassName> {\n     return new ClassName(names, concatAnnotations(annotations));\n   }\n \n+  @Override public TypeName withoutAnnotations() {\n+    return new ClassName(names);\n+  }\n+\n   /** Returns the package name, like {@code \"java.util\"} for {@code Map.Entry}. */\n   public String packageName() {\n     return names.get(0);\n@@ -203,6 +207,6 @@ public final class ClassName extends TypeName implements Comparable<ClassName> {\n   }\n \n   @Override CodeWriter emit(CodeWriter out) throws IOException {\n-    return emitAnnotations(out).emitAndIndent(out.lookupName(this));\n+    return out.emitAndIndent(out.lookupName(this));\n   }\n }\n"
    },
    {
        "commit_hash": "c759d9a47276b392739f8711c8a476f98c2b2f6a",
        "previous_commit_hash": "0ee14809c410c8cf52f4c7e5612cda5bbc3b7097",
        "diff_stats": {
            "additions": 4,
            "deletions": 0
        },
        "diff_content": "@@ -231,6 +231,10 @@ final class CodeWriter {\n \n         case \"$T\":\n           TypeName typeName = (TypeName) codeBlock.args.get(a++);\n+          if (typeName.isAnnotated()) {\n+            typeName.emitAnnotations(this);\n+            typeName = typeName.withoutAnnotations();\n+          }\n           // defer \"typeName.emit(this)\" if next format part will be handled by the default case\n           if (typeName instanceof ClassName && partIterator.hasNext()) {\n             if (!codeBlock.formatParts.get(partIterator.nextIndex()).startsWith(\"$\")) {\n"
    },
    {
        "commit_hash": "c759d9a47276b392739f8711c8a476f98c2b2f6a",
        "previous_commit_hash": "0ee14809c410c8cf52f4c7e5612cda5bbc3b7097",
        "diff_stats": {
            "additions": 6,
            "deletions": 1
        },
        "diff_content": "@@ -52,13 +52,18 @@ public final class ParameterizedTypeName extends TypeName {\n     return new ParameterizedTypeName(rawType, typeArguments, concatAnnotations(annotations));\n   }\n \n+  @Override public TypeName withoutAnnotations() {\n+    return new ParameterizedTypeName(rawType, typeArguments);\n+  }\n+\n   @Override CodeWriter emit(CodeWriter out) throws IOException {\n-    emitAnnotations(out);\n+    rawType.emitAnnotations(out);\n     rawType.emit(out);\n     out.emitAndIndent(\"<\");\n     boolean firstParameter = true;\n     for (TypeName parameter : typeArguments) {\n       if (!firstParameter) out.emitAndIndent(\", \");\n+      parameter.emitAnnotations(out);\n       parameter.emit(out);\n       firstParameter = false;\n     }\n"
    },
    {
        "commit_hash": "c759d9a47276b392739f8711c8a476f98c2b2f6a",
        "previous_commit_hash": "0ee14809c410c8cf52f4c7e5612cda5bbc3b7097",
        "diff_stats": {
            "additions": 8,
            "deletions": 3
        },
        "diff_content": "@@ -26,7 +26,6 @@ import java.util.Arrays;\n import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n-\n import javax.lang.model.element.TypeElement;\n import javax.lang.model.element.TypeParameterElement;\n import javax.lang.model.type.ArrayType;\n@@ -113,6 +112,10 @@ public class TypeName {\n     return new TypeName(keyword, concatAnnotations(annotations));\n   }\n \n+  public TypeName withoutAnnotations() {\n+    return new TypeName(keyword);\n+  }\n+\n   protected final List<AnnotationSpec> concatAnnotations(List<AnnotationSpec> annotations) {\n     List<AnnotationSpec> allAnnotations = new ArrayList<>(this.annotations);\n     allAnnotations.addAll(annotations);\n@@ -179,7 +182,9 @@ public class TypeName {\n   @Override public final String toString() {\n     try {\n       StringBuilder result = new StringBuilder();\n-      emit(new CodeWriter(result));\n+      CodeWriter codeWriter = new CodeWriter(result);\n+      emitAnnotations(codeWriter);\n+      emit(codeWriter);\n       return result.toString();\n     } catch (IOException e) {\n       throw new AssertionError();\n@@ -188,7 +193,7 @@ public class TypeName {\n \n   CodeWriter emit(CodeWriter out) throws IOException {\n     if (keyword == null) throw new AssertionError();\n-    return emitAnnotations(out).emitAndIndent(keyword);\n+    return out.emitAndIndent(keyword);\n   }\n \n   CodeWriter emitAnnotations(CodeWriter out) throws IOException {\n"
    },
    {
        "commit_hash": "c759d9a47276b392739f8711c8a476f98c2b2f6a",
        "previous_commit_hash": "0ee14809c410c8cf52f4c7e5612cda5bbc3b7097",
        "diff_stats": {
            "additions": 5,
            "deletions": 1
        },
        "diff_content": "@@ -53,6 +53,10 @@ public final class TypeVariableName extends TypeName {\n     return new TypeVariableName(name, bounds, annotations);\n   }\n \n+  @Override public TypeName withoutAnnotations() {\n+    return new TypeVariableName(name, bounds);\n+  }\n+\n   private static TypeVariableName of(String name, List<TypeName> bounds) {\n     // Strip java.lang.Object from bounds if it is present.\n     List<TypeName> boundsNoObject = new ArrayList<>(bounds);\n@@ -61,7 +65,7 @@ public final class TypeVariableName extends TypeName {\n   }\n \n   @Override CodeWriter emit(CodeWriter out) throws IOException {\n-    return emitAnnotations(out).emitAndIndent(name);\n+    return out.emitAndIndent(name);\n   }\n \n   /** Returns type variable named {@code name} without bounds. */\n"
    },
    {
        "commit_hash": "c759d9a47276b392739f8711c8a476f98c2b2f6a",
        "previous_commit_hash": "0ee14809c410c8cf52f4c7e5612cda5bbc3b7097",
        "diff_stats": {
            "additions": 4,
            "deletions": 1
        },
        "diff_content": "@@ -58,8 +58,11 @@ public final class WildcardTypeName extends TypeName {\n     return new WildcardTypeName(upperBounds, lowerBounds, concatAnnotations(annotations));\n   }\n \n+  @Override public TypeName withoutAnnotations() {\n+    return new WildcardTypeName(upperBounds, lowerBounds);\n+  }\n+\n   @Override CodeWriter emit(CodeWriter out) throws IOException {\n-    emitAnnotations(out);\n     if (lowerBounds.size() == 1) {\n       return out.emit(\"? super $T\", lowerBounds.get(0));\n     }\n"
    },
    {
        "commit_hash": "c759d9a47276b392739f8711c8a476f98c2b2f6a",
        "previous_commit_hash": "0ee14809c410c8cf52f4c7e5612cda5bbc3b7097",
        "diff_stats": {
            "additions": 22,
            "deletions": 0
        },
        "diff_content": "@@ -207,6 +207,28 @@ public final class TypeSpecTest {\n         + \"}\\n\");\n   }\n \n+  /**\n+   * We had a bug where annotations were preventing us from doing the right thing when resolving\n+   * imports. https://github.com/square/javapoet/issues/422\n+   */\n+  @Test public void annotationsAndJavaLangTypes() throws Exception {\n+    ClassName freeRange = ClassName.get(\"javax.annotation\", \"FreeRange\");\n+    TypeSpec taco = TypeSpec.classBuilder(\"EthicalTaco\")\n+        .addField(ClassName.get(String.class)\n+            .annotated(AnnotationSpec.builder(freeRange).build()), \"meat\")\n+        .build();\n+\n+    assertThat(toString(taco)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import java.lang.String;\\n\"\n+        + \"import javax.annotation.FreeRange;\\n\"\n+        + \"\\n\"\n+        + \"class EthicalTaco {\\n\"\n+        + \"  @FreeRange String meat;\\n\"\n+        + \"}\\n\");\n+  }\n+\n   @Test public void retrofitStyleInterface() throws Exception {\n     ClassName observable = ClassName.get(tacosPackage, \"Observable\");\n     ClassName fooBar = ClassName.get(tacosPackage, \"FooBar\");\n"
    },
    {
        "commit_hash": "944a070a02f56ddab43f9345b11ba14e54c3e72c",
        "previous_commit_hash": "19fe0a411228683d54e84e9e16b755bcc1a67058",
        "diff_stats": {
            "additions": 16,
            "deletions": 0
        },
        "diff_content": "@@ -90,14 +90,26 @@ public final class TypeSpec {\n     return new Builder(Kind.CLASS, checkNotNull(name, \"name == null\"), null);\n   }\n \n+  public static Builder classBuilder(ClassName className) {\n+    return classBuilder(checkNotNull(className, \"className == null\").simpleName());\n+  }\n+\n   public static Builder interfaceBuilder(String name) {\n     return new Builder(Kind.INTERFACE, checkNotNull(name, \"name == null\"), null);\n   }\n \n+  public static Builder interfaceBuilder(ClassName className) {\n+    return interfaceBuilder(checkNotNull(className, \"className == null\").simpleName());\n+  }\n+\n   public static Builder enumBuilder(String name) {\n     return new Builder(Kind.ENUM, checkNotNull(name, \"name == null\"), null);\n   }\n \n+  public static Builder enumBuilder(ClassName className) {\n+    return enumBuilder(checkNotNull(className, \"className == null\").simpleName());\n+  }\n+\n   public static Builder anonymousClassBuilder(String typeArgumentsFormat, Object... args) {\n     return new Builder(Kind.CLASS, null, CodeBlock.builder()\n         .add(typeArgumentsFormat, args)\n@@ -108,6 +120,10 @@ public final class TypeSpec {\n     return new Builder(Kind.ANNOTATION, checkNotNull(name, \"name == null\"), null);\n   }\n \n+  public static Builder annotationBuilder(ClassName className) {\n+    return annotationBuilder(checkNotNull(className, \"className == null\").simpleName());\n+  }\n+\n   public Builder toBuilder() {\n     Builder builder = new Builder(kind, name, anonymousTypeArguments);\n     builder.javadoc.add(javadoc);\n"
    },
    {
        "commit_hash": "944a070a02f56ddab43f9345b11ba14e54c3e72c",
        "previous_commit_hash": "19fe0a411228683d54e84e9e16b755bcc1a67058",
        "diff_stats": {
            "additions": 9,
            "deletions": 1
        },
        "diff_content": "@@ -2071,7 +2071,7 @@ public final class TypeSpecTest {\n             .addStatement(\"foo = $S\", \"FOO\")\n             .build())\n         .build();\n-    \n+\n     TypeSpec recreatedTaco = taco.toBuilder().build();\n     assertThat(toString(taco)).isEqualTo(toString(recreatedTaco));\n \n@@ -2161,6 +2161,14 @@ public final class TypeSpecTest {\n     assertThat(a.hashCode()).isEqualTo(b.hashCode());\n   }\n \n+  @Test public void classNameFactories() {\n+    ClassName className = ClassName.get(\"com.example\", \"Example\");\n+    assertThat(TypeSpec.classBuilder(className).build().name).isEqualTo(\"Example\");\n+    assertThat(TypeSpec.interfaceBuilder(className).build().name).isEqualTo(\"Example\");\n+    assertThat(TypeSpec.enumBuilder(className).addEnumConstant(\"A\").build().name).isEqualTo(\"Example\");\n+    assertThat(TypeSpec.annotationBuilder(className).build().name).isEqualTo(\"Example\");\n+  }\n+\n   private CodeBlock codeBlock(String format, Object... args) {\n     return CodeBlock.builder()\n         .add(format, args)\n"
    },
    {
        "commit_hash": "b42c9388a5098270adc0ff58c48084deffe01b25",
        "previous_commit_hash": "f1bf5464be6aab53eac63a5f6bdd719ee54fe9dc",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -204,7 +204,7 @@ public final class AnnotationSpec {\n     }\n \n     public Builder addMember(String name, String format, Object... args) {\n-      return addMember(name, CodeBlock.builder().add(format, args).build());\n+      return addMember(name, CodeBlock.of(format, args));\n     }\n \n     public Builder addMember(String name, CodeBlock codeBlock) {\n"
    },
    {
        "commit_hash": "b42c9388a5098270adc0ff58c48084deffe01b25",
        "previous_commit_hash": "f1bf5464be6aab53eac63a5f6bdd719ee54fe9dc",
        "diff_stats": {
            "additions": 4,
            "deletions": 0
        },
        "diff_content": "@@ -90,6 +90,10 @@ public final class CodeBlock {\n     }\n   }\n \n+  public static CodeBlock of(String format, Object... args) {\n+    return new Builder().add(format, args).build();\n+  }\n+\n   public static Builder builder() {\n     return new Builder();\n   }\n"
    },
    {
        "commit_hash": "b42c9388a5098270adc0ff58c48084deffe01b25",
        "previous_commit_hash": "f1bf5464be6aab53eac63a5f6bdd719ee54fe9dc",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -203,7 +203,7 @@ final class CodeWriter {\n   }\n \n   public CodeWriter emit(String format, Object... args) throws IOException {\n-    return emit(CodeBlock.builder().add(format, args).build());\n+    return emit(CodeBlock.of(format, args));\n   }\n \n   public CodeWriter emit(CodeBlock codeBlock) throws IOException {\n"
    },
    {
        "commit_hash": "b42c9388a5098270adc0ff58c48084deffe01b25",
        "previous_commit_hash": "f1bf5464be6aab53eac63a5f6bdd719ee54fe9dc",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -154,7 +154,7 @@ public final class FieldSpec {\n     }\n \n     public Builder initializer(String format, Object... args) {\n-      return initializer(CodeBlock.builder().add(format, args).build());\n+      return initializer(CodeBlock.of(format, args));\n     }\n \n     public Builder initializer(CodeBlock codeBlock) {\n"
    },
    {
        "commit_hash": "b42c9388a5098270adc0ff58c48084deffe01b25",
        "previous_commit_hash": "f1bf5464be6aab53eac63a5f6bdd719ee54fe9dc",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -420,7 +420,7 @@ public final class MethodSpec {\n     }\n \n     public Builder defaultValue(String format, Object... args) {\n-      return defaultValue(CodeBlock.builder().add(format, args).build());\n+      return defaultValue(CodeBlock.of(format, args));\n     }\n \n     public Builder defaultValue(CodeBlock codeBlock) {\n"
    },
    {
        "commit_hash": "b42c9388a5098270adc0ff58c48084deffe01b25",
        "previous_commit_hash": "f1bf5464be6aab53eac63a5f6bdd719ee54fe9dc",
        "diff_stats": {
            "additions": 5,
            "deletions": 0
        },
        "diff_content": "@@ -32,6 +32,11 @@ public final class CodeBlockTest {\n     assertThat(a.hashCode()).isEqualTo(b.hashCode());\n   }\n \n+  @Test public void of() {\n+    CodeBlock a = CodeBlock.of(\"$L taco\", \"delicious\");\n+    assertThat(a.toString()).isEqualTo(\"delicious taco\");\n+  }\n+\n   @Test public void indentCannotBeIndexed() {\n     try {\n       CodeBlock.builder().add(\"$1>\", \"taco\").build();\n"
    },
    {
        "commit_hash": "b42c9388a5098270adc0ff58c48084deffe01b25",
        "previous_commit_hash": "f1bf5464be6aab53eac63a5f6bdd719ee54fe9dc",
        "diff_stats": {
            "additions": 12,
            "deletions": 18
        },
        "diff_content": "@@ -1834,21 +1834,21 @@ public final class TypeSpecTest {\n         return \"foo\";\n       }\n     };\n-    assertThat(codeBlock(\"$L\", value).toString()).isEqualTo(\"foo\");\n+    assertThat(CodeBlock.of(\"$L\", value).toString()).isEqualTo(\"foo\");\n   }\n \n   @Test public void nameFromCharSequence() {\n-    assertThat(codeBlock(\"$N\", \"text\").toString()).isEqualTo(\"text\");\n+    assertThat(CodeBlock.of(\"$N\", \"text\").toString()).isEqualTo(\"text\");\n   }\n \n   @Test public void nameFromField() {\n     FieldSpec field = FieldSpec.builder(String.class, \"field\").build();\n-    assertThat(codeBlock(\"$N\", field).toString()).isEqualTo(\"field\");\n+    assertThat(CodeBlock.of(\"$N\", field).toString()).isEqualTo(\"field\");\n   }\n \n   @Test public void nameFromParameter() {\n     ParameterSpec parameter = ParameterSpec.builder(String.class, \"parameter\").build();\n-    assertThat(codeBlock(\"$N\", parameter).toString()).isEqualTo(\"parameter\");\n+    assertThat(CodeBlock.of(\"$N\", parameter).toString()).isEqualTo(\"parameter\");\n   }\n \n   @Test public void nameFromMethod() {\n@@ -1856,12 +1856,12 @@ public final class TypeSpecTest {\n         .addModifiers(Modifier.ABSTRACT)\n         .returns(String.class)\n         .build();\n-    assertThat(codeBlock(\"$N\", method).toString()).isEqualTo(\"method\");\n+    assertThat(CodeBlock.of(\"$N\", method).toString()).isEqualTo(\"method\");\n   }\n \n   @Test public void nameFromType() {\n     TypeSpec type = TypeSpec.classBuilder(\"Type\").build();\n-    assertThat(codeBlock(\"$N\", type).toString()).isEqualTo(\"Type\");\n+    assertThat(CodeBlock.of(\"$N\", type).toString()).isEqualTo(\"Type\");\n   }\n \n   @Test public void nameFromUnsupportedType() {\n@@ -1879,30 +1879,30 @@ public final class TypeSpecTest {\n         return \"foo\";\n       }\n     };\n-    assertThat(codeBlock(\"$S\", value).toString()).isEqualTo(\"\\\"foo\\\"\");\n+    assertThat(CodeBlock.of(\"$S\", value).toString()).isEqualTo(\"\\\"foo\\\"\");\n   }\n \n   @Test public void stringFromNull() {\n-    assertThat(codeBlock(\"$S\", new Object[] {null}).toString()).isEqualTo(\"null\");\n+    assertThat(CodeBlock.of(\"$S\", new Object[] {null}).toString()).isEqualTo(\"null\");\n   }\n \n   @Test public void typeFromTypeName() {\n     TypeName typeName = TypeName.get(String.class);\n-    assertThat(codeBlock(\"$T\", typeName).toString()).isEqualTo(\"java.lang.String\");\n+    assertThat(CodeBlock.of(\"$T\", typeName).toString()).isEqualTo(\"java.lang.String\");\n   }\n \n   @Test public void typeFromTypeMirror() {\n     TypeMirror mirror = getElement(String.class).asType();\n-    assertThat(codeBlock(\"$T\", mirror).toString()).isEqualTo(\"java.lang.String\");\n+    assertThat(CodeBlock.of(\"$T\", mirror).toString()).isEqualTo(\"java.lang.String\");\n   }\n \n   @Test public void typeFromTypeElement() {\n     TypeElement element = getElement(String.class);\n-    assertThat(codeBlock(\"$T\", element).toString()).isEqualTo(\"java.lang.String\");\n+    assertThat(CodeBlock.of(\"$T\", element).toString()).isEqualTo(\"java.lang.String\");\n   }\n \n   @Test public void typeFromReflectType() {\n-    assertThat(codeBlock(\"$T\", String.class).toString()).isEqualTo(\"java.lang.String\");\n+    assertThat(CodeBlock.of(\"$T\", String.class).toString()).isEqualTo(\"java.lang.String\");\n   }\n \n   @Test public void typeFromUnsupportedType() {\n@@ -2168,10 +2168,4 @@ public final class TypeSpecTest {\n     assertThat(TypeSpec.enumBuilder(className).addEnumConstant(\"A\").build().name).isEqualTo(\"Example\");\n     assertThat(TypeSpec.annotationBuilder(className).build().name).isEqualTo(\"Example\");\n   }\n-\n-  private CodeBlock codeBlock(String format, Object... args) {\n-    return CodeBlock.builder()\n-        .add(format, args)\n-        .build();\n-  }\n }\n"
    },
    {
        "commit_hash": "98c8b729607a14632b6c82975f05610d4ce5ce53",
        "previous_commit_hash": "ae486521e3b81415d6243983f84289c9d4ad1dc9",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -274,7 +274,7 @@ public final class JavaFileTest {\n     String source = JavaFile.builder(\"com.squareup.tacos\",\n         TypeSpec.classBuilder(\"Taco\")\n             .addField(Date.class, \"madeFreshDate\")\n-            .addField(java.sql.Date.class, \"madeFreshDatabaseDate\")\n+            .addField(ClassName.get(\"java.sql\", \"Date\"), \"madeFreshDatabaseDate\")\n             .build())\n         .build()\n         .toString();\n"
    },
    {
        "commit_hash": "98c8b729607a14632b6c82975f05610d4ce5ce53",
        "previous_commit_hash": "ae486521e3b81415d6243983f84289c9d4ad1dc9",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -21,10 +21,10 @@ import static org.junit.Assert.assertNotEquals;\n \n import java.io.Serializable;\n import java.lang.reflect.Method;\n-import java.rmi.server.UID;\n import java.util.Comparator;\n import java.util.List;\n import java.util.Set;\n+import java.util.UUID;\n import org.junit.Test;\n \n public class TypeNameTest {\n@@ -70,8 +70,8 @@ public class TypeNameTest {\n   @Test public void equalsAndHashCodeParameterizedTypeName() {\n     assertEqualsHashCodeAndToString(ParameterizedTypeName.get(Object.class),\n         ParameterizedTypeName.get(Object.class));\n-    assertEqualsHashCodeAndToString(ParameterizedTypeName.get(Set.class, UID.class),\n-        ParameterizedTypeName.get(Set.class, UID.class));\n+    assertEqualsHashCodeAndToString(ParameterizedTypeName.get(Set.class, UUID.class),\n+        ParameterizedTypeName.get(Set.class, UUID.class));\n     assertNotEquals(ClassName.get(List.class), ParameterizedTypeName.get(List.class,\n         String.class));\n   }\n"
    },
    {
        "commit_hash": "34cfcdf973527ec0f3149d868e55d6600802bf9d",
        "previous_commit_hash": "f1bf5464be6aab53eac63a5f6bdd719ee54fe9dc",
        "diff_stats": {
            "additions": 5,
            "deletions": 0
        },
        "diff_content": "@@ -30,6 +30,7 @@ import javax.lang.model.element.TypeElement;\n import javax.lang.model.element.TypeParameterElement;\n import javax.lang.model.type.ArrayType;\n import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.ErrorType;\n import javax.lang.model.type.NoType;\n import javax.lang.model.type.PrimitiveType;\n import javax.lang.model.type.TypeKind;\n@@ -246,6 +247,10 @@ public class TypeName {\n         return new ParameterizedTypeName(rawType, typeArgumentNames);\n       }\n \n+      @Override public TypeName visitError(ErrorType t, Void p) {\n+        return visitDeclared(t, p);\n+      }\n+\n       @Override public ArrayTypeName visitArray(ArrayType t, Void p) {\n         return ArrayTypeName.get(t, typeVariables);\n       }\n"
    },
    {
        "commit_hash": "34cfcdf973527ec0f3149d868e55d6600802bf9d",
        "previous_commit_hash": "f1bf5464be6aab53eac63a5f6bdd719ee54fe9dc",
        "diff_stats": {
            "additions": 58,
            "deletions": 0
        },
        "diff_content": "@@ -19,16 +19,22 @@ import static com.google.common.truth.Truth.assertThat;\n import static org.junit.Assert.*;\n \n import java.io.Serializable;\n+import java.lang.annotation.Annotation;\n import java.nio.charset.Charset;\n+import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n import javax.lang.model.element.TypeElement;\n import javax.lang.model.element.TypeParameterElement;\n import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.ErrorType;\n import javax.lang.model.type.TypeKind;\n import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.type.TypeVisitor;\n import javax.lang.model.type.WildcardType;\n import javax.lang.model.util.Elements;\n import javax.lang.model.util.Types;\n@@ -63,6 +69,12 @@ public abstract class AbstractTypesTest {\n         .isEqualTo(ParameterizedTypeName.get(ClassName.get(Set.class), ClassName.OBJECT));\n   }\n \n+  @Test public void getErrorType() {\n+    ErrorType errorType =\n+        new DeclaredTypeAsErrorType(getTypes().getDeclaredType(getElement(Set.class)));\n+    assertThat(TypeName.get(errorType)).isEqualTo(ClassName.get(Set.class));\n+  }\n+\n   static class Parameterized<\n       Simple,\n       ExtendsClass extends Number,\n@@ -234,4 +246,50 @@ public abstract class AbstractTypesTest {\n     } catch (UnsupportedOperationException expected) {\n     }\n   }\n+\n+  private static class DeclaredTypeAsErrorType implements ErrorType {\n+    private final DeclaredType declaredType;\n+\n+    public DeclaredTypeAsErrorType(DeclaredType declaredType) {\n+      this.declaredType = declaredType;\n+    }\n+\n+    @Override\n+    public Element asElement() {\n+      return declaredType.asElement();\n+    }\n+\n+    @Override\n+    public TypeMirror getEnclosingType() {\n+      return declaredType.getEnclosingType();\n+    }\n+\n+    @Override\n+    public List<? extends TypeMirror> getTypeArguments() {\n+      return declaredType.getTypeArguments();\n+    }\n+\n+    @Override\n+    public TypeKind getKind() {\n+      return declaredType.getKind();\n+    }\n+\n+    @Override\n+    public <R, P> R accept(TypeVisitor<R, P> typeVisitor, P p) {\n+      return typeVisitor.visitError(this, p);\n+    }\n+\n+    // JDK8 Compatibility:\n+    public <A extends Annotation> A[] getAnnotationsByType(Class<A> annotationType) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    public <A extends Annotation> A getAnnotation(Class<A> annotationType) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    public List<? extends AnnotationMirror> getAnnotationMirrors() {\n+      throw new UnsupportedOperationException();\n+    }\n+  }\n }\n"
    },
    {
        "commit_hash": "f80f1072b9c09b95b36b71d6d9c211f9c4a68eb6",
        "previous_commit_hash": "1a16944b319057b572bc5eab1267744a26b31835",
        "diff_stats": {
            "additions": 26,
            "deletions": 0
        },
        "diff_content": "@@ -21,6 +21,8 @@ import static org.junit.Assert.assertNotEquals;\n import static org.junit.Assert.assertTrue;\n \n import java.util.List;\n+import java.util.Map;\n+import org.junit.Ignore;\n import org.junit.Test;\n \n public class AnnotatedTypeNameTest {\n@@ -111,4 +113,28 @@ public class AnnotatedTypeNameTest {\n     assertEquals(type.annotated(NEVER_NULL).hashCode(), type.annotated(NEVER_NULL).hashCode());\n     assertNotEquals(type.hashCode(), type.annotated(NEVER_NULL).hashCode());\n   }\n+\n+  // https://github.com/square/javapoet/issues/431\n+  // @Target(ElementType.TYPE_USE) requires Java 1.8\n+  public @interface TypeUseAnnotation {}\n+\n+  // https://github.com/square/javapoet/issues/431\n+  @Ignore @Test public void annotatedNestedType() {\n+    String expected = \"java.util.Map.@\" + TypeUseAnnotation.class.getCanonicalName() + \" Entry\";\n+    AnnotationSpec typeUseAnnotation = AnnotationSpec.builder(TypeUseAnnotation.class).build();\n+    TypeName type = TypeName.get(Map.Entry.class).annotated(typeUseAnnotation);\n+    String actual = type.toString();\n+    assertEquals(expected, actual);\n+  }\n+\n+  // https://github.com/square/javapoet/issues/431\n+  @Ignore @Test public void annotatedNestedParameterizedType() {\n+    String expected = \"java.util.Map.@\" + TypeUseAnnotation.class.getCanonicalName()\n+        + \" Entry<java.lang.Byte, java.lang.Byte>\";\n+    AnnotationSpec typeUseAnnotation = AnnotationSpec.builder(TypeUseAnnotation.class).build();\n+    TypeName type = ParameterizedTypeName.get(Map.Entry.class, Byte.class, Byte.class)\n+        .annotated(typeUseAnnotation);\n+    String actual = type.toString();\n+    assertEquals(expected, actual);\n+  }\n }\n"
    },
    {
        "commit_hash": "3e10db6f9600b7f43a71244c3c441e0f2b8c5ebb",
        "previous_commit_hash": "4b0bd36c55658efb44edcb042db2dfb9bb1b9722",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -287,7 +287,7 @@ public final class MethodSpec {\n     private List<TypeVariableName> typeVariables = new ArrayList<>();\n     private TypeName returnType;\n     private final List<ParameterSpec> parameters = new ArrayList<>();\n-    private final List<TypeName> exceptions = new ArrayList<>();\n+    private final Set<TypeName> exceptions = new LinkedHashSet<>();\n     private final CodeBlock.Builder code = CodeBlock.builder();\n     private boolean varargs;\n     private CodeBlock defaultValue;\n"
    },
    {
        "commit_hash": "3e10db6f9600b7f43a71244c3c441e0f2b8c5ebb",
        "previous_commit_hash": "4b0bd36c55658efb44edcb042db2dfb9bb1b9722",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -73,8 +73,8 @@ final class Util {\n     if (!condition) throw new IllegalStateException(String.format(format, args));\n   }\n \n-  static <T> List<T> immutableList(List<T> list) {\n-    return Collections.unmodifiableList(new ArrayList<>(list));\n+  static <T> List<T> immutableList(Collection<T> collection) {\n+    return Collections.unmodifiableList(new ArrayList<>(collection));\n   }\n \n   static <T> Set<T> immutableSet(Collection<T> set) {\n"
    },
    {
        "commit_hash": "3e10db6f9600b7f43a71244c3c441e0f2b8c5ebb",
        "previous_commit_hash": "4b0bd36c55658efb44edcb042db2dfb9bb1b9722",
        "diff_stats": {
            "additions": 16,
            "deletions": 0
        },
        "diff_content": "@@ -21,9 +21,11 @@ import java.io.Closeable;\n import java.io.IOException;\n import java.lang.annotation.ElementType;\n import java.lang.annotation.Target;\n+import java.util.Arrays;\n import java.util.Collection;\n import java.util.List;\n import java.util.concurrent.Callable;\n+import java.util.concurrent.TimeoutException;\n import javax.lang.model.element.Element;\n import javax.lang.model.element.ExecutableElement;\n import javax.lang.model.element.Modifier;\n@@ -206,4 +208,18 @@ public final class MethodSpecTest {\n     assertThat(a.hashCode()).isEqualTo(b.hashCode());\n   }\n \n+  @Test public void duplicateExceptionsIgnored() {\n+    ClassName ioException = ClassName.get(IOException.class);\n+    ClassName timeoutException = ClassName.get(TimeoutException.class);\n+    MethodSpec methodSpec = MethodSpec.methodBuilder(\"duplicateExceptions\")\n+      .addException(ioException)\n+      .addException(timeoutException)\n+      .addException(timeoutException)\n+      .addException(ioException)\n+      .build();\n+    assertThat(methodSpec.exceptions).isEqualTo(Arrays.asList(ioException, timeoutException));\n+    assertThat(methodSpec.toBuilder().addException(ioException).build().exceptions)\n+      .isEqualTo(Arrays.asList(ioException, timeoutException));\n+  }\n+\n }\n"
    },
    {
        "commit_hash": "4ec59220a919b6b9d585fbdd32123c422667f21e",
        "previous_commit_hash": "90064083ec9b1e0a1f882bc284198c247580385a",
        "diff_stats": {
            "additions": 15,
            "deletions": 0
        },
        "diff_content": "@@ -57,6 +57,21 @@ public final class TypeVariableName extends TypeName {\n     return new TypeVariableName(name, bounds);\n   }\n \n+  public TypeVariableName withBounds(Type... bounds) {\n+    return withBounds(TypeName.list(bounds));\n+  }\n+\n+  public TypeVariableName withBounds(TypeName... bounds) {\n+    return withBounds(Arrays.asList(bounds));\n+  }\n+\n+  public TypeVariableName withBounds(List<TypeName> bounds) {\n+    ArrayList<TypeName> newBounds = new ArrayList<>();\n+    newBounds.addAll(this.bounds);\n+    newBounds.addAll(bounds);\n+    return new TypeVariableName(name, newBounds, annotations);\n+  }\n+\n   private static TypeVariableName of(String name, List<TypeName> bounds) {\n     // Strip java.lang.Object from bounds if it is present.\n     List<TypeName> boundsNoObject = new ArrayList<>(bounds);\n"
    },
    {
        "commit_hash": "4ec59220a919b6b9d585fbdd32123c422667f21e",
        "previous_commit_hash": "90064083ec9b1e0a1f882bc284198c247580385a",
        "diff_stats": {
            "additions": 0,
            "deletions": 1
        },
        "diff_content": "@@ -21,7 +21,6 @@ import static org.junit.Assert.*;\n import java.io.Serializable;\n import java.lang.annotation.Annotation;\n import java.nio.charset.Charset;\n-import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n"
    },
    {
        "commit_hash": "4ec59220a919b6b9d585fbdd32123c422667f21e",
        "previous_commit_hash": "90064083ec9b1e0a1f882bc284198c247580385a",
        "diff_stats": {
            "additions": 23,
            "deletions": 0
        },
        "diff_content": "@@ -578,6 +578,29 @@ public final class TypeSpecTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void typeVariableWithBounds() {\n+    AnnotationSpec a = AnnotationSpec.builder(ClassName.get(\"com.squareup.tacos\", \"A\")).build();\n+    TypeVariableName p = TypeVariableName.get(\"P\", Number.class);\n+    TypeVariableName q = (TypeVariableName) TypeVariableName.get(\"Q\", Number.class).annotated(a);\n+    TypeSpec typeSpec = TypeSpec.classBuilder(\"Location\")\n+        .addTypeVariable(p.withBounds(Comparable.class))\n+        .addTypeVariable(q.withBounds(Comparable.class))\n+        .addField(p, \"x\")\n+        .addField(q, \"y\")\n+        .build();\n+    assertThat(toString(typeSpec)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import java.lang.Comparable;\\n\"\n+        + \"import java.lang.Number;\\n\"\n+        + \"\\n\"\n+        + \"class Location<P extends Number & Comparable, Q extends Number & Comparable> {\\n\"\n+        + \"  P x;\\n\"\n+        + \"\\n\"\n+        + \"  @A Q y;\\n\"\n+        + \"}\\n\");\n+  }\n+\n   @Test public void classImplementsExtends() throws Exception {\n     ClassName taco = ClassName.get(tacosPackage, \"Taco\");\n     ClassName food = ClassName.get(\"com.squareup.tacos\", \"Food\");\n"
    },
    {
        "commit_hash": "859e7892c699d31a7786dfc73f06054bf1369e64",
        "previous_commit_hash": "90064083ec9b1e0a1f882bc284198c247580385a",
        "diff_stats": {
            "additions": 3,
            "deletions": 2
        },
        "diff_content": "@@ -533,8 +533,9 @@ public final class TypeSpec {\n         requireExactlyOneOf(methodSpec.modifiers, Modifier.ABSTRACT, Modifier.STATIC, Util.DEFAULT);\n         requireExactlyOneOf(methodSpec.modifiers, Modifier.PUBLIC, Modifier.PRIVATE);\n       } else if (kind == Kind.ANNOTATION) {\n-        checkState(methodSpec.modifiers.containsAll(kind.implicitMethodModifiers),\n-            \"%s %s.%s cannot have modifiers\", kind, name, methodSpec.name);\n+        checkState(methodSpec.modifiers.equals(kind.implicitMethodModifiers),\n+            \"%s %s.%s requires modifiers %s\",\n+            kind, name, methodSpec.name, kind.implicitMethodModifiers);\n       }\n       if (kind != Kind.ANNOTATION) {\n         checkState(methodSpec.defaultValue == null, \"%s %s.%s cannot have a default value\",\n"
    },
    {
        "commit_hash": "9dee15bb446f7891c10ca3d4c996e647e06b42bb",
        "previous_commit_hash": "b99e692763d53b5b738c9bb85eb6c4799ead2e6d",
        "diff_stats": {
            "additions": 17,
            "deletions": 0
        },
        "diff_content": "@@ -1,6 +1,23 @@\n Change Log\n ==========\n \n+JavaPoet 1.6.0 *(2016-03-19)*\n+----------------------------\n+\n+ * New: Revive `CodeBlock.of()`, a handy factory method for building code blocks.\n+ * New: Add `TypeSpec` factory methods that take a `ClassName`.\n+ * New: `TypeName.annotated()` adds an annotation to a type.\n+ * New: `TypeVariableName.withBounds()` adds bounds to a type variable.\n+ * New: `TypeSpec.Builder.addInitializerBlock()` adds an instance initializer.\n+ * Fix: Make `TypeSpec.Kind` enum public. This can be used to check if a `TypeSpec` is a class,\n+   interface, enum, or annotation.\n+ * Fix: Don\u2019t break import resolution on annotated types.\n+ * Fix: Forbid unexpected modifiers like `private` on annotation members.\n+ * Fix: Deduplicate exceptions in `MethodSpec.Builder`.\n+ * Fix: Treat `ErrorType` like a regular `DeclaredType` in `TypeName.get()`. This should make it\n+   easier to write annotation processors.\n+\n+\n JavaPoet 1.5.1 *(2016-01-10)*\n ----------------------------\n \n"
    },
    {
        "commit_hash": "9dee15bb446f7891c10ca3d4c996e647e06b42bb",
        "previous_commit_hash": "b99e692763d53b5b738c9bb85eb6c4799ead2e6d",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -801,12 +801,12 @@ Download [the latest .jar][dl] or depend via Maven:\n <dependency>\n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.5.1</version>\n+  <version>1.6.0</version>\n </dependency>\n ```\n or Gradle:\n ```groovy\n-compile 'com.squareup:javapoet:1.5.1'\n+compile 'com.squareup:javapoet:1.6.0'\n ```\n \n Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].\n"
    },
    {
        "commit_hash": "3b924132ff45f858be38039f75dab14b477c74fd",
        "previous_commit_hash": "9dee15bb446f7891c10ca3d4c996e647e06b42bb",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.6.0-SNAPSHOT</version>\n+  <version>1.6.0</version>\n \n   <name>JavaPoet</name>\n   <description>Use beautiful Java code to generate beautiful Java code.</description>\n@@ -54,13 +54,13 @@\n     <dependency>\n       <groupId>com.google.truth</groupId>\n       <artifactId>truth</artifactId>\n-      <version>1.0-SNAPSHOT</version>\n+      <version>0.28</version>\n       <scope>test</scope>\n     </dependency>\n     <dependency>\n       <groupId>com.google.testing.compile</groupId>\n       <artifactId>compile-testing</artifactId>\n-      <version>1.0-SNAPSHOT</version>\n+      <version>0.9</version>\n       <scope>test</scope>\n     </dependency>\n     <dependency>\n"
    },
    {
        "commit_hash": "4fd756960d5e16051e3e3506e8614ab80f21d4f8",
        "previous_commit_hash": "3b924132ff45f858be38039f75dab14b477c74fd",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.6.0</version>\n+  <version>1.7.0-SNAPSHOT</version>\n \n   <name>JavaPoet</name>\n   <description>Use beautiful Java code to generate beautiful Java code.</description>\n@@ -54,13 +54,13 @@\n     <dependency>\n       <groupId>com.google.truth</groupId>\n       <artifactId>truth</artifactId>\n-      <version>0.28</version>\n+      <version>1.0-SNAPSHOT</version>\n       <scope>test</scope>\n     </dependency>\n     <dependency>\n       <groupId>com.google.testing.compile</groupId>\n       <artifactId>compile-testing</artifactId>\n-      <version>0.9</version>\n+      <version>1.0-SNAPSHOT</version>\n       <scope>test</scope>\n     </dependency>\n     <dependency>\n"
    },
    {
        "commit_hash": "a8b274e2f0ba92581a16da58c8bfdf79ae5474e2",
        "previous_commit_hash": "4fd756960d5e16051e3e3506e8614ab80f21d4f8",
        "diff_stats": {
            "additions": 6,
            "deletions": 1
        },
        "diff_content": "@@ -122,7 +122,7 @@ final class Util {\n       case '\\r': return \"\\\\r\"; /* \\u000d: carriage return (CR) */\n       case '\\\"': return \"\\\"\";  /* \\u0022: double quote (\") */\n       case '\\'': return \"\\\\'\"; /* \\u0027: single quote (') */\n-      case '\\\\': return \"\\\\\";  /* \\u005c: backslash (\\) */\n+      case '\\\\': return \"\\\\\\\\\";  /* \\u005c: backslash (\\) */\n       default:\n         return isISOControl(c) ? String.format(\"\\\\u%04x\", (int) c) : Character.toString(c);\n     }\n@@ -139,6 +139,11 @@ final class Util {\n         result.append(\"'\");\n         continue;\n       }\n+      // trivial case: double quotes must be escaped\n+      if (c == '\\\"') {\n+        result.append(\"\\\\\\\"\");\n+        continue;\n+      }\n       // default case: just let character literal do its work\n       result.append(characterLiteralWithoutSingleQuotes(c));\n       // need to append indent after linefeed?\n"
    },
    {
        "commit_hash": "a8b274e2f0ba92581a16da58c8bfdf79ae5474e2",
        "previous_commit_hash": "4fd756960d5e16051e3e3506e8614ab80f21d4f8",
        "diff_stats": {
            "additions": 3,
            "deletions": 1
        },
        "diff_content": "@@ -33,7 +33,7 @@ public class UtilTest {\n     assertEquals(\"\\\\r\", Util.characterLiteralWithoutSingleQuotes('\\r'));\n     assertEquals(\"\\\"\", Util.characterLiteralWithoutSingleQuotes('\"'));\n     assertEquals(\"\\\\'\", Util.characterLiteralWithoutSingleQuotes('\\''));\n-    assertEquals(\"\\\\\", Util.characterLiteralWithoutSingleQuotes('\\\\'));\n+    assertEquals(\"\\\\\\\\\", Util.characterLiteralWithoutSingleQuotes('\\\\'));\n     // octal escapes\n     assertEquals(\"\\\\u0000\", Util.characterLiteralWithoutSingleQuotes('\\0'));\n     assertEquals(\"\\\\u0007\", Util.characterLiteralWithoutSingleQuotes('\\7'));\n@@ -61,6 +61,8 @@ public class UtilTest {\n     stringLiteral(\"\u2666\u2665\u2660\u2663\");\n     stringLiteral(\"\u20ac\\\\t@\\\\t$\", \"\u20ac\\t@\\t$\", \" \");\n     stringLiteral(\"abc();\\\\n\\\"\\n  + \\\"def();\", \"abc();\\ndef();\", \" \");\n+    stringLiteral(\"This is \\\\\\\"quoted\\\\\\\"!\", \"This is \\\"quoted\\\"!\", \" \");\n+    stringLiteral(\"e^{i\\\\\\\\pi}+1=0\", \"e^{i\\\\pi}+1=0\", \" \");\n   }\n \n   void stringLiteral(String string) {\n"
    },
    {
        "commit_hash": "30455b1a25b3ff348578d882812e4e7c94eb9e9e",
        "previous_commit_hash": "4de4f0ee58df9ad4d7560792a38018787eedcef9",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.7.0-SNAPSHOT</version>\n+  <version>1.6.1</version>\n \n   <name>JavaPoet</name>\n   <description>Use beautiful Java code to generate beautiful Java code.</description>\n@@ -54,13 +54,13 @@\n     <dependency>\n       <groupId>com.google.truth</groupId>\n       <artifactId>truth</artifactId>\n-      <version>1.0-SNAPSHOT</version>\n+      <version>0.25</version>\n       <scope>test</scope>\n     </dependency>\n     <dependency>\n       <groupId>com.google.testing.compile</groupId>\n       <artifactId>compile-testing</artifactId>\n-      <version>1.0-SNAPSHOT</version>\n+      <version>0.6</version>\n       <scope>test</scope>\n     </dependency>\n     <dependency>\n"
    },
    {
        "commit_hash": "dfcf55e5fc3f29ac55847a19627f9f15d3aff370",
        "previous_commit_hash": "30455b1a25b3ff348578d882812e4e7c94eb9e9e",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.6.1</version>\n+  <version>1.7.0-SNAPSHOT</version>\n \n   <name>JavaPoet</name>\n   <description>Use beautiful Java code to generate beautiful Java code.</description>\n@@ -54,13 +54,13 @@\n     <dependency>\n       <groupId>com.google.truth</groupId>\n       <artifactId>truth</artifactId>\n-      <version>0.25</version>\n+      <version>1.0-SNAPSHOT</version>\n       <scope>test</scope>\n     </dependency>\n     <dependency>\n       <groupId>com.google.testing.compile</groupId>\n       <artifactId>compile-testing</artifactId>\n-      <version>0.6</version>\n+      <version>1.0-SNAPSHOT</version>\n       <scope>test</scope>\n     </dependency>\n     <dependency>\n"
    },
    {
        "commit_hash": "9718d39ff8e432d2d196e6de5dfa3d4af785d91a",
        "previous_commit_hash": "dfcf55e5fc3f29ac55847a19627f9f15d3aff370",
        "diff_stats": {
            "additions": 7,
            "deletions": 0
        },
        "diff_content": "@@ -1,6 +1,13 @@\n Change Log\n ==========\n \n+JavaPoet 1.6.1 *(2016-03-21)*\n+----------------------------\n+\n+ * Fix: Double quotes and backslashes in string literals were not properly quoted in 1.6.0. This is\n+   now fixed.\n+\n+\n JavaPoet 1.6.0 *(2016-03-19)*\n ----------------------------\n \n"
    },
    {
        "commit_hash": "9718d39ff8e432d2d196e6de5dfa3d4af785d91a",
        "previous_commit_hash": "dfcf55e5fc3f29ac55847a19627f9f15d3aff370",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -801,12 +801,12 @@ Download [the latest .jar][dl] or depend via Maven:\n <dependency>\n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.6.0</version>\n+  <version>1.6.1</version>\n </dependency>\n ```\n or Gradle:\n ```groovy\n-compile 'com.squareup:javapoet:1.6.0'\n+compile 'com.squareup:javapoet:1.6.1'\n ```\n \n Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].\n"
    },
    {
        "commit_hash": "747b88b228fd2512e487506e4b2f764c26c6653d",
        "previous_commit_hash": "9718d39ff8e432d2d196e6de5dfa3d4af785d91a",
        "diff_stats": {
            "additions": 19,
            "deletions": 0
        },
        "diff_content": "@@ -127,10 +127,29 @@ public class TypeName {\n     return !annotations.isEmpty();\n   }\n \n+  /**\n+   * Returns true if this is a primitive type like {@code int}. Returns false for all other types\n+   * types including boxed primitives and {@code void}.\n+   */\n   public boolean isPrimitive() {\n     return keyword != null && this != VOID;\n   }\n \n+  /**\n+   * Returns true if this is a boxed primitive type like {@code Integer}. Returns false for all\n+   * other types types including unboxed primitives and {@code java.lang.Void}.\n+   */\n+  public boolean isBoxedPrimitive() {\n+    return this.equals(BOXED_BOOLEAN)\n+        || this.equals(BOXED_BYTE)\n+        || this.equals(BOXED_SHORT)\n+        || this.equals(BOXED_INT)\n+        || this.equals(BOXED_LONG)\n+        || this.equals(BOXED_CHAR)\n+        || this.equals(BOXED_FLOAT)\n+        || this.equals(BOXED_DOUBLE);\n+  }\n+\n   /**\n    * Returns a boxed type if this is a primitive type (like {@code Integer} for {@code int}) or\n    * {@code void}. Returns this type if boxing doesn't apply.\n"
    },
    {
        "commit_hash": "747b88b228fd2512e487506e4b2f764c26c6653d",
        "previous_commit_hash": "9718d39ff8e432d2d196e6de5dfa3d4af785d91a",
        "diff_stats": {
            "additions": 20,
            "deletions": 5
        },
        "diff_content": "@@ -15,10 +15,6 @@\n  */\n package com.squareup.javapoet;\n \n-import static com.google.common.truth.Truth.assertThat;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNotEquals;\n-\n import java.io.Serializable;\n import java.lang.reflect.Method;\n import java.util.Comparator;\n@@ -27,6 +23,10 @@ import java.util.Set;\n import java.util.UUID;\n import org.junit.Test;\n \n+import static com.google.common.truth.Truth.assertThat;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotEquals;\n+\n public class TypeNameTest {\n \n   protected <E extends Enum<E>> E generic(E[] values) {\n@@ -93,10 +93,25 @@ public class TypeNameTest {\n         WildcardTypeName.supertypeOf(String.class));\n   }\n \n+  @Test public void isPrimitive() throws Exception {\n+    assertThat(TypeName.INT.isPrimitive()).isTrue();\n+    assertThat(ClassName.get(\"java.lang\", \"Integer\").isPrimitive()).isFalse();\n+    assertThat(ClassName.get(\"java.lang\", \"String\").isPrimitive()).isFalse();\n+    assertThat(TypeName.VOID.isPrimitive()).isFalse();\n+    assertThat(ClassName.get(\"java.lang\", \"Void\").isPrimitive()).isFalse();\n+  }\n+\n+  @Test public void isBoxedPrimitive() throws Exception {\n+    assertThat(TypeName.INT.isBoxedPrimitive()).isFalse();\n+    assertThat(ClassName.get(\"java.lang\", \"Integer\").isBoxedPrimitive()).isTrue();\n+    assertThat(ClassName.get(\"java.lang\", \"String\").isBoxedPrimitive()).isFalse();\n+    assertThat(TypeName.VOID.isBoxedPrimitive()).isFalse();\n+    assertThat(ClassName.get(\"java.lang\", \"Void\").isBoxedPrimitive()).isFalse();\n+  }\n+\n   private void assertEqualsHashCodeAndToString(TypeName a, TypeName b) {\n     assertEquals(a.toString(), b.toString());\n     assertThat(a.equals(b)).isTrue();\n     assertThat(a.hashCode()).isEqualTo(b.hashCode());\n   }\n-\n }\n"
    },
    {
        "commit_hash": "3604f52b262f2525d4fa6de0606227684e6ab065",
        "previous_commit_hash": "495d95889484502834415db54d799a47560c43a6",
        "diff_stats": {
            "additions": 4,
            "deletions": 4
        },
        "diff_content": "@@ -22,8 +22,8 @@\n \n     <java.version>1.7</java.version>\n     <junit.version>4.12</junit.version>\n-    <truth.version>0.25</truth.version>\n-    <compile-testing.version>0.6</compile-testing.version>\n+    <truth.version>0.28</truth.version>\n+    <compile-testing.version>0.9</compile-testing.version>\n   </properties>\n \n   <scm>\n@@ -54,13 +54,13 @@\n     <dependency>\n       <groupId>com.google.truth</groupId>\n       <artifactId>truth</artifactId>\n-      <version>1.0-SNAPSHOT</version>\n+      <version>${truth.version}</version>\n       <scope>test</scope>\n     </dependency>\n     <dependency>\n       <groupId>com.google.testing.compile</groupId>\n       <artifactId>compile-testing</artifactId>\n-      <version>1.0-SNAPSHOT</version>\n+      <version>${compile-testing.version}</version>\n       <scope>test</scope>\n     </dependency>\n     <dependency>\n"
    },
    {
        "commit_hash": "cdc51fd2c5f5610c7377c5dd3e4013fba86b22d8",
        "previous_commit_hash": "373ac2ddb11def68874b1310978d32a0f6e6d01c",
        "diff_stats": {
            "additions": 4,
            "deletions": 0
        },
        "diff_content": "@@ -202,6 +202,10 @@ final class CodeWriter {\n     emit(\">\");\n   }\n \n+  public CodeWriter emit(String s) throws IOException {\n+    return emitAndIndent(s);\n+  }\n+\n   public CodeWriter emit(String format, Object... args) throws IOException {\n     return emit(CodeBlock.of(format, args));\n   }\n"
    },
    {
        "commit_hash": "2e6138631d6e808ace393f93149a4dc0af6668b3",
        "previous_commit_hash": "cdc51fd2c5f5610c7377c5dd3e4013fba86b22d8",
        "diff_stats": {
            "additions": 16,
            "deletions": 8
        },
        "diff_content": "@@ -90,6 +90,9 @@ public class TypeName {\n   private final String keyword;\n   public final List<AnnotationSpec> annotations;\n \n+  /** Lazily-initialized toString of this type name. */\n+  private String cachedString;\n+\n   private TypeName(String keyword) {\n     this(keyword, new ArrayList<AnnotationSpec>());\n   }\n@@ -200,15 +203,20 @@ public class TypeName {\n   }\n \n   @Override public final String toString() {\n-    try {\n-      StringBuilder result = new StringBuilder();\n-      CodeWriter codeWriter = new CodeWriter(result);\n-      emitAnnotations(codeWriter);\n-      emit(codeWriter);\n-      return result.toString();\n-    } catch (IOException e) {\n-      throw new AssertionError();\n+    String result = cachedString;\n+    if (result == null) {\n+      try {\n+        StringBuilder resultBuilder = new StringBuilder();\n+        CodeWriter codeWriter = new CodeWriter(resultBuilder);\n+        emitAnnotations(codeWriter);\n+        emit(codeWriter);\n+        result = resultBuilder.toString();\n+        cachedString = result;\n+      } catch (IOException e) {\n+        throw new AssertionError();\n+      }\n     }\n+    return result;\n   }\n \n   CodeWriter emit(CodeWriter out) throws IOException {\n"
    },
    {
        "commit_hash": "186ccd85c9e448195b9a2a88bf272041dd5f41bb",
        "previous_commit_hash": "b8d1957417d5f313b7ad29c0d6df10bdc2a58fb8",
        "diff_stats": {
            "additions": 63,
            "deletions": 21
        },
        "diff_content": "@@ -16,6 +16,7 @@\n package com.squareup.javapoet;\n \n import java.io.IOException;\n+import java.lang.reflect.Modifier;\n import java.lang.reflect.ParameterizedType;\n import java.lang.reflect.Type;\n import java.util.ArrayList;\n@@ -28,20 +29,24 @@ import static com.squareup.javapoet.Util.checkArgument;\n import static com.squareup.javapoet.Util.checkNotNull;\n \n public final class ParameterizedTypeName extends TypeName {\n+  private final ParameterizedTypeName enclosingType;\n   public final ClassName rawType;\n   public final List<TypeName> typeArguments;\n \n-  ParameterizedTypeName(ClassName rawType, List<TypeName> typeArguments) {\n-    this(rawType, typeArguments, new ArrayList<AnnotationSpec>());\n+  ParameterizedTypeName(ParameterizedTypeName enclosingType, ClassName rawType,\n+      List<TypeName> typeArguments) {\n+    this(enclosingType, rawType, typeArguments, new ArrayList<AnnotationSpec>());\n   }\n \n-  ParameterizedTypeName(ClassName rawType, List<TypeName> typeArguments,\n-      List<AnnotationSpec> annotations) {\n+  private ParameterizedTypeName(ParameterizedTypeName enclosingType, ClassName rawType,\n+      List<TypeName> typeArguments, List<AnnotationSpec> annotations) {\n     super(annotations);\n     this.rawType = checkNotNull(rawType, \"rawType == null\");\n+    this.enclosingType = enclosingType;\n     this.typeArguments = Util.immutableList(typeArguments);\n \n-    checkArgument(!this.typeArguments.isEmpty(), \"no type arguments: %s\", rawType);\n+    checkArgument(!this.typeArguments.isEmpty() || enclosingType != null,\n+        \"no type arguments: %s\", rawType);\n     for (TypeName typeArgument : this.typeArguments) {\n       checkArgument(!typeArgument.isPrimitive() && typeArgument != VOID,\n           \"invalid type parameter: %s\", typeArgument);\n@@ -49,35 +54,66 @@ public final class ParameterizedTypeName extends TypeName {\n   }\n \n   @Override public ParameterizedTypeName annotated(List<AnnotationSpec> annotations) {\n-    return new ParameterizedTypeName(rawType, typeArguments, concatAnnotations(annotations));\n+    return new ParameterizedTypeName(\n+        enclosingType, rawType, typeArguments, concatAnnotations(annotations));\n   }\n \n   @Override public TypeName withoutAnnotations() {\n-    return new ParameterizedTypeName(rawType, typeArguments);\n+    return new ParameterizedTypeName(\n+        enclosingType, rawType, typeArguments, new ArrayList<AnnotationSpec>());\n   }\n \n   @Override CodeWriter emit(CodeWriter out) throws IOException {\n-    rawType.emitAnnotations(out);\n-    rawType.emit(out);\n-    out.emitAndIndent(\"<\");\n-    boolean firstParameter = true;\n-    for (TypeName parameter : typeArguments) {\n-      if (!firstParameter) out.emitAndIndent(\", \");\n-      parameter.emitAnnotations(out);\n-      parameter.emit(out);\n-      firstParameter = false;\n+    if (enclosingType != null) {\n+      enclosingType.emitAnnotations(out);\n+      enclosingType.emit(out);\n+      out.emit(\".\" + rawType.simpleName());\n+    } else {\n+      rawType.emitAnnotations(out);\n+      rawType.emit(out);\n     }\n-    return out.emitAndIndent(\">\");\n+    if (!typeArguments.isEmpty()) {\n+      out.emitAndIndent(\"<\");\n+      boolean firstParameter = true;\n+      for (TypeName parameter : typeArguments) {\n+        if (!firstParameter) out.emitAndIndent(\", \");\n+        parameter.emitAnnotations(out);\n+        parameter.emit(out);\n+        firstParameter = false;\n+      }\n+      out.emitAndIndent(\">\");\n+    }\n+    return out;\n+  }\n+\n+  /**\n+   * Returns a new {@link ParameterizedTypeName} instance for the specified {@code name} as nested\n+   * inside this class.\n+   */\n+  public ParameterizedTypeName nestedClass(String name) {\n+    checkNotNull(name, \"name == null\");\n+    return new ParameterizedTypeName(this, rawType.nestedClass(name), new ArrayList<TypeName>(),\n+        new ArrayList<AnnotationSpec>());\n+  }\n+\n+  /**\n+   * Returns a new {@link ParameterizedTypeName} instance for the specified {@code name} as nested\n+   * inside this class, with the specified {@code typeArguments}.\n+   */\n+  public ParameterizedTypeName nestedClass(String name, List<TypeName> typeArguments) {\n+    checkNotNull(name, \"name == null\");\n+    return new ParameterizedTypeName(this, rawType.nestedClass(name), typeArguments,\n+        new ArrayList<AnnotationSpec>());\n   }\n \n   /** Returns a parameterized type, applying {@code typeArguments} to {@code rawType}. */\n   public static ParameterizedTypeName get(ClassName rawType, TypeName... typeArguments) {\n-    return new ParameterizedTypeName(rawType, Arrays.asList(typeArguments));\n+    return new ParameterizedTypeName(null, rawType, Arrays.asList(typeArguments));\n   }\n \n   /** Returns a parameterized type, applying {@code typeArguments} to {@code rawType}. */\n   public static ParameterizedTypeName get(Class<?> rawType, Type... typeArguments) {\n-    return new ParameterizedTypeName(ClassName.get(rawType), list(typeArguments));\n+    return new ParameterizedTypeName(null, ClassName.get(rawType), list(typeArguments));\n   }\n \n   /** Returns a parameterized type equivalent to {@code type}. */\n@@ -87,7 +123,13 @@ public final class ParameterizedTypeName extends TypeName {\n \n   /** Returns a parameterized type equivalent to {@code type}. */\n   static ParameterizedTypeName get(ParameterizedType type, Map<Type, TypeVariableName> map) {\n-    return new ParameterizedTypeName(ClassName.get((Class<?>) type.getRawType()),\n-        TypeName.list(type.getActualTypeArguments(), map));\n+    ClassName rawType = ClassName.get((Class<?>) type.getRawType());\n+    ParameterizedType ownerType = (type.getOwnerType() instanceof ParameterizedType)\n+        && !Modifier.isStatic(((Class<?>) type.getRawType()).getModifiers())\n+        ? (ParameterizedType) type.getOwnerType() : null;\n+    List<TypeName> typeArguments = TypeName.list(type.getActualTypeArguments(), map);\n+    return (ownerType != null)\n+        ? get(ownerType, map).nestedClass(rawType.simpleName(), typeArguments)\n+        : new ParameterizedTypeName(null, rawType, typeArguments);\n   }\n }\n"
    },
    {
        "commit_hash": "186ccd85c9e448195b9a2a88bf272041dd5f41bb",
        "previous_commit_hash": "b8d1957417d5f313b7ad29c0d6df10bdc2a58fb8",
        "diff_stats": {
            "additions": 14,
            "deletions": 2
        },
        "diff_content": "@@ -26,6 +26,7 @@ import java.util.Arrays;\n import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n+import javax.lang.model.element.Modifier;\n import javax.lang.model.element.TypeElement;\n import javax.lang.model.element.TypeParameterElement;\n import javax.lang.model.type.ArrayType;\n@@ -265,13 +266,24 @@ public class TypeName {\n \n       @Override public TypeName visitDeclared(DeclaredType t, Void p) {\n         ClassName rawType = ClassName.get((TypeElement) t.asElement());\n-        if (t.getTypeArguments().isEmpty()) return rawType;\n+        TypeMirror enclosingType = t.getEnclosingType();\n+        TypeName enclosing =\n+            (enclosingType.getKind() != TypeKind.NONE)\n+                    && !t.asElement().getModifiers().contains(Modifier.STATIC)\n+                ? enclosingType.accept(this, null)\n+                : null;\n+        if (t.getTypeArguments().isEmpty() && !(enclosing instanceof ParameterizedTypeName)) {\n+          return rawType;\n+        }\n \n         List<TypeName> typeArgumentNames = new ArrayList<>();\n         for (TypeMirror mirror : t.getTypeArguments()) {\n           typeArgumentNames.add(get(mirror, typeVariables));\n         }\n-        return new ParameterizedTypeName(rawType, typeArgumentNames);\n+        return enclosing instanceof ParameterizedTypeName\n+            ? ((ParameterizedTypeName) enclosing).nestedClass(\n+            rawType.simpleName(), typeArgumentNames)\n+            : new ParameterizedTypeName(null, rawType, typeArgumentNames);\n       }\n \n       @Override public TypeName visitError(ErrorType t, Void p) {\n"
    },
    {
        "commit_hash": "186ccd85c9e448195b9a2a88bf272041dd5f41bb",
        "previous_commit_hash": "b8d1957417d5f313b7ad29c0d6df10bdc2a58fb8",
        "diff_stats": {
            "additions": 66,
            "deletions": 1
        },
        "diff_content": "@@ -33,12 +33,77 @@ public class TypeNameTest {\n     return values[0];\n   }\n \n+  protected static class TestGeneric<T> {\n+    class Inner {}\n+\n+    class InnerGeneric<T2> {}\n+\n+    static class NestedNonGeneric {}\n+  }\n+\n+  protected static TestGeneric<String>.Inner testGenericStringInner() {\n+    return null;\n+  }\n+\n+  protected static TestGeneric<Integer>.Inner testGenericIntInner() {\n+    return null;\n+  }\n+\n+  protected static TestGeneric<Short>.InnerGeneric<Long> testGenericInnerLong() {\n+    return null;\n+  }\n+\n+  protected static TestGeneric<Short>.InnerGeneric<Integer> testGenericInnerInt() {\n+    return null;\n+  }\n+\n+  protected static TestGeneric.NestedNonGeneric testNestedNonGeneric() {\n+    return null;\n+  }\n+\n   @Test public void genericType() throws Exception {\n     Method recursiveEnum = getClass().getDeclaredMethod(\"generic\", Enum[].class);\n     TypeName.get(recursiveEnum.getReturnType());\n     TypeName.get(recursiveEnum.getGenericReturnType());\n-    TypeName.get(recursiveEnum.getParameterTypes()[0]);\n+    TypeName genericTypeName = TypeName.get(recursiveEnum.getParameterTypes()[0]);\n     TypeName.get(recursiveEnum.getGenericParameterTypes()[0]);\n+\n+    // Make sure the generic argument is present\n+    assertThat(genericTypeName.toString()).contains(\"Enum\");\n+  }\n+\n+  @Test public void innerClassInGenericType() throws Exception {\n+    Method genericStringInner = getClass().getDeclaredMethod(\"testGenericStringInner\");\n+    TypeName.get(genericStringInner.getReturnType());\n+    TypeName genericTypeName = TypeName.get(genericStringInner.getGenericReturnType());\n+    assertNotEquals(TypeName.get(genericStringInner.getGenericReturnType()),\n+        TypeName.get(getClass().getDeclaredMethod(\"testGenericIntInner\").getGenericReturnType()));\n+\n+    // Make sure the generic argument is present\n+    assertThat(genericTypeName.toString()).isEqualTo(\n+        TestGeneric.class.getCanonicalName() + \"<java.lang.String>.Inner\");\n+  }\n+\n+  @Test public void innerGenericInGenericType() throws Exception {\n+    Method genericStringInner = getClass().getDeclaredMethod(\"testGenericInnerLong\");\n+    TypeName.get(genericStringInner.getReturnType());\n+    TypeName genericTypeName = TypeName.get(genericStringInner.getGenericReturnType());\n+    assertNotEquals(TypeName.get(genericStringInner.getGenericReturnType()),\n+        TypeName.get(getClass().getDeclaredMethod(\"testGenericInnerInt\").getGenericReturnType()));\n+\n+    // Make sure the generic argument is present\n+    assertThat(genericTypeName.toString()).isEqualTo(\n+        TestGeneric.class.getCanonicalName() + \"<java.lang.Short>.InnerGeneric<java.lang.Long>\");\n+  }\n+\n+  @Test public void innerStaticInGenericType() throws Exception {\n+    Method staticInGeneric = getClass().getDeclaredMethod(\"testNestedNonGeneric\");\n+    TypeName.get(staticInGeneric.getReturnType());\n+    TypeName typeName = TypeName.get(staticInGeneric.getGenericReturnType());\n+\n+    // Make sure there are no generic arguments\n+    assertThat(typeName.toString()).isEqualTo(\n+        TestGeneric.class.getCanonicalName() + \".NestedNonGeneric\");\n   }\n \n   @Test public void equalsAndHashCodePrimitive() {\n"
    },
    {
        "commit_hash": "e2313a409ee1a8e44961ba8db885459a04371e5b",
        "previous_commit_hash": "a4bb248c59a362f07b324668c65bdcab6df785db",
        "diff_stats": {
            "additions": 7,
            "deletions": 0
        },
        "diff_content": "@@ -1,6 +1,13 @@\n Change Log\n ==========\n \n+JavaPoet 1.7.0 *(2016-04-26)*\n+----------------------------\n+\n+ * New: Support parameterized types that enclose other types, like `Outer<String>.Inner`.\n+ * New: `TypeName.isBoxedPrimitive()`.\n+\n+\n JavaPoet 1.6.1 *(2016-03-21)*\n ----------------------------\n \n"
    },
    {
        "commit_hash": "e2313a409ee1a8e44961ba8db885459a04371e5b",
        "previous_commit_hash": "a4bb248c59a362f07b324668c65bdcab6df785db",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -801,12 +801,12 @@ Download [the latest .jar][dl] or depend via Maven:\n <dependency>\n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.6.1</version>\n+  <version>1.7.0</version>\n </dependency>\n ```\n or Gradle:\n ```groovy\n-compile 'com.squareup:javapoet:1.6.1'\n+compile 'com.squareup:javapoet:1.7.0'\n ```\n \n Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].\n"
    },
    {
        "commit_hash": "79d83b201dea2fcd9eeee414d963b55136727aa6",
        "previous_commit_hash": "e2313a409ee1a8e44961ba8db885459a04371e5b",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.7.0-SNAPSHOT</version>\n+  <version>1.7.0</version>\n \n   <name>JavaPoet</name>\n   <description>Use beautiful Java code to generate beautiful Java code.</description>\n"
    },
    {
        "commit_hash": "0e00d87cecf635c40015d1698a0b5adb7da5ea15",
        "previous_commit_hash": "79d83b201dea2fcd9eeee414d963b55136727aa6",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.7.0</version>\n+  <version>1.8.0-SNAPSHOT</version>\n \n   <name>JavaPoet</name>\n   <description>Use beautiful Java code to generate beautiful Java code.</description>\n"
    },
    {
        "commit_hash": "8613629df7ebf9fc485965015d9beffaecb6103d",
        "previous_commit_hash": "0e00d87cecf635c40015d1698a0b5adb7da5ea15",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -65,7 +65,7 @@ public final class TypeVariableName extends TypeName {\n     return withBounds(Arrays.asList(bounds));\n   }\n \n-  public TypeVariableName withBounds(List<TypeName> bounds) {\n+  public TypeVariableName withBounds(List<? extends TypeName> bounds) {\n     ArrayList<TypeName> newBounds = new ArrayList<>();\n     newBounds.addAll(this.bounds);\n     newBounds.addAll(bounds);\n"
    },
    {
        "commit_hash": "05f74da539738429708dabf7291923243fcbd1cd",
        "previous_commit_hash": "93a496c900678768479bda5d19cc70f666d88c5c",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -318,7 +318,7 @@ MethodSpec beyond = MethodSpec.methodBuilder(\"beyond\")\n     .addStatement(\"$T result = new $T<>()\", listOfHoverboards, arrayList)\n     .addStatement(\"result.add($T.createNimbus(2000))\", hoverboard)\n     .addStatement(\"result.add($T.createNimbus(\\\"2001\\\"))\", hoverboard)\n-    .addStatement(\"result.add($T.createNimbus($T.THUNDERBOLT))\", namedBoards)\n+    .addStatement(\"result.add($T.createNimbus($T.THUNDERBOLT))\", hoverboard, namedBoards)\n     .addStatement(\"$T.sort(result)\", Collections.class)\n     .addStatement(\"return result.isEmpty() $T.emptyList() : result\", Collections.class)\n     .build();\n"
    },
    {
        "commit_hash": "1efac98929856ec9e47748fd67bfce2fde704e37",
        "previous_commit_hash": "d06b2fe79ea1f62bae6e12c3ecaef25b3cbd1bd4",
        "diff_stats": {
            "additions": 1,
            "deletions": 2
        },
        "diff_content": "@@ -484,8 +484,7 @@ public final class TypeSpec {\n     }\n \n     public Builder addField(FieldSpec fieldSpec) {\n-      checkState(kind != Kind.ANNOTATION, \"%s %s cannot have fields\", kind, name);\n-      if (kind == Kind.INTERFACE) {\n+      if (kind == Kind.INTERFACE || kind == Kind.ANNOTATION) {\n         requireExactlyOneOf(fieldSpec.modifiers, Modifier.PUBLIC, Modifier.PRIVATE);\n         Set<Modifier> check = EnumSet.of(Modifier.STATIC, Modifier.FINAL);\n         checkState(fieldSpec.modifiers.containsAll(check), \"%s %s.%s requires modifiers %s\",\n"
    },
    {
        "commit_hash": "1efac98929856ec9e47748fd67bfce2fde704e37",
        "previous_commit_hash": "d06b2fe79ea1f62bae6e12c3ecaef25b3cbd1bd4",
        "diff_stats": {
            "additions": 19,
            "deletions": 0
        },
        "diff_content": "@@ -770,6 +770,25 @@ public final class TypeSpecTest {\n     );\n   }\n \n+  @Test public void annotationWithFields() {\n+    FieldSpec field = FieldSpec.builder(int.class, \"FOO\")\n+            .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)\n+            .initializer(\"$L\", 101)\n+            .build();\n+\n+    TypeSpec anno = TypeSpec.annotationBuilder(\"Anno\")\n+            .addField(field)\n+            .build();\n+\n+    assertThat(toString(anno)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"@interface Anno {\\n\"\n+        + \"  int FOO = 101;\\n\"\n+        + \"}\\n\"\n+    );\n+  }\n+\n   @Test\n   public void classCannotHaveDefaultValueForMethod() throws Exception {\n     try {\n"
    },
    {
        "commit_hash": "a136eaa777b7750e16b3c6e8bd6d0228442e3e1d",
        "previous_commit_hash": "3d54bd91f17fcb212010470f158c5e79c8e79d26",
        "diff_stats": {
            "additions": 4,
            "deletions": 2
        },
        "diff_content": "@@ -149,6 +149,7 @@ public final class TypeSpec {\n     codeWriter.statementLine = -1;\n \n     try {\n+      codeWriter.pushType(this);\n       if (enumName != null) {\n         codeWriter.emitJavadoc(javadoc);\n         codeWriter.emitAnnotations(annotations, false);\n@@ -213,7 +214,7 @@ public final class TypeSpec {\n         codeWriter.emit(\" {\\n\");\n       }\n \n-      codeWriter.pushType(this);\n+      //codeWriter.pushType(this);\n       codeWriter.indent();\n       boolean firstMember = true;\n       for (Iterator<Map.Entry<String, TypeSpec>> i = enumConstants.entrySet().iterator();\n@@ -285,13 +286,14 @@ public final class TypeSpec {\n       }\n \n       codeWriter.unindent();\n-      codeWriter.popType();\n+      //codeWriter.popType();\n \n       codeWriter.emit(\"}\");\n       if (enumName == null && anonymousTypeArguments == null) {\n         codeWriter.emit(\"\\n\"); // If this type isn't also a value, include a trailing newline.\n       }\n     } finally {\n+      codeWriter.popType();\n       codeWriter.statementLine = previousStatementLine;\n     }\n   }\n"
    },
    {
        "commit_hash": "a136eaa777b7750e16b3c6e8bd6d0228442e3e1d",
        "previous_commit_hash": "3d54bd91f17fcb212010470f158c5e79c8e79d26",
        "diff_stats": {
            "additions": 19,
            "deletions": 0
        },
        "diff_content": "@@ -622,6 +622,25 @@ public final class TypeSpecTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void classImplementsExtendsSameName() throws Exception {\n+    ClassName javapoetTaco = ClassName.get(tacosPackage, \"Taco\");\n+    ClassName tacoBellTaco = ClassName.get(\"com.taco.bell\", \"Taco\");\n+    ClassName fishTaco = ClassName.get(\"org.fish.taco\", \"Taco\");\n+    TypeSpec typeSpec = TypeSpec.classBuilder(\"Taco\")\n+            .superclass(fishTaco)\n+            .addSuperinterface(ParameterizedTypeName.get(ClassName.get(Comparable.class), javapoetTaco))\n+            .addSuperinterface(tacoBellTaco)\n+            .build();\n+    assertThat(toString(typeSpec)).isEqualTo(\"\"\n+            + \"package com.squareup.tacos;\\n\"\n+            + \"\\n\"\n+            + \"import java.lang.Comparable;\\n\"\n+            + \"\\n\"\n+            + \"class Taco extends org.fish.taco.Taco \"\n+            + \"implements Comparable<Taco>, com.taco.bell.Taco {\\n\"\n+            + \"}\\n\");\n+  }\n+\n   @Test public void enumImplements() throws Exception {\n     TypeSpec typeSpec = TypeSpec.enumBuilder(\"Food\")\n         .addSuperinterface(Serializable.class)\n"
    },
    {
        "commit_hash": "338abf76a0e6e82fc9bcff73c8a629d62752ce2b",
        "previous_commit_hash": "a136eaa777b7750e16b3c6e8bd6d0228442e3e1d",
        "diff_stats": {
            "additions": 0,
            "deletions": 2
        },
        "diff_content": "@@ -214,7 +214,6 @@ public final class TypeSpec {\n         codeWriter.emit(\" {\\n\");\n       }\n \n-      //codeWriter.pushType(this);\n       codeWriter.indent();\n       boolean firstMember = true;\n       for (Iterator<Map.Entry<String, TypeSpec>> i = enumConstants.entrySet().iterator();\n@@ -286,7 +285,6 @@ public final class TypeSpec {\n       }\n \n       codeWriter.unindent();\n-      //codeWriter.popType();\n \n       codeWriter.emit(\"}\");\n       if (enumName == null && anonymousTypeArguments == null) {\n"
    },
    {
        "commit_hash": "19e1b4e3f253a3169853863199c932f36c5b6584",
        "previous_commit_hash": "3d54bd91f17fcb212010470f158c5e79c8e79d26",
        "diff_stats": {
            "additions": 5,
            "deletions": 0
        },
        "diff_content": "@@ -419,6 +419,11 @@ public final class MethodSpec {\n       return this;\n     }\n \n+    public Builder addComment(String format, Object... args) {\n+      code.add(\"// \" + format + \"\\n\", args);\n+      return this;\n+    }\n+\n     public Builder defaultValue(String format, Object... args) {\n       return defaultValue(CodeBlock.of(format, args));\n     }\n"
    },
    {
        "commit_hash": "fdaefdb063880bd83774999b99b3ac910f6ead28",
        "previous_commit_hash": "932695e9f03df31c7ec95c200c5a3d8fd7a0bc28",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -207,6 +207,7 @@ public final class MethodSpec {\n \n     modifiers = new LinkedHashSet<>(modifiers);\n     modifiers.remove(Modifier.ABSTRACT);\n+    modifiers.remove(Util.DEFAULT); // LinkedHashSet permits null as element for Java 7\n     methodBuilder.addModifiers(modifiers);\n \n     for (TypeParameterElement typeParameterElement : method.getTypeParameters()) {\n"
    },
    {
        "commit_hash": "fdaefdb063880bd83774999b99b3ac910f6ead28",
        "previous_commit_hash": "932695e9f03df31c7ec95c200c5a3d8fd7a0bc28",
        "diff_stats": {
            "additions": 18,
            "deletions": 0
        },
        "diff_content": "@@ -39,6 +39,7 @@ import org.junit.Test;\n \n import static com.google.common.collect.Iterables.getOnlyElement;\n import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.TruthJUnit.assume;\n import static javax.lang.model.util.ElementFilter.methodsIn;\n import static org.junit.Assert.fail;\n import static org.mockito.Mockito.mock;\n@@ -119,6 +120,9 @@ public final class MethodSpecTest {\n \n   interface ExtendsOthers extends Callable<Integer>, Comparable<Long> {\n   }\n+  \n+  interface ExtendsIterableWithDefaultMethods extends Iterable<Object> {\n+  }\n \n   @Test public void overrideEverything() {\n     TypeElement classElement = getElement(Everything.class);\n@@ -145,6 +149,20 @@ public final class MethodSpecTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void overrideDoesNotCopyDefaultModifier() {\n+    TypeElement classElement = getElement(ExtendsIterableWithDefaultMethods.class);\n+    DeclaredType classType = (DeclaredType) classElement.asType();\n+    List<ExecutableElement> methods = methodsIn(elements.getAllMembers(classElement));\n+    ExecutableElement exec = findFirst(methods, \"iterator\");\n+    assume().that(Util.DEFAULT).isNotNull();\n+    exec = findFirst(methods, \"spliterator\");\n+    MethodSpec method = MethodSpec.overriding(exec, classType, types).build();\n+    assertThat(method.toString()).isEqualTo(\"\"\n+        + \"@java.lang.Override\\n\"\n+        + \"public java.util.Spliterator<java.lang.Object> spliterator() {\\n\"\n+        + \"}\\n\");\n+  }\n+\n   @Test public void overrideExtendsOthersWorksWithActualTypeParameters() {\n     TypeElement classElement = getElement(ExtendsOthers.class);\n     DeclaredType classType = (DeclaredType) classElement.asType();\n"
    },
    {
        "commit_hash": "73c6bd309e903ba1eb6501b8dc3a59cc76618984",
        "previous_commit_hash": "7bbcb1fc454285daec6dddef20505ff84f924550",
        "diff_stats": {
            "additions": 18,
            "deletions": 0
        },
        "diff_content": "@@ -84,6 +84,24 @@ public final class ClassName extends TypeName implements Comparable<ClassName> {\n     return new ClassName(names.subList(0, 2));\n   }\n \n+  public String reflectionName() {\n+    // trivial case: no nested names\n+    if (names.size() == 2) {\n+      String packageName = packageName();\n+      if (packageName.isEmpty()) {\n+        return names.get(1);\n+      }\n+      return packageName + \".\" + names.get(1);\n+    }\n+    // concat top level class name and nested names\n+    StringBuilder builder = new StringBuilder();\n+    builder.append(topLevelClassName());\n+    for (String name : simpleNames().subList(1, simpleNames().size())) {\n+      builder.append('$').append(name);\n+    }\n+    return builder.toString();\n+  }\n+\n   /**\n    * Returns a new {@link ClassName} instance for the specified {@code name} as nested inside this\n    * class.\n"
    },
    {
        "commit_hash": "73c6bd309e903ba1eb6501b8dc3a59cc76618984",
        "previous_commit_hash": "7bbcb1fc454285daec6dddef20505ff84f924550",
        "diff_stats": {
            "additions": 10,
            "deletions": 0
        },
        "diff_content": "@@ -135,4 +135,14 @@ public final class ClassNameTest {\n     } catch (IllegalArgumentException ignored) {\n     }\n   }\n+\n+  @Test\n+  public void reflectionName() {\n+    assertEquals(\"java.lang.Object\", TypeName.OBJECT.reflectionName());\n+    assertEquals(\"java.lang.Thread$State\", ClassName.get(Thread.State.class).reflectionName());\n+    assertEquals(\"java.util.Map$Entry\", ClassName.get(Map.Entry.class).reflectionName());\n+    assertEquals(\"Foo\", ClassName.get(\"\", \"Foo\").reflectionName());\n+    assertEquals(\"Foo$Bar$Baz\", ClassName.get(\"\", \"Foo\", \"Bar\", \"Baz\").reflectionName());\n+    assertEquals(\"a.b.c.Foo$Bar$Baz\", ClassName.get(\"a.b.c\", \"Foo\", \"Bar\", \"Baz\").reflectionName());\n+  }\n }\n"
    },
    {
        "commit_hash": "9505ad0e027a1f125b5352ac722ea141831fbf1c",
        "previous_commit_hash": "a6c9a7dd9433138c81ea40cb8f06009f0486d614",
        "diff_stats": {
            "additions": 7,
            "deletions": 11
        },
        "diff_content": "@@ -25,7 +25,6 @@ import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Set;\n import javax.lang.model.SourceVersion;\n-import javax.lang.model.element.AnnotationMirror;\n import javax.lang.model.element.ExecutableElement;\n import javax.lang.model.element.Modifier;\n import javax.lang.model.element.TypeParameterElement;\n@@ -43,7 +42,6 @@ import static com.squareup.javapoet.Util.checkState;\n /** A generated constructor or method declaration. */\n public final class MethodSpec {\n   static final String CONSTRUCTOR = \"<init>\";\n-  static final ClassName OVERRIDE = ClassName.get(Override.class);\n \n   public final String name;\n   public final CodeBlock javadoc;\n@@ -184,6 +182,9 @@ public final class MethodSpec {\n    *\n    * <p>This will copy its visibility modifiers, type parameters, return type, name, parameters, and\n    * throws declarations. An {@link Override} annotation will be added.\n+   *\n+   * <p>Note that in JavaPoet 1.2 through 1.7 this method retained annotations from the method and\n+   * parameters of the overridden method. Since JavaPoet 1.8 annotations must be added separately.\n    */\n   public static Builder overriding(ExecutableElement method) {\n     checkNotNull(method, \"method == null\");\n@@ -198,12 +199,7 @@ public final class MethodSpec {\n     String methodName = method.getSimpleName().toString();\n     MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder(methodName);\n \n-    methodBuilder.addAnnotation(OVERRIDE);\n-    for (AnnotationMirror mirror : method.getAnnotationMirrors()) {\n-      AnnotationSpec annotationSpec = AnnotationSpec.get(mirror);\n-      if (annotationSpec.type.equals(OVERRIDE)) continue;\n-      methodBuilder.addAnnotation(annotationSpec);\n-    }\n+    methodBuilder.addAnnotation(Override.class);\n \n     modifiers = new LinkedHashSet<>(modifiers);\n     modifiers.remove(Modifier.ABSTRACT);\n@@ -224,9 +220,6 @@ public final class MethodSpec {\n       Set<Modifier> parameterModifiers = parameter.getModifiers();\n       ParameterSpec.Builder parameterBuilder = ParameterSpec.builder(type, name)\n           .addModifiers(parameterModifiers.toArray(new Modifier[parameterModifiers.size()]));\n-      for (AnnotationMirror mirror : parameter.getAnnotationMirrors()) {\n-        parameterBuilder.addAnnotation(AnnotationSpec.get(mirror));\n-      }\n       methodBuilder.addParameter(parameterBuilder.build());\n     }\n     methodBuilder.varargs(method.isVarArgs());\n@@ -246,6 +239,9 @@ public final class MethodSpec {\n    *\n    * <p>This will copy its visibility modifiers, type parameters, return type, name, parameters, and\n    * throws declarations. An {@link Override} annotation will be added.\n+   *\n+   * <p>Note that in JavaPoet 1.2 through 1.7 this method retained annotations from the method and\n+   * parameters of the overridden method. Since JavaPoet 1.8 annotations must be added separately.\n    */\n   public static Builder overriding(\n       ExecutableElement method, DeclaredType enclosing, Types types) {\n"
    },
    {
        "commit_hash": "9505ad0e027a1f125b5352ac722ea141831fbf1c",
        "previous_commit_hash": "a6c9a7dd9433138c81ea40cb8f06009f0486d614",
        "diff_stats": {
            "additions": 1,
            "deletions": 2
        },
        "diff_content": "@@ -130,10 +130,9 @@ public final class MethodSpecTest {\n     MethodSpec method = MethodSpec.overriding(methodElement).build();\n     assertThat(method.toString()).isEqualTo(\"\"\n         + \"@java.lang.Override\\n\"\n-        + \"@java.lang.Deprecated\\n\"\n         + \"protected <T extends java.lang.Runnable & java.io.Closeable> \"\n         + \"java.lang.Runnable everything(\"\n-        + \"@com.squareup.javapoet.MethodSpecTest.Nullable java.lang.String arg0, \"\n+        + \"java.lang.String arg0, \"\n         + \"java.util.List<? extends T> arg1) \"\n         + \"throws java.io.IOException, java.lang.SecurityException {\\n\"\n         + \"}\\n\");\n"
    },
    {
        "commit_hash": "242beb35bfbdb36b77d720bcfa3642427c48f433",
        "previous_commit_hash": "40e4c3a2bb288853ba9cbdcf300674552e26140b",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -434,6 +434,7 @@ public final class TypeSpec {\n     }\n \n     public Builder superclass(TypeName superclass) {\n+      checkState(this.kind == Kind.CLASS, \"only classes have super classes, not \" + this.kind);\n       checkState(this.superclass == ClassName.OBJECT,\n           \"superclass already set to \" + this.superclass);\n       checkArgument(!superclass.isPrimitive(), \"superclass may not be a primitive\");\n"
    },
    {
        "commit_hash": "242beb35bfbdb36b77d720bcfa3642427c48f433",
        "previous_commit_hash": "40e4c3a2bb288853ba9cbdcf300674552e26140b",
        "diff_stats": {
            "additions": 18,
            "deletions": 0
        },
        "diff_content": "@@ -2014,6 +2014,24 @@ public final class TypeSpecTest {\n     }\n   }\n \n+  @Test public void superClassOnlyValidForClasses() {\n+    try {\n+      TypeSpec.annotationBuilder(\"A\").superclass(ClassName.get(Object.class));\n+      fail();\n+    } catch (IllegalStateException expected) {\n+    }\n+    try {\n+      TypeSpec.enumBuilder(\"E\").superclass(ClassName.get(Object.class));\n+      fail();\n+    } catch (IllegalStateException expected) {\n+    }\n+    try {\n+      TypeSpec.interfaceBuilder(\"I\").superclass(ClassName.get(Object.class));\n+      fail();\n+    } catch (IllegalStateException expected) {\n+    }\n+  }\n+\n   @Test public void invalidSuperClass() {\n     try {\n       TypeSpec.classBuilder(\"foo\")\n"
    },
    {
        "commit_hash": "1e70284811cf7e323e7ab6232c4a94e985c30689",
        "previous_commit_hash": "242beb35bfbdb36b77d720bcfa3642427c48f433",
        "diff_stats": {
            "additions": 5,
            "deletions": 0
        },
        "diff_content": "@@ -126,6 +126,11 @@ public final class FieldSpec {\n       return this;\n     }\n \n+    public Builder addJavadoc(CodeBlock block) {\n+      javadoc.add(block);\n+      return this;\n+    }\n+\n     public Builder addAnnotations(Iterable<AnnotationSpec> annotationSpecs) {\n       checkArgument(annotationSpecs != null, \"annotationSpecs == null\");\n       for (AnnotationSpec annotationSpec : annotationSpecs) {\n"
    },
    {
        "commit_hash": "1e70284811cf7e323e7ab6232c4a94e985c30689",
        "previous_commit_hash": "242beb35bfbdb36b77d720bcfa3642427c48f433",
        "diff_stats": {
            "additions": 5,
            "deletions": 0
        },
        "diff_content": "@@ -301,6 +301,11 @@ public final class MethodSpec {\n       return this;\n     }\n \n+    public Builder addJavadoc(CodeBlock block) {\n+      javadoc.add(block);\n+      return this;\n+    }\n+\n     public Builder addAnnotations(Iterable<AnnotationSpec> annotationSpecs) {\n       checkArgument(annotationSpecs != null, \"annotationSpecs == null\");\n       for (AnnotationSpec annotationSpec : annotationSpecs) {\n"
    },
    {
        "commit_hash": "1e70284811cf7e323e7ab6232c4a94e985c30689",
        "previous_commit_hash": "242beb35bfbdb36b77d720bcfa3642427c48f433",
        "diff_stats": {
            "additions": 5,
            "deletions": 0
        },
        "diff_content": "@@ -391,6 +391,11 @@ public final class TypeSpec {\n       return this;\n     }\n \n+    public Builder addJavadoc(CodeBlock block) {\n+      javadoc.add(block);\n+      return this;\n+    }\n+\n     public Builder addAnnotations(Iterable<AnnotationSpec> annotationSpecs) {\n       checkArgument(annotationSpecs != null, \"annotationSpecs == null\");\n       for (AnnotationSpec annotationSpec : annotationSpecs) {\n"
    },
    {
        "commit_hash": "1e70284811cf7e323e7ab6232c4a94e985c30689",
        "previous_commit_hash": "242beb35bfbdb36b77d720bcfa3642427c48f433",
        "diff_stats": {
            "additions": 4,
            "deletions": 2
        },
        "diff_content": "@@ -1013,7 +1013,8 @@ public final class TypeSpecTest {\n   @Test public void javadoc() {\n     TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n         .addJavadoc(\"A hard or soft tortilla, loosely folded and filled with whatever {@link \\n\")\n-        .addJavadoc(\"{@link $T random} tex-mex stuff we could find in the pantry.\\n\", Random.class)\n+        .addJavadoc(\"{@link $T random} tex-mex stuff we could find in the pantry\\n\", Random.class)\n+        .addJavadoc(CodeBlock.of(\"and some {@link $T} cheese.\\n\", String.class))\n         .addField(FieldSpec.builder(boolean.class, \"soft\")\n             .addJavadoc(\"True for a soft flour tortilla; false for a crunchy corn tortilla.\\n\")\n             .build())\n@@ -1033,7 +1034,8 @@ public final class TypeSpecTest {\n         + \"\\n\"\n         + \"/**\\n\"\n         + \" * A hard or soft tortilla, loosely folded and filled with whatever {@link \\n\"\n-        + \" * {@link java.util.Random random} tex-mex stuff we could find in the pantry.\\n\"\n+        + \" * {@link java.util.Random random} tex-mex stuff we could find in the pantry\\n\"\n+        + \" * and some {@link java.lang.String} cheese.\\n\"\n         + \" */\\n\"\n         + \"class Taco {\\n\"\n         + \"  /**\\n\"\n"
    },
    {
        "commit_hash": "84c0f1596a45b7b27e2f99fb996e2b52c184f3cc",
        "previous_commit_hash": "1e70284811cf7e323e7ab6232c4a94e985c30689",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -48,8 +48,8 @@ import static com.squareup.javapoet.Util.checkArgument;\n  *       for types may be {@linkplain Class classes}, {@linkplain javax.lang.model.type.TypeMirror\n ,*       type mirrors}, and {@linkplain javax.lang.model.element.Element elements}.\n  *   <li>{@code $$} emits a dollar sign.\n- *   <li>{@code $&gt;} increases the indentation level.\n- *   <li>{@code $&lt;} decreases the indentation level.\n+ *   <li>{@code $>} increases the indentation level.\n+ *   <li>{@code $<} decreases the indentation level.\n  *   <li>{@code $[} begins a statement. For multiline statements, every line after the first line\n  *       is double-indented.\n  *   <li>{@code $]} ends a statement.\n"
    },
    {
        "commit_hash": "d2f829f2a3a03a730b1d06459807cf51d476d0ef",
        "previous_commit_hash": "d84dcffd57003ce85d669bd8619449965b2267a8",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -460,6 +460,7 @@ public final class TypeSpec {\n     }\n \n     public Builder addSuperinterface(TypeName superinterface) {\n+      checkArgument(superinterface != null, \"superinterface == null\");\n       this.superinterfaces.add(superinterface);\n       return this;\n     }\n"
    },
    {
        "commit_hash": "d2f829f2a3a03a730b1d06459807cf51d476d0ef",
        "previous_commit_hash": "d84dcffd57003ce85d669bd8619449965b2267a8",
        "diff_stats": {
            "additions": 10,
            "deletions": 0
        },
        "diff_content": "@@ -1770,6 +1770,16 @@ public final class TypeSpecTest {\n     }\n   }\n \n+  @Test public void nullSingleSuperinterfaceAddition() {\n+    try {\n+      TypeSpec.classBuilder(\"Taco\").addSuperinterface((TypeName) null);\n+      fail();\n+    } catch (IllegalArgumentException expected) {\n+      assertThat(expected.getMessage())\n+          .isEqualTo(\"superinterface == null\");\n+    }\n+  }\n+\n   @Test public void multipleSuperinterfaceAddition() {\n     TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n         .addSuperinterfaces(Arrays.asList(\n"
    },
    {
        "commit_hash": "e3baf6bf5c53add0012b253219ea3a8c816c2927",
        "previous_commit_hash": "dc40fbe045317c60e34abe755948c14e15363c7a",
        "diff_stats": {
            "additions": 14,
            "deletions": 4
        },
        "diff_content": "@@ -28,18 +28,19 @@ import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Objects;\n-\n-import static com.squareup.javapoet.Util.characterLiteralWithoutSingleQuotes;\n-import static com.squareup.javapoet.Util.checkNotNull;\n-\n import javax.lang.model.element.AnnotationMirror;\n import javax.lang.model.element.AnnotationValue;\n+import javax.lang.model.element.Element;\n import javax.lang.model.element.ExecutableElement;\n import javax.lang.model.element.TypeElement;\n import javax.lang.model.element.VariableElement;\n import javax.lang.model.type.TypeMirror;\n import javax.lang.model.util.SimpleAnnotationValueVisitor7;\n \n+import static com.squareup.javapoet.Util.characterLiteralWithoutSingleQuotes;\n+import static com.squareup.javapoet.Util.checkNotNull;\n+import static com.squareup.javapoet.Util.immutableList;\n+\n /** A generated annotation on a declaration. */\n public final class AnnotationSpec {\n   public final TypeName type;\n@@ -156,6 +157,15 @@ public final class AnnotationSpec {\n     return builder.build();\n   }\n \n+  /** Returns all annotations on {@code element}. */\n+  static List<AnnotationSpec> annotationsOf(Element element) {\n+    List<AnnotationSpec> result = new ArrayList<>();\n+    for (AnnotationMirror annotationMirror : element.getAnnotationMirrors()) {\n+      result.add(get(annotationMirror));\n+    }\n+    return immutableList(result);\n+  }\n+\n   public static Builder builder(ClassName type) {\n     checkNotNull(type, \"type == null\");\n     return new Builder(type);\n"
    },
    {
        "commit_hash": "e3baf6bf5c53add0012b253219ea3a8c816c2927",
        "previous_commit_hash": "dc40fbe045317c60e34abe755948c14e15363c7a",
        "diff_stats": {
            "additions": 1,
            "deletions": 11
        },
        "diff_content": "@@ -28,7 +28,6 @@ import javax.lang.model.SourceVersion;\n import javax.lang.model.element.ExecutableElement;\n import javax.lang.model.element.Modifier;\n import javax.lang.model.element.TypeParameterElement;\n-import javax.lang.model.element.VariableElement;\n import javax.lang.model.type.DeclaredType;\n import javax.lang.model.type.ExecutableType;\n import javax.lang.model.type.TypeMirror;\n@@ -212,16 +211,7 @@ public final class MethodSpec {\n     }\n \n     methodBuilder.returns(TypeName.get(method.getReturnType()));\n-\n-    List<? extends VariableElement> parameters = method.getParameters();\n-    for (VariableElement parameter : parameters) {\n-      TypeName type = TypeName.get(parameter.asType());\n-      String name = parameter.getSimpleName().toString();\n-      Set<Modifier> parameterModifiers = parameter.getModifiers();\n-      ParameterSpec.Builder parameterBuilder = ParameterSpec.builder(type, name)\n-          .addModifiers(parameterModifiers.toArray(new Modifier[parameterModifiers.size()]));\n-      methodBuilder.addParameter(parameterBuilder.build());\n-    }\n+    methodBuilder.addParameters(ParameterSpec.parametersOf(method));\n     methodBuilder.varargs(method.isVarArgs());\n \n     for (TypeMirror thrownType : method.getThrownTypes()) {\n"
    },
    {
        "commit_hash": "e3baf6bf5c53add0012b253219ea3a8c816c2927",
        "previous_commit_hash": "dc40fbe045317c60e34abe755948c14e15363c7a",
        "diff_stats": {
            "additions": 27,
            "deletions": 0
        },
        "diff_content": "@@ -23,7 +23,9 @@ import java.util.Collections;\n import java.util.List;\n import java.util.Set;\n import javax.lang.model.SourceVersion;\n+import javax.lang.model.element.ExecutableElement;\n import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.VariableElement;\n \n import static com.squareup.javapoet.Util.checkArgument;\n import static com.squareup.javapoet.Util.checkNotNull;\n@@ -78,6 +80,23 @@ public final class ParameterSpec {\n     }\n   }\n \n+  public static ParameterSpec get(VariableElement element) {\n+    TypeName type = TypeName.get(element.asType());\n+    String name = element.getSimpleName().toString();\n+    return ParameterSpec.builder(type, name)\n+        .addModifiers(element.getModifiers())\n+        .addAnnotations(AnnotationSpec.annotationsOf(element))\n+        .build();\n+  }\n+\n+  static List<ParameterSpec> parametersOf(ExecutableElement method) {\n+    List<ParameterSpec> result = new ArrayList<>();\n+    for (VariableElement parameter : method.getParameters()) {\n+      result.add(ParameterSpec.get(parameter));\n+    }\n+    return result;\n+  }\n+\n   public static Builder builder(TypeName type, String name, Modifier... modifiers) {\n     checkNotNull(type, \"type == null\");\n     checkArgument(SourceVersion.isName(name), \"not a valid name: %s\", name);\n@@ -139,6 +158,14 @@ public final class ParameterSpec {\n       return this;\n     }\n \n+    public Builder addModifiers(Iterable<Modifier> modifiers) {\n+      checkNotNull(modifiers, \"modifiers == null\");\n+      for (Modifier modifier : modifiers) {\n+        this.modifiers.add(modifier);\n+      }\n+      return this;\n+    }\n+\n     public ParameterSpec build() {\n       return new ParameterSpec(this);\n     }\n"
    },
    {
        "commit_hash": "e3baf6bf5c53add0012b253219ea3a8c816c2927",
        "previous_commit_hash": "dc40fbe045317c60e34abe755948c14e15363c7a",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -132,7 +132,7 @@ public final class MethodSpecTest {\n         + \"@java.lang.Override\\n\"\n         + \"protected <T extends java.lang.Runnable & java.io.Closeable> \"\n         + \"java.lang.Runnable everything(\"\n-        + \"java.lang.String arg0, \"\n+        + \"@\" + Nullable.class.getCanonicalName() + \" java.lang.String arg0, \"\n         + \"java.util.List<? extends T> arg1) \"\n         + \"throws java.io.IOException, java.lang.SecurityException {\\n\"\n         + \"}\\n\");\n"
    },
    {
        "commit_hash": "59ba4332c95dce61a22989890ee49d8e2e5c2d98",
        "previous_commit_hash": "4cc7b23d51cc3e829b227672e69a720a69d73f26",
        "diff_stats": {
            "additions": 5,
            "deletions": 4
        },
        "diff_content": "@@ -39,6 +39,7 @@ import javax.tools.SimpleJavaFileObject;\n \n import static com.squareup.javapoet.Util.checkArgument;\n import static com.squareup.javapoet.Util.checkNotNull;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n \n /** A Java file containing a single top level class. */\n public final class JavaFile {\n@@ -81,7 +82,7 @@ public final class JavaFile {\n     emit(codeWriter);\n   }\n \n-  /** Writes this to {@code directory} the standard directory structure. */\n+  /** Writes this to {@code directory} as UTF-8 using the standard directory structure. */\n   public void writeTo(Path directory) throws IOException {\n     checkArgument(Files.notExists(directory) || Files.isDirectory(directory),\n         \"path %s exists but is not a directory.\", directory);\n@@ -94,12 +95,12 @@ public final class JavaFile {\n     }\n \n     Path outputPath = outputDirectory.resolve(typeSpec.name + \".java\");\n-    try (Writer writer = new OutputStreamWriter(Files.newOutputStream(outputPath))) {\n+    try (Writer writer = new OutputStreamWriter(Files.newOutputStream(outputPath), UTF_8)) {\n       writeTo(writer);\n     }\n   }\n \n-  /** Writes this to {@code directory} the standard directory structure. */\n+  /** Writes this to {@code directory} as UTF-8 using the standard directory structure. */\n   public void writeTo(File directory) throws IOException {\n     writeTo(directory.toPath());\n   }\n@@ -190,7 +191,7 @@ public final class JavaFile {\n         return JavaFile.this.toString();\n       }\n       @Override public InputStream openInputStream() throws IOException {\n-        return new ByteArrayInputStream(getCharContent(true).getBytes());\n+        return new ByteArrayInputStream(getCharContent(true).getBytes(UTF_8));\n       }\n       @Override public long getLastModified() {\n         return lastModified;\n"
    },
    {
        "commit_hash": "59ba4332c95dce61a22989890ee49d8e2e5c2d98",
        "previous_commit_hash": "4cc7b23d51cc3e829b227672e69a720a69d73f26",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -15,8 +15,6 @@\n  */\n package com.squareup.javapoet;\n \n-import static java.lang.Character.isISOControl;\n-\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n@@ -28,6 +26,8 @@ import java.util.Map;\n import java.util.Set;\n import javax.lang.model.element.Modifier;\n \n+import static java.lang.Character.isISOControl;\n+\n /**\n  * Like Guava, but worse and standalone. This makes it easier to mix JavaPoet with libraries that\n  * bring their own version of Guava.\n"
    },
    {
        "commit_hash": "59ba4332c95dce61a22989890ee49d8e2e5c2d98",
        "previous_commit_hash": "4cc7b23d51cc3e829b227672e69a720a69d73f26",
        "diff_stats": {
            "additions": 8,
            "deletions": 10
        },
        "diff_content": "@@ -15,10 +15,9 @@\n  */\n package com.squareup.javapoet;\n \n+import com.google.common.io.ByteStreams;\n import java.io.IOException;\n import java.net.URI;\n-import java.nio.charset.Charset;\n-import java.nio.charset.StandardCharsets;\n import java.util.Collections;\n import java.util.Locale;\n import java.util.concurrent.Callable;\n@@ -36,9 +35,9 @@ import org.junit.Test;\n import org.junit.rules.TemporaryFolder;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n-import com.google.common.io.ByteStreams;\n \n import static com.google.common.truth.Truth.assertThat;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n \n @RunWith(JUnit4.class)\n public class FileReadingTest {\n@@ -63,7 +62,7 @@ public class FileReadingTest {\n   \n   @Test public void javaFileObjectCharacterContent() throws IOException {\n     TypeSpec type = TypeSpec.classBuilder(\"Test\")\n-        .addJavadoc(\"Testing, 1, 2, 3!\")\n+        .addJavadoc(\"Pi\\u00f1ata\\u00a1\")\n         .addMethod(MethodSpec.methodBuilder(\"fooBar\").build())\n         .build();\n     JavaFile javaFile = JavaFile.builder(\"foo\", type).build();\n@@ -74,14 +73,14 @@ public class FileReadingTest {\n     assertThat(javaFileObject.getCharContent(false)).isEqualTo(javaFile.toString());\n   }\n   \n-  @Test public void javaFileObjectInputStream() throws IOException {\n+  @Test public void javaFileObjectInputStreamIsUtf8() throws IOException {\n     JavaFile javaFile = JavaFile.builder(\"foo\", TypeSpec.classBuilder(\"Test\").build())\n-        .addFileComment(\"\\u00A9 Copyright character gets you everytime\")\n+        .addFileComment(\"Pi\\u00f1ata\\u00a1\")\n         .build();\n     byte[] bytes = ByteStreams.toByteArray(javaFile.toJavaFileObject().openInputStream());\n     \n-    // Be explicit with the default charset to assert the implicit behavior in the code\n-    assertThat(bytes).isEqualTo(javaFile.toString().getBytes(Charset.defaultCharset()));\n+    // JavaPoet always uses UTF-8.\n+    assertThat(bytes).isEqualTo(javaFile.toString().getBytes(UTF_8));\n   }\n   \n   @Test public void compileJavaFile() throws Exception {\n@@ -100,7 +99,7 @@ public class FileReadingTest {\n     JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n     DiagnosticCollector<JavaFileObject> diagnosticCollector = new DiagnosticCollector<>();\n     StandardJavaFileManager fileManager = compiler.getStandardFileManager(diagnosticCollector, \n-        Locale.getDefault(), StandardCharsets.UTF_8);\n+        Locale.getDefault(), UTF_8);\n     fileManager.setLocation(StandardLocation.CLASS_OUTPUT,\n         Collections.singleton(temporaryFolder.newFolder()));\n     CompilationTask task = compiler.getTask(null, \n@@ -117,5 +116,4 @@ public class FileReadingTest {\n     Callable<?> test = Class.forName(\"foo.Test\", true, loader).asSubclass(Callable.class).newInstance();\n     assertThat(Callable.class.getMethod(\"call\").invoke(test)).isEqualTo(value);\n   }\n-\n }\n"
    },
    {
        "commit_hash": "59ba4332c95dce61a22989890ee49d8e2e5c2d98",
        "previous_commit_hash": "4cc7b23d51cc3e829b227672e69a720a69d73f26",
        "diff_stats": {
            "additions": 20,
            "deletions": 0
        },
        "diff_content": "@@ -33,6 +33,7 @@ import org.junit.runners.JUnit4;\n import org.mockito.Mockito;\n \n import static com.google.common.truth.Truth.assertThat;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n import static org.junit.Assert.fail;\n \n @RunWith(JUnit4.class)\n@@ -196,4 +197,23 @@ public final class FileWritingTest {\n         + \"\\t}\\n\"\n         + \"}\\n\");\n   }\n+\n+  /**\n+   * This test confirms that JavaPoet ignores the host charset and always uses UTF-8. The host\n+   * charset is customized with {@code -Dfile.encoding=ISO-8859-1}.\n+   */\n+  @Test public void fileIsUtf8() throws IOException {\n+    JavaFile javaFile = JavaFile.builder(\"foo\", TypeSpec.classBuilder(\"Taco\").build())\n+        .addFileComment(\"Pi\\u00f1ata\\u00a1\")\n+        .build();\n+    javaFile.writeTo(fsRoot);\n+\n+    Path fooPath = fsRoot.resolve(fs.getPath(\"foo\", \"Taco.java\"));\n+    assertThat(new String(Files.readAllBytes(fooPath), UTF_8)).isEqualTo(\"\"\n+        + \"// Pi\\u00f1ata\\u00a1\\n\"\n+        + \"package foo;\\n\"\n+        + \"\\n\"\n+        + \"class Taco {\\n\"\n+        + \"}\\n\");\n+  }\n }\n"
    },
    {
        "commit_hash": "16cd72b20ba9f36a184b170f01c4a4a1db80bdbd",
        "previous_commit_hash": "89179ea493f852ed6b6b36ccde978e9ddc176ce0",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -454,7 +454,7 @@ public final class TypeSpec {\n     public Builder addSuperinterfaces(Iterable<? extends TypeName> superinterfaces) {\n       checkArgument(superinterfaces != null, \"superinterfaces == null\");\n       for (TypeName superinterface : superinterfaces) {\n-        this.superinterfaces.add(superinterface);\n+        addSuperinterface(superinterface);\n       }\n       return this;\n     }\n"
    },
    {
        "commit_hash": "16cd72b20ba9f36a184b170f01c4a4a1db80bdbd",
        "previous_commit_hash": "89179ea493f852ed6b6b36ccde978e9ddc176ce0",
        "diff_stats": {
            "additions": 15,
            "deletions": 0
        },
        "diff_content": "@@ -21,6 +21,7 @@ import java.io.IOException;\n import java.io.Serializable;\n import java.math.BigDecimal;\n import java.util.AbstractSet;\n+import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.Comparator;\n@@ -1780,6 +1781,20 @@ public final class TypeSpecTest {\n     }\n   }\n \n+  @Test public void nullInSuperinterfaceIterableAddition() {\n+    List<TypeName> superinterfaces = new ArrayList<>();\n+    superinterfaces.add(TypeName.get(List.class));\n+    superinterfaces.add(null);\n+\n+    try {\n+      TypeSpec.classBuilder(\"Taco\").addSuperinterfaces(superinterfaces);\n+      fail();\n+    } catch (IllegalArgumentException expected) {\n+      assertThat(expected.getMessage())\n+          .isEqualTo(\"superinterface == null\");\n+    }\n+  }\n+\n   @Test public void multipleSuperinterfaceAddition() {\n     TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n         .addSuperinterfaces(Arrays.asList(\n"
    },
    {
        "commit_hash": "868524732babecd9e88f1a5c2cd65d672f62fafd",
        "previous_commit_hash": "4eda8d4a3639f7645e7125a45d183db4d22a50c4",
        "diff_stats": {
            "additions": 45,
            "deletions": 9
        },
        "diff_content": "@@ -166,10 +166,10 @@ public static void main(String[] args) throws Exception {\n       .addMethod(whatsMyName(\"eminem\"))\n       .addMethod(whatsMyName(\"marshallMathers\"))\n       .build();\n-      \n+\n   JavaFile javaFile = JavaFile.builder(\"com.example.helloworld\", helloWorld)\n       .build();\n-      \n+\n   javaFile.writeTo(System.out);\n }\n \n@@ -210,15 +210,15 @@ MethodSpec today = MethodSpec.methodBuilder(\"today\")\n     .returns(Date.class)\n     .addStatement(\"return new $T()\", Date.class)\n     .build();\n-    \n+\n TypeSpec helloWorld = TypeSpec.classBuilder(\"HelloWorld\")\n     .addModifiers(Modifier.PUBLIC, Modifier.FINAL)\n     .addMethod(today)\n     .build();\n-    \n+\n JavaFile javaFile = JavaFile.builder(\"com.example.helloworld\", helloWorld)\n     .build();\n-    \n+\n javaFile.writeTo(System.out);\n ```\n \n@@ -387,7 +387,7 @@ MethodSpec hexDigit = MethodSpec.methodBuilder(\"hexDigit\")\n     .returns(char.class)\n     .addStatement(\"return (char) (i < 10 ? i + '0' : i - 10 + 'a')\")\n     .build();\n-    \n+\n MethodSpec byteToHex = MethodSpec.methodBuilder(\"byteToHex\")\n     .addParameter(int.class, \"b\")\n     .returns(String.class)\n@@ -398,6 +398,42 @@ MethodSpec byteToHex = MethodSpec.methodBuilder(\"byteToHex\")\n     .build();\n ```\n \n+### Code block format strings\n+\n+Code blocks may specify the values for their placeholders in a few ways. Only one style may be used\n+for each operation on a code block.\n+\n+#### Relative Arguments\n+\n+Pass an argument value for each placeholder in the format string to `CodeBlock.add()`. In each\n+example, we generate code to say \"I ate 3 tacos\"\n+\n+```java\n+CodeBlock.builder().add(\"I ate $L $L\", 3, \"tacos\")\n+```\n+\n+#### Positional Arguments\n+\n+Place an integer index (1-based) before the placeholder in the format string to specify which\n+ argument to use.\n+\n+```java\n+CodeBlock.builder().add(\"I ate $2L $1L\", \"tacos\", 3)\n+```\n+\n+#### Named Arguments\n+\n+Use the syntax `$argumentName:X` where `X` is the format character and call `CodeBlock.addNamed()`\n+with a map containing all argument keys in the format string. Argument names use characters in\n+`a-z`, `A-Z`, `0-9`, and `_`, and must start with a lowercase character.\n+\n+```java\n+Map<String, Object> map = new LinkedHashMap<>();\n+map.put(\"food\", \"tacos\");\n+map.put(\"count\", 3);\n+CodeBlock.builder().addNamed(\"I ate $count:L $food:L\", map)\n+```\n+\n ### Methods\n \n All of the above methods have a code body. Use `Modifiers.ABSTRACT` to get a method without any\n@@ -407,7 +443,7 @@ body. This is only legal if the enclosing class is either abstract or an interfa\n MethodSpec flux = MethodSpec.methodBuilder(\"flux\")\n     .addModifiers(Modifier.ABSTRACT, Modifier.PROTECTED)\n     .build();\n-    \n+\n TypeSpec helloWorld = TypeSpec.classBuilder(\"HelloWorld\")\n     .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)\n     .addMethod(flux)\n@@ -440,7 +476,7 @@ MethodSpec flux = MethodSpec.constructorBuilder()\n     .addParameter(String.class, \"greeting\")\n     .addStatement(\"this.$N = $N\", \"greeting\", \"greeting\")\n     .build();\n-    \n+\n TypeSpec helloWorld = TypeSpec.classBuilder(\"HelloWorld\")\n     .addModifiers(Modifier.PUBLIC)\n     .addField(String.class, \"greeting\", Modifier.PRIVATE, Modifier.FINAL)\n@@ -497,7 +533,7 @@ Like parameters, fields can be created either with builders or by using convenie\n FieldSpec android = FieldSpec.builder(String.class, \"android\")\n     .addModifiers(Modifier.PRIVATE, Modifier.FINAL)\n     .build();\n-    \n+\n TypeSpec helloWorld = TypeSpec.classBuilder(\"HelloWorld\")\n     .addModifiers(Modifier.PUBLIC)\n     .addField(android)\n"
    },
    {
        "commit_hash": "868524732babecd9e88f1a5c2cd65d672f62fafd",
        "previous_commit_hash": "4eda8d4a3639f7645e7125a45d183db4d22a50c4",
        "diff_stats": {
            "additions": 96,
            "deletions": 18
        },
        "diff_content": "@@ -20,6 +20,9 @@ import java.io.StringWriter;\n import java.lang.reflect.Type;\n import java.util.ArrayList;\n import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n import javax.lang.model.element.Element;\n import javax.lang.model.type.TypeMirror;\n \n@@ -56,6 +59,10 @@ import static com.squareup.javapoet.Util.checkArgument;\n  * </ul>\n  */\n public final class CodeBlock {\n+  private static final Pattern NAMED_ARGUMENT =\n+      Pattern.compile(\"\\\\$(?<argumentName>[\\\\w_]+):(?<typeChar>[\\\\w]).*\", Pattern.DOTALL);\n+  private static final Pattern LOWERCASE = Pattern.compile(\"[a-z]+[\\\\w_]*\");\n+\n   /** A heterogeneous list containing string literals and value placeholders. */\n   final List<String> formatParts;\n   final List<Object> args;\n@@ -112,9 +119,72 @@ public final class CodeBlock {\n     private Builder() {\n     }\n \n+    /**\n+     * Adds code using named arguments.\n+     *\n+     * <p>Named arguments specify their name after the '$' followed by : and the corresponding type\n+     * character. Argument names consist of characters in {@code a-z, A-Z, 0-9, and _} and must\n+     * start with a lowercase character.\n+     *\n+     * <p>For example, to refer to the type {@link java.lang.Integer} with the argument name {@code\n+     * clazz} use a format string containing {@code $clazz:T} and include the key {@code clazz} with\n+     * value {@code java.lang.Integer.class} in the argument map.\n+     */\n+    public Builder addNamed(String format, Map<String, ?> arguments) {\n+      int p = 0;\n+\n+      for (String argument : arguments.keySet()) {\n+        checkArgument(LOWERCASE.matcher(argument).matches(),\n+            \"argument '%s' must start with a lowercase character\", argument);\n+      }\n+\n+      while (p < format.length()) {\n+        int nextP = format.indexOf(\"$\", p);\n+        if (nextP == -1) {\n+          formatParts.add(format.substring(p, format.length()));\n+          break;\n+        }\n+\n+        if (p != nextP) {\n+          formatParts.add(format.substring(p, nextP));\n+          p = nextP;\n+        }\n+        Matcher matcher = NAMED_ARGUMENT.matcher(format.subSequence(p, format.length()));\n+        if (matcher.matches()) {\n+          String argumentName = matcher.group(\"argumentName\");\n+          checkArgument(arguments.containsKey(argumentName), \"Missing named argument for $%s\",\n+              argumentName);\n+          char formatChar = matcher.group(\"typeChar\").charAt(0);\n+          addArgument(format, formatChar, arguments.get(argumentName));\n+          formatParts.add(\"$\" + formatChar);\n+          p += matcher.regionStart() + argumentName.length() + 3;\n+        } else {\n+          checkArgument(p < format.length() - 1, \"dangling $ at end\");\n+          checkArgument(isNoArgPlaceholder(format.charAt(p + 1)),\n+              \"unknown format $%s at %s in '%s'\", format.charAt(p + 1), p + 1, format);\n+          formatParts.add(format.substring(p, p + 2));\n+          p += 2;\n+        }\n+      }\n+\n+      return this;\n+    }\n+\n+    /**\n+     * Add code with positional or relative arguments.\n+     *\n+     * <p>Relative arguments map 1:1 with the placeholders in the format string.\n+     *\n+     * <p>Positional arguments use an index after the placeholder to identify which argument index\n+     * to use. For example, for a literal to reference the 3rd argument: \"$3L\" (1 based index)\n+     *\n+     * <p>Mixing relative and positional arguments in a call to add is invalid and will result in an\n+     * error.\n+     */\n     public Builder add(String format, Object... args) {\n       boolean hasRelative = false;\n       boolean hasIndexed = false;\n+\n       int relativeParameterCount = 0;\n       int[] indexedParameterCount = new int[args.length];\n \n@@ -139,7 +209,7 @@ public final class CodeBlock {\n         int indexEnd = p - 1;\n \n         // If 'c' doesn't take an argument, we're done.\n-        if (c == '$' || c == '>' || c == '<' || c == '[' || c == ']') {\n+        if (isNoArgPlaceholder(c)) {\n           checkArgument(indexStart == indexEnd, \"$$, $>, $<, $[ and $] may not have an index\");\n           formatParts.add(\"$\" + c);\n           continue;\n@@ -162,23 +232,7 @@ public final class CodeBlock {\n             index + 1, format.substring(indexStart - 1, indexEnd + 1), args.length);\n         checkArgument(!hasIndexed || !hasRelative, \"cannot mix indexed and positional parameters\");\n \n-        switch (c) {\n-          case 'N':\n-            this.args.add(argToName(args[index]));\n-            break;\n-          case 'L':\n-            this.args.add(argToLiteral(args[index]));\n-            break;\n-          case 'S':\n-            this.args.add(argToString(args[index]));\n-            break;\n-          case 'T':\n-            this.args.add(argToType(args[index]));\n-            break;\n-          default:\n-            throw new IllegalArgumentException(\n-                String.format(\"invalid format string: '%s'\", format));\n-        }\n+        addArgument(format, c, args[index]);\n \n         formatParts.add(\"$\" + c);\n       }\n@@ -200,6 +254,30 @@ public final class CodeBlock {\n       return this;\n     }\n \n+    private boolean isNoArgPlaceholder(char c) {\n+      return c == '$' || c == '>' || c == '<' || c == '[' || c == ']';\n+    }\n+\n+    private void addArgument(String format, char c, Object arg) {\n+      switch (c) {\n+        case 'N':\n+          this.args.add(argToName(arg));\n+          break;\n+        case 'L':\n+          this.args.add(argToLiteral(arg));\n+          break;\n+        case 'S':\n+          this.args.add(argToString(arg));\n+          break;\n+        case 'T':\n+          this.args.add(argToType(arg));\n+          break;\n+        default:\n+          throw new IllegalArgumentException(\n+              String.format(\"invalid format string: '%s'\", format));\n+      }\n+    }\n+\n     private String argToName(Object o) {\n       if (o instanceof CharSequence) return o.toString();\n       if (o instanceof ParameterSpec) return ((ParameterSpec) o).name;\n"
    },
    {
        "commit_hash": "868524732babecd9e88f1a5c2cd65d672f62fafd",
        "previous_commit_hash": "4eda8d4a3639f7645e7125a45d183db4d22a50c4",
        "diff_stats": {
            "additions": 95,
            "deletions": 16
        },
        "diff_content": "@@ -15,6 +15,8 @@\n  */\n package com.squareup.javapoet;\n \n+import java.util.LinkedHashMap;\n+import java.util.Map;\n import org.junit.Test;\n \n import static com.google.common.truth.Truth.assertThat;\n@@ -45,7 +47,7 @@ public final class CodeBlockTest {\n       assertThat(exp).hasMessage(\"$$, $>, $<, $[ and $] may not have an index\");\n     }\n   }\n-  \n+\n   @Test public void deindentCannotBeIndexed() {\n     try {\n       CodeBlock.builder().add(\"$1<\", \"taco\").build();\n@@ -54,7 +56,7 @@ public final class CodeBlockTest {\n       assertThat(exp).hasMessage(\"$$, $>, $<, $[ and $] may not have an index\");\n     }\n   }\n-  \n+\n   @Test public void dollarSignEscapeCannotBeIndexed() {\n     try {\n       CodeBlock.builder().add(\"$1$\", \"taco\").build();\n@@ -63,7 +65,7 @@ public final class CodeBlockTest {\n       assertThat(exp).hasMessage(\"$$, $>, $<, $[ and $] may not have an index\");\n     }\n   }\n- \n+\n   @Test public void statementBeginningCannotBeIndexed() {\n     try {\n       CodeBlock.builder().add(\"$1[\", \"taco\").build();\n@@ -72,7 +74,7 @@ public final class CodeBlockTest {\n       assertThat(exp).hasMessage(\"$$, $>, $<, $[ and $] may not have an index\");\n     }\n   }\n-  \n+\n   @Test public void statementEndingCannotBeIndexed() {\n     try {\n       CodeBlock.builder().add(\"$1]\", \"taco\").build();\n@@ -81,27 +83,104 @@ public final class CodeBlockTest {\n       assertThat(exp).hasMessage(\"$$, $>, $<, $[ and $] may not have an index\");\n     }\n   }\n-  \n+\n   @Test public void nameFormatCanBeIndexed() {\n     CodeBlock block = CodeBlock.builder().add(\"$1N\", \"taco\").build();\n     assertThat(block.toString()).isEqualTo(\"taco\");\n   }\n-  \n+\n   @Test public void literalFormatCanBeIndexed() {\n     CodeBlock block = CodeBlock.builder().add(\"$1L\", \"taco\").build();\n     assertThat(block.toString()).isEqualTo(\"taco\");\n   }\n-  \n+\n   @Test public void stringFormatCanBeIndexed() {\n     CodeBlock block = CodeBlock.builder().add(\"$1S\", \"taco\").build();\n     assertThat(block.toString()).isEqualTo(\"\\\"taco\\\"\");\n   }\n-  \n+\n   @Test public void typeFormatCanBeIndexed() {\n     CodeBlock block = CodeBlock.builder().add(\"$1T\", String.class).build();\n     assertThat(block.toString()).isEqualTo(\"java.lang.String\");\n   }\n-  \n+\n+  @Test public void simpleNamedArgument() {\n+    Map<String, Object> map = new LinkedHashMap<>();\n+    map.put(\"text\", \"taco\");\n+    CodeBlock block = CodeBlock.builder().addNamed(\"$text:S\", map).build();\n+    assertThat(block.toString()).isEqualTo(\"\\\"taco\\\"\");\n+  }\n+\n+  @Test public void repeatedNamedArgument() {\n+    Map<String, Object> map = new LinkedHashMap<>();\n+    map.put(\"text\", \"tacos\");\n+    CodeBlock block = CodeBlock.builder()\n+        .addNamed(\"\\\"I like \\\" + $text:S + \\\". Do you like \\\" + $text:S + \\\"?\\\"\", map)\n+        .build();\n+    assertThat(block.toString()).isEqualTo(\n+        \"\\\"I like \\\" + \\\"tacos\\\" + \\\". Do you like \\\" + \\\"tacos\\\" + \\\"?\\\"\");\n+  }\n+\n+  @Test public void namedAndNoArgFormat() {\n+    Map<String, Object> map = new LinkedHashMap<>();\n+    map.put(\"text\", \"tacos\");\n+    CodeBlock block = CodeBlock.builder()\n+        .addNamed(\"$>\\n$text:L for $$3.50\", map).build();\n+    assertThat(block.toString()).isEqualTo(\"\\n  tacos for $3.50\");\n+  }\n+\n+  @Test public void missingNamedArgument() {\n+    try {\n+      Map<String, Object> map = new LinkedHashMap<>();\n+      CodeBlock.builder().addNamed(\"$text:S\", map).build();\n+      fail();\n+    } catch(IllegalArgumentException expected) {\n+      assertThat(expected).hasMessage(\"Missing named argument for $text\");\n+    }\n+  }\n+\n+  @Test public void lowerCaseNamed() {\n+    try {\n+      Map<String, Object> map = new LinkedHashMap<>();\n+      map.put(\"Text\", \"tacos\");\n+      CodeBlock block = CodeBlock.builder().addNamed(\"$Text:S\", map).build();\n+      fail();\n+    } catch(IllegalArgumentException expected) {\n+      assertThat(expected).hasMessage(\"argument 'Text' must start with a lowercase character\");\n+    }\n+  }\n+\n+  @Test public void multipleNamedArguments() {\n+    Map<String, Object> map = new LinkedHashMap<>();\n+    map.put(\"pipe\", System.class);\n+    map.put(\"text\", \"tacos\");\n+\n+    CodeBlock block = CodeBlock.builder()\n+        .addNamed(\"$pipe:T.out.println(\\\"Let's eat some $text:L\\\");\", map)\n+        .build();\n+\n+    assertThat(block.toString()).isEqualTo(\n+        \"java.lang.System.out.println(\\\"Let's eat some tacos\\\");\");\n+  }\n+\n+  @Test public void namedNewline() {\n+    Map<String, Object> map = new LinkedHashMap<>();\n+    map.put(\"clazz\", Integer.class);\n+    CodeBlock block = CodeBlock.builder().addNamed(\"$clazz:T\\n\", map).build();\n+    assertThat(block.toString()).isEqualTo(\"java.lang.Integer\\n\");\n+  }\n+\n+  @Test public void danglingNamed() {\n+    Map<String, Object> map = new LinkedHashMap<>();\n+    map.put(\"clazz\", Integer.class);\n+    try {\n+      CodeBlock.builder().addNamed(\"$clazz:T$\", map).build();\n+      fail();\n+    } catch(IllegalArgumentException expected) {\n+      assertThat(expected).hasMessage(\"dangling $ at end\");\n+    }\n+  }\n+\n   @Test public void indexTooHigh() {\n     try {\n       CodeBlock.builder().add(\"$2T\", String.class).build();\n@@ -110,7 +189,7 @@ public final class CodeBlockTest {\n       assertThat(expected).hasMessage(\"index 2 for '$2T' not in range (received 1 arguments)\");\n     }\n   }\n-  \n+\n   @Test public void indexIsZero() {\n     try {\n       CodeBlock.builder().add(\"$0T\", String.class).build();\n@@ -119,7 +198,7 @@ public final class CodeBlockTest {\n       assertThat(expected).hasMessage(\"index 0 for '$0T' not in range (received 1 arguments)\");\n     }\n   }\n-  \n+\n   @Test public void indexIsNegative() {\n     try {\n       CodeBlock.builder().add(\"$-1T\", String.class).build();\n@@ -128,7 +207,7 @@ public final class CodeBlockTest {\n       assertThat(expected).hasMessage(\"invalid format string: '$-1T'\");\n     }\n   }\n-  \n+\n   @Test public void indexWithoutFormatType() {\n     try {\n       CodeBlock.builder().add(\"$1\", String.class).build();\n@@ -137,7 +216,7 @@ public final class CodeBlockTest {\n       assertThat(expected).hasMessage(\"dangling format characters in '$1'\");\n     }\n   }\n-  \n+\n   @Test public void indexWithoutFormatTypeNotAtStringEnd() {\n     try {\n       CodeBlock.builder().add(\"$1 taco\", String.class).build();\n@@ -146,7 +225,7 @@ public final class CodeBlockTest {\n       assertThat(expected).hasMessage(\"invalid format string: '$1 taco'\");\n     }\n   }\n-  \n+\n   @Test public void formatIndicatorAlone() {\n     try {\n       CodeBlock.builder().add(\"$\", String.class).build();\n@@ -155,7 +234,7 @@ public final class CodeBlockTest {\n       assertThat(expected).hasMessage(\"dangling format characters in '$'\");\n     }\n   }\n-  \n+\n   @Test public void formatIndicatorWithoutIndexOrFormatType() {\n     try {\n       CodeBlock.builder().add(\"$ tacoString\", String.class).build();\n@@ -164,7 +243,7 @@ public final class CodeBlockTest {\n       assertThat(expected).hasMessage(\"invalid format string: '$ tacoString'\");\n     }\n   }\n-  \n+\n   @Test public void sameIndexCanBeUsedWithDifferentFormats() {\n     CodeBlock block = CodeBlock.builder()\n         .add(\"$1T.out.println($1S)\", ClassName.get(System.class))\n"
    },
    {
        "commit_hash": "61b0faf17728e28afac1240c3a565f95b083183b",
        "previous_commit_hash": "3bef6897622c8eb347fa10ece1102ef1188ae677",
        "diff_stats": {
            "additions": 4,
            "deletions": 2
        },
        "diff_content": "@@ -51,6 +51,8 @@ import static com.squareup.javapoet.Util.checkArgument;\n  *       for types may be {@linkplain Class classes}, {@linkplain javax.lang.model.type.TypeMirror\n ,*       type mirrors}, and {@linkplain javax.lang.model.element.Element elements}.\n  *   <li>{@code $$} emits a dollar sign.\n+ *   <li>{@code $W} emits a space or a newline, depending on its position on the line. This prefers\n+ *       to wrap lines before 100 columns.\n  *   <li>{@code $>} increases the indentation level.\n  *   <li>{@code $<} decreases the indentation level.\n  *   <li>{@code $[} begins a statement. For multiline statements, every line after the first line\n@@ -210,7 +212,7 @@ public final class CodeBlock {\n \n         // If 'c' doesn't take an argument, we're done.\n         if (isNoArgPlaceholder(c)) {\n-          checkArgument(indexStart == indexEnd, \"$$, $>, $<, $[ and $] may not have an index\");\n+          checkArgument(indexStart == indexEnd, \"$$, $>, $<, $[, $], and $W may not have an index\");\n           formatParts.add(\"$\" + c);\n           continue;\n         }\n@@ -255,7 +257,7 @@ public final class CodeBlock {\n     }\n \n     private boolean isNoArgPlaceholder(char c) {\n-      return c == '$' || c == '>' || c == '<' || c == '[' || c == ']';\n+      return c == '$' || c == '>' || c == '<' || c == '[' || c == ']' || c == 'W';\n     }\n \n     private void addArgument(String format, char c, Object arg) {\n"
    },
    {
        "commit_hash": "61b0faf17728e28afac1240c3a565f95b083183b",
        "previous_commit_hash": "3bef6897622c8eb347fa10ece1102ef1188ae677",
        "diff_stats": {
            "additions": 12,
            "deletions": 3
        },
        "diff_content": "@@ -45,7 +45,7 @@ final class CodeWriter {\n   private static final String NO_PACKAGE = new String();\n \n   private final String indent;\n-  private final Appendable out;\n+  private final LineWrapper out;\n   private int indentLevel;\n \n   private boolean javadoc = false;\n@@ -76,7 +76,7 @@ final class CodeWriter {\n \n   CodeWriter(Appendable out, String indent, Map<String, ClassName> importedTypes,\n       Set<String> staticImports) {\n-    this.out = checkNotNull(out, \"out == null\");\n+    this.out = new LineWrapper(out, indent, 100);\n     this.indent = checkNotNull(indent, \"indent == null\");\n     this.importedTypes = checkNotNull(importedTypes, \"importedTypes == null\");\n     this.staticImports = checkNotNull(staticImports, \"staticImports == null\");\n@@ -278,6 +278,10 @@ final class CodeWriter {\n           statementLine = -1;\n           break;\n \n+        case \"$W\":\n+          out.wrappingSpace(indentLevel + 2);\n+          break;\n+\n         default:\n           // handle deferred type\n           if (deferredTypeName != null) {\n@@ -298,6 +302,11 @@ final class CodeWriter {\n     return this;\n   }\n \n+  public CodeWriter emitWrappingSpace() throws IOException {\n+    out.wrappingSpace(indentLevel + 2);\n+    return this;\n+  }\n+\n   private static String extractMemberName(String part) {\n     checkArgument(Character.isJavaIdentifierStart(part.charAt(0)), \"not an identifier: %s\", part);\n     for (int i = 1; i <= part.length(); i++) {\n@@ -440,7 +449,7 @@ final class CodeWriter {\n           emitIndentation();\n           out.append(javadoc ? \" *\" : \"//\");\n         }\n-        out.append('\\n');\n+        out.append(\"\\n\");\n         trailingNewline = true;\n         if (statementLine != -1) {\n           if (statementLine == 0) {\n"
    },
    {
        "commit_hash": "61b0faf17728e28afac1240c3a565f95b083183b",
        "previous_commit_hash": "3bef6897622c8eb347fa10ece1102ef1188ae677",
        "diff_stats": {
            "additions": 106,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright (C) 2016 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javapoet;\n+\n+import java.io.IOException;\n+\n+import static com.squareup.javapoet.Util.checkNotNull;\n+\n+/**\n+ * Implements soft line wrapping on an appendable. To use, append characters using {@link #append}\n+ * or soft-wrapping spaces using {@link #wrappingSpace}.\n+ */\n+final class LineWrapper {\n+  private final Appendable out;\n+  private final String indent;\n+  private final int columnLimit;\n+  private boolean closed;\n+\n+  /** Characters written since the last wrapping space that haven't yet been flushed. */\n+  private final StringBuilder buffer = new StringBuilder();\n+\n+  /** The number of characters since the most recent newline. Includes both out and the buffer. */\n+  private int column = 0;\n+\n+  /** -1 if we have no buffering; otherwise the number of spaces to write after wrapping. */\n+  private int indentLevel = -1;\n+\n+  LineWrapper(Appendable out, String indent, int columnLimit) {\n+    checkNotNull(out, \"out == null\");\n+    this.out = out;\n+    this.indent = indent;\n+    this.columnLimit = columnLimit;\n+  }\n+\n+  /** Emit {@code s}. This may be buffered to permit line wraps to be inserted. */\n+  void append(String s) throws IOException {\n+    if (closed) throw new IllegalStateException(\"closed\");\n+\n+    if (indentLevel != -1) {\n+      int nextNewline = s.indexOf('\\n');\n+\n+      // If s doesn't cause the current line to cross the limit, buffer it and return. We'll decide\n+      // whether or not we have to wrap it later.\n+      if (nextNewline == -1 && column + s.length() <= columnLimit) {\n+        buffer.append(s);\n+        column += s.length();\n+        return;\n+      }\n+\n+      // Wrap if appending s would overflow the current line.\n+      boolean wrap = nextNewline == -1 || column + nextNewline > columnLimit;\n+      flush(wrap);\n+    }\n+\n+    out.append(s);\n+    int lastNewline = s.lastIndexOf('\\n');\n+    column = lastNewline != -1\n+        ? s.length() - lastNewline - 1\n+        : column + s.length();\n+  }\n+\n+  /** Emit either a space or a newline character. */\n+  void wrappingSpace(int indentLevel) throws IOException {\n+    if (closed) throw new IllegalStateException(\"closed\");\n+\n+    if (this.indentLevel != -1) flush(false);\n+    this.column++;\n+    this.indentLevel = indentLevel;\n+  }\n+\n+  /** Flush any outstanding text and forbid future writes to this line wrapper. */\n+  void close() throws IOException {\n+    if (indentLevel != -1) flush(false);\n+    closed = true;\n+  }\n+\n+  /** Write the space followed by any buffered text that follows it. */\n+  private void flush(boolean wrap) throws IOException {\n+    if (wrap) {\n+      out.append('\\n');\n+      for (int i = 0; i < indentLevel; i++) {\n+        out.append(indent);\n+      }\n+      column = indentLevel * indent.length();\n+      column += buffer.length();\n+    } else {\n+      out.append(' ');\n+    }\n+    out.append(buffer);\n+    buffer.delete(0, buffer.length());\n+    indentLevel = -1;\n+  }\n+}\n"
    },
    {
        "commit_hash": "61b0faf17728e28afac1240c3a565f95b083183b",
        "previous_commit_hash": "3bef6897622c8eb347fa10ece1102ef1188ae677",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -99,7 +99,7 @@ public final class MethodSpec {\n     boolean firstParameter = true;\n     for (Iterator<ParameterSpec> i = parameters.iterator(); i.hasNext(); ) {\n       ParameterSpec parameter = i.next();\n-      if (!firstParameter) codeWriter.emit(\", \");\n+      if (!firstParameter) codeWriter.emit(\",\").emitWrappingSpace();\n       parameter.emit(codeWriter, !i.hasNext() && varargs);\n       firstParameter = false;\n     }\n@@ -112,11 +112,11 @@ public final class MethodSpec {\n     }\n \n     if (!exceptions.isEmpty()) {\n-      codeWriter.emit(\" throws\");\n+      codeWriter.emitWrappingSpace().emit(\"throws\");\n       boolean firstException = true;\n       for (TypeName exception : exceptions) {\n         if (!firstException) codeWriter.emit(\",\");\n-        codeWriter.emit(\" $T\", exception);\n+        codeWriter.emitWrappingSpace().emit(\"$T\", exception);\n         firstException = false;\n       }\n     }\n"
    },
    {
        "commit_hash": "61b0faf17728e28afac1240c3a565f95b083183b",
        "previous_commit_hash": "3bef6897622c8eb347fa10ece1102ef1188ae677",
        "diff_stats": {
            "additions": 5,
            "deletions": 5
        },
        "diff_content": "@@ -44,7 +44,7 @@ public final class CodeBlockTest {\n       CodeBlock.builder().add(\"$1>\", \"taco\").build();\n       fail();\n     } catch (IllegalArgumentException exp) {\n-      assertThat(exp).hasMessage(\"$$, $>, $<, $[ and $] may not have an index\");\n+      assertThat(exp).hasMessage(\"$$, $>, $<, $[, $], and $W may not have an index\");\n     }\n   }\n \n@@ -53,7 +53,7 @@ public final class CodeBlockTest {\n       CodeBlock.builder().add(\"$1<\", \"taco\").build();\n       fail();\n     } catch (IllegalArgumentException exp) {\n-      assertThat(exp).hasMessage(\"$$, $>, $<, $[ and $] may not have an index\");\n+      assertThat(exp).hasMessage(\"$$, $>, $<, $[, $], and $W may not have an index\");\n     }\n   }\n \n@@ -62,7 +62,7 @@ public final class CodeBlockTest {\n       CodeBlock.builder().add(\"$1$\", \"taco\").build();\n       fail();\n     } catch (IllegalArgumentException exp) {\n-      assertThat(exp).hasMessage(\"$$, $>, $<, $[ and $] may not have an index\");\n+      assertThat(exp).hasMessage(\"$$, $>, $<, $[, $], and $W may not have an index\");\n     }\n   }\n \n@@ -71,7 +71,7 @@ public final class CodeBlockTest {\n       CodeBlock.builder().add(\"$1[\", \"taco\").build();\n       fail();\n     } catch (IllegalArgumentException exp) {\n-      assertThat(exp).hasMessage(\"$$, $>, $<, $[ and $] may not have an index\");\n+      assertThat(exp).hasMessage(\"$$, $>, $<, $[, $], and $W may not have an index\");\n     }\n   }\n \n@@ -80,7 +80,7 @@ public final class CodeBlockTest {\n       CodeBlock.builder().add(\"$1]\", \"taco\").build();\n       fail();\n     } catch (IllegalArgumentException exp) {\n-      assertThat(exp).hasMessage(\"$$, $>, $<, $[ and $] may not have an index\");\n+      assertThat(exp).hasMessage(\"$$, $>, $<, $[, $], and $W may not have an index\");\n     }\n   }\n \n"
    },
    {
        "commit_hash": "61b0faf17728e28afac1240c3a565f95b083183b",
        "previous_commit_hash": "3bef6897622c8eb347fa10ece1102ef1188ae677",
        "diff_stats": {
            "additions": 144,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright (C) 2016 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.squareup.javapoet;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+@RunWith(JUnit4.class)\n+public final class LineWrapperTest {\n+  @Test public void wrap() throws Exception {\n+    StringBuffer out = new StringBuffer();\n+    LineWrapper lineWrapper = new LineWrapper(out, \"  \", 10);\n+    lineWrapper.append(\"abcde\");\n+    lineWrapper.wrappingSpace(2);\n+    lineWrapper.append(\"fghij\");\n+    lineWrapper.close();\n+    assertThat(out.toString()).isEqualTo(\"abcde\\n    fghij\");\n+  }\n+\n+  @Test public void noWrap() throws Exception {\n+    StringBuffer out = new StringBuffer();\n+    LineWrapper lineWrapper = new LineWrapper(out, \"  \", 10);\n+    lineWrapper.append(\"abcde\");\n+    lineWrapper.wrappingSpace(2);\n+    lineWrapper.append(\"fghi\");\n+    lineWrapper.close();\n+    assertThat(out.toString()).isEqualTo(\"abcde fghi\");\n+  }\n+\n+  @Test public void multipleWrite() throws Exception {\n+    StringBuffer out = new StringBuffer();\n+    LineWrapper lineWrapper = new LineWrapper(out, \"  \", 10);\n+    lineWrapper.append(\"ab\");\n+    lineWrapper.wrappingSpace(1);\n+    lineWrapper.append(\"cd\");\n+    lineWrapper.wrappingSpace(1);\n+    lineWrapper.append(\"ef\");\n+    lineWrapper.wrappingSpace(1);\n+    lineWrapper.append(\"gh\");\n+    lineWrapper.wrappingSpace(1);\n+    lineWrapper.append(\"ij\");\n+    lineWrapper.wrappingSpace(1);\n+    lineWrapper.append(\"kl\");\n+    lineWrapper.wrappingSpace(1);\n+    lineWrapper.append(\"mn\");\n+    lineWrapper.wrappingSpace(1);\n+    lineWrapper.append(\"op\");\n+    lineWrapper.wrappingSpace(1);\n+    lineWrapper.append(\"qr\");\n+    lineWrapper.close();\n+    assertThat(out.toString()).isEqualTo(\"ab cd ef\\n  gh ij kl\\n  mn op qr\");\n+  }\n+\n+  @Test public void fencepost() throws Exception {\n+    StringBuffer out = new StringBuffer();\n+    LineWrapper lineWrapper = new LineWrapper(out, \"  \", 10);\n+    lineWrapper.append(\"abcde\");\n+    lineWrapper.append(\"fghij\");\n+    lineWrapper.wrappingSpace(2);\n+    lineWrapper.append(\"k\");\n+    lineWrapper.append(\"lmnop\");\n+    lineWrapper.close();\n+    assertThat(out.toString()).isEqualTo(\"abcdefghij\\n    klmnop\");\n+  }\n+\n+  @Test public void overlyLongLinesWithoutLeadingSpace() throws Exception {\n+    StringBuffer out = new StringBuffer();\n+    LineWrapper lineWrapper = new LineWrapper(out, \"  \", 10);\n+    lineWrapper.append(\"abcdefghijkl\");\n+    lineWrapper.close();\n+    assertThat(out.toString()).isEqualTo(\"abcdefghijkl\");\n+  }\n+\n+  @Test public void overlyLongLinesWithLeadingSpace() throws Exception {\n+    StringBuffer out = new StringBuffer();\n+    LineWrapper lineWrapper = new LineWrapper(out, \"  \", 10);\n+    lineWrapper.wrappingSpace(2);\n+    lineWrapper.append(\"abcdefghijkl\");\n+    lineWrapper.close();\n+    assertThat(out.toString()).isEqualTo(\"\\n    abcdefghijkl\");\n+  }\n+\n+  @Test public void noWrapEmbeddedNewlines() throws Exception {\n+    StringBuffer out = new StringBuffer();\n+    LineWrapper lineWrapper = new LineWrapper(out, \"  \", 10);\n+    lineWrapper.append(\"abcde\");\n+    lineWrapper.wrappingSpace(2);\n+    lineWrapper.append(\"fghi\\njklmn\");\n+    lineWrapper.append(\"opqrstuvwxy\");\n+    lineWrapper.close();\n+    assertThat(out.toString()).isEqualTo(\"abcde fghi\\njklmnopqrstuvwxy\");\n+  }\n+\n+  @Test public void wrapEmbeddedNewlines() throws Exception {\n+    StringBuffer out = new StringBuffer();\n+    LineWrapper lineWrapper = new LineWrapper(out, \"  \", 10);\n+    lineWrapper.append(\"abcde\");\n+    lineWrapper.wrappingSpace(2);\n+    lineWrapper.append(\"fghij\\nklmn\");\n+    lineWrapper.append(\"opqrstuvwxy\");\n+    lineWrapper.close();\n+    assertThat(out.toString()).isEqualTo(\"abcde\\n    fghij\\nklmnopqrstuvwxy\");\n+  }\n+\n+  @Test public void noWrapMultipleNewlines() throws Exception {\n+    StringBuffer out = new StringBuffer();\n+    LineWrapper lineWrapper = new LineWrapper(out, \"  \", 10);\n+    lineWrapper.append(\"abcde\");\n+    lineWrapper.wrappingSpace(2);\n+    lineWrapper.append(\"fghi\\nklmnopq\\nr\");\n+    lineWrapper.wrappingSpace(2);\n+    lineWrapper.append(\"stuvwxyz\");\n+    lineWrapper.close();\n+    assertThat(out.toString()).isEqualTo(\"abcde fghi\\nklmnopq\\nr stuvwxyz\");\n+  }\n+\n+  @Test public void wrapMultipleNewlines() throws Exception {\n+    StringBuffer out = new StringBuffer();\n+    LineWrapper lineWrapper = new LineWrapper(out, \"  \", 10);\n+    lineWrapper.append(\"abcde\");\n+    lineWrapper.wrappingSpace(2);\n+    lineWrapper.append(\"fghi\\nklmnopq\\nrs\");\n+    lineWrapper.wrappingSpace(2);\n+    lineWrapper.append(\"tuvwxyz1\");\n+    lineWrapper.close();\n+    assertThat(out.toString()).isEqualTo(\"abcde fghi\\nklmnopq\\nrs\\n    tuvwxyz1\");\n+  }\n+}\n"
    },
    {
        "commit_hash": "61b0faf17728e28afac1240c3a565f95b083183b",
        "previous_commit_hash": "3bef6897622c8eb347fa10ece1102ef1188ae677",
        "diff_stats": {
            "additions": 3,
            "deletions": 5
        },
        "diff_content": "@@ -130,11 +130,9 @@ public final class MethodSpecTest {\n     MethodSpec method = MethodSpec.overriding(methodElement).build();\n     assertThat(method.toString()).isEqualTo(\"\"\n         + \"@java.lang.Override\\n\"\n-        + \"protected <T extends java.lang.Runnable & java.io.Closeable> \"\n-        + \"java.lang.Runnable everything(\"\n-        + \"@\" + Nullable.class.getCanonicalName() + \" java.lang.String arg0, \"\n-        + \"java.util.List<? extends T> arg1) \"\n-        + \"throws java.io.IOException, java.lang.SecurityException {\\n\"\n+        + \"protected <T extends java.lang.Runnable & java.io.Closeable> java.lang.Runnable \"\n+        + \"everything(@com.squareup.javapoet.MethodSpecTest.Nullable java.lang.String arg0,\\n\"\n+        + \"    java.util.List<? extends T> arg1) throws java.io.IOException, java.lang.SecurityException {\\n\"\n         + \"}\\n\");\n   }\n \n"
    },
    {
        "commit_hash": "61b0faf17728e28afac1240c3a565f95b083183b",
        "previous_commit_hash": "3bef6897622c8eb347fa10ece1102ef1188ae677",
        "diff_stats": {
            "additions": 38,
            "deletions": 13
        },
        "diff_content": "@@ -34,7 +34,6 @@ import javax.lang.model.element.Element;\n import javax.lang.model.element.Modifier;\n import javax.lang.model.element.TypeElement;\n import javax.lang.model.type.TypeMirror;\n-import org.junit.Assert;\n import org.junit.Rule;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n@@ -42,6 +41,7 @@ import org.junit.runners.JUnit4;\n import org.mockito.Mockito;\n \n import static com.google.common.truth.Truth.assertThat;\n+import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.fail;\n import static org.junit.Assume.assumeTrue;\n \n@@ -81,7 +81,7 @@ public final class TypeSpecTest {\n         + \"    return \\\"taco\\\";\\n\"\n         + \"  }\\n\"\n         + \"}\\n\");\n-    Assert.assertEquals(472949424, taco.hashCode()); // update expected number if source changes\n+    assertEquals(472949424, taco.hashCode()); // update expected number if source changes\n   }\n \n   @Test public void interestingTypes() throws Exception {\n@@ -201,8 +201,8 @@ public final class TypeSpecTest {\n         + \"import java.lang.String;\\n\"\n         + \"\\n\"\n         + \"class Foo {\\n\"\n-        + \"  public Foo(long id, @Ping String one, @Ping String two, @Pong(\\\"pong\\\") String three, \"\n-        + \"@Ping String four) {\\n\"\n+        + \"  public Foo(long id, @Ping String one, @Ping String two, @Pong(\\\"pong\\\") String three,\\n\"\n+        + \"      @Ping String four) {\\n\"\n         + \"    /* code snippets */\\n\"\n         + \"  }\\n\"\n         + \"}\\n\");\n@@ -282,8 +282,9 @@ public final class TypeSpecTest {\n         + \"      \\\"User-Agent: foobar\\\"\\n\"\n         + \"  })\\n\"\n         + \"  @POST(\\\"/foo/bar\\\")\\n\"\n-        + \"  Observable<FooBar> fooBar(@Body Things<Thing> things, @QueryMap(encodeValues = false) \"\n-        + \"Map<String, String> query, @Header(\\\"Authorization\\\") String authorization);\\n\"\n+        + \"  Observable<FooBar> fooBar(@Body Things<Thing> things,\\n\"\n+        + \"      @QueryMap(encodeValues = false) Map<String, String> query,\\n\"\n+        + \"      @Header(\\\"Authorization\\\") String authorization);\\n\"\n         + \"}\\n\");\n   }\n \n@@ -2225,10 +2226,8 @@ public final class TypeSpecTest {\n         + \"}\\n\");\n   }\n \n-  @Test\n-  public void initializerBlockUnsupportedExceptionOnInterface() {\n+  @Test public void initializerBlockUnsupportedExceptionOnInterface() {\n     TypeSpec.Builder interfaceBuilder = TypeSpec.interfaceBuilder(\"Taco\");\n-\n     try {\n       interfaceBuilder.addInitializerBlock(CodeBlock.builder().build());\n       fail(\"Exception expected\");\n@@ -2236,11 +2235,8 @@ public final class TypeSpecTest {\n     }\n   }\n \n-  @Test\n-  public void initializerBlockUnsupportedExceptionOnAnnotation() {\n-\n+  @Test public void initializerBlockUnsupportedExceptionOnAnnotation() {\n     TypeSpec.Builder annotationBuilder = TypeSpec.annotationBuilder(\"Taco\");\n-\n     try {\n       annotationBuilder.addInitializerBlock(CodeBlock.builder().build());\n       fail(\"Exception expected\");\n@@ -2248,6 +2244,35 @@ public final class TypeSpecTest {\n     }\n   }\n \n+  @Test public void lineWrapping() {\n+    MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder(\"call\");\n+    methodBuilder.addCode(\"$[call(\");\n+    for (int i = 0; i < 32; i++) {\n+      methodBuilder.addParameter(String.class, \"s\" + i);\n+      methodBuilder.addCode(i > 0 ? \",$W$S\" : \"$S\", i);\n+    }\n+    methodBuilder.addCode(\");$]\\n\");\n+\n+    TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n+        .addMethod(methodBuilder.build())\n+        .build();\n+    assertThat(toString(taco)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import java.lang.String;\\n\"\n+        + \"\\n\"\n+        + \"class Taco {\\n\"\n+        + \"  void call(String s0, String s1, String s2, String s3, String s4, String s5, String s6, String s7,\\n\"\n+        + \"      String s8, String s9, String s10, String s11, String s12, String s13, String s14, String s15,\\n\"\n+        + \"      String s16, String s17, String s18, String s19, String s20, String s21, String s22,\\n\"\n+        + \"      String s23, String s24, String s25, String s26, String s27, String s28, String s29,\\n\"\n+        + \"      String s30, String s31) {\\n\"\n+        + \"    call(\\\"0\\\", \\\"1\\\", \\\"2\\\", \\\"3\\\", \\\"4\\\", \\\"5\\\", \\\"6\\\", \\\"7\\\", \\\"8\\\", \\\"9\\\", \\\"10\\\", \\\"11\\\", \\\"12\\\", \\\"13\\\", \\\"14\\\", \\\"15\\\", \\\"16\\\",\\n\"\n+        + \"        \\\"17\\\", \\\"18\\\", \\\"19\\\", \\\"20\\\", \\\"21\\\", \\\"22\\\", \\\"23\\\", \\\"24\\\", \\\"25\\\", \\\"26\\\", \\\"27\\\", \\\"28\\\", \\\"29\\\", \\\"30\\\", \\\"31\\\");\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n   @Test public void equalsAndHashCode() {\n     TypeSpec a = TypeSpec.interfaceBuilder(\"taco\").build();\n     TypeSpec b = TypeSpec.interfaceBuilder(\"taco\").build();\n"
    },
    {
        "commit_hash": "bc65a0b33398eac6e0f80d480ccb16fa13f33b9a",
        "previous_commit_hash": "bd786800328b47b8bb0b676b4afa1afb54a49211",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -149,7 +149,6 @@ public final class TypeSpec {\n     codeWriter.statementLine = -1;\n \n     try {\n-      codeWriter.pushType(this);\n       if (enumName != null) {\n         codeWriter.emitJavadoc(javadoc);\n         codeWriter.emitAnnotations(annotations, false);\n@@ -214,6 +213,7 @@ public final class TypeSpec {\n         codeWriter.emit(\" {\\n\");\n       }\n \n+      codeWriter.pushType(this);\n       codeWriter.indent();\n       boolean firstMember = true;\n       for (Iterator<Map.Entry<String, TypeSpec>> i = enumConstants.entrySet().iterator();\n@@ -285,13 +285,13 @@ public final class TypeSpec {\n       }\n \n       codeWriter.unindent();\n+      codeWriter.popType();\n \n       codeWriter.emit(\"}\");\n       if (enumName == null && anonymousTypeArguments == null) {\n         codeWriter.emit(\"\\n\"); // If this type isn't also a value, include a trailing newline.\n       }\n     } finally {\n-      codeWriter.popType();\n       codeWriter.statementLine = previousStatementLine;\n     }\n   }\n"
    },
    {
        "commit_hash": "bc65a0b33398eac6e0f80d480ccb16fa13f33b9a",
        "previous_commit_hash": "bd786800328b47b8bb0b676b4afa1afb54a49211",
        "diff_stats": {
            "additions": 40,
            "deletions": 16
        },
        "diff_content": "@@ -30,6 +30,7 @@ import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n import java.util.Random;\n+import java.util.concurrent.Callable;\n import javax.lang.model.element.Element;\n import javax.lang.model.element.Modifier;\n import javax.lang.model.element.TypeElement;\n@@ -629,18 +630,41 @@ public final class TypeSpecTest {\n     ClassName tacoBellTaco = ClassName.get(\"com.taco.bell\", \"Taco\");\n     ClassName fishTaco = ClassName.get(\"org.fish.taco\", \"Taco\");\n     TypeSpec typeSpec = TypeSpec.classBuilder(\"Taco\")\n-            .superclass(fishTaco)\n-            .addSuperinterface(ParameterizedTypeName.get(ClassName.get(Comparable.class), javapoetTaco))\n-            .addSuperinterface(tacoBellTaco)\n-            .build();\n+        .superclass(fishTaco)\n+        .addSuperinterface(ParameterizedTypeName.get(ClassName.get(Comparable.class), javapoetTaco))\n+        .addSuperinterface(tacoBellTaco)\n+        .build();\n+    assertThat(toString(typeSpec)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import java.lang.Comparable;\\n\"\n+        + \"\\n\"\n+        + \"class Taco extends org.fish.taco.Taco \"\n+        + \"implements Comparable<Taco>, com.taco.bell.Taco {\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void classImplementsNestedClass() throws Exception {\n+    ClassName outer = ClassName.get(tacosPackage, \"Outer\");\n+    ClassName inner = outer.nestedClass(\"Inner\");\n+    ClassName callable = ClassName.get(Callable.class);\n+    TypeSpec typeSpec = TypeSpec.classBuilder(\"Outer\")\n+        .superclass(ParameterizedTypeName.get(callable,\n+            inner))\n+        .addType(TypeSpec.classBuilder(\"Inner\")\n+            .addModifiers(Modifier.STATIC)\n+            .build())\n+        .build();\n+\n     assertThat(toString(typeSpec)).isEqualTo(\"\"\n-            + \"package com.squareup.tacos;\\n\"\n-            + \"\\n\"\n-            + \"import java.lang.Comparable;\\n\"\n-            + \"\\n\"\n-            + \"class Taco extends org.fish.taco.Taco \"\n-            + \"implements Comparable<Taco>, com.taco.bell.Taco {\\n\"\n-            + \"}\\n\");\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import java.util.concurrent.Callable;\\n\"\n+        + \"\\n\"\n+        + \"class Outer extends Callable<Outer.Inner> {\\n\"\n+        + \"  static class Inner {\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n   }\n \n   @Test public void enumImplements() throws Exception {\n@@ -793,13 +817,13 @@ public final class TypeSpecTest {\n \n   @Test public void annotationWithFields() {\n     FieldSpec field = FieldSpec.builder(int.class, \"FOO\")\n-            .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)\n-            .initializer(\"$L\", 101)\n-            .build();\n+        .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)\n+        .initializer(\"$L\", 101)\n+        .build();\n \n     TypeSpec anno = TypeSpec.annotationBuilder(\"Anno\")\n-            .addField(field)\n-            .build();\n+        .addField(field)\n+        .build();\n \n     assertThat(toString(anno)).isEqualTo(\"\"\n         + \"package com.squareup.tacos;\\n\"\n"
    },
    {
        "commit_hash": "19b9d73a1be5bba5890b194260d115d664c8b5ce",
        "previous_commit_hash": "8e358310a135ba4e82def404dcddabb2346bbc12",
        "diff_stats": {
            "additions": 0,
            "deletions": 11
        },
        "diff_content": "@@ -30,7 +30,6 @@ import java.util.Map;\n import java.util.Objects;\n import javax.lang.model.element.AnnotationMirror;\n import javax.lang.model.element.AnnotationValue;\n-import javax.lang.model.element.Element;\n import javax.lang.model.element.ExecutableElement;\n import javax.lang.model.element.TypeElement;\n import javax.lang.model.element.VariableElement;\n@@ -39,7 +38,6 @@ import javax.lang.model.util.SimpleAnnotationValueVisitor7;\n \n import static com.squareup.javapoet.Util.characterLiteralWithoutSingleQuotes;\n import static com.squareup.javapoet.Util.checkNotNull;\n-import static com.squareup.javapoet.Util.immutableList;\n \n /** A generated annotation on a declaration. */\n public final class AnnotationSpec {\n@@ -157,15 +155,6 @@ public final class AnnotationSpec {\n     return builder.build();\n   }\n \n-  /** Returns all annotations on {@code element}. */\n-  static List<AnnotationSpec> annotationsOf(Element element) {\n-    List<AnnotationSpec> result = new ArrayList<>();\n-    for (AnnotationMirror annotationMirror : element.getAnnotationMirrors()) {\n-      result.add(get(annotationMirror));\n-    }\n-    return immutableList(result);\n-  }\n-\n   public static Builder builder(ClassName type) {\n     checkNotNull(type, \"type == null\");\n     return new Builder(type);\n"
    },
    {
        "commit_hash": "19b9d73a1be5bba5890b194260d115d664c8b5ce",
        "previous_commit_hash": "8e358310a135ba4e82def404dcddabb2346bbc12",
        "diff_stats": {
            "additions": 0,
            "deletions": 1
        },
        "diff_content": "@@ -85,7 +85,6 @@ public final class ParameterSpec {\n     String name = element.getSimpleName().toString();\n     return ParameterSpec.builder(type, name)\n         .addModifiers(element.getModifiers())\n-        .addAnnotations(AnnotationSpec.annotationsOf(element))\n         .build();\n   }\n \n"
    },
    {
        "commit_hash": "19b9d73a1be5bba5890b194260d115d664c8b5ce",
        "previous_commit_hash": "8e358310a135ba4e82def404dcddabb2346bbc12",
        "diff_stats": {
            "additions": 3,
            "deletions": 2
        },
        "diff_content": "@@ -131,8 +131,9 @@ public final class MethodSpecTest {\n     assertThat(method.toString()).isEqualTo(\"\"\n         + \"@java.lang.Override\\n\"\n         + \"protected <T extends java.lang.Runnable & java.io.Closeable> java.lang.Runnable \"\n-        + \"everything(@com.squareup.javapoet.MethodSpecTest.Nullable java.lang.String arg0,\\n\"\n-        + \"    java.util.List<? extends T> arg1) throws java.io.IOException, java.lang.SecurityException {\\n\"\n+        + \"everything(java.lang.String arg0,\\n\"\n+        + \"    java.util.List<? extends T> arg1) throws java.io.IOException, \"\n+        + \"java.lang.SecurityException {\\n\"\n         + \"}\\n\");\n   }\n \n"
    },
    {
        "commit_hash": "70cbbc9e998fdd927e89fad23ef34ba417889f11",
        "previous_commit_hash": "a1db4599af61248bebc2e0582788c8a0a515232a",
        "diff_stats": {
            "additions": 59,
            "deletions": 0
        },
        "diff_content": "@@ -1,22 +1,53 @@\n Change Log\n ==========\n \n+JavaPoet 1.8.0 *(2016-11-09)*\n+-----------------------------\n+\n+ * New: Basic support for line wrapping. Use `$W` to insert a Wrappable Whitespace character. It'll\n+   emit either a single space or a newline with appropriate indentation.\n+ * New: Named arguments in `CodeBlock`. These are intended to make larger code snippets easier to\n+   read:\n+\n+   ```\n+    Map<String, Object> map = new LinkedHashMap<>();\n+    map.put(\"count\", 3);\n+    map.put(\"greeting\", \"Hello, \");\n+    map.put(\"system\", System.class);\n+\n+    String template = \"\"\n+        + \"for (int i = 0; i < $count:L; i++) {\\n\"\n+        + \"  $system:T.out.println($greeting:S + list.get(i));\\n\"\n+        + \"}\\n\";\n+\n+    CodeBlock.Builder builder = CodeBlock.builder();\n+    builder.addNamed(template, map);\n+   ```\n+\n+ * New: `addJavadoc(CodeBlock)` overloads for TypeSpec, MethodSpec, and FieldSpec.\n+ * New: `MethodSpec.addComment()` makes it easy to add a `// single-line comment.`\n+ * New: `ClassName.getReflectionName()` returns a string like `java.util.Map$Entry`.\n+ * Fix: Always write UTF-8. Previously JavaPoet would use the system default charset which was\n+   potentially inconsistent across environments.\n+ * Fix: Permit (constant) fields to be defined in annotation types.\n+\n+\n JavaPoet 1.7.0 *(2016-04-26)*\n-----------------------------\n+-----------------------------\n \n  * New: Support parameterized types that enclose other types, like `Outer<String>.Inner`.\n  * New: `TypeName.isBoxedPrimitive()`.\n \n \n JavaPoet 1.6.1 *(2016-03-21)*\n-----------------------------\n+-----------------------------\n \n  * Fix: Double quotes and backslashes in string literals were not properly quoted in 1.6.0. This is\n    now fixed.\n \n \n JavaPoet 1.6.0 *(2016-03-19)*\n-----------------------------\n+-----------------------------\n \n  * New: Revive `CodeBlock.of()`, a handy factory method for building code blocks.\n  * New: Add `TypeSpec` factory methods that take a `ClassName`.\n@@ -33,12 +64,12 @@ JavaPoet 1.6.0 *(2016-03-19)*\n \n \n JavaPoet 1.5.1 *(2016-01-10)*\n-----------------------------\n+-----------------------------\n \n  * Fix: Annotated `TypeName` instances are only equal if their annotations are equal.\n \n JavaPoet 1.5.0 *(2016-01-10)*\n-----------------------------\n+-----------------------------\n \n  * New: `import static`! See `JavaFile.Builder.addStaticImport()` variants.\n  * New: Overload `NameAllocator.newName(String)` for creating a one-off name without a tag.\n@@ -49,7 +80,7 @@ JavaPoet 1.5.0 *(2016-01-10)*\n \n \n JavaPoet 1.4.0 *(2015-11-13)*\n-----------------------------\n+-----------------------------\n \n  * New: `AnnotationSpec.get(Annotation)`.\n  * New: Type annotations! `TypeName.annotated()` can attach annotations like `@Nullable` directly to\n@@ -63,7 +94,7 @@ JavaPoet 1.4.0 *(2015-11-13)*\n \n \n JavaPoet 1.3.0 *(2015-09-20)*\n-----------------------------\n+-----------------------------\n \n  * New: `NameAllocator` API makes it easy to declare non-conflicting names.\n  * New: Support annotations on enum values.\n@@ -73,7 +104,7 @@ JavaPoet 1.3.0 *(2015-09-20)*\n \n \n JavaPoet 1.2.0 *(2015-07-04)*\n-----------------------------\n+-----------------------------\n \n  * New: Arguments may have positional indexes like `$1T` and `$2N`. Indexes can be used to refer to\n    the same argument multiple times in a single format string.\n@@ -83,7 +114,7 @@ JavaPoet 1.2.0 *(2015-07-04)*\n \n \n JavaPoet 1.1.0 *(2015-05-25)*\n-----------------------------\n+-----------------------------\n \n  * New: Eager validation of argument types like `$T` and `$N`.\n  * New: `MethodSpec.varargs(boolean)` to generate varags methods.\n@@ -100,7 +131,7 @@ JavaPoet 1.1.0 *(2015-05-25)*\n  * Fix: Don't allow double field initialization.\n \n JavaPoet 1.0.0 *(2015-01-28)*\n-----------------------------\n+-----------------------------\n \n  * This update is a complete rewrite. The project name is now `javapoet`. We renamed the it so you\n    can simultaneously use the old JavaWriter API and our new builder-based APIs in one project.\n@@ -111,7 +142,7 @@ JavaPoet 1.0.0 *(2015-01-28)*\n \n \n JavaWriter 2.5.1 *(2014-12-03)*\n-----------------------------\n+-------------------------------\n \n  * New: `StringLiteral` type which encapsulates the behavior of `stringLiteral`.\n  * Fix: Use canonical name when emitting a class import.\n@@ -120,7 +151,7 @@ JavaWriter 2.5.1 *(2014-12-03)*\n \n \n JavaWriter 2.5.0 *(2014-04-18)*\n-----------------------------\n+-------------------------------\n \n  * New: Methods in interfaces will always have no body declaration.\n  * New: Control flow begin declaration now supports String format arguments.\n@@ -129,20 +160,20 @@ JavaWriter 2.5.0 *(2014-04-18)*\n \n \n JavaWriter 2.4.0 *(2014-01-10)*\n-----------------------------\n+-------------------------------\n \n  * New: Properly indent hanging lines in field initializers.\n  * New: `emitEnumValue` variant which exposes a boolean of whether the current value is the last.\n \n \n JavaWriter 2.3.1 *(2013-12-16)*\n-----------------------------\n+-------------------------------\n \n  * Fix: Properly handle subpackages of `java.lang` in `compressType`.\n \n \n JavaWriter 2.3.0 *(2013-11-24)*\n-----------------------------\n+-------------------------------\n \n  * New: Configurable indent level via `setIndent`.\n  * New: `beginConstructor` method is a semantically clearer alternative for constructors.\n@@ -152,31 +183,31 @@ JavaWriter 2.3.0 *(2013-11-24)*\n \n \n JavaWriter 2.2.1 *(2013-10-23)*\n-----------------------------\n+-------------------------------\n \n  * Fix: Do not emit trailing whitespace for empty Javadoc lines.\n \n \n JavaWriter 2.2.0 *(2013-09-25)*\n-----------------------------\n+-------------------------------\n \n  * `setCompressingTypes` controls whether types are emitted as fully-qualified or not.\n \n \n JavaWriter 2.1.2 *(2013-08-23)*\n-----------------------------\n+-------------------------------\n \n  * Attempt to keep annotations on a single line.\n \n \n JavaWriter 2.1.1 *(2013-07-23)*\n-----------------------------\n+-------------------------------\n \n  * Fix: `stringLiteral` now correctly handles escapes and control characters.\n \n \n JavaWriter 2.1.0 *(2013-07-15)*\n-----------------------------\n+-------------------------------\n \n  * New: All methods now take a `Set` of `Modifier`s rather than an `int`. The `int` methods are\n    now deprecated for removal in JavaPoet 1.0.\n@@ -184,50 +215,50 @@ JavaWriter 2.1.0 *(2013-07-15)*\n \n \n JavaWriter 2.0.1 *(2013-06-17)*\n-----------------------------\n+-------------------------------\n \n  * Correct casing of `emitSingleLineComment`.\n \n \n JavaWriter 2.0.0 *(2013-06-06)*\n-----------------------------\n+-------------------------------\n \n  * Package name is now `com.squareup.javawriter`.\n  * Support declaring `throws` clause on methods.\n \n \n JavaWriter 1.0.5 *(2013-05-08)*\n-----------------------------\n+-------------------------------\n \n  * Fix: Fully qualify types whose simple name matches an import.\n \n \n JavaWriter 1.0.4 *(2013-03-15)*\n-----------------------------\n+-------------------------------\n \n  * Fix: Static import emit now properly supports method imports.\n \n \n JavaWriter 1.0.3 *(2013-02-21)*\n------------------------------\n+-------------------------------\n \n  * Add support for emitting static imports.\n \n \n JavaWriter 1.0.2 *(2013-02-11)*\n-----------------------------\n+-------------------------------\n \n  * Add `type` API for helping build generic types.\n  * Minor performance improvements.\n \n \n JavaWriter 1.0.1 *(2013-02-03)*\n-----------------------------\n+-------------------------------\n \n  * Expose `compressType` API.\n \n \n JavaWriter 1.0.0 *(2013-02-01)*\n-----------------------------\n+-------------------------------\n \n Initial release.\n"
    },
    {
        "commit_hash": "70cbbc9e998fdd927e89fad23ef34ba417889f11",
        "previous_commit_hash": "a1db4599af61248bebc2e0582788c8a0a515232a",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -837,12 +837,12 @@ Download [the latest .jar][dl] or depend via Maven:\n <dependency>\n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.7.0</version>\n+  <version>1.8.0</version>\n </dependency>\n ```\n or Gradle:\n ```groovy\n-compile 'com.squareup:javapoet:1.7.0'\n+compile 'com.squareup:javapoet:1.8.0'\n ```\n \n Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].\n"
    },
    {
        "commit_hash": "46913cd91914f2b30f3730390c96b8143c260a46",
        "previous_commit_hash": "70cbbc9e998fdd927e89fad23ef34ba417889f11",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.8.0-SNAPSHOT</version>\n+  <version>1.8.0</version>\n \n   <name>JavaPoet</name>\n   <description>Use beautiful Java code to generate beautiful Java code.</description>\n"
    },
    {
        "commit_hash": "8ec1afab2fbe54daf9ea0e5b3d2f327192484c14",
        "previous_commit_hash": "46913cd91914f2b30f3730390c96b8143c260a46",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.8.0</version>\n+  <version>1.9.0-SNAPSHOT</version>\n \n   <name>JavaPoet</name>\n   <description>Use beautiful Java code to generate beautiful Java code.</description>\n"
    },
    {
        "commit_hash": "01f7076cabdeb4444bf0606b4c88daf93a436af4",
        "previous_commit_hash": "8ec1afab2fbe54daf9ea0e5b3d2f327192484c14",
        "diff_stats": {
            "additions": 10,
            "deletions": 4
        },
        "diff_content": "@@ -62,7 +62,7 @@ import static com.squareup.javapoet.Util.checkArgument;\n  */\n public final class CodeBlock {\n   private static final Pattern NAMED_ARGUMENT =\n-      Pattern.compile(\"\\\\$(?<argumentName>[\\\\w_]+):(?<typeChar>[\\\\w]).*\", Pattern.DOTALL);\n+      Pattern.compile(\"\\\\$(?<argumentName>[\\\\w_]+):(?<typeChar>[\\\\w]).*\");\n   private static final Pattern LOWERCASE = Pattern.compile(\"[a-z]+[\\\\w_]*\");\n \n   /** A heterogeneous list containing string literals and value placeholders. */\n@@ -151,15 +151,21 @@ public final class CodeBlock {\n           formatParts.add(format.substring(p, nextP));\n           p = nextP;\n         }\n-        Matcher matcher = NAMED_ARGUMENT.matcher(format.subSequence(p, format.length()));\n-        if (matcher.matches()) {\n+\n+        Matcher matcher = null;\n+        int colon = format.indexOf(':', p);\n+        if (colon != -1) {\n+          int endIndex = Math.min(colon + 2, format.length());\n+          matcher = NAMED_ARGUMENT.matcher(format.substring(p, endIndex));\n+        }\n+        if (matcher != null && matcher.lookingAt()) {\n           String argumentName = matcher.group(\"argumentName\");\n           checkArgument(arguments.containsKey(argumentName), \"Missing named argument for $%s\",\n               argumentName);\n           char formatChar = matcher.group(\"typeChar\").charAt(0);\n           addArgument(format, formatChar, arguments.get(argumentName));\n           formatParts.add(\"$\" + formatChar);\n-          p += matcher.regionStart() + argumentName.length() + 3;\n+          p += matcher.regionEnd();\n         } else {\n           checkArgument(p < format.length() - 1, \"dangling $ at end\");\n           checkArgument(isNoArgPlaceholder(format.charAt(p + 1)),\n"
    },
    {
        "commit_hash": "fa5c19032459214bbb241202e435cfd2f21bbf43",
        "previous_commit_hash": "8ec1afab2fbe54daf9ea0e5b3d2f327192484c14",
        "diff_stats": {
            "additions": 6,
            "deletions": 0
        },
        "diff_content": "@@ -23,6 +23,7 @@ import java.util.Collections;\n import java.util.Iterator;\n import java.util.LinkedHashSet;\n import java.util.List;\n+import java.util.Map;\n import java.util.Set;\n import javax.lang.model.SourceVersion;\n import javax.lang.model.element.ExecutableElement;\n@@ -406,6 +407,11 @@ public final class MethodSpec {\n       return this;\n     }\n \n+    public Builder addNamedCode(String format, Map<String, ?> args) {\n+      code.addNamed(format, args);\n+      return this;\n+    }\n+\n     public Builder addCode(CodeBlock codeBlock) {\n       code.add(codeBlock);\n       return this;\n"
    },
    {
        "commit_hash": "ff50d7b60ad15fed7ed294ca2295cb356cbc4273",
        "previous_commit_hash": "73214de9ab09c724b3cd507c71d9e6ef4b5625d9",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -320,7 +320,7 @@ MethodSpec beyond = MethodSpec.methodBuilder(\"beyond\")\n     .addStatement(\"result.add($T.createNimbus(\\\"2001\\\"))\", hoverboard)\n     .addStatement(\"result.add($T.createNimbus($T.THUNDERBOLT))\", hoverboard, namedBoards)\n     .addStatement(\"$T.sort(result)\", Collections.class)\n-    .addStatement(\"return result.isEmpty() $T.emptyList() : result\", Collections.class)\n+    .addStatement(\"return result.isEmpty() ? $T.emptyList() : result\", Collections.class)\n     .build();\n \n TypeSpec hello = TypeSpec.classBuilder(\"HelloWorld\")\n"
    },
    {
        "commit_hash": "ff50d7b60ad15fed7ed294ca2295cb356cbc4273",
        "previous_commit_hash": "73214de9ab09c724b3cd507c71d9e6ef4b5625d9",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -41,7 +41,7 @@ public final class JavaFileTest {\n         .addStatement(\"result.add($T.createNimbus(\\\"2001\\\"))\", hoverboard)\n         .addStatement(\"result.add($T.createNimbus($T.THUNDERBOLT))\", hoverboard, namedBoards)\n         .addStatement(\"$T.sort(result)\", Collections.class)\n-        .addStatement(\"return result.isEmpty() $T.emptyList() : result\", Collections.class)\n+        .addStatement(\"return result.isEmpty() ? $T.emptyList() : result\", Collections.class)\n         .build();\n     TypeSpec hello = TypeSpec.classBuilder(\"HelloWorld\")\n         .addMethod(beyond)\n@@ -69,7 +69,7 @@ public final class JavaFileTest {\n         + \"    result.add(createNimbus(\\\"2001\\\"));\\n\"\n         + \"    result.add(createNimbus(THUNDERBOLT));\\n\"\n         + \"    sort(result);\\n\"\n-        + \"    return result.isEmpty() emptyList() : result;\\n\"\n+        + \"    return result.isEmpty() ? emptyList() : result;\\n\"\n         + \"  }\\n\"\n         + \"}\\n\");\n   }\n"
    },
    {
        "commit_hash": "b66d3d543982755f1d2397066ac9ccbc5ba8c327",
        "previous_commit_hash": "ff50d7b60ad15fed7ed294ca2295cb356cbc4273",
        "diff_stats": {
            "additions": 3,
            "deletions": 1
        },
        "diff_content": "@@ -228,7 +228,9 @@ public final class CodeBlock {\n         if (indexStart < indexEnd) {\n           index = Integer.parseInt(format.substring(indexStart, indexEnd)) - 1;\n           hasIndexed = true;\n-          indexedParameterCount[index % args.length]++; // modulo is needed, checked below anyway\n+          if (args.length > 0) {\n+            indexedParameterCount[index % args.length]++; // modulo is needed, checked below anyway\n+          }\n         } else {\n           index = relativeParameterCount;\n           hasRelative = true;\n"
    },
    {
        "commit_hash": "b66d3d543982755f1d2397066ac9ccbc5ba8c327",
        "previous_commit_hash": "ff50d7b60ad15fed7ed294ca2295cb356cbc4273",
        "diff_stats": {
            "additions": 9,
            "deletions": 0
        },
        "diff_content": "@@ -226,6 +226,15 @@ public final class CodeBlockTest {\n     }\n   }\n \n+  @Test public void indexButNoArguments() {\n+    try {\n+      CodeBlock.builder().add(\"$1T\").build();\n+      fail();\n+    } catch (IllegalArgumentException expected) {\n+      assertThat(expected).hasMessage(\"index 1 for '$1T' not in range (received 0 arguments)\");\n+    }\n+  }\n+\n   @Test public void formatIndicatorAlone() {\n     try {\n       CodeBlock.builder().add(\"$\", String.class).build();\n"
    },
    {
        "commit_hash": "414da301b9d58f7cc169a70bb7e68fe71e02822c",
        "previous_commit_hash": "b66d3d543982755f1d2397066ac9ccbc5ba8c327",
        "diff_stats": {
            "additions": 2,
            "deletions": 0
        },
        "diff_content": "@@ -25,6 +25,7 @@ import org.junit.Test;\n \n import static com.google.common.truth.Truth.assertThat;\n import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertNotEquals;\n \n public class TypeNameTest {\n@@ -178,5 +179,6 @@ public class TypeNameTest {\n     assertEquals(a.toString(), b.toString());\n     assertThat(a.equals(b)).isTrue();\n     assertThat(a.hashCode()).isEqualTo(b.hashCode());\n+    assertFalse(a.equals(null));\n   }\n }\n"
    },
    {
        "commit_hash": "89263f0462e47be5bac0298247be985ad0f4027b",
        "previous_commit_hash": "1e70284811cf7e323e7ab6232c4a94e985c30689",
        "diff_stats": {
            "additions": 5,
            "deletions": 1
        },
        "diff_content": "@@ -1,9 +1,13 @@\n language: java\n \n jdk:\n-  - oraclejdk7\n   - oraclejdk8\n \n+addons:\n+  apt:\n+    packages:\n+      - oracle-java8-installer # Updates JDK 8 to the latest available.\n+\n after_success:\n   - .buildscript/deploy_snapshot.sh\n \n"
    },
    {
        "commit_hash": "89263f0462e47be5bac0298247be985ad0f4027b",
        "previous_commit_hash": "1e70284811cf7e323e7ab6232c4a94e985c30689",
        "diff_stats": {
            "additions": 15,
            "deletions": 1
        },
        "diff_content": "@@ -94,11 +94,25 @@\n       <plugin>\n         <groupId>org.apache.maven.plugins</groupId>\n         <artifactId>maven-compiler-plugin</artifactId>\n-        <version>3.0</version>\n+        <version>3.6.1</version>\n         <configuration>\n+          <compilerId>javac-with-errorprone</compilerId>\n+          <forceJavacCompilerUse>true</forceJavacCompilerUse>\n           <source>${java.version}</source>\n           <target>${java.version}</target>\n         </configuration>\n+        <dependencies>\n+          <dependency>\n+            <groupId>org.codehaus.plexus</groupId>\n+            <artifactId>plexus-compiler-javac-errorprone</artifactId>\n+            <version>2.8.1</version>\n+          </dependency>\n+          <dependency>\n+            <groupId>com.google.errorprone</groupId>\n+            <artifactId>error_prone_core</artifactId>\n+            <version>2.0.16</version>\n+          </dependency>\n+        </dependencies>\n       </plugin>\n \n       <plugin>\n"
    },
    {
        "commit_hash": "647b93bc63c3bc3a43310e00e80f1bd86a5a3963",
        "previous_commit_hash": "0d6bdebf124a0c0e2a52ef520231b64e98c77a64",
        "diff_stats": {
            "additions": 2,
            "deletions": 0
        },
        "diff_content": "@@ -281,6 +281,7 @@ public final class MethodSpec {\n     private CodeBlock defaultValue;\n \n     private Builder(String name) {\n+      checkNotNull(name, \"name == null\");\n       checkArgument(name.equals(CONSTRUCTOR) || SourceVersion.isName(name),\n           \"not a valid name: %s\", name);\n       this.name = name;\n@@ -320,6 +321,7 @@ public final class MethodSpec {\n     }\n \n     public Builder addModifiers(Modifier... modifiers) {\n+      checkNotNull(modifiers, \"modifiers == null\");\n       Collections.addAll(this.modifiers, modifiers);\n       return this;\n     }\n"
    },
    {
        "commit_hash": "647b93bc63c3bc3a43310e00e80f1bd86a5a3963",
        "previous_commit_hash": "0d6bdebf124a0c0e2a52ef520231b64e98c77a64",
        "diff_stats": {
            "additions": 18,
            "deletions": 0
        },
        "diff_content": "@@ -238,4 +238,22 @@ public final class MethodSpecTest {\n       .isEqualTo(Arrays.asList(ioException, timeoutException));\n   }\n \n+  @Test public void nullIsNotAValidMethodName() {\n+    try {\n+      MethodSpec.methodBuilder(null);\n+      fail(\"NullPointerException expected\");\n+    } catch (NullPointerException e) {\n+      assertThat(e.getMessage()).isEqualTo(\"name == null\");\n+    }\n+  }\n+\n+  @Test public void addModifiersVarargsShouldNotBeNull() {\n+    try {\n+      MethodSpec.methodBuilder(\"taco\")\n+              .addModifiers((Modifier[]) null);\n+      fail(\"NullPointerException expected\");\n+    } catch (NullPointerException e) {\n+      assertThat(e.getMessage()).isEqualTo(\"modifiers == null\");\n+    }\n+  }\n }\n"
    },
    {
        "commit_hash": "e11279525524d12f8eb4687b1f4e926d75bf1371",
        "previous_commit_hash": "647b93bc63c3bc3a43310e00e80f1bd86a5a3963",
        "diff_stats": {
            "additions": 4,
            "deletions": 1
        },
        "diff_content": "@@ -419,7 +419,10 @@ public final class TypeSpec {\n \n     public Builder addModifiers(Modifier... modifiers) {\n       checkState(anonymousTypeArguments == null, \"forbidden on anonymous types.\");\n-      Collections.addAll(this.modifiers, modifiers);\n+      for (Modifier modifier : modifiers) {\n+        checkArgument(modifier != null, \"modifiers contain null\");\n+        this.modifiers.add(modifier);\n+      }\n       return this;\n     }\n \n"
    },
    {
        "commit_hash": "e11279525524d12f8eb4687b1f4e926d75bf1371",
        "previous_commit_hash": "647b93bc63c3bc3a43310e00e80f1bd86a5a3963",
        "diff_stats": {
            "additions": 10,
            "deletions": 0
        },
        "diff_content": "@@ -1836,6 +1836,16 @@ public final class TypeSpecTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void nullModifiersAddition() {\n+    try {\n+      TypeSpec.classBuilder(\"Taco\").addModifiers((Modifier) null);\n+      fail();\n+    } catch(IllegalArgumentException expected) {\n+      assertThat(expected.getMessage())\n+          .isEqualTo(\"modifiers contain null\");\n+    }\n+  }\n+\n   @Test public void nullTypeVariablesAddition() {\n     try {\n       TypeSpec.classBuilder(\"Taco\").addTypeVariables(null);\n"
    },
    {
        "commit_hash": "48378f7b2b491e1b6fed8c0a4eb25f331b71a6b1",
        "previous_commit_hash": "e11279525524d12f8eb4687b1f4e926d75bf1371",
        "diff_stats": {
            "additions": 27,
            "deletions": 3
        },
        "diff_content": "@@ -1,9 +1,10 @@\n <?xml version=\"1.0\"?>\n <!DOCTYPE module PUBLIC\n-    \"-//Puppy Crawl//DTD Check Configuration 1.2//EN\"\n-    \"http://www.puppycrawl.com/dtds/configuration_1_2.dtd\">\n+    \"-//Puppy Crawl//DTD Check Configuration 1.3//EN\"\n+    \"http://www.puppycrawl.com/dtds/configuration_1_3.dtd\">\n \n <module name=\"Checker\">\n+  <module name=\"SuppressWarningsFilter\"/>\n   <module name=\"NewlineAtEndOfFile\"/>\n   <module name=\"FileLength\"/>\n   <module name=\"FileTabCharacter\"/>\n@@ -14,6 +15,18 @@\n     <property name=\"message\" value=\"Line has trailing spaces.\"/>\n   </module>\n \n+  <!-- Space after 'for' and 'if' -->\n+  <module name=\"RegexpSingleline\">\n+    <property name=\"format\" value=\"^\\s*(for|if)\\b[^ ]\"/>\n+    <property name=\"message\" value=\"Space needed before opening parenthesis.\"/>\n+  </module>\n+\n+  <!-- For each spacing -->\n+  <module name=\"RegexpSingleline\">\n+    <property name=\"format\" value=\"^\\s*for \\(.*?([^ ]:|:[^ ])\"/>\n+    <property name=\"message\" value=\"Space needed around ':' character.\"/>\n+  </module>\n+\n   <module name=\"TreeWalker\">\n     <property name=\"cacheFile\" value=\"${checkstyle.cache.file}\"/>\n \n@@ -71,7 +84,15 @@\n     <module name=\"ParenPad\"/>\n     <module name=\"TypecastParenPad\"/>\n     <module name=\"WhitespaceAfter\"/>\n-    <module name=\"WhitespaceAround\"/>\n+    <module name=\"WhitespaceAround\">\n+      <property name=\"tokens\"\n+          value=\"ASSIGN, BAND, BAND_ASSIGN, BOR, BOR_ASSIGN, BSR, BSR_ASSIGN, BXOR, BXOR_ASSIGN,\n+          COLON, DIV, DIV_ASSIGN, DO_WHILE, EQUAL, GE, GT, LAND, LCURLY, LE, LITERAL_CATCH,\n+          LITERAL_DO, LITERAL_ELSE, LITERAL_FINALLY, LITERAL_FOR, LITERAL_IF, LITERAL_RETURN,\n+          LITERAL_SWITCH, LITERAL_SYNCHRONIZED, LITERAL_TRY, LITERAL_WHILE, LOR, LT, MINUS,\n+          MINUS_ASSIGN, MOD, MOD_ASSIGN, NOT_EQUAL, PLUS, PLUS_ASSIGN, QUESTION, SL, SLIST,\n+          SL_ASSIGN, SR, SR_ASSIGN, STAR, STAR_ASSIGN, LITERAL_ASSERT, TYPE_EXTENSION_AND\"/>\n+    </module>\n \n \n     <!-- Modifier Checks                                    -->\n@@ -120,5 +141,8 @@\n     <!--module name=\"FinalParameters\"/-->\n     <module name=\"TodoComment\"/>\n     <module name=\"UpperEll\"/>\n+\n+    <!-- Make the @SuppressWarnings annotations available to Checkstyle -->\n+    <module name=\"SuppressWarningsHolder\"/>\n   </module>\n </module>\n"
    },
    {
        "commit_hash": "48378f7b2b491e1b6fed8c0a4eb25f331b71a6b1",
        "previous_commit_hash": "e11279525524d12f8eb4687b1f4e926d75bf1371",
        "diff_stats": {
            "additions": 7,
            "deletions": 0
        },
        "diff_content": "@@ -119,6 +119,13 @@\n         <groupId>org.apache.maven.plugins</groupId>\n         <artifactId>maven-checkstyle-plugin</artifactId>\n         <version>2.17</version>\n+        <dependencies>\n+          <dependency>\n+            <groupId>com.puppycrawl.tools</groupId>\n+            <artifactId>checkstyle</artifactId>\n+            <version>7.7</version>\n+          </dependency>\n+        </dependencies>\n         <configuration>\n           <failsOnError>true</failsOnError>\n           <configLocation>checkstyle.xml</configLocation>\n"
    },
    {
        "commit_hash": "40dfa0cf36d844ca733bef0d4a61e87c9339af2c",
        "previous_commit_hash": "48378f7b2b491e1b6fed8c0a4eb25f331b71a6b1",
        "diff_stats": {
            "additions": 5,
            "deletions": 1
        },
        "diff_content": "@@ -111,11 +111,15 @@ public final class TypeSpec {\n   }\n \n   public static Builder anonymousClassBuilder(String typeArgumentsFormat, Object... args) {\n-    return new Builder(Kind.CLASS, null, CodeBlock.builder()\n+    return anonymousClassBuilder(CodeBlock.builder()\n         .add(typeArgumentsFormat, args)\n         .build());\n   }\n \n+  public static Builder anonymousClassBuilder(CodeBlock typeArguments) {\n+    return new Builder(Kind.CLASS, null, typeArguments);\n+  }\n+\n   public static Builder annotationBuilder(String name) {\n     return new Builder(Kind.ANNOTATION, checkNotNull(name, \"name == null\"), null);\n   }\n"
    },
    {
        "commit_hash": "40dfa0cf36d844ca733bef0d4a61e87c9339af2c",
        "previous_commit_hash": "48378f7b2b491e1b6fed8c0a4eb25f331b71a6b1",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -127,7 +127,7 @@ public final class TypeSpecTest {\n     ParameterSpec thungParameter = ParameterSpec.builder(thungOfSuperFoo, \"thung\")\n         .addModifiers(Modifier.FINAL)\n         .build();\n-    TypeSpec aSimpleThung = TypeSpec.anonymousClassBuilder(\"$N\", thungParameter)\n+    TypeSpec aSimpleThung = TypeSpec.anonymousClassBuilder(CodeBlock.of(\"$N\", thungParameter))\n         .superclass(simpleThungOfBar)\n         .addMethod(MethodSpec.methodBuilder(\"doSomething\")\n             .addAnnotation(Override.class)\n"
    },
    {
        "commit_hash": "4cd975b9649ec87f9a71ce48916fba8d9d460e4e",
        "previous_commit_hash": "40dfa0cf36d844ca733bef0d4a61e87c9339af2c",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -68,7 +68,7 @@\n       <property name=\"max\" value=\"100\"/>\n     </module>\n     <module name=\"MethodLength\">\n-      <property name=\"max\" value=\"155\"/>\n+      <property name=\"max\" value=\"160\"/>\n     </module>\n     <module name=\"ParameterNumber\"/>\n \n"
    },
    {
        "commit_hash": "4cd975b9649ec87f9a71ce48916fba8d9d460e4e",
        "previous_commit_hash": "40dfa0cf36d844ca733bef0d4a61e87c9339af2c",
        "diff_stats": {
            "additions": 29,
            "deletions": 0
        },
        "diff_content": "@@ -82,6 +82,30 @@ public final class TypeSpec {\n     this.originatingElements = Util.immutableList(originatingElementsMutable);\n   }\n \n+  /**\n+   * Creates a dummy type spec for type-resolution only (in CodeWriter)\n+   * while emitting the type declaration but before entering the type body.\n+   */\n+  private TypeSpec(TypeSpec type) {\n+    assert type.anonymousTypeArguments == null;\n+    this.kind = type.kind;\n+    this.name = type.name;\n+    this.anonymousTypeArguments = null;\n+    this.javadoc = type.javadoc;\n+    this.annotations = Collections.emptyList();\n+    this.modifiers = Collections.emptySet();\n+    this.typeVariables = Collections.emptyList();\n+    this.superclass = null;\n+    this.superinterfaces = Collections.emptyList();\n+    this.enumConstants = Collections.emptyMap();\n+    this.fieldSpecs = Collections.emptyList();\n+    this.staticBlock = type.staticBlock;\n+    this.initializerBlock = type.initializerBlock;\n+    this.methodSpecs = Collections.emptyList();\n+    this.typeSpecs = Collections.emptyList();\n+    this.originatingElements = Collections.emptyList();\n+  }\n+\n   public boolean hasModifier(Modifier modifier) {\n     return modifiers.contains(modifier);\n   }\n@@ -172,6 +196,9 @@ public final class TypeSpec {\n         codeWriter.emit(anonymousTypeArguments);\n         codeWriter.emit(\") {\\n\");\n       } else {\n+        // Push an empty type (specifically without nested types) for type-resolution.\n+        codeWriter.pushType(new TypeSpec(this));\n+\n         codeWriter.emitJavadoc(javadoc);\n         codeWriter.emitAnnotations(annotations, false);\n         codeWriter.emitModifiers(modifiers, Util.union(implicitModifiers, kind.asMemberModifiers));\n@@ -214,6 +241,8 @@ public final class TypeSpec {\n           }\n         }\n \n+        codeWriter.popType();\n+\n         codeWriter.emit(\" {\\n\");\n       }\n \n"
    },
    {
        "commit_hash": "4cd975b9649ec87f9a71ce48916fba8d9d460e4e",
        "previous_commit_hash": "40dfa0cf36d844ca733bef0d4a61e87c9339af2c",
        "diff_stats": {
            "additions": 94,
            "deletions": 0
        },
        "diff_content": "@@ -465,6 +465,84 @@ public final class JavaFileTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void classAndSuperclassShareName() throws Exception {\n+    String source = JavaFile.builder(\"com.squareup.tacos\",\n+        TypeSpec.classBuilder(\"Taco\")\n+            .superclass(ClassName.get(\"com.taco.bell\", \"Taco\"))\n+            .build())\n+        .build()\n+        .toString();\n+    assertThat(source).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"class Taco extends com.taco.bell.Taco {\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void conflictingAnnotation() throws Exception {\n+    String source = JavaFile.builder(\"com.squareup.tacos\",\n+        TypeSpec.classBuilder(\"Taco\")\n+            .addAnnotation(ClassName.get(\"com.taco.bell\", \"Taco\"))\n+            .build())\n+        .build()\n+        .toString();\n+    assertThat(source).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"@com.taco.bell.Taco\\n\"\n+        + \"class Taco {\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void conflictingAnnotationReferencedClass() throws Exception {\n+    String source = JavaFile.builder(\"com.squareup.tacos\",\n+        TypeSpec.classBuilder(\"Taco\")\n+            .addAnnotation(AnnotationSpec.builder(ClassName.get(\"com.squareup.tacos\", \"MyAnno\"))\n+                .addMember(\"value\", \"$T.class\", ClassName.get(\"com.taco.bell\", \"Taco\"))\n+                .build())\n+            .build())\n+        .build()\n+        .toString();\n+    assertThat(source).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"@MyAnno(com.taco.bell.Taco.class)\\n\"\n+        + \"class Taco {\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void conflictingTypeVariableBound() throws Exception {\n+    String source = JavaFile.builder(\"com.squareup.tacos\",\n+        TypeSpec.classBuilder(\"Taco\")\n+            .addTypeVariable(\n+                TypeVariableName.get(\"T\", ClassName.get(\"com.taco.bell\", \"Taco\")))\n+            .build())\n+        .build()\n+        .toString();\n+    assertThat(source).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"class Taco<T extends com.taco.bell.Taco> {\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void superclassReferencesSelf() throws Exception {\n+    String source = JavaFile.builder(\"com.squareup.tacos\",\n+        TypeSpec.classBuilder(\"Taco\")\n+            .superclass(ParameterizedTypeName.get(\n+                ClassName.get(Comparable.class), ClassName.get(\"com.squareup.tacos\", \"Taco\")))\n+            .build())\n+        .build()\n+        .toString();\n+    assertThat(source).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import java.lang.Comparable;\\n\"\n+        + \"\\n\"\n+        + \"class Taco extends Comparable<Taco> {\\n\"\n+        + \"}\\n\");\n+  }\n+\n   /** https://github.com/square/javapoet/issues/366 */\n   @Test public void annotationIsNestedClass() throws Exception {\n     String source = JavaFile.builder(\"com.squareup.tacos\",\n@@ -573,4 +651,20 @@ public final class JavaFileTest {\n         + \"  }\\n\"\n         + \"}\\n\");\n   }\n+\n+  @Test public void packageClassConflictsWithSuperlass() throws Exception {\n+    String source = JavaFile.builder(\"com.squareup.tacos\",\n+        TypeSpec.classBuilder(\"Taco\")\n+            .superclass(ClassName.get(\"com.taco.bell\", \"A\"))\n+            .addField(ClassName.get(\"com.squareup.tacos\", \"A\"), \"a\")\n+            .build())\n+        .build()\n+        .toString();\n+    assertThat(source).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"class Taco extends com.taco.bell.A {\\n\"\n+        + \"  A a;\\n\"\n+        + \"}\\n\");\n+  }\n }\n"
    },
    {
        "commit_hash": "4cd975b9649ec87f9a71ce48916fba8d9d460e4e",
        "previous_commit_hash": "40dfa0cf36d844ca733bef0d4a61e87c9339af2c",
        "diff_stats": {
            "additions": 0,
            "deletions": 19
        },
        "diff_content": "@@ -625,25 +625,6 @@ public final class TypeSpecTest {\n         + \"}\\n\");\n   }\n \n-  @Test public void classImplementsExtendsSameName() throws Exception {\n-    ClassName javapoetTaco = ClassName.get(tacosPackage, \"Taco\");\n-    ClassName tacoBellTaco = ClassName.get(\"com.taco.bell\", \"Taco\");\n-    ClassName fishTaco = ClassName.get(\"org.fish.taco\", \"Taco\");\n-    TypeSpec typeSpec = TypeSpec.classBuilder(\"Taco\")\n-        .superclass(fishTaco)\n-        .addSuperinterface(ParameterizedTypeName.get(ClassName.get(Comparable.class), javapoetTaco))\n-        .addSuperinterface(tacoBellTaco)\n-        .build();\n-    assertThat(toString(typeSpec)).isEqualTo(\"\"\n-        + \"package com.squareup.tacos;\\n\"\n-        + \"\\n\"\n-        + \"import java.lang.Comparable;\\n\"\n-        + \"\\n\"\n-        + \"class Taco extends org.fish.taco.Taco \"\n-        + \"implements Comparable<Taco>, com.taco.bell.Taco {\\n\"\n-        + \"}\\n\");\n-  }\n-\n   @Test public void classImplementsNestedClass() throws Exception {\n     ClassName outer = ClassName.get(tacosPackage, \"Outer\");\n     ClassName inner = outer.nestedClass(\"Inner\");\n"
    },
    {
        "commit_hash": "ca12c7bafd2d7033f8cff7770ecf2260d45aa4ab",
        "previous_commit_hash": "4cd975b9649ec87f9a71ce48916fba8d9d460e4e",
        "diff_stats": {
            "additions": 12,
            "deletions": 3
        },
        "diff_content": "@@ -49,9 +49,9 @@ public final class ClassName extends TypeName implements Comparable<ClassName> {\n       checkArgument(SourceVersion.isName(names.get(i)), \"part '%s' is keyword\", names.get(i));\n     }\n     this.names = Util.immutableList(names);\n-    this.canonicalName = names.get(0).isEmpty()\n+    this.canonicalName = (names.get(0).isEmpty()\n         ? Util.join(\".\", names.subList(1, names.size()))\n-        : Util.join(\".\", names);\n+        : Util.join(\".\", names)).replace(\".$\", \"$\");\n   }\n \n   @Override public ClassName annotated(List<AnnotationSpec> annotations) {\n@@ -141,7 +141,16 @@ public final class ClassName extends TypeName implements Comparable<ClassName> {\n     checkArgument(!clazz.isArray(), \"array types cannot be represented as a ClassName\");\n     List<String> names = new ArrayList<>();\n     while (true) {\n-      names.add(clazz.getSimpleName());\n+      if (clazz.isAnonymousClass()) {\n+        int lastDot = clazz.getName().lastIndexOf('.');\n+        if (lastDot != -1) {\n+          String anonClassName = clazz.getName().substring(lastDot + 1);\n+          int lastDollar = anonClassName.lastIndexOf('$');\n+          names.add(anonClassName.substring(lastDollar));\n+        }\n+      } else {\n+        names.add(clazz.getSimpleName());\n+      }\n       Class<?> enclosing = clazz.getEnclosingClass();\n       if (enclosing == null) break;\n       clazz = enclosing;\n"
    },
    {
        "commit_hash": "ca12c7bafd2d7033f8cff7770ecf2260d45aa4ab",
        "previous_commit_hash": "4cd975b9649ec87f9a71ce48916fba8d9d460e4e",
        "diff_stats": {
            "additions": 2,
            "deletions": 0
        },
        "diff_content": "@@ -107,6 +107,8 @@ public final class ClassNameTest {\n         .isEqualTo(\"java.lang.Object\");\n     assertThat(ClassName.get(OuterClass.InnerClass.class).toString())\n         .isEqualTo(\"com.squareup.javapoet.ClassNameTest.OuterClass.InnerClass\");\n+    assertThat((ClassName.get(new Object() {}.getClass())).toString())\n+        .isEqualTo(\"com.squareup.javapoet.ClassNameTest$1\");\n   }\n \n   @Test public void peerClass() {\n"
    },
    {
        "commit_hash": "7931dbd83395806358269d02f827db852234dbda",
        "previous_commit_hash": "ca12c7bafd2d7033f8cff7770ecf2260d45aa4ab",
        "diff_stats": {
            "additions": 9,
            "deletions": 0
        },
        "diff_content": "@@ -1,6 +1,15 @@\n Change Log\n ==========\n \n+JavaPoet 1.9.0 *(2017-05-13)*\n+-----------------------------\n+\n+ * Fix: Don't emit incorrect code when the declared type's signature references another type with\n+   the same simple name.\n+ * Fix: Support anonymous inner classes in `ClassName.get()`.\n+ * New: `MethodSpec.Builder.addNamedCode()` and `TypeSpec.anonymousClassBuilder(CodeBlock)`.\n+\n+\n JavaPoet 1.8.0 *(2016-11-09)*\n -----------------------------\n \n"
    },
    {
        "commit_hash": "7931dbd83395806358269d02f827db852234dbda",
        "previous_commit_hash": "ca12c7bafd2d7033f8cff7770ecf2260d45aa4ab",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -837,12 +837,12 @@ Download [the latest .jar][dl] or depend via Maven:\n <dependency>\n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.8.0</version>\n+  <version>1.9.0</version>\n </dependency>\n ```\n or Gradle:\n ```groovy\n-compile 'com.squareup:javapoet:1.8.0'\n+compile 'com.squareup:javapoet:1.9.0'\n ```\n \n Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].\n"
    },
    {
        "commit_hash": "dfba6d7272931991e56b0d0ac4b969c17cd3f334",
        "previous_commit_hash": "7931dbd83395806358269d02f827db852234dbda",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.9.0-SNAPSHOT</version>\n+  <version>1.9.0</version>\n \n   <name>JavaPoet</name>\n   <description>Use beautiful Java code to generate beautiful Java code.</description>\n"
    },
    {
        "commit_hash": "5f3b345be9bd8364268d6460424ae8cf59d087f0",
        "previous_commit_hash": "dfba6d7272931991e56b0d0ac4b969c17cd3f334",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.9.0</version>\n+  <version>1.10.0-SNAPSHOT</version>\n \n   <name>JavaPoet</name>\n   <description>Use beautiful Java code to generate beautiful Java code.</description>\n"
    },
    {
        "commit_hash": "08c7148ab302a364517f993c0fda33b1dca7bfe6",
        "previous_commit_hash": "5f3b345be9bd8364268d6460424ae8cf59d087f0",
        "diff_stats": {
            "additions": 7,
            "deletions": 10
        },
        "diff_content": "@@ -51,7 +51,7 @@ public final class ClassName extends TypeName implements Comparable<ClassName> {\n     this.names = Util.immutableList(names);\n     this.canonicalName = (names.get(0).isEmpty()\n         ? Util.join(\".\", names.subList(1, names.size()))\n-        : Util.join(\".\", names)).replace(\".$\", \"$\");\n+        : Util.join(\".\", names));\n   }\n \n   @Override public ClassName annotated(List<AnnotationSpec> annotations) {\n@@ -141,16 +141,13 @@ public final class ClassName extends TypeName implements Comparable<ClassName> {\n     checkArgument(!clazz.isArray(), \"array types cannot be represented as a ClassName\");\n     List<String> names = new ArrayList<>();\n     while (true) {\n-      if (clazz.isAnonymousClass()) {\n-        int lastDot = clazz.getName().lastIndexOf('.');\n-        if (lastDot != -1) {\n-          String anonClassName = clazz.getName().substring(lastDot + 1);\n-          int lastDollar = anonClassName.lastIndexOf('$');\n-          names.add(anonClassName.substring(lastDollar));\n-        }\n-      } else {\n-        names.add(clazz.getSimpleName());\n+      String anonymousSuffix = \"\";\n+      while (clazz.isAnonymousClass()) {\n+        int lastDollar = clazz.getName().lastIndexOf('$');\n+        anonymousSuffix = clazz.getName().substring(lastDollar) + anonymousSuffix;\n+        clazz = clazz.getEnclosingClass();\n       }\n+      names.add(clazz.getSimpleName() + anonymousSuffix);\n       Class<?> enclosing = clazz.getEnclosingClass();\n       if (enclosing == null) break;\n       clazz = enclosing;\n"
    },
    {
        "commit_hash": "08c7148ab302a364517f993c0fda33b1dca7bfe6",
        "previous_commit_hash": "5f3b345be9bd8364268d6460424ae8cf59d087f0",
        "diff_stats": {
            "additions": 16,
            "deletions": 2
        },
        "diff_content": "@@ -96,10 +96,18 @@ public final class ClassNameTest {\n     assertThat(baz).isEqualTo(ClassName.get(\"com.example\", \"Foo\", \"Bar\", \"Baz\"));\n   }\n \n+  static class $Outer {\n+    static class $Inner {}\n+  }\n+\n   @Test public void classNameFromTypeElement() {\n     Elements elements = compilationRule.getElements();\n-    TypeElement element = elements.getTypeElement(Object.class.getCanonicalName());\n-    assertThat(ClassName.get(element).toString()).isEqualTo(\"java.lang.Object\");\n+    TypeElement object = elements.getTypeElement(Object.class.getCanonicalName());\n+    assertThat(ClassName.get(object).toString()).isEqualTo(\"java.lang.Object\");\n+    TypeElement outer = elements.getTypeElement($Outer.class.getCanonicalName());\n+    assertThat(ClassName.get(outer).toString()).isEqualTo(\"com.squareup.javapoet.ClassNameTest.$Outer\");\n+    TypeElement inner = elements.getTypeElement($Outer.$Inner.class.getCanonicalName());\n+    assertThat(ClassName.get(inner).toString()).isEqualTo(\"com.squareup.javapoet.ClassNameTest.$Outer.$Inner\");\n   }\n \n   @Test public void classNameFromClass() {\n@@ -109,6 +117,12 @@ public final class ClassNameTest {\n         .isEqualTo(\"com.squareup.javapoet.ClassNameTest.OuterClass.InnerClass\");\n     assertThat((ClassName.get(new Object() {}.getClass())).toString())\n         .isEqualTo(\"com.squareup.javapoet.ClassNameTest$1\");\n+    assertThat((ClassName.get(new Object() { Object inner = new Object() {}; }.inner.getClass())).toString())\n+        .isEqualTo(\"com.squareup.javapoet.ClassNameTest$2$1\");\n+    assertThat((ClassName.get($Outer.class)).toString())\n+        .isEqualTo(\"com.squareup.javapoet.ClassNameTest.$Outer\");\n+    assertThat((ClassName.get($Outer.$Inner.class)).toString())\n+        .isEqualTo(\"com.squareup.javapoet.ClassNameTest.$Outer.$Inner\");\n   }\n \n   @Test public void peerClass() {\n"
    },
    {
        "commit_hash": "a5694ac69113d815dd6588775dbccf22747f556b",
        "previous_commit_hash": "08c7148ab302a364517f993c0fda33b1dca7bfe6",
        "diff_stats": {
            "additions": 4,
            "deletions": 0
        },
        "diff_content": "@@ -357,6 +357,10 @@ public final class CodeBlock {\n       return this;\n     }\n \n+    public Builder addStatement(CodeBlock codeBlock) {\n+      return addStatement(\"$L\", codeBlock);\n+    }\n+\n     public Builder add(CodeBlock codeBlock) {\n       formatParts.addAll(codeBlock.formatParts);\n       args.addAll(codeBlock.args);\n"
    },
    {
        "commit_hash": "a5694ac69113d815dd6588775dbccf22747f556b",
        "previous_commit_hash": "08c7148ab302a364517f993c0fda33b1dca7bfe6",
        "diff_stats": {
            "additions": 5,
            "deletions": 0
        },
        "diff_content": "@@ -471,6 +471,11 @@ public final class MethodSpec {\n       return this;\n     }\n \n+    public Builder addStatement(CodeBlock codeBlock) {\n+      code.addStatement(codeBlock);\n+      return this;\n+    }\n+\n     public MethodSpec build() {\n       return new MethodSpec(this);\n     }\n"
    },
    {
        "commit_hash": "a5694ac69113d815dd6588775dbccf22747f556b",
        "previous_commit_hash": "08c7148ab302a364517f993c0fda33b1dca7bfe6",
        "diff_stats": {
            "additions": 6,
            "deletions": 0
        },
        "diff_content": "@@ -1453,6 +1453,12 @@ public final class TypeSpecTest {\n     assertThat(codeBlock.toString()).isEqualTo(\"java.lang.String s = \\\"taco\\\".substring(0, 3);\\n\");\n   }\n \n+  @Test public void codeBlockAddStatementOfCodeBlockToString() throws Exception {\n+    CodeBlock contents = CodeBlock.of(\"$T $N = $S.substring(0, 3)\", String.class, \"s\", \"taco\");\n+    CodeBlock statement = CodeBlock.builder().addStatement(contents).build();\n+    assertThat(statement.toString()).isEqualTo(\"java.lang.String s = \\\"taco\\\".substring(0, 3);\\n\");\n+  }\n+\n   @Test public void fieldToString() throws Exception {\n     FieldSpec field = FieldSpec.builder(String.class, \"s\", Modifier.FINAL)\n         .initializer(\"$S.substring(0, 3)\", \"taco\")\n"
    },
    {
        "commit_hash": "384395d53cccde5a93932dba78328a5888db7ee8",
        "previous_commit_hash": "a5694ac69113d815dd6588775dbccf22747f556b",
        "diff_stats": {
            "additions": 1,
            "deletions": 2
        },
        "diff_content": "@@ -16,7 +16,6 @@\n package com.squareup.javapoet;\n \n import java.io.IOException;\n-import java.io.StringWriter;\n import java.lang.annotation.Annotation;\n import java.lang.reflect.Array;\n import java.lang.reflect.Method;\n@@ -184,7 +183,7 @@ public final class AnnotationSpec {\n   }\n \n   @Override public String toString() {\n-    StringWriter out = new StringWriter();\n+    StringBuilder out = new StringBuilder();\n     try {\n       CodeWriter codeWriter = new CodeWriter(out);\n       codeWriter.emit(\"$L\", this);\n"
    },
    {
        "commit_hash": "384395d53cccde5a93932dba78328a5888db7ee8",
        "previous_commit_hash": "a5694ac69113d815dd6588775dbccf22747f556b",
        "diff_stats": {
            "additions": 1,
            "deletions": 2
        },
        "diff_content": "@@ -16,7 +16,6 @@\n package com.squareup.javapoet;\n \n import java.io.IOException;\n-import java.io.StringWriter;\n import java.lang.reflect.Type;\n import java.util.ArrayList;\n import java.util.List;\n@@ -90,7 +89,7 @@ public final class CodeBlock {\n   }\n \n   @Override public String toString() {\n-    StringWriter out = new StringWriter();\n+    StringBuilder out = new StringBuilder();\n     try {\n       new CodeWriter(out).emit(this);\n       return out.toString();\n"
    },
    {
        "commit_hash": "384395d53cccde5a93932dba78328a5888db7ee8",
        "previous_commit_hash": "a5694ac69113d815dd6588775dbccf22747f556b",
        "diff_stats": {
            "additions": 1,
            "deletions": 2
        },
        "diff_content": "@@ -16,7 +16,6 @@\n package com.squareup.javapoet;\n \n import java.io.IOException;\n-import java.io.StringWriter;\n import java.lang.reflect.Type;\n import java.util.ArrayList;\n import java.util.Collections;\n@@ -77,7 +76,7 @@ public final class FieldSpec {\n   }\n \n   @Override public String toString() {\n-    StringWriter out = new StringWriter();\n+    StringBuilder out = new StringBuilder();\n     try {\n       CodeWriter codeWriter = new CodeWriter(out);\n       emit(codeWriter, Collections.<Modifier>emptySet());\n"
    },
    {
        "commit_hash": "384395d53cccde5a93932dba78328a5888db7ee8",
        "previous_commit_hash": "a5694ac69113d815dd6588775dbccf22747f556b",
        "diff_stats": {
            "additions": 1,
            "deletions": 2
        },
        "diff_content": "@@ -16,7 +16,6 @@\n package com.squareup.javapoet;\n \n import java.io.IOException;\n-import java.io.StringWriter;\n import java.lang.reflect.Type;\n import java.util.ArrayList;\n import java.util.Collections;\n@@ -159,7 +158,7 @@ public final class MethodSpec {\n   }\n \n   @Override public String toString() {\n-    StringWriter out = new StringWriter();\n+    StringBuilder out = new StringBuilder();\n     try {\n       CodeWriter codeWriter = new CodeWriter(out);\n       emit(codeWriter, \"Constructor\", Collections.<Modifier>emptySet());\n"
    },
    {
        "commit_hash": "384395d53cccde5a93932dba78328a5888db7ee8",
        "previous_commit_hash": "a5694ac69113d815dd6588775dbccf22747f556b",
        "diff_stats": {
            "additions": 1,
            "deletions": 2
        },
        "diff_content": "@@ -16,7 +16,6 @@\n package com.squareup.javapoet;\n \n import java.io.IOException;\n-import java.io.StringWriter;\n import java.lang.reflect.Type;\n import java.util.ArrayList;\n import java.util.Collections;\n@@ -70,7 +69,7 @@ public final class ParameterSpec {\n   }\n \n   @Override public String toString() {\n-    StringWriter out = new StringWriter();\n+    StringBuilder out = new StringBuilder();\n     try {\n       CodeWriter codeWriter = new CodeWriter(out);\n       emit(codeWriter, false);\n"
    },
    {
        "commit_hash": "384395d53cccde5a93932dba78328a5888db7ee8",
        "previous_commit_hash": "a5694ac69113d815dd6588775dbccf22747f556b",
        "diff_stats": {
            "additions": 1,
            "deletions": 2
        },
        "diff_content": "@@ -16,7 +16,6 @@\n package com.squareup.javapoet;\n \n import java.io.IOException;\n-import java.io.StringWriter;\n import java.lang.reflect.Type;\n import java.util.ArrayList;\n import java.util.Arrays;\n@@ -341,7 +340,7 @@ public final class TypeSpec {\n   }\n \n   @Override public String toString() {\n-    StringWriter out = new StringWriter();\n+    StringBuilder out = new StringBuilder();\n     try {\n       CodeWriter codeWriter = new CodeWriter(out);\n       emit(codeWriter, null, Collections.<Modifier>emptySet());\n"
    },
    {
        "commit_hash": "f5b1b622d2d4141898bf850bd3cd54ee3d153aa4",
        "previous_commit_hash": "384395d53cccde5a93932dba78328a5888db7ee8",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -191,6 +191,7 @@ final class CodeWriter {\n     boolean firstTypeVariable = true;\n     for (TypeVariableName typeVariable : typeVariables) {\n       if (!firstTypeVariable) emit(\", \");\n+      emitAnnotations(typeVariable.annotations, true);\n       emit(\"$L\", typeVariable.name);\n       boolean firstBound = true;\n       for (TypeName bound : typeVariable.bounds) {\n"
    },
    {
        "commit_hash": "f5b1b622d2d4141898bf850bd3cd54ee3d153aa4",
        "previous_commit_hash": "384395d53cccde5a93932dba78328a5888db7ee8",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -597,7 +597,7 @@ public final class TypeSpecTest {\n         + \"import java.lang.Comparable;\\n\"\n         + \"import java.lang.Number;\\n\"\n         + \"\\n\"\n-        + \"class Location<P extends Number & Comparable, Q extends Number & Comparable> {\\n\"\n+        + \"class Location<P extends Number & Comparable, @A Q extends Number & Comparable> {\\n\"\n         + \"  P x;\\n\"\n         + \"\\n\"\n         + \"  @A Q y;\\n\"\n"
    },
    {
        "commit_hash": "03f3a276b2f330c59e549e73542217c6028caed6",
        "previous_commit_hash": "f5b1b622d2d4141898bf850bd3cd54ee3d153aa4",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -140,6 +140,19 @@\n           </execution>\n         </executions>\n       </plugin>\n+      \n+      <plugin>\n+        <groupId>org.apache.maven.plugins</groupId>\n+        <artifactId>maven-jar-plugin</artifactId>\n+        <configuration>\n+          <archive>\n+            <manifestEntries>\n+              <Automatic-Module-Name>com.squareup.javapoet</Automatic-Module-Name>\n+            </manifestEntries>\n+          </archive>\n+        </configuration>\n+      </plugin>\n+      \n     </plugins>\n   </build>\n </project>\n"
    },
    {
        "commit_hash": "681060898269d30ae29ac78f958be0ac91ffb7e3",
        "previous_commit_hash": "b5cc9f4554e41cf2eb4b99ab4c197948d90eb9bb",
        "diff_stats": {
            "additions": 10,
            "deletions": 9
        },
        "diff_content": "@@ -22,8 +22,8 @@\n \n     <java.version>1.7</java.version>\n     <junit.version>4.12</junit.version>\n-    <truth.version>0.28</truth.version>\n-    <compile-testing.version>0.9</compile-testing.version>\n+    <truth.version>0.39</truth.version>\n+    <compile-testing.version>0.15</compile-testing.version>\n   </properties>\n \n   <scm>\n@@ -72,19 +72,19 @@\n     <dependency>\n       <groupId>com.google.jimfs</groupId>\n       <artifactId>jimfs</artifactId>\n-      <version>1.0</version>\n+      <version>1.1</version>\n       <scope>test</scope>\n     </dependency>\n     <dependency>\n       <groupId>org.mockito</groupId>\n       <artifactId>mockito-core</artifactId>\n-      <version>1.10.16</version>\n+      <version>2.13.0</version>\n       <scope>test</scope>\n     </dependency>\n     <dependency>\n       <groupId>org.eclipse.jdt.core.compiler</groupId>\n       <artifactId>ecj</artifactId>\n-      <version>4.4.2</version>\n+      <version>4.6.1</version>\n       <scope>test</scope>\n     </dependency>\n   </dependencies>\n@@ -94,7 +94,7 @@\n       <plugin>\n         <groupId>org.apache.maven.plugins</groupId>\n         <artifactId>maven-compiler-plugin</artifactId>\n-        <version>3.6.1</version>\n+        <version>3.7.0</version>\n         <configuration>\n           <compilerId>javac-with-errorprone</compilerId>\n           <forceJavacCompilerUse>true</forceJavacCompilerUse>\n@@ -105,12 +105,12 @@\n           <dependency>\n             <groupId>org.codehaus.plexus</groupId>\n             <artifactId>plexus-compiler-javac-errorprone</artifactId>\n-            <version>2.8.1</version>\n+            <version>2.8.2</version>\n           </dependency>\n           <dependency>\n             <groupId>com.google.errorprone</groupId>\n             <artifactId>error_prone_core</artifactId>\n-            <version>2.0.16</version>\n+            <version>2.2.0</version>\n           </dependency>\n         </dependencies>\n       </plugin>\n@@ -123,7 +123,7 @@\n           <dependency>\n             <groupId>com.puppycrawl.tools</groupId>\n             <artifactId>checkstyle</artifactId>\n-            <version>7.7</version>\n+            <version>8.7</version>\n           </dependency>\n         </dependencies>\n         <configuration>\n@@ -144,6 +144,7 @@\n       <plugin>\n         <groupId>org.apache.maven.plugins</groupId>\n         <artifactId>maven-jar-plugin</artifactId>\n+        <version>3.0.2</version>\n         <configuration>\n           <archive>\n             <manifestEntries>\n"
    },
    {
        "commit_hash": "681060898269d30ae29ac78f958be0ac91ffb7e3",
        "previous_commit_hash": "b5cc9f4554e41cf2eb4b99ab4c197948d90eb9bb",
        "diff_stats": {
            "additions": 18,
            "deletions": 18
        },
        "diff_content": "@@ -44,7 +44,7 @@ public final class CodeBlockTest {\n       CodeBlock.builder().add(\"$1>\", \"taco\").build();\n       fail();\n     } catch (IllegalArgumentException exp) {\n-      assertThat(exp).hasMessage(\"$$, $>, $<, $[, $], and $W may not have an index\");\n+      assertThat(exp).hasMessageThat().isEqualTo(\"$$, $>, $<, $[, $], and $W may not have an index\");\n     }\n   }\n \n@@ -53,7 +53,7 @@ public final class CodeBlockTest {\n       CodeBlock.builder().add(\"$1<\", \"taco\").build();\n       fail();\n     } catch (IllegalArgumentException exp) {\n-      assertThat(exp).hasMessage(\"$$, $>, $<, $[, $], and $W may not have an index\");\n+      assertThat(exp).hasMessageThat().isEqualTo(\"$$, $>, $<, $[, $], and $W may not have an index\");\n     }\n   }\n \n@@ -62,7 +62,7 @@ public final class CodeBlockTest {\n       CodeBlock.builder().add(\"$1$\", \"taco\").build();\n       fail();\n     } catch (IllegalArgumentException exp) {\n-      assertThat(exp).hasMessage(\"$$, $>, $<, $[, $], and $W may not have an index\");\n+      assertThat(exp).hasMessageThat().isEqualTo(\"$$, $>, $<, $[, $], and $W may not have an index\");\n     }\n   }\n \n@@ -71,7 +71,7 @@ public final class CodeBlockTest {\n       CodeBlock.builder().add(\"$1[\", \"taco\").build();\n       fail();\n     } catch (IllegalArgumentException exp) {\n-      assertThat(exp).hasMessage(\"$$, $>, $<, $[, $], and $W may not have an index\");\n+      assertThat(exp).hasMessageThat().isEqualTo(\"$$, $>, $<, $[, $], and $W may not have an index\");\n     }\n   }\n \n@@ -80,7 +80,7 @@ public final class CodeBlockTest {\n       CodeBlock.builder().add(\"$1]\", \"taco\").build();\n       fail();\n     } catch (IllegalArgumentException exp) {\n-      assertThat(exp).hasMessage(\"$$, $>, $<, $[, $], and $W may not have an index\");\n+      assertThat(exp).hasMessageThat().isEqualTo(\"$$, $>, $<, $[, $], and $W may not have an index\");\n     }\n   }\n \n@@ -135,7 +135,7 @@ public final class CodeBlockTest {\n       CodeBlock.builder().addNamed(\"$text:S\", map).build();\n       fail();\n     } catch(IllegalArgumentException expected) {\n-      assertThat(expected).hasMessage(\"Missing named argument for $text\");\n+      assertThat(expected).hasMessageThat().isEqualTo(\"Missing named argument for $text\");\n     }\n   }\n \n@@ -146,7 +146,7 @@ public final class CodeBlockTest {\n       CodeBlock block = CodeBlock.builder().addNamed(\"$Text:S\", map).build();\n       fail();\n     } catch(IllegalArgumentException expected) {\n-      assertThat(expected).hasMessage(\"argument 'Text' must start with a lowercase character\");\n+      assertThat(expected).hasMessageThat().isEqualTo(\"argument 'Text' must start with a lowercase character\");\n     }\n   }\n \n@@ -177,7 +177,7 @@ public final class CodeBlockTest {\n       CodeBlock.builder().addNamed(\"$clazz:T$\", map).build();\n       fail();\n     } catch(IllegalArgumentException expected) {\n-      assertThat(expected).hasMessage(\"dangling $ at end\");\n+      assertThat(expected).hasMessageThat().isEqualTo(\"dangling $ at end\");\n     }\n   }\n \n@@ -186,7 +186,7 @@ public final class CodeBlockTest {\n       CodeBlock.builder().add(\"$2T\", String.class).build();\n       fail();\n     } catch (IllegalArgumentException expected) {\n-      assertThat(expected).hasMessage(\"index 2 for '$2T' not in range (received 1 arguments)\");\n+      assertThat(expected).hasMessageThat().isEqualTo(\"index 2 for '$2T' not in range (received 1 arguments)\");\n     }\n   }\n \n@@ -195,7 +195,7 @@ public final class CodeBlockTest {\n       CodeBlock.builder().add(\"$0T\", String.class).build();\n       fail();\n     } catch (IllegalArgumentException expected) {\n-      assertThat(expected).hasMessage(\"index 0 for '$0T' not in range (received 1 arguments)\");\n+      assertThat(expected).hasMessageThat().isEqualTo(\"index 0 for '$0T' not in range (received 1 arguments)\");\n     }\n   }\n \n@@ -204,7 +204,7 @@ public final class CodeBlockTest {\n       CodeBlock.builder().add(\"$-1T\", String.class).build();\n       fail();\n     } catch (IllegalArgumentException expected) {\n-      assertThat(expected).hasMessage(\"invalid format string: '$-1T'\");\n+      assertThat(expected).hasMessageThat().isEqualTo(\"invalid format string: '$-1T'\");\n     }\n   }\n \n@@ -213,7 +213,7 @@ public final class CodeBlockTest {\n       CodeBlock.builder().add(\"$1\", String.class).build();\n       fail();\n     } catch (IllegalArgumentException expected) {\n-      assertThat(expected).hasMessage(\"dangling format characters in '$1'\");\n+      assertThat(expected).hasMessageThat().isEqualTo(\"dangling format characters in '$1'\");\n     }\n   }\n \n@@ -222,7 +222,7 @@ public final class CodeBlockTest {\n       CodeBlock.builder().add(\"$1 taco\", String.class).build();\n       fail();\n     } catch (IllegalArgumentException expected) {\n-      assertThat(expected).hasMessage(\"invalid format string: '$1 taco'\");\n+      assertThat(expected).hasMessageThat().isEqualTo(\"invalid format string: '$1 taco'\");\n     }\n   }\n \n@@ -231,7 +231,7 @@ public final class CodeBlockTest {\n       CodeBlock.builder().add(\"$1T\").build();\n       fail();\n     } catch (IllegalArgumentException expected) {\n-      assertThat(expected).hasMessage(\"index 1 for '$1T' not in range (received 0 arguments)\");\n+      assertThat(expected).hasMessageThat().isEqualTo(\"index 1 for '$1T' not in range (received 0 arguments)\");\n     }\n   }\n \n@@ -240,7 +240,7 @@ public final class CodeBlockTest {\n       CodeBlock.builder().add(\"$\", String.class).build();\n       fail();\n     } catch (IllegalArgumentException expected) {\n-      assertThat(expected).hasMessage(\"dangling format characters in '$'\");\n+      assertThat(expected).hasMessageThat().isEqualTo(\"dangling format characters in '$'\");\n     }\n   }\n \n@@ -249,7 +249,7 @@ public final class CodeBlockTest {\n       CodeBlock.builder().add(\"$ tacoString\", String.class).build();\n       fail();\n     } catch (IllegalArgumentException expected) {\n-      assertThat(expected).hasMessage(\"invalid format string: '$ tacoString'\");\n+      assertThat(expected).hasMessageThat().isEqualTo(\"invalid format string: '$ tacoString'\");\n     }\n   }\n \n@@ -267,7 +267,7 @@ public final class CodeBlockTest {\n       codeBlock.toString();\n       fail();\n     } catch (IllegalStateException expected) {\n-      assertThat(expected).hasMessage(\"statement enter $[ followed by statement enter $[\");\n+      assertThat(expected).hasMessageThat().isEqualTo(\"statement enter $[ followed by statement enter $[\");\n     }\n   }\n \n@@ -278,7 +278,7 @@ public final class CodeBlockTest {\n       codeBlock.toString();\n       fail();\n     } catch (IllegalStateException expected) {\n-      assertThat(expected).hasMessage(\"statement exit $] has no matching statement enter $[\");\n+      assertThat(expected).hasMessageThat().isEqualTo(\"statement exit $] has no matching statement enter $[\");\n     }\n   }\n }\n"
    },
    {
        "commit_hash": "681060898269d30ae29ac78f958be0ac91ffb7e3",
        "previous_commit_hash": "b5cc9f4554e41cf2eb4b99ab4c197948d90eb9bb",
        "diff_stats": {
            "additions": 4,
            "deletions": 1
        },
        "diff_content": "@@ -113,7 +113,10 @@ public class FileReadingTest {\n     assertThat(diagnosticCollector.getDiagnostics()).isEmpty();\n \n     ClassLoader loader = fileManager.getClassLoader(StandardLocation.CLASS_OUTPUT);\n-    Callable<?> test = Class.forName(\"foo.Test\", true, loader).asSubclass(Callable.class).newInstance();\n+    Callable<?> test = Class.forName(\"foo.Test\", true, loader)\n+            .asSubclass(Callable.class)\n+            .getDeclaredConstructor()\n+            .newInstance();\n     assertThat(Callable.class.getMethod(\"call\").invoke(test)).isEqualTo(value);\n   }\n }\n"
    },
    {
        "commit_hash": "681060898269d30ae29ac78f958be0ac91ffb7e3",
        "previous_commit_hash": "b5cc9f4554e41cf2eb4b99ab4c197948d90eb9bb",
        "diff_stats": {
            "additions": 9,
            "deletions": 9
        },
        "diff_content": "@@ -74,7 +74,7 @@ public final class MethodSpecTest {\n       MethodSpec.methodBuilder(\"doSomething\").addAnnotations(null);\n       fail();\n     } catch (IllegalArgumentException expected) {\n-      assertThat(expected).hasMessage(\"annotationSpecs == null\");\n+      assertThat(expected).hasMessageThat().isEqualTo(\"annotationSpecs == null\");\n     }\n   }\n \n@@ -83,7 +83,7 @@ public final class MethodSpecTest {\n       MethodSpec.methodBuilder(\"doSomething\").addTypeVariables(null);\n       fail();\n     } catch (IllegalArgumentException expected) {\n-      assertThat(expected).hasMessage(\"typeVariables == null\");\n+      assertThat(expected).hasMessageThat().isEqualTo(\"typeVariables == null\");\n     }\n   }\n \n@@ -92,7 +92,7 @@ public final class MethodSpecTest {\n       MethodSpec.methodBuilder(\"doSomething\").addParameters(null);\n       fail();\n     } catch (IllegalArgumentException expected) {\n-      assertThat(expected).hasMessage(\"parameterSpecs == null\");\n+      assertThat(expected).hasMessageThat().isEqualTo(\"parameterSpecs == null\");\n     }\n   }\n \n@@ -101,7 +101,7 @@ public final class MethodSpecTest {\n       MethodSpec.methodBuilder(\"doSomething\").addExceptions(null);\n       fail();\n     } catch (IllegalArgumentException expected) {\n-      assertThat(expected).hasMessage(\"exceptions == null\");\n+      assertThat(expected).hasMessageThat().isEqualTo(\"exceptions == null\");\n     }\n   }\n \n@@ -118,7 +118,7 @@ public final class MethodSpecTest {\n     @Override public abstract String toString();\n   }\n \n-  interface ExtendsOthers extends Callable<Integer>, Comparable<Long> {\n+  interface ExtendsOthers extends Callable<Integer>, Comparable<ExtendsOthers> {\n   }\n   \n   interface ExtendsIterableWithDefaultMethods extends Iterable<Object> {\n@@ -175,7 +175,7 @@ public final class MethodSpecTest {\n     method = MethodSpec.overriding(exec, classType, types).build();\n     assertThat(method.toString()).isEqualTo(\"\"\n         + \"@java.lang.Override\\n\"\n-        + \"public int compareTo(java.lang.Long arg0) {\\n\"\n+        + \"public int compareTo(\" + ExtendsOthers.class.getCanonicalName() + \" arg0) {\\n\"\n         + \"}\\n\");\n   }\n \n@@ -189,21 +189,21 @@ public final class MethodSpecTest {\n       MethodSpec.overriding(method);\n       fail();\n     } catch (IllegalArgumentException expected) {\n-      assertThat(expected).hasMessage(\"cannot override method with modifiers: [final]\");\n+      assertThat(expected).hasMessageThat().isEqualTo(\"cannot override method with modifiers: [final]\");\n     }\n     when(method.getModifiers()).thenReturn(ImmutableSet.of(Modifier.PRIVATE));\n     try {\n       MethodSpec.overriding(method);\n       fail();\n     } catch (IllegalArgumentException expected) {\n-      assertThat(expected).hasMessage(\"cannot override method with modifiers: [private]\");\n+      assertThat(expected).hasMessageThat().isEqualTo(\"cannot override method with modifiers: [private]\");\n     }\n     when(method.getModifiers()).thenReturn(ImmutableSet.of(Modifier.STATIC));\n     try {\n       MethodSpec.overriding(method);\n       fail();\n     } catch (IllegalArgumentException expected) {\n-      assertThat(expected).hasMessage(\"cannot override method with modifiers: [static]\");\n+      assertThat(expected).hasMessageThat().isEqualTo(\"cannot override method with modifiers: [static]\");\n     }\n   }\n \n"
    },
    {
        "commit_hash": "681060898269d30ae29ac78f958be0ac91ffb7e3",
        "previous_commit_hash": "b5cc9f4554e41cf2eb4b99ab4c197948d90eb9bb",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -79,7 +79,7 @@ public final class NameAllocatorTest {\n       nameAllocator.newName(\"bar\", 1);\n       fail();\n     } catch (IllegalArgumentException expected) {\n-      assertThat(expected).hasMessage(\"tag 1 cannot be used for both 'foo' and 'bar'\");\n+      assertThat(expected).hasMessageThat().isEqualTo(\"tag 1 cannot be used for both 'foo' and 'bar'\");\n     }\n   }\n \n@@ -89,7 +89,7 @@ public final class NameAllocatorTest {\n       nameAllocator.get(1);\n       fail();\n     } catch (IllegalArgumentException expected) {\n-      assertThat(expected).hasMessage(\"unknown tag: 1\");\n+      assertThat(expected).hasMessageThat().isEqualTo(\"unknown tag: 1\");\n     }\n   }\n \n"
    },
    {
        "commit_hash": "681060898269d30ae29ac78f958be0ac91ffb7e3",
        "previous_commit_hash": "b5cc9f4554e41cf2eb4b99ab4c197948d90eb9bb",
        "diff_stats": {
            "additions": 7,
            "deletions": 7
        },
        "diff_content": "@@ -1979,7 +1979,7 @@ public final class TypeSpecTest {\n       CodeBlock.builder().add(\"$N\", String.class);\n       fail();\n     } catch (IllegalArgumentException expected) {\n-      assertThat(expected).hasMessage(\"expected name but was \" + String.class);\n+      assertThat(expected).hasMessageThat().isEqualTo(\"expected name but was \" + String.class);\n     }\n   }\n \n@@ -2020,7 +2020,7 @@ public final class TypeSpecTest {\n       CodeBlock.builder().add(\"$T\", \"java.lang.String\");\n       fail();\n     } catch (IllegalArgumentException expected) {\n-      assertThat(expected).hasMessage(\"expected type but was java.lang.String\");\n+      assertThat(expected).hasMessageThat().isEqualTo(\"expected type but was java.lang.String\");\n     }\n   }\n \n@@ -2029,7 +2029,7 @@ public final class TypeSpecTest {\n       CodeBlock.builder().add(\"$S\");\n       fail();\n     } catch (IllegalArgumentException expected) {\n-      assertThat(expected).hasMessage(\"index 1 for '$S' not in range (received 0 arguments)\");\n+      assertThat(expected).hasMessageThat().isEqualTo(\"index 1 for '$S' not in range (received 0 arguments)\");\n     }\n   }\n \n@@ -2038,7 +2038,7 @@ public final class TypeSpecTest {\n       CodeBlock.builder().add(\"$L $L\", \"a\", \"b\", \"c\");\n       fail();\n     } catch (IllegalArgumentException expected) {\n-      assertThat(expected).hasMessage(\"unused arguments: expected 2, received 3\");\n+      assertThat(expected).hasMessageThat().isEqualTo(\"unused arguments: expected 2, received 3\");\n     }\n   }\n \n@@ -2047,19 +2047,19 @@ public final class TypeSpecTest {\n       CodeBlock.builder().add(\"$1L $2L\", \"a\", \"b\", \"c\");\n       fail();\n     } catch (IllegalArgumentException expected) {\n-      assertThat(expected).hasMessage(\"unused argument: $3\");\n+      assertThat(expected).hasMessageThat().isEqualTo(\"unused argument: $3\");\n     }\n     try {\n       CodeBlock.builder().add(\"$1L $1L $1L\", \"a\", \"b\", \"c\");\n       fail();\n     } catch (IllegalArgumentException expected) {\n-      assertThat(expected).hasMessage(\"unused arguments: $2, $3\");\n+      assertThat(expected).hasMessageThat().isEqualTo(\"unused arguments: $2, $3\");\n     }\n     try {\n       CodeBlock.builder().add(\"$3L $1L $3L $1L $3L\", \"a\", \"b\", \"c\", \"d\");\n       fail();\n     } catch (IllegalArgumentException expected) {\n-      assertThat(expected).hasMessage(\"unused arguments: $2, $4\");\n+      assertThat(expected).hasMessageThat().isEqualTo(\"unused arguments: $2, $4\");\n     }\n   }\n \n"
    },
    {
        "commit_hash": "ca0e12e93e8ef9e1666573e4dc635064cb8d3ab1",
        "previous_commit_hash": "681060898269d30ae29ac78f958be0ac91ffb7e3",
        "diff_stats": {
            "additions": 4,
            "deletions": 2
        },
        "diff_content": "@@ -52,6 +52,7 @@ import static com.squareup.javapoet.Util.checkArgument;\n  *   <li>{@code $$} emits a dollar sign.\n  *   <li>{@code $W} emits a space or a newline, depending on its position on the line. This prefers\n  *       to wrap lines before 100 columns.\n+ *   <li>{@code $Z} acts as a zero-width space. This prefers to wrap lines before 100 columns.\n  *   <li>{@code $>} increases the indentation level.\n  *   <li>{@code $<} decreases the indentation level.\n  *   <li>{@code $[} begins a statement. For multiline statements, every line after the first line\n@@ -217,7 +218,8 @@ public final class CodeBlock {\n \n         // If 'c' doesn't take an argument, we're done.\n         if (isNoArgPlaceholder(c)) {\n-          checkArgument(indexStart == indexEnd, \"$$, $>, $<, $[, $], and $W may not have an index\");\n+          checkArgument(\n+              indexStart == indexEnd, \"$$, $>, $<, $[, $], $W, and $Z may not have an index\");\n           formatParts.add(\"$\" + c);\n           continue;\n         }\n@@ -264,7 +266,7 @@ public final class CodeBlock {\n     }\n \n     private boolean isNoArgPlaceholder(char c) {\n-      return c == '$' || c == '>' || c == '<' || c == '[' || c == ']' || c == 'W';\n+      return c == '$' || c == '>' || c == '<' || c == '[' || c == ']' || c == 'W' || c == 'Z';\n     }\n \n     private void addArgument(String format, char c, Object arg) {\n"
    },
    {
        "commit_hash": "ca0e12e93e8ef9e1666573e4dc635064cb8d3ab1",
        "previous_commit_hash": "681060898269d30ae29ac78f958be0ac91ffb7e3",
        "diff_stats": {
            "additions": 4,
            "deletions": 0
        },
        "diff_content": "@@ -283,6 +283,10 @@ final class CodeWriter {\n           out.wrappingSpace(indentLevel + 2);\n           break;\n \n+        case \"$Z\":\n+          out.zeroWidthSpace(indentLevel + 2);\n+          break;\n+\n         default:\n           // handle deferred type\n           if (deferredTypeName != null) {\n"
    },
    {
        "commit_hash": "ca0e12e93e8ef9e1666573e4dc635064cb8d3ab1",
        "previous_commit_hash": "681060898269d30ae29ac78f958be0ac91ffb7e3",
        "diff_stats": {
            "additions": 48,
            "deletions": 16
        },
        "diff_content": "@@ -35,9 +35,16 @@ final class LineWrapper {\n   /** The number of characters since the most recent newline. Includes both out and the buffer. */\n   private int column = 0;\n \n-  /** -1 if we have no buffering; otherwise the number of spaces to write after wrapping. */\n+  /**\n+   * -1 if we have no buffering; otherwise the number of {@code indent}s to write after wrapping.\n+   */\n   private int indentLevel = -1;\n \n+  /** {@code null} if we have no buffering; otherwise the type to pass to the next call to {@link\n+   * #flush(FlushType)}.\n+   */\n+  private FlushType nextFlush;\n+\n   LineWrapper(Appendable out, String indent, int columnLimit) {\n     checkNotNull(out, \"out == null\");\n     this.out = out;\n@@ -49,7 +56,7 @@ final class LineWrapper {\n   void append(String s) throws IOException {\n     if (closed) throw new IllegalStateException(\"closed\");\n \n-    if (indentLevel != -1) {\n+    if (nextFlush != null) {\n       int nextNewline = s.indexOf('\\n');\n \n       // If s doesn't cause the current line to cross the limit, buffer it and return. We'll decide\n@@ -62,7 +69,7 @@ final class LineWrapper {\n \n       // Wrap if appending s would overflow the current line.\n       boolean wrap = nextNewline == -1 || column + nextNewline > columnLimit;\n-      flush(wrap);\n+      flush(wrap ? FlushType.WRAP : nextFlush);\n     }\n \n     out.append(s);\n@@ -76,31 +83,56 @@ final class LineWrapper {\n   void wrappingSpace(int indentLevel) throws IOException {\n     if (closed) throw new IllegalStateException(\"closed\");\n \n-    if (this.indentLevel != -1) flush(false);\n-    this.column++;\n+    if (this.nextFlush != null) flush(nextFlush);\n+    column++; // increment the column even though the space is deferred to next call to flush()\n+    this.nextFlush = FlushType.SPACE;\n+    this.indentLevel = indentLevel;\n+  }\n+\n+  /** Emit a newline character if the line will exceed it's limit, otherwise do nothing. */\n+  void zeroWidthSpace(int indentLevel) throws IOException {\n+    if (closed) throw new IllegalStateException(\"closed\");\n+\n+    // DO NOT SUBMIT: multiple zero-width chars in a row - should that cause a flush?\n+    // What about if the nextFlush is a SPACE?\n+    if (this.nextFlush != null) flush(nextFlush);\n+    this.nextFlush = FlushType.EMPTY;\n     this.indentLevel = indentLevel;\n   }\n \n   /** Flush any outstanding text and forbid future writes to this line wrapper. */\n   void close() throws IOException {\n-    if (indentLevel != -1) flush(false);\n+    if (nextFlush != null) flush(nextFlush);\n     closed = true;\n   }\n \n   /** Write the space followed by any buffered text that follows it. */\n-  private void flush(boolean wrap) throws IOException {\n-    if (wrap) {\n-      out.append('\\n');\n-      for (int i = 0; i < indentLevel; i++) {\n-        out.append(indent);\n-      }\n-      column = indentLevel * indent.length();\n-      column += buffer.length();\n-    } else {\n-      out.append(' ');\n+  private void flush(FlushType flushType) throws IOException {\n+    switch (flushType) {\n+      case WRAP:\n+        out.append('\\n');\n+        for (int i = 0; i < indentLevel; i++) {\n+          out.append(indent);\n+        }\n+        column = indentLevel * indent.length();\n+        column += buffer.length();\n+        break;\n+      case SPACE:\n+        out.append(' ');\n+        break;\n+      case EMPTY:\n+        break;\n+      default:\n+        throw new IllegalArgumentException(\"Unknown FlushType: \" + flushType);\n     }\n+\n     out.append(buffer);\n     buffer.delete(0, buffer.length());\n     indentLevel = -1;\n+    nextFlush = null;\n+  }\n+\n+  private enum FlushType {\n+    WRAP, SPACE, EMPTY;\n   }\n }\n"
    },
    {
        "commit_hash": "ca0e12e93e8ef9e1666573e4dc635064cb8d3ab1",
        "previous_commit_hash": "681060898269d30ae29ac78f958be0ac91ffb7e3",
        "diff_stats": {
            "additions": 15,
            "deletions": 5
        },
        "diff_content": "@@ -44,7 +44,9 @@ public final class CodeBlockTest {\n       CodeBlock.builder().add(\"$1>\", \"taco\").build();\n       fail();\n     } catch (IllegalArgumentException exp) {\n-      assertThat(exp).hasMessageThat().isEqualTo(\"$$, $>, $<, $[, $], and $W may not have an index\");\n+      assertThat(exp)\n+          .hasMessageThat()\n+          .isEqualTo(\"$$, $>, $<, $[, $], $W, and $Z may not have an index\");\n     }\n   }\n \n@@ -53,7 +55,9 @@ public final class CodeBlockTest {\n       CodeBlock.builder().add(\"$1<\", \"taco\").build();\n       fail();\n     } catch (IllegalArgumentException exp) {\n-      assertThat(exp).hasMessageThat().isEqualTo(\"$$, $>, $<, $[, $], and $W may not have an index\");\n+      assertThat(exp)\n+          .hasMessageThat()\n+          .isEqualTo(\"$$, $>, $<, $[, $], $W, and $Z may not have an index\");\n     }\n   }\n \n@@ -62,7 +66,9 @@ public final class CodeBlockTest {\n       CodeBlock.builder().add(\"$1$\", \"taco\").build();\n       fail();\n     } catch (IllegalArgumentException exp) {\n-      assertThat(exp).hasMessageThat().isEqualTo(\"$$, $>, $<, $[, $], and $W may not have an index\");\n+      assertThat(exp)\n+          .hasMessageThat()\n+          .isEqualTo(\"$$, $>, $<, $[, $], $W, and $Z may not have an index\");\n     }\n   }\n \n@@ -71,7 +77,9 @@ public final class CodeBlockTest {\n       CodeBlock.builder().add(\"$1[\", \"taco\").build();\n       fail();\n     } catch (IllegalArgumentException exp) {\n-      assertThat(exp).hasMessageThat().isEqualTo(\"$$, $>, $<, $[, $], and $W may not have an index\");\n+      assertThat(exp)\n+          .hasMessageThat()\n+          .isEqualTo(\"$$, $>, $<, $[, $], $W, and $Z may not have an index\");\n     }\n   }\n \n@@ -80,7 +88,9 @@ public final class CodeBlockTest {\n       CodeBlock.builder().add(\"$1]\", \"taco\").build();\n       fail();\n     } catch (IllegalArgumentException exp) {\n-      assertThat(exp).hasMessageThat().isEqualTo(\"$$, $>, $<, $[, $], and $W may not have an index\");\n+      assertThat(exp)\n+          .hasMessageThat()\n+          .isEqualTo(\"$$, $>, $<, $[, $], $W, and $Z may not have an index\");\n     }\n   }\n \n"
    },
    {
        "commit_hash": "ca0e12e93e8ef9e1666573e4dc635064cb8d3ab1",
        "previous_commit_hash": "681060898269d30ae29ac78f958be0ac91ffb7e3",
        "diff_stats": {
            "additions": 67,
            "deletions": 0
        },
        "diff_content": "@@ -43,6 +43,26 @@ public final class LineWrapperTest {\n     assertThat(out.toString()).isEqualTo(\"abcde fghi\");\n   }\n \n+  @Test public void zeroWidthNoWrap() throws Exception {\n+    StringBuffer out = new StringBuffer();\n+    LineWrapper lineWrapper = new LineWrapper(out, \"  \", 10);\n+    lineWrapper.append(\"abcde\");\n+    lineWrapper.zeroWidthSpace(2);\n+    lineWrapper.append(\"fghij\");\n+    lineWrapper.close();\n+    assertThat(out.toString()).isEqualTo(\"abcdefghij\");\n+  }\n+\n+  @Test public void nospaceWrapMax() throws Exception {\n+    StringBuffer out = new StringBuffer();\n+    LineWrapper lineWrapper = new LineWrapper(out, \"  \", 10);\n+    lineWrapper.append(\"abcde\");\n+    lineWrapper.zeroWidthSpace(2);\n+    lineWrapper.append(\"fghijk\");\n+    lineWrapper.close();\n+    assertThat(out.toString()).isEqualTo(\"abcde\\n    fghijk\");\n+  }\n+\n   @Test public void multipleWrite() throws Exception {\n     StringBuffer out = new StringBuffer();\n     LineWrapper lineWrapper = new LineWrapper(out, \"  \", 10);\n@@ -79,6 +99,18 @@ public final class LineWrapperTest {\n     assertThat(out.toString()).isEqualTo(\"abcdefghij\\n    klmnop\");\n   }\n \n+  @Test public void fencepostZeroWidth() throws Exception {\n+    StringBuffer out = new StringBuffer();\n+    LineWrapper lineWrapper = new LineWrapper(out, \"  \", 10);\n+    lineWrapper.append(\"abcde\");\n+    lineWrapper.append(\"fghij\");\n+    lineWrapper.zeroWidthSpace(2);\n+    lineWrapper.append(\"k\");\n+    lineWrapper.append(\"lmnop\");\n+    lineWrapper.close();\n+    assertThat(out.toString()).isEqualTo(\"abcdefghij\\n    klmnop\");\n+  }\n+\n   @Test public void overlyLongLinesWithoutLeadingSpace() throws Exception {\n     StringBuffer out = new StringBuffer();\n     LineWrapper lineWrapper = new LineWrapper(out, \"  \", 10);\n@@ -96,6 +128,19 @@ public final class LineWrapperTest {\n     assertThat(out.toString()).isEqualTo(\"\\n    abcdefghijkl\");\n   }\n \n+  @org.junit.Ignore\n+  @Test public void overlyLongLinesWithLeadingZeroWidth() throws Exception {\n+    StringBuffer out = new StringBuffer();\n+    LineWrapper lineWrapper = new LineWrapper(out, \"  \", 10);\n+    lineWrapper.zeroWidthSpace(2);\n+    lineWrapper.append(\"abcdefghijkl\");\n+    lineWrapper.close();\n+    // DO NOT SUBMIT: what should the functionality here be? if we don't want a newline, we can check:\n+    // if (column == 0) return;\n+    // before the check+call to flush()\n+    assertThat(out.toString()).isEqualTo(\"abcdefghijkl\");\n+  }\n+\n   @Test public void noWrapEmbeddedNewlines() throws Exception {\n     StringBuffer out = new StringBuffer();\n     LineWrapper lineWrapper = new LineWrapper(out, \"  \", 10);\n@@ -118,6 +163,28 @@ public final class LineWrapperTest {\n     assertThat(out.toString()).isEqualTo(\"abcde\\n    fghij\\nklmnopqrstuvwxy\");\n   }\n \n+  @Test public void noWrapEmbeddedNewlines_ZeroWidth() throws Exception {\n+    StringBuffer out = new StringBuffer();\n+    LineWrapper lineWrapper = new LineWrapper(out, \"  \", 10);\n+    lineWrapper.append(\"abcde\");\n+    lineWrapper.zeroWidthSpace(2);\n+    lineWrapper.append(\"fghij\\nklmn\");\n+    lineWrapper.append(\"opqrstuvwxyz\");\n+    lineWrapper.close();\n+    assertThat(out.toString()).isEqualTo(\"abcdefghij\\nklmnopqrstuvwxyz\");\n+  }\n+\n+  @Test public void wrapEmbeddedNewlines_ZeroWidth() throws Exception {\n+    StringBuffer out = new StringBuffer();\n+    LineWrapper lineWrapper = new LineWrapper(out, \"  \", 10);\n+    lineWrapper.append(\"abcde\");\n+    lineWrapper.zeroWidthSpace(2);\n+    lineWrapper.append(\"fghijk\\nlmn\");\n+    lineWrapper.append(\"opqrstuvwxy\");\n+    lineWrapper.close();\n+    assertThat(out.toString()).isEqualTo(\"abcde\\n    fghijk\\nlmnopqrstuvwxy\");\n+  }\n+\n   @Test public void noWrapMultipleNewlines() throws Exception {\n     StringBuffer out = new StringBuffer();\n     LineWrapper lineWrapper = new LineWrapper(out, \"  \", 10);\n"
    },
    {
        "commit_hash": "ca0e12e93e8ef9e1666573e4dc635064cb8d3ab1",
        "previous_commit_hash": "681060898269d30ae29ac78f958be0ac91ffb7e3",
        "diff_stats": {
            "additions": 22,
            "deletions": 0
        },
        "diff_content": "@@ -2294,6 +2294,28 @@ public final class TypeSpecTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void lineWrappingWithZeroWidthSpace() {\n+    MethodSpec method = MethodSpec.methodBuilder(\"call\")\n+        .addCode(\"$[iAmSickOfWaitingInLine($Z\")\n+        .addCode(\"it, has, been, far, too, long, of, a, wait, and, i, would, like, to, eat, \")\n+        .addCode(\"this, is, a, run, on, sentence\")\n+        .addCode(\");$]\\n\")\n+        .build();\n+\n+    TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n+        .addMethod(method)\n+        .build();\n+    assertThat(toString(taco)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"class Taco {\\n\"\n+        + \"  void call() {\\n\"\n+        + \"    iAmSickOfWaitingInLine(\\n\"\n+        + \"        it, has, been, far, too, long, of, a, wait, and, i, would, like, to, eat, this, is, a, run, on, sentence);\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n   @Test public void equalsAndHashCode() {\n     TypeSpec a = TypeSpec.interfaceBuilder(\"taco\").build();\n     TypeSpec b = TypeSpec.interfaceBuilder(\"taco\").build();\n"
    },
    {
        "commit_hash": "563cf74b4d699c4d63219cc33e9c095f73d8fbec",
        "previous_commit_hash": "ca0e12e93e8ef9e1666573e4dc635064cb8d3ab1",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -20,7 +20,7 @@\n   <properties>\n     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n \n-    <java.version>1.7</java.version>\n+    <java.version>1.8</java.version>\n     <junit.version>4.12</junit.version>\n     <truth.version>0.39</truth.version>\n     <compile-testing.version>0.15</compile-testing.version>\n"
    },
    {
        "commit_hash": "563cf74b4d699c4d63219cc33e9c095f73d8fbec",
        "previous_commit_hash": "ca0e12e93e8ef9e1666573e4dc635064cb8d3ab1",
        "diff_stats": {
            "additions": 75,
            "deletions": 0
        },
        "diff_content": "@@ -22,6 +22,8 @@ import java.util.List;\n import java.util.Map;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n+import java.util.stream.Collector;\n+import java.util.stream.StreamSupport;\n import javax.lang.model.element.Element;\n import javax.lang.model.type.TypeMirror;\n \n@@ -103,6 +105,46 @@ public final class CodeBlock {\n     return new Builder().add(format, args).build();\n   }\n \n+  /**\n+   * Joins {@code codeBlocks} into a single {@link CodeBlock}, each separated by {@code separator}.\n+   * For example, joining {@code String s}, {@code Object o} and {@code int i} using {@code \", \"}\n+   * would produce {@code String s, Object o, int i}.\n+   */\n+  public static CodeBlock join(Iterable<CodeBlock> codeBlocks, String separator) {\n+    return StreamSupport.stream(codeBlocks.spliterator(), false).collect(joining(separator));\n+  }\n+\n+  /**\n+   * A {@link Collector} implementation that joins {@link CodeBlock} instances together into one\n+   * separated by {@code separator}. For example, joining {@code String s}, {@code Object o} and\n+   * {@code int i} using {@code \", \"} would produce {@code String s, Object o, int i}.\n+   */\n+  public static Collector<CodeBlock, ?, CodeBlock> joining(String separator) {\n+    return Collector.of(\n+        () -> new CodeBlockJoiner(separator, builder()),\n+        CodeBlockJoiner::add,\n+        CodeBlockJoiner::merge,\n+        CodeBlockJoiner::join);\n+  }\n+\n+  /**\n+   * A {@link Collector} implementation that joins {@link CodeBlock} instances together into one\n+   * separated by {@code separator}. For example, joining {@code String s}, {@code Object o} and\n+   * {@code int i} using {@code \", \"} would produce {@code String s, Object o, int i}.\n+   */\n+  public static Collector<CodeBlock, ?, CodeBlock> joining(\n+      String separator, String prefix, String suffix) {\n+    Builder builder = builder().add(\"$N\", prefix);\n+    return Collector.of(\n+        () -> new CodeBlockJoiner(separator, builder),\n+        CodeBlockJoiner::add,\n+        CodeBlockJoiner::merge,\n+        joiner -> {\n+            builder.add(CodeBlock.of(\"$N\", suffix));\n+            return joiner.join();\n+        });\n+  }\n+\n   public static Builder builder() {\n     return new Builder();\n   }\n@@ -382,4 +424,37 @@ public final class CodeBlock {\n       return new CodeBlock(this);\n     }\n   }\n+\n+  private static final class CodeBlockJoiner {\n+    private final String delimiter;\n+    private final Builder builder;\n+    private boolean first = true;\n+\n+    CodeBlockJoiner(String delimiter, Builder builder) {\n+      this.delimiter = delimiter;\n+      this.builder = builder;\n+    }\n+\n+    CodeBlockJoiner add(CodeBlock codeBlock) {\n+      if (!first) {\n+        builder.add(delimiter);\n+      }\n+      first = false;\n+\n+      builder.add(codeBlock);\n+      return this;\n+    }\n+\n+    CodeBlockJoiner merge(CodeBlockJoiner other) {\n+      CodeBlock otherBlock = other.builder.build();\n+      if (!otherBlock.isEmpty()) {\n+        add(otherBlock);\n+      }\n+      return this;\n+    }\n+\n+    CodeBlock join() {\n+      return builder.build();\n+    }\n+  }\n }\n"
    },
    {
        "commit_hash": "563cf74b4d699c4d63219cc33e9c095f73d8fbec",
        "previous_commit_hash": "ca0e12e93e8ef9e1666573e4dc635064cb8d3ab1",
        "diff_stats": {
            "additions": 40,
            "deletions": 0
        },
        "diff_content": "@@ -15,7 +15,9 @@\n  */\n package com.squareup.javapoet;\n \n+import java.util.ArrayList;\n import java.util.LinkedHashMap;\n+import java.util.List;\n import java.util.Map;\n import org.junit.Test;\n \n@@ -291,4 +293,42 @@ public final class CodeBlockTest {\n       assertThat(expected).hasMessageThat().isEqualTo(\"statement exit $] has no matching statement enter $[\");\n     }\n   }\n+\n+  @Test public void join() {\n+    List<CodeBlock> codeBlocks = new ArrayList<>();\n+    codeBlocks.add(CodeBlock.of(\"$S\", \"hello\"));\n+    codeBlocks.add(CodeBlock.of(\"$T\", ClassName.get(\"world\", \"World\")));\n+    codeBlocks.add(CodeBlock.of(\"need tacos\"));\n+\n+    CodeBlock joined = CodeBlock.join(codeBlocks, \" || \");\n+    assertThat(joined.toString()).isEqualTo(\"\\\"hello\\\" || world.World || need tacos\");\n+  }\n+\n+  @Test public void joining() {\n+    List<CodeBlock> codeBlocks = new ArrayList<>();\n+    codeBlocks.add(CodeBlock.of(\"$S\", \"hello\"));\n+    codeBlocks.add(CodeBlock.of(\"$T\", ClassName.get(\"world\", \"World\")));\n+    codeBlocks.add(CodeBlock.of(\"need tacos\"));\n+\n+    CodeBlock joined = codeBlocks.stream().collect(CodeBlock.joining(\" || \"));\n+    assertThat(joined.toString()).isEqualTo(\"\\\"hello\\\" || world.World || need tacos\");\n+  }\n+\n+  @Test public void joiningSingle() {\n+    List<CodeBlock> codeBlocks = new ArrayList<>();\n+    codeBlocks.add(CodeBlock.of(\"$S\", \"hello\"));\n+\n+    CodeBlock joined = codeBlocks.stream().collect(CodeBlock.joining(\" || \"));\n+    assertThat(joined.toString()).isEqualTo(\"\\\"hello\\\"\");\n+  }\n+\n+  @Test public void joiningWithPrefixAndSuffix() {\n+    List<CodeBlock> codeBlocks = new ArrayList<>();\n+    codeBlocks.add(CodeBlock.of(\"$S\", \"hello\"));\n+    codeBlocks.add(CodeBlock.of(\"$T\", ClassName.get(\"world\", \"World\")));\n+    codeBlocks.add(CodeBlock.of(\"need tacos\"));\n+\n+    CodeBlock joined = codeBlocks.stream().collect(CodeBlock.joining(\" || \", \"start {\", \"} end\"));\n+    assertThat(joined.toString()).isEqualTo(\"start {\\\"hello\\\" || world.World || need tacos} end\");\n+  }\n }\n"
    },
    {
        "commit_hash": "6865d07a5ef86d2c4a04966633378cdc3340d902",
        "previous_commit_hash": "563cf74b4d699c4d63219cc33e9c095f73d8fbec",
        "diff_stats": {
            "additions": 4,
            "deletions": 0
        },
        "diff_content": "@@ -163,6 +163,10 @@ public final class CodeBlock {\n     private Builder() {\n     }\n \n+    public boolean isEmpty() {\n+      return formatParts.isEmpty();\n+    }\n+\n     /**\n      * Adds code using named arguments.\n      *\n"
    },
    {
        "commit_hash": "6865d07a5ef86d2c4a04966633378cdc3340d902",
        "previous_commit_hash": "563cf74b4d699c4d63219cc33e9c095f73d8fbec",
        "diff_stats": {
            "additions": 8,
            "deletions": 0
        },
        "diff_content": "@@ -22,6 +22,8 @@ import java.util.Map;\n import org.junit.Test;\n \n import static com.google.common.truth.Truth.assertThat;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n import static org.junit.Assert.fail;\n \n public final class CodeBlockTest {\n@@ -41,6 +43,12 @@ public final class CodeBlockTest {\n     assertThat(a.toString()).isEqualTo(\"delicious taco\");\n   }\n \n+  @Test public void isEmpty() {\n+    assertTrue(CodeBlock.builder().isEmpty());\n+    assertTrue(CodeBlock.builder().add(\"\").isEmpty());\n+    assertFalse(CodeBlock.builder().add(\" \").isEmpty());\n+  }\n+\n   @Test public void indentCannotBeIndexed() {\n     try {\n       CodeBlock.builder().add(\"$1>\", \"taco\").build();\n"
    },
    {
        "commit_hash": "870ece8e7caecc417a9cdee820642cfceab90592",
        "previous_commit_hash": "6865d07a5ef86d2c4a04966633378cdc3340d902",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -58,7 +58,7 @@ public final class ClassName extends TypeName implements Comparable<ClassName> {\n     return new ClassName(names, concatAnnotations(annotations));\n   }\n \n-  @Override public TypeName withoutAnnotations() {\n+  @Override public ClassName withoutAnnotations() {\n     return new ClassName(names);\n   }\n \n"
    },
    {
        "commit_hash": "870ece8e7caecc417a9cdee820642cfceab90592",
        "previous_commit_hash": "6865d07a5ef86d2c4a04966633378cdc3340d902",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -364,7 +364,7 @@ final class CodeWriter {\n       ClassName resolved = resolve(c.simpleName());\n       nameResolved = resolved != null;\n \n-      if (Objects.equals(resolved, c)) {\n+      if (resolved != null && Objects.equals(resolved.canonicalName, c.canonicalName)) {\n         int suffixOffset = c.simpleNames().size() - 1;\n         return join(\".\", className.simpleNames().subList(\n             suffixOffset, className.simpleNames().size()));\n"
    },
    {
        "commit_hash": "870ece8e7caecc417a9cdee820642cfceab90592",
        "previous_commit_hash": "6865d07a5ef86d2c4a04966633378cdc3340d902",
        "diff_stats": {
            "additions": 22,
            "deletions": 0
        },
        "diff_content": "@@ -17,6 +17,7 @@ package com.squareup.javapoet;\n \n import java.util.Collections;\n import java.util.Date;\n+import java.util.List;\n import java.util.concurrent.TimeUnit;\n import javax.lang.model.element.Modifier;\n import org.junit.Ignore;\n@@ -290,6 +291,27 @@ public final class JavaFileTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void annotatedTypeParam() throws Exception {\n+    String source = JavaFile.builder(\"com.squareup.tacos\",\n+        TypeSpec.classBuilder(\"Taco\")\n+            .addField(ParameterizedTypeName.get(ClassName.get(List.class),\n+                ClassName.get(\"com.squareup.meat\", \"Chorizo\")\n+                    .annotated(AnnotationSpec.builder(ClassName.get(\"com.squareup.tacos\", \"Spicy\"))\n+                        .build())), \"chorizo\")\n+            .build())\n+        .build()\n+        .toString();\n+    assertThat(source).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import com.squareup.meat.Chorizo;\\n\"\n+        + \"import java.util.List;\\n\"\n+        + \"\\n\"\n+        + \"class Taco {\\n\"\n+        + \"  List<@Spicy Chorizo> chorizo;\\n\"\n+        + \"}\\n\");\n+  }\n+\n   @Test public void skipJavaLangImportsWithConflictingClassLast() throws Exception {\n     // Whatever is used first wins! In this case the Float in java.lang is imported.\n     String source = JavaFile.builder(\"com.squareup.tacos\",\n"
    },
    {
        "commit_hash": "9e62955dc41e331f14b00e9f7d16dabff45884b0",
        "previous_commit_hash": "da2859b67f9098ac5c1c12aa64218c7e2dc1e63f",
        "diff_stats": {
            "additions": 12,
            "deletions": 0
        },
        "diff_content": "@@ -1,6 +1,18 @@\n Change Log\n ==========\n \n+JavaPoet 1.10.0 *(2018-01-27)*\n+-----------------------------\n+\n+ * New: `$Z` as an optional newline (zero-width space) if a line may exceed 100 chars.\n+ * New: `CodeBlock.join()` and `CodeBlock.joining()` let you join codeblocks by delimiters.\n+ * New: Add `CodeBlock.Builder.isEmpty()`.\n+ * New: `addStatement(CodeBlock)` overloads for `CodeBlock` and `MethodSpec`.\n+ * Fix: Include annotations when emitting type variables.\n+ * Fix: Use the right imports for annotated type parameters.\n+ * Fix: Don't incorrectly escape classnames that start with `$`.\n+\n+\n JavaPoet 1.9.0 *(2017-05-13)*\n -----------------------------\n \n"
    },
    {
        "commit_hash": "c6dd69cb207812493ca7675ea7a9abe64c2f4f98",
        "previous_commit_hash": "9e62955dc41e331f14b00e9f7d16dabff45884b0",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -140,7 +140,7 @@\n           </execution>\n         </executions>\n       </plugin>\n-      \n+\n       <plugin>\n         <groupId>org.apache.maven.plugins</groupId>\n         <artifactId>maven-jar-plugin</artifactId>\n@@ -153,7 +153,7 @@\n           </archive>\n         </configuration>\n       </plugin>\n-      \n+\n     </plugins>\n   </build>\n </project>\n"
    },
    {
        "commit_hash": "c6dd69cb207812493ca7675ea7a9abe64c2f4f98",
        "previous_commit_hash": "9e62955dc41e331f14b00e9f7d16dabff45884b0",
        "diff_stats": {
            "additions": 3,
            "deletions": 5
        },
        "diff_content": "@@ -40,8 +40,8 @@ final class LineWrapper {\n    */\n   private int indentLevel = -1;\n \n-  /** {@code null} if we have no buffering; otherwise the type to pass to the next call to {@link\n-   * #flush(FlushType)}.\n+  /**\n+   * Null if we have no buffering; otherwise the type to pass to the next call to {@link #flush}.\n    */\n   private FlushType nextFlush;\n \n@@ -84,7 +84,7 @@ final class LineWrapper {\n     if (closed) throw new IllegalStateException(\"closed\");\n \n     if (this.nextFlush != null) flush(nextFlush);\n-    column++; // increment the column even though the space is deferred to next call to flush()\n+    column++; // Increment the column even though the space is deferred to next call to flush().\n     this.nextFlush = FlushType.SPACE;\n     this.indentLevel = indentLevel;\n   }\n@@ -93,8 +93,6 @@ final class LineWrapper {\n   void zeroWidthSpace(int indentLevel) throws IOException {\n     if (closed) throw new IllegalStateException(\"closed\");\n \n-    // DO NOT SUBMIT: multiple zero-width chars in a row - should that cause a flush?\n-    // What about if the nextFlush is a SPACE?\n     if (this.nextFlush != null) flush(nextFlush);\n     this.nextFlush = FlushType.EMPTY;\n     this.indentLevel = indentLevel;\n"
    },
    {
        "commit_hash": "c6dd69cb207812493ca7675ea7a9abe64c2f4f98",
        "previous_commit_hash": "9e62955dc41e331f14b00e9f7d16dabff45884b0",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -91,9 +91,9 @@ public final class MethodSpec {\n     }\n \n     if (isConstructor()) {\n-      codeWriter.emit(\"$L(\", enclosingName);\n+      codeWriter.emit(\"$L($Z\", enclosingName);\n     } else {\n-      codeWriter.emit(\"$T $L(\", returnType, name);\n+      codeWriter.emit(\"$T $L($Z\", returnType, name);\n     }\n \n     boolean firstParameter = true;\n"
    },
    {
        "commit_hash": "c6dd69cb207812493ca7675ea7a9abe64c2f4f98",
        "previous_commit_hash": "9e62955dc41e331f14b00e9f7d16dabff45884b0",
        "diff_stats": {
            "additions": 4,
            "deletions": 4
        },
        "diff_content": "@@ -120,7 +120,7 @@ public final class MethodSpecTest {\n \n   interface ExtendsOthers extends Callable<Integer>, Comparable<ExtendsOthers> {\n   }\n-  \n+\n   interface ExtendsIterableWithDefaultMethods extends Iterable<Object> {\n   }\n \n@@ -131,9 +131,9 @@ public final class MethodSpecTest {\n     assertThat(method.toString()).isEqualTo(\"\"\n         + \"@java.lang.Override\\n\"\n         + \"protected <T extends java.lang.Runnable & java.io.Closeable> java.lang.Runnable \"\n-        + \"everything(java.lang.String arg0,\\n\"\n-        + \"    java.util.List<? extends T> arg1) throws java.io.IOException, \"\n-        + \"java.lang.SecurityException {\\n\"\n+        + \"everything(\\n\"\n+        + \"    java.lang.String arg0, java.util.List<? extends T> arg1) throws java.io.IOException,\\n\"\n+        + \"    java.lang.SecurityException {\\n\"\n         + \"}\\n\");\n   }\n \n"
    },
    {
        "commit_hash": "a2f21df8124e71c5ee55614919b86bb1e3879a55",
        "previous_commit_hash": "c6dd69cb207812493ca7675ea7a9abe64c2f4f98",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.10.0-SNAPSHOT</version>\n+  <version>1.10.0</version>\n \n   <name>JavaPoet</name>\n   <description>Use beautiful Java code to generate beautiful Java code.</description>\n"
    },
    {
        "commit_hash": "29f38bfd14e7cbd83b87d94c91a874da0782c737",
        "previous_commit_hash": "a2f21df8124e71c5ee55614919b86bb1e3879a55",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.10.0</version>\n+  <version>1.11.0-SNAPSHOT</version>\n \n   <name>JavaPoet</name>\n   <description>Use beautiful Java code to generate beautiful Java code.</description>\n"
    },
    {
        "commit_hash": "1ea76b466fdbd513a60fc3cc4178d78f30d0487a",
        "previous_commit_hash": "29f38bfd14e7cbd83b87d94c91a874da0782c737",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -837,12 +837,12 @@ Download [the latest .jar][dl] or depend via Maven:\n <dependency>\n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.9.0</version>\n+  <version>1.10.0</version>\n </dependency>\n ```\n or Gradle:\n ```groovy\n-compile 'com.squareup:javapoet:1.9.0'\n+compile 'com.squareup:javapoet:1.10.0'\n ```\n \n Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].\n"
    },
    {
        "commit_hash": "5dafdcb421fafc36a9db53c3106d7f183e23ea58",
        "previous_commit_hash": "b68e867d44e3a24e2d954fec83ce8a5170a4a03b",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -93,6 +93,7 @@ final class LineWrapper {\n   void zeroWidthSpace(int indentLevel) throws IOException {\n     if (closed) throw new IllegalStateException(\"closed\");\n \n+    if (column == 0) return;\n     if (this.nextFlush != null) flush(nextFlush);\n     this.nextFlush = FlushType.EMPTY;\n     this.indentLevel = indentLevel;\n"
    },
    {
        "commit_hash": "5dafdcb421fafc36a9db53c3106d7f183e23ea58",
        "previous_commit_hash": "b68e867d44e3a24e2d954fec83ce8a5170a4a03b",
        "diff_stats": {
            "additions": 0,
            "deletions": 4
        },
        "diff_content": "@@ -128,16 +128,12 @@ public final class LineWrapperTest {\n     assertThat(out.toString()).isEqualTo(\"\\n    abcdefghijkl\");\n   }\n \n-  @org.junit.Ignore\n   @Test public void overlyLongLinesWithLeadingZeroWidth() throws Exception {\n     StringBuffer out = new StringBuffer();\n     LineWrapper lineWrapper = new LineWrapper(out, \"  \", 10);\n     lineWrapper.zeroWidthSpace(2);\n     lineWrapper.append(\"abcdefghijkl\");\n     lineWrapper.close();\n-    // DO NOT SUBMIT: what should the functionality here be? if we don't want a newline, we can check:\n-    // if (column == 0) return;\n-    // before the check+call to flush()\n     assertThat(out.toString()).isEqualTo(\"abcdefghijkl\");\n   }\n \n"
    },
    {
        "commit_hash": "abaa7f083b308e2e6efedd97739f0ae3e57079ce",
        "previous_commit_hash": "5dafdcb421fafc36a9db53c3106d7f183e23ea58",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -116,7 +116,7 @@ final class CodeWriter {\n   }\n \n   public CodeWriter popPackage() {\n-    checkState(this.packageName != NO_PACKAGE, \"package already set: %s\", this.packageName);\n+    checkState(this.packageName != NO_PACKAGE, \"package not set\");\n     this.packageName = NO_PACKAGE;\n     return this;\n   }\n"
    },
    {
        "commit_hash": "d509342092ce1bd7755066b041dee2fe0f25bd23",
        "previous_commit_hash": "abaa7f083b308e2e6efedd97739f0ae3e57079ce",
        "diff_stats": {
            "additions": 43,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,43 @@\n+#!/bin/bash\n+#\n+# Install JDK from \"download.java.net\"\n+#\n+# Adapted from https://github.com/sormuras/bach/blob/master/install-jdk.sh\n+#\n+\n+set -e\n+\n+JDK_FEATURE='10'\n+\n+TMP=$(curl -L jdk.java.net/${JDK_FEATURE})\n+TMP=\"${TMP#*Most recent build: jdk-${JDK_FEATURE}-ea+}\" # remove everything before the number\n+TMP=\"${TMP%%<*}\"                                        # remove everything after the number\n+JDK_BUILD=\"$(echo -e \"${TMP}\" | tr -d '[:space:]')\"     # remove all whitespace\n+\n+JDK_LICENSE='GPL'\n+\n+while getopts F:B:L: option\n+do\n+ case \"${option}\"\n+ in\n+ F) JDK_FEATURE=${OPTARG};;\n+ B) JDK_BUILD=${OPTARG};;\n+ L) JDK_LICENSE=${OPTARG};;\n+ esac\n+done\n+\n+JDK_BASENAME='jdk'\n+if [ \"${JDK_LICENSE}\" == 'GPL' ]; then\n+  JDK_BASENAME='openjdk'\n+fi\n+\n+JDK_ARCHIVE=${JDK_BASENAME}-${JDK_FEATURE}-ea+${JDK_BUILD}_linux-x64_bin.tar.gz\n+\n+cd ~\n+wget http://download.java.net/java/jdk${JDK_FEATURE}/archive/${JDK_BUILD}/${JDK_LICENSE}/${JDK_ARCHIVE}\n+tar -xzf ${JDK_ARCHIVE}\n+export JAVA_HOME=~/jdk-${JDK_FEATURE}\n+export PATH=${JAVA_HOME}/bin:$PATH\n+cd -\n+\n+java --version\n"
    },
    {
        "commit_hash": "d509342092ce1bd7755066b041dee2fe0f25bd23",
        "previous_commit_hash": "abaa7f083b308e2e6efedd97739f0ae3e57079ce",
        "diff_stats": {
            "additions": 10,
            "deletions": 7
        },
        "diff_content": "@@ -1,12 +1,15 @@\n language: java\n \n-jdk:\n-  - oraclejdk8\n-\n-addons:\n-  apt:\n-    packages:\n-      - oracle-java8-installer # Updates JDK 8 to the latest available.\n+matrix:\n+  include:\n+    - env: JDK='OracleJDK 8'\n+      jdk: oraclejdk8\n+    - env: JDK='OracleJDK 9'\n+      jdk: oraclejdk9\n+    - env: JDK='OracleJDK 10'\n+      install: . ./.buildscript/install-jdk.sh -F 10 -L BCL\n+    - env: JDK='OpenJDK 10'\n+      install: . ./.buildscript/install-jdk.sh -F 10 -L GPL\n \n after_success:\n   - .buildscript/deploy_snapshot.sh\n"
    },
    {
        "commit_hash": "a4966ff80be8a1535fedf7313231161c3fdf46c1",
        "previous_commit_hash": "d509342092ce1bd7755066b041dee2fe0f25bd23",
        "diff_stats": {
            "additions": 2,
            "deletions": 1
        },
        "diff_content": "@@ -634,6 +634,7 @@ TypeSpec helloWorld = TypeSpec.enumBuilder(\"Roshambo\")\n             .addAnnotation(Override.class)\n             .addModifiers(Modifier.PUBLIC)\n             .addStatement(\"return $S\", \"avalanche!\")\n+            .returns(String.class)\n             .build())\n         .build())\n     .addEnumConstant(\"SCISSORS\", TypeSpec.anonymousClassBuilder(\"$S\", \"peace\")\n@@ -654,7 +655,7 @@ Which generates this:\n public enum Roshambo {\n   ROCK(\"fist\") {\n     @Override\n-    public void toString() {\n+    public String toString() {\n       return \"avalanche!\";\n     }\n   },\n"
    },
    {
        "commit_hash": "e6bc3b1d2b5db5f35214f7665ed9f96c6b6fe377",
        "previous_commit_hash": "b7176d095acc9eb39b132c52c2282a932a9578d1",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -4,6 +4,7 @@ Change Log\n JavaPoet 1.10.0 *(2018-01-27)*\n -----------------------------\n \n+ * **JavaPoet now requires Java 8 or newer.**\n  * New: `$Z` as an optional newline (zero-width space) if a line may exceed 100 chars.\n  * New: `CodeBlock.join()` and `CodeBlock.joining()` let you join codeblocks by delimiters.\n  * New: Add `CodeBlock.Builder.isEmpty()`.\n"
    },
    {
        "commit_hash": "0091cc5b8f172b4eca8dae95f82e060b0d203795",
        "previous_commit_hash": "e6bc3b1d2b5db5f35214f7665ed9f96c6b6fe377",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -10,7 +10,7 @@ set -e\n JDK_FEATURE='10'\n \n TMP=$(curl -L jdk.java.net/${JDK_FEATURE})\n-TMP=\"${TMP#*Most recent build: jdk-${JDK_FEATURE}-ea+}\" # remove everything before the number\n+TMP=\"${TMP#*Most recent build: jdk-${JDK_FEATURE}+}\"    # remove everything before the number\n TMP=\"${TMP%%<*}\"                                        # remove everything after the number\n JDK_BUILD=\"$(echo -e \"${TMP}\" | tr -d '[:space:]')\"     # remove all whitespace\n \n@@ -31,7 +31,7 @@ if [ \"${JDK_LICENSE}\" == 'GPL' ]; then\n   JDK_BASENAME='openjdk'\n fi\n \n-JDK_ARCHIVE=${JDK_BASENAME}-${JDK_FEATURE}-ea+${JDK_BUILD}_linux-x64_bin.tar.gz\n+JDK_ARCHIVE=${JDK_BASENAME}-${JDK_FEATURE}+${JDK_BUILD}_linux-x64_bin.tar.gz\n \n cd ~\n wget http://download.java.net/java/jdk${JDK_FEATURE}/archive/${JDK_BUILD}/${JDK_LICENSE}/${JDK_ARCHIVE}\n"
    },
    {
        "commit_hash": "1e70bf31a8be9b36f5495a2f38b50dbd588e1dd0",
        "previous_commit_hash": "62d7826d2a7a9d8faef1363addde7b221ef0cbd1",
        "diff_stats": {
            "additions": 5,
            "deletions": 0
        },
        "diff_content": "@@ -27,6 +27,7 @@ import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Objects;\n+import javax.lang.model.SourceVersion;\n import javax.lang.model.element.AnnotationMirror;\n import javax.lang.model.element.AnnotationValue;\n import javax.lang.model.element.ExecutableElement;\n@@ -36,6 +37,7 @@ import javax.lang.model.type.TypeMirror;\n import javax.lang.model.util.SimpleAnnotationValueVisitor7;\n \n import static com.squareup.javapoet.Util.characterLiteralWithoutSingleQuotes;\n+import static com.squareup.javapoet.Util.checkArgument;\n import static com.squareup.javapoet.Util.checkNotNull;\n \n /** A generated annotation on a declaration. */\n@@ -206,6 +208,8 @@ public final class AnnotationSpec {\n     }\n \n     public Builder addMember(String name, CodeBlock codeBlock) {\n+      checkNotNull(name, \"name == null\");\n+      checkArgument(SourceVersion.isName(name), \"not a valid name: %s\", name);\n       List<CodeBlock> values = members.get(name);\n       if (values == null) {\n         values = new ArrayList<>();\n@@ -223,6 +227,7 @@ public final class AnnotationSpec {\n     Builder addMemberForValue(String memberName, Object value) {\n       checkNotNull(memberName, \"memberName == null\");\n       checkNotNull(value, \"value == null, constant non-null value expected for %s\", memberName);\n+      checkArgument(SourceVersion.isName(memberName), \"not a valid name: %s\", memberName);\n       if (value instanceof Class<?>) {\n         return addMember(memberName, \"$T.class\", value);\n       }\n"
    },
    {
        "commit_hash": "1e70bf31a8be9b36f5495a2f38b50dbd588e1dd0",
        "previous_commit_hash": "62d7826d2a7a9d8faef1363addde7b221ef0cbd1",
        "diff_stats": {
            "additions": 21,
            "deletions": 0
        },
        "diff_content": "@@ -25,6 +25,7 @@ import org.junit.Rule;\n import org.junit.Test;\n \n import static com.google.common.truth.Truth.assertThat;\n+import static org.junit.Assert.fail;\n \n public final class AnnotationSpecTest {\n \n@@ -350,6 +351,26 @@ public final class AnnotationSpecTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void disallowsNullMemberName() {\n+    AnnotationSpec.Builder builder = AnnotationSpec.builder(HasDefaultsAnnotation.class);\n+    try {\n+      AnnotationSpec.Builder $L = builder.addMember(null, \"$L\", \"\");\n+      fail($L.build().toString());\n+    } catch (NullPointerException e) {\n+      assertThat(e).hasMessageThat().isEqualTo(\"name == null\");\n+    }\n+  }\n+\n+  @Test public void requiresValidMemberName() {\n+    AnnotationSpec.Builder builder = AnnotationSpec.builder(HasDefaultsAnnotation.class);\n+    try {\n+      AnnotationSpec.Builder $L = builder.addMember(\"@\", \"$L\", \"\");\n+      fail($L.build().toString());\n+    } catch (IllegalArgumentException e) {\n+      assertThat(e).hasMessageThat().isEqualTo(\"not a valid name: @\");\n+    }\n+  }\n+\n   private String toString(TypeSpec typeSpec) {\n     return JavaFile.builder(\"com.squareup.tacos\", typeSpec).build().toString();\n   }\n"
    },
    {
        "commit_hash": "28fdcfbbcf9ca9f3736d8825d841f58169bc78d0",
        "previous_commit_hash": "1e70bf31a8be9b36f5495a2f38b50dbd588e1dd0",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -3,7 +3,7 @@\n # Deploy a jar, source jar, and javadoc jar to Sonatype's snapshot repo.\n #\n # Adapted from https://coderwall.com/p/9b_lfq and\n-# http://benlimmer.com/2013/12/26/automatically-publish-javadoc-to-gh-pages-with-travis-ci/\n+# https://benlimmer.com/2013/12/26/automatically-publish-javadoc-to-gh-pages-with-travis-ci/\n \n SLUG=\"square/javapoet\"\n JDK=\"oraclejdk8\"\n"
    },
    {
        "commit_hash": "28fdcfbbcf9ca9f3736d8825d841f58169bc78d0",
        "previous_commit_hash": "1e70bf31a8be9b36f5495a2f38b50dbd588e1dd0",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -884,6 +884,6 @@ JavaWriter continues to be available in [GitHub][javawriter] and [Maven Central]\n  [snap]: https://oss.sonatype.org/content/repositories/snapshots/com/squareup/javapoet/\n  [javadoc]: https://square.github.io/javapoet/1.x/javapoet/\n  [javawriter]: https://github.com/square/javapoet/tree/javawriter_2\n- [javawriter_maven]: http://search.maven.org/#artifactdetails%7Ccom.squareup%7Cjavawriter%7C2.5.1%7Cjar\n- [formatter]: http://developer.android.com/reference/java/util/Formatter.html\n- [modifier]: http://docs.oracle.com/javase/8/docs/api/javax/lang/model/element/Modifier.html\n+ [javawriter_maven]: https://search.maven.org/#artifactdetails%7Ccom.squareup%7Cjavawriter%7C2.5.1%7Cjar\n+ [formatter]: https://developer.android.com/reference/java/util/Formatter.html\n+ [modifier]: https://docs.oracle.com/javase/8/docs/api/javax/lang/model/element/Modifier.html\n"
    },
    {
        "commit_hash": "b314337267eb36462c3bf67a87494e614c9c8b40",
        "previous_commit_hash": "82e20e0ce26eee0e20cc52f976bb3e7e627dd338",
        "diff_stats": {
            "additions": 4,
            "deletions": 13
        },
        "diff_content": "@@ -34,7 +34,7 @@ import javax.lang.model.element.ExecutableElement;\n import javax.lang.model.element.TypeElement;\n import javax.lang.model.element.VariableElement;\n import javax.lang.model.type.TypeMirror;\n-import javax.lang.model.util.SimpleAnnotationValueVisitor7;\n+import javax.lang.model.util.SimpleAnnotationValueVisitor8;\n \n import static com.squareup.javapoet.Util.characterLiteralWithoutSingleQuotes;\n import static com.squareup.javapoet.Util.checkArgument;\n@@ -113,12 +113,7 @@ public final class AnnotationSpec {\n     Builder builder = builder(annotation.annotationType());\n     try {\n       Method[] methods = annotation.annotationType().getDeclaredMethods();\n-      Arrays.sort(methods, new Comparator<Method>() {\n-        @Override\n-        public int compare(Method m1, Method m2) {\n-          return m1.getName().compareTo(m2.getName());\n-        }\n-      });\n+      Arrays.sort(methods, Comparator.comparing(Method::getName));\n       for (Method method : methods) {\n         Object value = method.invoke(annotation);\n         if (!includeDefaultValues) {\n@@ -210,11 +205,7 @@ public final class AnnotationSpec {\n     public Builder addMember(String name, CodeBlock codeBlock) {\n       checkNotNull(name, \"name == null\");\n       checkArgument(SourceVersion.isName(name), \"not a valid name: %s\", name);\n-      List<CodeBlock> values = members.get(name);\n-      if (values == null) {\n-        values = new ArrayList<>();\n-        members.put(name, values);\n-      }\n+      List<CodeBlock> values = members.computeIfAbsent(name, k -> new ArrayList<>());\n       values.add(codeBlock);\n       return this;\n     }\n@@ -254,7 +245,7 @@ public final class AnnotationSpec {\n   /**\n    * Annotation value visitor adding members to the given builder instance.\n    */\n-  private static class Visitor extends SimpleAnnotationValueVisitor7<Builder, String> {\n+  private static class Visitor extends SimpleAnnotationValueVisitor8<Builder, String> {\n     final Builder builder;\n \n     Visitor(Builder builder) {\n"
    },
    {
        "commit_hash": "b314337267eb36462c3bf67a87494e614c9c8b40",
        "previous_commit_hash": "82e20e0ce26eee0e20cc52f976bb3e7e627dd338",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -31,7 +31,7 @@ public final class ArrayTypeName extends TypeName {\n   public final TypeName componentType;\n \n   private ArrayTypeName(TypeName componentType) {\n-    this(componentType, new ArrayList<AnnotationSpec>());\n+    this(componentType, new ArrayList<>());\n   }\n \n   private ArrayTypeName(TypeName componentType, List<AnnotationSpec> annotations) {\n@@ -63,7 +63,7 @@ public final class ArrayTypeName extends TypeName {\n \n   /** Returns an array type equivalent to {@code mirror}. */\n   public static ArrayTypeName get(ArrayType mirror) {\n-    return get(mirror, new LinkedHashMap<TypeParameterElement, TypeVariableName>());\n+    return get(mirror, new LinkedHashMap<>());\n   }\n \n   static ArrayTypeName get(\n@@ -73,7 +73,7 @@ public final class ArrayTypeName extends TypeName {\n \n   /** Returns an array type equivalent to {@code type}. */\n   public static ArrayTypeName get(GenericArrayType type) {\n-    return get(type, new LinkedHashMap<Type, TypeVariableName>());\n+    return get(type, new LinkedHashMap<>());\n   }\n \n   static ArrayTypeName get(GenericArrayType type, Map<Type, TypeVariableName> map) {\n"
    },
    {
        "commit_hash": "b314337267eb36462c3bf67a87494e614c9c8b40",
        "previous_commit_hash": "82e20e0ce26eee0e20cc52f976bb3e7e627dd338",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -40,7 +40,7 @@ public final class ClassName extends TypeName implements Comparable<ClassName> {\n   final String canonicalName;\n \n   private ClassName(List<String> names) {\n-    this(names, new ArrayList<AnnotationSpec>());\n+    this(names, new ArrayList<>());\n   }\n \n   private ClassName(List<String> names, List<AnnotationSpec> annotations) {\n@@ -50,8 +50,8 @@ public final class ClassName extends TypeName implements Comparable<ClassName> {\n     }\n     this.names = Util.immutableList(names);\n     this.canonicalName = (names.get(0).isEmpty()\n-        ? Util.join(\".\", names.subList(1, names.size()))\n-        : Util.join(\".\", names));\n+        ? String.join(\".\", names.subList(1, names.size()))\n+        : String.join(\".\", names));\n   }\n \n   @Override public ClassName annotated(List<AnnotationSpec> annotations) {\n"
    },
    {
        "commit_hash": "b314337267eb36462c3bf67a87494e614c9c8b40",
        "previous_commit_hash": "82e20e0ce26eee0e20cc52f976bb3e7e627dd338",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -306,7 +306,7 @@ public final class CodeBlock {\n           }\n         }\n         String s = unused.size() == 1 ? \"\" : \"s\";\n-        checkArgument(unused.isEmpty(), \"unused argument%s: %s\", s, Util.join(\", \", unused));\n+        checkArgument(unused.isEmpty(), \"unused argument%s: %s\", s, String.join(\", \", unused));\n       }\n       return this;\n     }\n"
    },
    {
        "commit_hash": "b314337267eb36462c3bf67a87494e614c9c8b40",
        "previous_commit_hash": "82e20e0ce26eee0e20cc52f976bb3e7e627dd338",
        "diff_stats": {
            "additions": 5,
            "deletions": 5
        },
        "diff_content": "@@ -33,8 +33,8 @@ import javax.lang.model.element.Modifier;\n import static com.squareup.javapoet.Util.checkArgument;\n import static com.squareup.javapoet.Util.checkNotNull;\n import static com.squareup.javapoet.Util.checkState;\n-import static com.squareup.javapoet.Util.join;\n import static com.squareup.javapoet.Util.stringLiteralWithDoubleQuotes;\n+import static java.lang.String.join;\n \n /**\n  * Converts a {@link JavaFile} to a string suitable to both human- and javac-consumption. This\n@@ -67,11 +67,11 @@ final class CodeWriter {\n   int statementLine = -1;\n \n   CodeWriter(Appendable out) {\n-    this(out, \"  \", Collections.<String>emptySet());\n+    this(out, \"  \", Collections.emptySet());\n   }\n \n   CodeWriter(Appendable out, String indent, Set<String> staticImports) {\n-    this(out, indent, Collections.<String, ClassName>emptyMap(), staticImports);\n+    this(out, indent, Collections.emptyMap(), staticImports);\n   }\n \n   CodeWriter(Appendable out, String indent, Map<String, ClassName> importedTypes,\n@@ -177,7 +177,7 @@ final class CodeWriter {\n   }\n \n   public void emitModifiers(Set<Modifier> modifiers) throws IOException {\n-    emitModifiers(modifiers, Collections.<Modifier>emptySet());\n+    emitModifiers(modifiers, Collections.emptySet());\n   }\n \n   /**\n@@ -339,7 +339,7 @@ final class CodeWriter {\n   private void emitLiteral(Object o) throws IOException {\n     if (o instanceof TypeSpec) {\n       TypeSpec typeSpec = (TypeSpec) o;\n-      typeSpec.emit(this, null, Collections.<Modifier>emptySet());\n+      typeSpec.emit(this, null, Collections.emptySet());\n     } else if (o instanceof AnnotationSpec) {\n       AnnotationSpec annotationSpec = (AnnotationSpec) o;\n       annotationSpec.emit(this, true);\n"
    },
    {
        "commit_hash": "b314337267eb36462c3bf67a87494e614c9c8b40",
        "previous_commit_hash": "82e20e0ce26eee0e20cc52f976bb3e7e627dd338",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -79,7 +79,7 @@ public final class FieldSpec {\n     StringBuilder out = new StringBuilder();\n     try {\n       CodeWriter codeWriter = new CodeWriter(out);\n-      emit(codeWriter, Collections.<Modifier>emptySet());\n+      emit(codeWriter, Collections.emptySet());\n       return out.toString();\n     } catch (IOException e) {\n       throw new AssertionError();\n"
    },
    {
        "commit_hash": "b314337267eb36462c3bf67a87494e614c9c8b40",
        "previous_commit_hash": "82e20e0ce26eee0e20cc52f976bb3e7e627dd338",
        "diff_stats": {
            "additions": 1,
            "deletions": 2
        },
        "diff_content": "@@ -32,7 +32,6 @@ import java.util.Set;\n import java.util.TreeSet;\n import javax.annotation.processing.Filer;\n import javax.lang.model.element.Element;\n-import javax.lang.model.element.Modifier;\n import javax.tools.JavaFileObject;\n import javax.tools.JavaFileObject.Kind;\n import javax.tools.SimpleJavaFileObject;\n@@ -154,7 +153,7 @@ public final class JavaFile {\n       codeWriter.emit(\"\\n\");\n     }\n \n-    typeSpec.emit(codeWriter, null, Collections.<Modifier>emptySet());\n+    typeSpec.emit(codeWriter, null, Collections.emptySet());\n \n     codeWriter.popPackage();\n   }\n"
    },
    {
        "commit_hash": "b314337267eb36462c3bf67a87494e614c9c8b40",
        "previous_commit_hash": "82e20e0ce26eee0e20cc52f976bb3e7e627dd338",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -161,7 +161,7 @@ public final class MethodSpec {\n     StringBuilder out = new StringBuilder();\n     try {\n       CodeWriter codeWriter = new CodeWriter(out);\n-      emit(codeWriter, \"Constructor\", Collections.<Modifier>emptySet());\n+      emit(codeWriter, \"Constructor\", Collections.emptySet());\n       return out.toString();\n     } catch (IOException e) {\n       throw new AssertionError();\n@@ -202,7 +202,7 @@ public final class MethodSpec {\n \n     modifiers = new LinkedHashSet<>(modifiers);\n     modifiers.remove(Modifier.ABSTRACT);\n-    modifiers.remove(Util.DEFAULT); // LinkedHashSet permits null as element for Java 7\n+    modifiers.remove(Modifier.DEFAULT);\n     methodBuilder.addModifiers(modifiers);\n \n     for (TypeParameterElement typeParameterElement : method.getTypeParameters()) {\n"
    },
    {
        "commit_hash": "b314337267eb36462c3bf67a87494e614c9c8b40",
        "previous_commit_hash": "82e20e0ce26eee0e20cc52f976bb3e7e627dd338",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -83,7 +83,7 @@ public final class NameAllocator implements Cloneable {\n   private final Map<Object, String> tagToName;\n \n   public NameAllocator() {\n-    this(new LinkedHashSet<String>(), new LinkedHashMap<Object, String>());\n+    this(new LinkedHashSet<>(), new LinkedHashMap<>());\n   }\n \n   private NameAllocator(LinkedHashSet<String> allocatedNames,\n"
    },
    {
        "commit_hash": "b314337267eb36462c3bf67a87494e614c9c8b40",
        "previous_commit_hash": "82e20e0ce26eee0e20cc52f976bb3e7e627dd338",
        "diff_stats": {
            "additions": 6,
            "deletions": 7
        },
        "diff_content": "@@ -35,7 +35,7 @@ public final class ParameterizedTypeName extends TypeName {\n \n   ParameterizedTypeName(ParameterizedTypeName enclosingType, ClassName rawType,\n       List<TypeName> typeArguments) {\n-    this(enclosingType, rawType, typeArguments, new ArrayList<AnnotationSpec>());\n+    this(enclosingType, rawType, typeArguments, new ArrayList<>());\n   }\n \n   private ParameterizedTypeName(ParameterizedTypeName enclosingType, ClassName rawType,\n@@ -59,8 +59,7 @@ public final class ParameterizedTypeName extends TypeName {\n   }\n \n   @Override public TypeName withoutAnnotations() {\n-    return new ParameterizedTypeName(\n-        enclosingType, rawType, typeArguments, new ArrayList<AnnotationSpec>());\n+    return new ParameterizedTypeName(enclosingType, rawType, typeArguments, new ArrayList<>());\n   }\n \n   @Override CodeWriter emit(CodeWriter out) throws IOException {\n@@ -92,8 +91,8 @@ public final class ParameterizedTypeName extends TypeName {\n    */\n   public ParameterizedTypeName nestedClass(String name) {\n     checkNotNull(name, \"name == null\");\n-    return new ParameterizedTypeName(this, rawType.nestedClass(name), new ArrayList<TypeName>(),\n-        new ArrayList<AnnotationSpec>());\n+    return new ParameterizedTypeName(this, rawType.nestedClass(name), new ArrayList<>(),\n+        new ArrayList<>());\n   }\n \n   /**\n@@ -103,7 +102,7 @@ public final class ParameterizedTypeName extends TypeName {\n   public ParameterizedTypeName nestedClass(String name, List<TypeName> typeArguments) {\n     checkNotNull(name, \"name == null\");\n     return new ParameterizedTypeName(this, rawType.nestedClass(name), typeArguments,\n-        new ArrayList<AnnotationSpec>());\n+        new ArrayList<>());\n   }\n \n   /** Returns a parameterized type, applying {@code typeArguments} to {@code rawType}. */\n@@ -118,7 +117,7 @@ public final class ParameterizedTypeName extends TypeName {\n \n   /** Returns a parameterized type equivalent to {@code type}. */\n   public static ParameterizedTypeName get(ParameterizedType type) {\n-    return get(type, new LinkedHashMap<Type, TypeVariableName>());\n+    return get(type, new LinkedHashMap<>());\n   }\n \n   /** Returns a parameterized type equivalent to {@code type}. */\n"
    },
    {
        "commit_hash": "b314337267eb36462c3bf67a87494e614c9c8b40",
        "previous_commit_hash": "82e20e0ce26eee0e20cc52f976bb3e7e627dd338",
        "diff_stats": {
            "additions": 6,
            "deletions": 6
        },
        "diff_content": "@@ -36,7 +36,7 @@ import javax.lang.model.type.NoType;\n import javax.lang.model.type.PrimitiveType;\n import javax.lang.model.type.TypeKind;\n import javax.lang.model.type.TypeMirror;\n-import javax.lang.model.util.SimpleTypeVisitor7;\n+import javax.lang.model.util.SimpleTypeVisitor8;\n \n /**\n  * Any type in Java's type system, plus {@code void}. This class is an identifier for primitive\n@@ -95,7 +95,7 @@ public class TypeName {\n   private String cachedString;\n \n   private TypeName(String keyword) {\n-    this(keyword, new ArrayList<AnnotationSpec>());\n+    this(keyword, new ArrayList<>());\n   }\n \n   private TypeName(String keyword, List<AnnotationSpec> annotations) {\n@@ -235,12 +235,12 @@ public class TypeName {\n \n   /** Returns a type name equivalent to {@code mirror}. */\n   public static TypeName get(TypeMirror mirror) {\n-    return get(mirror, new LinkedHashMap<TypeParameterElement, TypeVariableName>());\n+    return get(mirror, new LinkedHashMap<>());\n   }\n \n   static TypeName get(TypeMirror mirror,\n       final Map<TypeParameterElement, TypeVariableName> typeVariables) {\n-    return mirror.accept(new SimpleTypeVisitor7<TypeName, Void>() {\n+    return mirror.accept(new SimpleTypeVisitor8<TypeName, Void>() {\n       @Override public TypeName visitPrimitive(PrimitiveType t, Void p) {\n         switch (t.getKind()) {\n           case BOOLEAN:\n@@ -315,7 +315,7 @@ public class TypeName {\n \n   /** Returns a type name equivalent to {@code type}. */\n   public static TypeName get(Type type) {\n-    return get(type, new LinkedHashMap<Type, TypeVariableName>());\n+    return get(type, new LinkedHashMap<>());\n   }\n \n   static TypeName get(Type type, Map<Type, TypeVariableName> map) {\n@@ -352,7 +352,7 @@ public class TypeName {\n \n   /** Converts an array of types to a list of type names. */\n   static List<TypeName> list(Type[] types) {\n-    return list(types, new LinkedHashMap<Type, TypeVariableName>());\n+    return list(types, new LinkedHashMap<>());\n   }\n \n   static List<TypeName> list(Type[] types, Map<Type, TypeVariableName> map) {\n"
    },
    {
        "commit_hash": "b314337267eb36462c3bf67a87494e614c9c8b40",
        "previous_commit_hash": "82e20e0ce26eee0e20cc52f976bb3e7e627dd338",
        "diff_stats": {
            "additions": 15,
            "deletions": 16
        },
        "diff_content": "@@ -34,7 +34,6 @@ import javax.lang.model.element.Modifier;\n import static com.squareup.javapoet.Util.checkArgument;\n import static com.squareup.javapoet.Util.checkNotNull;\n import static com.squareup.javapoet.Util.checkState;\n-import static com.squareup.javapoet.Util.hasDefaultModifier;\n import static com.squareup.javapoet.Util.requireExactlyOneOf;\n \n /** A generated class, interface, or enum declaration. */\n@@ -215,7 +214,7 @@ public final class TypeSpec {\n           implementsTypes = Collections.emptyList();\n         } else {\n           extendsTypes = superclass.equals(ClassName.OBJECT)\n-              ? Collections.<TypeName>emptyList()\n+              ? Collections.emptyList()\n               : Collections.singletonList(superclass);\n           implementsTypes = superinterfaces;\n         }\n@@ -252,8 +251,7 @@ public final class TypeSpec {\n           i.hasNext(); ) {\n         Map.Entry<String, TypeSpec> enumConstant = i.next();\n         if (!firstMember) codeWriter.emit(\"\\n\");\n-        enumConstant.getValue()\n-            .emit(codeWriter, enumConstant.getKey(), Collections.<Modifier>emptySet());\n+        enumConstant.getValue().emit(codeWriter, enumConstant.getKey(), Collections.emptySet());\n         firstMember = false;\n         if (i.hasNext()) {\n           codeWriter.emit(\",\\n\");\n@@ -343,7 +341,7 @@ public final class TypeSpec {\n     StringBuilder out = new StringBuilder();\n     try {\n       CodeWriter codeWriter = new CodeWriter(out);\n-      emit(codeWriter, null, Collections.<Modifier>emptySet());\n+      emit(codeWriter, null, Collections.emptySet());\n       return out.toString();\n     } catch (IOException e) {\n       throw new AssertionError();\n@@ -352,28 +350,28 @@ public final class TypeSpec {\n \n   public enum Kind {\n     CLASS(\n-        Collections.<Modifier>emptySet(),\n-        Collections.<Modifier>emptySet(),\n-        Collections.<Modifier>emptySet(),\n-        Collections.<Modifier>emptySet()),\n+        Collections.emptySet(),\n+        Collections.emptySet(),\n+        Collections.emptySet(),\n+        Collections.emptySet()),\n \n     INTERFACE(\n         Util.immutableSet(Arrays.asList(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)),\n         Util.immutableSet(Arrays.asList(Modifier.PUBLIC, Modifier.ABSTRACT)),\n         Util.immutableSet(Arrays.asList(Modifier.PUBLIC, Modifier.STATIC)),\n-        Util.immutableSet(Arrays.asList(Modifier.STATIC))),\n+        Util.immutableSet(Collections.singletonList(Modifier.STATIC))),\n \n     ENUM(\n-        Collections.<Modifier>emptySet(),\n-        Collections.<Modifier>emptySet(),\n-        Collections.<Modifier>emptySet(),\n+        Collections.emptySet(),\n+        Collections.emptySet(),\n+        Collections.emptySet(),\n         Collections.singleton(Modifier.STATIC)),\n \n     ANNOTATION(\n         Util.immutableSet(Arrays.asList(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)),\n         Util.immutableSet(Arrays.asList(Modifier.PUBLIC, Modifier.ABSTRACT)),\n         Util.immutableSet(Arrays.asList(Modifier.PUBLIC, Modifier.STATIC)),\n-        Util.immutableSet(Arrays.asList(Modifier.STATIC)));\n+        Util.immutableSet(Collections.singletonList(Modifier.STATIC)));\n \n     private final Set<Modifier> implicitFieldModifiers;\n     private final Set<Modifier> implicitMethodModifiers;\n@@ -571,7 +569,8 @@ public final class TypeSpec {\n \n     public Builder addMethod(MethodSpec methodSpec) {\n       if (kind == Kind.INTERFACE) {\n-        requireExactlyOneOf(methodSpec.modifiers, Modifier.ABSTRACT, Modifier.STATIC, Util.DEFAULT);\n+        requireExactlyOneOf(methodSpec.modifiers, Modifier.ABSTRACT, Modifier.STATIC,\n+            Modifier.DEFAULT);\n         requireExactlyOneOf(methodSpec.modifiers, Modifier.PUBLIC, Modifier.PRIVATE);\n       } else if (kind == Kind.ANNOTATION) {\n         checkState(methodSpec.modifiers.equals(kind.implicitMethodModifiers),\n@@ -583,7 +582,7 @@ public final class TypeSpec {\n             kind, name, methodSpec.name);\n       }\n       if (kind != Kind.INTERFACE) {\n-        checkState(!hasDefaultModifier(methodSpec.modifiers), \"%s %s.%s cannot be default\",\n+        checkState(!methodSpec.hasModifier(Modifier.DEFAULT), \"%s %s.%s cannot be default\",\n             kind, name, methodSpec.name);\n       }\n       methodSpecs.add(methodSpec);\n"
    },
    {
        "commit_hash": "b314337267eb36462c3bf67a87494e614c9c8b40",
        "previous_commit_hash": "82e20e0ce26eee0e20cc52f976bb3e7e627dd338",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -36,7 +36,7 @@ public final class TypeVariableName extends TypeName {\n   public final List<TypeName> bounds;\n \n   private TypeVariableName(String name, List<TypeName> bounds) {\n-    this(name, bounds, new ArrayList<AnnotationSpec>());\n+    this(name, bounds, new ArrayList<>());\n   }\n \n   private TypeVariableName(String name, List<TypeName> bounds, List<AnnotationSpec> annotations) {\n@@ -85,7 +85,7 @@ public final class TypeVariableName extends TypeName {\n \n   /** Returns type variable named {@code name} without bounds. */\n   public static TypeVariableName get(String name) {\n-    return TypeVariableName.of(name, Collections.<TypeName>emptyList());\n+    return TypeVariableName.of(name, Collections.emptyList());\n   }\n \n   /** Returns type variable named {@code name} with {@code bounds}. */\n@@ -145,7 +145,7 @@ public final class TypeVariableName extends TypeName {\n \n   /** Returns type variable equivalent to {@code type}. */\n   public static TypeVariableName get(java.lang.reflect.TypeVariable<?> type) {\n-    return get(type, new LinkedHashMap<Type, TypeVariableName>());\n+    return get(type, new LinkedHashMap<>());\n   }\n \n   /** @see #get(java.lang.reflect.TypeVariable, Map) */\n"
    },
    {
        "commit_hash": "b314337267eb36462c3bf67a87494e614c9c8b40",
        "previous_commit_hash": "82e20e0ce26eee0e20cc52f976bb3e7e627dd338",
        "diff_stats": {
            "additions": 0,
            "deletions": 26
        },
        "diff_content": "@@ -36,17 +36,6 @@ final class Util {\n   private Util() {\n   }\n \n-  /** Modifier.DEFAULT doesn't exist until Java 8, but we want to run on earlier releases. */\n-  static final Modifier DEFAULT;\n-  static {\n-    Modifier def = null;\n-    try {\n-      def = Modifier.valueOf(\"DEFAULT\");\n-    } catch (IllegalArgumentException ignored) {\n-    }\n-    DEFAULT = def;\n-  }\n-\n   static <K, V> Map<K, List<V>> immutableMultimap(Map<K, List<V>> multimap) {\n     LinkedHashMap<K, List<V>> result = new LinkedHashMap<>();\n     for (Map.Entry<K, List<V>> entry : multimap.entrySet()) {\n@@ -81,16 +70,6 @@ final class Util {\n     return Collections.unmodifiableSet(new LinkedHashSet<>(set));\n   }\n \n-  static String join(String separator, List<String> parts) {\n-    if (parts.isEmpty()) return \"\";\n-    StringBuilder result = new StringBuilder();\n-    result.append(parts.get(0));\n-    for (int i = 1; i < parts.size(); i++) {\n-      result.append(separator).append(parts.get(i));\n-    }\n-    return result.toString();\n-  }\n-\n   static <T> Set<T> union(Set<T> a, Set<T> b) {\n     Set<T> result = new LinkedHashSet<>();\n     result.addAll(a);\n@@ -101,17 +80,12 @@ final class Util {\n   static void requireExactlyOneOf(Set<Modifier> modifiers, Modifier... mutuallyExclusive) {\n     int count = 0;\n     for (Modifier modifier : mutuallyExclusive) {\n-      if (modifier == null && Util.DEFAULT == null) continue; // Skip 'DEFAULT' if it doesn't exist!\n       if (modifiers.contains(modifier)) count++;\n     }\n     checkArgument(count == 1, \"modifiers %s must contain one of %s\",\n         modifiers, Arrays.toString(mutuallyExclusive));\n   }\n \n-  static boolean hasDefaultModifier(Collection<Modifier> modifiers) {\n-    return DEFAULT != null && modifiers.contains(DEFAULT);\n-  }\n-\n   static String characterLiteralWithoutSingleQuotes(char c) {\n     // see https://docs.oracle.com/javase/specs/jls/se7/html/jls-3.html#jls-3.10.6\n     switch (c) {\n"
    },
    {
        "commit_hash": "b314337267eb36462c3bf67a87494e614c9c8b40",
        "previous_commit_hash": "82e20e0ce26eee0e20cc52f976bb3e7e627dd338",
        "diff_stats": {
            "additions": 6,
            "deletions": 6
        },
        "diff_content": "@@ -19,7 +19,6 @@ import java.io.IOException;\n import java.lang.reflect.Type;\n import java.lang.reflect.WildcardType;\n import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.Collections;\n import java.util.LinkedHashMap;\n import java.util.List;\n@@ -34,7 +33,7 @@ public final class WildcardTypeName extends TypeName {\n   public final List<TypeName> lowerBounds;\n \n   private WildcardTypeName(List<TypeName> upperBounds, List<TypeName> lowerBounds) {\n-    this(upperBounds, lowerBounds, new ArrayList<AnnotationSpec>());\n+    this(upperBounds, lowerBounds, new ArrayList<>());\n   }\n \n   private WildcardTypeName(List<TypeName> upperBounds, List<TypeName> lowerBounds,\n@@ -78,7 +77,7 @@ public final class WildcardTypeName extends TypeName {\n    * ? extends Object}.\n    */\n   public static WildcardTypeName subtypeOf(TypeName upperBound) {\n-    return new WildcardTypeName(Arrays.asList(upperBound), Collections.<TypeName>emptyList());\n+    return new WildcardTypeName(Collections.singletonList(upperBound), Collections.emptyList());\n   }\n \n   public static WildcardTypeName subtypeOf(Type upperBound) {\n@@ -90,7 +89,8 @@ public final class WildcardTypeName extends TypeName {\n    * bound} is {@code String.class}, this returns {@code ? super String}.\n    */\n   public static WildcardTypeName supertypeOf(TypeName lowerBound) {\n-    return new WildcardTypeName(Arrays.<TypeName>asList(OBJECT), Arrays.asList(lowerBound));\n+    return new WildcardTypeName(Collections.singletonList(OBJECT),\n+        Collections.singletonList(lowerBound));\n   }\n \n   public static WildcardTypeName supertypeOf(Type lowerBound) {\n@@ -98,7 +98,7 @@ public final class WildcardTypeName extends TypeName {\n   }\n \n   public static TypeName get(javax.lang.model.type.WildcardType mirror) {\n-    return get(mirror, new LinkedHashMap<TypeParameterElement, TypeVariableName>());\n+    return get(mirror, new LinkedHashMap<>());\n   }\n \n   static TypeName get(\n@@ -118,7 +118,7 @@ public final class WildcardTypeName extends TypeName {\n   }\n \n   public static TypeName get(WildcardType wildcardName) {\n-    return get(wildcardName, new LinkedHashMap<Type, TypeVariableName>());\n+    return get(wildcardName, new LinkedHashMap<>());\n   }\n \n   static TypeName get(WildcardType wildcardName, Map<Type, TypeVariableName> map) {\n"
    },
    {
        "commit_hash": "b314337267eb36462c3bf67a87494e614c9c8b40",
        "previous_commit_hash": "82e20e0ce26eee0e20cc52f976bb3e7e627dd338",
        "diff_stats": {
            "additions": 3,
            "deletions": 1
        },
        "diff_content": "@@ -20,6 +20,8 @@ import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertNotEquals;\n import static org.junit.Assert.assertTrue;\n \n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Target;\n import java.util.List;\n import java.util.Map;\n import org.junit.Ignore;\n@@ -115,7 +117,7 @@ public class AnnotatedTypeNameTest {\n   }\n \n   // https://github.com/square/javapoet/issues/431\n-  // @Target(ElementType.TYPE_USE) requires Java 1.8\n+  @Target(ElementType.TYPE_USE)\n   public @interface TypeUseAnnotation {}\n \n   // https://github.com/square/javapoet/issues/431\n"
    },
    {
        "commit_hash": "b314337267eb36462c3bf67a87494e614c9c8b40",
        "previous_commit_hash": "82e20e0ce26eee0e20cc52f976bb3e7e627dd338",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -105,8 +105,8 @@ public class FileReadingTest {\n     CompilationTask task = compiler.getTask(null, \n         fileManager,\n         diagnosticCollector,\n-        Collections.<String>emptySet(),\n-        Collections.<String>emptySet(),\n+        Collections.emptySet(),\n+        Collections.emptySet(),\n         Collections.singleton(javaFile.toJavaFileObject()));\n     \n     assertThat(task.call()).isTrue();\n"
    },
    {
        "commit_hash": "b314337267eb36462c3bf67a87494e614c9c8b40",
        "previous_commit_hash": "82e20e0ce26eee0e20cc52f976bb3e7e627dd338",
        "diff_stats": {
            "additions": 0,
            "deletions": 2
        },
        "diff_content": "@@ -39,7 +39,6 @@ import org.junit.Test;\n \n import static com.google.common.collect.Iterables.getOnlyElement;\n import static com.google.common.truth.Truth.assertThat;\n-import static com.google.common.truth.TruthJUnit.assume;\n import static javax.lang.model.util.ElementFilter.methodsIn;\n import static org.junit.Assert.fail;\n import static org.mockito.Mockito.mock;\n@@ -152,7 +151,6 @@ public final class MethodSpecTest {\n     DeclaredType classType = (DeclaredType) classElement.asType();\n     List<ExecutableElement> methods = methodsIn(elements.getAllMembers(classElement));\n     ExecutableElement exec = findFirst(methods, \"iterator\");\n-    assume().that(Util.DEFAULT).isNotNull();\n     exec = findFirst(methods, \"spliterator\");\n     MethodSpec method = MethodSpec.overriding(exec, classType, types).build();\n     assertThat(method.toString()).isEqualTo(\"\"\n"
    },
    {
        "commit_hash": "b314337267eb36462c3bf67a87494e614c9c8b40",
        "previous_commit_hash": "82e20e0ce26eee0e20cc52f976bb3e7e627dd338",
        "diff_stats": {
            "additions": 2,
            "deletions": 9
        },
        "diff_content": "@@ -44,7 +44,6 @@ import org.mockito.Mockito;\n import static com.google.common.truth.Truth.assertThat;\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.fail;\n-import static org.junit.Assume.assumeTrue;\n \n @RunWith(JUnit4.class)\n public final class TypeSpecTest {\n@@ -57,10 +56,6 @@ public final class TypeSpecTest {\n     return compilation.getElements().getTypeElement(clazz.getCanonicalName());\n   }\n \n-  private boolean isJava8() {\n-    return Util.DEFAULT != null;\n-  }\n-\n   @Test public void basic() throws Exception {\n     TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n         .addMethod(MethodSpec.methodBuilder(\"toString\")\n@@ -832,11 +827,10 @@ public final class TypeSpecTest {\n \n   @Test\n   public void classCannotHaveDefaultMethods() throws Exception {\n-    assumeTrue(isJava8());\n     try {\n       TypeSpec.classBuilder(\"Tacos\")\n           .addMethod(MethodSpec.methodBuilder(\"test\")\n-              .addModifiers(Modifier.PUBLIC, Modifier.valueOf(\"DEFAULT\"))\n+              .addModifiers(Modifier.PUBLIC, Modifier.DEFAULT)\n               .returns(int.class)\n               .addCode(CodeBlock.builder().addStatement(\"return 0\").build())\n               .build())\n@@ -869,10 +863,9 @@ public final class TypeSpecTest {\n \n   @Test\n   public void interfaceDefaultMethods() throws Exception {\n-    assumeTrue(isJava8());\n     TypeSpec bar = TypeSpec.interfaceBuilder(\"Tacos\")\n         .addMethod(MethodSpec.methodBuilder(\"test\")\n-            .addModifiers(Modifier.PUBLIC, Modifier.valueOf(\"DEFAULT\"))\n+            .addModifiers(Modifier.PUBLIC, Modifier.DEFAULT)\n             .returns(int.class)\n             .addCode(CodeBlock.builder().addStatement(\"return 0\").build())\n             .build())\n"
    },
    {
        "commit_hash": "b314337267eb36462c3bf67a87494e614c9c8b40",
        "previous_commit_hash": "82e20e0ce26eee0e20cc52f976bb3e7e627dd338",
        "diff_stats": {
            "additions": 4,
            "deletions": 4
        },
        "diff_content": "@@ -65,7 +65,7 @@ public final class TypesEclipseTest extends AbstractTypesTest {\n     public Statement apply(final Statement base, Description description) {\n       return new Statement() {\n         @Override public void evaluate() throws Throwable {\n-          final AtomicReference<Throwable> thrown = new AtomicReference<Throwable>();\n+          final AtomicReference<Throwable> thrown = new AtomicReference<>();\n           boolean successful = compile(ImmutableList.of(new AbstractProcessor() {\n             @Override\n             public SourceVersion getSupportedSourceVersion() {\n@@ -130,15 +130,15 @@ public final class TypesEclipseTest extends AbstractTypesTest {\n     static private boolean compile(Iterable<? extends Processor> processors) {\n       JavaCompiler compiler = new EclipseCompiler();\n       DiagnosticCollector<JavaFileObject> diagnosticCollector =\n-          new DiagnosticCollector<JavaFileObject>();\n+          new DiagnosticCollector<>();\n       JavaFileManager fileManager = compiler.getStandardFileManager(diagnosticCollector, Locale.getDefault(), UTF_8);\n       JavaCompiler.CompilationTask task = compiler.getTask(\n           null,\n           fileManager,\n           diagnosticCollector,\n-          ImmutableSet.<String>of(),\n+          ImmutableSet.of(),\n           ImmutableSet.of(TypesEclipseTest.class.getCanonicalName()),\n-          ImmutableSet.<JavaFileObject>of());\n+          ImmutableSet.of());\n       task.setProcessors(processors);\n       return task.call();\n     }\n"
    },
    {
        "commit_hash": "ee82208f4bc086e0b1334445f600789879fc7a78",
        "previous_commit_hash": "b314337267eb36462c3bf67a87494e614c9c8b40",
        "diff_stats": {
            "additions": 6,
            "deletions": 0
        },
        "diff_content": "@@ -25,6 +25,7 @@ import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import javax.lang.model.SourceVersion;\n+import javax.lang.model.element.Element;\n import javax.lang.model.element.ExecutableElement;\n import javax.lang.model.element.Modifier;\n import javax.lang.model.element.TypeParameterElement;\n@@ -188,6 +189,11 @@ public final class MethodSpec {\n   public static Builder overriding(ExecutableElement method) {\n     checkNotNull(method, \"method == null\");\n \n+    Element enclosingClass = method.getEnclosingElement();\n+    if (enclosingClass.getModifiers().contains(Modifier.FINAL)) {\n+      throw new IllegalArgumentException(\"Cannot override method on final class \" + enclosingClass);\n+    }\n+\n     Set<Modifier> modifiers = method.getModifiers();\n     if (modifiers.contains(Modifier.PRIVATE)\n         || modifiers.contains(Modifier.FINAL)\n"
    },
    {
        "commit_hash": "ee82208f4bc086e0b1334445f600789879fc7a78",
        "previous_commit_hash": "b314337267eb36462c3bf67a87494e614c9c8b40",
        "diff_stats": {
            "additions": 17,
            "deletions": 0
        },
        "diff_content": "@@ -123,6 +123,11 @@ public final class MethodSpecTest {\n   interface ExtendsIterableWithDefaultMethods extends Iterable<Object> {\n   }\n \n+  final class FinalClass {\n+    void method() {\n+    }\n+  }\n+\n   @Test public void overrideEverything() {\n     TypeElement classElement = getElement(Everything.class);\n     ExecutableElement methodElement = getOnlyElement(methodsIn(classElement.getEnclosedElements()));\n@@ -177,6 +182,18 @@ public final class MethodSpecTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void overrideFinalClassMethod() {\n+    TypeElement classElement = getElement(FinalClass.class);\n+    List<ExecutableElement> methods = methodsIn(elements.getAllMembers(classElement));\n+    try {\n+      MethodSpec.overriding(findFirst(methods, \"method\"));\n+      fail();\n+    } catch (IllegalArgumentException expected) {\n+      assertThat(expected).hasMessageThat().isEqualTo(\n+          \"Cannot override method on final class com.squareup.javapoet.MethodSpecTest.FinalClass\");\n+    }\n+  }\n+\n   @Test public void overrideInvalidModifiers() {\n     ExecutableElement method = mock(ExecutableElement.class);\n     when(method.getModifiers()).thenReturn(ImmutableSet.of(Modifier.FINAL));\n"
    },
    {
        "commit_hash": "adced314c48865463594bf58022f509090eef7af",
        "previous_commit_hash": "ee82208f4bc086e0b1334445f600789879fc7a78",
        "diff_stats": {
            "additions": 5,
            "deletions": 0
        },
        "diff_content": "@@ -243,6 +243,7 @@ public final class MethodSpec {\n       ExecutableElement method, DeclaredType enclosing, Types types) {\n     ExecutableType executableType = (ExecutableType) types.asMemberOf(enclosing, method);\n     List<? extends TypeMirror> resolvedParameterTypes = executableType.getParameterTypes();\n+    List<? extends TypeMirror> resolvedThrownTypes = executableType.getThrownTypes();\n     TypeMirror resolvedReturnType = executableType.getReturnType();\n \n     Builder builder = overriding(method);\n@@ -252,6 +253,10 @@ public final class MethodSpec {\n       TypeName type = TypeName.get(resolvedParameterTypes.get(i));\n       builder.parameters.set(i, parameter.toBuilder(type, parameter.name).build());\n     }\n+    builder.exceptions.clear();\n+    for (int i = 0, size = resolvedThrownTypes.size(); i < size; i++) {\n+      builder.addException(TypeName.get(resolvedThrownTypes.get(i)));\n+    }\n \n     return builder;\n   }\n"
    },
    {
        "commit_hash": "adced314c48865463594bf58022f509090eef7af",
        "previous_commit_hash": "ee82208f4bc086e0b1334445f600789879fc7a78",
        "diff_stats": {
            "additions": 12,
            "deletions": 1
        },
        "diff_content": "@@ -117,7 +117,12 @@ public final class MethodSpecTest {\n     @Override public abstract String toString();\n   }\n \n-  interface ExtendsOthers extends Callable<Integer>, Comparable<ExtendsOthers> {\n+  interface Throws<R extends RuntimeException> {\n+    void fail() throws R;\n+  }\n+\n+  interface ExtendsOthers extends Callable<Integer>, Comparable<ExtendsOthers>,\n+      Throws<IllegalStateException> {\n   }\n \n   interface ExtendsIterableWithDefaultMethods extends Iterable<Object> {\n@@ -180,6 +185,12 @@ public final class MethodSpecTest {\n         + \"@java.lang.Override\\n\"\n         + \"public int compareTo(\" + ExtendsOthers.class.getCanonicalName() + \" arg0) {\\n\"\n         + \"}\\n\");\n+    exec = findFirst(methods, \"fail\");\n+    method = MethodSpec.overriding(exec, classType, types).build();\n+    assertThat(method.toString()).isEqualTo(\"\"\n+        + \"@java.lang.Override\\n\"\n+        + \"public void fail() throws java.lang.IllegalStateException {\\n\"\n+        + \"}\\n\");\n   }\n \n   @Test public void overrideFinalClassMethod() {\n"
    },
    {
        "commit_hash": "d1080529667e27a8a81708774ef556c01bd03d4f",
        "previous_commit_hash": "adced314c48865463594bf58022f509090eef7af",
        "diff_stats": {
            "additions": 36,
            "deletions": 16
        },
        "diff_content": "@@ -15,7 +15,6 @@\n  */\n package com.squareup.javapoet;\n \n-import com.google.common.collect.ImmutableSet;\n import com.google.testing.compile.CompilationRule;\n import java.io.Closeable;\n import java.io.IOException;\n@@ -26,7 +25,6 @@ import java.util.Collection;\n import java.util.List;\n import java.util.concurrent.Callable;\n import java.util.concurrent.TimeoutException;\n-import javax.lang.model.element.Element;\n import javax.lang.model.element.ExecutableElement;\n import javax.lang.model.element.Modifier;\n import javax.lang.model.element.TypeElement;\n@@ -41,8 +39,6 @@ import static com.google.common.collect.Iterables.getOnlyElement;\n import static com.google.common.truth.Truth.assertThat;\n import static javax.lang.model.util.ElementFilter.methodsIn;\n import static org.junit.Assert.fail;\n-import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.when;\n \n public final class MethodSpecTest {\n   @Rule public final CompilationRule compilation = new CompilationRule();\n@@ -113,6 +109,12 @@ public final class MethodSpecTest {\n         @Nullable String thing, List<? extends T> things) throws IOException, SecurityException;\n   }\n \n+  abstract static class Generics {\n+    <T, R, V extends Throwable> T run(R param) throws V {\n+      return null;\n+    }\n+  }\n+\n   abstract static class HasAnnotation {\n     @Override public abstract String toString();\n   }\n@@ -133,6 +135,17 @@ public final class MethodSpecTest {\n     }\n   }\n \n+  abstract static class InvalidOverrideMethods {\n+    final void finalMethod() {\n+    }\n+\n+    private void privateMethod() {\n+    }\n+\n+    static void staticMethod() {\n+    }\n+  }\n+\n   @Test public void overrideEverything() {\n     TypeElement classElement = getElement(Everything.class);\n     ExecutableElement methodElement = getOnlyElement(methodsIn(classElement.getEnclosedElements()));\n@@ -146,6 +159,19 @@ public final class MethodSpecTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void overrideGenerics() {\n+    TypeElement classElement = getElement(Generics.class);\n+    ExecutableElement methodElement = getOnlyElement(methodsIn(classElement.getEnclosedElements()));\n+    MethodSpec method = MethodSpec.overriding(methodElement)\n+        .addStatement(\"return null\")\n+        .build();\n+    assertThat(method.toString()).isEqualTo(\"\"\n+        + \"@java.lang.Override\\n\"\n+        + \"<T, R, V extends java.lang.Throwable> T run(R param) throws V {\\n\"\n+        + \"  return null;\\n\"\n+        + \"}\\n\");\n+  }\n+\n   @Test public void overrideDoesNotCopyOverrideAnnotation() {\n     TypeElement classElement = getElement(HasAnnotation.class);\n     ExecutableElement exec = getOnlyElement(methodsIn(classElement.getEnclosedElements()));\n@@ -160,8 +186,7 @@ public final class MethodSpecTest {\n     TypeElement classElement = getElement(ExtendsIterableWithDefaultMethods.class);\n     DeclaredType classType = (DeclaredType) classElement.asType();\n     List<ExecutableElement> methods = methodsIn(elements.getAllMembers(classElement));\n-    ExecutableElement exec = findFirst(methods, \"iterator\");\n-    exec = findFirst(methods, \"spliterator\");\n+    ExecutableElement exec = findFirst(methods, \"spliterator\");\n     MethodSpec method = MethodSpec.overriding(exec, classType, types).build();\n     assertThat(method.toString()).isEqualTo(\"\"\n         + \"@java.lang.Override\\n\"\n@@ -206,27 +231,22 @@ public final class MethodSpecTest {\n   }\n \n   @Test public void overrideInvalidModifiers() {\n-    ExecutableElement method = mock(ExecutableElement.class);\n-    when(method.getModifiers()).thenReturn(ImmutableSet.of(Modifier.FINAL));\n-    Element element = mock(Element.class);\n-    when(element.asType()).thenReturn(mock(DeclaredType.class));\n-    when(method.getEnclosingElement()).thenReturn(element);\n+    TypeElement classElement = getElement(InvalidOverrideMethods.class);\n+    List<ExecutableElement> methods = methodsIn(elements.getAllMembers(classElement));\n     try {\n-      MethodSpec.overriding(method);\n+      MethodSpec.overriding(findFirst(methods, \"finalMethod\"));\n       fail();\n     } catch (IllegalArgumentException expected) {\n       assertThat(expected).hasMessageThat().isEqualTo(\"cannot override method with modifiers: [final]\");\n     }\n-    when(method.getModifiers()).thenReturn(ImmutableSet.of(Modifier.PRIVATE));\n     try {\n-      MethodSpec.overriding(method);\n+      MethodSpec.overriding(findFirst(methods, \"privateMethod\"));\n       fail();\n     } catch (IllegalArgumentException expected) {\n       assertThat(expected).hasMessageThat().isEqualTo(\"cannot override method with modifiers: [private]\");\n     }\n-    when(method.getModifiers()).thenReturn(ImmutableSet.of(Modifier.STATIC));\n     try {\n-      MethodSpec.overriding(method);\n+      MethodSpec.overriding(findFirst(methods, \"staticMethod\"));\n       fail();\n     } catch (IllegalArgumentException expected) {\n       assertThat(expected).hasMessageThat().isEqualTo(\"cannot override method with modifiers: [static]\");\n"
    },
    {
        "commit_hash": "d91f8e1374f7ccdb68d92c206c84864cd09c02f6",
        "previous_commit_hash": "adced314c48865463594bf58022f509090eef7af",
        "diff_stats": {
            "additions": 28,
            "deletions": 1
        },
        "diff_content": "@@ -48,9 +48,36 @@ public final class ArrayTypeName extends TypeName {\n   }\n \n   @Override CodeWriter emit(CodeWriter out) throws IOException {\n-    return out.emit(\"$T[]\", componentType);\n+    return emit(out, false);\n   }\n \n+  CodeWriter emit(CodeWriter out, boolean varargs) throws IOException {\n+    emitLeafType(out);\n+    return emitBrackets(out, varargs);\n+  }\n+\n+  private CodeWriter emitLeafType(CodeWriter out) throws IOException {\n+    if (TypeName.asArray(componentType) != null) {\n+      return TypeName.asArray(componentType).emitLeafType(out);\n+    }\n+    return componentType.emit(out);\n+  }\n+\n+  private CodeWriter emitBrackets(CodeWriter out, boolean varargs) throws IOException {\n+    if (isAnnotated()) {\n+      out.emit(\" \");\n+      emitAnnotations(out);\n+    }\n+\n+    if (TypeName.asArray(componentType) == null) {\n+      // Last bracket.\n+      return out.emit(varargs ? \"...\" : \"[]\");\n+    }\n+    out.emit(\"[]\");\n+    return TypeName.asArray(componentType) .emitBrackets(out, varargs);\n+  }\n+\n+\n   /** Returns an array type whose elements are all instances of {@code componentType}. */\n   public static ArrayTypeName of(TypeName componentType) {\n     return new ArrayTypeName(componentType);\n"
    },
    {
        "commit_hash": "d91f8e1374f7ccdb68d92c206c84864cd09c02f6",
        "previous_commit_hash": "adced314c48865463594bf58022f509090eef7af",
        "diff_stats": {
            "additions": 254,
            "deletions": 100
        },
        "diff_content": "@@ -17,7 +17,7 @@ package com.squareup.javapoet;\n \n import java.io.IOException;\n import java.util.ArrayList;\n-import java.util.Collections;\n+import java.util.Arrays;\n import java.util.List;\n import java.util.Map;\n import javax.lang.model.SourceVersion;\n@@ -32,106 +32,236 @@ import static javax.lang.model.element.NestingKind.MEMBER;\n import static javax.lang.model.element.NestingKind.TOP_LEVEL;\n \n /** A fully-qualified class name for top-level and member classes. */\n-public final class ClassName extends TypeName implements Comparable<ClassName> {\n-  public static final ClassName OBJECT = ClassName.get(Object.class);\n+public abstract class ClassName extends TypeName implements Comparable<ClassName> {\n+  final String simpleName;\n+  String canonicalName;\n \n-  /** From top to bottom. This will be [\"java.util\", \"Map\", \"Entry\"] for {@link Map.Entry}. */\n-  final List<String> names;\n-  final String canonicalName;\n+  /** A fully-qualified class name for top-level classes. */\n+  private static final class TopLevelClassName extends ClassName {\n+    final String packageName;\n \n-  private ClassName(List<String> names) {\n-    this(names, new ArrayList<>());\n-  }\n+    private TopLevelClassName(String packageName, String simpleName) {\n+      this(packageName, simpleName, new ArrayList<>());\n+    }\n \n-  private ClassName(List<String> names, List<AnnotationSpec> annotations) {\n-    super(annotations);\n-    for (int i = 1; i < names.size(); i++) {\n-      checkArgument(SourceVersion.isName(names.get(i)), \"part '%s' is keyword\", names.get(i));\n+    private TopLevelClassName(\n+        String packageName, String simpleName, List<AnnotationSpec> annotations) {\n+      super(simpleName, annotations);\n+      this.packageName = packageName == null ? \"\" : packageName;\n+      this.canonicalName = isDefaultPackage(packageName)\n+          ? simpleName : String.join(\".\", Arrays.asList(packageName, simpleName));\n+      checkArgument(\n+          isDefaultPackage(simpleName) || SourceVersion.isName(simpleName),\n+          \"part '%s' is keyword\", simpleName);\n+    }\n+\n+    @Override public TopLevelClassName annotated(List<AnnotationSpec> annotations) {\n+      return new TopLevelClassName(packageName, simpleName, concatAnnotations(annotations));\n+    }\n+\n+    @Override public TopLevelClassName withoutAnnotations() {\n+      return new TopLevelClassName(packageName, simpleName);\n+    }\n+\n+    public String packageName() {\n+      return packageName;\n+    }\n+\n+    @Override\n+    public ClassName enclosingClassName() {\n+      return null;\n+    }\n+\n+    @Override\n+    public TopLevelClassName topLevelClassName() {\n+      return this;\n+    }\n+\n+    @Override\n+    public String reflectionName() {\n+      return isDefaultPackage(packageName)\n+          ? simpleName\n+          : String.join(\".\", Arrays.asList(packageName, simpleName));\n+    }\n+\n+    @Override\n+    public List<String> simpleNames() {\n+      return Arrays.asList(simpleName);\n+    }\n+\n+    @Override\n+    public ClassName peerClass(String name) {\n+      return new TopLevelClassName(packageName, name);\n+    }\n+\n+    @Override\n+    ClassName prefixWithAtMostOneAnnotatedClass() {\n+      return this;\n+    }\n+\n+    @Override\n+    boolean hasAnnotatedEnclosingClass() {\n+      return false;\n+    }\n+\n+    @Override\n+    CodeWriter emitWithoutPrefix(CodeWriter out, ClassName unannotatedPrefix) {\n+      return out;\n     }\n-    this.names = Util.immutableList(names);\n-    this.canonicalName = (names.get(0).isEmpty()\n-        ? String.join(\".\", names.subList(1, names.size()))\n-        : String.join(\".\", names));\n   }\n \n-  @Override public ClassName annotated(List<AnnotationSpec> annotations) {\n-    return new ClassName(names, concatAnnotations(annotations));\n+  /** A fully-qualified class name for nested classes. */\n+  private static final class NestedClassName extends ClassName {\n+    /** From top to bottom. This will be [\"java.util\", \"Map\", \"Entry\"] for {@link Map.Entry}. */\n+    final ClassName enclosingClassName;\n+\n+    private NestedClassName(ClassName enclosingClassName, String simpleName) {\n+      this(enclosingClassName, simpleName, new ArrayList<>());\n+    }\n+\n+    private NestedClassName(\n+        ClassName enclosingClassName, String simpleName, List<AnnotationSpec> annotations) {\n+      super(simpleName, annotations);\n+      this.enclosingClassName = enclosingClassName;\n+      this.canonicalName =\n+          String.join(\".\", Arrays.asList(enclosingClassName.canonicalName, simpleName));\n+    }\n+\n+    @Override public NestedClassName annotated(List<AnnotationSpec> annotations) {\n+      return new NestedClassName(enclosingClassName, simpleName, concatAnnotations(annotations));\n+    }\n+\n+    @Override public NestedClassName withoutAnnotations() {\n+      return new NestedClassName(enclosingClassName.withoutAnnotations(), simpleName);\n+    }\n+\n+    /** Returns the package name, like {@code \"java.util\"} for {@code Map.Entry}. */\n+    public String packageName() {\n+      return enclosingClassName.packageName();\n+    }\n+\n+    @Override\n+    public ClassName enclosingClassName() {\n+      return enclosingClassName;\n+    }\n+\n+    @Override\n+    public ClassName topLevelClassName() {\n+      return enclosingClassName.topLevelClassName();\n+    }\n+\n+    @Override\n+    public String reflectionName() {\n+      return enclosingClassName.reflectionName() + \"$\" + simpleName;\n+    }\n+\n+    @Override\n+    public List<String> simpleNames() {\n+      List<String> simpleNames = new ArrayList<>(enclosingClassName().simpleNames());\n+      simpleNames.add(simpleName);\n+      return simpleNames;\n+    }\n+\n+    @Override\n+    public ClassName peerClass(String name) {\n+      return enclosingClassName.nestedClass(name);\n+    }\n+\n+    @Override\n+    ClassName prefixWithAtMostOneAnnotatedClass() {\n+      if (hasAnnotatedEnclosingClass()) {\n+        enclosingClassName.prefixWithAtMostOneAnnotatedClass();\n+      }\n+\n+      return this;\n+    }\n+\n+    @Override\n+    CodeWriter emitWithoutPrefix(\n+        CodeWriter out, ClassName unannotatedPrefix) throws IOException {\n+\n+      if (unannotatedPrefix.equals(this)) {\n+        return out;\n+      }\n+\n+      enclosingClassName.emitWithoutPrefix(out, unannotatedPrefix);\n+      out.emit(\".\");\n+      if (isAnnotated()) {\n+        out.emit(\" \");\n+        emitAnnotations(out);\n+      }\n+      return out.emit(simpleName);\n+    }\n+\n+    @Override\n+    boolean hasAnnotatedEnclosingClass() {\n+      return enclosingClassName.isAnnotated() || enclosingClassName.hasAnnotatedEnclosingClass();\n+    }\n   }\n \n-  @Override public ClassName withoutAnnotations() {\n-    return new ClassName(names);\n+  public static final ClassName OBJECT = ClassName.get(Object.class);\n+\n+  private ClassName(String simpleName, List<AnnotationSpec> annotations) {\n+    super(annotations);\n+    checkArgument(SourceVersion.isName(simpleName), \"part '%s' is keyword\", simpleName);\n+    this.simpleName = simpleName;\n   }\n \n+\n   /** Returns the package name, like {@code \"java.util\"} for {@code Map.Entry}. */\n-  public String packageName() {\n-    return names.get(0);\n-  }\n+  public abstract String packageName();\n \n   /**\n    * Returns the enclosing class, like {@link Map} for {@code Map.Entry}. Returns null if this class\n    * is not nested in another class.\n    */\n-  public ClassName enclosingClassName() {\n-    if (names.size() == 2) return null;\n-    return new ClassName(names.subList(0, names.size() - 1));\n-  }\n+  public abstract ClassName enclosingClassName();\n \n   /**\n    * Returns the top class in this nesting group. Equivalent to chained calls to {@link\n    * #enclosingClassName()} until the result's enclosing class is null.\n    */\n-  public ClassName topLevelClassName() {\n-    return new ClassName(names.subList(0, 2));\n-  }\n+  public abstract ClassName topLevelClassName();\n \n-  public String reflectionName() {\n-    // trivial case: no nested names\n-    if (names.size() == 2) {\n-      String packageName = packageName();\n-      if (packageName.isEmpty()) {\n-        return names.get(1);\n-      }\n-      return packageName + \".\" + names.get(1);\n-    }\n-    // concat top level class name and nested names\n-    StringBuilder builder = new StringBuilder();\n-    builder.append(topLevelClassName());\n-    for (String name : simpleNames().subList(1, simpleNames().size())) {\n-      builder.append('$').append(name);\n-    }\n-    return builder.toString();\n-  }\n+  /**\n+   * Return the binary name of a class.\n+   */\n+  public abstract String reflectionName();\n+\n+  public abstract ClassName withoutAnnotations();\n \n   /**\n    * Returns a new {@link ClassName} instance for the specified {@code name} as nested inside this\n    * class.\n    */\n   public ClassName nestedClass(String name) {\n-    checkNotNull(name, \"name == null\");\n-    List<String> result = new ArrayList<>(names.size() + 1);\n-    result.addAll(names);\n-    result.add(name);\n-    return new ClassName(result);\n+    return new NestedClassName(this, name);\n   }\n \n-  public List<String> simpleNames() {\n-    return names.subList(1, names.size());\n+  @Override\n+  public ClassName annotated(List<AnnotationSpec> annotations) {\n+    return (ClassName) super.annotated(annotations);\n   }\n \n+  public abstract List<String> simpleNames();\n+\n   /**\n    * Returns a class that shares the same enclosing package or class. If this class is enclosed by\n    * another class, this is equivalent to {@code enclosingClassName().nestedClass(name)}. Otherwise\n    * it is equivalent to {@code get(packageName(), name)}.\n    */\n-  public ClassName peerClass(String name) {\n-    List<String> result = new ArrayList<>(names);\n-    result.set(result.size() - 1, name);\n-    return new ClassName(result);\n-  }\n+  public abstract ClassName peerClass(String name);\n+\n+  abstract ClassName prefixWithAtMostOneAnnotatedClass();\n+\n+  abstract boolean hasAnnotatedEnclosingClass();\n+\n+  abstract CodeWriter emitWithoutPrefix(\n+      CodeWriter out, ClassName unannotatedPrefix) throws IOException;\n \n   /** Returns the simple name of this class, like {@code \"Entry\"} for {@link Map.Entry}. */\n   public String simpleName() {\n-    return names.get(names.size() - 1);\n+    return simpleName;\n   }\n \n   public static ClassName get(Class<?> clazz) {\n@@ -139,24 +269,23 @@ public final class ClassName extends TypeName implements Comparable<ClassName> {\n     checkArgument(!clazz.isPrimitive(), \"primitive types cannot be represented as a ClassName\");\n     checkArgument(!void.class.equals(clazz), \"'void' type cannot be represented as a ClassName\");\n     checkArgument(!clazz.isArray(), \"array types cannot be represented as a ClassName\");\n-    List<String> names = new ArrayList<>();\n-    while (true) {\n-      String anonymousSuffix = \"\";\n-      while (clazz.isAnonymousClass()) {\n-        int lastDollar = clazz.getName().lastIndexOf('$');\n-        anonymousSuffix = clazz.getName().substring(lastDollar) + anonymousSuffix;\n-        clazz = clazz.getEnclosingClass();\n-      }\n-      names.add(clazz.getSimpleName() + anonymousSuffix);\n-      Class<?> enclosing = clazz.getEnclosingClass();\n-      if (enclosing == null) break;\n-      clazz = enclosing;\n-    }\n-    // Avoid unreliable Class.getPackage(). https://github.com/square/javapoet/issues/295\n-    int lastDot = clazz.getName().lastIndexOf('.');\n-    if (lastDot != -1) names.add(clazz.getName().substring(0, lastDot));\n-    Collections.reverse(names);\n-    return new ClassName(names);\n+\n+    String anonymousSuffix = \"\";\n+    while (clazz.isAnonymousClass()) {\n+      int lastDollar = clazz.getName().lastIndexOf('$');\n+      anonymousSuffix = clazz.getName().substring(lastDollar) + anonymousSuffix;\n+      clazz = clazz.getEnclosingClass();\n+    }\n+    String name = clazz.getSimpleName() + anonymousSuffix;\n+\n+    if (clazz.getEnclosingClass() == null) {\n+      // Avoid unreliable Class.getPackage(). https://github.com/square/javapoet/issues/295\n+      int lastDot = clazz.getName().lastIndexOf('.');\n+      String packageName = (lastDot != -1)  ? clazz.getName().substring(0, lastDot) : null;\n+      return new TopLevelClassName(packageName, name);\n+    }\n+\n+    return ClassName.get(clazz.getEnclosingClass()).nestedClass(name);\n   }\n \n   /**\n@@ -176,17 +305,24 @@ public final class ClassName extends TypeName implements Comparable<ClassName> {\n       p = classNameString.indexOf('.', p) + 1;\n       checkArgument(p != 0, \"couldn't make a guess for %s\", classNameString);\n     }\n-    names.add(p != 0 ? classNameString.substring(0, p - 1) : \"\");\n+    String packageName = p == 0 ? null : classNameString.substring(0, p - 1);\n+    String[] classNames = classNameString.substring(p).split(\"\\\\.\", -1);\n+\n+    checkArgument(classNames.length >= 1, \"couldn't make a guess for %s\", classNameString);\n+\n+    String simpleName = classNames[0];\n+    checkArgument(!simpleName.isEmpty() && Character.isUpperCase(simpleName.codePointAt(0)),\n+        \"couldn't make a guess for %s\", classNameString);\n+    ClassName className = new TopLevelClassName(packageName, simpleName);\n \n     // Add the class names, like \"Map\" and \"Entry\".\n-    for (String part : classNameString.substring(p).split(\"\\\\.\", -1)) {\n+    for (String part : Arrays.asList(classNames).subList(1, classNames.length)) {\n       checkArgument(!part.isEmpty() && Character.isUpperCase(part.codePointAt(0)),\n           \"couldn't make a guess for %s\", classNameString);\n-      names.add(part);\n+      className = className.nestedClass(part);\n     }\n \n-    checkArgument(names.size() >= 2, \"couldn't make a guess for %s\", classNameString);\n-    return new ClassName(names);\n+    return className;\n   }\n \n   /**\n@@ -194,25 +330,26 @@ public final class ClassName extends TypeName implements Comparable<ClassName> {\n    * {@code \"java.util\"} and simple names {@code \"Map\"}, {@code \"Entry\"} yields {@link Map.Entry}.\n    */\n   public static ClassName get(String packageName, String simpleName, String... simpleNames) {\n-    List<String> result = new ArrayList<>();\n-    result.add(packageName);\n-    result.add(simpleName);\n-    Collections.addAll(result, simpleNames);\n-    return new ClassName(result);\n+    ClassName className = new TopLevelClassName(packageName, simpleName);\n+    for (String name : simpleNames) {\n+      className = className.nestedClass(name);\n+    }\n+    return className;\n   }\n \n   /** Returns the class name for {@code element}. */\n   public static ClassName get(TypeElement element) {\n     checkNotNull(element, \"element == null\");\n-    List<String> names = new ArrayList<>();\n-    for (Element e = element; isClassOrInterface(e); e = e.getEnclosingElement()) {\n-      checkArgument(element.getNestingKind() == TOP_LEVEL || element.getNestingKind() == MEMBER,\n-          \"unexpected type testing\");\n-      names.add(e.getSimpleName().toString());\n-    }\n-    names.add(getPackage(element).getQualifiedName().toString());\n-    Collections.reverse(names);\n-    return new ClassName(names);\n+    checkArgument(element.getNestingKind() == TOP_LEVEL || element.getNestingKind() == MEMBER,\n+        \"unexpected type nesting\");\n+    String simpleName = element.getSimpleName().toString();\n+\n+    if (isClassOrInterface(element.getEnclosingElement())) {\n+      return ClassName.get((TypeElement) element.getEnclosingElement()).nestedClass(simpleName);\n+    }\n+\n+    String packageName = getPackage(element.getEnclosingElement()).getQualifiedName().toString();\n+    return new TopLevelClassName(packageName, simpleName);\n   }\n \n   private static boolean isClassOrInterface(Element e) {\n@@ -227,10 +364,27 @@ public final class ClassName extends TypeName implements Comparable<ClassName> {\n   }\n \n   @Override public int compareTo(ClassName o) {\n-    return canonicalName.compareTo(o.canonicalName);\n+    return reflectionName().compareTo(o.reflectionName());\n   }\n \n   @Override CodeWriter emit(CodeWriter out) throws IOException {\n-    return out.emitAndIndent(out.lookupName(this));\n+    ClassName prefix = prefixWithAtMostOneAnnotatedClass();\n+    String unqualifiedName = out.lookupName(prefix);\n+    if (prefix.isAnnotated())  {\n+      int dot = unqualifiedName.lastIndexOf(\".\");\n+      out.emitAndIndent(unqualifiedName.substring(0, dot + 1));\n+      if (dot != -1) {\n+        out.emit(\" \");\n+      }\n+      prefix.emitAnnotations(out);\n+      out.emit(unqualifiedName.substring(dot + 1));\n+    } else {\n+        out.emitAndIndent(unqualifiedName);\n+    }\n+    return emitWithoutPrefix(out, prefix);\n+  }\n+\n+  private static boolean isDefaultPackage(String packageName) {\n+    return packageName == null || packageName.isEmpty();\n   }\n }\n"
    },
    {
        "commit_hash": "d91f8e1374f7ccdb68d92c206c84864cd09c02f6",
        "previous_commit_hash": "adced314c48865463594bf58022f509090eef7af",
        "diff_stats": {
            "additions": 0,
            "deletions": 4
        },
        "diff_content": "@@ -236,10 +236,6 @@ final class CodeWriter {\n \n         case \"$T\":\n           TypeName typeName = (TypeName) codeBlock.args.get(a++);\n-          if (typeName.isAnnotated()) {\n-            typeName.emitAnnotations(this);\n-            typeName = typeName.withoutAnnotations();\n-          }\n           // defer \"typeName.emit(this)\" if next format part will be handled by the default case\n           if (typeName instanceof ClassName && partIterator.hasNext()) {\n             if (!codeBlock.formatParts.get(partIterator.nextIndex()).startsWith(\"$\")) {\n"
    },
    {
        "commit_hash": "d91f8e1374f7ccdb68d92c206c84864cd09c02f6",
        "previous_commit_hash": "adced314c48865463594bf58022f509090eef7af",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -145,7 +145,7 @@ public final class JavaFile {\n     int importedTypesCount = 0;\n     for (ClassName className : new TreeSet<>(codeWriter.importedTypes().values())) {\n       if (skipJavaLangImports && className.packageName().equals(\"java.lang\")) continue;\n-      codeWriter.emit(\"import $L;\\n\", className);\n+      codeWriter.emit(\"import $L;\\n\", className.withoutAnnotations());\n       importedTypesCount++;\n     }\n \n"
    },
    {
        "commit_hash": "d91f8e1374f7ccdb68d92c206c84864cd09c02f6",
        "previous_commit_hash": "adced314c48865463594bf58022f509090eef7af",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -77,7 +77,7 @@ public final class MethodSpec {\n \n   private boolean lastParameterIsArray(List<ParameterSpec> parameters) {\n     return !parameters.isEmpty()\n-        && TypeName.arrayComponent(parameters.get(parameters.size() - 1).type) != null;\n+        && TypeName.asArray((parameters.get(parameters.size() - 1).type)) != null;\n   }\n \n   void emit(CodeWriter codeWriter, String enclosingName, Set<Modifier> implicitModifiers)\n"
    },
    {
        "commit_hash": "d91f8e1374f7ccdb68d92c206c84864cd09c02f6",
        "previous_commit_hash": "adced314c48865463594bf58022f509090eef7af",
        "diff_stats": {
            "additions": 3,
            "deletions": 2
        },
        "diff_content": "@@ -51,10 +51,11 @@ public final class ParameterSpec {\n     codeWriter.emitAnnotations(annotations, true);\n     codeWriter.emitModifiers(modifiers);\n     if (varargs) {\n-      codeWriter.emit(\"$T... $L\", TypeName.arrayComponent(type), name);\n+      TypeName.asArray(type).emit(codeWriter, true);\n     } else {\n-      codeWriter.emit(\"$T $L\", type, name);\n+      type.emit(codeWriter);\n     }\n+    codeWriter.emit(\" $L\", name);\n   }\n \n   @Override public boolean equals(Object o) {\n"
    },
    {
        "commit_hash": "d91f8e1374f7ccdb68d92c206c84864cd09c02f6",
        "previous_commit_hash": "adced314c48865463594bf58022f509090eef7af",
        "diff_stats": {
            "additions": 11,
            "deletions": 7
        },
        "diff_content": "@@ -41,7 +41,7 @@ public final class ParameterizedTypeName extends TypeName {\n   private ParameterizedTypeName(ParameterizedTypeName enclosingType, ClassName rawType,\n       List<TypeName> typeArguments, List<AnnotationSpec> annotations) {\n     super(annotations);\n-    this.rawType = checkNotNull(rawType, \"rawType == null\");\n+    this.rawType = checkNotNull(rawType, \"rawType == null\").annotated(annotations);\n     this.enclosingType = enclosingType;\n     this.typeArguments = Util.immutableList(typeArguments);\n \n@@ -58,17 +58,22 @@ public final class ParameterizedTypeName extends TypeName {\n         enclosingType, rawType, typeArguments, concatAnnotations(annotations));\n   }\n \n-  @Override public TypeName withoutAnnotations() {\n-    return new ParameterizedTypeName(enclosingType, rawType, typeArguments, new ArrayList<>());\n+  @Override\n+  public TypeName withoutAnnotations() {\n+    return new ParameterizedTypeName(\n+        enclosingType, rawType.withoutAnnotations(), typeArguments, new ArrayList<>());\n   }\n \n   @Override CodeWriter emit(CodeWriter out) throws IOException {\n     if (enclosingType != null) {\n-      enclosingType.emitAnnotations(out);\n       enclosingType.emit(out);\n-      out.emit(\".\" + rawType.simpleName());\n+      out.emit(\".\");\n+      if (isAnnotated()) {\n+        out.emit(\" \");\n+        emitAnnotations(out);\n+      }\n+      out.emit(rawType.simpleName());\n     } else {\n-      rawType.emitAnnotations(out);\n       rawType.emit(out);\n     }\n     if (!typeArguments.isEmpty()) {\n@@ -76,7 +81,6 @@ public final class ParameterizedTypeName extends TypeName {\n       boolean firstParameter = true;\n       for (TypeName parameter : typeArguments) {\n         if (!firstParameter) out.emitAndIndent(\", \");\n-        parameter.emitAnnotations(out);\n         parameter.emit(out);\n         firstParameter = false;\n       }\n"
    },
    {
        "commit_hash": "d91f8e1374f7ccdb68d92c206c84864cd09c02f6",
        "previous_commit_hash": "adced314c48865463594bf58022f509090eef7af",
        "diff_stats": {
            "additions": 14,
            "deletions": 1
        },
        "diff_content": "@@ -209,7 +209,6 @@ public class TypeName {\n       try {\n         StringBuilder resultBuilder = new StringBuilder();\n         CodeWriter codeWriter = new CodeWriter(resultBuilder);\n-        emitAnnotations(codeWriter);\n         emit(codeWriter);\n         result = resultBuilder.toString();\n         cachedString = result;\n@@ -222,6 +221,11 @@ public class TypeName {\n \n   CodeWriter emit(CodeWriter out) throws IOException {\n     if (keyword == null) throw new AssertionError();\n+\n+    if (isAnnotated()) {\n+      out.emit(\"\");\n+      emitAnnotations(out);\n+    }\n     return out.emitAndIndent(keyword);\n   }\n \n@@ -233,6 +237,7 @@ public class TypeName {\n     return out;\n   }\n \n+\n   /** Returns a type name equivalent to {@code mirror}. */\n   public static TypeName get(TypeMirror mirror) {\n     return get(mirror, new LinkedHashMap<>());\n@@ -369,4 +374,12 @@ public class TypeName {\n         ? ((ArrayTypeName) type).componentType\n         : null;\n   }\n+\n+  /** Returns {@code type} as an array, or null if {@code type} is not an array. */\n+  static ArrayTypeName asArray(TypeName type) {\n+    return type instanceof ArrayTypeName\n+        ? ((ArrayTypeName) type)\n+        : null;\n+  }\n+\n }\n"
    },
    {
        "commit_hash": "d91f8e1374f7ccdb68d92c206c84864cd09c02f6",
        "previous_commit_hash": "adced314c48865463594bf58022f509090eef7af",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -80,6 +80,7 @@ public final class TypeVariableName extends TypeName {\n   }\n \n   @Override CodeWriter emit(CodeWriter out) throws IOException {\n+    emitAnnotations(out);\n     return out.emitAndIndent(name);\n   }\n \n"
    },
    {
        "commit_hash": "d91f8e1374f7ccdb68d92c206c84864cd09c02f6",
        "previous_commit_hash": "adced314c48865463594bf58022f509090eef7af",
        "diff_stats": {
            "additions": 94,
            "deletions": 46
        },
        "diff_content": "@@ -15,6 +15,7 @@\n  */\n package com.squareup.javapoet;\n \n+import static com.google.common.truth.Truth.assertThat;\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertNotEquals;\n@@ -24,16 +25,23 @@ import java.lang.annotation.ElementType;\n import java.lang.annotation.Target;\n import java.util.List;\n import java.util.Map;\n-import org.junit.Ignore;\n import org.junit.Test;\n \n public class AnnotatedTypeNameTest {\n \n   private final static String NN = NeverNull.class.getCanonicalName();\n   private final AnnotationSpec NEVER_NULL = AnnotationSpec.builder(NeverNull.class).build();\n+  private final static String TUA = TypeUseAnnotation.class.getCanonicalName();\n+  private final AnnotationSpec TYPE_USE_ANNOTATION =\n+      AnnotationSpec.builder(TypeUseAnnotation.class).build();\n \n+  @Target(ElementType.TYPE_USE)\n   public @interface NeverNull {}\n \n+  @Target(ElementType.TYPE_USE)\n+  public @interface TypeUseAnnotation {}\n+\n+\n   @Test(expected=NullPointerException.class) public void nullAnnotationArray() {\n     TypeName.BOOLEAN.annotated((AnnotationSpec[]) null);\n   }\n@@ -46,55 +54,49 @@ public class AnnotatedTypeNameTest {\n     TypeName simpleString = TypeName.get(String.class);\n     assertFalse(simpleString.isAnnotated());\n     assertEquals(simpleString, TypeName.get(String.class));\n+\n     TypeName annotated = simpleString.annotated(NEVER_NULL);\n     assertTrue(annotated.isAnnotated());\n     assertEquals(annotated, annotated.annotated());\n   }\n \n   @Test public void annotatedType() {\n-    String expected = \"@\" + NN + \" java.lang.String\";\n     TypeName type = TypeName.get(String.class);\n-    String actual = type.annotated(NEVER_NULL).toString();\n-    assertEquals(expected, actual);\n+    TypeName actual = type.annotated(TYPE_USE_ANNOTATION);\n+    assertThat(actual.toString()).isEqualTo(\"java.lang. @\" + TUA + \" String\");\n   }\n \n   @Test public void annotatedTwice() {\n-    String expected = \"@\" + NN + \" @java.lang.Override java.lang.String\";\n     TypeName type = TypeName.get(String.class);\n-    String actual =\n+    TypeName actual =\n         type.annotated(NEVER_NULL)\n-            .annotated(AnnotationSpec.builder(Override.class).build())\n-            .toString();\n-    assertEquals(expected, actual);\n+            .annotated(TYPE_USE_ANNOTATION);\n+    assertThat(actual.toString())\n+        .isEqualTo(\"java.lang. @\" + NN + \" @\" + TUA + \" String\");\n   }\n \n   @Test public void annotatedParameterizedType() {\n-    String expected = \"@\" + NN + \" java.util.List<java.lang.String>\";\n     TypeName type = ParameterizedTypeName.get(List.class, String.class);\n-    String actual = type.annotated(NEVER_NULL).toString();\n-    assertEquals(expected, actual);\n+    TypeName actual = type.annotated(TYPE_USE_ANNOTATION);\n+    assertThat(actual.toString()).isEqualTo(\"java.util. @\" + TUA + \" List<java.lang.String>\");\n   }\n \n   @Test public void annotatedArgumentOfParameterizedType() {\n-    String expected = \"java.util.List<@\" + NN + \" java.lang.String>\";\n-    TypeName type = TypeName.get(String.class).annotated(NEVER_NULL);\n-    ClassName list = ClassName.get(List.class);\n-    String actual = ParameterizedTypeName.get(list, type).toString();\n-    assertEquals(expected, actual);\n+    TypeName type = TypeName.get(String.class).annotated(TYPE_USE_ANNOTATION);\n+    TypeName actual = ParameterizedTypeName.get(ClassName.get(List.class), type);\n+    assertThat(actual.toString()).isEqualTo(\"java.util.List<java.lang. @\" + TUA + \" String>\");\n   }\n \n   @Test public void annotatedWildcardTypeNameWithSuper() {\n-    String expected = \"? super @\" + NN + \" java.lang.String\";\n-    TypeName type = TypeName.get(String.class).annotated(NEVER_NULL);\n-    String actual = WildcardTypeName.supertypeOf(type).toString();\n-    assertEquals(expected, actual);\n+    TypeName type = TypeName.get(String.class).annotated(TYPE_USE_ANNOTATION);\n+    TypeName actual = WildcardTypeName.supertypeOf(type);\n+    assertThat(actual.toString()).isEqualTo(\"? super java.lang. @\" + TUA + \" String\");\n   }\n \n   @Test public void annotatedWildcardTypeNameWithExtends() {\n-    String expected = \"? extends @\" + NN + \" java.lang.String\";\n-    TypeName type = TypeName.get(String.class).annotated(NEVER_NULL);\n-    String actual = WildcardTypeName.subtypeOf(type).toString();\n-    assertEquals(expected, actual);\n+    TypeName type = TypeName.get(String.class).annotated(TYPE_USE_ANNOTATION);\n+    TypeName actual = WildcardTypeName.subtypeOf(type);\n+    assertThat(actual.toString()).isEqualTo(\"? extends java.lang. @\" + TUA + \" String\");\n   }\n \n   @Test public void annotatedEquivalence() {\n@@ -109,34 +111,80 @@ public class AnnotatedTypeNameTest {\n   private void annotatedEquivalence(TypeName type) {\n     assertFalse(type.isAnnotated());\n     assertEquals(type, type);\n-    assertEquals(type.annotated(NEVER_NULL), type.annotated(NEVER_NULL));\n-    assertNotEquals(type, type.annotated(NEVER_NULL));\n+    assertEquals(type.annotated(TYPE_USE_ANNOTATION), type.annotated(TYPE_USE_ANNOTATION));\n+    assertNotEquals(type, type.annotated(TYPE_USE_ANNOTATION));\n     assertEquals(type.hashCode(), type.hashCode());\n-    assertEquals(type.annotated(NEVER_NULL).hashCode(), type.annotated(NEVER_NULL).hashCode());\n-    assertNotEquals(type.hashCode(), type.annotated(NEVER_NULL).hashCode());\n+    assertEquals(type.annotated(TYPE_USE_ANNOTATION).hashCode(),\n+        type.annotated(TYPE_USE_ANNOTATION).hashCode());\n+    assertNotEquals(type.hashCode(), type.annotated(TYPE_USE_ANNOTATION).hashCode());\n   }\n \n   // https://github.com/square/javapoet/issues/431\n-  @Target(ElementType.TYPE_USE)\n-  public @interface TypeUseAnnotation {}\n-\n-  // https://github.com/square/javapoet/issues/431\n-  @Ignore @Test public void annotatedNestedType() {\n-    String expected = \"java.util.Map.@\" + TypeUseAnnotation.class.getCanonicalName() + \" Entry\";\n-    AnnotationSpec typeUseAnnotation = AnnotationSpec.builder(TypeUseAnnotation.class).build();\n-    TypeName type = TypeName.get(Map.Entry.class).annotated(typeUseAnnotation);\n-    String actual = type.toString();\n-    assertEquals(expected, actual);\n+  @Test public void annotatedNestedType() {\n+    TypeName type = TypeName.get(Map.Entry.class).annotated(TYPE_USE_ANNOTATION);\n+    assertThat(type.toString()).isEqualTo(\"java.util.Map. @\" + TUA + \" Entry\");\n   }\n \n   // https://github.com/square/javapoet/issues/431\n-  @Ignore @Test public void annotatedNestedParameterizedType() {\n-    String expected = \"java.util.Map.@\" + TypeUseAnnotation.class.getCanonicalName()\n-        + \" Entry<java.lang.Byte, java.lang.Byte>\";\n-    AnnotationSpec typeUseAnnotation = AnnotationSpec.builder(TypeUseAnnotation.class).build();\n+  @Test public void annotatedNestedParameterizedType() {\n     TypeName type = ParameterizedTypeName.get(Map.Entry.class, Byte.class, Byte.class)\n-        .annotated(typeUseAnnotation);\n-    String actual = type.toString();\n-    assertEquals(expected, actual);\n+        .annotated(TYPE_USE_ANNOTATION);\n+    assertThat(type.toString())\n+        .isEqualTo(\"java.util.Map. @\" + TUA + \" Entry<java.lang.Byte, java.lang.Byte>\");\n+  }\n+\n+  // https://github.com/square/javapoet/issues/614\n+   @Test public void annotatedArrayType() {\n+    TypeName type = ArrayTypeName.of(ClassName.get(Object.class)).annotated(TYPE_USE_ANNOTATION);\n+    assertThat(type.toString()).isEqualTo(\"java.lang.Object @\" + TUA + \" []\");\n+  }\n+\n+  @Test public void annotatedArrayElementType() {\n+    TypeName type = ArrayTypeName.of(ClassName.get(Object.class).annotated(TYPE_USE_ANNOTATION));\n+    assertThat(type.toString()).isEqualTo(\"java.lang. @\" + TUA + \" Object[]\");\n+  }\n+\n+  // https://github.com/square/javapoet/issues/614\n+  @Test public void annotatedOuterMultidimensionalArrayType() {\n+    TypeName type = ArrayTypeName.of(ArrayTypeName.of(ClassName.get(Object.class)))\n+        .annotated(TYPE_USE_ANNOTATION);\n+    assertThat(type.toString()).isEqualTo(\"java.lang.Object @\" + TUA + \" [][]\");\n+  }\n+\n+  // https://github.com/square/javapoet/issues/614\n+  @Test public void annotatedInnerMultidimensionalArrayType() {\n+    TypeName type = ArrayTypeName.of(ArrayTypeName.of(ClassName.get(Object.class))\n+        .annotated(TYPE_USE_ANNOTATION));\n+    assertThat(type.toString()).isEqualTo(\"java.lang.Object[] @\" + TUA + \" []\");\n+  }\n+\n+  // https://github.com/square/javapoet/issues/614\n+  @Test public void annotatedArrayTypeVarargsParameter() {\n+    TypeName type = ArrayTypeName.of(ArrayTypeName.of(ClassName.get(Object.class)))\n+        .annotated(TYPE_USE_ANNOTATION);\n+    MethodSpec varargsMethod = MethodSpec.methodBuilder(\"m\")\n+        .addParameter(\n+            ParameterSpec.builder(type, \"p\")\n+                .build())\n+        .varargs()\n+        .build();\n+    assertThat(varargsMethod.toString()).isEqualTo(\"\"\n+        + \"void m(java.lang.Object @\" + TUA + \" []... p) {\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  // https://github.com/square/javapoet/issues/614\n+  @Test public void annotatedArrayTypeInVarargsParameter() {\n+    TypeName type = ArrayTypeName.of(ArrayTypeName.of(ClassName.get(Object.class))\n+        .annotated(TYPE_USE_ANNOTATION));\n+    MethodSpec varargsMethod = MethodSpec.methodBuilder(\"m\")\n+        .addParameter(\n+            ParameterSpec.builder(type, \"p\")\n+                .build())\n+        .varargs()\n+        .build();\n+    assertThat(varargsMethod.toString()).isEqualTo(\"\"\n+        + \"void m(java.lang.Object[] @\" + TUA + \" ... p) {\\n\"\n+        + \"}\\n\");\n   }\n }\n"
    },
    {
        "commit_hash": "f24801f4bdafa1190211959653b2eb31296cfbb3",
        "previous_commit_hash": "d91f8e1374f7ccdb68d92c206c84864cd09c02f6",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -435,6 +435,7 @@ public final class TypeSpec {\n     }\n \n     public Builder addAnnotation(AnnotationSpec annotationSpec) {\n+      checkNotNull(annotationSpec, \"annotationSpec == null\");\n       this.annotations.add(annotationSpec);\n       return this;\n     }\n"
    },
    {
        "commit_hash": "f24801f4bdafa1190211959653b2eb31296cfbb3",
        "previous_commit_hash": "d91f8e1374f7ccdb68d92c206c84864cd09c02f6",
        "diff_stats": {
            "additions": 21,
            "deletions": 0
        },
        "diff_content": "@@ -325,6 +325,27 @@ public final class TypeSpecTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void addAnnotationDisallowsNull() {\n+    try {\n+      TypeSpec.classBuilder(\"Foo\").addAnnotation((AnnotationSpec) null);\n+      fail();\n+    } catch (NullPointerException expected) {\n+      assertThat(expected).hasMessageThat().isEqualTo(\"annotationSpec == null\");\n+    }\n+    try {\n+      TypeSpec.classBuilder(\"Foo\").addAnnotation((ClassName) null);\n+      fail();\n+    } catch (NullPointerException expected) {\n+      assertThat(expected).hasMessageThat().isEqualTo(\"type == null\");\n+    }\n+    try {\n+      TypeSpec.classBuilder(\"Foo\").addAnnotation((Class<?>) null);\n+      fail();\n+    } catch (NullPointerException expected) {\n+      assertThat(expected).hasMessageThat().isEqualTo(\"clazz == null\");\n+    }\n+  }\n+\n   @Test public void enumWithSubclassing() throws Exception {\n     TypeSpec roshambo = TypeSpec.enumBuilder(\"Roshambo\")\n         .addModifiers(Modifier.PUBLIC)\n"
    },
    {
        "commit_hash": "24c88ec21cb1297bfc92a747fa1f714514720cdc",
        "previous_commit_hash": "8ab7616e7d1acc76231bea1aa283c0fdefa24864",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -48,7 +48,7 @@ type, parameters and code statements. We add the main method to a `HelloWorld` c\n that to a `HelloWorld.java` file.\n \n In this case we write the file to `System.out`, but we could also get it as a string\n-(`JavaFile.toString()`) or write it to the file system (`JavaPoet.writeTo()`).\n+(`JavaFile.toString()`) or write it to the file system (`JavaFile.writeTo()`).\n \n The [Javadoc][javadoc] catalogs the complete JavaPoet API, which we explore below.\n \n"
    },
    {
        "commit_hash": "9ea843d73170f75d735114cdca6ba2463965cafb",
        "previous_commit_hash": "8e9b2ec3c3e9d09e19c88ef3d1fc92ab2f6472e2",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -104,7 +104,7 @@ we want to make the operation and range configurable. Here's a method that gener\n private MethodSpec computeRange(String name, int from, int to, String op) {\n   return MethodSpec.methodBuilder(name)\n       .returns(int.class)\n-      .addStatement(\"int result = 0\")\n+      .addStatement(\"int result = 1\")\n       .beginControlFlow(\"for (int i = \" + from + \"; i < \" + to + \"; i++)\")\n       .addStatement(\"result = result \" + op + \" i\")\n       .endControlFlow()\n@@ -117,7 +117,7 @@ And here's what we get when we call `computeRange(\"multiply10to20\", 10, 20, \"*\")\n \n ```java\n int multiply10to20() {\n-  int result = 0;\n+  int result = 1;\n   for (int i = 10; i < 20; i++) {\n     result = result * i;\n   }\n"
    },
    {
        "commit_hash": "bc7f6dc607c233c6bc62a39471905d98f737b9d8",
        "previous_commit_hash": "8e9b2ec3c3e9d09e19c88ef3d1fc92ab2f6472e2",
        "diff_stats": {
            "additions": 0,
            "deletions": 2
        },
        "diff_content": "@@ -297,8 +297,6 @@ public abstract class ClassName extends TypeName implements Comparable<ClassName\n    * instances without such restrictions.\n    */\n   public static ClassName bestGuess(String classNameString) {\n-    List<String> names = new ArrayList<>();\n-\n     // Add the package name, like \"java.util.concurrent\", or \"\" for no package.\n     int p = 0;\n     while (p < classNameString.length() && Character.isLowerCase(classNameString.codePointAt(p))) {\n"
    },
    {
        "commit_hash": "3c68a054848124bf53aa2f73b1c310c6fffa3d0b",
        "previous_commit_hash": "adced314c48865463594bf58022f509090eef7af",
        "diff_stats": {
            "additions": 0,
            "deletions": 43
        },
        "diff_content": "@@ -1,43 +0,0 @@\n-#!/bin/bash\n-#\n-# Install JDK from \"download.java.net\"\n-#\n-# Adapted from https://github.com/sormuras/bach/blob/master/install-jdk.sh\n-#\n-\n-set -e\n-\n-JDK_FEATURE='10'\n-\n-TMP=$(curl -L jdk.java.net/${JDK_FEATURE})\n-TMP=\"${TMP#*Most recent build: jdk-${JDK_FEATURE}+}\"    # remove everything before the number\n-TMP=\"${TMP%%<*}\"                                        # remove everything after the number\n-JDK_BUILD=\"$(echo -e \"${TMP}\" | tr -d '[:space:]')\"     # remove all whitespace\n-\n-JDK_LICENSE='GPL'\n-\n-while getopts F:B:L: option\n-do\n- case \"${option}\"\n- in\n- F) JDK_FEATURE=${OPTARG};;\n- B) JDK_BUILD=${OPTARG};;\n- L) JDK_LICENSE=${OPTARG};;\n- esac\n-done\n-\n-JDK_BASENAME='jdk'\n-if [ \"${JDK_LICENSE}\" == 'GPL' ]; then\n-  JDK_BASENAME='openjdk'\n-fi\n-\n-JDK_ARCHIVE=${JDK_BASENAME}-${JDK_FEATURE}+${JDK_BUILD}_linux-x64_bin.tar.gz\n-\n-cd ~\n-wget http://download.java.net/java/jdk${JDK_FEATURE}/archive/${JDK_BUILD}/${JDK_LICENSE}/${JDK_ARCHIVE}\n-tar -xzf ${JDK_ARCHIVE}\n-export JAVA_HOME=~/jdk-${JDK_FEATURE}\n-export PATH=${JAVA_HOME}/bin:$PATH\n-cd -\n-\n-java --version\n"
    },
    {
        "commit_hash": "3c68a054848124bf53aa2f73b1c310c6fffa3d0b",
        "previous_commit_hash": "adced314c48865463594bf58022f509090eef7af",
        "diff_stats": {
            "additions": 18,
            "deletions": 5
        },
        "diff_content": "@@ -2,14 +2,27 @@ language: java\n \n matrix:\n   include:\n-    - env: JDK='OracleJDK 8'\n+    - env: JDK='Oracle JDK 8'\n       jdk: oraclejdk8\n-    - env: JDK='OracleJDK 9'\n+    - env: JDK='Oracle JDK 9'\n       jdk: oraclejdk9\n-    - env: JDK='OracleJDK 10'\n-      install: . ./.buildscript/install-jdk.sh -F 10 -L BCL\n+    - env: JDK='Oracle JDK 10'\n+      install: . ./install-jdk.sh -F 10 -L BCL\n     - env: JDK='OpenJDK 10'\n-      install: . ./.buildscript/install-jdk.sh -F 10 -L GPL\n+      install: . ./install-jdk.sh -F 10 -L GPL\n+    - env: JDK='Oracle JDK 11'\n+      install: . ./install-jdk.sh -F 11 -L BCL\n+    - env: JDK='OpenJDK 11'\n+      install: . ./install-jdk.sh -F 11 -L GPL\n+  allow_failures:\n+    # ErrorProne/javac is not yet working on JDK 11\n+    - env: JDK='Oracle JDK 11'\n+    - env: JDK='OpenJDK 11'\n+\n+# Direct usage of `install-jdk.sh` might be superseded by https://github.com/travis-ci/travis-build/pull/1347\n+before_install:\n+  - unset _JAVA_OPTIONS\n+  - wget https://github.com/sormuras/bach/raw/1.0.1/install-jdk.sh\n \n after_success:\n   - .buildscript/deploy_snapshot.sh\n"
    },
    {
        "commit_hash": "491ff3cced8f79d8636bdc3f4a7ae5a76b834ac7",
        "previous_commit_hash": "034f0b6801eda34c96d880051f4611555a948ffb",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -110,7 +110,7 @@\n           <dependency>\n             <groupId>com.google.errorprone</groupId>\n             <artifactId>error_prone_core</artifactId>\n-            <version>2.2.0</version>\n+            <version>2.3.1</version>\n           </dependency>\n         </dependencies>\n       </plugin>\n"
    },
    {
        "commit_hash": "b1e1a088321da708d3299138fc55c0a9976a6291",
        "previous_commit_hash": "034f0b6801eda34c96d880051f4611555a948ffb",
        "diff_stats": {
            "additions": 122,
            "deletions": 226
        },
        "diff_content": "@@ -17,10 +17,9 @@ package com.squareup.javapoet;\n \n import java.io.IOException;\n import java.util.ArrayList;\n-import java.util.Arrays;\n+import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n-import javax.lang.model.SourceVersion;\n import javax.lang.model.element.Element;\n import javax.lang.model.element.ElementKind;\n import javax.lang.model.element.PackageElement;\n@@ -32,232 +31,109 @@ import static javax.lang.model.element.NestingKind.MEMBER;\n import static javax.lang.model.element.NestingKind.TOP_LEVEL;\n \n /** A fully-qualified class name for top-level and member classes. */\n-public abstract class ClassName extends TypeName implements Comparable<ClassName> {\n-  final String simpleName;\n-  String canonicalName;\n-\n-  /** A fully-qualified class name for top-level classes. */\n-  private static final class TopLevelClassName extends ClassName {\n-    final String packageName;\n-\n-    private TopLevelClassName(String packageName, String simpleName) {\n-      this(packageName, simpleName, new ArrayList<>());\n-    }\n-\n-    private TopLevelClassName(\n-        String packageName, String simpleName, List<AnnotationSpec> annotations) {\n-      super(simpleName, annotations);\n-      this.packageName = packageName == null ? \"\" : packageName;\n-      this.canonicalName = isDefaultPackage(packageName)\n-          ? simpleName : String.join(\".\", Arrays.asList(packageName, simpleName));\n-      checkArgument(\n-          isDefaultPackage(simpleName) || SourceVersion.isName(simpleName),\n-          \"part '%s' is keyword\", simpleName);\n-    }\n-\n-    @Override public TopLevelClassName annotated(List<AnnotationSpec> annotations) {\n-      return new TopLevelClassName(packageName, simpleName, concatAnnotations(annotations));\n-    }\n-\n-    @Override public TopLevelClassName withoutAnnotations() {\n-      return new TopLevelClassName(packageName, simpleName);\n-    }\n-\n-    public String packageName() {\n-      return packageName;\n-    }\n-\n-    @Override\n-    public ClassName enclosingClassName() {\n-      return null;\n-    }\n-\n-    @Override\n-    public TopLevelClassName topLevelClassName() {\n-      return this;\n-    }\n-\n-    @Override\n-    public String reflectionName() {\n-      return isDefaultPackage(packageName)\n-          ? simpleName\n-          : String.join(\".\", Arrays.asList(packageName, simpleName));\n-    }\n+public final class ClassName extends TypeName implements Comparable<ClassName> {\n+  public static final ClassName OBJECT = ClassName.get(Object.class);\n \n-    @Override\n-    public List<String> simpleNames() {\n-      return Arrays.asList(simpleName);\n-    }\n+  /** The package name of this class, or \"\" if this is in the default package. */\n+  final String packageName;\n \n-    @Override\n-    public ClassName peerClass(String name) {\n-      return new TopLevelClassName(packageName, name);\n-    }\n+  /** The enclosing class, or null if this is not enclosed in another class. */\n+  final ClassName enclosingClassName;\n \n-    @Override\n-    ClassName prefixWithAtMostOneAnnotatedClass() {\n-      return this;\n-    }\n+  /** This class name, like \"Entry\" for java.util.Map.Entry. */\n+  final String simpleName;\n \n-    @Override\n-    boolean hasAnnotatedEnclosingClass() {\n-      return false;\n-    }\n+  /** The full class name like \"java.util.Map.Entry\". */\n+  final String canonicalName;\n \n-    @Override\n-    CodeWriter emitWithoutPrefix(CodeWriter out, ClassName unannotatedPrefix) {\n-      return out;\n-    }\n+  private ClassName(String packageName, ClassName enclosingClassName, String simpleName) {\n+    this(packageName, enclosingClassName, simpleName, Collections.emptyList());\n   }\n \n-  /** A fully-qualified class name for nested classes. */\n-  private static final class NestedClassName extends ClassName {\n-    /** From top to bottom. This will be [\"java.util\", \"Map\", \"Entry\"] for {@link Map.Entry}. */\n-    final ClassName enclosingClassName;\n-\n-    private NestedClassName(ClassName enclosingClassName, String simpleName) {\n-      this(enclosingClassName, simpleName, new ArrayList<>());\n-    }\n-\n-    private NestedClassName(\n-        ClassName enclosingClassName, String simpleName, List<AnnotationSpec> annotations) {\n-      super(simpleName, annotations);\n-      this.enclosingClassName = enclosingClassName;\n-      this.canonicalName =\n-          String.join(\".\", Arrays.asList(enclosingClassName.canonicalName, simpleName));\n-    }\n-\n-    @Override public NestedClassName annotated(List<AnnotationSpec> annotations) {\n-      return new NestedClassName(enclosingClassName, simpleName, concatAnnotations(annotations));\n-    }\n-\n-    @Override public NestedClassName withoutAnnotations() {\n-      return new NestedClassName(enclosingClassName.withoutAnnotations(), simpleName);\n-    }\n-\n-    /** Returns the package name, like {@code \"java.util\"} for {@code Map.Entry}. */\n-    public String packageName() {\n-      return enclosingClassName.packageName();\n-    }\n-\n-    @Override\n-    public ClassName enclosingClassName() {\n-      return enclosingClassName;\n-    }\n-\n-    @Override\n-    public ClassName topLevelClassName() {\n-      return enclosingClassName.topLevelClassName();\n-    }\n-\n-    @Override\n-    public String reflectionName() {\n-      return enclosingClassName.reflectionName() + \"$\" + simpleName;\n-    }\n-\n-    @Override\n-    public List<String> simpleNames() {\n-      List<String> simpleNames = new ArrayList<>(enclosingClassName().simpleNames());\n-      simpleNames.add(simpleName);\n-      return simpleNames;\n-    }\n-\n-    @Override\n-    public ClassName peerClass(String name) {\n-      return enclosingClassName.nestedClass(name);\n-    }\n-\n-    @Override\n-    ClassName prefixWithAtMostOneAnnotatedClass() {\n-      if (hasAnnotatedEnclosingClass()) {\n-        enclosingClassName.prefixWithAtMostOneAnnotatedClass();\n-      }\n-\n-      return this;\n-    }\n-\n-    @Override\n-    CodeWriter emitWithoutPrefix(\n-        CodeWriter out, ClassName unannotatedPrefix) throws IOException {\n-\n-      if (unannotatedPrefix.equals(this)) {\n-        return out;\n-      }\n-\n-      enclosingClassName.emitWithoutPrefix(out, unannotatedPrefix);\n-      out.emit(\".\");\n-      if (isAnnotated()) {\n-        out.emit(\" \");\n-        emitAnnotations(out);\n-      }\n-      return out.emit(simpleName);\n-    }\n-\n-    @Override\n-    boolean hasAnnotatedEnclosingClass() {\n-      return enclosingClassName.isAnnotated() || enclosingClassName.hasAnnotatedEnclosingClass();\n-    }\n+  private ClassName(String packageName, ClassName enclosingClassName, String simpleName,\n+      List<AnnotationSpec> annotations) {\n+    super(annotations);\n+    this.packageName = packageName;\n+    this.enclosingClassName = enclosingClassName;\n+    this.simpleName = simpleName;\n+    this.canonicalName = enclosingClassName != null\n+        ? (enclosingClassName.canonicalName + '.' + simpleName)\n+        : (packageName.isEmpty() ? simpleName : packageName + '.' + simpleName);\n   }\n \n-  public static final ClassName OBJECT = ClassName.get(Object.class);\n+  @Override public ClassName annotated(List<AnnotationSpec> annotations) {\n+    return new ClassName(packageName, enclosingClassName, simpleName,\n+        concatAnnotations(annotations));\n+  }\n \n-  private ClassName(String simpleName, List<AnnotationSpec> annotations) {\n-    super(annotations);\n-    checkArgument(SourceVersion.isName(simpleName), \"part '%s' is keyword\", simpleName);\n-    this.simpleName = simpleName;\n+  @Override public ClassName withoutAnnotations() {\n+    if (!isAnnotated()) return this;\n+    ClassName resultEnclosingClassName = enclosingClassName != null\n+        ? enclosingClassName.withoutAnnotations()\n+        : null;\n+    return new ClassName(packageName, resultEnclosingClassName, simpleName);\n   }\n \n+  @Override public boolean isAnnotated() {\n+    return super.isAnnotated() || (enclosingClassName != null && enclosingClassName.isAnnotated());\n+  }\n \n-  /** Returns the package name, like {@code \"java.util\"} for {@code Map.Entry}. */\n-  public abstract String packageName();\n+  /**\n+   * Returns the package name, like {@code \"java.util\"} for {@code Map.Entry}. Returns the empty\n+   * string for the default package.\n+   */\n+  public String packageName() {\n+    return packageName;\n+  }\n \n   /**\n    * Returns the enclosing class, like {@link Map} for {@code Map.Entry}. Returns null if this class\n    * is not nested in another class.\n    */\n-  public abstract ClassName enclosingClassName();\n+  public ClassName enclosingClassName() {\n+    return enclosingClassName;\n+  }\n \n   /**\n    * Returns the top class in this nesting group. Equivalent to chained calls to {@link\n    * #enclosingClassName()} until the result's enclosing class is null.\n    */\n-  public abstract ClassName topLevelClassName();\n-\n-  /**\n-   * Return the binary name of a class.\n-   */\n-  public abstract String reflectionName();\n-\n-  public abstract ClassName withoutAnnotations();\n-\n-  /**\n-   * Returns a new {@link ClassName} instance for the specified {@code name} as nested inside this\n-   * class.\n-   */\n-  public ClassName nestedClass(String name) {\n-    return new NestedClassName(this, name);\n+  public ClassName topLevelClassName() {\n+    return enclosingClassName != null ? enclosingClassName.topLevelClassName() : this;\n   }\n \n-  @Override\n-  public ClassName annotated(List<AnnotationSpec> annotations) {\n-    return (ClassName) super.annotated(annotations);\n+  /** Return the binary name of a class. */\n+  public String reflectionName() {\n+    return enclosingClassName != null\n+        ? (enclosingClassName.reflectionName() + '$' + simpleName)\n+        : (packageName.isEmpty() ? simpleName : packageName + '.' + simpleName);\n   }\n \n-  public abstract List<String> simpleNames();\n+  public List<String> simpleNames() {\n+    List<String> simpleNames = new ArrayList<>();\n+    if (enclosingClassName != null) {\n+      simpleNames.addAll(enclosingClassName().simpleNames());\n+    }\n+    simpleNames.add(simpleName);\n+    return simpleNames;\n+  }\n \n   /**\n    * Returns a class that shares the same enclosing package or class. If this class is enclosed by\n    * another class, this is equivalent to {@code enclosingClassName().nestedClass(name)}. Otherwise\n    * it is equivalent to {@code get(packageName(), name)}.\n    */\n-  public abstract ClassName peerClass(String name);\n-\n-  abstract ClassName prefixWithAtMostOneAnnotatedClass();\n-\n-  abstract boolean hasAnnotatedEnclosingClass();\n+  public ClassName peerClass(String name) {\n+    return new ClassName(packageName, enclosingClassName, name);\n+  }\n \n-  abstract CodeWriter emitWithoutPrefix(\n-      CodeWriter out, ClassName unannotatedPrefix) throws IOException;\n+  /**\n+   * Returns a new {@link ClassName} instance for the specified {@code name} as nested inside this\n+   * class.\n+   */\n+  public ClassName nestedClass(String name) {\n+    return new ClassName(packageName, this, name);\n+  }\n \n   /** Returns the simple name of this class, like {@code \"Entry\"} for {@link Map.Entry}. */\n   public String simpleName() {\n@@ -281,8 +157,8 @@ public abstract class ClassName extends TypeName implements Comparable<ClassName\n     if (clazz.getEnclosingClass() == null) {\n       // Avoid unreliable Class.getPackage(). https://github.com/square/javapoet/issues/295\n       int lastDot = clazz.getName().lastIndexOf('.');\n-      String packageName = (lastDot != -1)  ? clazz.getName().substring(0, lastDot) : null;\n-      return new TopLevelClassName(packageName, name);\n+      String packageName = (lastDot != -1) ? clazz.getName().substring(0, lastDot) : null;\n+      return new ClassName(packageName, null, name);\n     }\n \n     return ClassName.get(clazz.getEnclosingClass()).nestedClass(name);\n@@ -303,21 +179,14 @@ public abstract class ClassName extends TypeName implements Comparable<ClassName\n       p = classNameString.indexOf('.', p) + 1;\n       checkArgument(p != 0, \"couldn't make a guess for %s\", classNameString);\n     }\n-    String packageName = p == 0 ? null : classNameString.substring(0, p - 1);\n-    String[] classNames = classNameString.substring(p).split(\"\\\\.\", -1);\n-\n-    checkArgument(classNames.length >= 1, \"couldn't make a guess for %s\", classNameString);\n+    String packageName = p == 0 ? \"\" : classNameString.substring(0, p - 1);\n \n-    String simpleName = classNames[0];\n-    checkArgument(!simpleName.isEmpty() && Character.isUpperCase(simpleName.codePointAt(0)),\n-        \"couldn't make a guess for %s\", classNameString);\n-    ClassName className = new TopLevelClassName(packageName, simpleName);\n-\n-    // Add the class names, like \"Map\" and \"Entry\".\n-    for (String part : Arrays.asList(classNames).subList(1, classNames.length)) {\n-      checkArgument(!part.isEmpty() && Character.isUpperCase(part.codePointAt(0)),\n+    // Add class names like \"Map\" and \"Entry\".\n+    ClassName className = null;\n+    for (String simpleName : classNameString.substring(p).split(\"\\\\.\", -1)) {\n+      checkArgument(!simpleName.isEmpty() && Character.isUpperCase(simpleName.codePointAt(0)),\n           \"couldn't make a guess for %s\", classNameString);\n-      className = className.nestedClass(part);\n+      className = new ClassName(packageName, className, simpleName);\n     }\n \n     return className;\n@@ -328,7 +197,7 @@ public abstract class ClassName extends TypeName implements Comparable<ClassName\n    * {@code \"java.util\"} and simple names {@code \"Map\"}, {@code \"Entry\"} yields {@link Map.Entry}.\n    */\n   public static ClassName get(String packageName, String simpleName, String... simpleNames) {\n-    ClassName className = new TopLevelClassName(packageName, simpleName);\n+    ClassName className = new ClassName(packageName, null, simpleName);\n     for (String name : simpleNames) {\n       className = className.nestedClass(name);\n     }\n@@ -347,7 +216,7 @@ public abstract class ClassName extends TypeName implements Comparable<ClassName\n     }\n \n     String packageName = getPackage(element.getEnclosingElement()).getQualifiedName().toString();\n-    return new TopLevelClassName(packageName, simpleName);\n+    return new ClassName(packageName, null, simpleName);\n   }\n \n   private static boolean isClassOrInterface(Element e) {\n@@ -362,27 +231,54 @@ public abstract class ClassName extends TypeName implements Comparable<ClassName\n   }\n \n   @Override public int compareTo(ClassName o) {\n-    return reflectionName().compareTo(o.reflectionName());\n+    return canonicalName.compareTo(o.canonicalName);\n   }\n \n   @Override CodeWriter emit(CodeWriter out) throws IOException {\n-    ClassName prefix = prefixWithAtMostOneAnnotatedClass();\n-    String unqualifiedName = out.lookupName(prefix);\n-    if (prefix.isAnnotated())  {\n-      int dot = unqualifiedName.lastIndexOf(\".\");\n-      out.emitAndIndent(unqualifiedName.substring(0, dot + 1));\n-      if (dot != -1) {\n-        out.emit(\" \");\n+    boolean charsEmitted = false;\n+    for (ClassName className : enclosingClasses()) {\n+      String simpleName;\n+      if (charsEmitted) {\n+        // We've already emitted an enclosing class. Emit as we go.\n+        out.emit(\".\");\n+        simpleName = className.simpleName;\n+\n+      } else if (className.isAnnotated() || className == this) {\n+        // We encountered the first enclosing class that must be emitted.\n+        String qualifiedName = out.lookupName(className);\n+        int dot = qualifiedName.lastIndexOf('.');\n+        if (dot != -1) {\n+          out.emitAndIndent(qualifiedName.substring(0, dot + 1));\n+          simpleName = qualifiedName.substring(dot + 1);\n+          charsEmitted = true;\n+        } else {\n+          simpleName = qualifiedName;\n+        }\n+\n+      } else {\n+        // Don't emit this enclosing type. Keep going so we can be more precise.\n+        continue;\n+      }\n+\n+      if (className.isAnnotated()) {\n+        if (charsEmitted) out.emit(\" \");\n+        className.emitAnnotations(out);\n       }\n-      prefix.emitAnnotations(out);\n-      out.emit(unqualifiedName.substring(dot + 1));\n-    } else {\n-        out.emitAndIndent(unqualifiedName);\n+\n+      out.emit(simpleName);\n+      charsEmitted = true;\n     }\n-    return emitWithoutPrefix(out, prefix);\n+\n+    return out;\n   }\n \n-  private static boolean isDefaultPackage(String packageName) {\n-    return packageName == null || packageName.isEmpty();\n+  /** Returns all enclosing classes in this, outermost first. */\n+  private List<ClassName> enclosingClasses() {\n+    List<ClassName> result = new ArrayList<>();\n+    for (ClassName c = this; c != null; c = c.enclosingClassName) {\n+      result.add(c);\n+    }\n+    Collections.reverse(result);\n+    return result;\n   }\n }\n"
    },
    {
        "commit_hash": "b1e1a088321da708d3299138fc55c0a9976a6291",
        "previous_commit_hash": "034f0b6801eda34c96d880051f4611555a948ffb",
        "diff_stats": {
            "additions": 33,
            "deletions": 6
        },
        "diff_content": "@@ -15,18 +15,18 @@\n  */\n package com.squareup.javapoet;\n \n-import static com.google.common.truth.Truth.assertThat;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertFalse;\n-import static org.junit.Assert.assertNotEquals;\n-import static org.junit.Assert.assertTrue;\n-\n import java.lang.annotation.ElementType;\n import java.lang.annotation.Target;\n import java.util.List;\n import java.util.Map;\n import org.junit.Test;\n \n+import static com.google.common.truth.Truth.assertThat;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertTrue;\n+\n public class AnnotatedTypeNameTest {\n \n   private final static String NN = NeverNull.class.getCanonicalName();\n@@ -125,6 +125,12 @@ public class AnnotatedTypeNameTest {\n     assertThat(type.toString()).isEqualTo(\"java.util.Map. @\" + TUA + \" Entry\");\n   }\n \n+  @Test public void annotatedEnclosingAndNestedType() {\n+    TypeName type = ((ClassName) TypeName.get(Map.class).annotated(TYPE_USE_ANNOTATION))\n+        .nestedClass(\"Entry\").annotated(TYPE_USE_ANNOTATION);\n+    assertThat(type.toString()).isEqualTo(\"java.util. @\" + TUA + \" Map. @\" + TUA + \" Entry\");\n+  }\n+\n   // https://github.com/square/javapoet/issues/431\n   @Test public void annotatedNestedParameterizedType() {\n     TypeName type = ParameterizedTypeName.get(Map.Entry.class, Byte.class, Byte.class)\n@@ -133,6 +139,27 @@ public class AnnotatedTypeNameTest {\n         .isEqualTo(\"java.util.Map. @\" + TUA + \" Entry<java.lang.Byte, java.lang.Byte>\");\n   }\n \n+  @Test public void withoutAnnotationsOnAnnotatedEnclosingAndNestedType() {\n+    TypeName type = ((ClassName) TypeName.get(Map.class).annotated(TYPE_USE_ANNOTATION))\n+        .nestedClass(\"Entry\").annotated(TYPE_USE_ANNOTATION);\n+    assertThat(type.isAnnotated()).isTrue();\n+    assertThat(type.withoutAnnotations()).isEqualTo(TypeName.get(Map.Entry.class));\n+  }\n+\n+  @Test public void withoutAnnotationsOnAnnotatedEnclosingType() {\n+    TypeName type = ((ClassName) TypeName.get(Map.class).annotated(TYPE_USE_ANNOTATION))\n+        .nestedClass(\"Entry\");\n+    assertThat(type.isAnnotated()).isTrue();\n+    assertThat(type.withoutAnnotations()).isEqualTo(TypeName.get(Map.Entry.class));\n+  }\n+\n+  @Test public void withoutAnnotationsOnAnnotatedNestedType() {\n+    TypeName type = ((ClassName) TypeName.get(Map.class))\n+        .nestedClass(\"Entry\").annotated(TYPE_USE_ANNOTATION);\n+    assertThat(type.isAnnotated()).isTrue();\n+    assertThat(type.withoutAnnotations()).isEqualTo(TypeName.get(Map.Entry.class));\n+  }\n+\n   // https://github.com/square/javapoet/issues/614\n    @Test public void annotatedArrayType() {\n     TypeName type = ArrayTypeName.of(ClassName.get(Object.class)).annotated(TYPE_USE_ANNOTATION);\n"
    },
    {
        "commit_hash": "1c897e44ddd6b50e22180b6d32e4a3c69223614a",
        "previous_commit_hash": "3f4d5c2c2eebc3915ab0f705f38d11a9f9b4237b",
        "diff_stats": {
            "additions": 10,
            "deletions": 20
        },
        "diff_content": "@@ -20,15 +20,12 @@ import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.Name;\n import javax.lang.model.element.PackageElement;\n import javax.lang.model.element.TypeElement;\n \n import static com.squareup.javapoet.Util.checkArgument;\n import static com.squareup.javapoet.Util.checkNotNull;\n-import static javax.lang.model.element.NestingKind.MEMBER;\n-import static javax.lang.model.element.NestingKind.TOP_LEVEL;\n \n /** A fully-qualified class name for top-level and member classes. */\n public final class ClassName extends TypeName implements Comparable<ClassName> {\n@@ -207,27 +204,20 @@ public final class ClassName extends TypeName implements Comparable<ClassName> {\n   /** Returns the class name for {@code element}. */\n   public static ClassName get(TypeElement element) {\n     checkNotNull(element, \"element == null\");\n-    checkArgument(element.getNestingKind() == TOP_LEVEL || element.getNestingKind() == MEMBER,\n-        \"unexpected type nesting\");\n     String simpleName = element.getSimpleName().toString();\n \n-    if (isClassOrInterface(element.getEnclosingElement())) {\n-      return ClassName.get((TypeElement) element.getEnclosingElement()).nestedClass(simpleName);\n-    }\n-\n-    String packageName = getPackage(element.getEnclosingElement()).getQualifiedName().toString();\n-    return new ClassName(packageName, null, simpleName);\n-  }\n+    switch (element.getNestingKind()) {\n+      case TOP_LEVEL:\n+        Name packageName = ((PackageElement) element.getEnclosingElement()).getQualifiedName();\n+        return new ClassName(packageName.toString(), null, simpleName);\n \n-  private static boolean isClassOrInterface(Element e) {\n-    return e.getKind().isClass() || e.getKind().isInterface();\n-  }\n+      case MEMBER:\n+        ClassName enclosingClass = get((TypeElement) element.getEnclosingElement());\n+        return enclosingClass.nestedClass(simpleName);\n \n-  private static PackageElement getPackage(Element type) {\n-    while (type.getKind() != ElementKind.PACKAGE) {\n-      type = type.getEnclosingElement();\n+      default:\n+        throw new IllegalArgumentException(\"unexpected type nesting\");\n     }\n-    return (PackageElement) type;\n   }\n \n   @Override public int compareTo(ClassName o) {\n"
    },
    {
        "commit_hash": "1c897e44ddd6b50e22180b6d32e4a3c69223614a",
        "previous_commit_hash": "3f4d5c2c2eebc3915ab0f705f38d11a9f9b4237b",
        "diff_stats": {
            "additions": 32,
            "deletions": 0
        },
        "diff_content": "@@ -23,10 +23,12 @@ import org.junit.Rule;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n+import org.mockito.Mockito;\n \n import static com.google.common.truth.Truth.assertThat;\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.when;\n \n @RunWith(JUnit4.class)\n public final class ClassNameTest {\n@@ -110,6 +112,36 @@ public final class ClassNameTest {\n     assertThat(ClassName.get(inner).toString()).isEqualTo(\"com.squareup.javapoet.ClassNameTest.$Outer.$Inner\");\n   }\n \n+  /**\n+   * Buck builds with \"source-based ABI generation\" and those builds don't support\n+   * {@link TypeElement#getKind()}. Test to confirm that we don't use that API.\n+   */\n+  @Test public void classNameFromTypeElementDoesntUseGetKind() {\n+    Elements elements = compilationRule.getElements();\n+    TypeElement object = elements.getTypeElement(Object.class.getCanonicalName());\n+    assertThat(ClassName.get(preventGetKind(object)).toString())\n+        .isEqualTo(\"java.lang.Object\");\n+    TypeElement outer = elements.getTypeElement($Outer.class.getCanonicalName());\n+    assertThat(ClassName.get(preventGetKind(outer)).toString())\n+        .isEqualTo(\"com.squareup.javapoet.ClassNameTest.$Outer\");\n+    TypeElement inner = elements.getTypeElement($Outer.$Inner.class.getCanonicalName());\n+    assertThat(ClassName.get(preventGetKind(inner)).toString())\n+        .isEqualTo(\"com.squareup.javapoet.ClassNameTest.$Outer.$Inner\");\n+  }\n+\n+  /** Returns a new instance like {@code object} that throws on {@code getKind()}. */\n+  private TypeElement preventGetKind(TypeElement object) {\n+    TypeElement spy = Mockito.spy(object);\n+    when(spy.getKind()).thenThrow(new AssertionError());\n+    when(spy.getEnclosingElement()).thenAnswer(invocation -> {\n+      Object enclosingElement = invocation.callRealMethod();\n+      return enclosingElement instanceof TypeElement\n+          ? preventGetKind((TypeElement) enclosingElement)\n+          : enclosingElement;\n+    });\n+    return spy;\n+  }\n+\n   @Test public void classNameFromClass() {\n     assertThat(ClassName.get(Object.class).toString())\n         .isEqualTo(\"java.lang.Object\");\n"
    },
    {
        "commit_hash": "5d6ff03f8baa4cb49334ed644dea8b8acb8545fb",
        "previous_commit_hash": "30ff8ce28c3cc99cb938c66879c16720e427e982",
        "diff_stats": {
            "additions": 8,
            "deletions": 0
        },
        "diff_content": "@@ -1,6 +1,14 @@\n Change Log\n ==========\n \n+JavaPoet 1.11.0 *(2018-04-29)*\n+-----------------------------\n+\n+ * New: Support `TYPE_USE` annotations on each enclosing `ClassName`.\n+ * New: Work around a compiler bug in `TypeName.get(TypeElement)`. There was a problem getting an\n+   element's kind when building from source ABIs.\n+\n+\n JavaPoet 1.10.0 *(2018-01-27)*\n -----------------------------\n \n"
    },
    {
        "commit_hash": "5d6ff03f8baa4cb49334ed644dea8b8acb8545fb",
        "previous_commit_hash": "30ff8ce28c3cc99cb938c66879c16720e427e982",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -838,12 +838,12 @@ Download [the latest .jar][dl] or depend via Maven:\n <dependency>\n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.10.0</version>\n+  <version>1.11.0</version>\n </dependency>\n ```\n or Gradle:\n ```groovy\n-compile 'com.squareup:javapoet:1.10.0'\n+compile 'com.squareup:javapoet:1.11.0'\n ```\n \n Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].\n"
    },
    {
        "commit_hash": "b09d944edd6029434aac2e14cff14df0f4bb521e",
        "previous_commit_hash": "5d6ff03f8baa4cb49334ed644dea8b8acb8545fb",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.11.0-SNAPSHOT</version>\n+  <version>1.11.0</version>\n \n   <name>JavaPoet</name>\n   <description>Use beautiful Java code to generate beautiful Java code.</description>\n"
    },
    {
        "commit_hash": "3ddde8f3ccb5182ce5da7fcca21997efe96028a0",
        "previous_commit_hash": "b09d944edd6029434aac2e14cff14df0f4bb521e",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.11.0</version>\n+  <version>1.12.0-SNAPSHOT</version>\n \n   <name>JavaPoet</name>\n   <description>Use beautiful Java code to generate beautiful Java code.</description>\n"
    },
    {
        "commit_hash": "558401605880b7d636c4e41e3044c775d987a208",
        "previous_commit_hash": "3ddde8f3ccb5182ce5da7fcca21997efe96028a0",
        "diff_stats": {
            "additions": 17,
            "deletions": 11
        },
        "diff_content": "@@ -20,9 +20,10 @@ import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n-import javax.lang.model.element.Name;\n+import javax.lang.model.element.Element;\n import javax.lang.model.element.PackageElement;\n import javax.lang.model.element.TypeElement;\n+import javax.lang.model.util.SimpleElementVisitor8;\n \n import static com.squareup.javapoet.Util.checkArgument;\n import static com.squareup.javapoet.Util.checkNotNull;\n@@ -206,18 +207,23 @@ public final class ClassName extends TypeName implements Comparable<ClassName> {\n     checkNotNull(element, \"element == null\");\n     String simpleName = element.getSimpleName().toString();\n \n-    switch (element.getNestingKind()) {\n-      case TOP_LEVEL:\n-        Name packageName = ((PackageElement) element.getEnclosingElement()).getQualifiedName();\n-        return new ClassName(packageName.toString(), null, simpleName);\n+    return element.getEnclosingElement().accept(new SimpleElementVisitor8<ClassName, Void>() {\n+      @Override public ClassName visitPackage(PackageElement packageElement, Void p) {\n+        return new ClassName(packageElement.getQualifiedName().toString(), null, simpleName);\n+      }\n \n-      case MEMBER:\n-        ClassName enclosingClass = get((TypeElement) element.getEnclosingElement());\n-        return enclosingClass.nestedClass(simpleName);\n+      @Override public ClassName visitType(TypeElement enclosingClass, Void p) {\n+        return ClassName.get(enclosingClass).nestedClass(simpleName);\n+      }\n \n-      default:\n-        throw new IllegalArgumentException(\"unexpected type nesting\");\n-    }\n+      @Override public ClassName visitUnknown(Element unknown, Void p) {\n+        return get(\"\", simpleName);\n+      }\n+\n+      @Override public ClassName defaultAction(Element enclosingElement, Void p) {\n+        throw new IllegalArgumentException(\"Unexpected type nesting: \" + element);\n+      }\n+    }, null);\n   }\n \n   @Override public int compareTo(ClassName o) {\n"
    },
    {
        "commit_hash": "558401605880b7d636c4e41e3044c775d987a208",
        "previous_commit_hash": "3ddde8f3ccb5182ce5da7fcca21997efe96028a0",
        "diff_stats": {
            "additions": 42,
            "deletions": 51
        },
        "diff_content": "@@ -16,19 +16,27 @@\n package com.squareup.javapoet;\n \n import static com.google.common.truth.Truth.assertThat;\n+import static com.google.testing.compile.CompilationSubject.assertThat;\n+import static com.google.testing.compile.Compiler.javac;\n+import static javax.lang.model.util.ElementFilter.fieldsIn;\n import static org.junit.Assert.*;\n \n+import com.google.testing.compile.Compilation;\n+import com.google.testing.compile.JavaFileObjects;\n import java.io.Serializable;\n import java.lang.annotation.Annotation;\n import java.nio.charset.Charset;\n+import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n-\n+import javax.annotation.processing.AbstractProcessor;\n+import javax.annotation.processing.RoundEnvironment;\n import javax.lang.model.element.AnnotationMirror;\n import javax.lang.model.element.Element;\n import javax.lang.model.element.TypeElement;\n import javax.lang.model.element.TypeParameterElement;\n+import javax.lang.model.element.VariableElement;\n import javax.lang.model.type.DeclaredType;\n import javax.lang.model.type.ErrorType;\n import javax.lang.model.type.TypeKind;\n@@ -37,6 +45,7 @@ import javax.lang.model.type.TypeVisitor;\n import javax.lang.model.type.WildcardType;\n import javax.lang.model.util.Elements;\n import javax.lang.model.util.Types;\n+import javax.tools.JavaFileObject;\n \n import org.junit.Test;\n \n@@ -68,10 +77,38 @@ public abstract class AbstractTypesTest {\n         .isEqualTo(ParameterizedTypeName.get(ClassName.get(Set.class), ClassName.OBJECT));\n   }\n \n-  @Test public void getErrorType() {\n-    ErrorType errorType =\n-        new DeclaredTypeAsErrorType(getTypes().getDeclaredType(getElement(Set.class)));\n-    assertThat(TypeName.get(errorType)).isEqualTo(ClassName.get(Set.class));\n+  @Test public void errorTypes() {\n+    JavaFileObject hasErrorTypes =\n+        JavaFileObjects.forSourceLines(\n+            \"com.squareup.tacos.ErrorTypes\",\n+            \"package com.squareup.tacos;\",\n+            \"\",\n+            \"@SuppressWarnings(\\\"hook-into-compiler\\\")\",\n+            \"class ErrorTypes {\",\n+            \"  Tacos tacos;\",\n+            \"  Ingredients.Guacamole guacamole;\",\n+            \"}\");\n+    Compilation compilation = javac().withProcessors(new AbstractProcessor() {\n+      @Override\n+      public boolean process(Set<? extends TypeElement> set, RoundEnvironment roundEnvironment) {\n+        TypeElement classFile =\n+            processingEnv.getElementUtils().getTypeElement(\"com.squareup.tacos.ErrorTypes\");\n+        List<VariableElement> fields = fieldsIn(classFile.getEnclosedElements());\n+        ErrorType topLevel = (ErrorType) fields.get(0).asType();\n+        ErrorType member = (ErrorType) fields.get(1).asType();\n+\n+        assertThat(TypeName.get(topLevel)).isEqualTo(ClassName.get(\"\", \"Tacos\"));\n+        assertThat(TypeName.get(member)).isEqualTo(ClassName.get(\"Ingredients\", \"Guacamole\"));\n+        return false;\n+      }\n+\n+      @Override\n+      public Set<String> getSupportedAnnotationTypes() {\n+        return Collections.singleton(\"*\");\n+      }\n+    }).compile(hasErrorTypes);\n+\n+    assertThat(compilation).failed();\n   }\n \n   static class Parameterized<\n@@ -245,50 +282,4 @@ public abstract class AbstractTypesTest {\n     } catch (UnsupportedOperationException expected) {\n     }\n   }\n-\n-  private static class DeclaredTypeAsErrorType implements ErrorType {\n-    private final DeclaredType declaredType;\n-\n-    public DeclaredTypeAsErrorType(DeclaredType declaredType) {\n-      this.declaredType = declaredType;\n-    }\n-\n-    @Override\n-    public Element asElement() {\n-      return declaredType.asElement();\n-    }\n-\n-    @Override\n-    public TypeMirror getEnclosingType() {\n-      return declaredType.getEnclosingType();\n-    }\n-\n-    @Override\n-    public List<? extends TypeMirror> getTypeArguments() {\n-      return declaredType.getTypeArguments();\n-    }\n-\n-    @Override\n-    public TypeKind getKind() {\n-      return declaredType.getKind();\n-    }\n-\n-    @Override\n-    public <R, P> R accept(TypeVisitor<R, P> typeVisitor, P p) {\n-      return typeVisitor.visitError(this, p);\n-    }\n-\n-    // JDK8 Compatibility:\n-    public <A extends Annotation> A[] getAnnotationsByType(Class<A> annotationType) {\n-      throw new UnsupportedOperationException();\n-    }\n-\n-    public <A extends Annotation> A getAnnotation(Class<A> annotationType) {\n-      throw new UnsupportedOperationException();\n-    }\n-\n-    public List<? extends AnnotationMirror> getAnnotationMirrors() {\n-      throw new UnsupportedOperationException();\n-    }\n-  }\n }\n"
    },
    {
        "commit_hash": "5ff40a9f70b2c0274d734701eb038c7c2ac4da6e",
        "previous_commit_hash": "558401605880b7d636c4e41e3044c775d987a208",
        "diff_stats": {
            "additions": 8,
            "deletions": 0
        },
        "diff_content": "@@ -1,6 +1,14 @@\n Change Log\n ==========\n \n+JavaPoet 1.11.1 *(2018-05-16)*\n+-----------------------------\n+\n+ * Fix: JavaPoet 1.11 had a regression where `TypeName.get()` would throw on error types, masking\n+   other errors in an annotation processing round. This is fixed with a test to prevent future\n+   regressions!\n+\n+\n JavaPoet 1.11.0 *(2018-04-29)*\n -----------------------------\n \n"
    },
    {
        "commit_hash": "5ff40a9f70b2c0274d734701eb038c7c2ac4da6e",
        "previous_commit_hash": "558401605880b7d636c4e41e3044c775d987a208",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -838,12 +838,12 @@ Download [the latest .jar][dl] or depend via Maven:\n <dependency>\n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.11.0</version>\n+  <version>1.11.1</version>\n </dependency>\n ```\n or Gradle:\n ```groovy\n-compile 'com.squareup:javapoet:1.11.0'\n+compile 'com.squareup:javapoet:1.11.1'\n ```\n \n Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].\n"
    },
    {
        "commit_hash": "a5db06d05f8bd799cef194af28ace07427e2d07e",
        "previous_commit_hash": "5ff40a9f70b2c0274d734701eb038c7c2ac4da6e",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.12.0-SNAPSHOT</version>\n+  <version>1.11.1</version>\n \n   <name>JavaPoet</name>\n   <description>Use beautiful Java code to generate beautiful Java code.</description>\n"
    },
    {
        "commit_hash": "564f37f35f1dd85bcc22e775b9eb3631d865bdee",
        "previous_commit_hash": "a5db06d05f8bd799cef194af28ace07427e2d07e",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.11.1</version>\n+  <version>1.12.0-SNAPSHOT</version>\n \n   <name>JavaPoet</name>\n   <description>Use beautiful Java code to generate beautiful Java code.</description>\n"
    },
    {
        "commit_hash": "46a6a6e2db009e98fed755ecf95bc5264635840d",
        "previous_commit_hash": "564f37f35f1dd85bcc22e775b9eb3631d865bdee",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -674,7 +674,7 @@ public enum Roshambo {\n \n ### Anonymous Inner Classes\n \n-In the enum code, we used `Types.anonymousInnerClass()`. Anonymous inner classes can also be used in\n+In the enum code, we used `TypeSpec.anonymousInnerClass()`. Anonymous inner classes can also be used in\n code blocks. They are values that can be referenced with `$L`:\n \n ```java\n"
    },
    {
        "commit_hash": "4a7857e873c4d5f249bee373187289c2e1fa35ba",
        "previous_commit_hash": "1469cfa30536afbaa8fcfe9d2ee0745ec0213bca",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -44,7 +44,7 @@ import javax.lang.model.util.SimpleTypeVisitor8;\n  * identifies composite types like {@code char[]} and {@code Set<Long>}.\n  *\n  * <p>Type names are dumb identifiers only and do not model the values they name. For example, the\n- * type name for {@code java.lang.List} doesn't know about the {@code size()} method, the fact that\n+ * type name for {@code java.util.List} doesn't know about the {@code size()} method, the fact that\n  * lists are collections, or even that it accepts a single type parameter.\n  *\n  * <p>Instances of this class are immutable value objects that implement {@code equals()} and {@code\n"
    },
    {
        "commit_hash": "dfb5bc6c4e0c33f0d40d02c9702089da8a848d2f",
        "previous_commit_hash": "37ccc0b97f171dcbfb9595ad0337c5d7d30ccef7",
        "diff_stats": {
            "additions": 7,
            "deletions": 17
        },
        "diff_content": "@@ -2,27 +2,17 @@ language: java\n \n matrix:\n   include:\n-    - env: JDK='Oracle JDK 8'\n-      jdk: oraclejdk8\n-    - env: JDK='Oracle JDK 9'\n-      jdk: oraclejdk9\n-    - env: JDK='Oracle JDK 10'\n-      install: . ./install-jdk.sh -F 10 -L BCL\n-    - env: JDK='OpenJDK 10'\n-      install: . ./install-jdk.sh -F 10 -L GPL\n-    - env: JDK='Oracle JDK 11'\n-      install: . ./install-jdk.sh -F 11 -L BCL\n-    - env: JDK='OpenJDK 11'\n-      install: . ./install-jdk.sh -F 11 -L GPL\n+    - jdk: oraclejdk8\n+    - jdk: openjdk10\n+    - jdk: openjdk11\n+    - jdk: openjdk-ea\n   allow_failures:\n-    # ErrorProne/javac is not yet working on JDK 11\n-    - env: JDK='Oracle JDK 11'\n-    - env: JDK='OpenJDK 11'\n+    # ErrorProne/javac is not yet working on JDK 11 nor 12 (current -ea)\n+    - jdk: openjdk11\n+    - jdk: openjdk-ea\n \n-# Direct usage of `install-jdk.sh` might be superseded by https://github.com/travis-ci/travis-build/pull/1347\n before_install:\n   - unset _JAVA_OPTIONS\n-  - wget https://github.com/sormuras/bach/raw/1.0.1/install-jdk.sh\n \n after_success:\n   - .buildscript/deploy_snapshot.sh\n"
    },
    {
        "commit_hash": "dfb5bc6c4e0c33f0d40d02c9702089da8a848d2f",
        "previous_commit_hash": "37ccc0b97f171dcbfb9595ad0337c5d7d30ccef7",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -94,7 +94,7 @@\n       <plugin>\n         <groupId>org.apache.maven.plugins</groupId>\n         <artifactId>maven-compiler-plugin</artifactId>\n-        <version>3.7.0</version>\n+        <version>3.8.0</version>\n         <configuration>\n           <compilerId>javac-with-errorprone</compilerId>\n           <forceJavacCompilerUse>true</forceJavacCompilerUse>\n"
    },
    {
        "commit_hash": "077bd8c26b4b509807bb3af96cc429e34982d927",
        "previous_commit_hash": "dfb5bc6c4e0c33f0d40d02c9702089da8a848d2f",
        "diff_stats": {
            "additions": 3,
            "deletions": 0
        },
        "diff_content": "@@ -18,9 +18,11 @@ package com.squareup.javapoet;\n import org.junit.Test;\n \n import static com.google.common.truth.Truth.assertThat;\n+import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.fail;\n \n public final class NameAllocatorTest {\n+\n   @Test public void usage() throws Exception {\n     NameAllocator nameAllocator = new NameAllocator();\n     assertThat(nameAllocator.newName(\"foo\", 1)).isEqualTo(\"foo\");\n@@ -59,6 +61,7 @@ public final class NameAllocatorTest {\n   @Test public void characterMappingInvalidStartButValidPart() throws Exception {\n     NameAllocator nameAllocator = new NameAllocator();\n     assertThat(nameAllocator.newName(\"1ab\", 1)).isEqualTo(\"_1ab\");\n+    assertThat(nameAllocator.newName(\"a-1\", 2)).isEqualTo(\"a_1\");\n   }\n \n   @Test public void characterMappingInvalidStartIsInvalidPart() throws Exception {\n"
    },
    {
        "commit_hash": "f1600e5cc03fcc8bc6757fd115e3de89c7dad6fd",
        "previous_commit_hash": "dfb5bc6c4e0c33f0d40d02c9702089da8a848d2f",
        "diff_stats": {
            "additions": 2,
            "deletions": 0
        },
        "diff_content": "@@ -28,10 +28,12 @@ public class ParameterSpecTest {\n     ParameterSpec b = ParameterSpec.builder(int.class, \"foo\").build();\n     assertThat(a.equals(b)).isTrue();\n     assertThat(a.hashCode()).isEqualTo(b.hashCode());\n+    assertThat(a.toString()).isEqualTo(b.toString());\n     a = ParameterSpec.builder(int.class, \"i\").addModifiers(Modifier.STATIC).build();\n     b = ParameterSpec.builder(int.class, \"i\").addModifiers(Modifier.STATIC).build();\n     assertThat(a.equals(b)).isTrue();\n     assertThat(a.hashCode()).isEqualTo(b.hashCode());\n+    assertThat(a.toString()).isEqualTo(b.toString());\n   }\n \n   @Test public void nullAnnotationsAddition() {\n"
    },
    {
        "commit_hash": "0cbc16df9213d64e6dfe389a2d164ab6f007121b",
        "previous_commit_hash": "dfb5bc6c4e0c33f0d40d02c9702089da8a848d2f",
        "diff_stats": {
            "additions": 2,
            "deletions": 0
        },
        "diff_content": "@@ -28,10 +28,12 @@ public class FieldSpecTest {\n     FieldSpec b = FieldSpec.builder(int.class, \"foo\").build();\n     assertThat(a.equals(b)).isTrue();\n     assertThat(a.hashCode()).isEqualTo(b.hashCode());\n+    assertThat(a.toString()).isEqualTo(b.toString());\n     a = FieldSpec.builder(int.class, \"FOO\", Modifier.PUBLIC, Modifier.STATIC).build();\n     b = FieldSpec.builder(int.class, \"FOO\", Modifier.PUBLIC, Modifier.STATIC).build();\n     assertThat(a.equals(b)).isTrue();\n     assertThat(a.hashCode()).isEqualTo(b.hashCode());\n+    assertThat(a.toString()).isEqualTo(b.toString());\n   }\n \n   @Test public void nullAnnotationsAddition() {\n"
    },
    {
        "commit_hash": "b879b58254804b953c6280d05d7882a89ec3b7c8",
        "previous_commit_hash": "dfb5bc6c4e0c33f0d40d02c9702089da8a848d2f",
        "diff_stats": {
            "additions": 36,
            "deletions": 1
        },
        "diff_content": "@@ -57,6 +57,7 @@ final class CodeWriter {\n   private final Map<String, ClassName> importedTypes;\n   private final Map<String, ClassName> importableTypes = new LinkedHashMap<>();\n   private final Set<String> referencedNames = new LinkedHashSet<>();\n+  private final Multiset<String> currentTypeVariables = new Multiset<>();\n   private boolean trailingNewline;\n \n   /**\n@@ -187,6 +188,8 @@ final class CodeWriter {\n   public void emitTypeVariables(List<TypeVariableName> typeVariables) throws IOException {\n     if (typeVariables.isEmpty()) return;\n \n+    typeVariables.forEach(typeVariable -> currentTypeVariables.add(typeVariable.name));\n+\n     emit(\"<\");\n     boolean firstTypeVariable = true;\n     for (TypeVariableName typeVariable : typeVariables) {\n@@ -203,6 +206,10 @@ final class CodeWriter {\n     emit(\">\");\n   }\n \n+  public void popTypeVariables(List<TypeVariableName> typeVariables) throws IOException {\n+    typeVariables.forEach(typeVariable -> currentTypeVariables.remove(typeVariable.name));\n+  }\n+\n   public CodeWriter emit(String s) throws IOException {\n     return emitAndIndent(s);\n   }\n@@ -353,6 +360,12 @@ final class CodeWriter {\n    * names visible due to inheritance.\n    */\n   String lookupName(ClassName className) {\n+    // If the top level simple name is masked by a current type variable, use the canonical name.\n+    String topLevelSimpleName = className.topLevelClassName().simpleName();\n+    if (currentTypeVariables.contains(topLevelSimpleName)) {\n+      return className.canonicalName;\n+    }\n+\n     // Find the shortest suffix of className that resolves to className. This uses both local type\n     // names (so `Entry` in `Map` refers to `Map.Entry`). Also uses imports.\n     boolean nameResolved = false;\n@@ -374,7 +387,7 @@ final class CodeWriter {\n \n     // If the class is in the same package, we're done.\n     if (Objects.equals(packageName, className.packageName())) {\n-      referencedNames.add(className.topLevelClassName().simpleName());\n+      referencedNames.add(topLevelSimpleName);\n       return join(\".\", className.simpleNames());\n     }\n \n@@ -494,4 +507,26 @@ final class CodeWriter {\n     result.keySet().removeAll(referencedNames);\n     return result;\n   }\n+\n+  // A makeshift multi-set implementation\n+  private static final class Multiset<T> {\n+    private final Map<T, Integer> map = new LinkedHashMap<>();\n+\n+    void add(T t) {\n+      int count = map.getOrDefault(t, 0);\n+      map.put(t, count + 1);\n+    }\n+\n+    void remove(T t) {\n+      int count = map.getOrDefault(t, 0);\n+      if (count == 0) {\n+        throw new IllegalStateException(t + \" is not in the multiset\");\n+      }\n+      map.put(t, count - 1);\n+    }\n+\n+    boolean contains(T t) {\n+      return map.getOrDefault(t, 0) > 0;\n+    }\n+  }\n }\n"
    },
    {
        "commit_hash": "b879b58254804b953c6280d05d7882a89ec3b7c8",
        "previous_commit_hash": "dfb5bc6c4e0c33f0d40d02c9702089da8a848d2f",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -137,6 +137,7 @@ public final class MethodSpec {\n \n       codeWriter.emit(\"}\\n\");\n     }\n+    codeWriter.popTypeVariables(typeVariables);\n   }\n \n   public boolean hasModifier(Modifier modifier) {\n"
    },
    {
        "commit_hash": "b879b58254804b953c6280d05d7882a89ec3b7c8",
        "previous_commit_hash": "dfb5bc6c4e0c33f0d40d02c9702089da8a848d2f",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -316,6 +316,7 @@ public final class TypeSpec {\n \n       codeWriter.unindent();\n       codeWriter.popType();\n+      codeWriter.popTypeVariables(typeVariables);\n \n       codeWriter.emit(\"}\");\n       if (enumName == null && anonymousTypeArguments == null) {\n"
    },
    {
        "commit_hash": "b879b58254804b953c6280d05d7882a89ec3b7c8",
        "previous_commit_hash": "dfb5bc6c4e0c33f0d40d02c9702089da8a848d2f",
        "diff_stats": {
            "additions": 68,
            "deletions": 0
        },
        "diff_content": "@@ -985,6 +985,74 @@ public final class TypeSpecTest {\n         + \"}\\n\");\n   }\n \n+  @Test public void simpleNameConflictsWithTypeVariable() {\n+    ClassName inPackage = ClassName.get(\"com.squareup.tacos\", \"InPackage\");\n+    ClassName otherType = ClassName.get(\"com.other\", \"OtherType\");\n+    ClassName methodInPackage = ClassName.get(\"com.squareup.tacos\", \"MethodInPackage\");\n+    ClassName methodOtherType = ClassName.get(\"com.other\", \"MethodOtherType\");\n+    TypeSpec gen = TypeSpec.classBuilder(\"Gen\")\n+        .addTypeVariable(TypeVariableName.get(\"InPackage\"))\n+        .addTypeVariable(TypeVariableName.get(\"OtherType\"))\n+        .addField(FieldSpec.builder(inPackage, \"inPackage\").build())\n+        .addField(FieldSpec.builder(otherType, \"otherType\").build())\n+        .addMethod(MethodSpec.methodBuilder(\"withTypeVariables\")\n+            .addTypeVariable(TypeVariableName.get(\"MethodInPackage\"))\n+            .addTypeVariable(TypeVariableName.get(\"MethodOtherType\"))\n+            .addStatement(\"$T inPackage = null\", methodInPackage)\n+            .addStatement(\"$T otherType = null\", methodOtherType)\n+            .build())\n+        .addMethod(MethodSpec.methodBuilder(\"withoutTypeVariables\")\n+            .addStatement(\"$T inPackage = null\", methodInPackage)\n+            .addStatement(\"$T otherType = null\", methodOtherType)\n+            .build())\n+        .addMethod(MethodSpec.methodBuilder(\"againWithTypeVariables\")\n+            .addTypeVariable(TypeVariableName.get(\"MethodInPackage\"))\n+            .addTypeVariable(TypeVariableName.get(\"MethodOtherType\"))\n+            .addStatement(\"$T inPackage = null\", methodInPackage)\n+            .addStatement(\"$T otherType = null\", methodOtherType)\n+            .build())\n+        // https://github.com/square/javapoet/pull/657#discussion_r205514292\n+        .addMethod(MethodSpec.methodBuilder(\"masksEnclosingTypeVariable\")\n+            .addTypeVariable(TypeVariableName.get(\"InPackage\"))\n+            .build())\n+        .addMethod(MethodSpec.methodBuilder(\"hasSimpleNameThatWasPreviouslyMasked\")\n+            .addStatement(\"$T inPackage = null\", inPackage)\n+            .build())\n+        .build();\n+    assertThat(toString(gen)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import com.other.MethodOtherType;\\n\"\n+        + \"\\n\"\n+        + \"class Gen<InPackage, OtherType> {\\n\"\n+        + \"  com.squareup.tacos.InPackage inPackage;\\n\"\n+        + \"\\n\"\n+        + \"  com.other.OtherType otherType;\\n\"\n+        + \"\\n\"\n+        + \"  <MethodInPackage, MethodOtherType> void withTypeVariables() {\\n\"\n+        + \"    com.squareup.tacos.MethodInPackage inPackage = null;\\n\"\n+        + \"    com.other.MethodOtherType otherType = null;\\n\"\n+        + \"  }\\n\"\n+        + \"\\n\"\n+        + \"  void withoutTypeVariables() {\\n\"\n+        + \"    MethodInPackage inPackage = null;\\n\"\n+        + \"    MethodOtherType otherType = null;\\n\"\n+        + \"  }\\n\"\n+        + \"\\n\"\n+        + \"  <MethodInPackage, MethodOtherType> void againWithTypeVariables() {\\n\"\n+        + \"    com.squareup.tacos.MethodInPackage inPackage = null;\\n\"\n+        + \"    com.other.MethodOtherType otherType = null;\\n\"\n+        + \"  }\\n\"\n+        + \"\\n\"\n+        + \"  <InPackage> void masksEnclosingTypeVariable() {\\n\"\n+        + \"  }\\n\"\n+        + \"\\n\"\n+        + \"  void hasSimpleNameThatWasPreviouslyMasked() {\\n\"\n+        + \"    com.squareup.tacos.InPackage inPackage = null;\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n   @Test public void originatingElementsIncludesThoseOfNestedTypes() {\n     Element outerElement = Mockito.mock(Element.class);\n     Element innerElement = Mockito.mock(Element.class);\n"
    },
    {
        "commit_hash": "c93bfa88c30940d4f9bda88cac322ebbb83703a6",
        "previous_commit_hash": "527c397d2987e44c4422412b8ab3ae5bca07db06",
        "diff_stats": {
            "additions": 3,
            "deletions": 0
        },
        "diff_content": "@@ -160,6 +160,9 @@ public final class ParameterSpec {\n     public Builder addModifiers(Iterable<Modifier> modifiers) {\n       checkNotNull(modifiers, \"modifiers == null\");\n       for (Modifier modifier : modifiers) {\n+        if (!modifier.equals(Modifier.FINAL)) {\n+          throw new IllegalStateException(\"unexpected parameter modifier: \" + modifier);\n+        }\n         this.modifiers.add(modifier);\n       }\n       return this;\n"
    },
    {
        "commit_hash": "c93bfa88c30940d4f9bda88cac322ebbb83703a6",
        "previous_commit_hash": "527c397d2987e44c4422412b8ab3ae5bca07db06",
        "diff_stats": {
            "additions": 17,
            "deletions": 1
        },
        "diff_content": "@@ -15,6 +15,8 @@\n  */\n package com.squareup.javapoet;\n \n+import java.util.ArrayList;\n+import java.util.List;\n import org.junit.Test;\n \n import static com.google.common.truth.Truth.assertThat;\n@@ -45,4 +47,18 @@ public class ParameterSpecTest {\n           .isEqualTo(\"annotationSpecs == null\");\n     }\n   }\n-}\n\\ No newline at end of file\n+\n+  @Test public void addNonFinalModifier() {\n+    List<Modifier> modifiers = new ArrayList<>();\n+    modifiers.add(Modifier.FINAL);\n+    modifiers.add(Modifier.PUBLIC);\n+\n+    try {\n+      ParameterSpec.builder(int.class, \"foo\").addModifiers(modifiers);\n+      fail();\n+    } catch (Exception e) {\n+      assertThat(e.getMessage())\n+          .isEqualTo(\"unexpected parameter modifier: public\");\n+    }\n+  }\n+}\n"
    },
    {
        "commit_hash": "ea7a02ee88f8a3aa9afd3a9268390f4f9fee4b59",
        "previous_commit_hash": "c93bfa88c30940d4f9bda88cac322ebbb83703a6",
        "diff_stats": {
            "additions": 15,
            "deletions": 1
        },
        "diff_content": "@@ -82,7 +82,7 @@ public final class MethodSpec {\n \n   void emit(CodeWriter codeWriter, String enclosingName, Set<Modifier> implicitModifiers)\n       throws IOException {\n-    codeWriter.emitJavadoc(javadoc);\n+    codeWriter.emitJavadoc(javadocWithParameters());\n     codeWriter.emitAnnotations(annotations, false);\n     codeWriter.emitModifiers(modifiers, implicitModifiers);\n \n@@ -140,6 +140,20 @@ public final class MethodSpec {\n     codeWriter.popTypeVariables(typeVariables);\n   }\n \n+  private CodeBlock javadocWithParameters() {\n+    CodeBlock.Builder builder = javadoc.toBuilder();\n+    boolean emitTagNewline = true;\n+    for (ParameterSpec parameterSpec : parameters) {\n+      if (!parameterSpec.javadoc.isEmpty()) {\n+        // Emit a new line before @param section only if the method javadoc is present.\n+        if (emitTagNewline && !javadoc.isEmpty()) builder.add(\"\\n\");\n+        emitTagNewline = false;\n+        builder.add(\"@param $L $L\", parameterSpec.name, parameterSpec.javadoc);\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n   public boolean hasModifier(Modifier modifier) {\n     return modifiers.contains(modifier);\n   }\n"
    },
    {
        "commit_hash": "ea7a02ee88f8a3aa9afd3a9268390f4f9fee4b59",
        "previous_commit_hash": "c93bfa88c30940d4f9bda88cac322ebbb83703a6",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -35,12 +35,14 @@ public final class ParameterSpec {\n   public final List<AnnotationSpec> annotations;\n   public final Set<Modifier> modifiers;\n   public final TypeName type;\n+  public final CodeBlock javadoc;\n \n   private ParameterSpec(Builder builder) {\n     this.name = checkNotNull(builder.name, \"name == null\");\n     this.annotations = Util.immutableList(builder.annotations);\n     this.modifiers = Util.immutableSet(builder.modifiers);\n     this.type = checkNotNull(builder.type, \"type == null\");\n+    this.javadoc = builder.javadoc.build();\n   }\n \n   public boolean hasModifier(Modifier modifier) {\n@@ -121,6 +123,7 @@ public final class ParameterSpec {\n   public static final class Builder {\n     private final TypeName type;\n     private final String name;\n+    private final CodeBlock.Builder javadoc = CodeBlock.builder();\n \n     private final List<AnnotationSpec> annotations = new ArrayList<>();\n     private final List<Modifier> modifiers = new ArrayList<>();\n@@ -130,6 +133,16 @@ public final class ParameterSpec {\n       this.name = name;\n     }\n \n+    public Builder addJavadoc(String format, Object... args) {\n+      javadoc.add(format, args);\n+      return this;\n+    }\n+\n+    public Builder addJavadoc(CodeBlock block) {\n+      javadoc.add(block);\n+      return this;\n+    }\n+\n     public Builder addAnnotations(Iterable<AnnotationSpec> annotationSpecs) {\n       checkArgument(annotationSpecs != null, \"annotationSpecs == null\");\n       for (AnnotationSpec annotationSpec : annotationSpecs) {\n"
    },
    {
        "commit_hash": "ea7a02ee88f8a3aa9afd3a9268390f4f9fee4b59",
        "previous_commit_hash": "c93bfa88c30940d4f9bda88cac322ebbb83703a6",
        "diff_stats": {
            "additions": 53,
            "deletions": 0
        },
        "diff_content": "@@ -270,6 +270,59 @@ public final class MethodSpecTest {\n     assertThat(a.hashCode()).isEqualTo(b.hashCode());\n   }\n \n+  @Test public void withoutParameterJavaDoc() {\n+    MethodSpec methodSpec = MethodSpec.methodBuilder(\"getTaco\")\n+        .addModifiers(Modifier.PRIVATE)\n+        .addParameter(TypeName.DOUBLE, \"money\")\n+        .addJavadoc(\"Gets the best Taco\\n\")\n+        .build();\n+    assertThat(methodSpec.toString()).isEqualTo(\"\"\n+        + \"/**\\n\"\n+        + \" * Gets the best Taco\\n\"\n+        + \" */\\n\"\n+        + \"private void getTaco(double money) {\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void withParameterJavaDoc() {\n+    MethodSpec methodSpec = MethodSpec.methodBuilder(\"getTaco\")\n+        .addParameter(ParameterSpec.builder(TypeName.DOUBLE, \"money\")\n+            .addJavadoc(\"the amount required to buy the taco.\\n\")\n+            .build())\n+        .addParameter(ParameterSpec.builder(TypeName.INT, \"count\")\n+            .addJavadoc(\"the number of Tacos to buy.\\n\")\n+            .build())\n+        .addJavadoc(\"Gets the best Taco money can buy.\\n\")\n+        .build();\n+    assertThat(methodSpec.toString()).isEqualTo(\"\"\n+        + \"/**\\n\"\n+        + \" * Gets the best Taco money can buy.\\n\"\n+        + \" *\\n\"\n+        + \" * @param money the amount required to buy the taco.\\n\"\n+        + \" * @param count the number of Tacos to buy.\\n\"\n+        + \" */\\n\"\n+        + \"void getTaco(double money, int count) {\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void withParameterJavaDocAndWithoutMethodJavadoc() {\n+    MethodSpec methodSpec = MethodSpec.methodBuilder(\"getTaco\")\n+        .addParameter(ParameterSpec.builder(TypeName.DOUBLE, \"money\")\n+            .addJavadoc(\"the amount required to buy the taco.\\n\")\n+            .build())\n+        .addParameter(ParameterSpec.builder(TypeName.INT, \"count\")\n+            .addJavadoc(\"the number of Tacos to buy.\\n\")\n+            .build())\n+        .build();\n+    assertThat(methodSpec.toString()).isEqualTo(\"\"\n+        + \"/**\\n\"\n+        + \" * @param money the amount required to buy the taco.\\n\"\n+        + \" * @param count the number of Tacos to buy.\\n\"\n+        + \" */\\n\"\n+        + \"void getTaco(double money, int count) {\\n\"\n+        + \"}\\n\");\n+  }\n+\n   @Test public void duplicateExceptionsIgnored() {\n     ClassName ioException = ClassName.get(IOException.class);\n     ClassName timeoutException = ClassName.get(TimeoutException.class);\n"
    },
    {
        "commit_hash": "30a8bdaa2224f224be04261b9fceea6cd7048cd5",
        "previous_commit_hash": "ea7a02ee88f8a3aa9afd3a9268390f4f9fee4b59",
        "diff_stats": {
            "additions": 8,
            "deletions": 0
        },
        "diff_content": "@@ -138,6 +138,14 @@ public final class ClassName extends TypeName implements Comparable<ClassName> {\n     return simpleName;\n   }\n \n+  /**\n+   * Returns the full class name of this class.\n+   * Like {@code \"java.util.Map.Entry\"} for {@link Map.Entry}.\n+   * */\n+  public String canonicalName() {\n+    return canonicalName;\n+  }\n+\n   public static ClassName get(Class<?> clazz) {\n     checkNotNull(clazz, \"clazz == null\");\n     checkArgument(!clazz.isPrimitive(), \"primitive types cannot be represented as a ClassName\");\n"
    },
    {
        "commit_hash": "30a8bdaa2224f224be04261b9fceea6cd7048cd5",
        "previous_commit_hash": "ea7a02ee88f8a3aa9afd3a9268390f4f9fee4b59",
        "diff_stats": {
            "additions": 10,
            "deletions": 0
        },
        "diff_content": "@@ -193,4 +193,14 @@ public final class ClassNameTest {\n     assertEquals(\"Foo$Bar$Baz\", ClassName.get(\"\", \"Foo\", \"Bar\", \"Baz\").reflectionName());\n     assertEquals(\"a.b.c.Foo$Bar$Baz\", ClassName.get(\"a.b.c\", \"Foo\", \"Bar\", \"Baz\").reflectionName());\n   }\n+\n+  @Test\n+  public void canonicalName() {\n+    assertEquals(\"java.lang.Object\", TypeName.OBJECT.canonicalName());\n+    assertEquals(\"java.lang.Thread.State\", ClassName.get(Thread.State.class).canonicalName());\n+    assertEquals(\"java.util.Map.Entry\", ClassName.get(Map.Entry.class).canonicalName());\n+    assertEquals(\"Foo\", ClassName.get(\"\", \"Foo\").canonicalName());\n+    assertEquals(\"Foo.Bar.Baz\", ClassName.get(\"\", \"Foo\", \"Bar\", \"Baz\").canonicalName());\n+    assertEquals(\"a.b.c.Foo.Bar.Baz\", ClassName.get(\"a.b.c\", \"Foo\", \"Bar\", \"Baz\").canonicalName());\n+  }\n }\n"
    },
    {
        "commit_hash": "274bb56141c18eb39308af60e9f490d0dfce570f",
        "previous_commit_hash": "527c397d2987e44c4422412b8ab3ae5bca07db06",
        "diff_stats": {
            "additions": 0,
            "deletions": 2
        },
        "diff_content": "@@ -29,8 +29,6 @@ branches:\n notifications:\n   email: false\n \n-sudo: false\n-\n cache:\n   directories:\n     - $HOME/.m2\n"
    },
    {
        "commit_hash": "53cfc840f2b860e88e8b0aecd7026901ee76399e",
        "previous_commit_hash": "791cb9631ab76fc07bf8825f23464ecd616acccc",
        "diff_stats": {
            "additions": 6,
            "deletions": 1
        },
        "diff_content": "@@ -292,7 +292,7 @@ public final class MethodSpec {\n   }\n \n   public static final class Builder {\n-    private final String name;\n+    private String name;\n \n     private final CodeBlock.Builder javadoc = CodeBlock.builder();\n     private final List<AnnotationSpec> annotations = new ArrayList<>();\n@@ -306,11 +306,16 @@ public final class MethodSpec {\n     private CodeBlock defaultValue;\n \n     private Builder(String name) {\n+      setName(name);\n+    }\n+\n+    public Builder setName(String name) {\n       checkNotNull(name, \"name == null\");\n       checkArgument(name.equals(CONSTRUCTOR) || SourceVersion.isName(name),\n           \"not a valid name: %s\", name);\n       this.name = name;\n       this.returnType = name.equals(CONSTRUCTOR) ? null : TypeName.VOID;\n+      return this;\n     }\n \n     public Builder addJavadoc(String format, Object... args) {\n"
    },
    {
        "commit_hash": "53cfc840f2b860e88e8b0aecd7026901ee76399e",
        "previous_commit_hash": "791cb9631ab76fc07bf8825f23464ecd616acccc",
        "diff_stats": {
            "additions": 13,
            "deletions": 0
        },
        "diff_content": "@@ -37,6 +37,7 @@ import org.junit.Test;\n \n import static com.google.common.collect.Iterables.getOnlyElement;\n import static com.google.common.truth.Truth.assertThat;\n+import static com.squareup.javapoet.MethodSpec.CONSTRUCTOR;\n import static javax.lang.model.util.ElementFilter.methodsIn;\n import static org.junit.Assert.fail;\n \n@@ -355,4 +356,16 @@ public final class MethodSpecTest {\n       assertThat(e.getMessage()).isEqualTo(\"modifiers == null\");\n     }\n   }\n+\n+  @Test public void modifyMethodName() {\n+    MethodSpec methodSpec = MethodSpec.methodBuilder(\"initialMethod\")\n+        .build()\n+        .toBuilder()\n+        .setName(\"revisedMethod\")\n+        .build();\n+\n+    assertThat(methodSpec.toString()).isEqualTo(\"\"\n+        + \"void revisedMethod() {\\n\"\n+        + \"}\\n\");\n+  }\n }\n"
    },
    {
        "commit_hash": "dc30890a5002fc65eefb94a570ff4aff2d6f8577",
        "previous_commit_hash": "53cfc840f2b860e88e8b0aecd7026901ee76399e",
        "diff_stats": {
            "additions": 2,
            "deletions": 4
        },
        "diff_content": "@@ -420,10 +420,8 @@ final class CodeWriter {\n     // Match a child of the current (potentially nested) class.\n     for (int i = typeSpecStack.size() - 1; i >= 0; i--) {\n       TypeSpec typeSpec = typeSpecStack.get(i);\n-      for (TypeSpec visibleChild : typeSpec.typeSpecs) {\n-        if (Objects.equals(visibleChild.name, simpleName)) {\n-          return stackClassName(i, simpleName);\n-        }\n+      if (typeSpec.nestedTypesSimpleNames.contains(simpleName)) {\n+        return stackClassName(i, simpleName);\n       }\n     }\n \n"
    },
    {
        "commit_hash": "dc30890a5002fc65eefb94a570ff4aff2d6f8577",
        "previous_commit_hash": "53cfc840f2b860e88e8b0aecd7026901ee76399e",
        "diff_stats": {
            "additions": 6,
            "deletions": 0
        },
        "diff_content": "@@ -21,6 +21,7 @@ import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.EnumSet;\n+import java.util.HashSet;\n import java.util.Iterator;\n import java.util.LinkedHashMap;\n import java.util.List;\n@@ -53,6 +54,7 @@ public final class TypeSpec {\n   public final CodeBlock initializerBlock;\n   public final List<MethodSpec> methodSpecs;\n   public final List<TypeSpec> typeSpecs;\n+  final Set<String> nestedTypesSimpleNames;\n   public final List<Element> originatingElements;\n \n   private TypeSpec(Builder builder) {\n@@ -72,11 +74,14 @@ public final class TypeSpec {\n     this.methodSpecs = Util.immutableList(builder.methodSpecs);\n     this.typeSpecs = Util.immutableList(builder.typeSpecs);\n \n+    nestedTypesSimpleNames = new HashSet<>(builder.typeSpecs.size());\n     List<Element> originatingElementsMutable = new ArrayList<>();\n     originatingElementsMutable.addAll(builder.originatingElements);\n     for (TypeSpec typeSpec : builder.typeSpecs) {\n+      nestedTypesSimpleNames.add(typeSpec.name);\n       originatingElementsMutable.addAll(typeSpec.originatingElements);\n     }\n+\n     this.originatingElements = Util.immutableList(originatingElementsMutable);\n   }\n \n@@ -102,6 +107,7 @@ public final class TypeSpec {\n     this.methodSpecs = Collections.emptyList();\n     this.typeSpecs = Collections.emptyList();\n     this.originatingElements = Collections.emptyList();\n+    this.nestedTypesSimpleNames = Collections.emptySet();\n   }\n \n   public boolean hasModifier(Modifier modifier) {\n"
    },
    {
        "commit_hash": "c054ce927191205b4a870b40eecfe63dffaba0e6",
        "previous_commit_hash": "791cb9631ab76fc07bf8825f23464ecd616acccc",
        "diff_stats": {
            "additions": 54,
            "deletions": 0
        },
        "diff_content": "@@ -128,6 +128,60 @@ int multiply10to20() {\n Methods generating methods! And since JavaPoet generates source instead of bytecode, you can\n read through it to make sure it's right.\n \n+Some control flow statements, such as `if/else`, can have unlimited control flow possibilities.\n+You can handle those options using `nextControlFlow()`:\n+\n+```java\n+MethodSpec main = MethodSpec.methodBuilder(\"main\")\n+    .addStatement(\"long now = $T.currentTimeMillis()\", System.class)\n+    .beginControlFlow(\"if ($T.currentTimeMillis() < now)\", System.class)\n+    .addStatement(\"$T.out.println($S)\", System.class, \"Time travelling, woo hoo!\")\n+    .nextControlFlow(\"else if ($T.currentTimeMillis() == now)\", System.class)\n+    .addStatement(\"$T.out.println($S)\", System.class, \"Time stood still!\")\n+    .nextControlFlow(\"else\")\n+    .addStatement(\"$T.out.println($S)\", System.class, \"Ok, time still moving forward\")\n+    .endControlFlow()\n+    .build();\n+```\n+\n+Which generates:\n+\n+```java\n+void main() {\n+  long now = System.currentTimeMillis();\n+  if (System.currentTimeMillis() < now)  {\n+    System.out.println(\"Time travelling, woo hoo!\");\n+  } else if (System.currentTimeMillis() == now) {\n+    System.out.println(\"Time stood still!\");\n+  } else {\n+    System.out.println(\"Ok, time still moving forward\");\n+  }\n+}\n+``` \n+\n+Catching exceptions using `try/catch` is also a use case for `nextControlFlow()`:\n+\n+```java\n+MethodSpec main = MethodSpec.methodBuilder(\"main\")\n+    .beginControlFlow(\"try\")\n+    .addStatement(\"throw new Exception($S)\", \"Failed\")\n+    .nextControlFlow(\"catch ($T e)\", Exception.class)\n+    .addStatement(\"throw new $T(e)\", RuntimeException.class)\n+    .endControlFlow()\n+    .build();\n+```\n+\n+Which produces:\n+\n+```java\n+void main() {\n+  try {\n+    throw new Exception(\"Failed\");\n+  } catch (Exception e) {\n+    throw new RuntimeException(e);\n+  }\n+}\n+```\n \n ### $L for Literals\n \n"
    },
    {
        "commit_hash": "a481d9d4c8e6e0b54887265b560b02946c318230",
        "previous_commit_hash": "218e4ad9c84fc72e6a56e20c114b221f35d2e26e",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -123,7 +123,7 @@\n           <dependency>\n             <groupId>com.puppycrawl.tools</groupId>\n             <artifactId>checkstyle</artifactId>\n-            <version>8.7</version>\n+            <version>8.18</version>\n           </dependency>\n         </dependencies>\n         <configuration>\n"
    },
    {
        "commit_hash": "e79bb2f09d29678ece0abfb50abe3e4a855aee4f",
        "previous_commit_hash": "1676ff4a8cd00888e7514c7ccfba974df7ce4372",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -189,7 +189,7 @@ public final class CodeBlock {\n       while (p < format.length()) {\n         int nextP = format.indexOf(\"$\", p);\n         if (nextP == -1) {\n-          formatParts.add(format.substring(p, format.length()));\n+          formatParts.add(format.substring(p));\n           break;\n         }\n \n"
    },
    {
        "commit_hash": "02ece26b2e05f3b1306f67aacc3a8932a3e51d51",
        "previous_commit_hash": "c4ac60e768c573cd1f682dac4d6922c05071c16c",
        "diff_stats": {
            "additions": 13,
            "deletions": 4
        },
        "diff_content": "@@ -41,6 +41,8 @@ public final class ClassName extends TypeName implements Comparable<ClassName> {\n   /** This class name, like \"Entry\" for java.util.Map.Entry. */\n   final String simpleName;\n \n+  private List<String> simpleNames;\n+\n   /** The full class name like \"java.util.Map.Entry\". */\n   final String canonicalName;\n \n@@ -108,11 +110,18 @@ public final class ClassName extends TypeName implements Comparable<ClassName> {\n   }\n \n   public List<String> simpleNames() {\n-    List<String> simpleNames = new ArrayList<>();\n-    if (enclosingClassName != null) {\n-      simpleNames.addAll(enclosingClassName().simpleNames());\n+    if (simpleNames != null) {\n+      return simpleNames;\n+    }\n+\n+    if (enclosingClassName == null) {\n+      simpleNames = Collections.singletonList(simpleName);\n+    } else {\n+      List<String> mutableNames = new ArrayList<>();\n+      mutableNames.addAll(enclosingClassName().simpleNames());\n+      mutableNames.add(simpleName);\n+      simpleNames = Collections.unmodifiableList(mutableNames);\n     }\n-    simpleNames.add(simpleName);\n     return simpleNames;\n   }\n \n"
    },
    {
        "commit_hash": "3829f2ca6f03a4b941fea41a1e2f4eead8f37bc1",
        "previous_commit_hash": "0f93da9a3d9a1da8d29fc993409fcf83d40452bc",
        "diff_stats": {
            "additions": 7,
            "deletions": 3
        },
        "diff_content": "@@ -20,6 +20,7 @@ import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n+import java.util.Objects;\n import javax.lang.model.element.Element;\n import javax.lang.model.element.PackageElement;\n import javax.lang.model.element.TypeElement;\n@@ -32,6 +33,9 @@ import static com.squareup.javapoet.Util.checkNotNull;\n public final class ClassName extends TypeName implements Comparable<ClassName> {\n   public static final ClassName OBJECT = ClassName.get(Object.class);\n \n+  /** The name representing the default Java package. */\n+  private static final String NO_PACKAGE = \"\";\n+\n   /** The package name of this class, or \"\" if this is in the default package. */\n   final String packageName;\n \n@@ -53,7 +57,7 @@ public final class ClassName extends TypeName implements Comparable<ClassName> {\n   private ClassName(String packageName, ClassName enclosingClassName, String simpleName,\n       List<AnnotationSpec> annotations) {\n     super(annotations);\n-    this.packageName = packageName;\n+    this.packageName = Objects.requireNonNull(packageName, \"packageName == null\");\n     this.enclosingClassName = enclosingClassName;\n     this.simpleName = simpleName;\n     this.canonicalName = enclosingClassName != null\n@@ -172,7 +176,7 @@ public final class ClassName extends TypeName implements Comparable<ClassName> {\n     if (clazz.getEnclosingClass() == null) {\n       // Avoid unreliable Class.getPackage(). https://github.com/square/javapoet/issues/295\n       int lastDot = clazz.getName().lastIndexOf('.');\n-      String packageName = (lastDot != -1) ? clazz.getName().substring(0, lastDot) : null;\n+      String packageName = (lastDot != -1) ? clazz.getName().substring(0, lastDot) : NO_PACKAGE;\n       return new ClassName(packageName, null, name);\n     }\n \n@@ -194,7 +198,7 @@ public final class ClassName extends TypeName implements Comparable<ClassName> {\n       p = classNameString.indexOf('.', p) + 1;\n       checkArgument(p != 0, \"couldn't make a guess for %s\", classNameString);\n     }\n-    String packageName = p == 0 ? \"\" : classNameString.substring(0, p - 1);\n+    String packageName = p == 0 ? NO_PACKAGE : classNameString.substring(0, p - 1);\n \n     // Add class names like \"Map\" and \"Entry\".\n     ClassName className = null;\n"
    },
    {
        "commit_hash": "3829f2ca6f03a4b941fea41a1e2f4eead8f37bc1",
        "previous_commit_hash": "0f93da9a3d9a1da8d29fc993409fcf83d40452bc",
        "diff_stats": {
            "additions": 33,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,33 @@\n+/*\n+ * Copyright (C) 2019 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import com.squareup.javapoet.ClassName;\n+import org.junit.Test;\n+\n+/**\n+ * Since it is impossible to import classes from the default package into other\n+ * modules, this test must live in this package.\n+ */\n+public final class ClassNameNoPackageTest {\n+  @Test public void shouldSupportClassInDefaultPackage() {\n+    ClassName className = ClassName.get(ClassNameNoPackageTest.class);\n+    assertThat(className.packageName()).isEqualTo(\"\");\n+    assertThat(className.simpleName()).isEqualTo(\"ClassNameNoPackageTest\");\n+    assertThat(className.toString()).isEqualTo(\"ClassNameNoPackageTest\");\n+  }\n+}\n"
    },
    {
        "commit_hash": "8bc90713f5efe4f827cb4af5aa558e170073ed27",
        "previous_commit_hash": "3829f2ca6f03a4b941fea41a1e2f4eead8f37bc1",
        "diff_stats": {
            "additions": 1,
            "deletions": 3
        },
        "diff_content": "@@ -139,9 +139,7 @@ public final class TypeSpec {\n   }\n \n   public static Builder anonymousClassBuilder(String typeArgumentsFormat, Object... args) {\n-    return anonymousClassBuilder(CodeBlock.builder()\n-        .add(typeArgumentsFormat, args)\n-        .build());\n+    return anonymousClassBuilder(CodeBlock.of(typeArgumentsFormat, args));\n   }\n \n   public static Builder anonymousClassBuilder(CodeBlock typeArguments) {\n"
    },
    {
        "commit_hash": "a03c97888d3afeeaa92e8ee8eaaffb19fccbaba1",
        "previous_commit_hash": "c1f97f4b8e22f429228d2844202f3a558215af40",
        "diff_stats": {
            "additions": 10,
            "deletions": 1
        },
        "diff_content": "@@ -22,6 +22,7 @@ import java.io.InputStream;\n import java.io.OutputStreamWriter;\n import java.io.Writer;\n import java.net.URI;\n+import java.nio.charset.Charset;\n import java.nio.file.Files;\n import java.nio.file.Path;\n import java.util.Arrays;\n@@ -83,6 +84,14 @@ public final class JavaFile {\n \n   /** Writes this to {@code directory} as UTF-8 using the standard directory structure. */\n   public void writeTo(Path directory) throws IOException {\n+    writeTo(directory, UTF_8);\n+  }\n+\n+  /**\n+   * Writes this to {@code directory} with the provided {@code charset}\n+   * using the standard directory structure.\n+   */\n+  public void writeTo(Path directory, Charset charset) throws IOException {\n     checkArgument(Files.notExists(directory) || Files.isDirectory(directory),\n         \"path %s exists but is not a directory.\", directory);\n     Path outputDirectory = directory;\n@@ -94,7 +103,7 @@ public final class JavaFile {\n     }\n \n     Path outputPath = outputDirectory.resolve(typeSpec.name + \".java\");\n-    try (Writer writer = new OutputStreamWriter(Files.newOutputStream(outputPath), UTF_8)) {\n+    try (Writer writer = new OutputStreamWriter(Files.newOutputStream(outputPath), charset)) {\n       writeTo(writer);\n     }\n   }\n"
    },
    {
        "commit_hash": "d13cf256ecdad39a556c0ae7224e25e0fc30bd6f",
        "previous_commit_hash": "a03c97888d3afeeaa92e8ee8eaaffb19fccbaba1",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@\n # https://benlimmer.com/2013/12/26/automatically-publish-javadoc-to-gh-pages-with-travis-ci/\n \n SLUG=\"square/javapoet\"\n-JDK=\"oraclejdk8\"\n+JDK=\"openjdk8\"\n BRANCH=\"master\"\n \n set -e\n"
    },
    {
        "commit_hash": "d13cf256ecdad39a556c0ae7224e25e0fc30bd6f",
        "previous_commit_hash": "a03c97888d3afeeaa92e8ee8eaaffb19fccbaba1",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -2,7 +2,7 @@ language: java\n \n matrix:\n   include:\n-    - jdk: oraclejdk8\n+    - jdk: openjdk8\n     - jdk: openjdk10\n     - jdk: openjdk11\n     - jdk: openjdk-ea\n"
    },
    {
        "commit_hash": "4e8f72f6a989ffbf99f0df4bbf0ab408ba412887",
        "previous_commit_hash": "d70a3035e5ed6d03108b26c557ff26aca34467dc",
        "diff_stats": {
            "additions": 6,
            "deletions": 0
        },
        "diff_content": "@@ -424,6 +424,12 @@ public final class CodeBlock {\n       return this;\n     }\n \n+    public Builder clear() {\n+      formatParts.clear();\n+      args.clear();\n+      return this;\n+    }\n+\n     public CodeBlock build() {\n       return new CodeBlock(this);\n     }\n"
    },
    {
        "commit_hash": "4e8f72f6a989ffbf99f0df4bbf0ab408ba412887",
        "previous_commit_hash": "d70a3035e5ed6d03108b26c557ff26aca34467dc",
        "diff_stats": {
            "additions": 9,
            "deletions": 0
        },
        "diff_content": "@@ -339,4 +339,13 @@ public final class CodeBlockTest {\n     CodeBlock joined = codeBlocks.stream().collect(CodeBlock.joining(\" || \", \"start {\", \"} end\"));\n     assertThat(joined.toString()).isEqualTo(\"start {\\\"hello\\\" || world.World || need tacos} end\");\n   }\n+\n+  @Test public void clear() {\n+    CodeBlock block = CodeBlock.builder()\n+        .addStatement(\"$S\", \"Test string\")\n+        .clear()\n+        .build();\n+\n+    assertThat(block.toString()).isEmpty();\n+  }\n }\n"
    },
    {
        "commit_hash": "a0eadbbf0e7b70f0fbbc66043536e4328c3808fd",
        "previous_commit_hash": "e9460b84fc41464c2aa2ef85c84dd1ac87ae1692",
        "diff_stats": {
            "additions": 11,
            "deletions": 0
        },
        "diff_content": "@@ -21,7 +21,9 @@ import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n import java.util.Set;\n+import java.util.stream.Collectors;\n import javax.lang.model.SourceVersion;\n+import javax.lang.model.element.ElementKind;\n import javax.lang.model.element.ExecutableElement;\n import javax.lang.model.element.Modifier;\n import javax.lang.model.element.VariableElement;\n@@ -83,10 +85,19 @@ public final class ParameterSpec {\n   }\n \n   public static ParameterSpec get(VariableElement element) {\n+    checkArgument(element.getKind().equals(ElementKind.PARAMETER), \"element is not a parameter\");\n+\n+    // Copy over any annotations from element.\n+    List<AnnotationSpec> annotations = element.getAnnotationMirrors()\n+        .stream()\n+        .map((mirror) -> AnnotationSpec.get(mirror))\n+        .collect(Collectors.toList());\n+\n     TypeName type = TypeName.get(element.asType());\n     String name = element.getSimpleName().toString();\n     return ParameterSpec.builder(type, name)\n         .addModifiers(element.getModifiers())\n+        .addAnnotations(annotations)\n         .build();\n   }\n \n"
    },
    {
        "commit_hash": "a0eadbbf0e7b70f0fbbc66043536e4328c3808fd",
        "previous_commit_hash": "e9460b84fc41464c2aa2ef85c84dd1ac87ae1692",
        "diff_stats": {
            "additions": 6,
            "deletions": 12
        },
        "diff_content": "@@ -38,6 +38,7 @@ import org.junit.Test;\n import static com.google.common.collect.Iterables.getOnlyElement;\n import static com.google.common.truth.Truth.assertThat;\n import static com.squareup.javapoet.MethodSpec.CONSTRUCTOR;\n+import static com.squareup.javapoet.TestUtil.findFirst;\n import static javax.lang.model.util.ElementFilter.methodsIn;\n import static org.junit.Assert.fail;\n \n@@ -56,15 +57,6 @@ public final class MethodSpecTest {\n     return elements.getTypeElement(clazz.getCanonicalName());\n   }\n \n-  private ExecutableElement findFirst(Collection<ExecutableElement> elements, String name) {\n-    for (ExecutableElement executableElement : elements) {\n-      if (executableElement.getSimpleName().toString().equals(name)) {\n-        return executableElement;\n-      }\n-    }\n-    throw new IllegalArgumentException(name + \" not found in \" + elements);\n-  }\n-\n   @Test public void nullAnnotationsAddition() {\n     try {\n       MethodSpec.methodBuilder(\"doSomething\").addAnnotations(null);\n@@ -155,8 +147,8 @@ public final class MethodSpecTest {\n         + \"@java.lang.Override\\n\"\n         + \"protected <T extends java.lang.Runnable & java.io.Closeable> java.lang.Runnable \"\n         + \"everything(\\n\"\n-        + \"    java.lang.String arg0, java.util.List<? extends T> arg1) throws java.io.IOException,\\n\"\n-        + \"    java.lang.SecurityException {\\n\"\n+        + \"    @com.squareup.javapoet.MethodSpecTest.Nullable java.lang.String arg0,\\n\"\n+        + \"    java.util.List<? extends T> arg1) throws java.io.IOException, java.lang.SecurityException {\\n\"\n         + \"}\\n\");\n   }\n \n@@ -187,7 +179,9 @@ public final class MethodSpecTest {\n     TypeElement classElement = getElement(ExtendsIterableWithDefaultMethods.class);\n     DeclaredType classType = (DeclaredType) classElement.asType();\n     List<ExecutableElement> methods = methodsIn(elements.getAllMembers(classElement));\n-    ExecutableElement exec = findFirst(methods, \"spliterator\");\n+    ExecutableElement exec = \n+      \n+      (methods, \"spliterator\");\n     MethodSpec method = MethodSpec.overriding(exec, classType, types).build();\n     assertThat(method.toString()).isEqualTo(\"\"\n         + \"@java.lang.Override\\n\"\n"
    },
    {
        "commit_hash": "a0eadbbf0e7b70f0fbbc66043536e4328c3808fd",
        "previous_commit_hash": "e9460b84fc41464c2aa2ef85c84dd1ac87ae1692",
        "diff_stats": {
            "additions": 55,
            "deletions": 0
        },
        "diff_content": "@@ -15,16 +15,39 @@\n  */\n package com.squareup.javapoet;\n \n+import com.google.testing.compile.CompilationRule;\n import java.util.ArrayList;\n import java.util.List;\n+import javax.annotation.Nullable;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.util.Elements;\n+import org.junit.Before;\n+import org.junit.Rule;\n import org.junit.Test;\n \n import static com.google.common.truth.Truth.assertThat;\n+import static com.squareup.javapoet.TestUtil.findFirst;\n+import static javax.lang.model.util.ElementFilter.fieldsIn;\n+import static javax.lang.model.util.ElementFilter.methodsIn;\n import static org.junit.Assert.fail;\n \n import javax.lang.model.element.Modifier;\n \n public class ParameterSpecTest {\n+  @Rule public final CompilationRule compilation = new CompilationRule();\n+\n+  private Elements elements;\n+\n+  @Before public void setUp() {\n+    elements = compilation.getElements();\n+  }\n+\n+  private TypeElement getElement(Class<?> clazz) {\n+    return elements.getTypeElement(clazz.getCanonicalName());\n+  }\n+\n   @Test public void equalsAndHashCode() {\n     ParameterSpec a = ParameterSpec.builder(int.class, \"foo\").build();\n     ParameterSpec b = ParameterSpec.builder(int.class, \"foo\").build();\n@@ -48,6 +71,38 @@ public class ParameterSpecTest {\n     }\n   }\n \n+  final class VariableElementFieldClass {\n+    String name;\n+  }\n+\n+  @Test public void fieldVariableElement() {\n+    TypeElement classElement = getElement(VariableElementFieldClass.class);\n+    List<VariableElement> methods = fieldsIn(elements.getAllMembers(classElement));\n+    VariableElement element = findFirst(methods, \"name\");\n+\n+    try {\n+      ParameterSpec.get(element);\n+      fail();\n+    } catch (IllegalArgumentException exception) {\n+      assertThat(exception).hasMessageThat().isEqualTo(\"element is not a parameter\");\n+    }\n+  }\n+\n+  final class VariableElementParameterClass {\n+    public void foo(@Nullable final String bar) {\n+    }\n+  }\n+\n+  @Test public void parameterVariableElement() {\n+    TypeElement classElement = getElement(VariableElementParameterClass.class);\n+    List<ExecutableElement> methods = methodsIn(elements.getAllMembers(classElement));\n+    ExecutableElement element = findFirst(methods, \"foo\");\n+    VariableElement parameterElement = element.getParameters().get(0);\n+\n+    assertThat(ParameterSpec.get(parameterElement).toString())\n+        .isEqualTo(\"@javax.annotation.Nullable java.lang.String arg0\");\n+  }\n+\n   @Test public void addNonFinalModifier() {\n     List<Modifier> modifiers = new ArrayList<>();\n     modifiers.add(Modifier.FINAL);\n"
    },
    {
        "commit_hash": "a0eadbbf0e7b70f0fbbc66043536e4328c3808fd",
        "previous_commit_hash": "e9460b84fc41464c2aa2ef85c84dd1ac87ae1692",
        "diff_stats": {
            "additions": 17,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,17 @@\n+package com.squareup.javapoet;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.VariableElement;\n+import java.util.Collection;\n+\n+final class TestUtil {\n+  static <E extends Element> E findFirst(Collection<E> elements, String name) {\n+    for (E element : elements) {\n+      if (element.getSimpleName().toString().equals(name)) {\n+        return element;\n+      }\n+    }\n+    throw new IllegalArgumentException(name + \" not found in \" + elements);\n+  }\n+}\n"
    },
    {
        "commit_hash": "e6993cc2af1a2db55c134e45dc324148d76b3993",
        "previous_commit_hash": "a0eadbbf0e7b70f0fbbc66043536e4328c3808fd",
        "diff_stats": {
            "additions": 1,
            "deletions": 3
        },
        "diff_content": "@@ -179,9 +179,7 @@ public final class MethodSpecTest {\n     TypeElement classElement = getElement(ExtendsIterableWithDefaultMethods.class);\n     DeclaredType classType = (DeclaredType) classElement.asType();\n     List<ExecutableElement> methods = methodsIn(elements.getAllMembers(classElement));\n-    ExecutableElement exec = \n-      \n-      (methods, \"spliterator\");\n+    ExecutableElement exec = findFirst(methods, \"spliterator\");\n     MethodSpec method = MethodSpec.overriding(exec, classType, types).build();\n     assertThat(method.toString()).isEqualTo(\"\"\n         + \"@java.lang.Override\\n\"\n"
    },
    {
        "commit_hash": "2d6680b249a6188d719e72d9dad9a9ee8a84c3b8",
        "previous_commit_hash": "e6993cc2af1a2db55c134e45dc324148d76b3993",
        "diff_stats": {
            "additions": 0,
            "deletions": 4
        },
        "diff_content": "@@ -3,13 +3,9 @@ language: java\n matrix:\n   include:\n     - jdk: openjdk8\n-    - jdk: openjdk10\n     - jdk: openjdk11\n-    - jdk: openjdk-ea\n   allow_failures:\n-    # ErrorProne/javac is not yet working on JDK 11 nor 12 (current -ea)\n     - jdk: openjdk11\n-    - jdk: openjdk-ea\n \n before_install:\n   - unset _JAVA_OPTIONS\n"
    },
    {
        "commit_hash": "4272265a319a562bceaa537fc1b9b6b40236a881",
        "previous_commit_hash": "3f5386230e12b8e9d3baf760ae3563b3f303f60c",
        "diff_stats": {
            "additions": 6,
            "deletions": 3
        },
        "diff_content": "@@ -192,7 +192,8 @@ public final class AnnotationSpec {\n \n   public static final class Builder {\n     private final TypeName type;\n-    private final Map<String, List<CodeBlock>> members = new LinkedHashMap<>();\n+\n+    public final Map<String, List<CodeBlock>> members = new LinkedHashMap<>();\n \n     private Builder(TypeName type) {\n       this.type = type;\n@@ -203,8 +204,6 @@ public final class AnnotationSpec {\n     }\n \n     public Builder addMember(String name, CodeBlock codeBlock) {\n-      checkNotNull(name, \"name == null\");\n-      checkArgument(SourceVersion.isName(name), \"not a valid name: %s\", name);\n       List<CodeBlock> values = members.computeIfAbsent(name, k -> new ArrayList<>());\n       values.add(codeBlock);\n       return this;\n@@ -238,6 +237,10 @@ public final class AnnotationSpec {\n     }\n \n     public AnnotationSpec build() {\n+      for (String name : members.keySet()) {\n+        checkNotNull(name, \"name == null\");\n+        checkArgument(SourceVersion.isName(name), \"not a valid name: %s\", name);\n+      }\n       return new AnnotationSpec(this);\n     }\n   }\n"
    },
    {
        "commit_hash": "4272265a319a562bceaa537fc1b9b6b40236a881",
        "previous_commit_hash": "3f5386230e12b8e9d3baf760ae3563b3f303f60c",
        "diff_stats": {
            "additions": 3,
            "deletions": 2
        },
        "diff_content": "@@ -111,10 +111,11 @@ public final class FieldSpec {\n     private final String name;\n \n     private final CodeBlock.Builder javadoc = CodeBlock.builder();\n-    private final List<AnnotationSpec> annotations = new ArrayList<>();\n-    private final List<Modifier> modifiers = new ArrayList<>();\n     private CodeBlock initializer = null;\n \n+    public final List<AnnotationSpec> annotations = new ArrayList<>();\n+    public final List<Modifier> modifiers = new ArrayList<>();\n+\n     private Builder(TypeName type, String name) {\n       this.type = type;\n       this.name = name;\n"
    },
    {
        "commit_hash": "4272265a319a562bceaa537fc1b9b6b40236a881",
        "previous_commit_hash": "3f5386230e12b8e9d3baf760ae3563b3f303f60c",
        "diff_stats": {
            "additions": 2,
            "deletions": 1
        },
        "diff_content": "@@ -225,10 +225,11 @@ public final class JavaFile {\n     private final String packageName;\n     private final TypeSpec typeSpec;\n     private final CodeBlock.Builder fileComment = CodeBlock.builder();\n-    private final Set<String> staticImports = new TreeSet<>();\n     private boolean skipJavaLangImports;\n     private String indent = \"  \";\n \n+    public final Set<String> staticImports = new TreeSet<>();\n+\n     private Builder(String packageName, TypeSpec typeSpec) {\n       this.packageName = packageName;\n       this.typeSpec = typeSpec;\n"
    },
    {
        "commit_hash": "4272265a319a562bceaa537fc1b9b6b40236a881",
        "previous_commit_hash": "3f5386230e12b8e9d3baf760ae3563b3f303f60c",
        "diff_stats": {
            "additions": 5,
            "deletions": 4
        },
        "diff_content": "@@ -295,16 +295,17 @@ public final class MethodSpec {\n     private String name;\n \n     private final CodeBlock.Builder javadoc = CodeBlock.builder();\n-    private final List<AnnotationSpec> annotations = new ArrayList<>();\n-    private final List<Modifier> modifiers = new ArrayList<>();\n-    private List<TypeVariableName> typeVariables = new ArrayList<>();\n     private TypeName returnType;\n-    private final List<ParameterSpec> parameters = new ArrayList<>();\n     private final Set<TypeName> exceptions = new LinkedHashSet<>();\n     private final CodeBlock.Builder code = CodeBlock.builder();\n     private boolean varargs;\n     private CodeBlock defaultValue;\n \n+    public final List<TypeVariableName> typeVariables = new ArrayList<>();\n+    public final List<AnnotationSpec> annotations = new ArrayList<>();\n+    public final List<Modifier> modifiers = new ArrayList<>();\n+    public final List<ParameterSpec> parameters = new ArrayList<>();\n+\n     private Builder(String name) {\n       setName(name);\n     }\n"
    },
    {
        "commit_hash": "4272265a319a562bceaa537fc1b9b6b40236a881",
        "previous_commit_hash": "3f5386230e12b8e9d3baf760ae3563b3f303f60c",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -136,8 +136,8 @@ public final class ParameterSpec {\n     private final String name;\n     private final CodeBlock.Builder javadoc = CodeBlock.builder();\n \n-    private final List<AnnotationSpec> annotations = new ArrayList<>();\n-    private final List<Modifier> modifiers = new ArrayList<>();\n+    public final List<AnnotationSpec> annotations = new ArrayList<>();\n+    public final List<Modifier> modifiers = new ArrayList<>();\n \n     private Builder(TypeName type, String name) {\n       this.type = type;\n"
    },
    {
        "commit_hash": "4272265a319a562bceaa537fc1b9b6b40236a881",
        "previous_commit_hash": "3f5386230e12b8e9d3baf760ae3563b3f303f60c",
        "diff_stats": {
            "additions": 76,
            "deletions": 46
        },
        "diff_content": "@@ -400,18 +400,19 @@ public final class TypeSpec {\n     private final CodeBlock anonymousTypeArguments;\n \n     private final CodeBlock.Builder javadoc = CodeBlock.builder();\n-    private final List<AnnotationSpec> annotations = new ArrayList<>();\n-    private final List<Modifier> modifiers = new ArrayList<>();\n-    private final List<TypeVariableName> typeVariables = new ArrayList<>();\n     private TypeName superclass = ClassName.OBJECT;\n-    private final List<TypeName> superinterfaces = new ArrayList<>();\n-    private final Map<String, TypeSpec> enumConstants = new LinkedHashMap<>();\n-    private final List<FieldSpec> fieldSpecs = new ArrayList<>();\n     private final CodeBlock.Builder staticBlock = CodeBlock.builder();\n     private final CodeBlock.Builder initializerBlock = CodeBlock.builder();\n-    private final List<MethodSpec> methodSpecs = new ArrayList<>();\n-    private final List<TypeSpec> typeSpecs = new ArrayList<>();\n-    private final List<Element> originatingElements = new ArrayList<>();\n+\n+    public final Map<String, TypeSpec> enumConstants = new LinkedHashMap<>();\n+    public final List<AnnotationSpec> annotations = new ArrayList<>();\n+    public final List<Modifier> modifiers = new ArrayList<>();\n+    public final List<TypeVariableName> typeVariables = new ArrayList<>();\n+    public final List<TypeName> superinterfaces = new ArrayList<>();\n+    public final List<FieldSpec> fieldSpecs = new ArrayList<>();\n+    public final List<MethodSpec> methodSpecs = new ArrayList<>();\n+    public final List<TypeSpec> typeSpecs = new ArrayList<>();\n+    public final List<Element> originatingElements = new ArrayList<>();\n \n     private Builder(Kind kind, String name,\n         CodeBlock anonymousTypeArguments) {\n@@ -454,16 +455,11 @@ public final class TypeSpec {\n     }\n \n     public Builder addModifiers(Modifier... modifiers) {\n-      checkState(anonymousTypeArguments == null, \"forbidden on anonymous types.\");\n-      for (Modifier modifier : modifiers) {\n-        checkArgument(modifier != null, \"modifiers contain null\");\n-        this.modifiers.add(modifier);\n-      }\n+      Collections.addAll(this.modifiers, modifiers);\n       return this;\n     }\n \n     public Builder addTypeVariables(Iterable<TypeVariableName> typeVariables) {\n-      checkState(anonymousTypeArguments == null, \"forbidden on anonymous types.\");\n       checkArgument(typeVariables != null, \"typeVariables == null\");\n       for (TypeVariableName typeVariable : typeVariables) {\n         this.typeVariables.add(typeVariable);\n@@ -472,7 +468,6 @@ public final class TypeSpec {\n     }\n \n     public Builder addTypeVariable(TypeVariableName typeVariable) {\n-      checkState(anonymousTypeArguments == null, \"forbidden on anonymous types.\");\n       typeVariables.add(typeVariable);\n       return this;\n     }\n@@ -513,10 +508,6 @@ public final class TypeSpec {\n     }\n \n     public Builder addEnumConstant(String name, TypeSpec typeSpec) {\n-      checkState(kind == Kind.ENUM, \"%s is not enum\", this.name);\n-      checkArgument(typeSpec.anonymousTypeArguments != null,\n-          \"enum constants must have anonymous type arguments\");\n-      checkArgument(SourceVersion.isName(name), \"not a valid enum constant: %s\", name);\n       enumConstants.put(name, typeSpec);\n       return this;\n     }\n@@ -530,12 +521,6 @@ public final class TypeSpec {\n     }\n \n     public Builder addField(FieldSpec fieldSpec) {\n-      if (kind == Kind.INTERFACE || kind == Kind.ANNOTATION) {\n-        requireExactlyOneOf(fieldSpec.modifiers, Modifier.PUBLIC, Modifier.PRIVATE);\n-        Set<Modifier> check = EnumSet.of(Modifier.STATIC, Modifier.FINAL);\n-        checkState(fieldSpec.modifiers.containsAll(check), \"%s %s.%s requires modifiers %s\",\n-            kind, name, fieldSpec.name, check);\n-      }\n       fieldSpecs.add(fieldSpec);\n       return this;\n     }\n@@ -574,23 +559,6 @@ public final class TypeSpec {\n     }\n \n     public Builder addMethod(MethodSpec methodSpec) {\n-      if (kind == Kind.INTERFACE) {\n-        requireExactlyOneOf(methodSpec.modifiers, Modifier.ABSTRACT, Modifier.STATIC,\n-            Modifier.DEFAULT);\n-        requireExactlyOneOf(methodSpec.modifiers, Modifier.PUBLIC, Modifier.PRIVATE);\n-      } else if (kind == Kind.ANNOTATION) {\n-        checkState(methodSpec.modifiers.equals(kind.implicitMethodModifiers),\n-            \"%s %s.%s requires modifiers %s\",\n-            kind, name, methodSpec.name, kind.implicitMethodModifiers);\n-      }\n-      if (kind != Kind.ANNOTATION) {\n-        checkState(methodSpec.defaultValue == null, \"%s %s.%s cannot have a default value\",\n-            kind, name, methodSpec.name);\n-      }\n-      if (kind != Kind.INTERFACE) {\n-        checkState(!methodSpec.hasModifier(Modifier.DEFAULT), \"%s %s.%s cannot be default\",\n-            kind, name, methodSpec.name);\n-      }\n       methodSpecs.add(methodSpec);\n       return this;\n     }\n@@ -604,9 +572,6 @@ public final class TypeSpec {\n     }\n \n     public Builder addType(TypeSpec typeSpec) {\n-      checkArgument(typeSpec.modifiers.containsAll(kind.implicitTypeModifiers),\n-          \"%s %s.%s requires modifiers %s\", kind, name, typeSpec.name,\n-          kind.implicitTypeModifiers);\n       typeSpecs.add(typeSpec);\n       return this;\n     }\n@@ -617,9 +582,74 @@ public final class TypeSpec {\n     }\n \n     public TypeSpec build() {\n+      for (AnnotationSpec annotationSpec : annotations) {\n+        checkNotNull(annotationSpec, \"annotationSpec == null\");\n+      }\n+\n+      if (!modifiers.isEmpty()) {\n+        checkState(anonymousTypeArguments == null, \"forbidden on anonymous types.\");\n+        for (Modifier modifier : modifiers) {\n+          checkArgument(modifier != null, \"modifiers contain null\");\n+        }\n+      }\n+\n       checkArgument(kind != Kind.ENUM || !enumConstants.isEmpty(),\n           \"at least one enum constant is required for %s\", name);\n \n+      for (TypeName superinterface : superinterfaces) {\n+        checkArgument(superinterface != null, \"superinterfaces contains null\");\n+      }\n+\n+      if (!typeVariables.isEmpty()) {\n+        checkState(anonymousTypeArguments == null,\n+            \"typevariables are forbidden on anonymous types.\");\n+        for (TypeVariableName typeVariableName : typeVariables) {\n+          checkArgument(typeVariableName != null, \"typeVariables contain null\");\n+        }\n+      }\n+\n+      for (Map.Entry<String, TypeSpec> enumConstant : enumConstants.entrySet()) {\n+        checkState(kind == Kind.ENUM, \"%s is not enum\", this.name);\n+        checkArgument(enumConstant.getValue().anonymousTypeArguments != null,\n+            \"enum constants must have anonymous type arguments\");\n+        checkArgument(SourceVersion.isName(name), \"not a valid enum constant: %s\", name);\n+      }\n+\n+      for (FieldSpec fieldSpec : fieldSpecs) {\n+        if (kind == Kind.INTERFACE || kind == Kind.ANNOTATION) {\n+          requireExactlyOneOf(fieldSpec.modifiers, Modifier.PUBLIC, Modifier.PRIVATE);\n+          Set<Modifier> check = EnumSet.of(Modifier.STATIC, Modifier.FINAL);\n+          checkState(fieldSpec.modifiers.containsAll(check), \"%s %s.%s requires modifiers %s\",\n+              kind, name, fieldSpec.name, check);\n+        }\n+      }\n+\n+      for (MethodSpec methodSpec : methodSpecs) {\n+        if (kind == Kind.INTERFACE) {\n+          requireExactlyOneOf(methodSpec.modifiers, Modifier.ABSTRACT, Modifier.STATIC,\n+              Modifier.DEFAULT);\n+          requireExactlyOneOf(methodSpec.modifiers, Modifier.PUBLIC, Modifier.PRIVATE);\n+        } else if (kind == Kind.ANNOTATION) {\n+          checkState(methodSpec.modifiers.equals(kind.implicitMethodModifiers),\n+              \"%s %s.%s requires modifiers %s\",\n+              kind, name, methodSpec.name, kind.implicitMethodModifiers);\n+        }\n+        if (kind != Kind.ANNOTATION) {\n+          checkState(methodSpec.defaultValue == null, \"%s %s.%s cannot have a default value\",\n+              kind, name, methodSpec.name);\n+        }\n+        if (kind != Kind.INTERFACE) {\n+          checkState(!methodSpec.hasModifier(Modifier.DEFAULT), \"%s %s.%s cannot be default\",\n+              kind, name, methodSpec.name);\n+        }\n+      }\n+\n+      for (TypeSpec typeSpec : typeSpecs) {\n+        checkArgument(typeSpec.modifiers.containsAll(kind.implicitTypeModifiers),\n+            \"%s %s.%s requires modifiers %s\", kind, name, typeSpec.name,\n+            kind.implicitTypeModifiers);\n+      }\n+\n       boolean isAbstract = modifiers.contains(Modifier.ABSTRACT) || kind != Kind.CLASS;\n       for (MethodSpec methodSpec : methodSpecs) {\n         checkArgument(isAbstract || !methodSpec.hasModifier(Modifier.ABSTRACT),\n"
    },
    {
        "commit_hash": "4272265a319a562bceaa537fc1b9b6b40236a881",
        "previous_commit_hash": "3f5386230e12b8e9d3baf760ae3563b3f303f60c",
        "diff_stats": {
            "additions": 12,
            "deletions": 0
        },
        "diff_content": "@@ -20,6 +20,8 @@ import java.lang.annotation.Annotation;\n import java.lang.annotation.Inherited;\n import java.lang.annotation.Retention;\n import java.lang.annotation.RetentionPolicy;\n+import java.util.Arrays;\n+\n import javax.lang.model.element.TypeElement;\n import org.junit.Rule;\n import org.junit.Test;\n@@ -371,6 +373,16 @@ public final class AnnotationSpecTest {\n     }\n   }\n \n+  @Test public void modifyMembers() {\n+    AnnotationSpec.Builder builder = AnnotationSpec.builder(SuppressWarnings.class)\n+            .addMember(\"value\", \"$S\", \"Foo\");\n+    \n+    builder.members.clear();\n+    builder.members.put(\"value\", Arrays.asList(CodeBlock.of(\"$S\", \"Bar\")));\n+\n+    assertThat(builder.build().toString()).isEqualTo(\"@java.lang.SuppressWarnings(\\\"Bar\\\")\");\n+  }\n+\n   private String toString(TypeSpec typeSpec) {\n     return JavaFile.builder(\"com.squareup.tacos\", typeSpec).build().toString();\n   }\n"
    },
    {
        "commit_hash": "4272265a319a562bceaa537fc1b9b6b40236a881",
        "previous_commit_hash": "3f5386230e12b8e9d3baf760ae3563b3f303f60c",
        "diff_stats": {
            "additions": 18,
            "deletions": 1
        },
        "diff_content": "@@ -46,4 +46,21 @@ public class FieldSpecTest {\n           .isEqualTo(\"annotationSpecs == null\");\n     }\n   }\n-}\n\\ No newline at end of file\n+\n+  @Test public void modifyAnnotations() {\n+    FieldSpec.Builder builder = FieldSpec.builder(int.class, \"foo\")\n+          .addAnnotation(Override.class)\n+          .addAnnotation(SuppressWarnings.class);\n+\n+    builder.annotations.remove(1);\n+    assertThat(builder.build().annotations).hasSize(1);\n+  }\n+\n+  @Test public void modifyModifiers() {\n+    FieldSpec.Builder builder = FieldSpec.builder(int.class, \"foo\")\n+          .addModifiers(Modifier.PUBLIC, Modifier.STATIC);\n+\n+    builder.modifiers.remove(1);\n+    assertThat(builder.build().modifiers).containsExactly(Modifier.PUBLIC);\n+  }\n+}\n"
    },
    {
        "commit_hash": "4272265a319a562bceaa537fc1b9b6b40236a881",
        "previous_commit_hash": "3f5386230e12b8e9d3baf760ae3563b3f303f60c",
        "diff_stats": {
            "additions": 21,
            "deletions": 0
        },
        "diff_content": "@@ -15,6 +15,7 @@\n  */\n package com.squareup.javapoet;\n \n+import java.io.File;\n import java.util.Collections;\n import java.util.Date;\n import java.util.List;\n@@ -689,4 +690,24 @@ public final class JavaFileTest {\n         + \"  A a;\\n\"\n         + \"}\\n\");\n   }\n+\n+  @Test public void modifyStaticImports() throws Exception {\n+    JavaFile.Builder builder = JavaFile.builder(\"com.squareup.tacos\",\n+        TypeSpec.classBuilder(\"Taco\")\n+            .build())\n+            .addStaticImport(File.class, \"separator\");\n+\n+    builder.staticImports.clear();\n+    builder.staticImports.add(File.class.getCanonicalName() + \".separatorChar\");\n+\n+    String source = builder.build().toString();\n+\n+    assertThat(source).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import static java.io.File.separatorChar;\\n\"\n+        + \"\\n\"\n+        + \"class Taco {\\n\"\n+        + \"}\\n\");\n+  }\n }\n"
    },
    {
        "commit_hash": "4272265a319a562bceaa537fc1b9b6b40236a881",
        "previous_commit_hash": "3f5386230e12b8e9d3baf760ae3563b3f303f60c",
        "diff_stats": {
            "additions": 36,
            "deletions": 3
        },
        "diff_content": "@@ -356,8 +356,41 @@ public final class MethodSpecTest {\n         .setName(\"revisedMethod\")\n         .build();\n \n-    assertThat(methodSpec.toString()).isEqualTo(\"\"\n-        + \"void revisedMethod() {\\n\"\n-        + \"}\\n\");\n+    assertThat(methodSpec.toString()).isEqualTo(\"\" + \"void revisedMethod() {\\n\" + \"}\\n\");\n+  }\n+\n+  @Test public void modifyAnnotations() {\n+    MethodSpec.Builder builder = MethodSpec.methodBuilder(\"foo\")\n+            .addAnnotation(Override.class)\n+            .addAnnotation(SuppressWarnings.class);\n+\n+    builder.annotations.remove(1);\n+    assertThat(builder.build().annotations).hasSize(1);\n+  }\n+\n+  @Test public void modifyModifiers() {\n+    MethodSpec.Builder builder = MethodSpec.methodBuilder(\"foo\")\n+            .addModifiers(Modifier.PUBLIC, Modifier.STATIC);\n+\n+    builder.modifiers.remove(1);\n+    assertThat(builder.build().modifiers).containsExactly(Modifier.PUBLIC);\n+  }\n+\n+  @Test public void modifyParameters() {\n+    MethodSpec.Builder builder = MethodSpec.methodBuilder(\"foo\")\n+            .addParameter(int.class, \"source\");\n+\n+    builder.parameters.remove(0);\n+    assertThat(builder.build().parameters).isEmpty();\n+  }\n+\n+  @Test public void modifyTypeVariables() {\n+    TypeVariableName t = TypeVariableName.get(\"T\");\n+    MethodSpec.Builder builder = MethodSpec.methodBuilder(\"foo\")\n+            .addTypeVariable(t)\n+            .addTypeVariable(TypeVariableName.get(\"V\"));\n+\n+    builder.typeVariables.remove(1);\n+    assertThat(builder.build().typeVariables).containsExactly(t);\n   }\n }\n"
    },
    {
        "commit_hash": "4272265a319a562bceaa537fc1b9b6b40236a881",
        "previous_commit_hash": "3f5386230e12b8e9d3baf760ae3563b3f303f60c",
        "diff_stats": {
            "additions": 21,
            "deletions": 5
        },
        "diff_content": "@@ -25,6 +25,7 @@ import javax.lang.model.element.VariableElement;\n import javax.lang.model.util.Elements;\n import org.junit.Before;\n import org.junit.Rule;\n+import javax.lang.model.element.Modifier;\n import org.junit.Test;\n \n import static com.google.common.truth.Truth.assertThat;\n@@ -33,8 +34,6 @@ import static javax.lang.model.util.ElementFilter.fieldsIn;\n import static javax.lang.model.util.ElementFilter.methodsIn;\n import static org.junit.Assert.fail;\n \n-import javax.lang.model.element.Modifier;\n-\n public class ParameterSpecTest {\n   @Rule public final CompilationRule compilation = new CompilationRule();\n \n@@ -109,11 +108,28 @@ public class ParameterSpecTest {\n     modifiers.add(Modifier.PUBLIC);\n \n     try {\n-      ParameterSpec.builder(int.class, \"foo\").addModifiers(modifiers);\n+      ParameterSpec.builder(int.class, \"foo\")\n+          .addModifiers(modifiers);\n       fail();\n     } catch (Exception e) {\n-      assertThat(e.getMessage())\n-          .isEqualTo(\"unexpected parameter modifier: public\");\n+      assertThat(e.getMessage()).isEqualTo(\"unexpected parameter modifier: public\");\n     }\n   }\n+\n+  @Test public void modifyAnnotations() {\n+    ParameterSpec.Builder builder = ParameterSpec.builder(int.class, \"foo\")\n+            .addAnnotation(Override.class)\n+            .addAnnotation(SuppressWarnings.class);\n+\n+    builder.annotations.remove(1);\n+    assertThat(builder.build().annotations).hasSize(1);\n+  }\n+\n+  @Test public void modifyModifiers() {\n+    ParameterSpec.Builder builder = ParameterSpec.builder(int.class, \"foo\")\n+            .addModifiers(Modifier.PUBLIC, Modifier.STATIC);\n+\n+    builder.modifiers.remove(1);\n+    assertThat(builder.build().modifiers).containsExactly(Modifier.PUBLIC);\n+  }\n }\n"
    },
    {
        "commit_hash": "4272265a319a562bceaa537fc1b9b6b40236a881",
        "previous_commit_hash": "3f5386230e12b8e9d3baf760ae3563b3f303f60c",
        "diff_stats": {
            "additions": 98,
            "deletions": 6
        },
        "diff_content": "@@ -17,6 +17,14 @@ package com.squareup.javapoet;\n \n import com.google.common.collect.ImmutableMap;\n import com.google.testing.compile.CompilationRule;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.Mockito;\n+\n+import java.io.File;\n import java.io.IOException;\n import java.io.Serializable;\n import java.math.BigDecimal;\n@@ -31,15 +39,11 @@ import java.util.Locale;\n import java.util.Map;\n import java.util.Random;\n import java.util.concurrent.Callable;\n+\n import javax.lang.model.element.Element;\n import javax.lang.model.element.Modifier;\n import javax.lang.model.element.TypeElement;\n import javax.lang.model.type.TypeMirror;\n-import org.junit.Rule;\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.junit.runners.JUnit4;\n-import org.mockito.Mockito;\n \n import static com.google.common.truth.Truth.assertThat;\n import static org.junit.Assert.assertEquals;\n@@ -1907,7 +1911,7 @@ public final class TypeSpecTest {\n \n   @Test public void nullModifiersAddition() {\n     try {\n-      TypeSpec.classBuilder(\"Taco\").addModifiers((Modifier) null);\n+      TypeSpec.classBuilder(\"Taco\").addModifiers((Modifier) null).build();\n       fail();\n     } catch(IllegalArgumentException expected) {\n       assertThat(expected.getMessage())\n@@ -2424,4 +2428,92 @@ public final class TypeSpecTest {\n     assertThat(TypeSpec.enumBuilder(className).addEnumConstant(\"A\").build().name).isEqualTo(\"Example\");\n     assertThat(TypeSpec.annotationBuilder(className).build().name).isEqualTo(\"Example\");\n   }\n+\n+  @Test\n+  public void modifyAnnotations() {\n+    TypeSpec.Builder builder =\n+        TypeSpec.classBuilder(\"Taco\")\n+            .addAnnotation(Override.class)\n+            .addAnnotation(SuppressWarnings.class);\n+\n+    builder.annotations.remove(1);\n+    assertThat(builder.build().annotations).hasSize(1);\n+  }\n+\n+  @Test\n+  public void modifyModifiers() {\n+    TypeSpec.Builder builder =\n+        TypeSpec.classBuilder(\"Taco\").addModifiers(Modifier.PUBLIC, Modifier.FINAL);\n+\n+    builder.modifiers.remove(1);\n+    assertThat(builder.build().modifiers).containsExactly(Modifier.PUBLIC);\n+  }\n+\n+  @Test\n+  public void modifyFields() {\n+    TypeSpec.Builder builder = TypeSpec.classBuilder(\"Taco\")\n+        .addField(int.class, \"source\");\n+\n+    builder.fieldSpecs.remove(0);\n+    assertThat(builder.build().fieldSpecs).isEmpty();\n+  }\n+\n+  @Test\n+  public void modifyTypeVariables() {\n+    TypeVariableName t = TypeVariableName.get(\"T\");\n+    TypeSpec.Builder builder =\n+        TypeSpec.classBuilder(\"Taco\")\n+            .addTypeVariable(t)\n+            .addTypeVariable(TypeVariableName.get(\"V\"));\n+\n+    builder.typeVariables.remove(1);\n+    assertThat(builder.build().typeVariables).containsExactly(t);\n+  }\n+\n+  @Test\n+  public void modifySuperinterfaces() {\n+    TypeSpec.Builder builder = TypeSpec.classBuilder(\"Taco\")\n+        .addSuperinterface(File.class);\n+\n+    builder.superinterfaces.clear();\n+    assertThat(builder.build().superinterfaces).isEmpty();\n+  }\n+\n+  @Test\n+  public void modifyMethods() {\n+    TypeSpec.Builder builder = TypeSpec.classBuilder(\"Taco\")\n+        .addMethod(MethodSpec.methodBuilder(\"bell\").build());\n+\n+    builder.methodSpecs.clear();\n+    assertThat(builder.build().methodSpecs).isEmpty();\n+  }\n+\n+  @Test\n+  public void modifyTypes() {\n+    TypeSpec.Builder builder = TypeSpec.classBuilder(\"Taco\")\n+        .addType(TypeSpec.classBuilder(\"Bell\").build());\n+\n+    builder.typeSpecs.clear();\n+    assertThat(builder.build().typeSpecs).isEmpty();\n+  }\n+\n+  @Test\n+  public void modifyEnumConstants() {\n+    TypeSpec constantType = TypeSpec.anonymousClassBuilder(\"\").build();\n+    TypeSpec.Builder builder = TypeSpec.enumBuilder(\"Taco\")\n+        .addEnumConstant(\"BELL\", constantType)\n+        .addEnumConstant(\"WUT\", TypeSpec.anonymousClassBuilder(\"\").build());\n+\n+    builder.enumConstants.remove(\"WUT\");\n+    assertThat(builder.build().enumConstants).containsExactly(\"BELL\", constantType);\n+  }\n+\n+  @Test\n+  public void modifyOriginatingElements() {\n+    TypeSpec.Builder builder = TypeSpec.classBuilder(\"Taco\")\n+        .addOriginatingElement(Mockito.mock(Element.class));\n+\n+    builder.originatingElements.clear();\n+    assertThat(builder.build().originatingElements).isEmpty();\n+  }\n }\n"
    },
    {
        "commit_hash": "e2ed025d5936a65836f1a6f79c750a3197f290e9",
        "previous_commit_hash": "4272265a319a562bceaa537fc1b9b6b40236a881",
        "diff_stats": {
            "additions": 8,
            "deletions": 1
        },
        "diff_content": "@@ -149,7 +149,7 @@ final class CodeWriter {\n     emit(\"/**\\n\");\n     javadoc = true;\n     try {\n-      emit(javadocCodeBlock);\n+      emit(javadocCodeBlock, true);\n     } finally {\n       javadoc = false;\n     }\n@@ -219,6 +219,10 @@ final class CodeWriter {\n   }\n \n   public CodeWriter emit(CodeBlock codeBlock) throws IOException {\n+    return emit(codeBlock, false);\n+  }\n+\n+  public CodeWriter emit(CodeBlock codeBlock, boolean ensureTrailingNewline) throws IOException {\n     int a = 0;\n     ClassName deferredTypeName = null; // used by \"import static\" logic\n     ListIterator<String> partIterator = codeBlock.formatParts.listIterator();\n@@ -307,6 +311,9 @@ final class CodeWriter {\n           break;\n       }\n     }\n+    if (ensureTrailingNewline && out.lastChar() != '\\n') {\n+      emit(\"\\n\");\n+    }\n     return this;\n   }\n \n"
    },
    {
        "commit_hash": "e2ed025d5936a65836f1a6f79c750a3197f290e9",
        "previous_commit_hash": "4272265a319a562bceaa537fc1b9b6b40236a881",
        "diff_stats": {
            "additions": 36,
            "deletions": 2
        },
        "diff_content": "@@ -24,7 +24,7 @@ import static com.squareup.javapoet.Util.checkNotNull;\n  * or soft-wrapping spaces using {@link #wrappingSpace}.\n  */\n final class LineWrapper {\n-  private final Appendable out;\n+  private final RecordingAppendable out;\n   private final String indent;\n   private final int columnLimit;\n   private boolean closed;\n@@ -47,11 +47,16 @@ final class LineWrapper {\n \n   LineWrapper(Appendable out, String indent, int columnLimit) {\n     checkNotNull(out, \"out == null\");\n-    this.out = out;\n+    this.out = new RecordingAppendable(out);\n     this.indent = indent;\n     this.columnLimit = columnLimit;\n   }\n \n+  /** @return the last emitted char or {@link Character#MIN_VALUE} if nothing emitted yet. */\n+  char lastChar() {\n+    return out.lastChar;\n+  }\n+\n   /** Emit {@code s}. This may be buffered to permit line wraps to be inserted. */\n   void append(String s) throws IOException {\n     if (closed) throw new IllegalStateException(\"closed\");\n@@ -134,4 +139,33 @@ final class LineWrapper {\n   private enum FlushType {\n     WRAP, SPACE, EMPTY;\n   }\n+\n+  /** A delegating {@link Appendable} that records info about the chars passing through it. */\n+  static final class RecordingAppendable implements Appendable {\n+    private final Appendable delegate;\n+\n+    char lastChar = Character.MIN_VALUE;\n+\n+    RecordingAppendable(Appendable delegate) {\n+      this.delegate = delegate;\n+    }\n+\n+    @Override public Appendable append(CharSequence csq) throws IOException {\n+      int length = csq.length();\n+      if (length != 0) {\n+        lastChar = csq.charAt(length - 1);\n+      }\n+      return delegate.append(csq);\n+    }\n+\n+    @Override public Appendable append(CharSequence csq, int start, int end) throws IOException {\n+      CharSequence sub = csq.subSequence(start, end);\n+      return append(sub);\n+    }\n+\n+    @Override public Appendable append(char c) throws IOException {\n+      lastChar = c;\n+      return delegate.append(c);\n+    }\n+  }\n }\n"
    },
    {
        "commit_hash": "e2ed025d5936a65836f1a6f79c750a3197f290e9",
        "previous_commit_hash": "4272265a319a562bceaa537fc1b9b6b40236a881",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -132,7 +132,7 @@ public final class MethodSpec {\n       codeWriter.emit(\" {\\n\");\n \n       codeWriter.indent();\n-      codeWriter.emit(code);\n+      codeWriter.emit(code, true);\n       codeWriter.unindent();\n \n       codeWriter.emit(\"}\\n\");\n"
    },
    {
        "commit_hash": "e2ed025d5936a65836f1a6f79c750a3197f290e9",
        "previous_commit_hash": "4272265a319a562bceaa537fc1b9b6b40236a881",
        "diff_stats": {
            "additions": 23,
            "deletions": 0
        },
        "diff_content": "@@ -393,4 +393,27 @@ public final class MethodSpecTest {\n     builder.typeVariables.remove(1);\n     assertThat(builder.build().typeVariables).containsExactly(t);\n   }\n+\n+  @Test public void ensureTrailingNewline() {\n+    MethodSpec methodSpec = MethodSpec.methodBuilder(\"method\")\n+        .addCode(\"codeWithNoNewline();\")\n+        .build();\n+\n+    assertThat(methodSpec.toString()).isEqualTo(\"\"\n+        + \"void method() {\\n\"\n+        + \"  codeWithNoNewline();\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  /** Ensures that we don't add a duplicate newline if one is already present. */\n+  @Test public void ensureTrailingNewlineWithExistingNewline() {\n+    MethodSpec methodSpec = MethodSpec.methodBuilder(\"method\")\n+        .addCode(\"codeWithNoNewline();\\n\") // Have a newline already, so ensure we're not adding one\n+        .build();\n+\n+    assertThat(methodSpec.toString()).isEqualTo(\"\"\n+        + \"void method() {\\n\"\n+        + \"  codeWithNoNewline();\\n\"\n+        + \"}\\n\");\n+  }\n }\n"
    },
    {
        "commit_hash": "e2ed025d5936a65836f1a6f79c750a3197f290e9",
        "previous_commit_hash": "4272265a319a562bceaa537fc1b9b6b40236a881",
        "diff_stats": {
            "additions": 32,
            "deletions": 1
        },
        "diff_content": "@@ -1852,7 +1852,8 @@ public final class TypeSpecTest {\n         + \"  }\\n\"\n         + \"\\n\"\n         + \"  /**\\n\"\n-        + \"   * chosen by fair dice roll ;) */\\n\"\n+        + \"   * chosen by fair dice roll ;)\\n\"\n+        + \"   */\\n\"\n         + \"  public int getRandomQuantity() {\\n\"\n         + \"    return 4;\\n\"\n         + \"  }\\n\"\n@@ -2516,4 +2517,34 @@ public final class TypeSpecTest {\n     builder.originatingElements.clear();\n     assertThat(builder.build().originatingElements).isEmpty();\n   }\n+    \n+  @Test public void javadocWithTrailingLineDoesNotAddAnother() {\n+    TypeSpec spec = TypeSpec.classBuilder(\"Taco\")\n+        .addJavadoc(\"Some doc with a newline\\n\")\n+        .build();\n+\n+    assertThat(toString(spec)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"/**\\n\"\n+        + \" * Some doc with a newline\\n\"\n+        + \" */\\n\"\n+        + \"class Taco {\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void javadocEnsuresTrailingLine() {\n+    TypeSpec spec = TypeSpec.classBuilder(\"Taco\")\n+        .addJavadoc(\"Some doc with a newline\")\n+        .build();\n+\n+    assertThat(toString(spec)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"/**\\n\"\n+        + \" * Some doc with a newline\\n\"\n+        + \" */\\n\"\n+        + \"class Taco {\\n\"\n+        + \"}\\n\");\n+  }\n }\n"
    },
    {
        "commit_hash": "1225800fdbd05d6a2b069fc1e4949f6461a7236b",
        "previous_commit_hash": "e2ed025d5936a65836f1a6f79c750a3197f290e9",
        "diff_stats": {
            "additions": 1,
            "deletions": 0
        },
        "diff_content": "@@ -168,6 +168,7 @@ public final class TypeSpec {\n     builder.typeSpecs.addAll(typeSpecs);\n     builder.initializerBlock.add(initializerBlock);\n     builder.staticBlock.add(staticBlock);\n+    builder.originatingElements.addAll(originatingElements);\n     return builder;\n   }\n \n"
    },
    {
        "commit_hash": "1225800fdbd05d6a2b069fc1e4949f6461a7236b",
        "previous_commit_hash": "e2ed025d5936a65836f1a6f79c750a3197f290e9",
        "diff_stats": {
            "additions": 9,
            "deletions": 8
        },
        "diff_content": "@@ -17,13 +17,6 @@ package com.squareup.javapoet;\n \n import com.google.common.collect.ImmutableMap;\n import com.google.testing.compile.CompilationRule;\n-\n-import org.junit.Rule;\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.junit.runners.JUnit4;\n-import org.mockito.Mockito;\n-\n import java.io.File;\n import java.io.IOException;\n import java.io.Serializable;\n@@ -39,11 +32,15 @@ import java.util.Locale;\n import java.util.Map;\n import java.util.Random;\n import java.util.concurrent.Callable;\n-\n import javax.lang.model.element.Element;\n import javax.lang.model.element.Modifier;\n import javax.lang.model.element.TypeElement;\n import javax.lang.model.type.TypeMirror;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.Mockito;\n \n import static com.google.common.truth.Truth.assertThat;\n import static org.junit.Assert.assertEquals;\n@@ -2269,6 +2266,7 @@ public final class TypeSpecTest {\n \n   @Test public void initializersToBuilder() {\n     // Tests if toBuilder() contains correct static and instance initializers\n+    Element originatingElement = getElement(TypeSpecTest.class);\n     TypeSpec taco = TypeSpec.classBuilder(\"Taco\")\n         .addField(String.class, \"foo\", Modifier.PRIVATE)\n         .addField(String.class, \"FOO\", Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)\n@@ -2285,10 +2283,13 @@ public final class TypeSpecTest {\n         .addInitializerBlock(CodeBlock.builder()\n             .addStatement(\"foo = $S\", \"FOO\")\n             .build())\n+        .addOriginatingElement(originatingElement)\n         .build();\n \n     TypeSpec recreatedTaco = taco.toBuilder().build();\n     assertThat(toString(taco)).isEqualTo(toString(recreatedTaco));\n+    assertThat(taco.originatingElements)\n+        .containsExactlyElementsIn(recreatedTaco.originatingElements);\n \n     TypeSpec initializersAdded = taco.toBuilder()\n         .addInitializerBlock(CodeBlock.builder()\n"
    },
    {
        "commit_hash": "3d65852a482185e464c4986b862394691ac197da",
        "previous_commit_hash": "1225800fdbd05d6a2b069fc1e4949f6461a7236b",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -461,7 +461,7 @@ final class CodeWriter {\n    */\n   CodeWriter emitAndIndent(String s) throws IOException {\n     boolean first = true;\n-    for (String line : s.split(\"\\n\", -1)) {\n+    for (String line : s.split(\"\\\\R\", -1)) {\n       // Emit a newline character. Make sure blank lines in Javadoc & comments look good.\n       if (!first) {\n         if ((javadoc || comment) && trailingNewline) {\n"
    },
    {
        "commit_hash": "3d65852a482185e464c4986b862394691ac197da",
        "previous_commit_hash": "1225800fdbd05d6a2b069fc1e4949f6461a7236b",
        "diff_stats": {
            "additions": 23,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,23 @@\n+package com.squareup.javapoet;\n+\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+public class CodeWriterTest {\n+\n+    @Test\n+    public void emptyLineInJavaDocDosEndings() throws IOException {\n+        CodeBlock javadocCodeBlock = CodeBlock.of(\"A\\r\\n\\r\\nB\\r\\n\");\n+        StringBuilder out = new StringBuilder();\n+        new CodeWriter(out).emitJavadoc(javadocCodeBlock);\n+        assertThat(out.toString()).isEqualTo(\n+                \"/**\\n\" +\n+                        \" * A\\n\" +\n+                        \" *\\n\" +\n+                        \" * B\\n\" +\n+                        \" */\\n\");\n+    }\n+}\n\\ No newline at end of file\n"
    },
    {
        "commit_hash": "25d19845b866c04a2fb3e11ce3d43ccb2e7b98cd",
        "previous_commit_hash": "3d65852a482185e464c4986b862394691ac197da",
        "diff_stats": {
            "additions": 24,
            "deletions": 0
        },
        "diff_content": "@@ -474,6 +474,14 @@ public final class MethodSpec {\n       return this;\n     }\n \n+    /**\n+     * @param codeBlock the control flow construct and its code, such as \"if (foo == 5)\".\n+     * Shouldn't contain braces or newline characters.\n+     */\n+    public Builder beginControlFlow(CodeBlock codeBlock) {\n+      return beginControlFlow(\"$L\", codeBlock);\n+    }\n+\n     /**\n      * @param controlFlow the control flow construct and its code, such as \"else if (foo == 10)\".\n      *     Shouldn't contain braces or newline characters.\n@@ -483,6 +491,14 @@ public final class MethodSpec {\n       return this;\n     }\n \n+    /**\n+     * @param codeBlock the control flow construct and its code, such as \"else if (foo == 10)\".\n+     *     Shouldn't contain braces or newline characters.\n+     */\n+    public Builder nextControlFlow(CodeBlock codeBlock) {\n+      return nextControlFlow(\"$L\", codeBlock);\n+    }\n+\n     public Builder endControlFlow() {\n       code.endControlFlow();\n       return this;\n@@ -497,6 +513,14 @@ public final class MethodSpec {\n       return this;\n     }\n \n+    /**\n+     * @param codeBlock the optional control flow construct and its code, such as\n+     *     \"while(foo == 20)\". Only used for \"do/while\" control flows.\n+     */\n+    public Builder endControlFlow(CodeBlock codeBlock) {\n+      return endControlFlow(\"$L\", codeBlock);\n+    }\n+\n     public Builder addStatement(String format, Object... args) {\n       code.addStatement(format, args);\n       return this;\n"
    },
    {
        "commit_hash": "25d19845b866c04a2fb3e11ce3d43ccb2e7b98cd",
        "previous_commit_hash": "3d65852a482185e464c4986b862394691ac197da",
        "diff_stats": {
            "additions": 45,
            "deletions": 1
        },
        "diff_content": "@@ -21,8 +21,9 @@ import java.io.IOException;\n import java.lang.annotation.ElementType;\n import java.lang.annotation.Target;\n import java.util.Arrays;\n-import java.util.Collection;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n import java.util.concurrent.Callable;\n import java.util.concurrent.TimeoutException;\n import javax.lang.model.element.ExecutableElement;\n@@ -416,4 +417,47 @@ public final class MethodSpecTest {\n         + \"  codeWithNoNewline();\\n\"\n         + \"}\\n\");\n   }\n+\n+  @Test public void controlFlowWithNamedCodeBlocks() {\n+    Map<String, Object> m = new HashMap<>();\n+    m.put(\"field\", \"valueField\");\n+    m.put(\"threshold\", \"5\");\n+\n+    MethodSpec methodSpec = MethodSpec.methodBuilder(\"method\")\n+        .beginControlFlow(named(\"if ($field:N > $threshold:L)\", m))\n+        .nextControlFlow(named(\"else if ($field:N == $threshold:L)\", m))\n+        .endControlFlow()\n+        .build();\n+\n+    assertThat(methodSpec.toString()).isEqualTo(\"\"\n+        + \"void method() {\\n\"\n+        + \"  if (valueField > 5) {\\n\"\n+        + \"  } else if (valueField == 5) {\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void doWhileWithNamedCodeBlocks() {\n+    Map<String, Object> m = new HashMap<>();\n+    m.put(\"field\", \"valueField\");\n+    m.put(\"threshold\", \"5\");\n+\n+    MethodSpec methodSpec = MethodSpec.methodBuilder(\"method\")\n+        .beginControlFlow(\"do\")\n+        .addStatement(named(\"$field:N--\", m))\n+        .endControlFlow(named(\"while ($field:N > $threshold:L)\", m))\n+        .build();\n+\n+    assertThat(methodSpec.toString()).isEqualTo(\"\"\n+        + \"void method() {\\n\" +\n+        \"  do {\\n\" +\n+        \"    valueField--;\\n\" +\n+        \"  } while (valueField > 5);\\n\" +\n+        \"}\\n\");\n+  }\n+\n+  private static CodeBlock named(String format, Map<String, ?> args){\n+    return CodeBlock.builder().addNamed(format, args).build();\n+  }\n+\n }\n"
    },
    {
        "commit_hash": "80ddc99409399bd15b06509a6e3e75cb4117b8d2",
        "previous_commit_hash": "25d19845b866c04a2fb3e11ce3d43ccb2e7b98cd",
        "diff_stats": {
            "additions": 13,
            "deletions": 5
        },
        "diff_content": "@@ -54,6 +54,7 @@ final class CodeWriter {\n   private final List<TypeSpec> typeSpecStack = new ArrayList<>();\n   private final Set<String> staticImportClassNames;\n   private final Set<String> staticImports;\n+  private final Set<String> alwaysQualify;\n   private final Map<String, ClassName> importedTypes;\n   private final Map<String, ClassName> importableTypes = new LinkedHashMap<>();\n   private final Set<String> referencedNames = new LinkedHashSet<>();\n@@ -68,19 +69,23 @@ final class CodeWriter {\n   int statementLine = -1;\n \n   CodeWriter(Appendable out) {\n-    this(out, \"  \", Collections.emptySet());\n+    this(out, \"  \", Collections.emptySet(), Collections.emptySet());\n   }\n \n-  CodeWriter(Appendable out, String indent, Set<String> staticImports) {\n-    this(out, indent, Collections.emptyMap(), staticImports);\n+  CodeWriter(Appendable out, String indent, Set<String> staticImports, Set<String> alwaysQualify) {\n+    this(out, indent, Collections.emptyMap(), staticImports, alwaysQualify);\n   }\n \n-  CodeWriter(Appendable out, String indent, Map<String, ClassName> importedTypes,\n-      Set<String> staticImports) {\n+  CodeWriter(Appendable out,\n+      String indent,\n+      Map<String, ClassName> importedTypes,\n+      Set<String> staticImports,\n+      Set<String> alwaysQualify) {\n     this.out = new LineWrapper(out, indent, 100);\n     this.indent = checkNotNull(indent, \"indent == null\");\n     this.importedTypes = checkNotNull(importedTypes, \"importedTypes == null\");\n     this.staticImports = checkNotNull(staticImports, \"staticImports == null\");\n+    this.alwaysQualify = checkNotNull(alwaysQualify, \"alwaysQualify == null\");\n     this.staticImportClassNames = new LinkedHashSet<>();\n     for (String signature : staticImports) {\n       staticImportClassNames.add(signature.substring(0, signature.lastIndexOf('.')));\n@@ -409,6 +414,9 @@ final class CodeWriter {\n   private void importableType(ClassName className) {\n     if (className.packageName().isEmpty()) {\n       return;\n+    } else if (alwaysQualify.contains(className.simpleName)) {\n+      // TODO what about nested types like java.util.Map.Entry?\n+      return;\n     }\n     ClassName topLevelClassName = className.topLevelClassName();\n     String simpleName = topLevelClassName.simpleName();\n"
    },
    {
        "commit_hash": "80ddc99409399bd15b06509a6e3e75cb4117b8d2",
        "previous_commit_hash": "25d19845b866c04a2fb3e11ce3d43ccb2e7b98cd",
        "diff_stats": {
            "additions": 27,
            "deletions": 3
        },
        "diff_content": "@@ -27,6 +27,7 @@ import java.nio.file.Files;\n import java.nio.file.Path;\n import java.util.Arrays;\n import java.util.Collections;\n+import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n@@ -60,6 +61,7 @@ public final class JavaFile {\n   public final TypeSpec typeSpec;\n   public final boolean skipJavaLangImports;\n   private final Set<String> staticImports;\n+  private final Set<String> alwaysQualify;\n   private final String indent;\n \n   private JavaFile(Builder builder) {\n@@ -69,16 +71,33 @@ public final class JavaFile {\n     this.skipJavaLangImports = builder.skipJavaLangImports;\n     this.staticImports = Util.immutableSet(builder.staticImports);\n     this.indent = builder.indent;\n+\n+    Set<String> alwaysQualifiedNames = new LinkedHashSet<>();\n+    fillAlwaysQualifiedNames(builder.typeSpec, alwaysQualifiedNames);\n+    this.alwaysQualify = Util.immutableSet(alwaysQualifiedNames);\n+  }\n+\n+  private void fillAlwaysQualifiedNames(TypeSpec spec, Set<String> alwaysQualifiedNames) {\n+    alwaysQualifiedNames.addAll(spec.alwaysQualifiedNames);\n+    for (TypeSpec nested : spec.typeSpecs) {\n+      fillAlwaysQualifiedNames(nested, alwaysQualifiedNames);\n+    }\n   }\n \n   public void writeTo(Appendable out) throws IOException {\n     // First pass: emit the entire class, just to collect the types we'll need to import.\n-    CodeWriter importsCollector = new CodeWriter(NULL_APPENDABLE, indent, staticImports);\n+    CodeWriter importsCollector = new CodeWriter(\n+        NULL_APPENDABLE,\n+        indent,\n+        staticImports,\n+        alwaysQualify\n+    );\n     emit(importsCollector);\n     Map<String, ClassName> suggestedImports = importsCollector.suggestedImports();\n \n     // Second pass: write the code, taking advantage of the imports.\n-    CodeWriter codeWriter = new CodeWriter(out, indent, suggestedImports, staticImports);\n+    CodeWriter codeWriter\n+        = new CodeWriter(out, indent, suggestedImports, staticImports, alwaysQualify);\n     emit(codeWriter);\n   }\n \n@@ -153,7 +172,12 @@ public final class JavaFile {\n \n     int importedTypesCount = 0;\n     for (ClassName className : new TreeSet<>(codeWriter.importedTypes().values())) {\n-      if (skipJavaLangImports && className.packageName().equals(\"java.lang\")) continue;\n+      // TODO what about nested types like java.util.Map.Entry?\n+      if (skipJavaLangImports\n+          && className.packageName().equals(\"java.lang\")\n+          && !alwaysQualify.contains(className.simpleName)) {\n+        continue;\n+      }\n       codeWriter.emit(\"import $L;\\n\", className.withoutAnnotations());\n       importedTypesCount++;\n     }\n"
    },
    {
        "commit_hash": "80ddc99409399bd15b06509a6e3e75cb4117b8d2",
        "previous_commit_hash": "25d19845b866c04a2fb3e11ce3d43ccb2e7b98cd",
        "diff_stats": {
            "additions": 171,
            "deletions": 2
        },
        "diff_content": "@@ -16,6 +16,7 @@\n package com.squareup.javapoet;\n \n import java.io.IOException;\n+import java.lang.reflect.ParameterizedType;\n import java.lang.reflect.Type;\n import java.util.ArrayList;\n import java.util.Arrays;\n@@ -24,6 +25,7 @@ import java.util.EnumSet;\n import java.util.HashSet;\n import java.util.Iterator;\n import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n@@ -31,6 +33,11 @@ import java.util.Set;\n import javax.lang.model.SourceVersion;\n import javax.lang.model.element.Element;\n import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.NoType;\n+import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.util.ElementFilter;\n \n import static com.squareup.javapoet.Util.checkArgument;\n import static com.squareup.javapoet.Util.checkNotNull;\n@@ -56,6 +63,7 @@ public final class TypeSpec {\n   public final List<TypeSpec> typeSpecs;\n   final Set<String> nestedTypesSimpleNames;\n   public final List<Element> originatingElements;\n+  public final Set<String> alwaysQualifiedNames;\n \n   private TypeSpec(Builder builder) {\n     this.kind = builder.kind;\n@@ -73,6 +81,7 @@ public final class TypeSpec {\n     this.initializerBlock = builder.initializerBlock.build();\n     this.methodSpecs = Util.immutableList(builder.methodSpecs);\n     this.typeSpecs = Util.immutableList(builder.typeSpecs);\n+    this.alwaysQualifiedNames = Util.immutableSet(builder.alwaysQualifiedNames);\n \n     nestedTypesSimpleNames = new HashSet<>(builder.typeSpecs.size());\n     List<Element> originatingElementsMutable = new ArrayList<>();\n@@ -108,6 +117,7 @@ public final class TypeSpec {\n     this.typeSpecs = Collections.emptyList();\n     this.originatingElements = Collections.emptyList();\n     this.nestedTypesSimpleNames = Collections.emptySet();\n+    this.alwaysQualifiedNames = Collections.emptySet();\n   }\n \n   public boolean hasModifier(Modifier modifier) {\n@@ -169,6 +179,7 @@ public final class TypeSpec {\n     builder.initializerBlock.add(initializerBlock);\n     builder.staticBlock.add(staticBlock);\n     builder.originatingElements.addAll(originatingElements);\n+    builder.alwaysQualifiedNames.addAll(alwaysQualifiedNames);\n     return builder;\n   }\n \n@@ -414,6 +425,7 @@ public final class TypeSpec {\n     public final List<MethodSpec> methodSpecs = new ArrayList<>();\n     public final List<TypeSpec> typeSpecs = new ArrayList<>();\n     public final List<Element> originatingElements = new ArrayList<>();\n+    public final Set<String> alwaysQualifiedNames = new LinkedHashSet<>();\n \n     private Builder(Kind kind, String name,\n         CodeBlock anonymousTypeArguments) {\n@@ -483,7 +495,32 @@ public final class TypeSpec {\n     }\n \n     public Builder superclass(Type superclass) {\n-      return superclass(TypeName.get(superclass));\n+      return superclass(superclass, true);\n+    }\n+\n+    public Builder superclass(Type superclass, boolean avoidNestedTypeNameClashes) {\n+      superclass(TypeName.get(superclass));\n+      if (avoidNestedTypeNameClashes) {\n+        Class<?> clazz = getRawType(superclass);\n+        if (clazz != null) {\n+          avoidClashesWithNestedClasses(clazz);\n+        }\n+      }\n+      return this;\n+    }\n+\n+    public Builder superclass(TypeMirror superclass) {\n+      return superclass(superclass, true);\n+    }\n+\n+    public Builder superclass(TypeMirror superclass, boolean avoidNestedTypeNameClashes) {\n+      superclass(TypeName.get(superclass));\n+      if (avoidNestedTypeNameClashes && superclass instanceof DeclaredType) {\n+        TypeElement superInterfaceElement =\n+            (TypeElement) ((DeclaredType) superclass).asElement();\n+        avoidClashesWithNestedClasses(superInterfaceElement);\n+      }\n+      return this;\n     }\n \n     public Builder addSuperinterfaces(Iterable<? extends TypeName> superinterfaces) {\n@@ -501,7 +538,43 @@ public final class TypeSpec {\n     }\n \n     public Builder addSuperinterface(Type superinterface) {\n-      return addSuperinterface(TypeName.get(superinterface));\n+      return addSuperinterface(superinterface, true);\n+    }\n+\n+    public Builder addSuperinterface(Type superinterface, boolean avoidNestedTypeNameClashes) {\n+      addSuperinterface(TypeName.get(superinterface));\n+      if (avoidNestedTypeNameClashes) {\n+        Class<?> clazz = getRawType(superinterface);\n+        if (clazz != null) {\n+          avoidClashesWithNestedClasses(clazz);\n+        }\n+      }\n+      return this;\n+    }\n+\n+    private Class<?> getRawType(Type type) {\n+      if (type instanceof Class<?>) {\n+        return (Class<?>) type;\n+      } else if (type instanceof ParameterizedType) {\n+        return getRawType(((ParameterizedType) type).getRawType());\n+      } else {\n+        return null;\n+      }\n+    }\n+\n+    public Builder addSuperinterface(TypeMirror superinterface) {\n+      return addSuperinterface(superinterface, true);\n+    }\n+\n+    public Builder addSuperinterface(TypeMirror superinterface,\n+        boolean avoidNestedTypeNameClashes) {\n+      addSuperinterface(TypeName.get(superinterface));\n+      if (avoidNestedTypeNameClashes && superinterface instanceof DeclaredType) {\n+        TypeElement superInterfaceElement =\n+            (TypeElement) ((DeclaredType) superinterface).asElement();\n+        avoidClashesWithNestedClasses(superInterfaceElement);\n+      }\n+      return this;\n     }\n \n     public Builder addEnumConstant(String name) {\n@@ -582,6 +655,102 @@ public final class TypeSpec {\n       return this;\n     }\n \n+    public Builder alwaysQualify(String... simpleNames) {\n+      checkArgument(simpleNames != null, \"simpleNames == null\");\n+      for (String name : simpleNames) {\n+        checkArgument(\n+            name != null,\n+            \"null entry in simpleNames array: %s\",\n+            Arrays.toString(simpleNames)\n+        );\n+        alwaysQualifiedNames.add(name);\n+      }\n+      return this;\n+    }\n+\n+    /**\n+     * Call this to always fully qualify any types that would conflict with possibly nested types of\n+     * this {@code typeElement}. For example - if the following type was passed in as the\n+     * typeElement:\n+     *\n+     * <pre><code>\n+     *   class Foo {\n+     *     class NestedTypeA {\n+     *\n+     *     }\n+     *     class NestedTypeB {\n+     *\n+     *     }\n+     *   }\n+     * </code></pre>\n+     *\n+     * <p>\n+     * Then this would add {@code \"NestedTypeA\"} and {@code \"NestedTypeB\"} as names that should\n+     * always be qualified via {@link #alwaysQualify(String...)}. This way they would avoid\n+     * possible import conflicts when this JavaFile is written.\n+     *\n+     * @param typeElement the {@link TypeElement} with nested types to avoid clashes with.\n+     * @return this builder instance.\n+     */\n+    public Builder avoidClashesWithNestedClasses(TypeElement typeElement) {\n+      checkArgument(typeElement != null, \"typeElement == null\");\n+      for (TypeElement nestedType : ElementFilter.typesIn(typeElement.getEnclosedElements())) {\n+        alwaysQualify(nestedType.getSimpleName().toString());\n+      }\n+      TypeMirror superclass = typeElement.getSuperclass();\n+      if (!(superclass instanceof NoType) && superclass instanceof DeclaredType) {\n+        TypeElement superclassElement = (TypeElement) ((DeclaredType) superclass).asElement();\n+        avoidClashesWithNestedClasses(superclassElement);\n+      }\n+      for (TypeMirror superinterface : typeElement.getInterfaces()) {\n+        if (superinterface instanceof DeclaredType) {\n+          TypeElement superinterfaceElement\n+              = (TypeElement) ((DeclaredType) superinterface).asElement();\n+          avoidClashesWithNestedClasses(superinterfaceElement);\n+        }\n+      }\n+      return this;\n+    }\n+\n+    /**\n+     * Call this to always fully qualify any types that would conflict with possibly nested types of\n+     * this {@code typeElement}. For example - if the following type was passed in as the\n+     * typeElement:\n+     *\n+     * <pre><code>\n+     *   class Foo {\n+     *     class NestedTypeA {\n+     *\n+     *     }\n+     *     class NestedTypeB {\n+     *\n+     *     }\n+     *   }\n+     * </code></pre>\n+     *\n+     * <p>\n+     * Then this would add {@code \"NestedTypeA\"} and {@code \"NestedTypeB\"} as names that should\n+     * always be qualified via {@link #alwaysQualify(String...)}. This way they would avoid\n+     * possible import conflicts when this JavaFile is written.\n+     *\n+     * @param clazz the {@link Class} with nested types to avoid clashes with.\n+     * @return this builder instance.\n+     */\n+    public Builder avoidClashesWithNestedClasses(Class<?> clazz) {\n+      checkArgument(clazz != null, \"clazz == null\");\n+      for (Class<?> nestedType : clazz.getDeclaredClasses()) {\n+        alwaysQualify(nestedType.getSimpleName());\n+      }\n+      Class<?> superclass = clazz.getSuperclass();\n+      if (superclass != null && !Object.class.equals(superclass)) {\n+        avoidClashesWithNestedClasses(superclass);\n+      }\n+      for (Class<?> superinterface : clazz.getInterfaces()) {\n+        avoidClashesWithNestedClasses(superinterface);\n+      }\n+      return this;\n+    }\n+\n     public TypeSpec build() {\n       for (AnnotationSpec annotationSpec : annotations) {\n         checkNotNull(annotationSpec, \"annotationSpec == null\");\n"
    },
    {
        "commit_hash": "80ddc99409399bd15b06509a6e3e75cb4117b8d2",
        "previous_commit_hash": "25d19845b866c04a2fb3e11ce3d43ccb2e7b98cd",
        "diff_stats": {
            "additions": 301,
            "deletions": 0
        },
        "diff_content": "@@ -16,12 +16,18 @@\n package com.squareup.javapoet;\n \n import java.io.File;\n+import com.google.testing.compile.CompilationRule;\n import java.util.Collections;\n import java.util.Date;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n import java.util.concurrent.TimeUnit;\n+import java.util.regex.Pattern;\n import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n import org.junit.Ignore;\n+import org.junit.Rule;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n@@ -30,6 +36,13 @@ import static com.google.common.truth.Truth.assertThat;\n \n @RunWith(JUnit4.class)\n public final class JavaFileTest {\n+\n+  @Rule public final CompilationRule compilation = new CompilationRule();\n+\n+  private TypeElement getElement(Class<?> clazz) {\n+    return compilation.getElements().getTypeElement(clazz.getCanonicalName());\n+  }\n+\n   @Test public void importStaticReadmeExample() {\n     ClassName hoverboard = ClassName.get(\"com.mattel\", \"Hoverboard\");\n     ClassName namedBoards = ClassName.get(\"com.mattel\", \"Hoverboard\", \"Boards\");\n@@ -710,4 +723,292 @@ public final class JavaFileTest {\n         + \"class Taco {\\n\"\n         + \"}\\n\");\n   }\n+\n+  @Test public void alwaysQualifySimple() {\n+    String source = JavaFile.builder(\"com.squareup.tacos\",\n+        TypeSpec.classBuilder(\"Taco\")\n+            .addField(Thread.class, \"thread\")\n+            .alwaysQualify(\"Thread\")\n+            .build())\n+        .build()\n+        .toString();\n+    assertThat(source).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"class Taco {\\n\"\n+        + \"  java.lang.Thread thread;\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void alwaysQualifySupersedesJavaLangImports() {\n+    String source = JavaFile.builder(\"com.squareup.tacos\",\n+        TypeSpec.classBuilder(\"Taco\")\n+            .addField(Thread.class, \"thread\")\n+            .alwaysQualify(\"Thread\")\n+            .build())\n+        .skipJavaLangImports(true)\n+        .build()\n+        .toString();\n+    assertThat(source).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"class Taco {\\n\"\n+        + \"  java.lang.Thread thread;\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void avoidClashesWithNestedClasses_viaClass() {\n+    String source = JavaFile.builder(\"com.squareup.tacos\",\n+        TypeSpec.classBuilder(\"Taco\")\n+            // These two should get qualified\n+            .addField(ClassName.get(\"other\", \"NestedTypeA\"), \"nestedA\")\n+            .addField(ClassName.get(\"other\", \"NestedTypeB\"), \"nestedB\")\n+            // This one shouldn't since it's not a nested type of Foo\n+            .addField(ClassName.get(\"other\", \"NestedTypeC\"), \"nestedC\")\n+            // This one shouldn't since we only look at nested types\n+            .addField(ClassName.get(\"other\", \"Foo\"), \"foo\")\n+            .avoidClashesWithNestedClasses(Foo.class)\n+            .build())\n+        .build()\n+        .toString();\n+    assertThat(source).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import other.Foo;\\n\"\n+        + \"import other.NestedTypeC;\\n\"\n+        + \"\\n\"\n+        + \"class Taco {\\n\"\n+        + \"  other.NestedTypeA nestedA;\\n\"\n+        + \"\\n\"\n+        + \"  other.NestedTypeB nestedB;\\n\"\n+        + \"\\n\"\n+        + \"  NestedTypeC nestedC;\\n\"\n+        + \"\\n\"\n+        + \"  Foo foo;\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void avoidClashesWithNestedClasses_viaTypeElement() {\n+    String source = JavaFile.builder(\"com.squareup.tacos\",\n+        TypeSpec.classBuilder(\"Taco\")\n+            // These two should get qualified\n+            .addField(ClassName.get(\"other\", \"NestedTypeA\"), \"nestedA\")\n+            .addField(ClassName.get(\"other\", \"NestedTypeB\"), \"nestedB\")\n+            // This one shouldn't since it's not a nested type of Foo\n+            .addField(ClassName.get(\"other\", \"NestedTypeC\"), \"nestedC\")\n+            // This one shouldn't since we only look at nested types\n+            .addField(ClassName.get(\"other\", \"Foo\"), \"foo\")\n+            .avoidClashesWithNestedClasses(getElement(Foo.class))\n+            .build())\n+        .build()\n+        .toString();\n+    assertThat(source).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import other.Foo;\\n\"\n+        + \"import other.NestedTypeC;\\n\"\n+        + \"\\n\"\n+        + \"class Taco {\\n\"\n+        + \"  other.NestedTypeA nestedA;\\n\"\n+        + \"\\n\"\n+        + \"  other.NestedTypeB nestedB;\\n\"\n+        + \"\\n\"\n+        + \"  NestedTypeC nestedC;\\n\"\n+        + \"\\n\"\n+        + \"  Foo foo;\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test public void avoidClashesWithNestedClasses_viaSuperinterfaceType() {\n+    String source = JavaFile.builder(\"com.squareup.tacos\",\n+        TypeSpec.classBuilder(\"Taco\")\n+            // These two should get qualified\n+            .addField(ClassName.get(\"other\", \"NestedTypeA\"), \"nestedA\")\n+            .addField(ClassName.get(\"other\", \"NestedTypeB\"), \"nestedB\")\n+            // This one shouldn't since it's not a nested type of Foo\n+            .addField(ClassName.get(\"other\", \"NestedTypeC\"), \"nestedC\")\n+            // This one shouldn't since we only look at nested types\n+            .addField(ClassName.get(\"other\", \"Foo\"), \"foo\")\n+            .addType(TypeSpec.classBuilder(\"NestedTypeA\").build())\n+            .addType(TypeSpec.classBuilder(\"NestedTypeB\").build())\n+            .addSuperinterface(FooInterface.class)\n+            .build())\n+        .build()\n+        .toString();\n+    assertThat(source).isEqualTo(\"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"import com.squareup.javapoet.JavaFileTest;\\n\"\n+        + \"import other.Foo;\\n\"\n+        + \"import other.NestedTypeC;\\n\"\n+        + \"\\n\"\n+        + \"class Taco implements JavaFileTest.FooInterface {\\n\"\n+        + \"  other.NestedTypeA nestedA;\\n\"\n+        + \"\\n\"\n+        + \"  other.NestedTypeB nestedB;\\n\"\n+        + \"\\n\"\n+        + \"  NestedTypeC nestedC;\\n\"\n+        + \"\\n\"\n+        + \"  Foo foo;\\n\"\n+        + \"\\n\"\n+        + \"  class NestedTypeA {\\n\"\n+        + \"  }\\n\"\n+        + \"\\n\"\n+        + \"  class NestedTypeB {\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  static class Foo {\n+    static class NestedTypeA {\n+\n+    }\n+    static class NestedTypeB {\n+\n+    }\n+  }\n+\n+  interface FooInterface {\n+    class NestedTypeA {\n+\n+    }\n+    class NestedTypeB {\n+\n+    }\n+  }\n+\n+  private TypeSpec.Builder childTypeBuilder() {\n+    return TypeSpec.classBuilder(\"Child\")\n+        .addMethod(MethodSpec.methodBuilder(\"optionalString\")\n+            .returns(ParameterizedTypeName.get(Optional.class, String.class))\n+            .addStatement(\"return $T.empty()\", Optional.class)\n+            .build())\n+        .addMethod(MethodSpec.methodBuilder(\"pattern\")\n+            .returns(Pattern.class)\n+            .addStatement(\"return null\")\n+            .build());\n+  }\n+\n+  @Test\n+  public void avoidClashes_parentChild_superclass_type() {\n+    String source = JavaFile.builder(\"com.squareup.javapoet\",\n+        childTypeBuilder().superclass(Parent.class).build())\n+        .build()\n+        .toString();\n+    assertThat(source).isEqualTo(\"package com.squareup.javapoet;\\n\"\n+        + \"\\n\"\n+        + \"import java.lang.String;\\n\"\n+        + \"\\n\"\n+        + \"class Child extends JavaFileTest.Parent {\\n\"\n+        + \"  java.util.Optional<String> optionalString() {\\n\"\n+        + \"    return java.util.Optional.empty();\\n\"\n+        + \"  }\\n\"\n+        + \"\\n\"\n+        + \"  java.util.regex.Pattern pattern() {\\n\"\n+        + \"    return null;\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test\n+  public void avoidClashes_parentChild_superclass_typeMirror() {\n+    String source = JavaFile.builder(\"com.squareup.javapoet\",\n+        childTypeBuilder().superclass(getElement(Parent.class).asType()).build())\n+        .build()\n+        .toString();\n+    assertThat(source).isEqualTo(\"package com.squareup.javapoet;\\n\"\n+        + \"\\n\"\n+        + \"import java.lang.String;\\n\"\n+        + \"\\n\"\n+        + \"class Child extends JavaFileTest.Parent {\\n\"\n+        + \"  java.util.Optional<String> optionalString() {\\n\"\n+        + \"    return java.util.Optional.empty();\\n\"\n+        + \"  }\\n\"\n+        + \"\\n\"\n+        + \"  java.util.regex.Pattern pattern() {\\n\"\n+        + \"    return null;\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test\n+  public void avoidClashes_parentChild_superinterface_type() {\n+    String source = JavaFile.builder(\"com.squareup.javapoet\",\n+        childTypeBuilder().addSuperinterface(ParentInterface.class).build())\n+        .build()\n+        .toString();\n+    assertThat(source).isEqualTo(\"package com.squareup.javapoet;\\n\"\n+        + \"\\n\"\n+        + \"import java.lang.String;\\n\"\n+        + \"import java.util.regex.Pattern;\\n\"\n+        + \"\\n\"\n+        + \"class Child implements JavaFileTest.ParentInterface {\\n\"\n+        + \"  java.util.Optional<String> optionalString() {\\n\"\n+        + \"    return java.util.Optional.empty();\\n\"\n+        + \"  }\\n\"\n+        + \"\\n\"\n+        + \"  Pattern pattern() {\\n\"\n+        + \"    return null;\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  @Test\n+  public void avoidClashes_parentChild_superinterface_typeMirror() {\n+    String source = JavaFile.builder(\"com.squareup.javapoet\",\n+        childTypeBuilder().addSuperinterface(getElement(ParentInterface.class).asType()).build())\n+        .build()\n+        .toString();\n+    assertThat(source).isEqualTo(\"package com.squareup.javapoet;\\n\"\n+        + \"\\n\"\n+        + \"import java.lang.String;\\n\"\n+        + \"import java.util.regex.Pattern;\\n\"\n+        + \"\\n\"\n+        + \"class Child implements JavaFileTest.ParentInterface {\\n\"\n+        + \"  java.util.Optional<String> optionalString() {\\n\"\n+        + \"    return java.util.Optional.empty();\\n\"\n+        + \"  }\\n\"\n+        + \"\\n\"\n+        + \"  Pattern pattern() {\\n\"\n+        + \"    return null;\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n+\n+  // Regression test for https://github.com/square/javapoet/issues/77\n+  // This covers class and inheritance\n+  static class Parent implements ParentInterface {\n+    static class Pattern {\n+\n+    }\n+  }\n+\n+  interface ParentInterface {\n+    class Optional {\n+\n+    }\n+  }\n+\n+  // Regression test for case raised here: https://github.com/square/javapoet/issues/77#issuecomment-519972404\n+  @Test\n+  public void avoidClashes_mapEntry() {\n+    String source = JavaFile.builder(\"com.squareup.javapoet\",\n+        TypeSpec.classBuilder(\"MapType\")\n+            .addMethod(MethodSpec.methodBuilder(\"optionalString\")\n+                .returns(ClassName.get(\"com.foo\", \"Entry\"))\n+                .addStatement(\"return null\")\n+                .build())\n+            .addSuperinterface(Map.class)\n+            .build())\n+        .build()\n+        .toString();\n+    assertThat(source).isEqualTo(\"package com.squareup.javapoet;\\n\"\n+        + \"\\n\"\n+        + \"import java.util.Map;\\n\"\n+        + \"\\n\"\n+        + \"class MapType implements Map {\\n\"\n+        + \"  com.foo.Entry optionalString() {\\n\"\n+        + \"    return null;\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\");\n+  }\n }\n"
    },
    {
        "commit_hash": "80ddc99409399bd15b06509a6e3e75cb4117b8d2",
        "previous_commit_hash": "25d19845b866c04a2fb3e11ce3d43ccb2e7b98cd",
        "diff_stats": {
            "additions": 3,
            "deletions": 0
        },
        "diff_content": "@@ -2284,12 +2284,15 @@ public final class TypeSpecTest {\n             .addStatement(\"foo = $S\", \"FOO\")\n             .build())\n         .addOriginatingElement(originatingElement)\n+        .alwaysQualify(\"com.example.AlwaysQualified\")\n         .build();\n \n     TypeSpec recreatedTaco = taco.toBuilder().build();\n     assertThat(toString(taco)).isEqualTo(toString(recreatedTaco));\n     assertThat(taco.originatingElements)\n         .containsExactlyElementsIn(recreatedTaco.originatingElements);\n+    assertThat(taco.alwaysQualifiedNames)\n+        .containsExactlyElementsIn(recreatedTaco.alwaysQualifiedNames);\n \n     TypeSpec initializersAdded = taco.toBuilder()\n         .addInitializerBlock(CodeBlock.builder()\n"
    },
    {
        "commit_hash": "dc64ed1f9bf362e68451d75f302e6e656a114066",
        "previous_commit_hash": "80ddc99409399bd15b06509a6e3e75cb4117b8d2",
        "diff_stats": {
            "additions": 28,
            "deletions": 3
        },
        "diff_content": "@@ -103,14 +103,30 @@ public final class JavaFile {\n \n   /** Writes this to {@code directory} as UTF-8 using the standard directory structure. */\n   public void writeTo(Path directory) throws IOException {\n-    writeTo(directory, UTF_8);\n+    writeToPath(directory);\n   }\n \n   /**\n-   * Writes this to {@code directory} with the provided {@code charset}\n-   * using the standard directory structure.\n+   * Writes this to {@code directory} with the provided {@code charset} using the standard directory\n+   * structure.\n    */\n   public void writeTo(Path directory, Charset charset) throws IOException {\n+    writeToPath(directory, charset);\n+  }\n+\n+  /**\n+   * Writes this to {@code directory} as UTF-8 using the standard directory structure.\n+   * Returns the {@link Path} instance to which source is actually written.\n+   * */\n+  public Path writeToPath(Path directory) throws IOException {\n+    return writeToPath(directory, UTF_8);\n+  }\n+\n+  /**\n+   * Writes this to {@code directory} with the provided {@code charset} using the standard directory\n+   * structure.\n+   * Returns the {@link Path} instance to which source is actually written. */\n+  public Path writeToPath(Path directory, Charset charset) throws IOException {\n     checkArgument(Files.notExists(directory) || Files.isDirectory(directory),\n         \"path %s exists but is not a directory.\", directory);\n     Path outputDirectory = directory;\n@@ -125,6 +141,8 @@ public final class JavaFile {\n     try (Writer writer = new OutputStreamWriter(Files.newOutputStream(outputPath), charset)) {\n       writeTo(writer);\n     }\n+\n+    return outputPath;\n   }\n \n   /** Writes this to {@code directory} as UTF-8 using the standard directory structure. */\n@@ -132,6 +150,13 @@ public final class JavaFile {\n     writeTo(directory.toPath());\n   }\n \n+  /** Writes this to {@code directory} as UTF-8 using the standard directory structure.\n+   * Returns the {@link File} instance to which source is actually written. */\n+  public File writeToFile(File directory) throws IOException {\n+    final Path outputPath = writeToPath(directory.toPath());\n+    return outputPath.toFile();\n+  }\n+\n   /** Writes this to {@code filer}. */\n   public void writeTo(Filer filer) throws IOException {\n     String fileName = packageName.isEmpty()\n"
    },
    {
        "commit_hash": "eff1ee43296678eb0b0588faf4f18c34d8be4baf",
        "previous_commit_hash": "74a0f27a71a5627a81799010d761fb4f5b08e1f6",
        "diff_stats": {
            "additions": 7,
            "deletions": 4
        },
        "diff_content": "@@ -117,7 +117,7 @@ public final class JavaFile {\n   /**\n    * Writes this to {@code directory} as UTF-8 using the standard directory structure.\n    * Returns the {@link Path} instance to which source is actually written.\n-   * */\n+   */\n   public Path writeToPath(Path directory) throws IOException {\n     return writeToPath(directory, UTF_8);\n   }\n@@ -125,7 +125,8 @@ public final class JavaFile {\n   /**\n    * Writes this to {@code directory} with the provided {@code charset} using the standard directory\n    * structure.\n-   * Returns the {@link Path} instance to which source is actually written. */\n+   * Returns the {@link Path} instance to which source is actually written.\n+   */\n   public Path writeToPath(Path directory, Charset charset) throws IOException {\n     checkArgument(Files.notExists(directory) || Files.isDirectory(directory),\n         \"path %s exists but is not a directory.\", directory);\n@@ -150,8 +151,10 @@ public final class JavaFile {\n     writeTo(directory.toPath());\n   }\n \n-  /** Writes this to {@code directory} as UTF-8 using the standard directory structure.\n-   * Returns the {@link File} instance to which source is actually written. */\n+  /**\n+   * Writes this to {@code directory} as UTF-8 using the standard directory structure.\n+   * Returns the {@link File} instance to which source is actually written.\n+   */\n   public File writeToFile(File directory) throws IOException {\n     final Path outputPath = writeToPath(directory.toPath());\n     return outputPath.toFile();\n"
    },
    {
        "commit_hash": "eff1ee43296678eb0b0588faf4f18c34d8be4baf",
        "previous_commit_hash": "74a0f27a71a5627a81799010d761fb4f5b08e1f6",
        "diff_stats": {
            "additions": 7,
            "deletions": 0
        },
        "diff_content": "@@ -216,4 +216,11 @@ public final class FileWritingTest {\n         + \"class Taco {\\n\"\n         + \"}\\n\");\n   }\n+\n+  @Test public void writeToPathReturnsPath() throws IOException {\n+    JavaFile javaFile = JavaFile.builder(\"foo\", TypeSpec.classBuilder(\"Taco\").build()).build();\n+    Path filePath = javaFile.writeToPath(fsRoot);\n+    // Cast to avoid ambiguity between assertThat(Path) and assertThat(Iterable<?>)\n+    assertThat((Iterable<?>) filePath).isEqualTo(fsRoot.resolve(fs.getPath(\"foo\", \"Taco.java\")));\n+  }\n }\n"
    },
    {
        "commit_hash": "8b5db1a19db6366841a9ce31d526482c8b35e745",
        "previous_commit_hash": "aba981036ea5e4cc3950cb5332940f44402cfd05",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.12.0-SNAPSHOT</version>\n+  <version>1.12.0</version>\n \n   <name>JavaPoet</name>\n   <description>Use beautiful Java code to generate beautiful Java code.</description>\n"
    },
    {
        "commit_hash": "1ef324c43fe5371e4d0c63dfe4d52c14c0c01631",
        "previous_commit_hash": "8b5db1a19db6366841a9ce31d526482c8b35e745",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.12.0</version>\n+  <version>1.13.0-SNAPSHOT</version>\n \n   <name>JavaPoet</name>\n   <description>Use beautiful Java code to generate beautiful Java code.</description>\n"
    },
    {
        "commit_hash": "0d25ea100a4387c28b5ef12e44fbffc0b22b5343",
        "previous_commit_hash": "1ef324c43fe5371e4d0c63dfe4d52c14c0c01631",
        "diff_stats": {
            "additions": 24,
            "deletions": 0
        },
        "diff_content": "@@ -1,6 +1,30 @@\n Change Log\n ==========\n \n+JavaPoet 1.12.0 *(2020-01-09)*\n+-----------------------------\n+\n+ * New: Add `JavaFile.writeToPath()` and `JavaFile.writeToFile()` methods that return paths to the \n+   generated file as `Path` and `File` respectively.\n+ * New: Add `TypeSpec.alwaysQualify()` API to avoid clashes involving nested type names.\n+ * New: Add overloads accepting `CodeBlock`s to `MethodSpec`'s control flow methods.\n+ * New: Make list fields of all `Builder` types mutable.\n+ * New: Add `CodeBlock.clear()`.\n+ * New: Allow passing a custom `Charset` to `JavaFile.writeTo()`.\n+ * New: Improved performance of `ClassName.simpleNames()` by memoizing results.\n+ * New: Significant performance improvements for `CodeWriter.resolve()` as all nested simple names \n+   of a `TypeSpec` get pre-computed.\n+ * New: Add `TypeName.Builder.setName()` to allow overriding names passed in the constructor.\n+ * New: Add `TypeName.canonicalName()`.\n+ * Fix: Use `\\\\R` instead of `\\n` as line separator in `CodeWriter.emitAndIndent()`.\n+ * Fix: Copy originating elements in `TypeSpec.toBuilder()`.\n+ * Fix: Ensure trailing newlines in Javadocs and method bodies.\n+ * Fix: Copy annotations when creating a `ParameterSpec` from a `VariableElement`.\n+ * Fix: Properly handle classes located in empty packages in `ClassName`.\n+ * Fix: Disallow `final` modifier on a `ParameterSpec`.\n+ * Fix: Use fully-qualified names for type names that are masked by type variable names.\n+\n+\n JavaPoet 1.11.1 *(2018-05-16)*\n -----------------------------\n \n"
    },
    {
        "commit_hash": "0d25ea100a4387c28b5ef12e44fbffc0b22b5343",
        "previous_commit_hash": "1ef324c43fe5371e4d0c63dfe4d52c14c0c01631",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -892,12 +892,12 @@ Download [the latest .jar][dl] or depend via Maven:\n <dependency>\n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.11.1</version>\n+  <version>1.12.0</version>\n </dependency>\n ```\n or Gradle:\n ```groovy\n-compile 'com.squareup:javapoet:1.11.1'\n+compile 'com.squareup:javapoet:1.12.0'\n ```\n \n Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].\n"
    },
    {
        "commit_hash": "d3eef47161d7aea57273f1fe0b80fbb9068e785b",
        "previous_commit_hash": "0d25ea100a4387c28b5ef12e44fbffc0b22b5343",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -21,7 +21,7 @@ JavaPoet 1.12.0 *(2020-01-09)*\n  * Fix: Ensure trailing newlines in Javadocs and method bodies.\n  * Fix: Copy annotations when creating a `ParameterSpec` from a `VariableElement`.\n  * Fix: Properly handle classes located in empty packages in `ClassName`.\n- * Fix: Disallow `final` modifier on a `ParameterSpec`.\n+ * Fix: Only allow `final` modifier on a `ParameterSpec`.\n  * Fix: Use fully-qualified names for type names that are masked by type variable names.\n \n \n"
    },
    {
        "commit_hash": "5a6c842a37a8c71f079ad2ce6063a70a9dee9e31",
        "previous_commit_hash": "d3eef47161d7aea57273f1fe0b80fbb9068e785b",
        "diff_stats": {
            "additions": 9,
            "deletions": 1
        },
        "diff_content": "@@ -24,6 +24,7 @@ import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.stream.Collectors;\n import javax.lang.model.SourceVersion;\n import javax.lang.model.element.Element;\n import javax.lang.model.element.ExecutableElement;\n@@ -232,7 +233,14 @@ public final class MethodSpec {\n     }\n \n     methodBuilder.returns(TypeName.get(method.getReturnType()));\n-    methodBuilder.addParameters(ParameterSpec.parametersOf(method));\n+    methodBuilder.addParameters(ParameterSpec.parametersOf(method)\n+        .stream()\n+        .map(parameterSpec -> {\n+          ParameterSpec.Builder builder = parameterSpec.toBuilder();\n+          builder.annotations.clear();\n+          return builder.build();\n+        })\n+        .collect(Collectors.toList()));\n     methodBuilder.varargs(method.isVarArgs());\n \n     for (TypeMirror thrownType : method.getThrownTypes()) {\n"
    },
    {
        "commit_hash": "5a6c842a37a8c71f079ad2ce6063a70a9dee9e31",
        "previous_commit_hash": "d3eef47161d7aea57273f1fe0b80fbb9068e785b",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -148,8 +148,8 @@ public final class MethodSpecTest {\n         + \"@java.lang.Override\\n\"\n         + \"protected <T extends java.lang.Runnable & java.io.Closeable> java.lang.Runnable \"\n         + \"everything(\\n\"\n-        + \"    @com.squareup.javapoet.MethodSpecTest.Nullable java.lang.String arg0,\\n\"\n-        + \"    java.util.List<? extends T> arg1) throws java.io.IOException, java.lang.SecurityException {\\n\"\n+        + \"    java.lang.String arg0, java.util.List<? extends T> arg1) throws java.io.IOException,\\n\"\n+        + \"    java.lang.SecurityException {\\n\"\n         + \"}\\n\");\n   }\n \n"
    },
    {
        "commit_hash": "ecfcfca2781e1edd2a98a8508294ea0ad40e88a6",
        "previous_commit_hash": "8ce7d7568c23afbd1cbb56ffbd24ae696f1b92b1",
        "diff_stats": {
            "additions": 2,
            "deletions": 0
        },
        "diff_content": "@@ -233,6 +233,8 @@ public final class MethodSpec {\n     }\n \n     methodBuilder.returns(TypeName.get(method.getReturnType()));\n+    // Copying parameter annotations from the overridden method can be incorrect so we're\n+    // deliberately dropping them. See https://github.com/square/javapoet/issues/482.\n     methodBuilder.addParameters(ParameterSpec.parametersOf(method)\n         .stream()\n         .map(parameterSpec -> {\n"
    },
    {
        "commit_hash": "9451a362adee16bbf7be382c2a95772fae2c48d1",
        "previous_commit_hash": "2b7adc794b2ec7fbce3c23409283110757ca7596",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.13.0-SNAPSHOT</version>\n+  <version>1.12.1</version>\n \n   <name>JavaPoet</name>\n   <description>Use beautiful Java code to generate beautiful Java code.</description>\n"
    },
    {
        "commit_hash": "2063666c382f8fd0b35811db0d761c5b6ba18484",
        "previous_commit_hash": "9451a362adee16bbf7be382c2a95772fae2c48d1",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.12.1</version>\n+  <version>1.13.0-SNAPSHOT</version>\n \n   <name>JavaPoet</name>\n   <description>Use beautiful Java code to generate beautiful Java code.</description>\n"
    },
    {
        "commit_hash": "44622704248975ca398b90b4385005fdddeb35f9",
        "previous_commit_hash": "2063666c382f8fd0b35811db0d761c5b6ba18484",
        "diff_stats": {
            "additions": 6,
            "deletions": 0
        },
        "diff_content": "@@ -1,6 +1,12 @@\n Change Log\n ==========\n \n+JavaPoet 1.12.1 *(2020-01-20)*\n+-----------------------------\n+\n+ * Fix: Ignore parameter annotations in `MethodSpec.overriding()`.\n+\n+\n JavaPoet 1.12.0 *(2020-01-09)*\n -----------------------------\n \n"
    },
    {
        "commit_hash": "44622704248975ca398b90b4385005fdddeb35f9",
        "previous_commit_hash": "2063666c382f8fd0b35811db0d761c5b6ba18484",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -892,12 +892,12 @@ Download [the latest .jar][dl] or depend via Maven:\n <dependency>\n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.12.0</version>\n+  <version>1.12.1</version>\n </dependency>\n ```\n or Gradle:\n ```groovy\n-compile 'com.squareup:javapoet:1.12.0'\n+compile 'com.squareup:javapoet:1.12.1'\n ```\n \n Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].\n"
    },
    {
        "commit_hash": "622e07eb0859fcf0eb9537ea5657277b7f3b18af",
        "previous_commit_hash": "44622704248975ca398b90b4385005fdddeb35f9",
        "diff_stats": {
            "additions": 1,
            "deletions": 11
        },
        "diff_content": "@@ -24,7 +24,6 @@ import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n-import java.util.stream.Collectors;\n import javax.lang.model.SourceVersion;\n import javax.lang.model.element.Element;\n import javax.lang.model.element.ExecutableElement;\n@@ -233,16 +232,7 @@ public final class MethodSpec {\n     }\n \n     methodBuilder.returns(TypeName.get(method.getReturnType()));\n-    // Copying parameter annotations from the overridden method can be incorrect so we're\n-    // deliberately dropping them. See https://github.com/square/javapoet/issues/482.\n-    methodBuilder.addParameters(ParameterSpec.parametersOf(method)\n-        .stream()\n-        .map(parameterSpec -> {\n-          ParameterSpec.Builder builder = parameterSpec.toBuilder();\n-          builder.annotations.clear();\n-          return builder.build();\n-        })\n-        .collect(Collectors.toList()));\n+    methodBuilder.addParameters(ParameterSpec.parametersOf(method));\n     methodBuilder.varargs(method.isVarArgs());\n \n     for (TypeMirror thrownType : method.getThrownTypes()) {\n"
    },
    {
        "commit_hash": "622e07eb0859fcf0eb9537ea5657277b7f3b18af",
        "previous_commit_hash": "44622704248975ca398b90b4385005fdddeb35f9",
        "diff_stats": {
            "additions": 2,
            "deletions": 8
        },
        "diff_content": "@@ -21,7 +21,6 @@ import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n import java.util.Set;\n-import java.util.stream.Collectors;\n import javax.lang.model.SourceVersion;\n import javax.lang.model.element.ElementKind;\n import javax.lang.model.element.ExecutableElement;\n@@ -87,17 +86,12 @@ public final class ParameterSpec {\n   public static ParameterSpec get(VariableElement element) {\n     checkArgument(element.getKind().equals(ElementKind.PARAMETER), \"element is not a parameter\");\n \n-    // Copy over any annotations from element.\n-    List<AnnotationSpec> annotations = element.getAnnotationMirrors()\n-        .stream()\n-        .map((mirror) -> AnnotationSpec.get(mirror))\n-        .collect(Collectors.toList());\n-\n     TypeName type = TypeName.get(element.asType());\n     String name = element.getSimpleName().toString();\n+    // Copying parameter annotations can be incorrect so we're deliberately not including them.\n+    // See https://github.com/square/javapoet/issues/482.\n     return ParameterSpec.builder(type, name)\n         .addModifiers(element.getModifiers())\n-        .addAnnotations(annotations)\n         .build();\n   }\n \n"
    },
    {
        "commit_hash": "622e07eb0859fcf0eb9537ea5657277b7f3b18af",
        "previous_commit_hash": "44622704248975ca398b90b4385005fdddeb35f9",
        "diff_stats": {
            "additions": 26,
            "deletions": 0
        },
        "diff_content": "@@ -15,6 +15,7 @@\n  */\n package com.squareup.javapoet;\n \n+import com.google.testing.compile.Compilation;\n import com.google.testing.compile.CompilationRule;\n import java.io.Closeable;\n import java.io.IOException;\n@@ -30,14 +31,19 @@ import javax.lang.model.element.ExecutableElement;\n import javax.lang.model.element.Modifier;\n import javax.lang.model.element.TypeElement;\n import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.util.ElementFilter;\n import javax.lang.model.util.Elements;\n import javax.lang.model.util.Types;\n+import javax.tools.JavaFileObject;\n+\n+import com.google.testing.compile.CompilationSubject;\n import org.junit.Before;\n import org.junit.Rule;\n import org.junit.Test;\n \n import static com.google.common.collect.Iterables.getOnlyElement;\n import static com.google.common.truth.Truth.assertThat;\n+import static com.google.testing.compile.Compiler.javac;\n import static com.squareup.javapoet.MethodSpec.CONSTRUCTOR;\n import static com.squareup.javapoet.TestUtil.findFirst;\n import static javax.lang.model.util.ElementFilter.methodsIn;\n@@ -247,6 +253,26 @@ public final class MethodSpecTest {\n     }\n   }\n \n+  abstract static class AbstractClassWithPrivateAnnotation {\n+\n+    private @interface PrivateAnnotation{ }\n+\n+    abstract void foo(@PrivateAnnotation final String bar);\n+  }\n+\n+  @Test public void overrideDoesNotCopyParameterAnnotations() {\n+    TypeElement abstractTypeElement = getElement(AbstractClassWithPrivateAnnotation.class);\n+    ExecutableElement fooElement = ElementFilter.methodsIn(abstractTypeElement.getEnclosedElements()).get(0);\n+    ClassName implClassName = ClassName.get(\"com.squareup.javapoet\", \"Impl\");\n+    TypeSpec type = TypeSpec.classBuilder(implClassName)\n+            .superclass(abstractTypeElement.asType())\n+            .addMethod(MethodSpec.overriding(fooElement).build())\n+            .build();\n+    JavaFileObject jfo = JavaFile.builder(implClassName.packageName, type).build().toJavaFileObject();\n+    Compilation compilation = javac().compile(jfo);\n+    CompilationSubject.assertThat(compilation).succeeded();\n+  }\n+\n   @Test public void equalsAndHashCode() {\n     MethodSpec a = MethodSpec.constructorBuilder().build();\n     MethodSpec b = MethodSpec.constructorBuilder().build();\n"
    },
    {
        "commit_hash": "622e07eb0859fcf0eb9537ea5657277b7f3b18af",
        "previous_commit_hash": "44622704248975ca398b90b4385005fdddeb35f9",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -99,7 +99,7 @@ public class ParameterSpecTest {\n     VariableElement parameterElement = element.getParameters().get(0);\n \n     assertThat(ParameterSpec.get(parameterElement).toString())\n-        .isEqualTo(\"@javax.annotation.Nullable java.lang.String arg0\");\n+        .isEqualTo(\"java.lang.String arg0\");\n   }\n \n   @Test public void addNonFinalModifier() {\n"
    },
    {
        "commit_hash": "4135ccbc902eac2f2bfc063aacd8b3e7864e1ab5",
        "previous_commit_hash": "622e07eb0859fcf0eb9537ea5657277b7f3b18af",
        "diff_stats": {
            "additions": 2,
            "deletions": 3
        },
        "diff_content": "@@ -36,15 +36,14 @@ import javax.lang.model.util.Elements;\n import javax.lang.model.util.Types;\n import javax.tools.JavaFileObject;\n \n-import com.google.testing.compile.CompilationSubject;\n import org.junit.Before;\n import org.junit.Rule;\n import org.junit.Test;\n \n import static com.google.common.collect.Iterables.getOnlyElement;\n import static com.google.common.truth.Truth.assertThat;\n+import static com.google.testing.compile.CompilationSubject.assertThat;\n import static com.google.testing.compile.Compiler.javac;\n-import static com.squareup.javapoet.MethodSpec.CONSTRUCTOR;\n import static com.squareup.javapoet.TestUtil.findFirst;\n import static javax.lang.model.util.ElementFilter.methodsIn;\n import static org.junit.Assert.fail;\n@@ -270,7 +269,7 @@ public final class MethodSpecTest {\n             .build();\n     JavaFileObject jfo = JavaFile.builder(implClassName.packageName, type).build().toJavaFileObject();\n     Compilation compilation = javac().compile(jfo);\n-    CompilationSubject.assertThat(compilation).succeeded();\n+    assertThat(compilation).succeeded();\n   }\n \n   @Test public void equalsAndHashCode() {\n"
    },
    {
        "commit_hash": "a5f4f0f2ada5c8040d7a02db9b423093f051b1d6",
        "previous_commit_hash": "304176ef98fa80f35cb49ed130620c7b0ecdf5a6",
        "diff_stats": {
            "additions": 10,
            "deletions": 1
        },
        "diff_content": "@@ -103,9 +103,18 @@ public final class ParameterSpec {\n     return result;\n   }\n \n+  private static boolean isValidParameterName(String name) {\n+    // Allow \"this\" for explicit receiver parameters\n+    // See https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.1.\n+    if (name.endsWith(\".this\")) {\n+      return SourceVersion.isIdentifier(name.substring(0, name.length() - \".this\".length()));\n+    }\n+    return name.equals(\"this\") || SourceVersion.isName(name);\n+  }\n+\n   public static Builder builder(TypeName type, String name, Modifier... modifiers) {\n     checkNotNull(type, \"type == null\");\n-    checkArgument(SourceVersion.isName(name), \"not a valid name: %s\", name);\n+    checkArgument(isValidParameterName(name), \"not a valid name: %s\", name);\n     return new Builder(type, name)\n         .addModifiers(modifiers);\n   }\n"
    },
    {
        "commit_hash": "a5f4f0f2ada5c8040d7a02db9b423093f051b1d6",
        "previous_commit_hash": "304176ef98fa80f35cb49ed130620c7b0ecdf5a6",
        "diff_stats": {
            "additions": 19,
            "deletions": 0
        },
        "diff_content": "@@ -60,6 +60,25 @@ public class ParameterSpecTest {\n     assertThat(a.toString()).isEqualTo(b.toString());\n   }\n \n+  @Test public void receiverParameterInstanceMethod() {\n+    ParameterSpec.Builder builder = ParameterSpec.builder(int.class, \"this\");\n+    assertThat(builder.build().name).isEqualTo(\"this\");\n+  }\n+\n+  @Test public void receiverParameterNestedClass() {\n+    ParameterSpec.Builder builder = ParameterSpec.builder(int.class, \"Foo.this\");\n+    assertThat(builder.build().name).isEqualTo(\"Foo.this\");\n+  }\n+\n+  @Test public void keywordName() {\n+    try {\n+      ParameterSpec.builder(int.class, \"super\");\n+      fail();\n+    } catch (Exception e) {\n+      assertThat(e.getMessage()).isEqualTo(\"not a valid name: super\");\n+    }\n+  }\n+\n   @Test public void nullAnnotationsAddition() {\n     try {\n       ParameterSpec.builder(int.class, \"foo\").addAnnotations(null);\n"
    },
    {
        "commit_hash": "8705e5ce5befdc0cc47ef57919cf69ab2dde9ff8",
        "previous_commit_hash": "e77793bc164c32982e3047a5260dbf009f208c7f",
        "diff_stats": {
            "additions": 7,
            "deletions": 0
        },
        "diff_content": "@@ -1,6 +1,13 @@\n Change Log\n ==========\n \n+JavaPoet 1.13.0 *(2020-06-18)*\n+-----------------------------\n+\n+ * New: Add support for explicit receiver parameters.\n+ * Fix: Don't copy parameter annotations when creating a `ParameterSpec`.\n+\n+\n JavaPoet 1.12.1 *(2020-01-20)*\n -----------------------------\n \n"
    },
    {
        "commit_hash": "714e05ca60179285746604452324262b126dcb2d",
        "previous_commit_hash": "8705e5ce5befdc0cc47ef57919cf69ab2dde9ff8",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.13.0-SNAPSHOT</version>\n+  <version>1.13.0</version>\n \n   <name>JavaPoet</name>\n   <description>Use beautiful Java code to generate beautiful Java code.</description>\n"
    },
    {
        "commit_hash": "081d839bff0b47c6a72790d5e3788f2626b928f6",
        "previous_commit_hash": "714e05ca60179285746604452324262b126dcb2d",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.13.0</version>\n+  <version>1.14.0-SNAPSHOT</version>\n \n   <name>JavaPoet</name>\n   <description>Use beautiful Java code to generate beautiful Java code.</description>\n"
    },
    {
        "commit_hash": "8e02981e9ff54ccf7220c97abe8da71bf8b5661c",
        "previous_commit_hash": "081d839bff0b47c6a72790d5e3788f2626b928f6",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.14.0-SNAPSHOT</version>\n+  <version>1.13.0</version>\n \n   <name>JavaPoet</name>\n   <description>Use beautiful Java code to generate beautiful Java code.</description>\n"
    },
    {
        "commit_hash": "d9fc2a80a22febc763d46770a589795f8b3bfae1",
        "previous_commit_hash": "8e02981e9ff54ccf7220c97abe8da71bf8b5661c",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -892,12 +892,12 @@ Download [the latest .jar][dl] or depend via Maven:\n <dependency>\n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.12.1</version>\n+  <version>1.13.0</version>\n </dependency>\n ```\n or Gradle:\n ```groovy\n-compile 'com.squareup:javapoet:1.12.1'\n+compile 'com.squareup:javapoet:1.13.0'\n ```\n \n Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].\n"
    },
    {
        "commit_hash": "d9fc2a80a22febc763d46770a589795f8b3bfae1",
        "previous_commit_hash": "8e02981e9ff54ccf7220c97abe8da71bf8b5661c",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.13.0</version>\n+  <version>1.13.0-SNAPSHOT</version>\n \n   <name>JavaPoet</name>\n   <description>Use beautiful Java code to generate beautiful Java code.</description>\n"
    },
    {
        "commit_hash": "5ca6d5b206bccb53305ad6235df45a173e983297",
        "previous_commit_hash": "d9fc2a80a22febc763d46770a589795f8b3bfae1",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.13.0-SNAPSHOT</version>\n+  <version>1.13.0</version>\n \n   <name>JavaPoet</name>\n   <description>Use beautiful Java code to generate beautiful Java code.</description>\n"
    },
    {
        "commit_hash": "b190e633e66cf2c5cf3e6a192d5be1a2d617b3b0",
        "previous_commit_hash": "5ca6d5b206bccb53305ad6235df45a173e983297",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.13.0</version>\n+  <version>1.14.0-SNAPSHOT</version>\n \n   <name>JavaPoet</name>\n   <description>Use beautiful Java code to generate beautiful Java code.</description>\n"
    },
    {
        "commit_hash": "f5eb99607562acb23997bc281c797acb26b0444e",
        "previous_commit_hash": "b190e633e66cf2c5cf3e6a192d5be1a2d617b3b0",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.14.0-SNAPSHOT</version>\n+  <version>1.13.0-SNAPSHOT</version>\n \n   <name>JavaPoet</name>\n   <description>Use beautiful Java code to generate beautiful Java code.</description>\n"
    },
    {
        "commit_hash": "ebb7d3ce593d9ae587e120f8a1e566555f9e074b",
        "previous_commit_hash": "f5eb99607562acb23997bc281c797acb26b0444e",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.13.0-SNAPSHOT</version>\n+  <version>1.13.0</version>\n \n   <name>JavaPoet</name>\n   <description>Use beautiful Java code to generate beautiful Java code.</description>\n"
    },
    {
        "commit_hash": "5e5a9c55951ef4384ecaa1524f4799e7a7334de1",
        "previous_commit_hash": "ebb7d3ce593d9ae587e120f8a1e566555f9e074b",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -11,7 +11,7 @@\n \n   <groupId>com.squareup</groupId>\n   <artifactId>javapoet</artifactId>\n-  <version>1.13.0</version>\n+  <version>1.14.0-SNAPSHOT</version>\n \n   <name>JavaPoet</name>\n   <description>Use beautiful Java code to generate beautiful Java code.</description>\n"
    },
    {
        "commit_hash": "24bf1f0307f07d0273298d9068697a723ca412c3",
        "previous_commit_hash": "b190e633e66cf2c5cf3e6a192d5be1a2d617b3b0",
        "diff_stats": {
            "additions": 47,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,47 @@\n+Releasing\n+=========\n+\n+1. Update the CHANGELOG.md for the impending release.\n+2. Update the README.md with the new version.\n+3. `git commit -am \"Update changelog for X.Y.Z.\"` (where X.Y.Z is the new version).\n+4. `mvn-release`.\n+    * `What is the release version for \"JavaPoet\"? (com.squareup.javapoet) X.Y.Z:` - hit Enter.\n+    * `What is SCM release tag or label for \"JavaPoet\"? (com.squareup.javapoet) javapoet-X.Y.Z:` - hit Enter.\n+    * `What is the new development version for \"JavaPoet\"? (com.squareup.javapoet) X.Y.(Z + 1)-SNAPSHOT:` - enter `X.(Y + 1).0-SNAPSHOT`.\n+    * Enter your GPG Passphrase when prompted.\n+5. Visit Sonatype Nexus and promote the artifact.\n+\n+If step 4 or 5 fails:\n+\n+  * Drop the Sonatype repo, \n+  * Fix the problem,\n+  * Manully revert the version change in `pom.xml` made by `mvn-release`,\n+  * Commit,\n+  * And start again at step 4.\n+\n+Prerequisites\n+-------------\n+\n+In `~/.m2/settings.xml`, set the following:\n+\n+```xml\n+<settings>\n+  <servers>\n+    <server>\n+      <id>sonatype-nexus-staging</id>\n+      <username>your-nexus-username</username>\n+      <password>your-nexus-password</password>\n+    </server>\n+  </servers>\n+</settings>\n+```\n+\n+In your shell's `.rc` file, set the following:\n+\n+```\n+alias mvn-release='mvn clean source:jar javadoc:jar verify && mvn clean release:clean && mvn release:prepare release:perform'\n+```\n+\n+Refer to the [GPG Keys][gpg_keys] guide if you need to set up GPG keys for signing.\n+\n+ [gpg_keys]: https://square.github.io/okio/releasing/#prerequisite-gpg-keys\n"
    },
    {
        "commit_hash": "7c8595ce6dc0c63a61d710a53df5a9086bf2a793",
        "previous_commit_hash": "0a6ee12960724854a0da33b171bcb06c1121c3e5",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -21,7 +21,7 @@\n     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n \n     <java.version>1.8</java.version>\n-    <junit.version>4.12</junit.version>\n+    <junit.version>4.13.1</junit.version>\n     <truth.version>0.39</truth.version>\n     <compile-testing.version>0.15</compile-testing.version>\n   </properties>\n"
    },
    {
        "commit_hash": "52c72c0a96c9e0b3b953f00af75dc663a308680a",
        "previous_commit_hash": "8ebce31cd655cf181ebdde59dcf04c50cbda7264",
        "diff_stats": {
            "additions": 3,
            "deletions": 1
        },
        "diff_content": "@@ -27,6 +27,7 @@ import java.util.Locale;\n import java.util.Map;\n import java.util.Objects;\n import java.util.Set;\n+import java.util.regex.Pattern;\n import javax.lang.model.SourceVersion;\n import javax.lang.model.element.Modifier;\n \n@@ -43,6 +44,7 @@ import static java.lang.String.join;\n final class CodeWriter {\n   /** Sentinel value that indicates that no user-provided package has been set. */\n   private static final String NO_PACKAGE = new String();\n+  private static final Pattern LINE_BREAKING_PATTERN = Pattern.compile(\"\\\\R\");\n \n   private final String indent;\n   private final LineWrapper out;\n@@ -469,7 +471,7 @@ final class CodeWriter {\n    */\n   CodeWriter emitAndIndent(String s) throws IOException {\n     boolean first = true;\n-    for (String line : s.split(\"\\\\R\", -1)) {\n+    for (String line : LINE_BREAKING_PATTERN.split(s, -1)) {\n       // Emit a newline character. Make sure blank lines in Javadoc & comments look good.\n       if (!first) {\n         if ((javadoc || comment) && trailingNewline) {\n"
    },
    {
        "commit_hash": "6f3d36c155880af80f6754fa69eaf9d42dbeb640",
        "previous_commit_hash": "8d7a39b2dab980363104164134638cf762d94edb",
        "diff_stats": {
            "additions": 9,
            "deletions": 2
        },
        "diff_content": "@@ -796,9 +796,16 @@ public final class TypeSpec {\n \n       for (MethodSpec methodSpec : methodSpecs) {\n         if (kind == Kind.INTERFACE) {\n-          requireExactlyOneOf(methodSpec.modifiers, Modifier.ABSTRACT, Modifier.STATIC,\n-              Modifier.DEFAULT);\n           requireExactlyOneOf(methodSpec.modifiers, Modifier.PUBLIC, Modifier.PRIVATE);\n+          if (methodSpec.modifiers.contains(Modifier.PRIVATE)) {\n+            checkState(!methodSpec.hasModifier(Modifier.DEFAULT),\n+                \"%s %s.%s cannot be private and default\", kind, name, methodSpec.name);\n+            checkState(!methodSpec.hasModifier(Modifier.ABSTRACT),\n+                \"%s %s.%s cannot be private and abstract\", kind, name, methodSpec.name);\n+          } else {\n+            requireExactlyOneOf(methodSpec.modifiers, Modifier.ABSTRACT, Modifier.STATIC,\n+                Modifier.DEFAULT);\n+          }\n         } else if (kind == Kind.ANNOTATION) {\n           checkState(methodSpec.modifiers.equals(kind.implicitMethodModifiers),\n               \"%s %s.%s requires modifiers %s\",\n"
    },
    {
        "commit_hash": "6f3d36c155880af80f6754fa69eaf9d42dbeb640",
        "previous_commit_hash": "8d7a39b2dab980363104164134638cf762d94edb",
        "diff_stats": {
            "additions": 77,
            "deletions": 0
        },
        "diff_content": "@@ -904,6 +904,83 @@ public final class TypeSpecTest {\n     );\n   }\n \n+  @Test\n+  public void invalidInterfacePrivateMethods() {\n+    try {\n+      TypeSpec.interfaceBuilder(\"Tacos\")\n+          .addMethod(MethodSpec.methodBuilder(\"test\")\n+              .addModifiers(Modifier.PRIVATE, Modifier.DEFAULT)\n+              .returns(int.class)\n+              .addCode(CodeBlock.builder().addStatement(\"return 0\").build())\n+              .build())\n+          .build();\n+      fail();\n+    } catch (IllegalStateException expected) {\n+    }\n+\n+    try {\n+      TypeSpec.interfaceBuilder(\"Tacos\")\n+          .addMethod(MethodSpec.methodBuilder(\"test\")\n+              .addModifiers(Modifier.PRIVATE, Modifier.ABSTRACT)\n+              .returns(int.class)\n+              .build())\n+          .build();\n+      fail();\n+    } catch (IllegalStateException expected) {\n+    }\n+\n+    try {\n+      TypeSpec.interfaceBuilder(\"Tacos\")\n+          .addMethod(MethodSpec.methodBuilder(\"test\")\n+              .addModifiers(Modifier.PRIVATE, Modifier.PUBLIC)\n+              .returns(int.class)\n+              .addCode(CodeBlock.builder().addStatement(\"return 0\").build())\n+              .build())\n+          .build();\n+      fail();\n+    } catch (IllegalArgumentException expected) {\n+    }\n+  }\n+\n+  @Test\n+  public void interfacePrivateMethods() {\n+    TypeSpec bar = TypeSpec.interfaceBuilder(\"Tacos\")\n+        .addMethod(MethodSpec.methodBuilder(\"test\")\n+            .addModifiers(Modifier.PRIVATE)\n+            .returns(int.class)\n+            .addCode(CodeBlock.builder().addStatement(\"return 0\").build())\n+            .build())\n+        .build();\n+\n+    assertThat(toString(bar)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"interface Tacos {\\n\"\n+        + \"  private int test() {\\n\"\n+        + \"    return 0;\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\"\n+    );\n+\n+    bar = TypeSpec.interfaceBuilder(\"Tacos\")\n+        .addMethod(MethodSpec.methodBuilder(\"test\")\n+            .addModifiers(Modifier.PRIVATE, Modifier.STATIC)\n+            .returns(int.class)\n+            .addCode(CodeBlock.builder().addStatement(\"return 0\").build())\n+            .build())\n+        .build();\n+\n+    assertThat(toString(bar)).isEqualTo(\"\"\n+        + \"package com.squareup.tacos;\\n\"\n+        + \"\\n\"\n+        + \"interface Tacos {\\n\"\n+        + \"  private static int test() {\\n\"\n+        + \"    return 0;\\n\"\n+        + \"  }\\n\"\n+        + \"}\\n\"\n+    );\n+  }\n+\n   @Test public void referencedAndDeclaredSimpleNamesConflict() throws Exception {\n     FieldSpec internalTop = FieldSpec.builder(\n         ClassName.get(tacosPackage, \"Top\"), \"internalTop\").build();\n"
    },
    {
        "commit_hash": "8d619f1dbc2fac3e003d700034c01b70e302e1c5",
        "previous_commit_hash": "8d7a39b2dab980363104164134638cf762d94edb",
        "diff_stats": {
            "additions": 0,
            "deletions": 26
        },
        "diff_content": "@@ -1,26 +0,0 @@\n-#!/bin/bash\n-#\n-# Deploy a jar, source jar, and javadoc jar to Sonatype's snapshot repo.\n-#\n-# Adapted from https://coderwall.com/p/9b_lfq and\n-# https://benlimmer.com/2013/12/26/automatically-publish-javadoc-to-gh-pages-with-travis-ci/\n-\n-SLUG=\"square/javapoet\"\n-JDK=\"openjdk8\"\n-BRANCH=\"master\"\n-\n-set -e\n-\n-if [ \"$TRAVIS_REPO_SLUG\" != \"$SLUG\" ]; then\n-  echo \"Skipping snapshot deployment: wrong repository. Expected '$SLUG' but was '$TRAVIS_REPO_SLUG'.\"\n-elif [ \"$TRAVIS_JDK_VERSION\" != \"$JDK\" ]; then\n-  echo \"Skipping snapshot deployment: wrong JDK. Expected '$JDK' but was '$TRAVIS_JDK_VERSION'.\"\n-elif [ \"$TRAVIS_PULL_REQUEST\" != \"false\" ]; then\n-  echo \"Skipping snapshot deployment: was pull request.\"\n-elif [ \"$TRAVIS_BRANCH\" != \"$BRANCH\" ]; then\n-  echo \"Skipping snapshot deployment: wrong branch. Expected '$BRANCH' but was '$TRAVIS_BRANCH'.\"\n-else\n-  echo \"Deploying snapshot...\"\n-  mvn clean source:jar javadoc:jar deploy --settings=\".buildscript/settings.xml\" -Dmaven.test.skip=true\n-  echo \"Snapshot deployed!\"\n-fi\n"
    },
    {
        "commit_hash": "8d619f1dbc2fac3e003d700034c01b70e302e1c5",
        "previous_commit_hash": "8d7a39b2dab980363104164134638cf762d94edb",
        "diff_stats": {
            "additions": 0,
            "deletions": 9
        },
        "diff_content": "@@ -1,9 +0,0 @@\n-<settings>\n-  <servers>\n-    <server>\n-      <id>sonatype-nexus-snapshots</id>\n-      <username>${env.CI_DEPLOY_USERNAME}</username>\n-      <password>${env.CI_DEPLOY_PASSWORD}</password>\n-    </server>\n-  </servers>\n-</settings>\n"
    },
    {
        "commit_hash": "8d619f1dbc2fac3e003d700034c01b70e302e1c5",
        "previous_commit_hash": "8d7a39b2dab980363104164134638cf762d94edb",
        "diff_stats": {
            "additions": 0,
            "deletions": 0
        },
        "diff_content": ""
    },
    {
        "commit_hash": "8d619f1dbc2fac3e003d700034c01b70e302e1c5",
        "previous_commit_hash": "8d7a39b2dab980363104164134638cf762d94edb",
        "diff_stats": {
            "additions": 34,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,34 @@\n+name: build\n+\n+on: [push, pull_request]\n+\n+jobs:\n+  jvm:\n+    runs-on: ubuntu-latest\n+\n+    strategy:\n+      fail-fast: false\n+      matrix:\n+        java-version:\n+          - 1.8\n+          - 9\n+          - 10\n+          # TODO:\n+          #- 11\n+          #- 12\n+          #- 13\n+          #- 14\n+          #- 15\n+          #- 16\n+\n+    steps:\n+      - uses: actions/checkout@v2\n+\n+      - uses: actions/setup-java@v1\n+        with:\n+          java-version: ${{ matrix.java-version }}\n+\n+      - run: mvn --no-transfer-progress verify source:jar javadoc:jar\n+\n+      - run: mvn --no-transfer-progress deploy --settings=\".github/workflows/settings.xml\" -Dmaven.test.skip=true\n+        if: ${{ github.ref == 'refs/heads/master' && github.repository == 'square/javapoet' && matrix.java-version == '1.8' }}\n"
    },
    {
        "commit_hash": "8d619f1dbc2fac3e003d700034c01b70e302e1c5",
        "previous_commit_hash": "8d7a39b2dab980363104164134638cf762d94edb",
        "diff_stats": {
            "additions": 9,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,9 @@\n+<settings>\n+  <servers>\n+    <server>\n+      <id>sonatype-nexus-snapshots</id>\n+      <username>${env.SONATYPE_DEPLOY_USERNAME}</username>\n+      <password>${env.SONATYPE_DEPLOY_PASSWORD}</password>\n+    </server>\n+  </servers>\n+</settings>\n"
    },
    {
        "commit_hash": "8d619f1dbc2fac3e003d700034c01b70e302e1c5",
        "previous_commit_hash": "8d7a39b2dab980363104164134638cf762d94edb",
        "diff_stats": {
            "additions": 0,
            "deletions": 30
        },
        "diff_content": "@@ -1,30 +0,0 @@\n-language: java\n-\n-matrix:\n-  include:\n-    - jdk: openjdk8\n-    - jdk: openjdk11\n-  allow_failures:\n-    - jdk: openjdk11\n-\n-before_install:\n-  - unset _JAVA_OPTIONS\n-\n-after_success:\n-  - .buildscript/deploy_snapshot.sh\n-\n-env:\n-  global:\n-    - secure: \"nkVNCk8H2orIZOmow0t+Qub1lFQCYpJgNZf17zYI5x0JVqQNCqkcTYYDHqzwkvkmixXFCrfYZQuXy7x2qg9zjCX+vmhlmiMWwe8dNa34OLTseuuR2irS0C8nRGRYxKM7EGenRZSqbFVUksKRm2iWnHKxtmCzeDaS7MoMit2wdUo=\"\n-    - secure: \"j8+hPaZnyM+UlOBYOEA96fPbVWbN6bMQ28SGQnFMwxo2axHi9ww9Au1N7002HzHnxX8iyesdWFBigArnEL8zKEoXH9Bmur0sn3Ys4bu72C3ozscP4cjXfYSHj8aVLp1EIMdQPDF7MkCccx9l7ONdsW0ltmdiVUtDxzqkH+63WLU=\"\n-\n-branches:\n-  except:\n-    - gh-pages\n-\n-notifications:\n-  email: false\n-\n-cache:\n-  directories:\n-    - $HOME/.m2\n"
    },
    {
        "commit_hash": "ed181db179bd76e801daac69a0f3b91cabbca9b8",
        "previous_commit_hash": "742af18b143dab63e757d9952c7773f60c1af841",
        "diff_stats": {
            "additions": 5,
            "deletions": 6
        },
        "diff_content": "@@ -263,6 +263,8 @@ public final class TypeSpec {\n       codeWriter.pushType(this);\n       codeWriter.indent();\n       boolean firstMember = true;\n+      boolean needsSeparator = kind == Kind.ENUM\n+              && (!fieldSpecs.isEmpty() || !methodSpecs.isEmpty() || !typeSpecs.isEmpty());\n       for (Iterator<Map.Entry<String, TypeSpec>> i = enumConstants.entrySet().iterator();\n           i.hasNext(); ) {\n         Map.Entry<String, TypeSpec> enumConstant = i.next();\n@@ -271,13 +273,13 @@ public final class TypeSpec {\n         firstMember = false;\n         if (i.hasNext()) {\n           codeWriter.emit(\",\\n\");\n-        } else if (!fieldSpecs.isEmpty() || !methodSpecs.isEmpty() || !typeSpecs.isEmpty()) {\n-          codeWriter.emit(\";\\n\");\n-        } else {\n+        } else if (!needsSeparator) {\n           codeWriter.emit(\"\\n\");\n         }\n       }\n \n+      if (needsSeparator) codeWriter.emit(\";\\n\");\n+\n       // Static fields.\n       for (FieldSpec fieldSpec : fieldSpecs) {\n         if (!fieldSpec.hasModifier(Modifier.STATIC)) continue;\n@@ -763,9 +765,6 @@ public final class TypeSpec {\n         }\n       }\n \n-      checkArgument(kind != Kind.ENUM || !enumConstants.isEmpty(),\n-          \"at least one enum constant is required for %s\", name);\n-\n       for (TypeName superinterface : superinterfaces) {\n         checkArgument(superinterface != null, \"superinterfaces contains null\");\n       }\n"
    },
    {
        "commit_hash": "ed181db179bd76e801daac69a0f3b91cabbca9b8",
        "previous_commit_hash": "742af18b143dab63e757d9952c7773f60c1af841",
        "diff_stats": {
            "additions": 13,
            "deletions": 7
        },
        "diff_content": "@@ -435,13 +435,19 @@ public final class TypeSpecTest {\n         + \"}\\n\");\n   }\n \n-  @Test public void enumConstantsRequired() throws Exception {\n-    try {\n-      TypeSpec.enumBuilder(\"Roshambo\")\n-          .build();\n-      fail();\n-    } catch (IllegalArgumentException expected) {\n-    }\n+  @Test public void noEnumConstants() throws Exception {\n+    TypeSpec roshambo = TypeSpec.enumBuilder(\"Roshambo\")\n+            .addField(String.class, \"NO_ENUM\", Modifier.STATIC)\n+            .build();\n+    assertThat(toString(roshambo)).isEqualTo(\"\"\n+            + \"package com.squareup.tacos;\\n\"\n+            + \"\\n\"\n+            + \"import java.lang.String;\\n\"\n+            + \"\\n\"\n+            + \"enum Roshambo {\\n\"\n+            + \"  ;\\n\"\n+            + \"  static String NO_ENUM;\\n\"\n+            + \"}\\n\");\n   }\n \n   @Test public void onlyEnumsMayHaveEnumConstants() throws Exception {\n"
    },
    {
        "commit_hash": "34bbe74168478c072a62b975983a196d64a6d03d",
        "previous_commit_hash": "395609730a1d5a4fc47296a3df5f91b39c4739d4",
        "diff_stats": {
            "additions": 2,
            "deletions": 1
        },
        "diff_content": "@@ -24,8 +24,9 @@ jobs:\n     steps:\n       - uses: actions/checkout@v2\n \n-      - uses: actions/setup-java@v1\n+      - uses: actions/setup-java@v2\n         with:\n+          distribution: 'zulu'\n           java-version: ${{ matrix.java-version }}\n \n       - run: mvn --no-transfer-progress verify source:jar javadoc:jar\n"
    },
    {
        "commit_hash": "c772d45d546b82362dc8053c223ac562edc58558",
        "previous_commit_hash": "88517888277e3e92cbbdd054228f7f0ff68a841c",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -10,7 +10,7 @@ jobs:\n       fail-fast: false\n       matrix:\n         java-version:\n-          - 1.8\n+          - 8\n           - 9\n           - 10\n           # TODO:\n@@ -32,4 +32,4 @@ jobs:\n       - run: mvn --no-transfer-progress verify source:jar javadoc:jar\n \n       - run: mvn --no-transfer-progress deploy --settings=\".github/workflows/settings.xml\" -Dmaven.test.skip=true\n-        if: ${{ github.ref == 'refs/heads/master' && github.repository == 'square/javapoet' && matrix.java-version == '1.8' }}\n+        if: ${{ github.ref == 'refs/heads/master' && github.repository == 'square/javapoet' && matrix.java-version == '8' }}\n"
    },
    {
        "commit_hash": "788256e2487fcc1dc1fd9bacf43d8fe1fed421f9",
        "previous_commit_hash": "333d6646202935061940882164b80e0324598b0c",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -23,7 +23,7 @@\n     <java.version>1.8</java.version>\n     <junit.version>4.13.1</junit.version>\n     <truth.version>0.39</truth.version>\n-    <compile-testing.version>0.15</compile-testing.version>\n+    <compile-testing.version>0.19</compile-testing.version>\n   </properties>\n \n   <scm>\n"
    },
    {
        "commit_hash": "2d0bfe5f68e7b1027f2644d01d8814e9bb2a9887",
        "previous_commit_hash": "333d6646202935061940882164b80e0324598b0c",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -78,7 +78,7 @@\n     <dependency>\n       <groupId>org.mockito</groupId>\n       <artifactId>mockito-core</artifactId>\n-      <version>2.13.0</version>\n+      <version>4.4.0</version>\n       <scope>test</scope>\n     </dependency>\n     <dependency>\n"
    },
    {
        "commit_hash": "1bd1e636c1ceb65250c0bafe52a84220eb89c543",
        "previous_commit_hash": "333d6646202935061940882164b80e0324598b0c",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -22,9 +22,9 @@ jobs:\n           #- 16\n \n     steps:\n-      - uses: actions/checkout@v2\n+      - uses: actions/checkout@v3\n \n-      - uses: actions/setup-java@v2\n+      - uses: actions/setup-java@v3\n         with:\n           distribution: 'zulu'\n           java-version: ${{ matrix.java-version }}\n"
    },
    {
        "commit_hash": "6adea7a00a3f94cfd8cbf4481fa0af045999ec72",
        "previous_commit_hash": "2555b622e1b88f94fe23cac1c8ae456f92d742be",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -94,7 +94,7 @@\n       <plugin>\n         <groupId>org.apache.maven.plugins</groupId>\n         <artifactId>maven-compiler-plugin</artifactId>\n-        <version>3.8.0</version>\n+        <version>3.10.1</version>\n         <configuration>\n           <compilerId>javac-with-errorprone</compilerId>\n           <forceJavacCompilerUse>true</forceJavacCompilerUse>\n"
    },
    {
        "commit_hash": "70ef9bdf9a72743746e2315d3bdf9b89c7990b29",
        "previous_commit_hash": "47e45db7ed1a76aa8dd749758e5f8ad20aa24272",
        "diff_stats": {
            "additions": 2,
            "deletions": 0
        },
        "diff_content": "@@ -42,6 +42,8 @@ import static com.squareup.javapoet.Util.checkNotNull;\n \n /** A generated annotation on a declaration. */\n public final class AnnotationSpec {\n+  public static final String VALUE = \"value\";\n+\n   public final TypeName type;\n   public final Map<String, List<CodeBlock>> members;\n \n"
    },
    {
        "commit_hash": "4c8817be63d6d736ad322aa9b0095571eca3e659",
        "previous_commit_hash": "70ef9bdf9a72743746e2315d3bdf9b89c7990b29",
        "diff_stats": {
            "additions": 10,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,10 @@\n+version: 2\n+updates:\n+  - package-ecosystem: \"maven\"\n+    directory: \"/\"\n+    schedule:\n+      interval: \"monthly\"\n+  - package-ecosystem: \"github-actions\"\n+    directory: \"/\"\n+    schedule:\n+      interval: \"monthly\"\n"
    },
    {
        "commit_hash": "72989aec54304bbbb4a85acd92fa7edfe8b7b796",
        "previous_commit_hash": "8f05fd7269374bb19d222117f986e62f4d0805c6",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -118,7 +118,7 @@\n       <plugin>\n         <groupId>org.apache.maven.plugins</groupId>\n         <artifactId>maven-checkstyle-plugin</artifactId>\n-        <version>2.17</version>\n+        <version>3.1.2</version>\n         <dependencies>\n           <dependency>\n             <groupId>com.puppycrawl.tools</groupId>\n"
    },
    {
        "commit_hash": "a1d485a7e17ca7ed266da2d647782e84aa82dba4",
        "previous_commit_hash": "8f05fd7269374bb19d222117f986e62f4d0805c6",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -22,7 +22,7 @@\n \n     <java.version>1.8</java.version>\n     <junit.version>4.13.1</junit.version>\n-    <truth.version>0.39</truth.version>\n+    <truth.version>1.1.3</truth.version>\n     <compile-testing.version>0.19</compile-testing.version>\n   </properties>\n \n"
    },
    {
        "commit_hash": "aa0170116cdf25ff0955458894204296548cb824",
        "previous_commit_hash": "8f05fd7269374bb19d222117f986e62f4d0805c6",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -144,7 +144,7 @@\n       <plugin>\n         <groupId>org.apache.maven.plugins</groupId>\n         <artifactId>maven-jar-plugin</artifactId>\n-        <version>3.0.2</version>\n+        <version>3.2.2</version>\n         <configuration>\n           <archive>\n             <manifestEntries>\n"
    },
    {
        "commit_hash": "f0cfed9bed3ffb31bbb11f8bb865ccce750b4c07",
        "previous_commit_hash": "17e79f6f1060116bf74b0e882135c368429e1479",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -21,7 +21,7 @@\n     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n \n     <java.version>1.8</java.version>\n-    <junit.version>4.13.1</junit.version>\n+    <junit.version>4.13.2</junit.version>\n     <truth.version>1.1.3</truth.version>\n     <compile-testing.version>0.19</compile-testing.version>\n   </properties>\n"
    },
    {
        "commit_hash": "06a5ed17a55bc097e774267f6b07869457f5f372",
        "previous_commit_hash": "17e79f6f1060116bf74b0e882135c368429e1479",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -78,7 +78,7 @@\n     <dependency>\n       <groupId>org.mockito</groupId>\n       <artifactId>mockito-core</artifactId>\n-      <version>4.4.0</version>\n+      <version>4.5.1</version>\n       <scope>test</scope>\n     </dependency>\n     <dependency>\n"
    },
    {
        "commit_hash": "5d416f32a33dd4b2c3440e665eac56f99ef4b385",
        "previous_commit_hash": "17e79f6f1060116bf74b0e882135c368429e1479",
        "diff_stats": {
            "additions": 3,
            "deletions": 3
        },
        "diff_content": "@@ -21,7 +21,7 @@\n     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n \n     <java.version>1.8</java.version>\n-    <junit.version>4.13.1</junit.version>\n+    <junit.version>4.13.2</junit.version>\n     <truth.version>1.1.3</truth.version>\n     <compile-testing.version>0.19</compile-testing.version>\n   </properties>\n@@ -72,13 +72,13 @@\n     <dependency>\n       <groupId>com.google.jimfs</groupId>\n       <artifactId>jimfs</artifactId>\n-      <version>1.1</version>\n+      <version>1.2</version>\n       <scope>test</scope>\n     </dependency>\n     <dependency>\n       <groupId>org.mockito</groupId>\n       <artifactId>mockito-core</artifactId>\n-      <version>4.4.0</version>\n+      <version>4.5.1</version>\n       <scope>test</scope>\n     </dependency>\n     <dependency>\n"
    },
    {
        "commit_hash": "956b4a9af32aae2d0560eb03ccc0efd81b144303",
        "previous_commit_hash": "86d478ba7c9c8aa815e05caec18e23a119519ca5",
        "diff_stats": {
            "additions": 6,
            "deletions": 0
        },
        "diff_content": "@@ -0,0 +1,6 @@\n+{\n+  \"$schema\": \"https://docs.renovatebot.com/renovate-schema.json\",\n+  \"extends\": [\n+    \"config:base\"\n+  ]\n+}\n"
    },
    {
        "commit_hash": "b7b10bfff25e15023d1979e9098ef810443ca6ab",
        "previous_commit_hash": "73ae3e7f357a7d1032316f6b2370b5a3cd5c993d",
        "diff_stats": {
            "additions": 0,
            "deletions": 10
        },
        "diff_content": "@@ -1,10 +0,0 @@\n-version: 2\n-updates:\n-  - package-ecosystem: \"maven\"\n-    directory: \"/\"\n-    schedule:\n-      interval: \"monthly\"\n-  - package-ecosystem: \"github-actions\"\n-    directory: \"/\"\n-    schedule:\n-      interval: \"monthly\"\n"
    },
    {
        "commit_hash": "cad985c7ad42d555ed9e541db9193017ac11087f",
        "previous_commit_hash": "e9ed3a8b0c8f9ecc5015636c33e3ab4462381d3f",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -118,7 +118,7 @@\n       <plugin>\n         <groupId>org.apache.maven.plugins</groupId>\n         <artifactId>maven-checkstyle-plugin</artifactId>\n-        <version>3.1.2</version>\n+        <version>3.2.1</version>\n         <dependencies>\n           <dependency>\n             <groupId>com.puppycrawl.tools</groupId>\n"
    },
    {
        "commit_hash": "4d202946e418ef2b4067371729ccaa998dbeb9f0",
        "previous_commit_hash": "8f6998992496ccc88122461dd020eb30800663b8",
        "diff_stats": {
            "additions": 3,
            "deletions": 19
        },
        "diff_content": "@@ -3,33 +3,17 @@ name: build\n on: [push, pull_request]\n \n jobs:\n-  jvm:\n+  build:\n     runs-on: ubuntu-latest\n-\n-    strategy:\n-      fail-fast: false\n-      matrix:\n-        java-version:\n-          - 8\n-          - 9\n-          - 10\n-          # TODO:\n-          #- 11\n-          #- 12\n-          #- 13\n-          #- 14\n-          #- 15\n-          #- 16\n-\n     steps:\n       - uses: actions/checkout@v3\n \n       - uses: actions/setup-java@v3\n         with:\n           distribution: 'zulu'\n-          java-version: ${{ matrix.java-version }}\n+          java-version: 8\n \n       - run: mvn --no-transfer-progress verify source:jar javadoc:jar\n \n       - run: mvn --no-transfer-progress deploy --settings=\".github/workflows/settings.xml\" -Dmaven.test.skip=true\n-        if: ${{ github.ref == 'refs/heads/master' && github.repository == 'square/javapoet' && matrix.java-version == '8' }}\n+        if: ${{ github.ref == 'refs/heads/master' && github.repository == 'square/javapoet' }}\n"
    },
    {
        "commit_hash": "4e0fb130cd47011692b00b0d75361d9b3744b1cb",
        "previous_commit_hash": "6d197e5c948bed1d348401320f490e331b8d7253",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -78,7 +78,7 @@\n     <dependency>\n       <groupId>org.mockito</groupId>\n       <artifactId>mockito-core</artifactId>\n-      <version>4.5.1</version>\n+      <version>4.11.0</version>\n       <scope>test</scope>\n     </dependency>\n     <dependency>\n"
    },
    {
        "commit_hash": "c492b99eb98b33dc955edb757926e8c6042e8c59",
        "previous_commit_hash": "8e5b3af6903410e35f2803aefdf704d4c77b36c5",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -144,7 +144,7 @@\n       <plugin>\n         <groupId>org.apache.maven.plugins</groupId>\n         <artifactId>maven-jar-plugin</artifactId>\n-        <version>3.2.2</version>\n+        <version>3.3.0</version>\n         <configuration>\n           <archive>\n             <manifestEntries>\n"
    },
    {
        "commit_hash": "2d33c7710973eed2139d37d141e40c0d178d0284",
        "previous_commit_hash": "912952ee987b7e2e770d25261334cba3e5a308f1",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -23,7 +23,7 @@\n     <java.version>1.8</java.version>\n     <junit.version>4.13.2</junit.version>\n     <truth.version>1.1.3</truth.version>\n-    <compile-testing.version>0.19</compile-testing.version>\n+    <compile-testing.version>0.21.0</compile-testing.version>\n   </properties>\n \n   <scm>\n"
    },
    {
        "commit_hash": "28ce6dc810625347f7472ef33ebfbdca9e07b087",
        "previous_commit_hash": "e4e324680a2c6bf8d9c667eabed58f4850b68255",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -94,7 +94,7 @@\n       <plugin>\n         <groupId>org.apache.maven.plugins</groupId>\n         <artifactId>maven-compiler-plugin</artifactId>\n-        <version>3.10.1</version>\n+        <version>3.11.0</version>\n         <configuration>\n           <compilerId>javac-with-errorprone</compilerId>\n           <forceJavacCompilerUse>true</forceJavacCompilerUse>\n"
    },
    {
        "commit_hash": "6a37b551e2bbc7463c2b284cea2d27ced61b435a",
        "previous_commit_hash": "53a6c3328982e39acadad480950a5f183f1b3d20",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -118,7 +118,7 @@\n       <plugin>\n         <groupId>org.apache.maven.plugins</groupId>\n         <artifactId>maven-checkstyle-plugin</artifactId>\n-        <version>3.2.1</version>\n+        <version>3.2.2</version>\n         <dependencies>\n           <dependency>\n             <groupId>com.puppycrawl.tools</groupId>\n"
    },
    {
        "commit_hash": "70d3466e1c096cf271f617f94018191efc26e91f",
        "previous_commit_hash": "e48d418880076d72fab1a11196321efe3600053c",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -118,7 +118,7 @@\n       <plugin>\n         <groupId>org.apache.maven.plugins</groupId>\n         <artifactId>maven-checkstyle-plugin</artifactId>\n-        <version>3.2.2</version>\n+        <version>3.3.0</version>\n         <dependencies>\n           <dependency>\n             <groupId>com.puppycrawl.tools</groupId>\n"
    },
    {
        "commit_hash": "142b5ecf285e0fb102fb015394fb1c1c17885b18",
        "previous_commit_hash": "0e11ccf64f4b8421f3a4d54f2bd952ab2c34c411",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -22,7 +22,7 @@\n \n     <java.version>1.8</java.version>\n     <junit.version>4.13.2</junit.version>\n-    <truth.version>1.1.3</truth.version>\n+    <truth.version>1.1.4</truth.version>\n     <compile-testing.version>0.21.0</compile-testing.version>\n   </properties>\n \n"
    },
    {
        "commit_hash": "2be1e7718e5265f1b877b99090423edf525f55a7",
        "previous_commit_hash": "361511a8b49d2dd0ded84dd5ddfa6780fb97fcfc",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -22,7 +22,7 @@\n \n     <java.version>1.8</java.version>\n     <junit.version>4.13.2</junit.version>\n-    <truth.version>1.1.4</truth.version>\n+    <truth.version>1.1.5</truth.version>\n     <compile-testing.version>0.21.0</compile-testing.version>\n   </properties>\n \n"
    },
    {
        "commit_hash": "3a053b7505efa8547ea0cb97c1a68038812e37a2",
        "previous_commit_hash": "190aaed71e427514e860e49b62b7ad9c07bd884b",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -72,7 +72,7 @@\n     <dependency>\n       <groupId>com.google.jimfs</groupId>\n       <artifactId>jimfs</artifactId>\n-      <version>1.2</version>\n+      <version>1.3.0</version>\n       <scope>test</scope>\n     </dependency>\n     <dependency>\n"
    },
    {
        "commit_hash": "f914783d5a93a2ccde3d0c6c272c4344d099ecd5",
        "previous_commit_hash": "ba4395e8dae03738a1768d7f6ee02e78fbf44faf",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@ jobs:\n   build:\n     runs-on: ubuntu-latest\n     steps:\n-      - uses: actions/checkout@v3\n+      - uses: actions/checkout@3df4ab11eba7bda6032a0b82a6bb43b11571feac # v4\n \n       - uses: actions/setup-java@v3\n         with:\n"
    },
    {
        "commit_hash": "44afd4876cebc49b571c58d8e0119b35b087f93e",
        "previous_commit_hash": "d2e4d285526ec1ef22eeb9fcc7595bfe3c4628cc",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -6,7 +6,7 @@ jobs:\n   build:\n     runs-on: ubuntu-latest\n     steps:\n-      - uses: actions/checkout@3df4ab11eba7bda6032a0b82a6bb43b11571feac # v4\n+      - uses: actions/checkout@v4\n \n       - uses: actions/setup-java@v3\n         with:\n"
    },
    {
        "commit_hash": "cadaa8a1768137f33393d02713f8e70abe0094ed",
        "previous_commit_hash": "44afd4876cebc49b571c58d8e0119b35b087f93e",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -118,7 +118,7 @@\n       <plugin>\n         <groupId>org.apache.maven.plugins</groupId>\n         <artifactId>maven-checkstyle-plugin</artifactId>\n-        <version>3.3.0</version>\n+        <version>3.3.1</version>\n         <dependencies>\n           <dependency>\n             <groupId>com.puppycrawl.tools</groupId>\n"
    },
    {
        "commit_hash": "d682f2013751d25725349d79b449870d0e77354c",
        "previous_commit_hash": "0d55218ae3b8c8d6fe84132b7867d8c12698ce5e",
        "diff_stats": {
            "additions": 37,
            "deletions": 28
        },
        "diff_content": "@@ -118,6 +118,9 @@ public class TypeName {\n   }\n \n   public TypeName withoutAnnotations() {\n+    if (annotations.isEmpty()) {\n+      return this;\n+    }\n     return new TypeName(keyword);\n   }\n \n@@ -144,14 +147,15 @@ public class TypeName {\n    * other types types including unboxed primitives and {@code java.lang.Void}.\n    */\n   public boolean isBoxedPrimitive() {\n-    return this.equals(BOXED_BOOLEAN)\n-        || this.equals(BOXED_BYTE)\n-        || this.equals(BOXED_SHORT)\n-        || this.equals(BOXED_INT)\n-        || this.equals(BOXED_LONG)\n-        || this.equals(BOXED_CHAR)\n-        || this.equals(BOXED_FLOAT)\n-        || this.equals(BOXED_DOUBLE);\n+    TypeName thisWithoutAnnotations = withoutAnnotations();\n+    return thisWithoutAnnotations.equals(BOXED_BOOLEAN)\n+        || thisWithoutAnnotations.equals(BOXED_BYTE)\n+        || thisWithoutAnnotations.equals(BOXED_SHORT)\n+        || thisWithoutAnnotations.equals(BOXED_INT)\n+        || thisWithoutAnnotations.equals(BOXED_LONG)\n+        || thisWithoutAnnotations.equals(BOXED_CHAR)\n+        || thisWithoutAnnotations.equals(BOXED_FLOAT)\n+        || thisWithoutAnnotations.equals(BOXED_DOUBLE);\n   }\n \n   /**\n@@ -160,16 +164,18 @@ public class TypeName {\n    */\n   public TypeName box() {\n     if (keyword == null) return this; // Doesn't need boxing.\n-    if (this == VOID) return BOXED_VOID;\n-    if (this == BOOLEAN) return BOXED_BOOLEAN;\n-    if (this == BYTE) return BOXED_BYTE;\n-    if (this == SHORT) return BOXED_SHORT;\n-    if (this == INT) return BOXED_INT;\n-    if (this == LONG) return BOXED_LONG;\n-    if (this == CHAR) return BOXED_CHAR;\n-    if (this == FLOAT) return BOXED_FLOAT;\n-    if (this == DOUBLE) return BOXED_DOUBLE;\n-    throw new AssertionError(keyword);\n+    TypeName boxed = null;\n+    if (keyword.equals(VOID.keyword)) boxed = BOXED_VOID;\n+    else if (keyword.equals(BOOLEAN.keyword)) boxed = BOXED_BOOLEAN;\n+    else if (keyword.equals(BYTE.keyword)) boxed = BOXED_BYTE;\n+    else if (keyword.equals(SHORT.keyword)) boxed = BOXED_SHORT;\n+    else if (keyword.equals(INT.keyword)) boxed = BOXED_INT;\n+    else if (keyword.equals(LONG.keyword)) boxed = BOXED_LONG;\n+    else if (keyword.equals(CHAR.keyword)) boxed = BOXED_CHAR;\n+    else if (keyword.equals(FLOAT.keyword)) boxed = BOXED_FLOAT;\n+    else if (keyword.equals(DOUBLE.keyword)) boxed = BOXED_DOUBLE;\n+    else throw new AssertionError(keyword);\n+    return annotations.isEmpty() ? boxed : boxed.annotated(annotations);\n   }\n \n   /**\n@@ -180,16 +186,19 @@ public class TypeName {\n    */\n   public TypeName unbox() {\n     if (keyword != null) return this; // Already unboxed.\n-    if (this.equals(BOXED_VOID)) return VOID;\n-    if (this.equals(BOXED_BOOLEAN)) return BOOLEAN;\n-    if (this.equals(BOXED_BYTE)) return BYTE;\n-    if (this.equals(BOXED_SHORT)) return SHORT;\n-    if (this.equals(BOXED_INT)) return INT;\n-    if (this.equals(BOXED_LONG)) return LONG;\n-    if (this.equals(BOXED_CHAR)) return CHAR;\n-    if (this.equals(BOXED_FLOAT)) return FLOAT;\n-    if (this.equals(BOXED_DOUBLE)) return DOUBLE;\n-    throw new UnsupportedOperationException(\"cannot unbox \" + this);\n+    TypeName thisWithoutAnnotations = withoutAnnotations();\n+    TypeName unboxed = null;\n+    if (thisWithoutAnnotations.equals(BOXED_VOID)) unboxed = VOID;\n+    else if (thisWithoutAnnotations.equals(BOXED_BOOLEAN)) unboxed = BOOLEAN;\n+    else if (thisWithoutAnnotations.equals(BOXED_BYTE)) unboxed = BYTE;\n+    else if (thisWithoutAnnotations.equals(BOXED_SHORT)) unboxed = SHORT;\n+    else if (thisWithoutAnnotations.equals(BOXED_INT)) unboxed = INT;\n+    else if (thisWithoutAnnotations.equals(BOXED_LONG)) unboxed = LONG;\n+    else if (thisWithoutAnnotations.equals(BOXED_CHAR)) unboxed = CHAR;\n+    else if (thisWithoutAnnotations.equals(BOXED_FLOAT)) unboxed = FLOAT;\n+    else if (thisWithoutAnnotations.equals(BOXED_DOUBLE)) unboxed = DOUBLE;\n+    else throw new UnsupportedOperationException(\"cannot unbox \" + this);\n+    return annotations.isEmpty() ? unboxed : unboxed.annotated(annotations);\n   }\n \n   @Override public final boolean equals(Object o) {\n"
    },
    {
        "commit_hash": "d682f2013751d25725349d79b449870d0e77354c",
        "previous_commit_hash": "0d55218ae3b8c8d6fe84132b7867d8c12698ce5e",
        "diff_stats": {
            "additions": 15,
            "deletions": 0
        },
        "diff_content": "@@ -17,6 +17,7 @@ package com.squareup.javapoet;\n \n import java.io.Serializable;\n import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n import java.util.Comparator;\n import java.util.List;\n import java.util.Set;\n@@ -30,6 +31,8 @@ import static org.junit.Assert.assertNotEquals;\n \n public class TypeNameTest {\n \n+  private static final AnnotationSpec ANNOTATION_SPEC = AnnotationSpec.builder(ClassName.OBJECT).build();\n+\n   protected <E extends Enum<E>> E generic(E[] values) {\n     return values[0];\n   }\n@@ -173,6 +176,18 @@ public class TypeNameTest {\n     assertThat(ClassName.get(\"java.lang\", \"String\").isBoxedPrimitive()).isFalse();\n     assertThat(TypeName.VOID.isBoxedPrimitive()).isFalse();\n     assertThat(ClassName.get(\"java.lang\", \"Void\").isBoxedPrimitive()).isFalse();\n+    assertThat(ClassName.get(\"java.lang\", \"Integer\")\n+            .annotated(ANNOTATION_SPEC).isBoxedPrimitive()).isTrue();\n+  }\n+\n+  @Test public void canBoxAnnotatedPrimitive() throws Exception {\n+    assertThat(TypeName.BOOLEAN.annotated(ANNOTATION_SPEC).box()).isEqualTo(\n+            ClassName.get(\"java.lang\", \"Boolean\").annotated(ANNOTATION_SPEC));\n+  }\n+\n+  @Test public void canUnboxAnnotatedPrimitive() throws Exception {\n+    assertThat(ClassName.get(\"java.lang\", \"Boolean\").annotated(ANNOTATION_SPEC)\n+            .unbox()).isEqualTo(TypeName.BOOLEAN.annotated(ANNOTATION_SPEC));\n   }\n \n   private void assertEqualsHashCodeAndToString(TypeName a, TypeName b) {\n"
    },
    {
        "commit_hash": "5dbdda8dea26fae855d65358cfa1de36190da485",
        "previous_commit_hash": "d682f2013751d25725349d79b449870d0e77354c",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -8,7 +8,7 @@ jobs:\n     steps:\n       - uses: actions/checkout@v4\n \n-      - uses: actions/setup-java@v3\n+      - uses: actions/setup-java@v4\n         with:\n           distribution: 'zulu'\n           java-version: 8\n"
    },
    {
        "commit_hash": "cce32be76c5657d587b8d7ed028f93b44d8d302e",
        "previous_commit_hash": "cbf5587d43d253d4804e0da8482e24df402fc3d0",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -94,7 +94,7 @@\n       <plugin>\n         <groupId>org.apache.maven.plugins</groupId>\n         <artifactId>maven-compiler-plugin</artifactId>\n-        <version>3.11.0</version>\n+        <version>3.12.0</version>\n         <configuration>\n           <compilerId>javac-with-errorprone</compilerId>\n           <forceJavacCompilerUse>true</forceJavacCompilerUse>\n"
    },
    {
        "commit_hash": "4f21543f4c9f24d552fe6ce6561fb411e82f9d53",
        "previous_commit_hash": "42c69cc9859c7558330c5190298df356fece11d8",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -22,7 +22,7 @@\n \n     <java.version>1.8</java.version>\n     <junit.version>4.13.2</junit.version>\n-    <truth.version>1.1.5</truth.version>\n+    <truth.version>1.2.0</truth.version>\n     <compile-testing.version>0.21.0</compile-testing.version>\n   </properties>\n \n"
    },
    {
        "commit_hash": "a24c125dd164436d9ec2a1e71822ef93a938d82a",
        "previous_commit_hash": "62eb8d2e81db857af70eb91d9f832960df21073e",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -94,7 +94,7 @@\n       <plugin>\n         <groupId>org.apache.maven.plugins</groupId>\n         <artifactId>maven-compiler-plugin</artifactId>\n-        <version>3.12.0</version>\n+        <version>3.12.1</version>\n         <configuration>\n           <compilerId>javac-with-errorprone</compilerId>\n           <forceJavacCompilerUse>true</forceJavacCompilerUse>\n"
    },
    {
        "commit_hash": "fa579e1b403315558abc0178cd84c31b5e02b37e",
        "previous_commit_hash": "aaebc488320bd11aab1a6248d6b8058a255c92df",
        "diff_stats": {
            "additions": 3,
            "deletions": 0
        },
        "diff_content": "@@ -232,6 +232,9 @@ public final class AnnotationSpec {\n       if (value instanceof Float) {\n         return addMember(memberName, \"$Lf\", value);\n       }\n+      if (value instanceof Long) {\n+        return addMember(memberName, \"$LL\", value);\n+      }\n       if (value instanceof Character) {\n         return addMember(memberName, \"'$L'\", characterLiteralWithoutSingleQuotes((char) value));\n       }\n"
    },
    {
        "commit_hash": "fa579e1b403315558abc0178cd84c31b5e02b37e",
        "previous_commit_hash": "aaebc488320bd11aab1a6248d6b8058a255c92df",
        "diff_stats": {
            "additions": 2,
            "deletions": 2
        },
        "diff_content": "@@ -59,7 +59,7 @@ public final class AnnotationSpecTest {\n \n     int c() default 7;\n \n-    long d() default 8;\n+    long d() default 12345678910L;\n \n     float e() default 9.0f;\n \n@@ -313,7 +313,7 @@ public final class AnnotationSpecTest {\n         + \"    a = 5,\\n\"\n         + \"    b = 6,\\n\"\n         + \"    c = 7,\\n\"\n-        + \"    d = 8,\\n\"\n+        + \"    d = 12345678910L,\\n\"\n         + \"    e = 9.0f,\\n\"\n         + \"    f = 11.1,\\n\"\n         + \"    g = {\\n\"\n"
    },
    {
        "commit_hash": "eb1828903395663db00e8bb5d9a98b6665f3f759",
        "previous_commit_hash": "c9925e48577e3e74b91eb737b2c2b3c22109cde8",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -22,7 +22,7 @@\n \n     <java.version>1.8</java.version>\n     <junit.version>4.13.2</junit.version>\n-    <truth.version>1.2.0</truth.version>\n+    <truth.version>1.3.0</truth.version>\n     <compile-testing.version>0.21.0</compile-testing.version>\n   </properties>\n \n"
    },
    {
        "commit_hash": "9029849de29d8f965f2b8e8a79865bb02cd1a2bc",
        "previous_commit_hash": "91e587ccdfedb49da61e52c802bdda9224455b21",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -22,7 +22,7 @@\n \n     <java.version>1.8</java.version>\n     <junit.version>4.13.2</junit.version>\n-    <truth.version>1.3.0</truth.version>\n+    <truth.version>1.4.0</truth.version>\n     <compile-testing.version>0.21.0</compile-testing.version>\n   </properties>\n \n"
    },
    {
        "commit_hash": "90bbceb3703a28eae617aff4fe13177146421eec",
        "previous_commit_hash": "06bc59971795638b010e51f4f04b6b7d1a42abbc",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -22,7 +22,7 @@\n \n     <java.version>1.8</java.version>\n     <junit.version>4.13.2</junit.version>\n-    <truth.version>1.4.0</truth.version>\n+    <truth.version>1.4.1</truth.version>\n     <compile-testing.version>0.21.0</compile-testing.version>\n   </properties>\n \n"
    },
    {
        "commit_hash": "c60b76b60958b245fb366c7bd10c1c54db6d38ac",
        "previous_commit_hash": "47def3e7d1c4b4f8f29a515bea419305f23e2ac8",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -22,7 +22,7 @@\n \n     <java.version>1.8</java.version>\n     <junit.version>4.13.2</junit.version>\n-    <truth.version>1.4.1</truth.version>\n+    <truth.version>1.4.2</truth.version>\n     <compile-testing.version>0.21.0</compile-testing.version>\n   </properties>\n \n"
    },
    {
        "commit_hash": "58d629f92345ad4fc9f15ba26b30e05d7e015572",
        "previous_commit_hash": "09093974bc673e7464b81a89ce0cfc2fdce588cf",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -144,7 +144,7 @@\n       <plugin>\n         <groupId>org.apache.maven.plugins</groupId>\n         <artifactId>maven-jar-plugin</artifactId>\n-        <version>3.3.0</version>\n+        <version>3.4.1</version>\n         <configuration>\n           <archive>\n             <manifestEntries>\n"
    },
    {
        "commit_hash": "91bdfde74ea877bb6b35a3f7090e79b7a3a980af",
        "previous_commit_hash": "63c473cef6ed558d09310f3077d29852a5bc2a19",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -144,7 +144,7 @@\n       <plugin>\n         <groupId>org.apache.maven.plugins</groupId>\n         <artifactId>maven-jar-plugin</artifactId>\n-        <version>3.4.1</version>\n+        <version>3.4.2</version>\n         <configuration>\n           <archive>\n             <manifestEntries>\n"
    },
    {
        "commit_hash": "b0ef58ffd45ca6fa41aa33d6010c78d8237788d0",
        "previous_commit_hash": "146e7d20d8e77440a8fcde14c6c8fd4cd59414ec",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -118,7 +118,7 @@\n       <plugin>\n         <groupId>org.apache.maven.plugins</groupId>\n         <artifactId>maven-checkstyle-plugin</artifactId>\n-        <version>3.3.1</version>\n+        <version>3.4.0</version>\n         <dependencies>\n           <dependency>\n             <groupId>com.puppycrawl.tools</groupId>\n"
    },
    {
        "commit_hash": "8d60c6277039b3f394782eba001ba9ea4841f810",
        "previous_commit_hash": "98bcd5463a8d80138b709e5f77ebcfe33fa8d3f1",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -22,7 +22,7 @@\n \n     <java.version>1.8</java.version>\n     <junit.version>4.13.2</junit.version>\n-    <truth.version>1.4.2</truth.version>\n+    <truth.version>1.4.3</truth.version>\n     <compile-testing.version>0.21.0</compile-testing.version>\n   </properties>\n \n"
    },
    {
        "commit_hash": "66953b8bf5b43e84fa775934808dee1f84575e62",
        "previous_commit_hash": "f27ad04c9e7de4ec7b207979cfd47ec1d878ca03",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -22,7 +22,7 @@\n \n     <java.version>1.8</java.version>\n     <junit.version>4.13.2</junit.version>\n-    <truth.version>1.4.3</truth.version>\n+    <truth.version>1.4.4</truth.version>\n     <compile-testing.version>0.21.0</compile-testing.version>\n   </properties>\n \n"
    },
    {
        "commit_hash": "4286e31f5bdb65b32d75a5ff5e11884ca055b00c",
        "previous_commit_hash": "05bb87bfacdf79a8a1e596fc851801235eb8c2ec",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -118,7 +118,7 @@\n       <plugin>\n         <groupId>org.apache.maven.plugins</groupId>\n         <artifactId>maven-checkstyle-plugin</artifactId>\n-        <version>3.4.0</version>\n+        <version>3.5.0</version>\n         <dependencies>\n           <dependency>\n             <groupId>com.puppycrawl.tools</groupId>\n"
    },
    {
        "commit_hash": "9d93c79b0995a41c24058884ec0295667349842f",
        "previous_commit_hash": "e7429cba4323e6e14d814b40833d9a9b4904cefb",
        "diff_stats": {
            "additions": 31,
            "deletions": 0
        },
        "diff_content": "@@ -8,6 +8,37 @@ with metadata files (e.g., database schemas, protocol formats). By generating co\n the need to write boilerplate while also keeping a single source of truth for the metadata.\n \n \n+Deprecated\n+----------\n+\n+As of 2020-10-10, Square's JavaPoet project is deprecated. We're proud of our work but we haven't\n+kept up on maintaining it.\n+\n+If you'd like an alternative that supports the latest Java language features, one option is\n+[Palantir's JavaPoet](https://github.com/palantir/javapoet).\n+\n+To switch to that project, you'll need new Maven coordinates:\n+\n+```diff\n+- javapoet = { module = \"com.squareup:javapoet\", version = \"1.13.0\" }\n++ javapoet = { module = \"com.palantir.javapoet:javapoet\", version.ref = \"javapoet\" }\n+```\n+\n+And new imports:\n+\n+```\n+sed -i \"\" \\\n+  's/com.squareup.javapoet.\\([A-Za-z]*\\)/com.palantir.javapoet.\\1/g' \\\n+  `find . -name \"*.kt\" -or -name \"*.java\"`\n+```\n+\n+And you might need to track some API changes where fields became functions:\n+\n+```\n+- javaFile.packageName\n++ javaFile.packageName()\n+```\n+\n ### Example\n \n Here's a (boring) `HelloWorld` class:\n"
    },
    {
        "commit_hash": "cdb1f2d0ce441d05c073e7ecfb8fe438f1487fe3",
        "previous_commit_hash": "9d93c79b0995a41c24058884ec0295667349842f",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -21,7 +21,7 @@ To switch to that project, you'll need new Maven coordinates:\n \n ```diff\n - javapoet = { module = \"com.squareup:javapoet\", version = \"1.13.0\" }\n-+ javapoet = { module = \"com.palantir.javapoet:javapoet\", version.ref = \"javapoet\" }\n++ javapoet = { module = \"com.palantir.javapoet:javapoet\", version = \"0.5.0\" }\n ```\n \n And new imports:\n"
    },
    {
        "commit_hash": "b9017a9503b76e11b4ad4c1a9f050e2d29112cb0",
        "previous_commit_hash": "a5ddb12d66f3ba2cc943b3f7444ac247081b5a0e",
        "diff_stats": {
            "additions": 1,
            "deletions": 1
        },
        "diff_content": "@@ -34,7 +34,7 @@ sed -i \"\" \\\n \n And you might need to track some API changes where fields became functions:\n \n-```\n+```diff\n - javaFile.packageName\n + javaFile.packageName()\n ```\n"
    }
]